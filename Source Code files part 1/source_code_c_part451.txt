CodedBlocks,cl
   js        IntraByDecree

  xor        ebx,ebx                     ; Avoid partial register stall.
   xor       ecx,ecx
  mov        cl,[edx].MBEdgeType         ; 1 left | 2 right | 4 top | 8 bottom
   pcmpeqd   mm7,mm7                     ; Init previous best SWD to huge.
  mov        bl,[edx].FirstMEState       ; Test for INTRA-BY-DECREE.
   sub       eax,ecx                     ; Negative iff should do heuristic ME
   ;                                     ; for this macroblock.
  test       bl,bl
   je        IntraByDecree

  sar        eax,31
   psrlq     mm7,2
  or         ebx,eax                     ; -1 if doing heuristic ME.
   mov       al,INTER1MV                 ; Speculate INTER, 1 motion vector.
  mov        [edx].BlockType,al
   psrld     mm7,14       ; mm7[32:63]:  Previous best SWD = 0x0000FFFF.
   ;                      ; mm7[ 0:31]:  Prev SWD that we diminish = 0x0003FFFF.
   ;                      ; Since we can't diminish it below 0x00020000, we
   ;                      ; won't take the short circuit exit from MblkEstQWA.

; At this point:
;  ebp -- PITCH
;  esi -- Address of upper left block of 0,0 ref area.
;  edi -- Address of upper left block of target.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- CurrSWDState, i.e. FirstMEState.
;  eax -- Scratch
;  mm7 -- Previous best SWD initialized to huge (0xFFFF, 0x3FFFF).
;  mm0-mm6 -- Scratch

;============================================================================
; Compute SWD for macroblock.

ComputeMBSWD:

;  Registers at this point:
;  ebp -- PITCH
;  esi -- Address of upper left block of candidate ref area.
;  edi -- Address of upper left block of target.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- CurrSWDState
;  eax -- Scratch
;  mm7 -- Previous best SWD.
;  mm0-mm6 -- Scratch
;

  lea        ecx,[ebp+ebp*4]       ; Get PITCH*5
   lea       eax,[ebp+ebp*2]       ; Get PITCH*3
  movq       mm0,[esi+PITCH*15]    ; FL A:  Ref MB, lower left block, line 15.
  psubw      mm0,[edi+PITCH*15]    ; FL B:  Diff for lower left block, line 15.
  movq       mm6,[esi+PITCH*15+8]  ; FR A
   psllw     mm0,8                 ; FL C:  Extract diffs for line 15 even pels.
  psubw      mm6,[edi+PITCH*15+8]  ; FR B
   pmaddwd   mm0,mm0               ; FL D:  Square of diffs for even pels.
  movq       mm1,[esi+PITCH*9]     ; 9L A
   psllw     mm6,8                 ; FR C
  psubw      mm1,[edi+PITCH*9]     ; 9L B
   pmaddwd   mm6,mm6               ; FR D
  movq       mm5,[esi+PITCH*9+8]   ; 9R A
   psllw     mm1,8                 ; 9L C
  psubw      mm5,[edi+PITCH*9+8]   ; 9R B
   pmaddwd   mm1,mm1               ; 9L D
  movq       mm2,[esi+eax*4]       ; CL a
   psllw     mm5,8                 ; 9R C
  psubw      mm2,[edi+eax*4]       ; CL b
   pmaddwd   mm5,mm5               ; 9R D
  movq       mm3,[esi+eax*4+8]     ; CR a
   pmaddwd   mm2,mm2               ; CL c:  Square of diffs for odd pels.
  psubw      mm3,[edi+eax*4+8]     ; CR b
   paddusw   mm0,mm1               ; LL +   Accumulate SWD for lower left block.
  movq       mm1,[esi+eax*1]       ; 3L A
   pmaddwd   mm3,mm3               ; CR c
  psubw      mm1,[edi+eax*1]       ; 3L B
   paddusw   mm6,mm5               ; LR +
  movq       mm5,[esi+eax*1+8]     ; 3R A
   psllw     mm1,8                 ; 3L C
  psubw      mm5,[edi+eax*1+8]     ; 3R B
   paddusw   mm0,mm2               ; LL +
  movq       mm2,[esi]             ; 0L a
   pmaddwd   mm1,mm1               ; 3L D
  psubw      mm2,[edi]             ; 0L b
   paddusw   mm6,mm3               ; LR +
  movq       mm3,[esi+8]           ; 0R a
   psllw     mm5,8                 ; 3R C
  psubw      mm3,[edi+8]           ; 0R b
   pmaddwd   mm5,mm5               ; 3R D
  movq       mm4,[esi+eax*2]       ; 6L a
   pmaddwd   mm2,mm2               ; 0L c
  psubw      mm4,[edi+eax*2]       ; 6L b
   pmaddwd   mm3,mm3               ; 0R c
  movq       PartSWDForLLBlk,mm0   ;       Stash SWD for lines 9,12,15, LL blk.
   paddusw   mm0,mm6               ;       Sum SWD for lines 9,12,15 LL and LR.
  movq       PartSWDForLRBlk,mm6   ;       Stash SWD for lines 9,12,15, LR blk.
   pmaddwd   mm4,mm4               ; 6L c
  movq       mm6,[esi+eax*2+8]     ; 6R a
   paddusw   mm1,mm2               ; UL +
  psubw      mm6,[edi+eax*2+8]     ; 6R b
   paddusw   mm5,mm3               ; UR +
  movq       mm2,[esi+ebp*1]       ; 1L A
   pmaddwd   mm6,mm6               ; 6R c
  psubw      mm2,[edi+ebp*1]       ; 1L B
   paddusw   mm1,mm4               ; UL +
  movq       mm3,[esi+ecx*1]       ; 5L A
   paddusw   mm0,mm1               ;       Sum partial SWD for LL, LR, and UL.
  psubw      mm3,[edi+ecx*1]       ; 5L B
   paddusw   mm5,mm6               ; UR +
  movq       mm6,[esi+ebp*4]       ; 4L a
   paddusw   mm0,mm5               ;       Sum partial SWD for all blocks.
  movq       PartSWDForURBlk,mm5   ;       Stash SWD for lines 0,3,6, UR blk.
   punpckldq mm5,mm0               ;       Get low sum into high bits.
  psubw      mm6,[edi+ebp*4]       ; 4L b
   paddusw   mm5,mm0               ;       Total up SWD for every third line.
  movq       mm0,[esi+ebp*2]       ; 2L a
   psrlq     mm5,47                ;       Position, and double.
  psubw      mm0,[edi+ebp*2]       ; 2L b
   pcmpgtd   mm5,mm7               ;       Is 2 * SWD for 6 lines > prev SWD?
  pmaddwd    mm0,mm0               ; 2L c
   psllw     mm2,8                 ; 1L C
  movdf      eax,mm5
   pmaddwd   mm2,mm2               ; 1L D
  test       eax,eax 
   jne       MblkEst_EarlyOut

  lea        eax,[ecx+ebp*2]       ; PITCH*7
   psllw     mm3,8                 ; 5L C
  paddusw    mm1,mm2               ; UL +
   pmaddwd   mm3,mm3               ; 5L D
  movq       mm5,[esi+eax*1]       ; 7L A
  psubw      mm5,[edi+eax*1]       ; 7L B
   pmaddwd   mm6,mm6               ; 4L c
  movq       mm2,[esi+PITCH*11+8]  ; BR A
   psllw     mm5,8                 ; 7L C
  psubw      mm2,[edi+PITCH*11+8]  ; BR B
   paddusw   mm1,mm3               ; UL +
  movq       mm3,[esi+PITCH*13+8]  ; DR A
   paddusw   mm1,mm0               ; UL +
  psubw      mm3,[edi+PITCH*13+8]  ; DR B
   pmaddwd   mm5,mm5               ; 7L D
  movq       mm0,[esi+ebp*8+8]     ; 8R a
   paddusw   mm1,mm6               ; UL +
  psubw      mm0,[edi+ebp*8+8]     ; 8R b
   psllw     mm2,8                 ; BR C
  movq       mm4,[esi+ecx*2+8]     ; AR a
   paddusw   mm1,mm5               ; UL +
  psubw      mm4,[edi+ecx*2+8]     ; AR b
   punpckldq mm6,mm1               ;      Get low SWD accum to hi order of mm6.
  movq       mm5,[esi+eax*2+8]     ; ER a
   paddusw   mm6,mm1               ;      mm6[48:63] is SWD for upper left blk.
  psubw      mm5,[edi+eax*2+8]     ; ER b
   psrlq     mm6,48                ;      mm6 is SWD for upper left block.
  psubusw    mm7,mm6               ;      Diminish prev best SWD by cand UL blk.
   pmaddwd   mm2,mm2               ; BR D
  pmaddwd    mm0,mm0               ; 8R c
   psllw     mm3,8                 ; DR C
  movq       mm1,[esi+ebp*1+8]     ; 1R A
   pmaddwd   mm3,mm3               ; DR D
  paddusw    mm2,PartSWDForLRBlk   ; LR +
   pmaddwd   mm4,mm4               ; AR c
  psubw      mm1,[edi+ebp*1+8]     ; 1R B
   paddusw   mm2,mm0               ; LR +
  movq       mm0,[esi+ecx*1+8]     ; 5R A
   pmaddwd   mm5,mm5               ; ER c
  psubw      mm0,[edi+ecx*1+8]     ; 5R B
   paddusw   mm2,mm3               ; LR +
  movq       mm3,[esi+eax*1+8]     ; 7R A
   paddusw   mm2,mm4               ; LR +
  paddusw    mm2,mm5               ; LR +
   psllw     mm1,8                 ; 1R C
  psubw      mm3,[edi+eax*1+8]     ; 7R B
   punpckldq mm5,mm2               ;      Get low SWD accum to hi order of mm5.
  paddusw    mm5,mm2               ;      mm5[48:63] is SWD for lower right blk.
   pmaddwd   mm1,mm1               ; 1R D
  movq       mm2,[esi+ebp*2+8]     ; 2R a
   psrlq     mm5,48                ;      mm5 is SWD for lower right block.
  psubusw    mm7,mm5               ;      Diminish prev best SWD by cand LR blk.
   punpckldq mm6,mm5               ;      mm6[0:31] UL SWD;  mm6[32:63] LR SWD.
  psubw      mm2,[edi+ebp*2+8]     ; 2R b
   psllw     mm0,8                 ; 5R C
  movq       mm5,[esi+ebp*4+8]     ; 4R a
   pmaddwd   mm0,mm0               ; 5R D
  psubw      mm5,[edi+ebp*4+8]     ; 4R b
   psllw     mm3,8                 ; 7R C
  paddusw    mm1,PartSWDForURBlk   ; UR +
   pmaddwd   mm3,mm3               ; 7R D
  paddusw    mm1,mm0               ; UR +
   pmaddwd   mm2,mm2               ; 2R c
  movq       mm0,[esi+PITCH*11]    ; BL A
   pmaddwd   mm5,mm5               ; 4R c
  psubw      mm0,[edi+PITCH*11]    ; BL B
   paddusw   mm1,mm3               ; UR +
  movq       mm3,[esi+ecx*2]       ; AL a
   paddusw   mm1,mm2               ; UR +
  psubw      mm3,[edi+ecx*2]       ; AL b
   paddusw   mm1,mm5               ; UR +
  pmaddwd    mm3,mm3               ; AL c
   psllw     mm0,8                 ; BL C
  movq       mm2,[esi+PITCH*13]    ; DL A
   pmaddwd   mm0,mm0               ; BL D
  psubw      mm2,[edi+PITCH*13]    ; DL B
   punpckldq mm5,mm1               ;      Get low SWD accum to hi order of mm5.
  movq       mm4,[esi+ebp*8]       ; 8L a
   paddusw   mm5,mm1               ;      mm5[48:63] is SWD for upper right blk.
  psubw      mm4,[edi+ebp*8]       ; 8L b
   psllw     mm2,8                 ; DL C
  movq       mm1,[esi+eax*2]       ; EL a
   pmaddwd   mm2,mm2               ; DL D
  psubw      mm1,[edi+eax*2]       ; EL b
   pmaddwd   mm4,mm4               ; 8L c
  paddusw    mm3,PartSWDForLLBlk   ; LL +
   pmaddwd   mm1,mm1               ; EL c
  paddusw    mm3,mm0               ; LL +
   psrlq     mm5,48                ;      mm5 is SWD for upper right block.
  paddusw    mm3,mm2               ; LL +
   psubusw   mm7,mm5               ;      Diminish prev best SWD by cand UR blk.
  paddusw    mm3,mm4               ; LL +
   movq      mm0,mm7
  paddusw    mm3,mm1               ; LL +
   psrlq     mm7,32	           ; Get original Best SWD
  punpckldq  mm1,mm3
   pxor      mm2,mm2
  paddusw    mm1,mm3
  psrlq      mm1,48
  punpckldq  mm5,mm1           ; mm5[32:63] SWD for LL.  mm5[0:31] SWD for UR.
   psubusw   mm0,mm1
  psubusw    mm7,mm0           ; BestSWD dim (BestSWD dim CandSWD) --> new best.
   pcmpeqd   mm2,mm0           ; [0:31] == 0 iff cand better, else -1.

;  Registers at this point:
;  ebp -- PITCH
;  edi -- Target MacroBlock Base Address.
;  esi -- Address of upper left block of candidate ref area.
;  edx -- MBlockActionStream
;  ebx -- CurrSWDState
;  mm7 -- New best SWD for macroblock.
;  mm6 -- [0:31] SWD for upper left;   [32:63] SWD for lower right.
;  mm5 -- [0:31] SWD for upper right;  [32:63] SWD for lower left.
;  mm2 -- [0:31] 0 if cand better, else -1.

  cmp        ebx,LASTINITIALMESTATE  ; Did we just do zero motion vector?
   jg        MEForNonZeroMVDone

  movdf      eax,mm7                 ; SWD for this candidate.
   punpckldq mm7,mm7                 ; Put new best in mm7[0:31] and mm7[32:63].
  test       ebx,ebx
   jns       ZeroMVDoneForNonHeuristicME

HeuristicME_EarlyOut:

  movq       mm0,EMVLimitsForThisMB  ; Speculate no extended motion vectors.
   pcmpeqb   mm1,mm1                 ; <FFFF FFFF FFFF FFFF>
  xor        ecx,ecx
   cmp       bl,-3
  mov        cl,[edx].MBEdgeType     ; 1 left | 2 right | 4 top | 8 bottom
   jle       HeuristicME_CaseSigMVDone_or_CaseAboveMVDone

  sub        eax,NONZEROMVDIFFERENTIAL
   inc       bl
  mov        ebx,DoExtendedMotionVectors  ; 7 iff doing extende MVs, else 0.
   jne       HeuristicME_CaseLeftMVDone

HeuristicME_Case0MVDone:

  movq       SWDULandLR,mm6
   pcmpeqb   mm4,mm4                 ; <FFFF FFFF FFFF FFFF>
  movq       SWDURandLL,mm5
   psllw     mm4,15                  ; <8000 8000 8000 8000>
  cmp        eax,ZEROVECTORTHRESHOLD-NONZEROMVDIFFERENTIAL
  ;                                  ; Compare 0-MV against ZeroVectorThreshold.
   jl        BelowZeroThresh         ; Jump if 0-MV is good enough.

  mov        SWDForNon0MVToBeat,eax
   and       ebx,ecx                 ; Elim flag for bottom row. 0 iff no ExtMV.
  mov        eax,BlockAbove[4]
   je        NotExtendedMVs          ; Jump if not doing extended MVs?

                                     ; Below:  A==left;  B==above;  C==above rt.
  movdt      mm3,ValidRemoteVectors[ebx*4]              ; <mask(A) (C) (B) (A)>
   movq      mm2,mm4                 ; <8000 8000 8000 8000>

IF SIZEOF T_MacroBlockActionDescr-128
**** error:  Due to assembler weakness, can't use spaces here, so SIZEOF
**** T_MacroBlockActionDescr is replaced by constant.  If assembly error
**** occurs, the constant has been changed, and the three instructions in
**** the next 10 lines have to change.
ENDIF
IF SIZEOF T_Blk-16
**** error:  Due to assembler weakness, can't use spaces here, so SIZEOF T_Blk
**** is replaced by constant.  If assembly error occurs, the constant has been
**** changed, and the three instructions in the next 10 lines have to change.
ENDIF
  movdt      mm0,[edx-128].BestFullPelMBMVs             ; <x    x    Av,h x   >
   punpcklbw mm3,mm3                                    ; mask for both MV parts
  movdt      mm1,[edx+eax-2*16+128].BestFullPelMBMVs    ; <x    x    Cv,h x   >
   psrlw     mm2,8                                      ; <0080 0080 0080 0080>
  por        mm4,mm2                                    ; <8080 ...> bias value.
   punpcklwd mm1,mm0                                    ; <Av,h Cv,h x    x   >
  punpcklwd  mm0,[edx+eax-2*16].BestFullPelMBMVs        ; <Bv,h Av,h x x >
   ;
  punpckhdq  mm0,mm1                 ; <Av,h Cv,h Bv,h Av,h>
   ;
  pand       mm0,mm3                 ; Set to 0 any off edge.
   and       ebx,4                   ; If zero, we're on the top edge.
  paddb      mm0,mm4                 ; <Av,h Cv,h Bv,h Av,h> biased
   je        @f                      ; If on top edge, cause LEFT to be taken.
  movq       mm1,mm0                 ; <Av,h Cv,h Bv,h Av,h>
   psrlq     mm0,16                  ; <x    Av,h Cv,h Bv,h>
  psubusb    mm0,mm1                 ; <x    floor(A-C) floor(C-B) floor(B-A)>
   ;
  paddb      mm0,mm1                 ; <x    max(A,C) max(C,B) max(B,A)>
   ;
  movq       mm1,mm0                 ; <x    max(A,C) max(C,B) max(B,A)>
   psrlq     mm0,16                  ; <x    x        max(A,C) max(C,B)>
  pxor       mm1,mm0                 ; Part of median calc.
   psrlq     mm0,16                  ; <x    x        x        max(A,C)>
  pxor       mm0,mm1                 ; <x x x median(A,B,C)> biased by +128.
   ;

@@:

  punpcklbw  mm0,mm0                 ; 2 copies of median predictor MVs.
   pcmpeqb   mm1,mm1
  punpcklwd  mm0,mm0                 ; 4 copies.  Will now calc the following:
  ;                                  ; [ 0: 7] -- HMV lower limit for sig search
  ;                                  ; [ 8:15] -- HMV lower limit
  ;                                  ; [16:23] -- HMV upper limit for sig search
  ;                                  ; [24:31] -- HMV upper limit
  ;                                  ; [32:39] -- VMV lower limit for sig search
  ;                                  ; [40:47] -- VMV lower limit
  ;                                  ; [48:55] -- VMV upper limit for sig search
  ;                                  ; [56:63] -- VMV upper limit
   ;
  psubusb    mm0,EMV_ClampLowerEnd[ecx*8-40]
   psllw     mm1,3                   ; <FF F8 FF F8 FF F8 FF F8> i.e.  Mask to
   ;                                 ; set sig srch range to mult of 8.
  paddusb    mm0,EMV_ClampUpperEnd[ecx*8-40]

  psubb      mm0,EMV_RestoreRange[ecx*8-40]

NotExtendedMVs:

  movq       SWD0MVURandLL,mm5
   pand      mm0,mm1                 ; Set sig search at multiples of four.
  movq       SWD0MVULandLR,mm6
   pcmpeqb   mm2,mm2                 ; Set cand as worse than 0MV, in case skip.
  movq       EMVLimitsForThisMB,mm0
  and        cl,1
   je        HeuristicME_SkipLeftMV

  mov        BestOfFourStartingPoints,esi
   mov       ebx,-2                  ; Indicate trying MV of MB to left.
  movsx      ecx,[edx-SIZEOF T_MacroBlockActionDescr].BestFullPelMBVMV
  movsx      eax,[edx-SIZEOF T_MacroBlockActionDescr].BestFullPelMBHMV

ClampHeurMECandidateToRange:

  movsx      esi,PB EMVLimitsForThisMB+5  ; VMV lower limit.
  cmp        ecx,esi
   jl        ClampVMV_1

  movsx      esi,PB EMVLimitsForThisMB+7  ; VMV upper limit.
  cmp        ecx,esi
   jle       @f

ClampVMV_1:

  mov        ecx,esi

@@:

  movsx      esi,PB EMVLimitsForThisMB+1  ; HMV lower limit.
  cmp        eax,esi
   jl        ClampHMV_1

  movsx      esi,PB EMVLimitsForThisMB+3  ; HMV upper limit.
  cmp        eax,esi
   jle       @f

ClampHMV_1:

  mov        eax,esi

@@:

  sar        eax,1
   lea       ecx,[ecx+ecx*2]
IF PITCH-384
*** error:  The magic here assumes a pitch of 384.
ENDIF
  shl        ecx,6
   mov       esi,Addr0MVRef
  add        eax,ecx                      ; Clamped Linearized Motion Vector
   ;
  sub        eax,1
   jc        MblkEst_EarlyOut             ; Jump if Lin MV is zero.

  lea        esi,[esi+eax+1]              ; Candidate reference address.
   jmp       ComputeMBSWD

HeuristicME_SkipLeftMV:

  mov        BestOfFourStartingPoints,esi
   mov       cl,[edx].MBEdgeType   ; 1 left | 2 right | 4 top | 8 bottom

HeuristicME_CaseLeftMVDone:

  movdf      eax,mm2               ; eax == 0 iff cand better, else -1.
  mov        ebx,BlockAbove[4]
   and       cl,4
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   punpckldq mm7,mm7               ; Put new best in mm7[0:31] and mm7[32:63].
  movq       SWDURandLL[eax*8],mm5
   pcmpeqb   mm2,mm2               ; Set cand as worse than prev, in case skip.
  mov        BestOfFourStartingPoints[eax*4],esi
   je        HeuristicME_SkipAboveMV

  movsx      ecx,[edx+ebx-2*SIZEOF T_Blk].BestFullPelMBVMV
  movsx      eax,[edx+ebx-2*SIZEOF T_Blk].BestFullPelMBHMV
  mov        ebx,-3                  ; Indicate trying MV of MB above.
   jmp       ClampHeurMECandidateToRange

HeuristicME_CaseSigMVDone_or_CaseAboveMVDone:
HeuristicME_SkipAboveMV:

  movdf      eax,mm2               ; eax == 0 iff cand better, else -1.
  jne        HeuristicME_CaseSigMVDone

HeuristicME_CaseAboveMVDone:

  mov        cl,4
   lea       ebx,C0001000100010001
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   pxor      mm0,mm0
  movq       SWDURandLL[eax*8],mm5
   pxor      mm1,mm1
  mov        BestOfFourStartingPoints[eax*4],esi
   lea       esi,TargetSigContribForRowPairs
  movdf      BestMBFullPelSWD,mm7  ; Stash SWD for best full pel MB MV.
   pcmpeqb   mm7,mm7               ; W:<0xFFFF  0xFFFF  0xFFFF  0xFFFF>

; ebp -- Pitch
; edi -- Address of target macroblock.
; esi -- Address at which to store target macroblock's signature contributions.
; cl  -- Loop counter.
; mm0 -- Accumulator for target MB's sig contrib for first four even columns.
; mm1 -- Accumulator for target MB's sig contrib for last four even columns.

  movq       mm2,[edi]             ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5               ; W:<0xFFFF  0xFFFF  0xFFFF  0xFFFF>
  paddb      mm2,[edi+ebp*1]       ; B:<P07+P17 P06+P16 P05+P15 P04+P14 ...>
   psrlw     mm5,8                 ; W:<0x00FF  0x00FF  0x00FF  0x00FF>

@@:

  movq       mm3,[edi+ebp*2]       ; B:<P27 P26 P25 P24 P23 P22 P21 P20>
   movq      mm4,mm2               ; B:<P07+P17 P06+P16 P05+P15 P04+P14 ...>
  paddb      mm3,[edi+PITCH*3]     ; B:<P27+P37 P26+P36 P25+P35 P24+P34 ...>
   psrlw     mm2,8                 ; W:<P07+P17 P05+P15 P03+P13 P01+P11>
  pmaddwd    mm2,[ebx]             ; D:<P07+P17+P05+P15 P03+P13+P01+P11>
   movq      mm7,mm5               ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  pand       mm5,mm3               ; W:<P26+P36 P24+P34 P22+P32 P20+P30>
   psrlw     mm3,8                 ; W:<P27+P37 P25+P35 P23+P33 P21+P31>
  pmaddwd    mm3,[ebx]             ; D:<P27+P37+P25+P35 P23+P33+P21+P31>
   paddw     mm0,mm5               ; W:<sum(P*6) sum(P*4) sum(P*2) sum (P*0)>
  movq       mm5,[edi+ebp*2+8]     ; B:<P2F P2E P2D P2C P2B P2A P29 P28>
   pand      mm4,mm7               ; W:<P06+P16 P04+P14 P02+P12 P00+P10>
  paddb      mm5,[edi+PITCH*3+8]   ; B:<P2F+P3F P2E+P3E P2D+P3D P2C+P3C ...>
   paddw     mm0,mm4               ; W:<sum(P*6) sum(P*4) sum(P*2) sum (P*0)>
  movq       mm4,[edi+8]           ; B:<P0F P0E P0D P0C P0B P0A P09 P08>
   movq      mm6,mm7               ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  paddb      mm4,[edi+ebp*1+8]     ; B:<P0F+P1F P0E+P1E P0D+P1D P0C+P1C ...>
   pand      mm7,mm5               ; W:<P2E+P3E P2C+P3C P2A+P3A P28+P38>
  pand       mm6,mm4               ; W:<P0E+P1E P0C+P1C P0A+P1A P08+P18>
   psrlw     mm5,8                 ; W:<P2F+P3F P2D+P3D P2B+P3B P29+P39>
  pmaddwd    mm5,[ebx]             ; D:<P2F+P3F+P2D+P3D P2B+P3B+P29+P39>
   psrlw     mm4,8                 ; W:<P0F+P1F P0D+P1D P0B+P1B P09+P19>
  pmaddwd    mm4,[ebx]             ; D:<P0F+P1F+P0D+P1D P0B+P1B+P09+P19>
   paddw     mm1,mm7               ; W:<sum(P*E) sum(P*C) sum(P*A) sum (P*8)>
  paddw      mm1,mm6               ; W:<sum(P*E) sum(P*C) sum(P*A) sum (P*8)>
   lea       edi,[edi+ebp*4]       ; Advance input cursor
  paddw      mm3,mm5               ; D:<P2F+P3F+P2D+P3D+P27+P37+P25+P35
   ;                               ;    P2B+P3B+P29+P39+P23+P33+P21+P31>
   pcmpeqb   mm5,mm5               ; Next W:<0xFFFF  0xFFFF  0xFFFF  0xFFFF>
  paddw      mm4,mm2               ; D:<P0F+P1F+P0D+P1D+P07+P17+P05+P15
   ;                               ;    P0B+P1B+P09+P19+P03+P13+P01+P11>
   punpckldq mm7,mm3               ; D:<P0B+P1B+P09+P19+P03+P13+P01+P11 junk>
  paddw      mm7,mm3               ; [32:47]:<sum of odd pels of lines 0 and 1>
   punpckldq mm6,mm4               ; W:<P2B+P3B+P29+P39+P23+P33+P21+P31 junk>
  movq       mm2,[edi]             ; Next B:<P07 P06 P05 P04 P03 P02 P01 P00>
   paddw     mm6,mm4               ; [32:47]:<sum of odd pels of lines 2 and 3>
  paddb      mm2,[edi+ebp*1]       ; Next B:<P07+P17 P06+P16 P05+P15 ...>
   punpckhwd mm6,mm7               ; [0:31] W:<Line_0&1_odd  Line_2&3_odd>
  mov        MBlockActionStream,edx
   dec       cl
  movdf      [esi],mm6             ; Save W:<Line_0&1_odd  Line_2&3_odd>
   psrlw     mm5,8                 ; Next W:<0x00FF  0x00FF  0x00FF  0x00FF>
  lea        esi,[esi+4]           ; Advance output cursor
   jne       @b

; ebp -- Pitch
; edi -- Address of candidate reference MB's signature contribs.
; esi -- Address at which target MB's signature contribs were stored, plus 16.
; edx -- Scratch.
; ecx -- Count down number of lines of signatures to try.
; ebx -- Increment to get from end of one line of signatures to start of next.
; al  -- Count down number of signatures to try in a line.
; ah  -- Reinits counter of signatures to try in a line.
; mm0 -- Target MB's sig contrib for first four even columns.
; mm1 -- Target MB's sig contrib for last four even columns.
; mm2 -- Target MB's sig contrib for first four pairs of rows, odd columns.
; mm3 -- Amount and address of best signature seen so far.

IF PITCH-384
*** error:  The magic here assumes a pitch of 384.
ENDIF
  xor        eax,eax
   mov       ecx,TargetToSig_Debiased
  mov        al,EMVLimitsForThisMB+4 ; Lower vert lim for sig srch (half pels)
   xor       ebx,ebx
  add        edi,ecx
   mov       bl,EMVLimitsForThisMB+0 ; Lower horz lim for sig srch (half pels)
  shr        ebx,1
   lea       ecx,[eax+eax*2]
  shl        ecx,6
   add       edi,ebx
  add        edi,ecx
   xor       ecx,ecx
  add        ebx,ebx
   mov       cl,EMVLimitsForThisMB+6 ; Upper vert lim for sig srch (half pels)
  sub        ecx,eax
   mov       al,EMVLimitsForThisMB+2 ; Upper horz lim for sig srch (half pels)
  shr        ecx,3                   ; Number of lines of sigs to do, minus 1.
   sub       eax,ebx
  shr        eax,3                   ; Number of columns of sigs to do.
   lea       ebx,[ebp-1+080000000H]
  sub        ebx,eax                 ; 1/4th amt to add to move to next line.
   mov       ah,al
  inc        ah                      ; To reinit cntr for line.
  movq       mm2,[esi-16]
   pcmpeqd   mm3,mm3                 ; Set winning signature artificially high.
  movdt      mm4,[edi]
   psrld     mm3,2
  punpckldq  mm4,[edi+4]         ; ref sig contribs of left even cols.

TryNextSignature:

  movdt      mm5,[edi+8]
   psubw     mm4,mm0             ; diffs for sums of left even columns.
  punpckldq  mm5,[edi+12]        ; ref sig contribs of right even cols.
   pmaddwd   mm4,mm4             ; Squared differences.
  movdt      mm6,[edi+ebp*2]     ; Sums for first two pairs of rows.
   psubw     mm5,mm1             ; diffs for sums of right even columns.
  punpckldq  mm6,[edi+PITCH*6]   ; Sums for second two pairs of rows.
   pmaddwd   mm5,mm5             ; Squared differences.
  movdt      mm7,[edi+PITCH*10]  ; Sums for third two pairs of rows.
   psubw     mm6,mm2             ; Words: diffs for sums of first 4 pairs rows.
  punpckldq  mm7,[edi+PITCH*14]  ; Sums for last two pairs of rows.
   pmaddwd   mm6,mm6             ; Squared differences.
  psubw      mm7,[esi-8]         ; Words: diffs for sums of first 4 pairs rows.
   paddd     mm4,mm5             ; Accumulate squared differences.
  sub        al,1                ; Decrement line counter.
   pmaddwd   mm7,mm7             ; Squared differences.
  sbb        edx,edx             ; -1 if done with line, else 0.
   paddd     mm6,mm4             ; Accumulate squared differences.
  and        edx,ebx             ; 1/4 Amt to sub to goto next line, else 0.
   paddd     mm7,mm6             ; Accumulate squared differences.
  movdt      mm5,edi             ; Address of this signature
   punpckldq mm6,mm7             ; <low_order_accumulator junk>
  paddd      mm7,mm6             ; <full_signature_amt junk>
   psllq     mm5,32              ; <Addr_of_this_signature     0>
  lea        edi,[edi+edx*4+4]   ; advance signature position to next cand.
   punpckhdq mm5,mm7             ; <cand_signature_amt cand_signature_addr>
  sar        edx,31              ; -1 if done with line, else 0.
   pcmpgtd   mm7,mm3             ; <0xFFFFFFFF if cand not better    junk>
  movdt      mm4,[edi]
   punpckhdq mm7,mm7             ; <0xFFFFFFFFFFFFFFFF if cand not better>
  punpckldq  mm4,[edi+4]
   pand      mm3,mm7             ; 1st_best if cand not better, else 0.
  and        dl,ah               ; Num cols in a line if done with line, else 0.
   pandn     mm7,mm5             ; cand if better than 1st_best, else 0.
  add        al,dl               ; Reinit col count if finishing with line.
   por       mm3,mm7             ; Better of cand and 1st_best.
  sbb        ecx,0               ; Decrement line count if just finished line.
   jge       TryNextSignature

  movdf      ecx,mm3                ; Fetch address of best signature.
   pcmpeqb   mm2,mm2                ; Set cand as worse than prev, in case skip.
  mov        edi,TargetMacroBlockBaseAddr
   mov       ebx,-4                 ; Indicate trying MV of best signature.
  sub        ecx,edi
   mov       eax,SigToTarget
  movdt      mm7,BestMBFullPelSWD   ; Reload SWD for best full pel MB MV.
  lea        esi,[ecx+eax]          ; Linearized motion vector
   add       eax,ecx                ; Linearized motion vector
  sar        esi,8                  ; Full pel vert lin offset div 256.
   mov       edx,MBlockActionStream ; Reload pointer to MBA descriptor.
  shl        eax,25
   punpckldq mm7,mm7
  movsx      ecx,UnlinearizedVertMV[esi]  ; Get full pel vert MV component.
  sar        eax,24                 ; Full pel HMV.
   jmp       ClampHeurMECandidateToRange

HeuristicME_CaseSigMVDone:
HeuristicME_SkipSigMV:

  movdf      eax,mm2                        ; eax == 0 iff cand better, else -1.
   pcmpeqd   mm0,mm0                        ; Init previous best SWD to huge.
  mov        ecx,Addr0MVRef                 ; Start to calc linearized MV.
   mov       bh,EMVLimitsForThisMB+1        ; HMV lower limit.
  mov        BestOfFourStartingPoints[eax*4],esi
   add       bh,4
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   psrlq     mm0,2
  movq       SWDURandLL[eax*8],mm5
   psrld     mm0,14
  mov        eax,BestOfFourStartingPoints
   mov       bl,EMVLimitsForThisMB+5        ; VMV lower limit.
  mov        esi,eax
   sub       eax,ecx                        ; Linearized motion vector
  mov        ecx,eax                        ; Linearized motion vector
   add       al,al                          ; Full pel HMV.
  cmp        al,bh
   jl        ClampHMV_2

  mov        bh,EMVLimitsForThisMB+3        ; HMV upper limit
  sub        bh,4
  cmp        al,bh
   jle       NoClampHMV_2

ClampHMV_2:

  sar        ecx,8                          ; Full pel vert lin offset div 256.
   add       bl,4
  movzx      eax,bh
  movsx      ecx,PB UnlinearizedVertMV[ecx] ; Get full pel vert MV component.
  cmp        cl,bl
   jl        @f

  mov        bl,EMVLimitsForThisMB+7        ; VMV upper limit.
   movq      mm7,mm0
  sub        bl,4
  cmp        cl,bl
   jle       NoClampVMV_2

@@:

  movsx      ecx,bl
  movq       mm7,mm0

NoClampVMV_2:

  sar        eax,1
   lea       ecx,[ecx+ecx*2]
  shl        ecx,6
   mov       ebx,FIRST_HEURISTIC_EXHAUSTIVE_NEW_CTR  ; New state number.
  mov        esi,Addr0MVRef
   add       eax,ecx               ; Linearized motion vector.
  add        esi,eax
   jmp       ComputeMBSWD

NoClampHMV_2:

  sar        ecx,8                          ; Full pel vert lin offset div 256.
   add       bl,4
  mov        ah,bl
  movsx      ecx,PB UnlinearizedVertMV[ecx] ; Get full pel vert MV component.
  cmp        cl,ah
   jl        @f

  mov        ah,EMVLimitsForThisMB+7        ; VMV upper limit.
   lea       esi,[esi+ebp+1]
  sub        ah,4
   mov       ebx,FIRST_HEURISTIC_EXHAUSTIVE ; New state number.
  cmp        cl,ah
   jle       ComputeMBSWD

@@:

  movsx      ecx,ah
  movzx      eax,al
  sar        eax,1
   lea       ecx,[ecx+ecx*2]
  shl        ecx,6
   mov       ebx,FIRST_HEURISTIC_EXHAUSTIVE_NEW_CTR  ; New state number.
  mov        esi,Addr0MVRef
   add       eax,ecx               ; Linearized motion vector.
  add        esi,eax
   movq      mm7,mm0
  jmp        ComputeMBSWD


ZeroMVDoneForNonHeuristicME:

  movq       SWDULandLR,mm6
  movq       SWDURandLL,mm5
  cmp        eax,ZEROVECTORTHRESHOLD ; Compare 0-MV against ZeroVectorThreshold.
   jl        BelowZeroThresh         ; Jump if 0-MV is good enough.

  xor        ecx,ecx
   sub       eax,NONZEROMVDIFFERENTIAL
  mov        cl,StateEngineFirstRule[ebx]     ; MV adjustment.
   mov       bl,StateEngineFirstRule[ebx+10]  ; New state number.
  shl        ecx,11
   mov       SWDForNon0MVToBeat,eax
  movq       SWD0MVULandLR,mm6
  movq       SWD0MVURandLL,mm5
  lea        esi,[esi+ecx-PITCH*8]
   jmp       ComputeMBSWD

MEForNonZeroMVDone:

  movdf      eax,mm2           ; eax == 0 iff cand better, else -1.

MblkEst_EarlyOut:

  xor        ecx,ecx
   test      ebx,ebx
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   pcmpeqb   mm2,mm2                 ; Set cand as worse than 0MV.
  mov        cl,StateEngine[eax+ebx*4+1] ; Index of MV adjustment.
   js        HeuristicME_EarlyOut

  add        esi,ecx               ; Adjust ref addr for horz motion.
   mov       bl,StateEngine[eax+ebx*4+3] ; 0:239 -> New state number;
   ;                                     ; 240:255 -> flags which 1/2 pel to do.
  shr        ecx,4
   punpckldq mm7,mm7               ; Put new best in mm7[0:31] and mm7[32:63].
  movq       SWDURandLL[eax*8],mm5
   pxor      mm6,mm6               ; Speculatively zero to prep for half pel ME.
  add        esi,FullPelMotionVectorAdjustment[ecx*4] ; Adjust ref addr for VMV.
   cmp       bl,240                ; Terminal state?
  jb         ComputeMBSWD

  mov        eax,esi
   mov       ecx,Addr0MVRef               ; Start to calc linearized MV.
  sub        eax,ecx                      ; Linearized Motion Vector
   ;
  mov        ecx,eax
   ;
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  add        cl,cl
   ;
  mov        ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
IFDEF H261
ELSE
   mov       eax,DoHalfPelME ; 0 if not, -4 if so.
  test       eax,eax
   je        SkipHalfPelMBME

  cmp        cl,EMVLimitsForThisMB+1      ; Skip half pel ME if at edge of range
   jle       SkipHalfPelMBME

  cmp        cl,EMVLimitsForThisMB+3
   jge       SkipHalfPelMBME

  cmp        ch,EMVLimitsForThisMB+5
   jle       SkipHalfPelMBME

  cmp        ch,EMVLimitsForThisMB+7
   jge       SkipHalfPelMBME


; Registers:
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock
;  edx -- MBlockActionStream
;  ecx -- Nothing presently.
;  edi -- Address of target macroblock.
;  ebx -- 240 + Flags to indicate which half pel ME to do:
;         1 --> right;   2 --> left;   4 --> down;   8 --> up
;  eax -- Count from -4 to -1 for blocks of macroblock.
;  mm0:mm7 -- Scratch

  movdf      BestMBFullPelSWD,mm7   ; Stash SWD for best full pel MB MV.
   pxor      mm7,mm7                ; Prep accumulator for half pel ME.

  call       HalfPelMotionEstimation

  movdt      mm7,InvalidateBadHalfPelMVs[eax*4] ; Need to inflate SWDs for
  ;                                             ; MVs that go off frame edge.
  mov        eax,esi
   mov       ebx,Addr0MVRef               ; Start to calc linearized MV.
  sub        eax,ebx                      ; Linearized Motion Vector
   punpcklbw mm7,mm7                      ; Expand adjustment to words.
  mov        ecx,eax                      ; Linearized Motion Vector
   paddusw   mm7,mm3                      ; Now have SWDs for half pel MBME.
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  add        cl,cl
   movq      mm6,mm7
  mov        [edx].BestFullPelMBHMV,cl    ; Save HMV
   mov       ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
  movdf      eax,mm7                      ; eax[ 0:15] -- SWD for leftward ref.
  ;                                       ; eax[16:31] -- SWD for rightward ref.
   psrlq     mm6,32
  mov        [edx].BestFullPelMBVMV,ch    ; Save VMV
   mov       ebx,eax
  shr        eax,16                       ; eax -- SWD for leftward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for rightward ref.
  cmp        eax,ebx
   jg        MBME_RightBetterThanLeft

MBME_LeftBetterThanRight:

  cmp        eax,BestMBFullPelSWD
   jge       MBME_CtrIsBestHMV

MBME_LeftBestHMV:

  movdf      ebx,mm6                      ; ebx[ 0:15] -- SWD for downward ref.
  ;                                       ; ebx[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,eax
   mov       eax,ebx
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        MBME_LeftBestHMV_DownBetterThanUp

MBME_LeftBestHMV_UpBetterThanDown:

  cmp        eax,BestMBFullPelSWD
   jge       MBME_LeftIsBest

MBME_LeftBestHMV_UpBestVMV:

  sub        esi,PITCH+1                  ; Try ref 1/2 pel left and up
   mov       BestHalfPelVertSWD,eax
  mov        al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
   lea       esi,[esi+ebp*1+1]            ; Back to center.
  cmp        eax,ebx
   jle       MBME_UpBetterThanUpLeft

MBME_UpLeftBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_LeftIsBest

MBME_UpLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-PITCH-1]            ; Best is ref 1/2 pel left and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       MBME_HalfPelSearchDone

MBME_UpBetterThanUpLeft:

  cmp        eax,BestHalfPelHorzSWD
   jg        MBME_LeftIsBest

MBME_UpIsBest:

  mov        ebx,eax
   dec       ch                           ; Back up the vert MV one up.
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       MBME_HalfPelSearchDone

MBME_LeftBestHMV_DownBetterThanUp:

  cmp        ebx,BestMBFullPelSWD
   jge       MBME_LeftIsBest

MBME_LeftBestHMV_DownBestVMV:

  dec        esi                          ; Try ref 1/2 pel left and down
   mov       BestHalfPelVertSWD,ebx
  mov        al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
   inc       esi                          ; Back to center.
  cmp        eax,ebx
   jle       MBME_DownBetterThanDownLeft

MBME_DownLeftBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_LeftIsBest

MBME_DownLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left and down
  inc        ch                           ; Advance the vert MV one down.
   jmp       MBME_HalfPelSearchDone

MBME_DownBetterThanDownLeft:

  cmp        eax,BestHalfPelHorzSWD
   jle       MBME_DownIsBest

MBME_LeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left.
  mov        ebx,BestHalfPelHorzSWD
   jmp       MBME_HalfPelSearchDone

MBME_RightBetterThanLeft:

  cmp        ebx,BestMBFullPelSWD
   jge       MBME_CtrIsBestHMV

MBME_RightBestHMV:

  movdf      eax,mm6                      ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,ebx
   mov       ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        MBME_RightBestHMV_DownBetterThanUp

MBME_RightBestHMV_UpBetterThanDown:

  cmp        eax,BestMBFullPelSWD
   jge       MBME_RightIsBest

MBME_RightBestHMV_UpBestVMV:

  sub        esi,ebp                      ; Try ref 1/2 pel right and up
   mov       BestHalfPelVertSWD,eax
  mov        al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
   lea       esi,[esi+ebp*1]              ; Back to center.
  cmp        eax,ebx
   jle       MBME_UpBetterThanUpRight

MBME_UpRightBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_RightIsBest

MBME_UpRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   lea       eax,[esi-PITCH]              ; Best is ref 1/2 pel right and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       MBME_HalfPelSearchDone

MBME_UpBetterThanUpRight:

  cmp        eax,BestHalfPelHorzSWD
   jle       MBME_UpIsBest

MBME_RightIsBest:

  mov        ebx,BestHalfPelHorzSWD
   inc       cl                           ; Advance the horz MV one to right.
  mov        eax,esi
   jmp       MBME_HalfPelSearchDone

MBME_RightBestHMV_DownBetterThanUp:

  cmp        ebx,BestMBFullPelSWD
   jge       MBME_RightIsBest

MBME_RightBestHMV_DownBestVMV:

  mov        BestHalfPelVertSWD,ebx
   mov       al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
  cmp        eax,ebx
   jle       MBME_DownBetterThanDownRight

MBME_DownRightBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_RightIsBest

MBME_DownRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   mov       eax,esi
  inc        ch                           ; Advance vert MV one down.
   jmp       MBME_HalfPelSearchDone

MBME_DownBetterThanDownRight:

  cmp        eax,BestHalfPelHorzSWD
   jg        MBME_RightIsBest

MBME_DownIsBest:

  mov        ebx,eax
   inc       ch                           ; Advance vert MV one down.
  mov        eax,esi
   jmp       MBME_HalfPelSearchDone

MBME_CtrIsBestHMV:

  movdf      eax,mm6                      ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jge       MBME_CtrBestHMV_DownBetterThanUp

MBME_CtrBestHMV_UpBetterThanDown:

  mov        ebx,BestMBFullPelSWD
  cmp        eax,ebx
   jge       MBME_CenterIsBest

; Up is best.

  mov        ebx,eax
   dec       ch                           ; Back up the vert MV one up.
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       MBME_HalfPelSearchDone

MBME_CtrBestHMV_DownBetterThanUp:

  mov        eax,ebx
   mov       ebx,BestMBFullPelSWD
  cmp        eax,ebx
   jge       MBME_CenterIsBest

; Down is best.

  mov        ebx,eax
   inc       ch                           ; Advande the vert MV one down.
  mov        eax,esi
   jmp       MBME_HalfPelSearchDone

ENDIF

SkipHalfPelMBME:

  mov        [edx].BestFullPelMBHMV,cl    ; Save HMV
  movdf      ebx,mm7                      ; SWD for best full pel MB MV.
  mov        [edx].BestFullPelMBVMV,ch    ; Save VMV

MBME_CenterIsBest:

  mov        eax,esi

MBME_HalfPelSearchDone:

  mov        BestMBHalfPelSWD,ebx
   mov       BestMBHalfPelMV,cl           ; Save HMV
  mov        BestMBHalfPelRefAddr,eax
   mov       BestMBHalfPelMV+1,ch         ; Save VMV

IFDEF H261
ELSE ; H263
  mov        bl,EMVLimitsForThisMB+1     ; Lower limit comparison.
   mov       al,DoBlockLevelVectors      ; Are we doing block level MVs?
  dec        al
   jne       NoBlockMotionVectors

  mov        cl,[edx].CodedBlocks        ; Fetch coded block pattern.
   add       bl,2
  and        cl,080H
   jne       NoBlockMotionVectors        ; Skip Block ME if forced intra.

  mov        al,[edx].BestFullPelMBHMV   ; Compare full pel HMV against limits.
   mov       cl,EMVLimitsForThisMB+3
  cmp        al,bl
   jl        NoBlockMotionVectors

  mov        bl,EMVLimitsForThisMB+5
   sub       cl,2
  cmp        al,cl                       ; Upper limit comparison.
   jg        NoBlockMotionVectors

  mov        al,[edx].BestFullPelMBVMV   ; Compare full pel VMV against limits.
   add       bl,2
  mov        cl,EMVLimitsForThisMB+7
   cmp       al,bl
  mov        ebx,PD [edx].BestFullPelMBVMV-3
   jl        NoBlockMotionVectors

  sar        ebx,18
   sub       cl,2
  cmp        al,cl                       ; Upper limit comparison.
   jg        NoBlockMotionVectors

  mov        ecx,BestMBHalfPelSWD        ; Jump if SWD for MB MV < thresh.
IF PITCH-384
*** error:  The magic here assumes a pitch of 384.
ENDIF
   and       ebx,0FFFFFF80H              ; VMV*128
  cmp        ecx,BLOCKMOTIONTHRESHOLD
   jle       NoBlockMotionVectors

;==========================================================================
; Starting from the best full pel macroblock motion vector calculated above, we
; search for the best block motion vectors.
;
;  ebp -- PITCH
;  esi -- Address of ref block.
;  edi -- Address of target block.
;  edx -- Induction variable over luma blocks in MBlockAction Descriptor.
;  ecx -- Scratch
;  ebx -- CurrSWDState
;  eax -- Scratch
;  mm7 -- Best SWD for current block
;  mm6 -- unused.
;  mm5 -- Best SWD for right block of pair worked on by inner loop.
;  mm0-mm4 Scratch
;

  movq       mm0,HalfPelMBMESWDAccum+8
  movq       mm1,HalfPelMBMESWDAccum+16
   psubusw   mm7,mm0
  movq       mm2,HalfPelMBMESWDAccum+0
   psubusw   mm0,mm1
  movq       [edx].BlkY4.BlkLvlSWD+16,mm7
   psubusw   mm1,mm2
  movq       [edx].BlkY2.BlkLvlSWD+16,mm0
  movq       [edx].BlkY3.BlkLvlSWD+16,mm1
  movq       [edx].BlkY1.BlkLvlSWD+16,mm2

  movsx      eax,[edx].BestFullPelMBHMV
  sar        eax,1
   lea       ebx,[ebx+ebx*2]
  mov        esi,Addr0MVRef
   add       ebx,ebp
  mov        Addr0MVRefBlk,esi
   add       esi,eax
  lea        ecx,[ecx+ecx*2]               ; Best MBMV SWD times 3.
   add       esi,ebx                       ; Try V+1 first
  shr        ecx,2                         ; Best MBMV SWD * 3/4.
   mov       eax,SWDForNon0MVToBeat
  mov        BestBlockRefAddrVP1,esi       ; Stash BestBlockRefAddr
   sub       ecx,BLOCKMVDIFFERENTIAL       ; Best MBMV SWD * 3/4 - Differential.
  lea        eax,[eax+eax*2-BLOCKMVDIFFERENTIAL*4] ; Non0MBMVSWDToBeat*3-4*Diff.
   mov       LimitForSWDForBlkMV,ecx
  shr        eax,2                         ; Non0MBMVSWDToBeat * 3/4.
   mov       ebx,FIRSTBLOCKMESTATE
  cmp        eax,ecx
   jg        @f

  mov        LimitForSWDForBlkMV,eax
   mov       ecx,eax

@@:

  movdt      mm5,SWDURandLL     ; Get SWD for best MB level full pel MVs, blk 2.
  test       ecx,ecx
   jle       NoBlockMotionVectors
  movdt      mm7,SWDULandLR     ; Get SWD for best MB level full pel MVs, blk 1.
  movdf      SWDForBlock2Or4,mm5

;============================================================================
; Compute SWD for block.

DoBlkMEForNextBlk:
ComputeBlkSWD:

  movq       mm0,[esi+ebp*1]
  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.
  movq       mm1,[esi+PITCH*3] ; Ref MB, upper left block, Line 3.
   psllw     mm0,8             ; Extract diffs for line 1 even pels.
  psubw      mm1,[edi+PITCH*3] ; Diff for line 3.
   pmaddwd   mm0,mm0           ; Square of diffs for even pels of line 1.
  movq       mm2,[esi+PITCH*5]
   psllw     mm1,8
  psubw      mm2,[edi+PITCH*5]
   pmaddwd   mm1,mm1
  movq       mm3,[esi+PITCH*7]
   psllw     mm2,8
  psubw      mm3,[edi+PITCH*7]
   pmaddwd   mm2,mm2
  movq       mm4,[esi]         ; Ref MB, upper left blk, Line 0.
   psllw     mm3,8
  psubw      mm4,[edi]         ; Diff for line 0.
   paddusw   mm0,mm1           ; Accumulate SWD (lines 0 and 2).
  movq       mm1,[esi+ebp*2]
   pmaddwd   mm3,mm3
  psubw      mm1,[edi+ebp*2]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebp*4]
   pmaddwd   mm4,mm4           ; Square of diffs for odd pels of line 0.
  psubw      mm2,[edi+ebp*4]
   paddusw   mm0,mm3
  movq       mm3,[esi+PITCH*6]
   pmaddwd   mm1,mm1
  psubw      mm3,[edi+PITCH*6]
   pmaddwd   mm2,mm2
  paddusw    mm0,mm4
   pmaddwd   mm3,mm3
  paddusw    mm0,mm1
   ;
  paddusw    mm0,mm2
   ;
  paddusw    mm0,mm3
   ;
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   movq      mm4,mm7           ; Get original Best SWD for block

  paddusw    mm1,mm0           ; mm1[48:63] is SWD for block.
   pxor      mm2,mm2
  psrlq      mm1,48            ; mm1 is SWD for block.
   ;
  psubusw    mm4,mm1
   xor       ecx,ecx
  pcmpeqd    mm2,mm4           ; mm2[0:31] == 0 iff cand better, else -1.
   psubusw   mm7,mm4           ; BestSWD dim (BestSWD dim CandSWD) --> new best.
  ;
   ;
  movdf      eax,mm2           ; edi == 0 iff cand better, else -1.
   ;

;  Registers at this point:
;  ebp -- PITCH
;  esi -- Address of block of candidate ref area.
;  edi -- 0 iff candidate SWD better, else -1.
;  edx -- Induction variable over luma blocks in MBlockAction Descriptor.
;  ecx -- Scratch
;  ebx -- CurrSWDState.
;  eax -- CurrSWDState.
;  mm7 -- New best SWD for current block
;  mm6 -- Unused.

  movq       [edx].BlkY1.BlkLvlSWD,mm7   ; Save best blk level SWD.
   pxor      mm6,mm6                     ; Spec zero to prep for half pel ME.
  mov        cl,StateEngine[eax+ebx*4+1] ; Index of MV adjustment.
   mov       bl,StateEngine[eax+ebx*4+3] ; New state number; 255 means done.
  add        esi,ecx                     ; Adjust ref addr for horz motion.
   mov       eax,DoHalfPelME             ; 0 if not, -4 if so.
  shr        ecx,4
   cmp       bl,240                      ; Terminal state?
  jae        @f

  add        esi,FullPelMotionVectorAdjustment[ecx*4] ; Adjust ref addr for VMV.
   jmp       ComputeBlkSWD

@@:
  add        esi,FullPelMotionVectorAdjustment[ecx*4] ; Adjust ref addr for VMV.
   add       eax,4
  mov        ecx,esi
   jne       SkipHalfPelBlkME

; Registers:
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock
;  edx -- Induction variable over luma blocks in MBlockAction Descriptor.
;  ecx -- Copy of esi.
;  edi -- Address of target block.
;  ebx -- Scratch
;  eax -- Set to 0 to cause HalfPelMotionEstimation to quit after one block.
;  mm0:mm7 -- Scratch

  mov        ebx,BestBlockRefAddrVP1
   add       ecx,ebp
  cmp        ebx,ecx
   jne       FullPelBlkMEMovedFromCenter

  movdf      BestBlkFullPelSWD,mm7        ; Stash SWD for best full pel MB MV.
  movq       mm3,[edx].BlkY1.BlkLvlSWD+16 ; SWDs: H+1, H-1, V+1, V-1.
  jmp        FullPelBlkMEDidNotMoveFromCenter

FullPelBlkMEMovedFromCenter:

  movdf      BestBlkFullPelSWD,mm7   ; Stash SWD for best full pel MB MV.
   pxor      mm7,mm7                 ; Prep accumulator for half pel ME.

  call       HalfPelMotionEstimation

  lea        esi,[esi+ebp*8+8]            ; Fix reference pointer.
   lea       edi,[edi+ebp*8+8]            ; Fix target pointer.

FullPelBlkMEDidNotMoveFromCenter:

  mov        eax,esi
   mov       ebx,Addr0MVRefBlk            ; Start to calc linearized MV.
  sub        ecx,ebx                      ; Linearized Motion Vector
   sub       eax,ebx                      ; Linearized Motion Vector
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  movdf      ebx,mm3                      ; ebx[ 0:15] -- SWD for leftward ref.
  ;                                       ; ebx[16:31] -- SWD for rightward ref.
   psrlq     mm3,32
  mov        ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
   mov       eax,ebx
  shr        eax,16                       ; eax -- SWD for leftward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for rightward ref.
  cmp        eax,ebx
   jg        BlkME_RightBetterThanLeft

BlkME_LeftBetterThanRight:

  add        cl,cl
   mov       ebx,BestBlkFullPelSWD
  cmp        eax,ebx
   jge       BlkME_CtrIsBestHMV

BlkME_LeftBestHMV:

  movdf      ebx,mm3                      ; ebx[ 0:15] -- SWD for downward ref.
  ;                                       ; ebx[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,eax
   mov       eax,ebx
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        BlkME_LeftBestHMV_DownBetterThanUp

BlkME_LeftBestHMV_UpBetterThanDown:

  cmp        eax,BestBlkFullPelSWD
   jge       BlkME_LeftIsBest

BlkME_LeftBestHMV_UpBestVMV:

  sub        esi,PITCH+1                  ; Try ref 1/2 pel left and up
   mov       BestHalfPelVertSWD,eax
  mov        al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+PITCH*9+9]          ; Back to center.
   cmp       eax,ebx
  jle        BlkME_UpBetterThanUpLeft

BlkME_UpLeftBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_LeftIsBest

BlkME_UpLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-PITCH-1]            ; Best is ref 1/2 pel left and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       BlkME_HalfPelSearchDone

BlkME_UpBetterThanUpLeft:

  cmp        eax,BestHalfPelHorzSWD
   jg        BlkME_LeftIsBest

BlkME_UpIsBest:

  dec        ch                           ; Back up the vert MV one up.
   mov       ebx,eax
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       BlkME_HalfPelSearchDone

BlkME_LeftBestHMV_DownBetterThanUp:

  cmp        ebx,BestBlkFullPelSWD
   jge       BlkME_LeftIsBest

BlkME_LeftBestHMV_DownBestVMV:

  dec        esi                          ; Try ref 1/2 pel left and down
   mov       BestHalfPelVertSWD,ebx
  mov        al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+ebp*8+9]            ; Back to center.
   cmp       eax,ebx
  jle        BlkME_DownBetterThanDownLeft

BlkME_DownLeftBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_LeftIsBest

BlkME_DownLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left and down
  inc        ch                           ; Advance the vert MV one down.
   jmp       BlkME_HalfPelSearchDone

BlkME_DownBetterThanDownLeft:

  cmp        eax,BestHalfPelHorzSWD
   jle       BlkME_DownIsBest

BlkME_LeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left.
  mov        ebx,BestHalfPelHorzSWD
   jmp       BlkME_HalfPelSearchDone

BlkME_RightBetterThanLeft:

  add        cl,cl
   mov       eax,BestBlkFullPelSWD
  cmp        eax,ebx
   jle       BlkME_CtrIsBestHMV

BlkME_RightBestHMV:

  movdf      eax,mm3                    ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,ebx
   mov       ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        BlkME_RightBestHMV_DownBetterThanUp

BlkME_RightBestHMV_UpBetterThanDown:

  cmp        eax,BestBlkFullPelSWD
   jge       BlkME_RightIsBest

BlkME_RightBestHMV_UpBestVMV:

  sub        esi,ebp                      ; Try ref 1/2 pel right and up
   mov       BestHalfPelVertSWD,eax
  mov        al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+PITCH*9+8]          ; Back to center.
   cmp       eax,ebx
  jle        BlkME_UpBetterThanUpRight

BlkME_UpRightBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_RightIsBest

BlkME_UpRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   lea       eax,[esi-PITCH]              ; Best is ref 1/2 pel right and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       BlkME_HalfPelSearchDone

BlkME_UpBetterThanUpRight:

  cmp        eax,BestHalfPelHorzSWD
   jle       BlkME_UpIsBest

BlkME_RightIsBest:

  mov        ebx,BestHalfPelHorzSWD
   inc       cl                           ; Advance the horz MV one to right.
  mov        eax,esi
   jmp       BlkME_HalfPelSearchDone

BlkME_RightBestHMV_DownBetterThanUp:

  cmp        ebx,BestBlkFullPelSWD
   jge       BlkME_RightIsBest

BlkME_RightBestHMV_DownBestVMV:

  mov        BestHalfPelVertSWD,ebx
   mov       al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+ebp*8+8]            ; Back to center.
   cmp       eax,ebx
  jle        BlkME_DownBetterThanDownRight

BlkME_DownRightBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_RightIsBest

BlkME_DownRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   mov       eax,esi
  inc        ch                           ; Advance vert MV one down.
   jmp       BlkME_HalfPelSearchDone

BlkME_DownBetterThanDownRight:

  cmp        eax,BestHalfPelHorzSWD
   jg        BlkME_RightIsBest

BlkME_DownIsBest:

  inc        ch                           ; Advance vert MV one down.
   mov       ebx,eax
  mov        eax,esi
   jmp       BlkME_HalfPelSearchDone

BlkME_CtrIsBestHMV:

  movdf      eax,mm3                    ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jge       BlkME_CtrBestHMV_DownBetterThanUp

BlkME_CtrBestHMV_UpBetterThanDown:

  mov        ebx,BestBlkFullPelSWD
  cmp        eax,ebx
   jge       BlkME_CenterIsBest

; Up is best.

  mov        ebx,eax
   dec       ch                           ; Back up the vert MV one up.
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       BlkME_HalfPelSearchDone

BlkME_CtrBestHMV_DownBetterThanUp:

  mov        eax,ebx
   mov       ebx,BestBlkFullPelSWD
  cmp        eax,ebx
   jge       BlkME_CenterIsBest

; Down is best.

  mov        ebx,eax
   inc       ch                           ; Advande the vert MV one down.
  mov        eax,esi
   jmp       BlkME_HalfPelSearchDone

SkipHalfPelBlkME:

  mov        eax,esi
   mov       ebx,Addr0MVRefBlk            ; Start to calc linearized MV.
  sub        ecx,ebx                      ; Linearized Motion Vector
   sub       eax,ebx                      ; Linearized Motion Vector
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  add        cl,cl
   ;
  mov        ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
   ;
  movdf      ebx,mm7                      ; SWD for best full pel block MV.

BlkME_CenterIsBest:

  mov        eax,esi

BlkME_HalfPelSearchDone:

  mov        [edx].BlkY1.BlkLvlSWD,ebx
   mov       [edx].BlkY1.PastRef,eax
  mov        [edx].BlkY1.PHMV,cl        ; Save HMV
   mov       eax,LimitForSWDForBlkMV    ; Does block's SWD put us over limit?
  mov        [edx].BlkY1.PVMV,ch        ; Save VMV
   sub       eax,ebx
  jl         BlkEst_EarlyOut

  mov        LimitForSWDForBlkMV,eax ; Remember how much is left for other blks.
   mov       esi,BestBlockRefAddrVP1
  add        edi,8                      ; Move to blk 2 or 4, V+4.
   mov       ecx,Addr0MVRefBlk          ; Calc addr of 0MV ref for this blk.
  add        esi,8                      ; Move to blk 2 or 4, V+4.
   add       ecx,8
  mov        Addr0MVRefBlk,ecx
   add       edx,SIZEOF T_Blk           ; Increment to next block.
  test       dl,SIZEOF T_Blk
  movdt      mm7,SWDForBlock2Or4
  mov        ebx,FIRSTBLOCKMESTATE
   jne       DoBlkMEForNextBlk          ; If so, go do blk 2 or 4.

  lea        esi,[esi+ebp*8-8]          ; Move to blk 3
   lea       ecx,[ecx+ebp*8-16]
  mov        BestBlockRefAddrVP1,esi
   lea       edi,[edi+ebp*8-16]
  movdt      mm5,SWDULandLR+4           ; Get SWD for best MB level MVs, blk 4.
  movdt      mm7,SWDURandLL+4           ; Get SWD for best MB level MVs, blk 3.
  movdf      SWDForBlock2Or4,mm5
  test       dl,2*SIZEOF T_Blk          ; Just finishing blk 2?
  mov        Addr0MVRefBlk,ecx
   jne       DoBlkMEForNextBlk          ; If so, go do blk 3.

;==============================================================================
; Block motion vectors are best.

  mov        esi,[edx-4*SIZEOF T_Blk].BlkY1.BlkLvlSWD
   mov       edi,[edx-4*SIZEOF T_Blk].BlkY4.BlkLvlSWD
  mov        SWDULandLR,esi
   mov       SWDULandLR+4,edi
  mov        esi,[edx-4*SIZEOF T_Blk].BlkY3.BlkLvlSWD
   mov       edi,[edx-4*SIZEOF T_Blk].BlkY2.BlkLvlSWD
  mov        eax,[edx-4*SIZEOF T_Blk].BlkY1.MVs
   mov       ebx,[edx-4*SIZEOF T_Blk].BlkY2.MVs
  mov        ecx,eax
   xor       eax,ebx
  xor        ecx,[edx-4*SIZEOF T_Blk].BlkY3.MVs
   xor       ebx,[edx-4*SIZEOF T_Blk].BlkY4.MVs
  mov        SWDURandLL,edi
   or        eax,ebx
  sub        edx,4*SIZEOF T_Blk         ; Restore MacroBlockActionStream ptr.
   or        eax,ecx
  test       eax,0FFFFH
   mov       SWDURandLL+4,esi
  je         MotionVectorSettled

  mov        al,INTER4MV               ; Set type for MB to INTER-coded, 4 MVs.
  mov        [edx].BlockType,al
   jmp       MotionVectorSettled

BlkEst_EarlyOut:

  and        edx,-1-3*SIZEOF T_Blk
   mov       ecx,BestMBHalfPelSWD       ; Get total SWD for macroblock MV.

BlockMVNotBigEnoughGain:               ; Try MB-level motion vector.

  cmp        ecx,SWDForNon0MVToBeat
   jge       NonZeroMVNotBigEnoughGain

ENDIF ; H263

  mov        ebx,BestMBHalfPelMV
   mov       esi,BestMBHalfPelRefAddr         ; Reload BestMBHalfPelRefAddr

NonZeroMBLevelMVBest:

; Non-zero macroblock level motion vector is best.

  mov        [edx].BlkY1.MVs,ebx
   mov       [edx].BlkY2.MVs,ebx
  mov        [edx].BlkY3.MVs,ebx
   mov       [edx].BlkY4.MVs,ebx
  mov        [edx].BlkY1.PastRef,esi
   lea       ecx,[esi+ebp*8]
  mov        [edx].BlkY3.PastRef,ecx
   add       esi,8
  mov        [edx].BlkY2.PastRef,esi
   add       ecx,8
  mov        [edx].BlkY4.PastRef,ecx
   jmp       MotionVectorSettled

NoBlockMotionVectors:

  mov        ecx,BestMBHalfPelSWD       ; Get total SWD for macroblock MV.
   mov       eax,SWDForNon0MVToBeat
  cmp        eax,ecx
   mov       ebx,BestMBHalfPelMV
  mov        esi,BestMBHalfPelRefAddr
   jge       NonZeroMBLevelMVBest

NonZeroMVNotBigEnoughGain:

  mov        esi,Addr0MVRef             ; 0-MV ref block.
  movq       mm6,SWD0MVULandLR
  movq       mm5,SWD0MVURandLL
  movq       SWDULandLR,mm6
  movq       SWDURandLL,mm5

BelowZeroThresh:

  mov        [edx].BlkY1.PastRef,esi   ; Save address of ref block, all blks.
   lea       eax,[esi+8]
  mov        [edx].BlkY2.PastRef,eax
   lea       eax,[esi+ebp*8]
  mov        [edx].BlkY3.PastRef,eax
   add       eax,8
  mov        [edx].BlkY4.PastRef,eax
   xor       eax,eax
  mov        [edx].BlkY1.MVs,eax       ; Set horz and vert MVs to 0 in all blks.
   mov       [edx].BlkY2.MVs,eax
  mov        [edx].BlkY3.MVs,eax
   mov       [edx].BestFullPelMBHMV,al
  mov        [edx].BlkY4.MVs,eax
   mov       [edx].BestFullPelMBVMV,al
  mov        BestMBHalfPelMV,eax


MotionVectorSettled:

IFDEF H261

;===============================================================================
; For H261, we've settled on the best motion vector.  Now we need to determine
; if spatial filtering should be done.
;
;  ebp -- PITCH
;  esi -- Address of block of ref area.
;  edi -- Address of spatially filtred block.
;  edx -- MBlockActionStream
;  ecx -- Loop counter.
;  ebx -- Address of constant 0x7F in all 8 bytes.
;  eax -- Scratch
;  mm7 -- Mask to extract bytes 0 and 7.  (High bit of bytes 1:6 must be off).
;  mm6 -- All bytes -1.
;  mm5 -- Mask to extract bytes 1:6 and clear bit 8 thereof.

  movdf      esi,mm7                 ; Restore non-SLF SWD for macroblock.
  cmp        esi,SpatialFiltThreshold
   jle       SkipSpatialFiltering

  mov        ecx,DoSpatialFiltering   ; Are we doing spatial filtering?
   mov       esi,[edx].BlkY1.PastRef
  test       cl,cl
   je        SkipSpatialFiltering

DoSpatialFilterForChroma:
DoSpatialFilterForLuma:

  movq       mm5,C7F7F7F7F7F7F7F7F   ; Mask to extract bytes 1:6.
  movdf      BestMBFullPelSWD,mm7    ; Stash SWD for best full pel MB MV.
   psllq     mm5,16
  psrlq      mm5,8
   pcmpeqb   mm7,mm7
  pxor       mm7,mm5                 ; Mask to extract bytes 0 and 7.
   mov       edi,SpatiallyFilteredMB
  lea        eax,[esi+ebp*4]
   lea       ebx,C7F7F7F7F7F7F7F7F ; Address of this useful constant.

SpatialFilterLoop:

  movq       mm0,[esi]      ; 0a: <P7 P6 P5 P4 P3 P2 P1 P0>
   pcmpeqb   mm6,mm6        ;     To add one to all bytes.
  movq       mm4,mm0        ; 0b: <P7 P6 P5 P4 P3 P2 P1 P0>
   psllq     mm0,16         ; 0c: <P5 P4 P3 P2 P1 P0  0  0>
  movq       mm3,[esi+ebp*1]; 1a
   paddb     mm0,mm4        ; 0d: <P7+P5 P6+P4 ... P3+P1 P2+P0 jnk  jnk >
  movq       mm1,mm3        ; 1b
   psrlq     mm0,9          ; 0e: <0  (P7+P5)/2 ... (P2+P0)/2 jnk>  (dirty)

SpatialFilterLoop_BlockToRight:

  pand       mm0,mm5        ; 0f: <0  (P7+P5)/2 ... (P2+P0)/2    0>  (clean)
   psllq     mm1,16         ; 1c
  paddb      mm0,mm4        ; 0g: <jnk   (P7+2P6+P5)/2 ...  (P2+2P1+P0)/2 jnk>
   paddb     mm1,mm3        ; 1d
  psubb      mm0,mm6        ; 0h: <jnk (P7+2P6+P5+2)/2 ... (P2+2P1+P0+2)/2 jnk>
   psrlq     mm1,9          ; 1e
  psrlq      mm0,1          ; 0i: <jnk (P7+2P6+P5+2)/4 ... (P2+2P1+P0+2)/2 jnk>
   pand      mm4,mm7        ; 0j: <P7  0  0  0  0  0  0 P0>
  pand       mm0,mm5        ; 0k: < 0 (P7+2P6+P5+2)/4 ... (P2+2P1+P0+2)/2  0>
   pand      mm1,mm5        ; 1f
  por        mm0,mm4        ; 0l: <P7 (P7+2P6+P5+2)/4 ... (P2+2P1+P0+2)/4 P0>
   paddb     mm1,mm3        ; 1g
  movq       mm2,[esi+ebp*2]; 2a
   psubb     mm1,mm6        ; 1h
  movq       [edi],mm0      ; 0m: Store line 0 of filtered block.  This is R0.
   movq      mm4,mm2        ; 2b
  psrlq      mm1,1          ; 1i
   pand      mm3,mm7        ; 1j
  pand       mm1,mm5        ; 1k
   psllq     mm2,16         ; 2c
  por        mm1,mm3        ; 1l: This is R1
   paddb     mm2,mm4        ; 2d
  psubb      mm1,mm6               ; 1A: R1+1
   psrlq     mm2,9                 ; 2e
  pand       mm2,mm5               ; 2f
   paddb     mm0,mm1               ; 1B: R0+R1+1
  paddb      mm2,mm4               ; 2g
   psrlq     mm0,1                 ; 1C: (R0+R1+1)/2  (dirty)
  pand       mm0,[ebx]             ; 1D: (R0+R1+1)/2  (clean)
   psubb     mm2,mm6               ; 2h
  psrlq      mm2,1                 ; 2i
   pand      mm4,mm7               ; 2j
  movq       mm3,[esi+PITCH*3]     ; 3a
   pand      mm2,mm5               ; 2k
  por        mm2,mm4               ; 2l:  This is R2.
   movq      mm4,mm3               ; 3b
  paddb      mm1,mm2               ; 1E & 2B: R1+R2+1
   psllq     mm3,16                ; 3c
  psrlq      mm1,1                 ; 1F & 2C: (R1+R2+1)/2  (dirty)
   paddb     mm3,mm4               ; 3d
  pand       mm1,[ebx]             ; 1G & 2D: (R1+R2+1)/2  (clean)
   psrlq     mm3,9                 ; 3e
  paddb      mm0,mm1               ; 1H:  (R0+2R1+R2+2)/2
   pand      mm3,mm5               ; 3f
  psrlq      mm0,1                 ; 1I:  (R0+2R1+R2+2)/4  (dirty)
   paddb     mm3,mm4               ; 3g
  pand       mm0,[ebx]             ; 1J:  (R0+2R1+R2+2)/4  (clean)
   psubb     mm3,mm6               ; 3h
  psrlq      mm3,1                 ; 3i
   pand      mm4,mm7               ; 3j
  movq       [edi+ebp*1],mm0       ; 1K: Store line 1 of filtered block.
   pand      mm3,mm5               ; 3k
  movq       mm0,[eax]             ; 4a
   por       mm3,mm4               ; 3l
  psubb      mm3,mm6               ; 3A: R3+1
   movq      mm4,mm0               ; 4b
  paddb      mm2,mm3               ; 2E & 3B: R2+R3+1
   psllq     mm0,16                ; 4c
  psrlq      mm2,1                 ; 2F & 3C: (R2+R3+1)/2  (dirty)
   paddb     mm0,mm4               ; 4d
  pand       mm2,[ebx]             ; 2G & 3D: (R2+R3+1)/2  (clean)
   psrlq     mm0,9                 ; 4e
  paddb      mm1,mm2               ; 2H:  (R1+2R2+R3+2)/2
   pand      mm0,mm5               ; 4f
  psrlq      mm1,1                 ; 2I:  (R1+2R2+R3+2)/4  (dirty)
   paddb     mm0,mm4               ; 4g
  pand       mm1,[ebx]             ; 2J:  (R1+2R2+R3+2)/4  (clean)
   psubb     mm0,mm6               ; 4h
  psrlq      mm0,1                 ; 4i
   pand      mm4,mm7               ; 4j
  movq       [edi+ebp*2],mm1       ; 2K: Store line 2 of filtered block.
   pand      mm0,mm5               ; 4k
  movq       mm1,[eax+ebp*1]       ; 5a
   por       mm0,mm4               ; 4l
  movq       mm4,mm1               ; 5b
   psllq     mm1,16                ; 5c
  paddb      mm3,mm0               ; 3E & 4B: R3+R4+1
   paddb     mm1,mm4               ; 5d
  add        esi,8
   psrlq     mm3,1                 ; 3F & 4C: (R3+R4+1)/2  (dirty)
  pand       mm3,[ebx]             ; 3G & 4D: (R3+R4+1)/2  (clean)
   psrlq     mm1,9                 ; 5e
  paddb      mm2,mm3               ; 3H:  (R2+2R3+R4+2)/2
   pand      mm1,mm5               ; 5f
  psrlq      mm2,1                 ; 3I:  (R2+2R3+R4+2)/4  (dirty)
   paddb     mm1,mm4               ; 5g
  pand       mm2,[ebx]             ; 3J:  (R2+2R3+R4+2)/4  (clean)
   psubb     mm1,mm6               ; 5h
  psrlq      mm1,1                 ; 5i
   pand      mm4,mm7               ; 5j
  movq       [edi+PITCH*3],mm2     ; 3K: Store line 3 of filtered block.
   pand      mm1,mm5               ; 5k
  movq       mm2,[eax+ebp*2]       ; 6a
   por       mm1,mm4               ; 5l
  psubb      mm1,mm6               ; 5A: R5+1
   movq      mm4,mm2               ; 6b
  paddb      mm0,mm1               ; 4E & 5B: R4+R5+1
   psllq     mm2,16                ; 6c
  psrlq      mm0,1                 ; 4F & 5C: (R4+R5+1)/2  (dirty)
   paddb     mm2,mm4               ; 6d
  pand       mm0,[ebx]             ; 4G & 5D: (R4+R5+1)/2  (clean)
   psrlq     mm2,9                 ; 6e
  paddb      mm3,mm0               ; 4H:  (R3+2R4+R5+2)/2
   pand      mm2,mm5               ; 6f
  psrlq      mm3,1                 ; 4I:  (R3+2R4+R5+2)/4  (dirty)
   paddb     mm2,mm4               ; 6g
  pand       mm3,[ebx]             ; 4J:  (R3+2R4+R5+2)/4  (clean)
   psubb     mm2,mm6               ; 6h
  psrlq      mm2,1                 ; 6i
   sub       cl,2                  ;     Loop control
  movq       [edi+ebp*4],mm3       ; 4K: Store line 4 of filtered block.
   pand      mm4,mm7               ; 6j
  movq       mm3,[eax+PITCH*3]     ; 7a
   pand      mm2,mm5               ; 6k
  por        mm2,mm4               ; 6l
   movq      mm4,mm3               ; 7b
  paddb      mm1,mm2               ; 5E & 6B: R5+R6+1
   psllq     mm3,16                ; 7c
  psrlq      mm1,1                 ; 5F & 6C: (R5+R6+1)/2  (dirty)
   paddb     mm3,mm4               ; 7d
  pand       mm1,[ebx]             ; 5G & 6D: (R5+R6+1)/2  (clean)
   psrlq     mm3,9                 ; 7e
  paddb      mm0,mm1               ; 5H:  (R4+2R5+R6+2)/2
   pand      mm3,mm5               ; 7f
  psrlq      mm0,1                 ; 5I:  (R4+2R5+R6+2)/4  (dirty)
   paddb     mm3,mm4               ; 7g
  pand       mm0,[ebx]             ; 5J:  (R4+2R5+R6+2)/4  (clean)
   psubb     mm3,mm6               ; 7h
  psrlq      mm3,1                 ; 7i
   pand      mm4,mm7               ; 7j
  movq       [edi+PITCH*5],mm0     ; 5K: Store line 5 of filtered block.
   pand      mm3,mm5               ; 7k
  psubb      mm2,mm6               ; 7A: R6+1
   por       mm3,mm4               ; 7l
  paddb      mm2,mm3               ; 6E: R6+R7+1
   lea       eax,[esi+ebp*4]
  movq       mm0,[esi]             ; 0a:  for next iteration
   psrlq     mm2,1                 ; 6F: (R6+R7+1)/2  (dirty)
  pand       mm2,[ebx]             ; 6G: (R6+R7+1)/2  (clean)
   movq      mm4,mm0               ; 0b:  for next iteration
  movq       [edi+PITCH*7],mm3     ; 7m: Store line 7 of filtered block.
   paddb     mm1,mm2               ; 6H: (R5+2R6+R7+2)/2
  lea        edi,[edi+8]           ;     Advance output cursor.
   psrlq     mm1,1                 ; 6I: (R5+2R6+R7+2)/4  (dirty)
  pand       mm1,[ebx]             ; 6J: (R5+2R6+R7+2)/4  (clean)
   psllq     mm0,16                ; 0c:  for next iteration
  movq       mm3,[esi+ebp*1]       ; 1a:  for next iteration
   paddb     mm0,mm4               ; 0d:  for next iteration
  movq       [edi+PITCH*6-8],mm1   ; 6K: Store line 6 of filtered block.
   movq      mm1,mm3               ; 1b:  for next iteration
  psrlq      mm0,9                 ; 0e:  for next iteration
   jg        SpatialFilterLoop_BlockToRight

  lea        esi,[esi+ebp*8-16]
   lea       eax,[eax+ebp*8-16]
  lea        edi,[edi+ebp*8-16]
   mov       cl,4
  jl         SpatialFilterLoop

SpatialFilterDone:

  mov        edi,TargetMacroBlockBaseAddr
   mov       esi,SpatiallyFilteredMB
  test       ch,ch
   jg        ReturnFromSpatialFilterForU

;  Registers at this point:
;  ebp -- PITCH
;  esi -- Address of upper left block of spatially filtered candidate ref area.
;  edi -- Address of upper left block of target.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- Scratch
;  eax -- Loop control
;  mm0-mm4 -- Scratch
;  mm5,mm6 -- SWD for each block
;  mm7 -- SWD for macroblock
;

  movq       mm0,[esi+ebp*1]
   pxor      mm7,mm7
  mov        al,3
   jl        ReturnFromSpatialFilterForV

ComputeSWDforSLFBlock:

  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.

ComputeSWDforSLFBlock_BlkToRight:

  movq       mm1,[esi+PITCH*3] ; Ref MB, Line 3.
   psllw     mm0,8             ; Extract diffs for line 1 even pels.
  psubw      mm1,[edi+PITCH*3] ; Diff for line 3.
   pmaddwd   mm0,mm0           ; Square of diffs for even pels of line 1.
  movq       mm2,[esi+PITCH*5]
   psllw     mm1,8
  psubw      mm2,[edi+PITCH*5]
   pmaddwd   mm1,mm1
  movq       mm3,[esi+PITCH*7]
   psllw     mm2,8
  psubw      mm3,[edi+PITCH*7]
   pmaddwd   mm2,mm2
  movq       mm4,[esi]         ; Ref MB, upper left blk, Line 0.
   psllw     mm3,8
  psubw      mm4,[edi]         ; Diff for line 0.
   paddusw   mm0,mm1           ; Accumulate SWD (lines 0 and 2).
  movq       mm1,[esi+ebp*2]
   pmaddwd   mm3,mm3
  psubw      mm1,[edi+ebp*2]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebp*4]
   pmaddwd   mm4,mm4           ; Square of diffs for odd pels of line 0.
  psubw      mm2,[edi+ebp*4]
   paddusw   mm0,mm3
  movq       mm3,[esi+PITCH*6]
   pmaddwd   mm1,mm1
  psubw      mm3,[edi+PITCH*6]
   pmaddwd   mm2,mm2
  paddusw    mm4,mm0
   pmaddwd   mm3,mm3
  paddusw    mm4,mm1
   add       esi,8
  paddusw    mm4,mm2
   add       edi,8
  movq       mm0,[esi+ebp*1]
   paddusw   mm4,mm3
  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.
   punpckldq mm1,mm4           ; Get low order SWD accum to high order of mm1.
  paddusw    mm1,mm4           ; mm1[48:63] is SWD for block.
   psllq     mm6,32            ; Shift previous block's SWD left.
  psrlq      mm1,48            ; mm1 is SWD for block.
   sub       al,2              ; Loop control.
  paddusw    mm7,mm1
   por       mm6,mm1           ; Save current block's SWD.
  movq       mm4,mm5
   jg        ComputeSWDforSLFBlock_BlkToRight

  movq       mm0,[esi+PITCH*9-16]
   movq      mm5,mm6
  lea        edi,[edi+ebp*8-16]
   lea       esi,[esi+ebp*8-16]
  mov        al,4
   jl        ComputeSWDforSLFBlock

  mov        ebx,BestMBFullPelSWD    ; Restore non-SLF SWD for macroblock.
   mov       eax,SpatialFiltDifferential
  sub        ebx,eax
   sub       edi,PITCH*16+16
  movdf      eax,mm7                 ; SLF SWD for macroblock.
  cmp        eax,ebx
   jge       SpatialFilterNotAsGood

  movdf      SWDULandLR+4,mm5
   psrlq     mm5,32
  movdf      SWDURandLL+4,mm5
  movdf      SWDURandLL,mm6
   psrlq     mm6,32
  movdf      SWDULandLR,mm6
  mov        al,INTERSLF
   mov       ebx,SpatiallyFilteredMB
  mov        [edx].BlockType,al
   sub       esi,PITCH*8-8
  mov        [edx].BlkY4.PastRef,esi
   mov       [edx].BlkY1.PastRef,ebx
  sub        esi,8
   add       ebx,8
  mov        [edx].BlkY3.PastRef,esi
   mov       [edx].BlkY2.PastRef,ebx

SkipSpatialFiltering:
SpatialFilterNotAsGood:
ENDIF ; H261

;===============================================================================
; We've settled on the motion vector that will be used if we do indeed code the
; macroblock with inter-coding.  We need to determine if some or all of the
; blocks can be forced as empty (copy).  If all the blocks can be forced
; empty, we force the whole macroblock to be empty.

  mov        esi,EMPTYTHRESHOLD         ; Get threshold for forcing block empty?
   mov       ebx,SWDULandLR             ; Get SWD for block 1.
  mov        al,[edx].CodedBlocks
   cmp       ebx,esi                    ; Is SWD > threshold?
  jg         @f

  and        al,0FEH                    ; If not, indicate block 1 is NOT coded.
   xor       ebx,ebx

@@:

  mov        ecx,SWDURandLL             ; Get SWD for block 2.
  cmp        ecx,esi
   jg        @f

  and        al,0FDH
   xor       ecx,ecx

@@:

  add        ebx,ecx
   mov       ecx,SWDURandLL+4           ; Get SWD for block 3.
  cmp        ecx,esi
   jg        @f

  and        al,0FBH
   xor       ecx,ecx

@@:

  add        ebx,ecx
   mov       ecx,SWDULandLR+4           ; Get SWD for block 4.
  cmp        ecx,esi
   jg        @f

  and        al,0F7H
   xor       ecx,ecx

@@:

  mov        [edx].CodedBlocks,al  ; Store coded block pattern.
   and       al,00FH
  add        ebx,ecx
   cmp       al,00FH               ; Are any blks marked empty?
  jne        InterBest             ; If some blks are empty, can't code as Intra

  mov        edi,TargetMacroBlockBaseAddr
   mov       [edx].SWD,ebx
  cmp        ebx,INTERCODINGTHRESHOLD  ; Is InterSWD below inter-coding thresh?
   jae       CalculateIntraSWD

InterBestX:

  mov        ebx,[edx].SWD

InterBest:

  mov        ecx,SWDTotal          ; Add to total for this macroblock class.
  add        ecx,ebx
IFDEF H261
  mov        SWDTotal,ecx
ELSE ;H263
   mov       bl,DoAdvancedPrediction
  mov        SWDTotal,ecx
   test      bl,bl
  jne        OBMCDifferencing
ENDIF

;============================================================================
; Perform differencing for the non-empty luma blocks of an Inter-coded
; macroblock.  This is the non-OBMC case;  i.e. Advanced Prediction is
; not selected.
;
;  ebp -- PITCH
;  esi -- Address of reference block.
;  edi -- Address of target block.
;  edx -- MBlockActionStream.  Used as cursor over luma blocks.
;  ecx -- Not in use.
;  ebx -- Scratch.  Used to test half pel MV resolution.
;  eax[0:3] -- Coded block pattern for luma blocks.

  mov        cl,INTER1MV
   mov       ebx,TargetMacroBlockBaseAddr
  mov        StashBlockType,cl
   test      al,1                        ; Don't diff block 1 if marked empty.
  mov        edi,ebx
   je        @f

  mov        ebx,[edx].BlkY1.MVs
   mov       esi,[edx].BlkY1.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  mov        al,[edx].CodedBlocks
  sub        al,bl
   mov       ebx,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>

@@:

  lea        edi,[ebx+8]                 ; Get address of next macroblock to do.
   test      al,2                        ; Don't diff block 2 if marked empty.
  je         @f

  mov        ebx,[edx].BlkY2.MVs
   mov       esi,[edx].BlkY2.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,1
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       ebx,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>

@@:

  lea        edi,[ebx+ebp*8]             ; Get address of next macroblock to do.
   test      al,4                        ; Don't diff block 3 if marked empty.
  je         @f

  mov        ebx,[edx].BlkY3.MVs
   mov       esi,[edx].BlkY3.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,2
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       ebx,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>

@@:

  lea        edi,[ebx+ebp*8+8]           ; Get address of next macroblock to do.
   test      al,8                        ; Don't diff block 4 if marked empty.
  je         NonOBMCDifferencingDone

  mov        ebx,[edx].BlkY4.MVs
   mov       esi,[edx].BlkY4.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,3
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       edi                   ; Adjust stack pointer
  mov        [edx].CodedBlocks,al

StackOffset TEXTEQU <0>
NonOBMCDifferencingDone:

IFDEF H261
ELSE
   mov       al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock

  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

ENDIF
  jmp        NextMacroBlock

;============================================================================
;  Register usage in the following internal function.  This function does
;  half pel motion estimation for whole macroblocks, or individual blocks.
;
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock.  For MBME unchanged
;         at exit.  For BlkME, adjusted by -8-8*PITCH.
;  edi -- Address of target macroblock.  For MBME unchanged at exit.  For BlkME,
;         adjusted by -8-8*PITCH.
;  edx -- MBlockActionStream
;  ecx -- Reserved.
;  ebx -- For MBME:  240 + Flags to indicate which half pel ME to do:
;                    1 --> right;   2 --> left;   4 --> down;   8 --> up
;         For BlkME: Garbage
;  eax -- Count from -4 to -1 for blocks of macroblock.  0 for single block.
;  mm7 -- Initialized to zero.
;  mm6 -- Initialized to zero.
;  mm0:mm7 -- Scratch
;  mm3[ 0:15] -- SWD for ref 1/2 pel rightward
;  mm3[16:31] -- SWD for ref 1/2 pel leftward
;  mm3[32:47] -- SWD for ref 1/2 pel downward
;  mm3[48:63] -- SWD for ref 1/2 pel upward

StackOffset TEXTEQU <4>
HalfPelMotionEstimation:

  and       bl,15

HalfPelMBMEForUpperBlock:
HalfPelMEForFirst2LinesOfBlock:

  movq       mm0,[esi-PITCH]   ; <P^7 P^6 P^5 P^4 P^3 P^2 P^1 P^0>
  movq       mm1,[esi]         ; <P07 P06 P05 P04 P03 P02 P01 P00>
  movq       mm4,[edi+ebp*1]   ; <T17 T16 T15 T14 T13 T12 T11 T10>
   paddb     mm0,mm1           ; <P^7+P07 P^6+P06 P^5+P05 P^4+P04 ...>

HalfPelMEForNext2LinesOfBlock:

  movq       mm2,[esi+ebp*1]   ; <P17 P16 P15 P14 P13 P12 P11 P10>
   psrlw     mm0,1             ; <(P^7+P07)/2 junk (P^5+P05)/2 junk ...>
  movq       mm5,mm1           ; <P07 P06 P05 P04 P03 P02 P01 P00>
   psllw     mm4,8             ; <T16 0 T14 0 T12 0 T10 0>

HalfPelMBMEForLowerBlock:

  psubw      mm0,[edi]         ; <(P^7+P07)/2-T07 junk (P^5+P05)/2-T05 junk ...>
   paddb     mm5,mm2           ; <P07+P17 P06+P16 P05+P15 P04+P14 ...>
  pmullw     mm1,C0101010101010101  ; <(P07+P06)*256+P06 ...>
   psllw     mm5,8             ; <(P06+P16) 0 (P04+P14) 0 ...>
  pmaddwd    mm0,mm0           ; Square diff for line 0 odd pels, upward ref.
   psrlw     mm5,1             ; <(P06+P16)/2 0 (P04+P14)/2 0 ...>
  movq       mm3,[edi]         ; <T07 T06 T05 T04 T03 T02 T01 T00>
   psubw     mm4,mm5           ; <T16-(P06+P16)/2 junk ...>
  pmaddwd    mm4,mm4           ; Square diff for line 1 even pels, upward ref.
   psrlw     mm1,1             ; <(P07+P06)*128+P06/2 ...>
  psllw      mm3,8             ; <T06 0 T04 0 T02 0 T00 0>
   lea       edi,[edi+ebp*2]   ; Advance Target cursor
  psubw      mm3,mm1           ; <T06-(P07+P06)/2 junk T04-(P05+P03)/2 junk ...>
   lea       esi,[esi+ebp*2]   ; Advance Reference cursor
  psubw      mm1,[edi-PITCH*2] ; <(P07+P06)/2-T07 junk (P05+P04)/2-T05 junk ...>
   pmaddwd   mm3,mm3           ; Square diff for line 0 even pels, rightwrd ref.
  pmaddwd    mm1,mm1           ; Square diff for line 0 odd pels, leftward ref.
   paddusw   mm0,mm4           ; SSD for line 0 and 1, upward ref.
  pand       mm0,CFFFF0000FFFF0000 ; Extract SSD for line 0 and 1, upward ref.
   movq      mm4,mm2           ; <P17 P16 P15 P14 P13 P12 P11 P10>
  paddusw    mm6,mm0           ; Accumulate SSD for line 0 and 1, upward ref.
   psrlq     mm4,8             ; <  0 P17 P16 P15 P14 P13 P12 P11>
  pand       mm1,CFFFF0000FFFF0000 ; Extract SSD for line 0, leftward ref.
   psrld     mm3,16            ; Extract SSD for line 0, rightward ref.
  pmullw     mm4,C0200010101010101  ; <P17*256*2 (P16+P15)*256+P15 ...>
   paddw     mm3,mm1           ; SSD for line 0, leftward and rightward refs.
  movq       mm1,[esi]         ; <P27 P26 P25 P24 P23 P22 P21 P20>
   movq      mm0,mm2           ; <P17 P16 P15 P14 P13 P12 P11 P10>
  paddusw    mm7,mm3           ; Accumulate SSD for line 0, left and right refs.
   paddb     mm2,mm1           ; <P17+P27 P16+P26 P15+P25 P14+P24 ...>
  movq       mm3,mm0           ; <P17 P16 P15 P14 P13 P12 P11 P10>
   psrlw     mm4,1             ; <P17 (P16*P15)*128+P15/2 ...>
  psubw      mm4,[edi-PITCH*1] ; <P17-T17 junk (P16*P15)/2-T15 junk ...>
   psllq     mm3,8             ; <P16 P15 P14 P13 P12 P11 P10   0>
  pmullw     mm3,C0101010101010002  ; <(P16+P15)*256+P15 ... P10*256*2>
   psrlw     mm2,1             ; <(P17+P27)/2 junk (P15+P25)/2 junk ...>
  movq       StashMM6,mm6
   pmaddwd   mm4,mm4           ; Square diff for line 1 odd pels, rightward ref.
  movq       mm6,[edi-PITCH*1] ; <T17 T16 T15 T14 T13 T12 T11 T10>
   psrlw     mm3,1             ; <(P16+P15)*128+P15/2 ... P10*256>
  psubw      mm2,[edi-PITCH*1] ; <(P17+P27)/2-T17 junk (P15+P25)/2-T15 junk ...>
   psllw     mm6,8             ; <T16 0 T14 0 T12 0 T10 0>
  psubw      mm3,mm6           ; <(P16+P15)/2-T16 junk ... P10-T10>
   psrld     mm4,16            ; Extract SSD for line 1, rightward ref.
  movq       mm6,[edi-PITCH*2] ; <T07 T06 T05 T04 T03 T02 T01 T00>
   pmaddwd   mm3,mm3           ; Square diff for line 1 even pels, leftward ref.
  pmaddwd    mm2,mm2           ; Square diff for line 1 odd pels, downward ref.
   psllw     mm6,8             ; <T06 0 T04 0 T02 0 T00 0>
  paddusw    mm7,mm4           ; Accumulate SSD for line 1, rightward ref.
   psubw     mm6,mm5           ; <T06-(P06+P16)/2 junk ...>
  pand       mm3,CFFFF0000FFFF0000 ; Extract SSD for line 1, leftward ref.
   pmaddwd   mm6,mm6           ; Square diff for line 0 even pels, downward ref.
  add        bl,080H
   psrld     mm2,16            ; Extract SSD for line 1, downward ref.
  paddusw    mm2,StashMM6      ; Accumulate SSD for line 1, downward ref.
   paddusw   mm7,mm3           ; Accumulate SSD for line 1, leftward ref.
  movq       mm4,[edi+ebp*1]   ; <T17 T16 T15 T14 T13 T12 T11 T10>
   psrld     mm6,16            ; Extract SSD for line 0, downward ref.
  paddusw    mm6,mm2           ; Accumulate SSD for line 0, downward ref.
   paddb     mm0,mm1           ; <P^7+P07 P^6+P06 P^5+P05 P^4+P04 ...>
  punpckldq  mm5,mm6           ; Speculatively start to accum partial SWDs.
   jnc       HalfPelMEForNext2LinesOfBlock  ; Iterate twice, for half a block.

  punpckldq  mm3,mm7
   add       bl,040H
  paddusw    mm5,mm6
   jns       HalfPelMEForNext2LinesOfBlock  ; Iterate twice, for a whole block.

  paddusw    mm3,mm7
   psrlw     mm0,1             ; <(P^7+P07)/2 junk (P^5+P05)/2 junk ...>
  movq       mm2,[esi+ebp*1]   ; <P17 P16 P15 P14 P13 P12 P11 P10>
   punpckhdq mm3,mm5           ; mm3[ 0:15] -- SWD for ref 1/2 pel rightward
   ;                           ; mm3[16:31] -- SWD for ref 1/2 pel leftward
   ;                           ; mm3[32:47] -- SWD for ref 1/2 pel downward
   ;                           ; mm3[48:63] -- SWD for ref 1/2 pel upward
  movq       mm5,mm1           ; <P07 P06 P05 P04 P03 P02 P01 P00>
   sub       bl,080H
  movq       HalfPelMBMESWDAccum[eax*8+32],mm3
   psllw     mm4,8             ; <T16 0 T14 0 T12 0 T10 0>
  add        eax,2
   jl        HalfPelMBMEForLowerBlock       ; Iterate twice for 2 blocks.

  lea        edi,[edi-PITCH*16+8]
   lea       esi,[esi-PITCH*16+8]
  lea        eax,[eax-3]
   je        HalfPelMBMEForUpperBlock       ; Iterate twice for macroblock.

  sub        edi,16
   xor       eax,eax
  sub        esi,16
   mov       al,bl
  ret

StackOffset TEXTEQU <0>

;============================================================================
;  Register usage in the following internal function.  This function does
;  half pel motion estimation in both directions for whole macroblocks, or
;  individual blocks.
;
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock.  For MBME unchanged
;         at exit.  For BlkME, adjusted by -8-8*PITCH.
;  edi -- Address of target macroblock.  For MBME unchanged at exit.  For BlkME,
;         adjusted by -8-8*PITCH.
;  edx -- MBlockActionStream
;  ecx -- Reserved.  Contains motion vectors.
;  ebx -- Returns SWD for this reference block or macroblock.
;  al  -- Count from 4 to 1 for blocks of macroblock.  1 for blk only.
;  mm0:mm6 -- Scratch
;  mm7 -- Reserved.  Contains SWDs for four 1/2 pel refs at main compass points.
;  mm4 -- Returns SWD for this reference block or macroblock.

StackOffset TEXTEQU <4>
HalfPelMotionEstimationBothWays:

  movq       mm3,C0101010101010101
   pxor      mm6,mm6                ; Zero out SSD accumulator.

HalfPelMBMEForUpperBlockBothWays:
HalfPelMEForFirst2LinesOfBlockBothWays:

  movq       mm0,[esi]         ; <P07 P06 P05 P04 P03 P02 P01 P00>

HalfPelMEForNext2LinesOfBlockBothWays:
HalfPelMBMEForLowerBlockBothWays:

  movq       mm1,[esi+ebp*1]   ; <P17 P16 P15 P14 P13 P12 P11 P10>
   pmullw    mm0,mm3           ; <(P07+P06)*256+P06 ...>
  movq       mm2,[esi+ebp*2]   ; <P27 P26 P25 P24 P23 P22 P21 P20>
   pmullw    mm3,mm1           ; <(P17+P16)*256+P16 ...>
  movq       mm4,mm2           ; <P27 P26 P25 P24 P23 P22 P21 P20>
   psrlq     mm2,8             ; <  0 P27 P26 P25 P24 P23 P22 P21>
  pmullw     mm2,C0200010101010101 ; <P27*256*2 (P26+P25)*256+P25 ...>
   psrlq     mm1,8             ; <  0 P17 P16 P15 P14 P13 P12 P11>
  pmullw     mm1,C0200010101010101 ; <P17*256*2 (P16+P15)*256+P15 ...>
   psrlw     mm3,2             ; <(P17+P16)/4 junk ...> (w /2 frac bits)
  movq       mm5,[edi]         ; <T07 T06 T05 T04 T03 T02 T01 T00>
   psrlw     mm0,2             ; <(P07+P06)/4 junk ...> (w/ 2 frac bits)
  paddw      mm3,mm0           ; <(P07+P06+P17+P16)/4 junk ...>
   psrlw     mm2,2             ; <P27/2 junk (P26+P25)/4 junk ...>
  psubw      mm2,[edi+ebp*1]   ; <P27/2-T17 junk (P26+P25)/4-T15 junk ...>
   psrlw     mm1,2             ; <P17/2 junk (P16+P15)/4 junk ...>
  paddw      mm2,mm1     ; <(P17+P27)/2-T17 junk (P16+P15+P26+P25)-T15 junk ...>
   psllw     mm5,8             ; <T06   0 T04   0 T02   0 T00   0>
  psubw      mm5,mm3           ; <T06-(P07+P06+P17+P16)/4 junk ...>
   pmaddwd   mm2,mm2           ; Square diffs for odd pels of line 1.
  pmaddwd    mm5,mm5           ; Square diffs for even pels of line 0.
   movq      mm0,mm4           ; <P27 P26 P25 P24 P23 P22 P21 P20>
  lea        edi,[edi+ebp*2]   ; Advance target cursor.
   lea       esi,[esi+ebp*2]   ; Advance reference cursor.
  paddusw    mm6,mm2           ; Accumulate SSD for odd pels of line 1.
   add       al,080H
  movq       mm3,C0101010101010101
   paddusw   mm6,mm5           ; Accumulate SSD for even pels of line 0.
  punpckldq  mm4,mm6           ; Speculatively start to accum partial SWDs.
   jnc       HalfPelMEForNext2LinesOfBlockBothWays  ; Twice, for half a block.

  add        al,040H
   paddusw   mm4,mm6            ; After whole block, SSD is in mm4[48:63].
  psrlq      mm4,48
   jns       HalfPelMEForNext2LinesOfBlockBothWays  ; Twice, for a whole block.

  movdf      ebx,mm4
  sub        al,082H
   jg        HalfPelMBMEForLowerBlockBothWays  ; Iterate twice for 2 blocks.

  lea        edi,[edi-PITCH*16+8]
   lea       esi,[esi-PITCH*16+8]
  mov        al,3
   je        HalfPelMBMEForUpperBlockBothWays  ; Iterate twice for macroblock.

  sub        edi,16
   sub       esi,16
  ret

StackOffset TEXTEQU <0>

;============================================================================
;  Register usage in the following internal function.  This function is also
;  called to do frame differencing for chroma blocks.
;
;  ebp -- PITCH
;  esi -- Address of reference block.
;  edi -- Address of target block.
;  edx -- Unavailable.  In use by caller.
;  ecx -- Not in use.
;  ebx -- Motion vectors for the block.  bl[0] indicates whether half-pel
;         horizontal interpolation is required;  bh[0] same for vertical.
;         This register is then used for scratch purposes.
;  eax -- Unavailable.  In use by caller.
;  mm0-mm5 -- Scratch
;  mm6 -- 8 bytes of 0xFE
;  mm7 -- 8 bytes of -1

StackOffset TEXTEQU <4>

DoNonOBMCDifferencing: ; Internal Function

  pcmpeqb    mm7,mm7
   pcmpeqb   mm6,mm6
IFDEF H261
ELSE ;H263
  shr        bl,1

   jc        NonOBMCDiff_Horz
ENDIF


  movq       mm1,[esi+ebp*1]     ; BC . . .  R0Dn
   paddb     mm6,mm6
IFDEF H261
ELSE ;H263
  shr        bh,1
   jc        NonOBMCDiff_Vert
ENDIF

  psubb      mm1,[edi+ebp*1]     ; P1 - T1
   pxor      mm4,mm4
  movq       mm0,[edi]           ; T0
   psubb     mm4,mm1             ; D1 = T1 - P1
  psubb      mm0,[esi]           ; D0 = T0 - P0
  movq       mm2,[edi+ebp*2]     ; T2
  movq       mm3,[edi+PITCH*3]   ; T3
  psubb      mm2,[esi+ebp*2]     ; D2 = T2 - P2
  psubb      mm3,[esi+PITCH*3]   ; D3 = T3 - P3
  movq       PelDiffsLine0,mm0   ; Store D0.
  movq       PelDiffsLine1,mm4   ; Store D1.
  movq       PelDiffsLine2,mm2   ; Store D2.
  movq       PelDiffsLine3,mm3   ; Store D3.
  movq       mm3,[esi+PITCH*7]   ; P7
  movq       mm2,[esi+PITCH*6]   ; P6
   paddb     mm3,mm3             ; Double so that return will fix it.
  movq       mm1,[esi+PITCH*5]   ; P5
   paddb     mm2,mm2             ; Double so that return will fix it.
  movq       mm0,[esi+ebp*4]     ; P4
   paddb     mm1,mm1             ; Double so that return will fix it.
  ret

IFDEF H261
ELSE ;H263
NonOBMCDiff_Vert:                ; 0123   Detail for 0

  movq       mm0,[esi]           ; C. .   R0Up
   psubb     mm1,mm7             ; DD .   R0Dn+1

  call       Get4LinesOfPred_InterpVert

  movq       mm5,[edi]           ; T0
   psrlq     mm1,1               ;  O .
  movq       mm7,[edi+ebp*1]
   psubb     mm5,mm0             ; D0 = T0 - P0
  movq       mm0,mm4
   psubb     mm7,mm1
  movq       mm1,[edi+ebp*2]
   pand      mm2,mm6             ;  .N.
  movq       mm4,[edi+PITCH*3]
  pand       mm3,mm6             ;  . N
   psrlq     mm2,1               ;  .O.
  movq       PelDiffsLine0,mm5   ; Store D0.
   psubb     mm1,mm2
  movq       PelDiffsLine1,mm7   ; Store D1.
   psrlq     mm3,1               ;  . O
  movq       PelDiffsLine2,mm1   ; Store D2.
   psubb     mm4,mm3
  movq       mm1,[esi+ebp*1]     ; BC . . .  R0Dn
   pcmpeqb   mm7,mm7
  movq       PelDiffsLine3,mm4   ; Store D3.
   psubb     mm1,mm7             ; DD . . .  R0Dn+1
; jmp        Get4MoreLinesOfPred_InterpVert

;===========================================================================
; Internal function to get 4 lines of prediction, interpolating in the
; vertical direction.  The first 3 lines of the function are scheduled into
; the caller's space, and so are commented out here.  For 8 lines of prediction,
; a second call, to the second entry point, is called after consuming the
; outputs of the first function call.  Certain registers must remain intact
; to convey information from the first call to the second.
;
; ebp -- PITCH
; edi -- Points to target block.
; esi -- Points to Upper left corner of 8 column, 9 row block that will be
;        interpolated vertically to generate prediction.
; edx -- Reserved (MBlockActionStream)
; ecx -- Not in use.
; ebx -- Will be used.
; eax -- Reserved.
; mm6 -- 8 bytes of 0xFE.
; mm7 -- 8 bytes of -1.
; mm0-mm5 -- Scratch.

StackOffset TEXTEQU <StackDepthVaries_DoNotUseStackVariables>
Get4LinesOfPred_InterpVert:      ; 0123   Details for line 0
; movq       mm1,[esi+ebp*1]     ; BC .   R0Dn
; movq       mm0,[esi]           ; C. .   R0Up
;  psubb     mm1,mm7             ; DD .   R0Dn+1
Get4MoreLinesOfPred_InterpVert:
  movq       mm2,[esi+ebp*2]     ;  BC.
   paddb     mm0,mm1             ; E. .   R0Up+R0Dn+1
  movq       mm3,[esi+PITCH*3]   ;  .BC
   paddb     mm1,mm2             ;  E .
  movq       mm4,[esi+ebp*4]     ;  . BC
   psubb     mm3,mm7             ;  .DD
  paddb      mm2,mm3             ;  .E.
   pand      mm0,mm6             ; F. .   Pre-clean
  paddb      mm3,mm4             ;    E
   pand      mm1,mm6             ;  F .
  lea        esi,[esi+ebp*4]     ;       Advance to next four lines.
   psrlq     mm0,1               ; G. .   P0 = (R0Up + R0Dn + 1) / 2
; pand       mm2,mm6             ;   G.
;  psrlq     mm1,1               ;  H .
; pand       mm3,mm6             ;    G
;  psrlq     mm2,1               ;   H.
; psrlq      mm3,1               ;    H
  ret
StackOffset TEXTEQU <4>

;===========================================================================

NonOBMCDiff_Horz:

  movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
   paddb     mm6,mm6             ; . .      8 bytes of 0xFE
  shr        bh,1
   jc        NonOBMCDiff_Both

  movq       mm7,[edi+PITCH*3]   ; T3

  call       Get4LinesOfPred_InterpHorz

  movq       mm4,[edi]           ; T0
   psrlq     mm1,1               ;  O .
  movq       mm5,[edi+ebp*1]
   psubb     mm4,mm0             ; D0 = T0 - P0
  movq       mm0,[edi+ebp*2]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*3]
   pand      mm2,mm6             ;  .N.
  pand       mm3,mm6             ;  . N
   psrlq     mm2,1               ;  .O.
  movq       PelDiffsLine0,mm4   ; Store D0.
   psubb     mm0,mm2
  movq       PelDiffsLine1,mm5   ; Store D1.
   psrlq     mm3,1               ;  . O
  movq       PelDiffsLine2,mm0   ; Store D2.
   psubb     mm1,mm3
  movq       mm5,[esi+1]         ; <R48 R47 R46 R45 R44 R43 R42 R41>
   ;
  movq       PelDiffsLine3,mm1   ; Store D3.
   ;

;===========================================================================
; Internal function to get 4 lines of prediction, interpolating in the
; horizontal direction.  The first line of the function are scheduled into
; the caller's space, and so are commented out here.  For 8 lines of prediction,
; a second call, to the second entry point, is called after consuming the
; outputs of the first function call.  Certain registers must remain intact
; to convey information from the first call to the second.
;
; ebp -- PITCH
; edi -- Points to target block.
; esi -- Points to Upper left corner of 9 column, 8 row block that will be
;        interpolated horizontally to generate prediction.
; edx -- Reserved (MBlockActionStream)
; ecx -- Not in use.
; ebx -- Will be used.
; eax -- Reserved.
; mm6 -- 8 bytes of 0xFE.
; mm0-mm5 -- Will be used.

StackOffset TEXTEQU <StackDepthVaries_DoNotUseStackVariables>
Get4LinesOfPred_InterpHorz:
Get4MoreLinesOfPred_InterpHorz:

; movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  xor        ebx,ebx             ;  . .
   movq      mm0,mm5             ; B. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  mov        bl,[esi]            ; C. .  R00
   psllq     mm5,8               ; D. .  <R07 R06 R05 R04 R03 R02 R01   0>
  movq       mm1,[esi+ebp*1+1]   ;  A .
   paddb     mm0,mm5             ; E. .  <R08+R07   ... R02+R01   R01      >
  paddb      mm0,Pel_Rnd[ebx*8]  ; F. .  <R08+R07+1 ... R02+R01+1 R01+R00+1>
   movq      mm4,mm1             ;  B .
  mov        bl,[esi+ebp*1]      ;  C .
   psllq     mm4,8               ;  D .
  movq       mm2,[esi+ebp*2+1]   ;   A.
   paddb     mm1,mm4             ;  E .
  paddb      mm1,Pel_Rnd[ebx*8]  ;  F .
   movq      mm5,mm2             ;   B.
  mov        bl,[esi+ebp*2]      ;   C.
   psllq     mm5,8               ;   D.
  movq       mm3,[esi+PITCH*3+1] ;    A
   paddb     mm2,mm5             ;   E.
  paddb      mm2,Pel_Rnd[ebx*8]  ;   F.
   movq      mm4,mm3             ;    B
  mov        bl,[esi+PITCH*3]    ;    C
   psllq     mm4,8               ;    D
  paddb      mm3,mm4             ;    E
   pand      mm0,mm6             ; G. .  pre-cleaned
  paddb      mm3,Pel_Rnd[ebx*8]  ;    F
   psrlq     mm0,1               ; H. .  P0=<(R08+R07+1)/2 ... (R01+R00+1)/2>
  lea        esi,[esi+ebp*4]     ;       Advance to next four lines.
   pand      mm1,mm6             ;  G .
; pand       mm2,mm6             ;   G.
;  psrlq     mm1,1               ;  H .
; pand       mm3,mm6             ;    G
;  psrlq     mm2,1               ;   H.
; psrlq      mm3,1               ;    H
  ret
StackOffset TEXTEQU <4>

; The steps commented out above are scheduled into the mem-ops the caller has
; to do at the point of return.  As though these ops were done, the registers
; look as follows:
;  mm0 -- Prediction for line 0.
;  mm1 -- Prediction for line 1.
;  mm2 -- Prediction for line 2.
;  mm3 -- Prediction for line 3.
;  mm6 -- 8 bytes of 0xFE.  Must be this when computing pred for next 4 lines.
;=============================================================================
 
NonOBMCDiff_Both:

  call       Get4LinesOfPred_InterpBoth

  movq       mm7,[edi]           ; T0
   psrlq     mm1,1               ;  O .
  psubb      mm7,mm0             ; D0 = T0 - P0
   pand      mm2,mm6             ;  .N.
  movq       mm0,[edi+ebp*1]
   psrlq     mm2,1               ;  .O.
  movq       PelDiffsLine0,mm7   ; Store D0.
   psubb     mm0,mm1
  movq       mm7,[edi+ebp*2]
   pand      mm3,mm6             ;  . N
  movq       PelDiffsLine1,mm0
   psrlq     mm3,1               ;  . O
  movq       mm1,[edi+PITCH*3]
   psubb     mm7,mm2
  psubb      mm1,mm3
   movq      mm0,mm4
  movq       PelDiffsLine2,mm7
   paddb     mm5,mm5             ;  . .  Prepare for use for next 4 lines.
  movq       PelDiffsLine3,mm1   ; Store D3.
   pcmpeqb   mm7,mm7
  jmp        Get4MoreLinesOfPred_InterpBoth

;===========================================================================
; Internal function to get 4 lines of prediction, interpolating in both
; directions.  The first line of the function are scheduled into the
; caller's space, and so are commented out here.  For 8 lines of prediction,
; a second call, to the second entry point, is called after consuming the
; outputs of the first function call.  Certain registers must remain intact
; to convey information from the first call to the second.
;
; ebp -- PITCH
; edi -- Points to target block.
; esi -- Points to Upper left corner of 9*9 block that will be interpolated
;        horizontally and vertically to generate prediction.
; edx -- Reserved (MBlockActionStream)
; ecx -- Not in use
; ebx -- Will be used.
; eax -- Reserved.
; mm6 -- 8 bytes of 0xFE.
; mm7 -- 8 bytes of -1.
; mm0-mm5 -- Scratch

StackOffset TEXTEQU <StackDepthVaries_DoNotUseStackVariables>
Get4LinesOfPred_InterpBoth:      ; 01234 Details for line 0

; movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  movq       mm1,mm5             ; B. .  <R08 R07 R06 R05 R04 R03 R02 R01>
   xor       ebx,ebx             ;  . .
  mov        bl,[esi]            ; C. .  R00
   psllq     mm5,8               ; D. .  <R07 R06 R05 R04 R03 R02 R01   0>
  paddb      mm5,mm1             ; E. .  <R08+R07 ... R02+R01 R01>
  paddb      mm5,Pel_Rnd[ebx*8]  ; F. .  <R08+R07+1 ... R02+R01+1 R01+R00+1>
   movq      mm0,mm6             ; G. .  Mask to extract each pel's frac bit.
  pandn      mm0,mm5             ; H. .  <(R08+R07+1)&1 ...>
   pand      mm5,mm6             ; I. .  Pre-clean
Get4MoreLinesOfPred_InterpBoth:  ;  . .
  movq       mm2,[esi+ebp*1+1]   ;  A .
   psrlq     mm5,1               ; J. .  <(R08+R07+1)/2 ... (R01+R00+1)/2)>
  xor        ebx,ebx             ;  . .
   movq      mm1,mm2             ;  B .
  mov        bl,[esi+ebp*1]      ;  C .
   psllq     mm2,8               ;  D .
  movq       mm3,[esi+ebp*2+1]   ;  .A.
   paddb     mm2,mm1             ;  E .
  paddb      mm2,Pel_Rnd[ebx*8]  ;  F .
   movq      mm1,mm3             ;  .B.
  mov        bl,[esi+ebp*2]      ;  .C.
   psllq     mm3,8               ;  .D.
  movq       mm4,[esi+PITCH*3+1] ;  . A
   paddb     mm3,mm1             ;  .E.
  paddb      mm3,Pel_Rnd[ebx*8]  ;  .F.
   movq      mm1,mm4             ;  . B
  mov        bl,[esi+PITCH*3]    ;  . C
   pand      mm0,mm2             ; K. .  <(R08+R07+1)&(R18+R17+1)&1 ...>
  paddb      mm0,mm5             ; L. .  <(R08+R07+1+((R18+R17+1)&1))/2 ...>
   psllq     mm4,8               ;  . D
  movq       mm5,[esi+ebp*4+1]   ;  . .A
   paddb     mm4,mm1             ;  . E
  paddb      mm4,Pel_Rnd[ebx*8]  ;  . F
   movq      mm1,mm5             ;  . .B
  mov        bl,[esi+ebp*4]      ;  . .C
   psllq     mm5,8               ;  . .D
  paddb      mm5,mm1             ;  . .E
   movq      mm1,mm6             ;  G .
  pandn      mm1,mm2             ;  H .
   pand      mm2,mm6             ;  I .
  paddb      mm5,Pel_Rnd[ebx*8]  ;  . .F
   psrlq     mm2,1               ;  J .
  paddb      mm0,mm2             ; M. .  <(R08+R07+R18+R17+2)/2 ...>
   pand      mm1,mm3             ;  K .
  paddb      mm1,mm2             ;  L .
   movq      mm2,mm6             ;  .G.
  pandn      mm2,mm3             ;  .H.
   pand      mm3,mm6             ;  .I.
  pand       mm0,mm6             ; N. .  Pre-clean
   psrlq     mm3,1               ;  .J.
  paddb      mm1,mm3             ;  M .
   pand      mm2,mm4             ;  .K.
  paddb      mm2,mm3             ;  .L.
   movq      mm3,mm6             ;  . G
  pandn      mm3,mm4             ;  . H
   pand      mm4,mm6             ;  . I
  pand       mm3,mm5             ;  . K
   psrlq     mm4,1               ;  . J
  paddb      mm2,mm4             ;  .M.
   paddb     mm3,mm4             ;  . L
  movq       mm4,mm6             ;  . .G
   psrlq     mm0,1               ; O. .  P0 = <(R08+R07+R18+R17+2)/4 ...>
  pandn      mm4,mm5             ;  . .H
   pand      mm5,mm6             ;  . .I
  pand       mm1,mm6             ;  N .
   psrlq     mm5,1               ;  . .J
  paddb      mm3,mm5             ;  . M
   lea       esi,[esi+ebp*4]     ;       Advance to next four lines.
; pand       mm2,mm6             ;  .N.
;  psrlq     mm1,1               ;  O .
; pand       mm3,mm6             ;  . N
;  psrlq     mm2,1               ;  .O.
; paddb      mm5,mm5             ;  . .  Prepare for use for next 4 lines.
;  psrlq     mm3,1               ;  . O
  ret
StackOffset TEXTEQU <4>

; The steps commented out above are scheduled into the mem-ops the caller has
; to do at the point of return.  As though these ops were done, the registers
; look as follows:
;  mm0 -- Prediction for line 0.
;  mm1 -- Prediction for line 1.
;  mm2 -- Prediction for line 2.
;  mm3 -- Prediction for line 3.
;  mm4 -- Must be moved to mm0 before computing prediction for next 4 lines.
;  mm5 -- Must be doubled before computing prediction for next 4 lines.
;  mm6 -- 8 bytes of 0x01.  Must be this when computing pred for next 4 lines.
;  mm7 -- 8 bytes of 0xFE.  Must be this when computing pred for next 4 lines.
;=============================================================================
ENDIF

StackOffset TEXTEQU <0>

IFDEF H261
ELSE ;H263
OBMCDifferencing:

  mov        al,PendingOBMC           ; Do OBMC for previous block, if needed..
   mov       bl,1
  test       al,al
   mov       PendingOBMC,bl
  mov        cl,INTER1MV
   je        NextMacroBlock

  mov        StashBlockType,cl

  call       DoPendingOBMCDiff

  mov        al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock

  add        edx,-SIZEOF T_MacroBlockActionDescr
  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

  sub        edx,-SIZEOF T_MacroBlockActionDescr
   jmp       NextMacroBlock

ENDIF

;============================================================================
; Calculate the IntraSWD
;
;  ebp -- PITCH
;  esi -- Accumulation for IntraSWD
;  edi -- Address of target macroblock.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- Amount IntraSWD has to be less than to be the winner.
;  eax -- Reserved.  Holds coded blk pattern, (except undef when IntraByDecree).
;  mm7 -- SWD total for macroblock.
;  mm6 -- Average pel value for block 1.
;  mm5 -- Average pel value for block 2.
;  mm4 -- Average pel value for block 3.
;  mm3 -- Average pel value for block 4.
;  mm0-mm2 Scratch
;

IntraByDecree:

  mov        ebx,000080000H           ; Set Inter SWD artificially high.

CalculateIntraSWD:

  sub        ebx,INTRACODINGDIFFERENTIAL
   mov       cl,1
  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5

ComputeIntraSWDForNextBlock:

  movq       mm2,[edi+ebp*2]        ; <P27 P26 P25 P24 P23 P22 P21 P20>
   psrlw     mm5,8
  movq       mm4,[edi+ebp*4]
   paddw     mm0,mm2                ; <junk P06+P26 junk P04+P24 ...>
  movq       mm6,[edi+PITCH*6]
   pand      mm0,mm5                ; <P06+P26 P04+P24 P02+P22 P00+P20>
  movq       mm1,[edi+ebp*1]        ; <P17 P16 P15 P14 P13 P12 P11 P10>
   paddw     mm4,mm6
  movq       mm3,[edi+PITCH*3]      ; <P37 P36 P35 P34 P33 P32 P31 P30>
   pand      mm4,mm5
  movq       mm5,[edi+PITCH*5]
   paddw     mm1,mm3                ; <P17+P37 junk P15+P35 junk ...>
  movq       mm7,[edi+PITCH*7]
   psrlw     mm1,8                  ; <P17+P37 P15+P35 P13+P33 P11+P31>
  paddw      mm0,mm1
   paddw     mm5,mm7
  paddw      mm0,mm4
   psrlw     mm5,8
  paddw      mm0,mm5
   pcmpeqw   mm5,mm5                ; Get words of -1
  movq       mm4,[edi+ebp*4]
   pmaddwd   mm0,mm5                ; <SumHi = Sum3+Sum2 | SumLo = Sum1+Sum0>
  pcmpeqw    mm1,mm1
   psllw     mm3,8                  ; <P36   0 P34   0 P32  0 P30  0>
  movq       mm5,[edi+PITCH*5]
   psllw     mm1,3                  ; 4 words of 0xFFF8
  packssdw   mm0,mm0                ; <SumHi | SumLo | SumHi | SumLo>
   mov       al,[edx].CodedBlocks   ; Fetch coded block pattern.
  pmaddwd    mm0,mm1                ; <Sum = SumHi+SumLo | Sum = SumHi+SumLo>
   psllw     mm5,8
  movq       mm1,[edi+ebp*1]
   psllw     mm7,8
  ;
   psllw     mm1,8
  ;
   packssdw  mm0,mm0                ; <Sum | Sum | Sum | Sum>
  psubw      mm1,mm0                ; <P16-Avg frac P14-Avg frac ...>
   psubw     mm2,mm0                ; <P27-Avg frac P25-Avg frac ...>
  pmaddwd    mm1,mm1                ; Square of diff
   psubw     mm3,mm0
  pmaddwd    mm2,mm2
   psubw     mm4,mm0
  pmaddwd    mm3,mm3
   psubw     mm5,mm0
  pmaddwd    mm4,mm4
   psubw     mm6,mm0
  psubw      mm7,mm0
   paddusw   mm1,mm2
  psubw      mm0,[edi]
   pmaddwd   mm5,mm5
  pmaddwd    mm6,mm6
   paddusw   mm1,mm3
  pmaddwd    mm7,mm7
   paddusw   mm1,mm4
  pmaddwd    mm0,mm0
   paddusw   mm1,mm5
  paddusw    mm1,mm6
   cmp       cl,2
  paddusw    mm1,mm7
   ;
  paddusw    mm0,mm1
   ;
  punpckldq  mm1,mm0
   ;
  paddusw    mm0,mm1
   jg        LowerBlkIntraDone

  psrlq      mm0,48
   lea       edi,[edi+ebp*8+8]   ; Speculate going from blk 1 to blk 4
  mov        cl,4
   je        Blk2IntraDone

Blk1IntraDone:

  movdf      esi,mm0
  sub        ebx,esi
   jle       InterBestX

  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5
  jmp        ComputeIntraSWDForNextBlock

LowerBlkIntraDone:


  psrlq      mm0,48
   sub       edi,PITCH*8         ; Speculate going from blk 4 to blk 2
  cmp        cl,3
   je        Blk3IntraDone

Blk4IntraDone:

  movdf      ecx,mm0
  add        esi,ecx             ; Accumulate IntraSWD
   sub       ebx,ecx
  jle        InterBestX

  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5
  mov        cl,2
   jmp       ComputeIntraSWDForNextBlock

Blk2IntraDone:

  movdf      ecx,mm0
  add        esi,ecx             ; Accumulate IntraSWD
   sub       edi,16              ; Get to blk 3.
  sub        ebx,ecx
   jle       InterBestX

  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5
  mov        cl,3
   jmp       ComputeIntraSWDForNextBlock

Blk3IntraDone:

  movdf      ecx,mm0
  add        esi,ecx             ; Accumulate IntraSWD
   sub       ebx,ecx
  jle        InterBestX

IntraBest:

  mov        ecx,SWDTotal
   and       al,07FH                   ; Turn off FORCE-INTRA bit.
  mov        [edx].SWD,esi
   add       ecx,esi                   ; Add to total.
  mov        SWDTotal,ecx
   mov       cl,INTRA
  mov        [edx].BlockType,cl        ; Indicate macroblock handling decision.
   xor       ecx,ecx
  mov        [edx].BlkY1.MVs,ecx
   mov       [edx].BlkY2.MVs,ecx
  mov        [edx].BlkY3.MVs,ecx
   mov       [edx].BlkY4.MVs,ecx
  mov        [edx].CodedBlocks,al

IFDEF H261
ELSE ;H263
   mov       al,PendingOBMC            ; Do Prev MB if it needs to be OBMC'ed.
  mov        [edx].BestFullPelMBHMV,cl ; Kill MVs so extended EMV of other
  ;                                    ; blocks will work right.
   dec       al
  mov        [edx].BestFullPelMBVMV,cl
   jne       @f

  mov        PendingOBMC,al            ; Go on to next MB, unless the prev MB
  ;                                    ; needs to be finished (OBMC).
   mov       cl,INTER1MV
  mov        StashBlockType,cl

  call       DoPendingOBMCDiff

  mov        al,IsPlainPFrame
  test       al,al
   jne       @f

  add        edx,-SIZEOF T_MacroBlockActionDescr
  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

  sub        edx,-SIZEOF T_MacroBlockActionDescr

@@:

ENDIF

  mov        cl,INTRA
   mov       esi,TargetMacroBlockBaseAddr
  mov        StashBlockType,cl
   push      eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>
  call       MMxDoForwardDCT
  mov        al,[edx].CodedBlocks
   mov       esi,TargetMacroBlockBaseAddr
  sub        al,bl
   add       esi,8
  mov        [edx].CodedBlocks,al
  call       MMxDoForwardDCT
  shl        bl,1
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       esi,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   add       esi,PITCH*8
  call       MMxDoForwardDCT
  shl        bl,2
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       esi,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   add       esi,PITCH*8+8
  call       MMxDoForwardDCT
  shl        bl,3
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        [edx].CodedBlocks,al
IFDEF H261
ELSE
   mov       al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock

  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks
ENDIF

  jmp        NextMacroBlock


IFDEF H261
ELSE; H263
StackOffset TEXTEQU <4>
DoPendingOBMCDiff: ; Internal function

;============================================================================
; Perform differencing for the non-empty luma blocks of an Inter-coded
; macroblock.  This is the OBMC case;  i.e. Advanced Prediction is selected.

PrevMBAD EQU [edx-SIZEOF T_MacroBlockActionDescr]

  pcmpeqb    mm6,mm6
   pcmpeqb   mm7,mm7                    ; 8 bytes of -1
  paddb      mm6,mm6                    ; 8 bytes of 0xFE
   mov       al,PrevMBAD.CodedBlocks    ; Bits  0- 3  set for non-empty Y blks.
  test       al,1                       ; Check if block 1 empty.
   je        OBMCDoneForBlock1

  xor        ebx,ebx
   mov       eax,SIZEOF T_Blk           ; Blk to right is blk 2 of this MB.
  mov        bl,PrevMBAD.MBEdgeType
   mov       ecx,1                      ; Mask to extract left edge indicator.
  and        ecx,ebx                    ; Extract left edge indicator.
   and       ebx,4                      ; Extract top edge indicator.
  mov        esi,PrevMBAD.BlkY1.MVs
   lea       edi,[eax*2]                ; Blk below is blk 3 of this MB.
  mov        DistToBADforBlockBelow,edi ; Stash BAD offset for lower remote MV.
   mov       edi,BlockAbove[ebx]        ; Blk above is blk 3 of mb above, or off
   ;                                    ; upper edge.
  mov        ecx,BlockToLeft[ecx*4]     ; Blk to left is blk 2 of mb to the
  ;                                     ; left, or off left edge.
   mov       DistToBADforBlockAbove,edi
  call       DoOBMCForBlock
  mov        al,PrevMBAD.CodedBlocks    ; Bits  0- 3  set for non-empty Y blks.
  sub        al,bl
  mov        PrevMBAD.CodedBlocks,al

OBMCDoneForBlock1:

   add       edx,SIZEOF T_Blk
  test       al,2                       ; Check if block 2 empty.
   je        OBMCDoneForBlock2

  xor        ebx,ebx
   mov       eax,2                      ; Mask to extract right edge indicator.
  mov        bl,PrevMBAD[-SIZEOF T_Blk].MBEdgeType
   mov       edi,2*SIZEOF T_Blk         ; Blk below is blk 4 of this MB.
  and        eax,ebx                    ; Extract right edge indicator.
   and       ebx,4                      ; Extract top edge indicator.
  mov        DistToBADforBlockBelow,edi ; Stash BAD offset for lower remote MV.
   lea       ecx,[edi-3*SIZEOF T_Blk]   ; Blk to left is blk 1 of this MB.
  mov        eax,BlockToRight[eax*2]    ; Blk to right is blk 1 of mb to the
  ;                                     ; right, or off right edge.
   mov       edi,BlockAbove[ebx]        ; Blk above is blk 4 of mb above, or off
   ;                                    ; upper edge.
  mov        esi,PrevMBAD.BlkY1.MVs
   mov       DistToBADforBlockAbove,edi
  call       DoOBMCForBlock
  shl        bl,1
   mov       al,PrevMBAD[-1*SIZEOF T_Blk].CodedBlocks
  sub        al,bl
  mov        PrevMBAD[-1*SIZEOF T_Blk].CodedBlocks,al

OBMCDoneForBlock2:

   add       edx,SIZEOF T_Blk
  test       al,4                       ; Check if block 3 empty.
   je        OBMCDoneForBlock3

  xor        ecx,ecx
   xor       ebx,ebx                    ; Blk below is this block.
  mov        cl,PrevMBAD[-2*SIZEOF T_Blk].MBEdgeType
   mov       eax,SIZEOF T_Blk           ; Blk to right is blk 4 of this MB.
  and        ecx,1                      ; Extract left edge indicator.
   mov       DistToBADforBlockBelow,ebx ; Stash BAD offset for lower remote MV.
  lea        edi,[eax-3*SIZEOF T_Blk]   ; Blk above is blk 1 of this MB.
   mov       esi,PrevMBAD.BlkY1.MVs
  mov        DistToBADforBlockAbove,edi
   mov       ecx,BlockToLeft[ecx*4]     ; Blk to left is blk 1 of mb to the
  ;                                     ; left, or off left edge.
  call       DoOBMCForBlock
  shl        bl,2
   mov       al,PrevMBAD[-2*SIZEOF T_Blk].CodedBlocks
  sub        al,bl
  mov        PrevMBAD[-2*SIZEOF T_Blk].CodedBlocks,al

OBMCDoneForBlock3:

   add       edx,SIZEOF T_Blk
  test       al,8                       ; Check if block 4 empty.
   je        OBMCDoneForBlock4

  xor        eax,eax
   xor       ebx,ebx                    ; Blk below is this block.
  mov        al,PrevMBAD[-3*SIZEOF T_Blk].MBEdgeType
   mov       ecx,-SIZEOF T_Blk          ; Blk to left is blk 3 of this MB.
  and        eax,2                      ; Extract right edge indicator.
   mov       DistToBADforBlockBelow,ebx ; Stash BAD offset for lower remote MV.
  lea        edi,[ecx*2]                ; Blk above is blk 2 of this MB.
   mov       esi,PrevMBAD.BlkY1.MVs
  mov        DistToBADforBlockAbove,edi
   mov       eax,BlockToRight[eax*2]    ; Blk to right is blk 1 of mb to the
  ;                                     ; right, or off right edge.
  call       DoOBMCForBlock
  shl        bl,3
   mov       al,PrevMBAD[-3*SIZEOF T_Blk].CodedBlocks
  sub        al,bl
  mov        PrevMBAD[-3*SIZEOF T_Blk].CodedBlocks,al

OBMCDoneForBlock4:

   sub       edx,3*SIZEOF T_Blk    ; Get back to MacroBlock Action Descriptor
  ret

StackOffset TEXTEQU <8>
DoOBMCForBlock: ; Internal Function

;  Present register contents.
;  ebp -- PITCH
;  esi -- Motion vectors for current block.
;  ecx -- Distance from BAD of blk we're doing to BAD for block that provides
;         remote MV from left.
;  eax -- Distance from BAD of blk we're doing to BAD for block that provides
;         remote MV from right.
;  edx -- MBlockActionStream, adjusted to reach BAD of blk we are doing OBMC to.
;         doing OBMC)
;  mm7 -- 8 bytes of -1.
;  mm6 -- 8 bytes of 0xFE.
;
; In the body of this code:
;
;  edx -- Unchanged.
;  edi -- Saved to memory.  Then used for address of destination for storing
;         remote prediction blocks.
;  ebp -- PITCH.
;  esi -- Pointer to 8*8, 8*9, 9*8, or 9*9 remote reference areas, which are
;         then interpolated and stored at edi.
;  ecx, eax -- Inputs are used, then these are scratch.
;  ebx -- Scratch
;  mm7 -- 8 bytes of -1
;  mm6 -- 8 bytes of 0xFE
;  mm0-mm5 -- Scratch

;  Compute left remote prediction block.

  lea        edi,PrevMBAD[ecx]
  and        edi,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk to left.
   lea       ebx,CentralPred
  mov        AddrOfLeftPred,ebx  ; Speculate that left remote MV == center MV.
   mov       AddrOfRightPred,ebx ; Speculate that right remote MV == center MV.
  mov        bl,[edi].BlockType
  cmp        bl,INTRA
   je        LeftEqCtr           ; Jump if INTRA.  (Use central)

  mov        ebx,PrevMBAD[ecx].BlkY1.MVs
  and        ebx,00000FFFFH     ; Blk to left may have B MVs set.  Clear them.
  cmp        esi,ebx
   je        LeftEqCtr

  mov        edi,PrevMBAD[ecx].BlkY1.BlkOffset
   mov       esi,PrevMBAD[ecx].BlkY1.PastRef   ; Get ref addr using left remote.
  sub        esi,edi
   mov       edi,PrevMBAD.BlkY1.BlkOffset
  add        esi,edi
   lea       edi,LeftPred

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  lea        ecx,PrevMBAD[eax]
  and        ecx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk to right.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7             ;  . .  Restore 8 bytes of -1

;  Compute right remote prediction block.

  mov        AddrOfLeftPred,edi
   mov       bl,[ecx].BlockType
  cmp        bl,INTRA
   je        RightEqCtrButLeftNeCtr ; Jump if INTRA.(Use central)

  mov        ebx,PrevMBAD[eax].BlkY1.MVs
  cmp        esi,ebx
   je        RightEqCtrButLeftNeCtr

  mov        esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using right remote.
   mov       edi,PrevMBAD[eax].BlkY1.BlkOffset

RightNeCtr:

  sub        esi,edi
   mov       edi,PrevMBAD.BlkY1.BlkOffset
  add        esi,edi
   lea       edi,RightPred

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  mov        AddrOfRightPred,edi
   ;
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7             ;  . .  Restore 8 bytes of -1

RightEqCtrButLeftNeCtr:

;  Compute central prediction block.

  mov        ebx,PrevMBAD.BlkY1.MVs
   mov       esi,PrevMBAD.BlkY1.PastRef
  lea        edi,CentralPred
   mov       eax,DistToBADforBlockBelow

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  lea        ecx,PrevMBAD[eax]
  and        ecx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk below.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7
  mov        bl,[ecx].BlockType
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  cmp        bl,INTRA
   je        BelowEqCtrButSidesDiffer ; Jump if INTRA.  (Use central)

; Compute bottom remote prediction block.

  mov        ebx,PrevMBAD[eax].BlkY1.MVs
   mov       edi,AddrOfLeftPred
  cmp        esi,ebx
   jne       BelowNeCtr

BelowEqCtrButSidesDiffer:

  paddb      mm1,mm1             ; Prep mm0-3, which have ctr, for reuse below.
   paddb     mm2,mm2
  paddb      mm3,mm3
   mov       edi,AddrOfLeftPred
  jmp        BelowEqCtr

BelowNeCtr:

  mov        esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
   mov       eax,PrevMBAD[eax].BlkY1.BlkOffset
  sub        esi,eax
   lea       eax,[ecx+ebp*4]

  call       GetPredForAboveOrBelow

BelowEqCtr:

; Compute difference for lines 4 thru 7.
; Lines 4 and 5: Cols 0,1,6, and 7 treated same.  Cols 2-5 treated same.

  mov        esi,AddrOfRightPred
   mov       ebx,TargetFrameBaseAddress
  movdt      mm5,[edi+48]          ; 6B: <  0   0   0   0 R63 R62 R61 R60>
   pand      mm2,mm6
  punpckldq  mm5,[esi+48+4]        ; 6C: <L67 L66 L65 L64 R63 R62 R61 R60>
   pand      mm3,mm6
  movq       mm4,CFFFF00000000FFFF ; 6D: < FF  FF  00  00  00  00  FF  FF>
   psrlq     mm2,1                 ; 6A: <B67 B66 B65 B64 B63 B62 B61 B60>
  pand       mm4,mm5               ; 6E: <L67 L66  00  00  00  00 R61 R60>
   paddb     mm5,mm2               ; 6F: <B67+L67 ... B65+L65 ...>

  pand       mm2,C0000FFFFFFFF0000 ; 6G: < 00  00 B65 B64 B63 B62  00  00>
   psrlq     mm1,1                 ; 5A: <B57 B56 B55 B54 B53 B52 B51 B50>
  paddb      mm2,mm4               ; 6H: <L67 L66 B65 B64 B63 B62 R61 R60>
   add       ecx,ebx               ;     Address of target block.
  movdt      mm4,[edi+56]          ; 7B: <  0   0   0   0 R73 R72 R71 R70>
   psubb     mm5,mm2               ; 6I: <B67 B66 L65 L64 R63 R62 B61 B60>
  paddb      mm5,CentralPred+48    ; 6J: <C67+B67 ... C65+L65 ...>
   psrlq     mm3,1                 ; 7A: <B77 B76 B75 B74 B73 B72 B71 B70>
  punpckldq  mm4,[esi+56+4]        ; 7C: <L77 L76 L75 L74 R73 R72 R71 R70>
   pand      mm5,mm6               ; 6K: <C67+B67 ... C65+L65 ...> pre-cleaned
  mov        eax,DistToBADforBlockAbove
   psrlq     mm5,1                 ; 6L: <(C67+B67)/2 ... (C65+L65)/2 ...>
  paddb      mm2,mm5               ; 6M: <(C67+B67+2L67)/2 ...
  ;                                ;      (C65+2B65+L65)/2 ...>
   lea       ebx,PelDiffs
  movq       mm5,CFF000000000000FF ; 7D: < FF  00  00  00  00  00  00  FF>
   pand      mm2,mm6               ; 6N: pre-cleaned
  pandn      mm5,CentralPred+56    ; 7E: < 00 C76 C75 C74 C73 C72 C71  00>
   psrlq     mm2,1                 ; 6O: <(C67+B67+2L67)/4 ...
   ;                               ;      (C65+2B65+L65)/4 ...>
  paddb      mm2,CentralPred+48    ; 6P: <(5C67+B67+2L67)/4 ...
  ;                                ;      (5C65+2B65+L65)/4 ...>
   paddb     mm5,mm4               ; 7F: <L77 C76+L76 ...>
  pand       mm4,CFF000000000000FF ; 7G: <L77  00  00  00  00  00  00  L70>
   psubb     mm2,mm7               ; 6Q: <(5C67+B67+2L67+4)/4 ...
   ;                               ;      (5C65+2B65+L65+4)/4 ...>
  paddb      mm4,mm5               ; 7H: <2L77 C76+L76 ...>
   pand      mm2,mm6               ; 6R: pre-cleaned
  movq       mm5,[ecx+PITCH*6]     ; 6T: T6
   psrlq     mm2,1                 ; 6S: P6 = <(5C67+B67+2L67+4)/8 ...
   ;                               ;           (5C65+2B65+L65+4)/8 ...>
  psubb      mm5,mm2               ; 6U: D6 = T6 - P6
   ;
                                   ; 4A: <B47 B46 B45 B44 B43 B42 B41 B40>: mm0
  movdt      mm2,[edi+32]          ; 4B: <  0   0   0   0 R43 R42 R41 R40>
   pand      mm4,mm6               ; 7I: <2L77 C76+L76 ...> pre-cleaned
  movq       [ebx+6*16],mm5        ; 6V: Store D6.
   psrlq     mm4,1                 ; 7J: <2L77/2 (C76+L76)/2 ...>
  punpckldq  mm2,[esi+32+4]        ; 4C: <L47 L46 L45 L44 R43 R42 R41 R40>
   paddb     mm3,mm4               ; 7K: <(2B77+2L77)/2 (C76+2B76+L76)/2 ...>
  movq       mm5,CFFFF00000000FFFF ; 4D: < FF  FF  00  00  00  00  FF  FF>
   pand      mm3,mm6               ; 7L: pre-cleaned
  movq       mm4,CentralPred+32    ; 4E: <C47 C46 C45 C44 C43 C42 C41 C40>
   psrlq     mm3,1                 ; 7M: <(2B77+2L77)/4 (C76+2B76+L76)/4 ...>
  paddb      mm3,CentralPred+56    ; 7N: <(4C77+2B77+2L77)/4
  ;                                ;      (5C76+2B76+L76)/4 ...>
   pand      mm5,mm4               ; 4F: <C47 C46  00  00  00  00 C41 C40>
  psubb      mm3,mm7               ; 7O: <(4C77+2B77+2L77+4)/4
   ;                               ;      (5C76+2B76+L76+4)/4 ...>
   paddb     mm4,mm2               ; 4G: <C47+L47 ... C45+L45 ...>
  pand       mm2,C0000FFFFFFFF0000 ; 4H: < 00  00 L45 L44 R43 R42  00  00>
   pand      mm3,mm6               ; 7P: <(4C77+2B77+2L77+4)/4
   ;                               ;      (5C76+2B76+L76+4)/4 ...> pre-cleaned
  paddb      mm2,mm5               ; 4I: <C47 C46 L45 L44 R43 R42 C41 C40>
   psrlq     mm3,1                 ; 7Q: P7 = <(4C77+2B77+2L77+4)/8
   ;                               ;           (5C76+2B76+L76+4)/8 ...>
  movdt      mm5,[edi+40]          ; 5B: <  0   0   0   0 R53 R52 R51 R50>
   psubb     mm4,mm2               ; 4J: <L47 L46 C45 C44 C43 C42 R41 R40>
  punpckldq  mm5,[esi+40+4]        ; 5C: <L57 L56 L55 L54 R53 R52 R51 R50>
   paddb     mm0,mm2               ; 4K: <C47+B47 ... B45+L45 ...>
  movq       mm2,[ecx+PITCH*7]     ; 7R: T7
   pand      mm0,mm6               ; 4L: <C47+B47 ... B45+L45 ...> pre-cleaned
  psubb      mm2,mm3               ; 7S: D7 = T7 - P7
   psrlq     mm0,1                 ; 4M: <(C47+B47)/2 ... (B45+L45)/2 ...>
  movq       mm3,CFFFF00000000FFFF ; 5D: < FF  FF  00  00  00  00  FF  FF>
   paddb     mm0,mm4               ; 4N: <(C47+B47+2L47)/2 ...
   ;                               ;      (2C45+B45+L45)/2 ...>
  movq       mm4,CentralPred+40    ; 5E: <C57 C56 C55 C54 C53 C52 C51 C50>
   pand      mm0,mm6               ; 4O: pre-cleaned
  pand       mm3,mm4               ; 5F: <C57 C56  00  00  00  00 C51 C50>
   paddb     mm4,mm5               ; 5G: <C57+L57 ... C55+L55 ...>
  pand       mm5,C0000FFFFFFFF0000 ; 5H: < 00  00 L55 L54 R53 R52  00  00>
   psrlq     mm0,1                 ; 4P: <(C47+B47+2L47)/4 ...
   ;                               ;      (2C45+B45+L45)/4 ...>
  paddb      mm0,CentralPred+32    ; 4Q: <(5C47+B47+2L47)/4 ...
  ;                                ;      (6C45+B45+L45)/4 ...>
   paddb     mm5,mm3               ; 5I: <C57 C56 L55 L54 R53 R52 C51 C50>
  psubb      mm4,mm5               ; 5J: <L57 L56 C55 C54 C53 C52 R51 R50>
   paddb     mm1,mm5               ; 5K: <C57+B57 ... B55+L55 ...>
  pand       mm1,mm6               ; 5L: <C57+B57 ... B55+L55 ...> pre-cleaned
   psubb     mm0,mm7               ; 4R: <(5C47+B47+2L47+4)/4 ...
   ;                               ;      (6C45+B45+L45+4)/4 ...>
  pand       mm0,mm6               ; 4S: pre-cleaned
   psrlq     mm1,1                 ; 5M: <(C57+B57)/2 ... (B55+L55)/2 ...>
  paddb      mm1,mm4               ; 5N: <(C57+B57+2L57)/2 ...
  ;                                ;      (2C55+B55+L55)/2 ...>
   psrlq     mm0,1                 ; 4T: P4 = <(5C47+B47+2L47+4)/8 ...
   ;                               ;           (6C45+B45+L45+4)/8 ...>
  movq       mm3,[ecx+PITCH*5]     ; 5U: T5
   pand      mm1,mm6               ; 5O: pre-cleaned
  movq       mm4,[ecx+ebp*4]       ; 4U: T4
   psrlq     mm1,1                 ; 5P: <(C57+B57+2L57)/4 ...
   ;                               ;      (2C55+B55+L55)/4 ...>
  paddb      mm1,CentralPred+40    ; 5Q: <(5C57+B57+2L57)/4 ...
  ;                                ;      (6C55+B55+L55)/4 ...>
   psubb     mm4,mm0               ; 4V: D4 = T4 - P4
  lea        esi,PrevMBAD[eax]
   psubb     mm1,mm7               ; 5R: <(5C57+B57+2L57+4)/4 ...
   ;                               ;      (6C55+B55+L55+4)/4 ...>
  and        esi,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk above.
   pand      mm1,mm6               ; 5S: pre-cleaned
  movq       [ebx+7*16],mm2        ; 7T
   psrlq     mm1,1                 ; 5T: P5 = <(5C57+B57+2L57+4)/8 ...
   ;                               ;           (6C55+B55+L55+4)/8 ...>
  movq       [ebx+4*16],mm4        ; 4W: Store D4.
   psubb     mm3,mm1               ; 5V: D5 = T5 - P5
  mov        cl,[esi].BlockType    ; Bottom bit set if above neighbor is INTRA.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [ebx+5*16],mm3        ; 5W: Store D5.
  cmp        cl,INTRA
   je        AboveEqCtrButSidesDiffer ; Jump if INTRA.  (Use central)

; Compute top remote prediction block.

  mov        ebx,PrevMBAD[eax].BlkY1.MVs
  and        ebx,00000FFFFH     ; Blk above may have B MVs set.  Clear them.
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  cmp        esi,ebx
   jne       AboveNeCtr

AboveEqCtrButSidesDiffer:

  movq       mm3,CentralPred+24   ; Prep mm0-3, which have ctr, for reuse below.
  movq       mm2,CentralPred+16
   paddb     mm3,mm3
  movq       mm1,CentralPred+8
   paddb     mm2,mm2
  movq       mm0,CentralPred
   paddb     mm1,mm1
  mov        ecx,PrevMBAD.BlkY1.BlkOffset
   jmp       AboveEqCtr

AboveNeCtr:

  mov        esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
   mov       eax,PrevMBAD[eax].BlkY1.BlkOffset
  sub        esi,eax
   mov       eax,ecx

  call       GetPredForAboveOrBelow

AboveEqCtr:

; Compute difference for lines 0 thru 3.

  mov        esi,AddrOfRightPred
   mov       ebx,TargetFrameBaseAddress
  movdt      mm5,[edi+8]           ; 1B: <  0   0   0   0 R13 R12 R11 R10>
   psrlq     mm1,1                 ; 1A: <A17 A16 A15 A14 A13 A12 A11 A10>
  punpckldq  mm5,[esi+8+4]         ; 1C: <L17 L16 L15 L14 R13 R12 R11 R10>
   pand      mm3,mm6
  movq       mm4,CFFFF00000000FFFF ; 1D: < FF  FF  00  00  00  00  FF  FF>
   psrlq     mm3,1                 ; 3A: <A37 A36 A35 A34 A33 A32 A31 A30>: mm0
  pand       mm4,mm5               ; 1E: <L17 L16  00  00  00  00 R11 R10>
   paddb     mm5,mm1               ; 1F: <A17+L17 ... A15+L15 ...>
  pand       mm1,C0000FFFFFFFF0000 ; 1G: < 00  00 A15 A14 A13 A12  00  00>
   pand      mm2,mm6
  paddb      mm5,CentralPred+8     ; 1H: <C17+A17+L17 ... C15+A15+L15 ...>
   paddb     mm1,mm4               ; 1I: <L17 L16 A15 A14 A13 A12 R11 R10>
                                   ; 0A: <A07 A06 A05 A04 A03 A02 A01 A00>:mm0
  movdt      mm4,[edi]             ; 0B: <  0   0   0   0 R03 R02 R01 R00>
   psubb     mm5,mm1               ; 1J: <C17+A17 ... C15+L15 ...>
  punpckldq  mm4,[esi+4]           ; 0C: <L07 L06 L05 L04 R03 R02 R01 R00>
   pand      mm5,mm6               ; 1K: <C17+A17 ... C15+L15 ...> pre-cleaned
  add        ecx,ebx               ;     Address of target block.
   psrlq     mm5,1                 ; 1L: <(C17+A17)/2 ... (C15+L15)/2 ...>
  paddb      mm1,mm5               ; 1M: <(C17+A17+2L17)/2 ...
   ;                               ;      (C15+2A15+L15)/2 ...>
   psrlq     mm2,1                 ; 2A: <A27 A26 A25 A24 A23 A22 A21 A20>
  movq       mm5,CFF000000000000FF ; 0D: < FF  00  00  00  00  00  00  FF>
   pand      mm1,mm6               ; 1N: pre-cleaned
  pandn      mm5,CentralPred       ; 0E: < 00 C06 C05 C04 C03 C02 C01  00>
   psrlq     mm1,1                 ; 1O: <(C17+A17+2L17)/4 ...
   ;                               ;      (C15+2A15+L15)/4 ...>
  paddb      mm1,CentralPred+8     ; 1P: <(5C17+A17+2L17)/4 ...
  ;                                ;      (5C15+2A15+L15)/4 ...>
   paddb     mm5,mm4               ; 0F: <L07 C06+L06 ...>
  pand       mm4,CFF000000000000FF ; 0G: <L07  00  00  00  00  00  00  L00>
   psubb     mm1,mm7               ; 1Q: <(5C17+A17+2L17+4)/4 ...
   ;                               ;      (5C15+2A15+L15+4)/4 ...>
  paddb      mm4,mm5               ; 0H: <2L07 C06+L06 ...>
   pand      mm1,mm6               ; 1R: pre-cleaned
  movq       mm5,[ecx+ebp*1]       ; 1T: T1
   psrlq     mm1,1                 ; 1S: P1 = <(5C17+A17+2L17+4)/8 ...
   ;                               ;           (5C15+2A15+L15+4)/8 ...>
  psubb      mm5,mm1               ; 1U: D1 = T1 - P1
   ;
  movdt      mm1,[edi+24]          ; 3B: <  0   0   0   0 R33 R32 R31 R30>
   pand      mm4,mm6               ; 0I: <2L07 C06+L06 ...> pre-cleaned
  movq       PelDiffsLine1,mm5       ; 1V: Store D1.
   psrlq     mm4,1                 ; 0J: <2L07/2 (C06+L06)/2 ...>
  punpckldq  mm1,[esi+24+4]        ; 3C: <L37 L36 L35 L34 R33 R32 R31 R30>
   paddb     mm0,mm4               ; 0K: <(2A07+2L07)/2 (C06+2A06+L06)/2 ...>
  movq       mm5,CFFFF00000000FFFF ; 3D: < FF  FF  00  00  00  00  FF  FF>
   pand      mm0,mm6               ; 0L: pre-cleaned
  movq       mm4,CentralPred+24    ; 3E: <C37 C36 C35 C34 C33 C32 C31 C30>
   psrlq     mm0,1                 ; 0M: <(2A07+2L07)/4 (C06+2A06+L06)/4 ...>
  paddb      mm0,CentralPred       ; 0N: <(4C07+2A07+2L07)/4
  ;                                ;      (5C06+2A06+L06)/4 ...>
   pand      mm5,mm4               ; 3F: <C37 C36  00  00  00  00 C31 C30>
  psubb      mm0,mm7               ; 0O: <(4C07+2A07+2L07+4)/4
  ;                                ;      (5C06+2A06+L06+4)/4 ...>
   paddb     mm4,mm1               ; 3G: <C37+L37 ... C35+L35 ...>
  pand       mm1,C0000FFFFFFFF0000 ; 3H: < 00  00 L35 L34 R33 R32  00  00>
   pand      mm0,mm6               ; 0P: <(4C07+2A07+2L07+4)/4
   ;                               ;      (5C06+2A06+L06+4)/4 ...> pre-cleaned
  paddb      mm1,mm5               ; 3I: <C37 C36 L35 L34 R33 R32 C31 C30>
   psrlq     mm0,1                 ; 0Q: P0 = <(4C07+2A07+2L07+4)/8
   ;                               ;           (5C06+2A06+L06+4)/8 ...>
  movdt      mm5,[edi+16]          ; 2B: <  0   0   0   0 R23 R22 R21 R20>
   psubb     mm4,mm1               ; 3J: <L37 L36 C35 C34 C33 C32 R31 R30>
  punpckldq  mm5,[esi+16+4]        ; 2C: <L27 L26 L25 L24 R23 R22 R21 R20>
   paddb     mm3,mm1               ; 3K: <C37+A37 ... A35+L35 ...>
  movq       mm1,[ecx]             ; 0R: T0
   pand      mm3,mm6               ; 3L: <C37+A37 ... A35+L35 ...> pre-cleaned
  psubb      mm1,mm0               ; 0S: D0 = T0 - P0
   psrlq     mm3,1                 ; 3M: <(C37+A37)/2 ... (A35+L35)/2 ...>
  movq       mm0,CFFFF00000000FFFF ; 2D: < FF  FF  00  00  00  00  FF  FF>
   paddb     mm3,mm4               ; 3N: <(C37+A37+2L37)/2 ...
   ;                               ;      (2C35+A35+L35)/2 ...>
  movq       mm4,CentralPred+16    ; 2E: <C27 C26 C25 C24 C23 C22 C21 C20>
   pand      mm3,mm6               ; 3O: pre-cleaned
  pand       mm0,mm4               ; 2F: <C27 C26  00  00  00  00 C21 C20>
   paddb     mm4,mm5               ; 2G: <C27+L27 ... C25+L25 ...>
  pand       mm5,C0000FFFFFFFF0000 ; 2H: < 00  00 L25 L24 R23 R22  00  00>
   psrlq     mm3,1                 ; 3P: <(C37+A37+2L37)/4 ...
   ;                               ;      (2C35+A35+L35)/4 ...>
  paddb      mm3,CentralPred+24    ; 3Q: <(5C37+A37+2L37)/4 ...
  ;                                ;      (6C35+A35+L35)/4 ...>
   paddb     mm5,mm0               ; 2I: <C27 C26 L25 L24 R23 R22 C21 C20>
  psubb      mm4,mm5               ; 2J: <L27 L26 C25 C24 C23 C22 R21 R20>
   paddb     mm2,mm5               ; 2K: <C27+A27 ... A25+L25 ...>
  pand       mm2,mm6               ; 2L: <C27+A27 ... A25+L25 ...> pre-cleaned
   psubb     mm3,mm7               ; 3R: <(5C37+A37+2L37+4)/4 ...
   ;                               ;      (6C35+A35+L35+4)/4 ...>
  pand       mm3,mm6               ; 3S: pre-cleaned
   psrlq     mm2,1                 ; 2M: <(C27+A27)/2 ... (A25+L25)/2 ...>
  paddb      mm2,mm4               ; 2N: <(C27+A27+2L27)/2 ...
  ;                                ;      (2C25+A25+L25)/2 ...>
   psrlq     mm3,1                 ; 3T: P3 = <(5C37+A37+2L37+4)/8 ...
   ;                               ;           (6C35+A35+L35+4)/8 ...>
  movq       mm0,[ecx+ebp*2]       ; 2U: T2
   pand      mm2,mm6               ; 2O: pre-cleaned
  movq       mm4,[ecx+PITCH*3]     ; 3U: T3
   psrlq     mm2,1                 ; 2P: <(C27+A27+2L27)/4 ...
   ;                               ;      (2C25+A25+L25)/4 ...>
  paddb      mm2,CentralPred+16    ; 2Q: <(5C27+A27+2L27)/4 ...
  ;                                ;      (6C25+A25+L25)/4 ...>
   psubb     mm4,mm3               ; 3V: D3 = T3 - P3
  movq       PelDiffsLine0,mm1     ; 0T
   psubb     mm2,mm7               ; 2R: <(5C27+A27+2L27+4)/4 ...
   ;                               ;      (6C25+A25+L25+4)/4 ...>
  movq       PelDiffsLine3,mm4     ; 3W: Store D3.
   pand      mm2,mm6               ; 2S: pre-cleaned
  psrlq      mm2,1                 ; 2T: P2 = <(5C27+A27+2L27+4)/8 ...
  ;                                ;           (6C25+A25+L25+4)/8 ...>
   ;
  psubb      mm0,mm2               ; 2V: D2 = T2 - P2
   ;
  ;
   ;
  movq       PelDiffsLine2,mm0     ; 2W: Store D2.
   ;
  jmp        MMxDoForwardDCTy      ; Block is in PelDiffs block;  Pitch is 16

LeftEqCtr:

;  Left remote motion vector was same as center.
;  Compute right remote prediction block.

  lea        edi,PrevMBAD[eax]
  and        edi,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk to right.
   mov       esi,PrevMBAD.BlkY1.MVs
  ;
   ;
  mov        cl,[edi].BlockType
   mov       ebx,PrevMBAD[eax].BlkY1.MVs
  cmp        cl,INTRA
   je        LeftEqCtrAndRightEqCtr ; Jump if INTRA.  (Use central)

  cmp        esi,ebx
   mov       esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using right remote.
  mov        edi,PrevMBAD[eax].BlkY1.BlkOffset
   jne       RightNeCtr

;  Left and right remote motion vectors were same as center.
;  Compute central prediction block.

LeftEqCtrAndRightEqCtr:

  mov        ebx,PrevMBAD.BlkY1.MVs
   mov       esi,PrevMBAD.BlkY1.PastRef
  lea        edi,CentralPred
   mov       eax,DistToBADforBlockBelow

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  lea        ecx,PrevMBAD[eax]
  and        ecx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk below.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7             ;  . .  Restore 8 bytes of -1
  mov        bl,[ecx].BlockType
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  cmp        bl,INTRA
   mov       edi,AddrOfLeftPred
  mov        ebx,PrevMBAD[eax].BlkY1.MVs
   je        BottomHalfAllSame   ; Jump if INTRA.  (Use central)

; Compute bottom remote prediction block.

  cmp        esi,ebx
   mov       esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
  mov        eax,PrevMBAD[eax].BlkY1.BlkOffset
   je        BottomHalfAllSame

  sub        esi,eax
   lea       eax,[ecx+ebp*4]

  call       GetPredForAboveOrBelow

; Compute difference for lines 4 thru 7.  Only the remote motion vector below
; was different than the central motion vector.

                                   ; 4A: <B47 B46 B45 B44 B43 B42 B41 B40>: mm0
  movq       mm5,CentralPred+48    ; 6b: <C67 C66 C65 C64 C63 C62 C61 C60>
   pand      mm2,mm6
  movq       mm4,CentralPred+32    ; 4B: <C47 C46 C45 C44 C43 C42 C41 C40>
   psrlq     mm2,1                 ; 6a: <B67 B66 B65 B64 B63 B62 B61 B60>
  paddb      mm2,mm5               ; 6c: <C67+B67 ... C65+B65 ...>
   paddb     mm0,mm4               ; 4C: <C47+B47>
  pand       mm0,mm6               ; 4D: <C47+B47> pre-cleaned
   psrlq     mm1,1                 ; 5A: <B57 B56 B55 B54 B53 B52 B51 B50>
  pand       mm2,mm6               ; 6d: <C67+B67 ... C65+B65 ...> pre-cleaned 
   psrlq     mm0,1                 ; 4E: <(C47+B47)/2 ...>
  paddb      mm0,mm4               ; 4F: <(3C47+B47)/2 ...>
   psrlq     mm2,1                 ; 6e: <(C67+B67)/2 ... (C65+B65)/2 ...>
  pmullw     mm2,C0001000200020001 ; 6f: <(C67+B67)/2 ... (2C65+2B65)/2 ...>
   pand      mm0,mm6               ; 4G: <(3C47+B47)/2 ...> pre-cleaned
  pand       mm3,mm6
   psrlq     mm0,1                 ; 4H: <(3C47+B47)/4 ...>
  paddb      mm0,mm4               ; 4I: <(7C47+B47)/4 ...>
   psrlq     mm3,1                 ; 7A: <B77 B76 B75 B74 B73 B72 B71 B70>
  movq       mm4,C0000FFFFFFFF0000 ; 6g: < 00  00  FF  FF  FF  FF  00  00>
   psubb     mm0,mm7               ; 4J: <(7C47+B47+4)/4 ...>
  pandn      mm4,mm5               ; 6h: <C67 C66  00  00  00  00 C61 C60>
   psubb     mm5,mm7               ; 6i: <C67+1 ... C65+1 ...>
  paddb      mm2,mm4               ; 6j: <(3C67+B67)/2 ... (2C65+2B65)/2 ...>
   pand      mm0,mm6               ; 4K: <(7C47+B47+4)/4 ...> pre-cleaned
  movq       mm4,CentralPred+40    ; 5B
   pand      mm2,mm6               ; 6k: pre-cleaned
  paddb      mm1,mm4               ; 5C
   psrlq     mm0,1                 ; 4L: <(7C47+B47+4)/8 ...>
  pand       mm1,mm6               ; 5D
   psrlq     mm2,1                 ; 6l: <(3C67+B67)/4 ... (2C65+2B65)/4 ...>
  paddb      mm2,mm5               ; 6m: <(7C67+B67+4)/4 ... (6C65+2B65+4)/4...>
   psrlq     mm1,1                 ; 5E
  movq       mm5,CentralPred+56    ; 7B: <C77 C76 C75 C74 C73 C72 C71 C70>
   paddb     mm1,mm4               ; 5F
  paddb      mm3,mm5               ; 7C: <C77+B47>
   pand      mm1,mm6               ; 5G
  pand       mm3,mm6               ; 7D: <C77+B47> pre-cleaned
   psrlq     mm1,1                 ; 5H
  paddb      mm1,mm4               ; 5I
   psrlq     mm3,1                 ; 7E: <(C77+B47)/2 ...>
  psubb      mm1,mm7               ; 5J
   paddb     mm3,mm5               ; 7F: <(3C77+B47)/2 ...>
  pand       mm1,mm6               ; 5K
   psubb     mm3,mm7               ; 7G: <(3C77+B47+2)/2 ...>
  pand       mm2,mm6               ; 6n: pre-cleaned
   psrlq     mm1,1                 ; 5L
  pand       mm3,mm6               ; 7H: <(3C77+B47+2)/2 ...> pre-cleaned
   psrlq     mm2,1                 ; 6o: <(7C67+B67+4)/8 ... (6C65+2B65+4)/8...>
  psrlq      mm3,1                 ; 7I: <(3C77+B47+2)/4 ...>

BottomHalfAllSame:

   mov       ebx,TargetFrameBaseAddress
  mov        eax,DistToBADforBlockAbove
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       mm5,[ecx+ebx+PITCH*5] ; 5M
  add        ecx,ebx               ;     Address of target block.
   lea       ebx,PrevMBAD[eax]

  and        ebx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk above.
   psubb     mm5,mm1               ; 5N
  movq       mm4,[ecx+ebp*4]       ; 4M: T4
  movq       mm1,[ecx+PITCH*7]     ; 7J: T7
   psubb     mm4,mm0               ; 4N: D4 = T4 - P4
  movq       mm0,[ecx+PITCH*6]     ; 6p: T6
   psubb     mm1,mm3               ; 7K: D7 = T7 - P7
  movq       PelDiffsLine4,mm4     ; 4O: Store D4.
   psubb     mm0,mm2               ; 6q: D6 = T6 - P6
  movq       PelDiffsLine5,mm5     ; 5O
  movq       PelDiffsLine6,mm0     ; 6r
  movq       PelDiffsLine7,mm1     ; 7L
  mov        cl,[ebx].BlockType
  cmp        cl,INTRA
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  mov        ebx,PrevMBAD[eax].BlkY1.MVs
   je        SidesEqCtrAndAboveEqCtr  ; Jump if INTRA.  (Use central)

; Compute top remote prediction block.

  and        ebx,00000FFFFH     ; Blk above may have B MVs set.  Clear them.
  cmp        esi,ebx
   mov       esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
  mov        eax,PrevMBAD[eax].BlkY1.BlkOffset
   jne       SidesEqCtrButAboveNeCtr

SidesEqCtrAndAboveEqCtr:

  movq       mm0,CentralPred
  movq       mm1,CentralPred+8
   paddb     mm0,mm0
  movq       mm2,CentralPred+16
   paddb     mm1,mm1
  movq       mm3,CentralPred+24
   paddb     mm2,mm2
  jmp        TopHalfAllSame

SidesEqCtrButAboveNeCtr:

  sub        esi,eax
   mov       eax,ecx

  call       GetPredForAboveOrBelow

; Compute difference for lines 0 thru 3.  Only the remote motion vector above
; was different than the central motion vector.

  movq       mm5,CentralPred+8     ; 1b
   pand      mm3,mm6
  movq       mm4,CentralPred+24    ; 3B
   psrlq     mm3,1                 ; 3A
  paddb      mm3,mm4               ; 3C
   psrlq     mm1,1                 ; 1A
  paddb      mm1,mm5               ; 1c
   pand      mm3,mm6               ; 3D
  pand       mm1,mm6               ; 1d
   psrlq     mm3,1                 ; 3E
  paddb      mm3,mm4               ; 3F
   psrlq     mm1,1                 ; 1e
  pmullw     mm1,C0001000200020001 ; 1f
   pand      mm3,mm6               ; 3G
  pand       mm2,mm6
   psrlq     mm3,1                 ; 3H
  paddb      mm3,mm4               ; 3I
   psrlq     mm2,1                 ; 2a
  movq       mm4,C0000FFFFFFFF0000 ; 1g
   psubb     mm3,mm7               ; 3J
  pandn      mm4,mm5               ; 1h
   psubb     mm5,mm7               ; 1i
  paddb      mm1,mm4               ; 1j
   pand      mm3,mm6               ; 3K
  movq       mm4,CentralPred+16    ; 2B
   pand      mm1,mm6               ; 1k
  paddb      mm2,mm4               ; 2C
   psrlq     mm3,1                 ; 3L
  pand       mm2,mm6               ; 2D
   psrlq     mm1,1                 ; 1l
  paddb      mm1,mm5               ; 1m
   psrlq     mm2,1                 ; 2E
  movq       mm5,CentralPred       ; 0B
   paddb     mm2,mm4               ; 2F
  paddb      mm0,mm5               ; 0C
   pand      mm2,mm6               ; 2G
  pand       mm0,mm6               ; 0D
   psrlq     mm2,1                 ; 2H
  paddb      mm2,mm4               ; 2I
   psrlq     mm0,1                 ; 0E
  psubb      mm2,mm7               ; 2J
   paddb     mm0,mm5               ; 0F
  pand       mm2,mm6               ; 2K
   psubb     mm0,mm7               ; 0G

TopHalfAllSame:

  mov        ebx,TargetFrameBaseAddress
  lea        edi,[ecx+ebx]
   pand      mm1,mm6               ; 1n
  movq       mm7,[ecx+ebx]         ; 0J
   pand      mm0,mm6               ; 0H
  movq       mm5,[edi+PITCH*3]     ; 3M
   psrlq     mm2,1                 ; 2L
  movq       mm4,[edi+ebp*2]       ; 2M
   psubb     mm5,mm3               ; 3N
  psubb      mm4,mm2               ; 2N
   psrlq     mm1,1                 ; 1o
  movq       mm3,[edi+ebp*1]       ; 1p
   psubb     mm3,mm1               ; 1q
  movq       PelDiffsLine3,mm5     ; 3O
   psrlq     mm0,1                 ; 0I
  movq       PelDiffsLine2,mm4     ; 2O
   psubb     mm7,mm0               ; 0K
  movq       PelDiffsLine1,mm3     ; 1r
  movq       PelDiffsLine0,mm7     ; 0L
  jmp        MMxDoForwardDCTy      ; Block is in PelDiffs block;  Pitch is 16

;=============================================================================
; This internal function computes the OBMC contribution for the reference
; block that uses the left, central, or right remote motion vector.
;
;  ebp -- PITCH
;  edi -- Address of where to put the contribution.
;  esi -- Address of reference block.
;  edx -- Reserved.  MBlockActionStream
;  ecx -- Unavailable.
;  ebx -- Scratch.  Initially the horizontal and vertical motion vectors.
;  eax -- Unavailable.
;  mm7 -- 8 bytes of -1
;  mm6 -- 8 bytes of 0xFE
;  mm0-mm5 -- Scratch

StackOffset TEXTEQU <12_ButAccessToLocalVariablesShouldNotBeNeeded>

GetPredForCenterLeftOrRight:

  shr        ebx,1
   jc        HorzInterpInCLRPred
  
  movq       mm1,[esi+ebp*1]
  and        bl,080H
   je        NoInterpInCLRPred

VertInterpInCLRPred:

  movq       mm0,[esi]
   psubb     mm1,mm7

  call       Get4LinesOfPred_InterpVert

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+0],mm0
   pand      mm3,mm6
  movq       [edi+8],mm1
   psrlq     mm2,1
  movq       mm1,[esi+ebp*1]
   psrlq     mm3,1
  movq       [edi+16],mm2
   movq      mm0,mm4
  movq       [edi+24],mm3
   psubb     mm1,mm7
  jmp        Get4MoreLinesOfPred_InterpVert

HorzInterpInCLRPred:
  
  movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  and        bl,080H
   jne       BothInterpInCLRPred

  call       Get4LinesOfPred_InterpHorz

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+0],mm0
   pand      mm3,mm6
  movq       [edi+8],mm1
   psrlq     mm2,1
  movq       mm5,[esi+1]         ; <R48 R47 R46 R45 R44 R43 R42 R41>
   psrlq     mm3,1
  movq       [edi+16],mm2
   ;
  movq       [edi+24],mm3
   ;
  jmp        Get4MoreLinesOfPred_InterpHorz

BothInterpInCLRPred:

  call       Get4LinesOfPred_InterpBoth

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+0],mm0
   pand      mm3,mm6
  movq       [edi+8],mm1
   psrlq     mm2,1
  movq       mm1,[esi+ebp*1]
   psrlq     mm3,1
  movq       [edi+16],mm2
   movq      mm0,mm4
  movq       [edi+24],mm3
   psubb     mm1,mm7
  paddb      mm5,mm5
   jmp       Get4MoreLinesOfPred_InterpBoth

NoInterpInCLRPred:

  movq       mm0,[esi]
  movq       mm2,[esi+ebp*2]
  movq       mm3,[esi+PITCH*3]
  movq       [edi+0],mm0
  movq       [edi+8],mm1
  movq       [edi+16],mm2
  movq       [edi+24],mm3
  movq       mm3,[esi+PITCH*7]
  movq       mm2,[esi+PITCH*6]
   paddb     mm3,mm3
  movq       mm1,[esi+PITCH*5]
   paddb     mm2,mm2
  movq       mm0,[esi+ebp*4]
   paddb     mm1,mm1
  ret

;=============================================================================
; This internal function computes the OBMC contribution for the reference
; block that uses the remote motion vector from block above or below.
;
;  ebp -- PITCH
;  edi -- Not used.
;  esi -- Address of reference block (after ecx is added in).
;  edx -- Reserved.  MBlockActionStream
;  ecx -- Unavailable.  Must not be changed.
;  ebx -- Scratch.  Initially the horizontal and vertical motion vectors.
;  eax -- Offset within frame for block being worked on.
;  mm7 -- 8 bytes of -1
;  mm6 -- 8 bytes of 0xFE
;  mm0-mm5 -- Scratch

GetPredForAboveOrBelow:

  shr        ebx,1
   lea       esi,[esi+eax]
  jc         HorzInterpInABPred
  
  movq       mm1,[esi+ebp*1]
  movq       mm0,[esi]
   psubb     mm1,mm7
  and        bl,080H
   jne       Get4LinesOfPred_InterpVert

  movq       mm2,[esi+ebp*2]
   paddb     mm1,mm7
  movq       mm3,[esi+PITCH*3]
   paddb     mm1,mm1
  paddb      mm2,mm2
   paddb     mm3,mm3
  ret

HorzInterpInABPred:
  
  movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  and        bl,080H
   jne       Get4LinesOfPred_InterpBoth

  jmp        Get4LinesOfPred_InterpHorz

StackOffset TEXTEQU <0>
;=============================================================================
ENDIF

Done:

IFDEF H261
ELSE; H263
  mov        bl,PendingOBMC
   mov       cl,INTER1MV
  test       bl,bl
   je        TrulyDone

  mov        StashBlockType,cl

  call       DoPendingOBMCDiff

  mov        al,IsPlainPFrame
   add       edx,-SIZEOF T_MacroBlockActionDescr
  test       al,al
   jne       TrulyDone

  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

ENDIF
TrulyDone:

  emms
IFDEF H261
  mov        eax,SWDTotal
  mov        esp,StashESP
  mov        edi,[esp+PSWDTotal]
  mov        [edi],eax
ELSE
  mov        eax,SWDTotal
   mov       ebx,BSWDTotal
  mov        esp,StashESP
  mov        edi,[esp+PSWDTotal]
   mov       esi,[esp+PBSWDTotal]
  mov        [edi],eax
   mov       [esi],ebx
ENDIF
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  rturn

MMxEDTQ endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\memmodel.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\memmodel.inv   1.1   27 Dec 1995 14:36:24   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\memmodel.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:24   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF memmodel_inc
ELSE

IFDEF WIN32
.486
.MODEL FLAT, STDCALL
Zd EQU <>
Ze EQU <>
Zf EQU <>
Zg EQU <>
Zs EQU <>
Zc EQU <>
BPTR equ ebp
SPTR equ esp
NAT_WORD TEXTEQU <DWORD>

ELSE

.MODEL MEDIUM
.486
Zd EQU <ds:>
Ze EQU <es:>
Zf EQU <fs:>
Zg EQU <gs:>
Zs EQU <ss:>
Zc EQU <cs:>
BPTR equ bp
SPTR equ sp
NAT_WORD TEXTEQU <WORD>

ENDIF

PD EQU <DWORD PTR>
PW EQU <WORD PTR>
PB EQU <BYTE PTR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; this provides a normal return when under WIN32 and
;; a 16 bit mode instruction override when under not WIN32
;;
;; This is needed as the segment this code runs in is
;; in 32 bit mode but the caller is in 16 bit mode.
;;
;; under WIN32, we must relieve the stack of passed
;; args, and with proper setup of the PROC directive,
;; the assembler will calculate the correct value
;; to relieve every time it sees the ret.
;;
;; this also sets the language to 'C' when not under WIN32 and
;; stdcall when under WIN32
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifdef WIN32
LANG    TEXTEQU <stdcall>
DIST    TEXTEQU <>
rturn   MACRO
	ret
ENDM
else
LANG    TEXTEQU <C>
DIST    TEXTEQU <FAR>
rturn   MACRO
	db      66h
	retf
ENDM
endif

memmodel_inc=1

; this is intended to emulate a disabled epilouge with the single
; exception of relieving the stack of passed parameters if
; the calling type is STDCALL.
;
; only stdcall and c calling conventions are directly supported.
; VARARGS is not supported.
; NONE of the standard prologue or epilogue switches
; are used.
; Like the standard epilogue, the use of retf, retn or ret n
; where n is the number of bytes to relieve, this macro
; is effectively disabled.
ReturnAndRelieveEpilogueMacro MACRO procname, \
                                    flag,     \
                                    parmbytes, \
                                    localbytes, \
                                    reglist, \
                                    macroargs
LOCAL RET_DIST
if (flag AND 020h)
; We are in a FAR procedure
	RET_DIST TEXTEQU <retf>
else
; We are in a local procedure
	RET_DIST TEXTEQU <ret>
endif

if (flag AND 010h)
; user restoring the stack: ret n, retf or retn was used
	RET_DIST
else
; user expects us to restore the stack: ret was used
if (flag AND 007h) EQ 3
; stdcall calling convention
if parmbytes EQ 0
	RET_DIST
else
	RET_DIST		parmbytes
endif
else
; assume 'C' calling convention
	RET_DIST
endif

endif
ENDM

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\bib_32.c ===
#ifdef _X86_
void PassLow8(short *vin,short *vout,short *mem,short nech)
{
	short low_a;

	_asm
	{
		MOV	ESI,[vin]       		; SI  adress input samples
		MOV	CX,[nech]

	BP_LOOP:
		MOV	EBX,0
		MOV	WORD PTR [low_a],0
		MOV	EDI,[mem]      		; DI  adress mem vect.
		ADD	EDI,14			; point on mem(7)

		MOV	AX,-3126		; AX=c(8)
		IMUL	WORD PTR [EDI]		; *=mem(7)
		SUB	WORD PTR [low_a],AX	; accumulate in EBX:LOW_A
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2			; mem--

		MOV	AX,-22721		; AX=c(7)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,-12233		; AX=c(6)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,11718		; AX=c(5)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,-13738		; AX=c(4)
		IMUL    WORD PTR [EDI]
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,-26425		; AX=c(3)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	DX,WORD PTR [EDI]	; c(2)=0 !
		MOV	WORD PTR [EDI+2],DX
		SUB	EDI,2

		MOV	AX,26425		; AX=c(1)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		MOV	AX,13738		; AX=c(0)
		MOV	DX,WORD PTR [ESI]	; *=input !!!
		ADD	ESI,2
		MOV	WORD PTR [EDI],DX	; DI=mem(0)
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		SAL	EBX,1
		MOV	[EDI+8],BX

		MOV	EDI,[vout]
		MOV	[EDI],BX

		ADD	DWORD PTR [vout],2		; vout++

		DEC	CX
		JNE     BP_LOOP
	}
}
#else
void PassLow8(short *vin,short *vout,short *mem,int nech)
{
	int j,k;
	long X;

	for (j=nech;j>0;j--)
	{
		X = 0;
		X -=   (((long)-3126*(long)mem[7])+
			((long)-22721*(long)mem[6])+
			((long)-12233*(long)mem[5])+
			((long)11718*(long)mem[4]))>>1;

		X +=   (((long)-13738*(long)mem[3])+
			((long)-26425*(long)mem[2])+
			((long)26425*(long)mem[0])+
			((long)13738*(long)(*vin)))>>1;

		mem[7]=mem[6];
		mem[6]=mem[5];
		mem[5]=mem[4];
		mem[4]=(int)(X>>14);
		mem[3]=mem[2];
		mem[2]=mem[1];
		mem[1]=mem[0];
		mem[0]=*vin++;
		*vout++=mem[4];
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void PassLow11(short *vin,short *vout,short *mem,short nech)
{
	short low_a;

	_asm
	{
		MOV	ESI,[vin]       		; ESI  adress input samples
		MOV	CX,[nech]

	BP11_LOOP:
		MOV	EBX,0
		MOV	WORD PTR [low_a],0
		MOV	EDI,[mem]      		; EDI  adress mem vect.
		ADD	EDI,14			; point on mem(7)

		MOV	AX,3782			; AX=c(8)
		IMUL	WORD PTR [EDI]		; *=mem(7)
		SUB	WORD PTR [low_a],AX	; accumulate in EBX:low_a
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2			; mem--

		MOV	AX,-8436		; AX=c(7)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,17092		; AX=c(6)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,-10681		; AX=c(5)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,1179			; AX=c(4)
		IMUL    WORD PTR [EDI]
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,4280			; AX=c(3)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,6208			; AX=c(3)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,4280			; AX=c(1)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		MOV	AX,1179			; AX=c(0)
		MOV	DX,WORD PTR [ESI]	; *=input !!!
		ADD	ESI,2
		MOV	WORD PTR [EDI],DX	; EDI=mem(0)
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		SAL	EBX,2
		MOV	[EDI+8],BX

		MOV	EDI,[vout]
		MOV	[EDI],BX

		ADD	WORD PTR [vout],2		; vout++

		DEC	CX
		JNE     BP11_LOOP
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void PassHigh8(short *mem, short *Vin, short *Vout, short lfen)
{

	_asm
	{
		MOV	CX,[lfen]		;CX=cpteur

		MOV	EDI,[mem]

	PH8_LOOP:
		MOV	ESI,[Vin]
		MOV	BX,WORD PTR [ESI]        ;BX=Xin
		MOV	AX,WORD PTR [EDI]	;AX=z(1)
		MOV	WORD PTR [EDI],BX        ;mise a jour memoire
		SUB	BX,AX                   ;BX=Xin-z(1)
		ADD	WORD PTR [Vin],2     ;pointer echant svt
		MOV	AX,WORD PTR [EDI+2]	;AX=z(2)
		MOV	DX,30483		;DX=0.9608
		IMUL	DX
		ADD	AX,16384
		ADC	DX,0                    ;arrondi et dble signe
		SHLD	DX,AX,1
		ADD	DX,BX			;reponse=DX=tmp
		MOV	WORD PTR [EDI+2],DX      ;mise a jour memoire
		MOV	ESI,[Vout]
		MOV	WORD PTR [ESI],DX     	;output=tmp
		ADD	WORD PTR [Vout],2  	;pointer echant svt
		DEC	CX
		JNE	PH8_LOOP
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void PassHigh11(short *mem, short *Vin, short *Vout, short lfen)
{
	_asm
	{
		MOV	CX,[lfen]		;CX=cpteur

		MOV	EDI,[mem]

	PH11_LOOP:
		MOV	ESI,[Vin]
		MOV	BX,WORD PTR [ESI]        ;BX=Xin
		MOV	AX,WORD PTR [EDI]	;AX=z(1)
		MOV	WORD PTR [EDI],BX        ;mise a jour memoire
		SUB	BX,AX                   ;BX=Xin-z(1)
		ADD	WORD PTR [Vin],2  	;pointer echant svt
		MOV	AX,WORD PTR [EDI+2]	;AX=z(2)
		MOV	DX,30830		;DX=0.9714
		IMUL	DX
		ADD	AX,16384
		ADC	DX,0                    ;arrondi et dble signe
		SHLD	DX,AX,1
		ADD	DX,BX			;reponse=DX=tmp
		MOV	WORD PTR [EDI+2],DX      ;mise a jour memoire
		MOV	ESI,[Vout]
		MOV	WORD PTR [ESI],DX     	;output=tmp
		ADD	WORD PTR [Vout],2  	;pointer echant svt
		DEC	CX
		JNE	PH11_LOOP
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void Down11_8(short *Vin, short *Vout, short *mem)
{
	short low_a, count;

	_asm
	{
		MOV	WORD PTR [count],176
		MOV	ESI,[Vin]
		MOV	EDI,[Vout]

		MOV	CX,[ESI]			; *mem=*in

	DOWN_LOOP:
		MOV	[EDI],CX
		ADD	EDI,2
		ADD	ESI,2

		MOV	AX,7040
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,2112
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-960
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,3584
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,5376
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-768
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	ESI,2
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,8064
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,576
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-448
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,6144
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,3072
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-1024
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,1920
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,6720
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-448
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	ESI,2
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,7680
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,1280
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-768
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,4992
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,4160
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-960
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	ESI,4
		MOV	CX,[ESI]
		ADD	EDI,2

		SUB	WORD PTR [count],11
		JNE	DOWN_LOOP

		SUB	ESI,2
		MOV	EBX,[mem]
		MOV	CX,[ESI]
		MOV	[EBX],CX			; *memory=*(++ptr_in)
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void Up8_11(short *Vin, short *Vout, short *mem1, short *mem2)
{
	short low_a, count;

	_asm
	{
		MOV	WORD PTR [count],128
		MOV	ESI,[Vin]

		MOV	EBX,[mem1]
		MOV	CX,[EBX]		;CX=memo
		MOV	EDI,[mem2]

		MOV	AX,7582
		IMUL	CX
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,1421
		IMUL	WORD PTR [ESI]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-812
		IMUL	WORD PTR [EDI]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	EDI,[Vout]
		MOV	[EDI],AX
		ADD	EDI,2

	UP_LOOP:
		MOV	AX,[ESI]
		MOV	[EDI],AX
		ADD	EDI,2

		MOV	AX,3859
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,5145
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-812
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,6499
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,2708
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-1015
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,7921
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,880
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-609
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	EDI,2

		MOV	AX,1421
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,7108
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-338
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,4874
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,4265
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-947
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,7108
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,2031
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-947
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,8124
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,406
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-338
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	EDI,2

		MOV	AX,2708
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,6093
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-609
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,5754
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,3452
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-1015
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		CMP	WORD PTR [count],8
		JE	END_OF_LOOP

		MOV	AX,7582
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,1421
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-812
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2



	END_OF_LOOP:
		SUB	WORD PTR [count],8
		JNE	UP_LOOP

		MOV	EBX,[mem2]
		MOV	CX,[ESI-2]
		MOV	[EBX],CX			; *memory2=*(ptr_in-1)
		MOV	EBX,[mem1]
		MOV	CX,[ESI]
		MOV	[EBX],CX			; *memory=*(ptr_in)
	}
}
#endif

#ifdef _X86_
void QMFilter(short *input,short *coef,short *out_low,short *out_high,
		     short *mem,short lng)
{
	long R1,R0;
	
	_asm
	{

	QMF_LOOP:
		MOV	ESI,[input]		; ES:SI for input
		MOV	EBX,[mem]		; DS:BX for memory
		MOV	AX,WORD PTR [ESI]		; AX=*input
		MOV	WORD PTR [EBX+16],AX		; *high_mem=*input
		ADD	ESI,2			; input++
		MOV	AX,WORD PTR [ESI]		; AX=*input
		MOV	WORD PTR [EBX],AX		; *low_mem=*input
		ADD	DWORD PTR [input],4		; input++
		MOV	DWORD PTR [R1],0	; initialize accumulation in R1
		MOV	DWORD PTR [R0],0	; initialize accumulation in R0
		MOV	ESI,[coef]	; ES:SI for ptr1
		MOV	EDI,ESI
		ADD	EDI,14			; ES:DI for ptr2
		ADD	EBX,14			; DS:BX for end of mem vector

		MOV	CX,8			; CX=count

	QMF_LOOP2:
		MOV	AX,WORD PTR [ESI]	; AX=*ptr1
		ADD	ESI,2			; ptr1++
		IMUL	WORD PTR [EBX+16]	; DX:AX *=(*high_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R1],EDX
		
		MOV	AX,WORD PTR [EDI]	; AX=*ptr0
		SUB	EDI,2			; ptr1--
		IMUL	WORD PTR [EBX]		; DX:AX *=(*low_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R0],EDX

		MOV	AX,WORD PTR [EBX-2]
		MOV	WORD PTR [EBX],AX		; *low_mem=*(low_mem-1)
		MOV	AX,WORD PTR [EBX+14]
		MOV	WORD PTR [EBX+16],AX		; *high_mem=*(high_mem-1)
		SUB	EBX,2			; *low_mem-- , *high_mem--
		DEC	CX
		JNE	QMF_LOOP2

		MOV	EAX,DWORD PTR [R0]
		SUB	EAX,DWORD PTR [R1]
		SAR	EAX,15
		MOV	EDI,[out_high]
		MOV	WORD PTR [EDI],AX	; *high_out=R0-R1
		ADD	DWORD PTR [out_high],2	; high_low++

		MOV	EAX,DWORD PTR [R0]
		ADD	EAX,DWORD PTR [R1]
		SAR	EAX,15
		MOV	EDI,[out_low]
		MOV	WORD PTR [EDI],AX	; *low_out=R0+R1
		ADD	DWORD PTR [out_low],2	; low_out++

		DEC	WORD PTR [lng]
		JNE     QMF_LOOP
	}
}
#else
void QMFilter(short *in,short *coef,short *out_low,short *out_high,
		     short *mem,short lng)
{
   int i,j;
   long R1,R0;
   short *ptr0,*ptr1,*high_p,*low_p;

   for (j=lng; j>0; j--)
   {
      high_p = mem+8;
      low_p = mem;

      *high_p =  *in++;
      *low_p =  *in++;

      R1=R0=0;

      ptr0 = coef; ptr1 = coef+8-1;

      for (i=8; i>0; i--)
      {
	 R1 += (long)(*ptr1--) * (long)(*high_p++);
	 R0 += (long)(*ptr0++) * (long)(*low_p++);
      }
      *out_low++ = (short)((R0+R1)>>15);
      *out_high++ = (short)((R0-R1)>>15);

      for (i=8; i>0; i--)
      {
	 high_p--; low_p--;
	 *high_p = *(high_p-1); *low_p = *(low_p-1);
      }
   }
}

#endif

#ifdef _X86_
void QMInverse(short *in_low,short *in_high,short *coef,
			short *output,short *mem,short lng)
{
	long R0,R1;

	_asm
	{
	QMI_LOOP:
		MOV	ESI,[in_low]		; ES:SI for input low
		MOV	EDI,[in_high]		; ES:DI for input high
		MOV	EBX,[mem]		; DS:BX for memory
		MOV	AX,WORD PTR [ESI]
		SUB	AX,WORD PTR [EDI]	; AX=*in_low-*in_high
		MOV     WORD PTR [EBX],AX	; *low_mem=*in_low-*in_high
		MOV	AX,WORD PTR [ESI]
		ADD	AX,WORD PTR [EDI]	; AX=*in_low+*in_high
		MOV     WORD PTR [EBX+16],AX	; *high_mem=*in_low+*in_high

		ADD	DWORD PTR [in_low],2	; in_low++
		ADD	DWORD PTR [in_high],2	; in_high++
		MOV	DWORD PTR [R0],0
		MOV	DWORD PTR [R1],0
		MOV	ESI,[coef]	; ES:SI for ptr1
		MOV	EDI,ESI
		ADD	EDI,14			; ES:DI for ptr2
		ADD	EBX,14			; DS:BX for end of mem vector

		MOV	CX,8			; DX=count
	QMI_LOOP2:
		MOV	AX,WORD PTR [ESI]	; AX=*ptr1
		ADD	ESI,2			; ptr1++

		IMUL	WORD PTR [EBX+16]	; DX:AX*=(*high_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R1],EDX	; Accumulate in R1

		MOV	AX,WORD PTR [EDI]	; AX=*ptr0
		SUB	EDI,2			; ptr1--
		IMUL	WORD PTR [EBX]		; DX:AX*=(*low_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R0],EDX 		; Accumulate in R0

		MOV	AX,WORD PTR [EBX-2]
		MOV	WORD PTR [EBX],AX	; *low_mem=*(low_mem-1)
		MOV	AX,WORD PTR [EBX+14]
		MOV	WORD PTR [EBX+16],AX	; *high_mem=*(high_mem-1)
		SUB	EBX,2			; *low_mem-- , *high_mem--
		DEC	CX
		JNE	QMI_LOOP2

		MOV	EDI,[output]
		MOV	EAX,DWORD PTR [R1]
		SAR	EAX,15
		MOV	WORD PTR [EDI+2],AX	; *(out+1)=R1
		MOV	EAX,DWORD PTR [R0]
		SAR	EAX,15
		MOV	WORD PTR [EDI],AX	; *out=R0
		ADD	DWORD PTR [output],4	; out++,out++

		DEC	WORD PTR [lng]
		JNE     QMI_LOOP
	}
}
#else
void QMInverse(short *in_low,short *in_high,short *coef,
		short *out,short *mem,short lng)
{
   int i,j;
   long R1,R0;
   short *ptr0,*ptr1,*high_p,*low_p;

   for (j=0; j<lng; j++)
   {
       high_p = mem+8;
       low_p = mem;

       *high_p =  *in_low + *in_high;
       *low_p =  *in_low++ - *in_high++;

       R1 = R0 = 0;
       ptr0 = coef; ptr1 = coef+8-1;

       for (i=8; i>0; i--)
       {
	  R1 += (long)(*ptr1--) * (long)(*high_p++);
	  R0 += (long)(*ptr0++) * (long)(*low_p++);
       }

       *out++ = (short)(R0>>15);
       *out++ = (short)(R1>>15);

       for (i=8; i>0; i--)
       {
	  high_p--; low_p--;
	  *high_p = *(high_p-1); *low_p = *(low_p-1);
       }
   }
}
#endif

#ifdef _X86_
void iConvert64To8(short *input, short *output, short N, short *mem)
{
	short LOW_A;

	_asm
	{
		MOV	ESI,[input]
		MOV	EDI,[output]

		MOV	AX,[ESI]
		MOV	[EDI],AX		; out[0]=in[0]

		MOV	WORD PTR [LOW_A],0
		MOV	AX,-3072
		MOV	EBX,[mem]		; BX for memory
		IMUL	word ptr [EBX]
		MOV	EBX,0
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,14336
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,21504
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+2],BX			; out[1]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-4096
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,24576
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,12288
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+4],BX			; out[2]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3072
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,30720
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,5120
		IMUL	word ptr [ESI+6]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+6],BX			; out[3]

		MOV	AX,[ESI+6]
		MOV	[EDI+8],AX		; out[4]

		MOV	CX,0
	iUPSAMP:
		ADD	CX,4
		CMP	CX,WORD PTR [N]
		JGE	iEND_UPSAMP
		ADD	ESI,8
		ADD	EDI,10

		MOV	AX,[ESI]
		MOV	[EDI],AX			; out[0]=in[0]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3072
		IMUL	word ptr [ESI-2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,14336
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,21504
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+2],BX			; out[1]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-4096
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,24576
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,12288
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+4],BX			; out[2]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3072
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,30720
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,5120
		IMUL	word ptr [ESI+6]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+6],BX			; out[3]

		MOV	AX,[ESI+6]
		MOV	[EDI+8],AX		; out[4]

		JMP	iUPSAMP

	iEND_UPSAMP:
		MOV	EBX,[mem]
		MOV	AX,[ESI+6]
		MOV	[EBX],AX		; mem[0]=in[N-1]
	}
}
#else
void iConvert64To8(short *input, /* Pointer to input buffer */
				   short *output, /* Pointer to output buffer */
				   short N,		/* Number of input samples */
				   short *mem)	/* Pointer to two word temporary storage */
{
	int i;

	/* This copies samples and replicates every 4th */
	/* (and leaves garbage at the end if not a multiple of 4 */
	for(i=0; i<N/4; i++) {
		short temp;

		*output++ = *input++;
		*output++ = *input++;
		*output++ = *input++;
		*output++ = temp = *input++;
		*output++ = temp;
	}

}
#endif

#ifdef _X86_
void iConvert8To64(short *input, short *output, short N, short *mem)
{
	short LOW_A;

	_asm
	{

		MOV	ESI,[input]
		MOV	EDI,[output]

		MOV	CX,0

	iDOWNSAMP:
		CMP	CX,WORD PTR [N]
		JGE	iEND_DOWNSAMP

		MOV	AX,[ESI]
		MOV	[EDI],AX			; out[0]=in[0]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3623
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,29200
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,7191
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+2],BX			; out[1]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3677
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,18494
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,17950
		IMUL	word ptr [ESI+6]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+4],BX			; out[2]

		MOV	AX,[ESI+8]
		MOV	[EDI+6],AX		; out[3]=in[4]

		ADD	CX,5
		ADD	SI,10
		ADD	EDI,8

		JMP	iDOWNSAMP

	iEND_DOWNSAMP:

	}
}
#else
/* Resample 8 KHz to 6.4 KHz */
void iConvert8To64(short *input,	/* Pointer to input sample buffer */
				   short *output,	/* Pointer to output sample buffer */
				   short N,			/* Count of input samples */
				   short *mem)		/* Pointer to two word temporary storage */
{
	int i;

	/* This copies 4 of every 5 samples */
	/* (and leaves garbage at the end if not a multiple of 5 */
	for(i=0; i<N/5; i++) {
		*output++ = *input++ >> 1;
		*output++ = *input++ >> 1;
		*output++ = *input++ >> 1;
		*output++ = *input++ >> 1;
		input++;
	}

}
#endif

#ifdef _X86_
void fenetre(short *src,short *fen,short *dest,short lng)
{
	_asm
	{

		MOV	ESI,[src]
		MOV     EDI,[fen]
		MOV     EBX,[dest]

		MOV	CX,[lng]     ; CX : compteur

	fen_loop:
		MOV	AX,WORD PTR [ESI]     ; AX = src
		IMUL    WORD PTR [EDI]        ; DX:AX = src*fen
		ADD     AX,16384
		ADC     DX,0                    ; arrondi
		SHLD    DX,AX,1
		MOV     WORD PTR [EBX],DX
		ADD     ESI,2
		ADD     EDI,2
		ADD     EBX,2
		DEC	CX
		JNE	fen_loop
	}
}
#else
/* Window the data in buffer */
/* not tested - tfm */
void fenetre(short *src,short *fen,short *dest,short lng)
{
	int i;

	for(i=0; i<lng; i++) {
		*dest++ = *src++ * *fen++;
	}
}

#endif


#ifdef _X86_
void autocor(short *vech,long *ri,short nech,short ordre)
{
	short low_a,compta;

	_asm
	{
		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons
		MOV     BX,[nech]
		MOV     WORD PTR [low_a],0
		MOV     ECX,0

	DYNAMIC:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    AX             ; DX:AX = xi*xi
		ADD     [low_a],AX
		MOVSX   EAX,DX
		ADC     ECX,EAX         ;accumuler sur 48 bits
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB	BX,1
		JG      DYNAMIC

		MOV     EDI,[ri]         ;ES:DI  adresse vect. autocorr.

		MOV     EAX,ECX
		SAR     EAX,15
		ADD     AX,0
		JZ      FORMAT_OK

	;RISK_OV:
		MOV     AX,[low_a]
		ADD     AX,8
		ADC     ECX,0
		SAR     AX,4
		AND     AX,0FFFH

		SAL     ECX,12
		OR      CX,AX
		MOV     DWORD PTR [EDI],ECX     ;Sauvegarder R(0)

		MOVSX   EAX,[ordre]
		SAL	EAX,2
		ADD     EDI,EAX           ;Pointer dernier lment du vect. autoc.

	ATCROV1:
		MOV     CX,[nech]       ;Charger nombre de points vect. source
		SUB     CX,[ordre]    ;Dcrmenter de l'ordre de corrlation
		MOV     [compta],CX

		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons
		MOVSX   EBX,[ordre]
		ADD     EBX,EBX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     ECX,0
		MOV     WORD PTR [low_a],0	; //SS:

	ATCROV2:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    WORD PTR [ESI+EBX] ;Multiplier par l'lment dcal
		ADD     [low_a],AX
		MOVSX   EAX,DX
		ADC     ECX,EAX
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB     WORD PTR [compta],1		; //SS:
		JG      ATCROV2

		MOV     AX,[low_a]
		ADD     AX,8
		ADC     ECX,0
		SAR     AX,4
		AND     AX,0FFFH

		SAL     ECX,12
		OR      CX,AX
		MOV     DWORD PTR [EDI],ECX     ;Sauvegarder rsultat
		SUB     EDI,4            ;Pointer autocor. prcdant
		SUB     WORD PTR [ordre],1   ;Test de fin de boucle //SS:
		JG      ATCROV1

		JMP     FIN_ATCR

	FORMAT_OK:
		SAL     ECX,16
		MOV     CX,[low_a]
		MOV     DWORD PTR [EDI],ECX     ;Sauvegarder R(0)
		MOVSX   EAX,WORD PTR [ordre]
		SAL     EAX,2
		ADD     EDI,EAX           ;Pointer dernier lment du vect. autoc.

	ATCR10:
		MOV     CX,[nech]       ;Charger nombre de points vect. source
		SUB     CX,[ordre]    ;Dcrmenter de l'ordre de corrlation
		MOV     [compta],CX

		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons
		MOVSX	EBX,[ordre]
		ADD     EBX,EBX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     CX,0
		MOV     WORD PTR [low_a],0		;//SS:

	ATCR20:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    WORD PTR [ESI+EBX] ;Multiplier par l'lment dcal
		ADD     [low_a],AX
		ADC     CX,DX
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB     WORD PTR [compta],1		;//SS:
		JG      ATCR20

		MOV     AX,[low_a]
		MOV     WORD PTR [EDI],AX      ;Sauvegarder rsultat
		MOV     WORD PTR [EDI+2],CX

		SUB     EDI,4            ;Pointer autocor. prcdant
		SUB     WORD PTR [ordre],1   ;Test de fin de boucle
		JG      ATCR10

	FIN_ATCR:

	}	// _asm
}
#else
void autocor(short *vech,long *ri,short nech,short ordre)
{
	// TODO: Fill this in
}
#endif

#ifdef _X86_
short max_autoc(short *vech,short nech,short debut,short fin)
{
	short max_pos,max_l,compta;
	long lmax_h;

	_asm
	{
		MOV     WORD PTR [max_pos],69
		MOV     DWORD PTR [lmax_h],-6969
		MOV     WORD PTR [max_l],69

	M_ATCR1:
		MOV     CX,[nech]      ;Charger nombre de points vect. source
		MOVSX   EBX,WORD PTR [fin]
		SUB     CX,BX           ;Dcrmenter de l'ordre de corrlation
		MOV     [compta],CX

		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons

		ADD     EBX,EBX           ;Dfinir un Deplacement d'adresse vect. source

		MOV     ECX,0
		MOV     DI,0;

	M_ATCR2:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    WORD PTR [ESI+EBX] ;Multiplier par l'lment dcal
		ADD     DI,AX
		MOVSX   EAX,DX
		ADC     ECX,EAX
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB     WORD PTR [compta],1
		JG      M_ATCR2

		MOV     BX,[max_l]
		SUB     BX,DI

		MOV     EDX,[lmax_h]
		SBB     EDX,ECX

		JGE     NEXT_ITR

		MOV     [max_l],DI                 ;save max
		MOV     [lmax_h],ECX
		MOV     AX,[fin]
		MOV     [max_pos],AX

	NEXT_ITR:
		MOV     CX,[fin]                 ;Test de fin de boucle
		SUB     CX,1
		MOV     [fin],CX
		SUB     CX,[debut]
		JGE     M_ATCR1

	}

	// MOV     AX,[max_pos]
	return max_pos;
}
#else
short max_autoc(short *vech,short nech,short debut,short fin)
{
		// TODO need 64-bit
	return 0;
}
#endif


#ifdef _X86_
#pragma warning(disable : 4035)
short max_vect(short *vech,short nech)
{

	_asm
	{
		MOV     CX,[nech]      ;Charger nombre de points vect. source
		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons

		MOV     AX,-32767       ; AX = maximum

	L_M_VECT:
		MOV     BX,WORD PTR [ESI]     ;Charger elem. vect.
		ADD     BX,0
		JGE     BX_POSIT
		NEG     BX

	BX_POSIT:
		CMP     BX,AX
		JLE     NEXT_VALUE
		MOV     AX,BX

	NEXT_VALUE:
		ADD     ESI,2
		DEC	CX
		JNE	L_M_VECT
	}

}
#pragma warning(default : 4035)

void upd_max(long *corr_ene,long *vval,short pitch)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EDI,[vval]        ; ES:DI  maximum.


		MOV     EAX,DWORD PTR [ESI+8]    ; AX = partie haute de ener
		SAR     EAX,15
		ADD     AX,0
		JE      FORMA32

		MOV     EAX,DWORD PTR [ESI]            ;EAX = corr. high
		MOV     BX,WORD PTR [ESI+4]
		ADD     BX,8
		ADC     EAX,0
		SAR     BX,4
		AND     BX,0FFFH
		SAL     EAX,12
		OR      AX,BX
		ADD     EAX,0
		JGE     CORR_POSIT
		NEG     EAX

	CORR_POSIT:
		MOV     DWORD PTR [ESI+16],EAX

		MOV     EBX,DWORD PTR [ESI+8]
		MOV     DX,WORD PTR [ESI+12]
		ADD     DX,8
		ADC     EBX,0
		SAR     DX,4
		AND     DX,0FFFH
		SAL     EBX,12
		OR      BX,DX
		MOV     DWORD PTR [ESI+20],EBX
		MOV     ECX,4
		JMP     DEB_COMP

	FORMA32:
		MOV     ECX,0            ; init normalisat.
		MOV     AX,WORD PTR [ESI]
		SAL     EAX,16
		MOV     AX,WORD PTR [ESI+4]
		ADD     EAX,0
		JGE     CORR_POSIT2
		NEG     EAX

	CORR_POSIT2:
		MOV     DWORD PTR [ESI+16],EAX
		MOV     BX,WORD PTR [ESI+8]
		SAL     EBX,16
		MOV     BX,WORD PTR [ESI+12]
		MOV     DWORD PTR [ESI+20],EBX

	DEB_COMP:
					; EAX = correl.
					; EBX = ener
		ADD     EBX,0
		JE      ENER_NULL

		MOV     DX,WORD PTR [ESI+22]
		ADD     DX,WORD PTR [ESI+18]
		JG      GT16BIT

	;FORM_16:
		SAL     EBX,15
		SAL     EAX,15
		SUB     ECX,15
	GT16BIT:
		ADD     EAX,0
		JE      ENER_NULL
		CMP     EBX,40000000H
		JGE     NO_E_NORMU
	NORM_ENEU:
		ADD     EBX,EBX
		INC     ECX
		CMP     EBX,40000000H
		JL      NORM_ENEU

	NO_E_NORMU:
		CMP     EAX,40000000H      ; normaliser acc
		JGE     PAS_D_N_C

	NORM_CORL:
		ADD     EAX,EAX
		SUB     ECX,2
		CMP     EAX,40000000H
		JL      NORM_CORL
	PAS_D_N_C:
		IMUL    EAX             ;EDX:EAX = produit
		CMP     EDX,20000000H
		JLE     MAKE_DIVU

		SHRD    EAX,EDX,1
		SAR     EDX,1
		INC     ECX

	MAKE_DIVU:
		IDIV    EBX
		CMP     EAX,40000000H
		JGE     SAVE_RAPP

	NORM_RAPP:
		ADD     EAX,EAX
		DEC     ECX
		CMP     EAX,40000000H
		JLE     NORM_RAPP

	SAVE_RAPP:
		MOV     EBX,DWORD PTR [EDI+4]
		CMP     ECX,EBX
		JG      UPDATE_M
		JL      ENER_NULL

	;EBX_EQU_ECX:
		MOV     EBX,DWORD PTR [EDI]
		CMP     EAX,EBX
		JLE     ENER_NULL

	UPDATE_M:
		MOV     DWORD PTR [EDI],EAX          ; sauver mant. et exp. max
		MOV     DWORD PTR [EDI+4],ECX

		MOV     EAX,DWORD PTR [ESI+16]
		MOV     EDX,DWORD PTR [ESI]
		ADD     EDX,0
		JGE     SIGNE_OK
		NEG     EAX
	SIGNE_OK:
		MOV     DWORD PTR [EDI+8],EAX
		MOV     EAX,DWORD PTR [ESI+20]
		MOV     DWORD PTR [EDI+12],EAX

		MOVSX   EAX,WORD PTR [pitch]
		MOV     DWORD PTR [EDI+16],EAX

	ENER_NULL:

	}
}


#pragma warning(disable : 4035)

short upd_max_d(long *corr_ene,long *vval)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EDI,[vval]        ; ES:DI  maximum.

		MOV     AX,0
		MOV     EBX,DWORD PTR [ESI+4]    ;EBX = ener
		ADD     EBX,0
		JE      ENER_ZRO

		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr.
		SAL     EAX,10           ; 12 initialement
		IMUL    EAX              ; EDX:EAX = corr*corr

		IDIV    EBX              ; EAX = corr*corr/ener

		MOV     ECX,EAX
		MOV     AX,0
		MOV     EDX,DWORD PTR [EDI]      ; EDX = GGmax
		CMP     ECX,EDX
		JLE     ENER_ZRO
		MOV     DWORD PTR [EDI],ECX       ; save max
		MOV     DWORD PTR [EDI+8],EBX
		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr.
		MOV     DWORD PTR [EDI+4],EAX
		MOV     AX,7FFFH
	ENER_ZRO:
	}
}
#pragma warning(default : 4035)

void norm_corrl(long *corr,long *vval)
{
	_asm
	{
		MOV     ESI,[corr]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[vval]        ; ES:DI  adresse acc et ener.

		MOV     EAX,DWORD PTR [EDI+8]    ; AX = partie haute de ener
		SAR     EAX,15
		ADD     AX,0
		JE      FORM_32

		MOV     EAX,DWORD PTR [EDI]
		MOV     BX,WORD PTR [EDI+4]
		ADD     BX,32
		ADC     EAX,0
		SAR     BX,5
		AND     BX,07FFH
		SAL     EAX,11            ;
		OR      AX,BX
		MOV     DWORD PTR [EDI+16],EAX

		MOV     EBX,DWORD PTR [EDI+8]
		MOV     DX,WORD PTR [EDI+12]
		ADD     DX,32
		ADC     EBX,0
		SAR     DX,5
		AND     DX,07FFH
		SAL     EBX,11           ;
		OR      BX,DX
		MOV     DWORD PTR [EDI+20],EBX
		MOV     ECX,5
		JMP     DEB_PROC

	FORM_32:
		MOV     ECX,0            ; init normalisation
		MOV     AX,WORD PTR [EDI]
		SAL     EAX,16
		MOV     AX,WORD PTR [EDI+4]
		MOV     DWORD PTR [EDI+16],EAX

		MOV     BX,WORD PTR [EDI+8]
		SAL     EBX,16
		MOV     BX,WORD PTR [EDI+12]
		MOV     DWORD PTR [EDI+20],EBX

	DEB_PROC:
		ADD     EAX,0			;EAX = acc
		JLE     CORR_LE_0

		CMP     EBX,40000000H
		JGE     NO_E_NORM

	NORM_ENE:
		ADD     EBX,EBX
		INC     ECX
		CMP     EBX,40000000H
		JL      NORM_ENE

	NO_E_NORM:
		CMP     EAX,40000000H      ; normaliser acc
		JGE     PAS_D_NORM

	NORM_ACC:
		ADD     EAX,EAX
		SUB     ECX,2
		CMP     EAX,40000000H
		JL      NORM_ACC

	PAS_D_NORM:
		IMUL    EAX             ;EDX:EAX = produit
		CMP     EDX,20000000H
		JLE     MAKE_DIV
		SHRD    EAX,EDX,1
		SAR     EDX,1
		INC     ECX

	MAKE_DIV:
		IDIV    EBX
		CMP     EAX,40000000H
		JL      SAVE_CRR

		SAR     EAX,1
		INC     ECX
		JMP     SAVE_CRR

	CORR_LE_0:
		MOV     EAX,0
		MOV     ECX,-69

	SAVE_CRR:
		MOV     DWORD PTR [ESI],EAX
		MOV     DWORD PTR [ESI+4],ECX
	}
}

void norm_corrr(long *corr,long *vval)
{
	_asm
	{
		MOV     ESI,[corr]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[vval]        ; ES:DI  adresse acc et ener.

		MOV     EAX,DWORD PTR [EDI+8]    ; AX = partie haute de ener
		SAR     EAX,15
		ADD     AX,0
		JE      FORM_32R

		MOV     EAX,DWORD PTR [EDI]
		MOV     BX,WORD PTR [EDI+4]
		ADD     BX,32
		ADC     EAX,0
		SAR     BX,5
		AND     BX,07FFH
		SAL     EAX,11            ;
		OR      AX,BX
		MOV     DWORD PTR [EDI+16],EAX

		MOV     EBX,DWORD PTR [EDI+8]
		MOV     DX,WORD PTR [EDI+12]
		ADD     DX,32
		ADC     EBX,0
		SAR     DX,5
		AND     DX,07FFH
		SAL     EBX,11           ;
		OR      BX,DX
		MOV     DWORD PTR [EDI+20],EBX
		MOV     ECX,5
		JMP     DEB_PROCR

	FORM_32R:
		MOV     ECX,0            ; init normalisat.
		MOV     AX,WORD PTR [EDI]
		SAL     EAX,16
		MOV     AX,WORD PTR [EDI+4]
		MOV     DWORD PTR [EDI+16],EAX

		MOV     BX,WORD PTR [EDI+8]
		SAL     EBX,16
		MOV     BX,WORD PTR [EDI+12]
		MOV     DWORD PTR [EDI+20],EBX

	DEB_PROCR:
					;EAX = acc
		ADD     EAX,0
		JLE     CORRR_LE_0
					;EBX = ener
		CMP     EBX,40000000H
		JGE     NO_E_NORMR

	NORM_ENER:
		ADD     EBX,EBX
		INC     ECX
		CMP     EBX,40000000H
		JL      NORM_ENER

	NO_E_NORMR:
		CMP     EAX,40000000H      ; normaliser acc
		JGE     PAS_D_NORMR

	NORM_ACCR:
		ADD     EAX,EAX
		SUB     ECX,2
		CMP     EAX,40000000H
		JL      NORM_ACCR

	PAS_D_NORMR:
		IMUL    EAX             ;EDX:EAX = produit
		CMP     EDX,20000000H
		JLE     MAKE_DIVR

		SHRD    EAX,EDX,1
		SAR     EDX,1
		INC     ECX

	MAKE_DIVR:
		IDIV    EBX
		CMP     EAX,40000000H
		JL      SAVE_CRRR

		SAR     EAX,1
		INC     ECX

	SAVE_CRRR:
		MOV     EBX,DWORD PTR [ESI+4]
		CMP     EBX,ECX
		JL      BX_LT_CX
		JG      BX_GT_CX

	;BX_EQU_CX:
		ADD     DWORD PTR [ESI],EAX
		JMP     CORRR_LE_0

	BX_LT_CX:
		MOV     DWORD PTR [ESI+4],ECX          ; sauver exp.
		SUB     CX,BX                  ;
		MOV     EDX,DWORD PTR [ESI]
		SAR     EDX,CL
		ADD     EAX,EDX
		MOV     DWORD PTR [ESI],EAX
		JMP     CORRR_LE_0

	BX_GT_CX:
		SUB     BX,CX                  ;
		MOV     CL,BL
		SAR     EAX,CL
		ADD     DWORD PTR [ESI],EAX
	CORRR_LE_0:
		MOV     EAX,DWORD PTR [ESI]
		MOV     ECX,DWORD PTR [ESI+4]
		ADD     EAX,0
		JZ      END_CRRR

		CMP     EAX,40000000H
		JGE     END_CRRR

	NRM_RR:
		ADD     EAX,EAX
		DEC     ECX
		CMP     EAX,40000000H
		JL      NRM_RR

		MOV     DWORD PTR [ESI],EAX
		MOV     DWORD PTR [ESI+4],ECX

	END_CRRR:
	}
}

void energy(short *vech,long *ene,short lng)
{
	_asm
	{
		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons

		MOV     CX,[lng]      ;Initialiser le compteur

		MOV     EBX,0
		MOV     DI,0

	L_ENERGY:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    AX                 ;Multiplier
		ADD     DI,AX
		MOVSX   EAX,DX
		ADC     EBX,EAX
		ADD     ESI,2               ;Pointer lmen suiv.
		DEC	CX
		JNE     L_ENERGY

		MOV     ESI,[ene]          ;  adresse result.
		MOV     DWORD PTR [ESI],EBX
		MOV     WORD PTR [ESI+4],DI
	}
}

void venergy(short *vech,long *vene,short lng)
{
	_asm
	{

		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons
		MOV     EDI,[vene]          ;  adresse result.

		MOV     EBX,0
		MOV     CX,0
	L_VENERGY:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    AX                 ;Multiplier
		ADD     CX,AX
		MOVSX   EAX,DX
		ADC     EBX,EAX            ; acc. en EBX:CX
		ADD     ESI,2               ;Pointer lmen suiv.

		MOV     EDX,EBX            ; sauver EBX:CX>>5
		MOV     AX,CX              ; mettre dans EDX:AX
		ADD     AX,16              ; arrondi
		ADC     EDX,0
		SAL     EDX,11             ; EDX<<11
		SAR     AX,5               ;
		AND     AX,07FFH
		OR      DX,AX              ; EDX = (EBX:CX + 16) >> 5
		MOV     DWORD PTR [EDI],EDX
		ADD     EDI,4
		SUB     WORD PTR [lng],1
		JG      L_VENERGY
	}
}

void energy2(short *vech,long *ene,short lng)
{
	_asm
	{
		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons

		MOV     CX,[lng]      ;Initialiser le compteur
		MOV     EBX,0
		MOV     DI,0
	L_ENERGY2:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    AX                 ;Multiplier
		ADD     DI,AX
		MOVSX   EAX,DX
		ADC     EBX,EAX
		ADD     ESI,2               ;Pointer lmen suiv.
		DEC	    CX
		JNE     L_ENERGY2

		MOV     ESI,[ene]         ;  adresse result.
				       ; sauver EBX:[LOW_A]>>5
		ADD     DI,16              ; arrondi
		ADC     EBX,0
		SAL     EBX,11             ; EBX<<11
		SAR     DI,5               ;
		AND     DI,07FFH
		OR      BX,DI              ; EBX = (EBX:AX + 16) >> 5
		MOV     DWORD PTR [ESI],EBX
	}
}

void upd_ene(long *ener,long *val)
{
	_asm
	{
		MOV     ESI,[ener]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[val]        ; ES:DI  adresse acc et ener.

		MOV     EBX,DWORD PTR [ESI]      ; EBX partie H ene
		MOV     AX,WORD PTR [ESI+4]    ; AX = partie low

		MOV     CX,WORD PTR [EDI]
		MOVSX   EDX,WORD PTR [EDI+2]    ; EDX:CX  ajouter

		ADD     AX,CX
		ADC     EBX,EDX

		MOV     CX,WORD PTR [EDI+4]
		MOVSX   EDX,WORD PTR [EDI+6]    ; EDX:CX  retirer

		SUB     AX,CX
		SBB     EBX,EDX

		MOV     DWORD PTR [ESI],EBX
		MOV     WORD PTR [ESI+4],AX
	}
}


#pragma warning(disable : 4035)

short max_posit(long *vcorr,long *maxval,short pitch,short lvect)
{

	_asm
	{
		MOV     ESI,[vcorr]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[maxval]        ; ES:DI  adresse val max

		MOV     CX,[lvect]       ; init compt

		MOV     EAX,DWORD PTR [ESI]      ; init max
		MOV     EBX,DWORD PTR [ESI+4]
		ADD     ESI,8
		MOV     WORD PTR [EDI],CX
		DEC     CX

	L_MAX_POS:
		MOV     EDX,DWORD PTR [ESI+4]    ; EDX = exp. du candidat
		CMP     EDX,EBX
		JG      UPDT_MAX
		JL      NEXT_IND

		MOV     EDX,DWORD PTR [ESI]      ; EDX = mantisse
		CMP     EDX,EAX
		JLE     NEXT_IND

	UPDT_MAX:
		MOV     EAX,DWORD PTR [ESI]
		MOV     EBX,DWORD PTR [ESI+4]
		MOV     WORD PTR [EDI],CX

	NEXT_IND:
		ADD     ESI,8
		DEC	CX
		JNE	L_MAX_POS

		MOV     CX,WORD PTR [EDI]
		NEG     CX
		ADD     CX,[lvect]

		MOV     DX,[lvect]
		SAR     DX,1
		SUB     CX,DX
		ADD     CX,[pitch]

		MOV     DWORD PTR [EDI],EAX
		MOV     DWORD PTR [EDI+4],EBX

		MOV     AX,CX
	}
}
#pragma warning(default : 4035)

void correlation(short *vech,short *vech2,long *acc,short lng)
{
	short low_a;

	_asm
	{
		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons
		MOV     EDI,[vech2]      ; ES:DI  adresse 2d vect.
		MOV     CX,[lng]      ;Initialiser le compteur

		MOV     EBX,0
		MOV     WORD PTR [low_a],0

	L_CORREL:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    WORD PTR [EDI]   ;Multiplier par l'lment dcal
		ADD     [low_a],AX
		MOVSX   EAX,DX
		ADC     EBX,EAX
		ADD     ESI,2            ;Pointer lmen suiv.
		ADD     EDI,2
		DEC	CX
		JNE     L_CORREL

		MOV     ESI,[acc]           ;  adresse result.
		MOV     DWORD PTR [ESI],EBX
		MOV     AX,[low_a]
		MOV     WORD PTR [ESI+4],AX
	}
}

void  schur(short *parcor,long *Ri,short netages)
{
	short cmpt2;

	_asm
	{
		MOV     ESI,[Ri]
		MOV     EDI,ESI
		ADD     EDI,44             ; DS:DI for V

		MOV     EBX,DWORD PTR [ESI]       ; EBX = R(0)
		MOV     CL,0
		CMP     EBX,40000000H     ;normaliser R(0)
		JGE     OUT_N_R0
	NORM_R0:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H
		JL      NORM_R0
	OUT_N_R0:
		MOV     DWORD PTR [ESI],EBX
				      ;Initialisation de  V = R1..Rp
		MOV     DX,[netages]       ;Charger ordre p du LPC
		ADD     ESI,4              ;Pointer R1
	INIT_V:
		MOV     EAX,DWORD PTR [ESI]       ;EAX = Ri
		SAL     EAX,CL
		MOV     DWORD PTR [ESI],EAX       ;Sauver dans U[i]
		MOV     DWORD PTR [EDI],EAX       ;Sauver dans V[i]
		ADD     ESI,4              ;passer au suivant
		ADD     EDI,4
		DEC     DX
		JG      INIT_V

		MOV     WORD PTR [cmpt2],1    ;I=1

	HANITRA:
		MOV     CX,[netages]            ;CX = NETAGES
		SUB     CX,[cmpt2]             ;CX = NETAGES-I
		ADD     WORD PTR [cmpt2],1
		MOV     ESI,[Ri]               ;Charger vecteur U
		MOV     EDI,ESI
		ADD     EDI,44                  ;Charger vect. V

		MOV     EDX,DWORD PTR [EDI]            ; EDX = V(0)
		MOV     EAX,0
		SHRD    EAX,EDX,1
		SAR     EDX,1
		MOV     EBX,DWORD PTR [ESI]            ; EBX = S(0)
		NEG     EBX
		IDIV    EBX

		MOV     EBX,EAX                ; EBX = KI

		MOV     EAX,DWORD PTR [EDI]            ; EAX =V(0)
		IMUL    EBX                    ; EDX:EAX = PARCOR*V[0]
		SHLD    EDX,EAX,1
		ADD     EDX,DWORD PTR [ESI]            ; EDX = U[0]+V[0]*PARCOR
		CMP     CX,0
		JE      FINATCR
		MOV     DWORD PTR [ESI],EDX            ;Sauver U[0]; EBX = KI

	LALA:
		ADD     EDI,4                     ;Incrementer les pointeurs
		ADD     ESI,4                     ;
		MOV     EAX,DWORD PTR [ESI]
		IMUL    EBX                      ;EDX:EAX = PARCOR*U[I]
		SHLD    EDX,EAX,1
		ADD     EDX,DWORD PTR [EDI]              ;EDX = V[I]+U[I]*PARCOR
		MOV     DWORD PTR [EDI-4],EDX            ;Sauver V[I-1];

		MOV     EAX,DWORD PTR [EDI]
		IMUL    EBX                      ;EDX:EAX = PARCOR*V[I]
		SHLD    EDX,EAX,1
		ADD     EDX,DWORD PTR [ESI]              ;EDX = U[I]+V[I]*PARCOR
		MOV     DWORD PTR [ESI],EDX              ;Sauver U[I]; ST = KI
		DEC     CX
		JNE     LALA

		MOV     EDI,[parcor]
		ADD     EBX,32768
		SAR     EBX,16
		MOV     WORD PTR [EDI],BX        ; sauver KI
		ADD     DWORD PTR [parcor],2   ;Next KI

		JMP     HANITRA

	FINATCR:
		ADD     EBX,32768
		SAR     EBX,16
		MOV     EDI,[parcor]
		MOV     WORD PTR [EDI],BX               ; sauver KI

	}
}

void interpol(short *lsp1,short *lsp2,short *dest,short lng)
{
	_asm
	{
		MOV	ESI,[lsp1]
		MOV     EDI,[lsp2]
		MOV     EBX,[dest]

		MOV	CX,[lng]     ; CX : compteur

	interp_loop:
		MOVSX	EAX,WORD PTR [ESI]     ; AX = lsp1
		ADD     ESI,2

		ADD     EAX,EAX        		; EAX = 2*lsp1
		MOVSX   EDX,WORD PTR [EDI]
		ADD     EAX,EDX        		; EAX = 2*lsp1+lsp2
		ADD     EDI,2

		MOV     EDX,21845       ; 21845 = 1/3
		IMUL    EDX             ; EDX:EAX = AX/3

		ADD     EAX,32768
		SAR     EAX,16

		MOV     WORD PTR [EBX],AX
		ADD     EBX,2

		DEC	CX
		JNE	interp_loop
	}
}

void add_sf_vect(short *y1,short *y2,short deb,short lng)
{
	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]
		MOV     CX,[lng]
		MOVSX	EBX,WORD PTR [deb]
		SUB     CX,BX            ; CX : compteur
		ADD     BX,BX
		ADD     ESI,EBX

	ADD_SHFT:
		MOV	AX,WORD PTR [EDI]
		ADD	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	ADD_SHFT
	}
}

void sub_sf_vect(short *y1,short *y2,short deb,short lng)
{
	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]
		MOV     CX,[lng]
		MOVSX	EBX,[deb]
		SUB     CX,BX            ; CX : compteur
		ADD     BX,BX
		ADD     ESI,EBX

	SUB_SHFT:
		MOV	AX,WORD PTR [EDI]
		SUB	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	SUB_SHFT
	}
}

void short_to_short(short *src,short *dest,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV     EDI,[dest]
		MOV	CX,[lng]     ; CX : compteur

	COPY_LOOP:
		MOV	AX,WORD PTR [ESI]
		MOV	WORD PTR [EDI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	COPY_LOOP
	}
}

void inver_v_int(short *src,short *dest,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV     EDI,[dest]
		MOV	CX,[lng]     ; CX : compteur
		MOVSX   EBX,CX
		DEC     EBX
		ADD     EBX,EBX
		ADD     EDI,EBX

	INVERS_LOOP:
		MOV	AX,WORD PTR [ESI]
		MOV	WORD PTR [EDI],AX
		ADD	ESI,2
		SUB     EDI,2
		DEC	CX
		JNE	INVERS_LOOP
	}
}

void long_to_long(long *src,long *dest,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV     EDI,[dest]
		MOV	CX,[lng]     ; CX : compteur

	COPY_LOOP2:
		MOV	EAX,DWORD PTR [ESI]
		MOV	DWORD PTR [EDI],EAX
		ADD	ESI,4
		ADD     EDI,4
		DEC	CX
		JNE	COPY_LOOP2
	}
}

void init_zero(short *src,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV	CX,[lng]     ; CX : compteur
		MOV     AX,0

	COPY_LOOP3:
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		DEC	CX
		JNE	COPY_LOOP3
	}
}



#if 0
// PhilF: The following is never called!!!
void update_dic(short *y1,short *y2,short hy[],short lng,short i0,short fact)
{
	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]
		MOV	CX,[i0]       ; CX : compteur
		MOV     DX,CX

	UPDAT_LOOP1:
		MOV	AX,WORD PTR [EDI]     ; y1 = y2 for (i=0..i0-1)
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	UPDAT_LOOP1

		MOV     EBX,[hy]
		MOV     CX,[lng]
		SUB     CX,DX          ; CX = lng-i0 = compteur

		MOV     AX,[fact]
		ADD     AX,0
		JL      FACT_NEG

	UPDAT_LOOP2:
		MOV	AX,WORD PTR [EDI]     ; AX = y2[i]
		MOV     DX,WORD PTR [EBX]
		ADD     AX,DX
		ADD     AX,DX          ; AX = y2[i] + 2*hy[i]
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		ADD     EBX,2
		DEC	CX
		JNE	UPDAT_LOOP2

		JMP     FIN_UPDT
	FACT_NEG:
		MOV     AX,WORD PTR [EDI]     ; AX = y2[i]
		MOV     DX,WORD PTR [EBX]
		SUB     AX,DX
		SUB     AX,DX	       ; AX = y2[i] - 2*hy[i]
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		ADD     EBX,2
		DEC	CX
		JNE	FACT_NEG

	FIN_UPDT:
	}
}
#endif

void update_ltp(short *y1,short *y2,short hy[],short lng,short gdgrd,short fact)
{
	short arrondi;

	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]

		MOV     BX,[fact]
		MOV     CX,[gdgrd]       ; CX = bit de garde
		ADD     CX,0
		JE      BDG_NUL
		DEC     CL
		SAR     BX,CL
		ADD     BX,1
		SAR     BX,1
		INC     CL
	BDG_NUL:
		MOV     WORD PTR [ESI],BX
		ADD     ESI,2
		ADD     CL,11

		MOV     AX,1
		SAL     AX,CL
		MOV     [arrondi],AX            ; [BP-2] = arrondi
		INC     CL

		SUB     WORD PTR [lng],1

		MOV     BX,[fact]

	UPDAT_LTP:
		XCHG    ESI,[hy]
		MOV	AX,WORD PTR [ESI]     ; AX = hy[i]
		IMUL    BX             ; DX:AX = fact*hy
		ADD     AX,[arrondi]      ;arrondi
		ADC     DX,0
		SHRD    AX,DX,CL
		ADD     AX,WORD PTR [EDI]
		ADD     ESI,2           ; increm.
		ADD     EDI,2
		XCHG    ESI,[hy]
		MOV     WORD PTR [ESI],AX
		ADD     ESI,2
		SUB     WORD PTR [lng],1
		JG      UPDAT_LTP
	}
}

void proc_gain2(long *corr_ene,long *gain,short bit_garde)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EAX,0
		MOV     EBX,DWORD PTR [ESI+4]    ;EBX = ener
		ADD     EBX,0
		JE      G_ENER_NULL2

		MOV     CX,[bit_garde]
		ADD     CL,19
		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr
		CDQ
		SHLD    EDX,EAX,CL       ;
		SAL     EAX,CL
		IDIV    EBX
	G_ENER_NULL2:

		MOV     ESI,[gain]       ; DS:SI  adresse resultat
		MOV     DWORD PTR [ESI],EAX
	}
}


#if 0
void proc_gain(long *corr_ene,long *gain)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EAX,0
		MOV     EBX,DWORD PTR [ESI+4]    ;EBX = ener
		ADD     EBX,0
		JE      G_ENER_NULL

		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr
		CDQ
		SHLD    EDX,EAX,13
		SAL     EAX,13
		IDIV    EBX
	G_ENER_NULL:
		MOV     ESI,[gain]       ; DS:SI  adresse resultat
		MOV     DWORD PTR [ESI],EAX
	}
}
#else
void proc_gain(long *corr_ene,long gain)
{
	_asm
	{
		MOV		ESI,[corr_ene]
		MOV		EAX,0
		MOV		EBX,DWORD PTR [ESI+4]	;EBX = energy
		ADD		EBX,0
		JLE		G_ENER_NULL				; REPLACED JE BY JLE: ENERGY MUST BE POSITIVE

		MOV		EAX,DWORD PTR [ESI]		; EAX = correlation
		CDQ
		SHLD	EDX,EAX,13
		SAL		EAX,13

		; ----------------------------------------------
		; AT THIS POINT, EDX:EAX contains the dividend, EBX the divisor. HERE IS THE ADDED CHECK

		MOV		ECX,EDX					; COPY EDX IN ECX
		CMP		ECX,0					; CHECK SIGN OF ECX
		JGE		G_CORR_POS
		NEG		ECX						; IF ECX IS NEGATIVE, TAKE ABS(ECX)
		SAL		ECX,2					; AND COMPARE ECX<<2 WITH EBX
		CMP		ECX,EBX					; IF (ECX<<2) >= EBX, THERE IS A RISK OF OVERFLOW,
		JL		G_NO_OVERFLOW			; IN THAT CASE WE SAVE A BIG VALUE IN EAX
		MOV		EAX,-2147483647			; (NEGATIVE BECAUSE EDX<0)
		JMP		G_ENER_NULL				; AND WE EXIT

	G_CORR_POS:
		SAL		ECX,2
		CMP		ECX,EBX					; THE SAME CHECKING FOR THE CASE EDX>0
		JL		G_NO_OVERFLOW			; BUT HERE WE SAVE A BIG POSITIVE VALUE
		MOV		EAX,2147483647			; IN CASE OF OVERFLOW
		JMP		G_ENER_NULL

	G_NO_OVERFLOW:
		; END OF ADDED CODE
		;-------------------------------------------------

		IDIV	EBX						; IF THERE IS NO RISK OF OVERFLOW, WE MAKE THE DIV
	G_ENER_NULL:
		MOV		ESI,[gain]
		MOV		DWORD PTR [ESI],EAX
	}
}
#endif

void decode_dic(short *code,short dic,short npuls)
{
	_asm
	{
		MOV	ESI,[code]
		MOVSX	ECX,[npuls]
		DEC     ECX
		ADD	ECX,ECX          ; CX = deplacement
		ADD     ESI,ECX
		MOV     BX,[dic]     ; BX = Dictionnaire
		MOV     AX,1           ; AX = Mask
		MOV	CX,[npuls]     ; CX : compteur
		DEC     CX
	dic_loop:
		MOV     DX,BX          ; DX = dec
		AND     DX,AX          ; Masquer
		JNZ     NO_NUL         ; Saut si non null
		MOV	WORD PTR [ESI],-1
		JMP     NDAO
	NO_NUL:
		MOV     WORD PTR [ESI],1
	NDAO:
		SUB     ESI,2
		ADD	AX,AX
		DEC	CX
		JNE	dic_loop
	}
}

void dsynthesis(long *z,short *coef,short *input,short *output,
						short lng,short netages)
{
	short depl,count;

	_asm
	{
		MOV     CX,[netages]   ; CX = filter order
		ADD	CX,CX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       ; [BP-2] = deplacement

	DSYNTH_GEN:
		MOV	EDI,[z]

		MOV     ESI,[input]           		; FS:[SI] input
		MOVSX   EBX,WORD PTR [ESI]	 	; EBX = entre
		NEG     EBX
		SAL     EBX,16
		ADD     DWORD PTR [input],2	  	; increm.
		MOV     DWORD PTR [EDI],EBX            	; mise  jour mmoire

		MOV     ESI,[coef]

		MOVSX   ECX,[depl]
		ADD     ESI,ECX
		ADD     EDI,ECX
		ADD     EDI,ECX

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX
		MOV     EBX,0
		MOV     ECX,0
	DSYNTHL:
		MOV     EAX,DWORD PTR [EDI]            ;EAX = Zi
		MOV     DWORD PTR [EDI+4],EAX           ;update memory
		MOVSX   EDX,WORD PTR [ESI]		   ;EDX = Ai
		IMUL    EDX                    ;EDX:EAX = Zi*Ai
		SUB     ECX,EAX
		SBB     EBX,EDX                ;Acc en EBX:ECX
		SUB     EDI,4                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1
		JGE     DSYNTHL

		ADD     ECX,512
		ADC     EBX,0
		SHLD    EBX,ECX,22

		ADD     EDI,8
		MOV     DWORD PTR [EDI],EBX             ; mise  jour mmoire

		MOV     ESI,[output]
		ADD     EBX,32768
		SAR     EBX,16
		MOV     WORD PTR [ESI],BX              ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1  ;decrem compt
		JG      DSYNTH_GEN
	}
}

void synthesis(short *z,short *coef,short *input,short *output,
				short lng,short netages,short bdgrd )
{
	short depl,count,coeff;

	_asm
	{
		MOV     CX,[netages]   ; CX = filter order
		ADD     CX,CX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       ; [BP-2] = deplacement

		MOV     ESI,[coef]
		MOV     AX,WORD PTR [ESI]
		MOV     [coeff],AX
		MOV     CX,[bdgrd]
		SAR     AX,CL
		MOV     WORD PTR [ESI],AX

	SYNTH_GEN:
		MOV	EDI,[z]

		MOV     ESI,[input]           ; FS:[SI] input
		MOV     BX,WORD PTR [ESI]           ; BX = entre
		NEG     BX
		ADD     DWORD PTR [input],2  ; increm.
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[coef]

		ADD     SI,[depl]
		ADD     DI,[depl]

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX

		MOV     CX,0
		MOV     BX,0
	SYNTHL:
		MOV     AX,WORD PTR [EDI]             ;AX = Zi
		MOV     WORD PTR [EDI+2],AX           ;update memory
		MOV     DX,WORD PTR [ESI]             ;DX = Ai
		IMUL    DX                     ;DX:AX = Zi*Ai
		SUB     BX,AX
		SBB     CX,DX                  ;acc. en CX:BX

		SUB     EDI,2                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1   ;Decrem. compt.
		JGE     SYNTHL

		ADD	BX,512                 ;arrondi
		ADC     CX,0
		SHRD    BX,CX,10

		ADD     EDI,4
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[output]
		MOV     WORD PTR [ESI],BX       ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1    ;Decrem. compt.
		JG      SYNTH_GEN

		MOV     ESI,[coef]
		MOV     AX,[coeff]
		MOV     WORD PTR [ESI],AX
	}
}

void synthese(short *z,short *coef,short *input,short *output,
						short lng,short netages)
{
	short depl,count;

	_asm
	{
		MOV     CX,[netages]   ; CX = filter order
		ADD	CX,CX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       ; [BP-2] = deplacement

	SYNTH_GEN2:
		MOV	EDI,[z]
		MOV     ESI,[input]           ; FS:[SI] input
		MOV     BX,WORD PTR [ESI]           ; BX = entre
		NEG     BX
		ADD     DWORD PTR [input],2  ; increm.
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[coef]

		ADD     SI,[depl]
		ADD     DI,[depl]

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX

		MOV     CX,0
		MOV     BX,0
	SYNTHL2:
		MOV     AX,WORD PTR [EDI]             ;AX = Zi
		MOV     WORD PTR [EDI+2],AX           ;update memory
		MOV     DX,WORD PTR [ESI]             ;DX = Ai
		IMUL    DX                     ;DX:AX = Zi*Ai
		SUB     BX,AX
		SBB     CX,DX                  ;acc. en CX:BX

		SUB     EDI,2                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1   ;Decrem. compt.
		JGE     SYNTHL2

		ADD	BX,512                 ;arrondi
		ADC     CX,0
		SHRD    BX,CX,10

		ADD     EDI,4
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[output]
		MOV     WORD PTR [ESI],BX       ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1    ;Decrem. compt.
		JG      SYNTH_GEN2
	}
}

void f_inverse(short *z,short *coef,short *input,short *output,
						short lng,short netages )
{
	short depl,count;

	_asm
	{
		MOV     CX,[netages]   		; CX = filter order
		ADD		CX,CX                   ; Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       	; [BP-2] = deplacement

	INVER_GEN:
		MOV		EDI,[z]

		MOV     ESI,[input]             ; FS:[SI] input
		MOV     BX,WORD PTR [ESI]             ; BX = entre
		ADD     DWORD PTR [input],2 	 ; increm.
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[coef]

		ADD     SI,[depl]
		ADD     DI,[depl]

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX            ;BP-4 : compteur
		MOV     CX,0
		MOV     BX,0
	INVERL:
		MOV     AX,WORD PTR [EDI]             ;AX = Zi
		MOV     WORD PTR [EDI+2],AX           ;update memory
		MOV     DX,WORD PTR [ESI]             ;DX = Ai
		IMUL    DX                     ;DX:AX = Zi*Ai

		ADD     CX,AX
		ADC     BX,DX                  ; acc. en BX:CX

		SUB     EDI,2                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1
		JGE     INVERL

		MOV     ESI,[output]
		ADD	CX,512                ;arrondi
		ADC     BX,0
		SHRD    CX,BX,10

		MOV     WORD PTR [ESI],CX                 ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1      ;decrem.
		JG      INVER_GEN
	}
}

void filt_iir(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre)
{
	long off_coef,off_mem,delta;
	long acc_low;

	_asm
	{
		MOVSX   ECX,[ordre]      ;ordre du filtre
		SAL		ECX,3            ;Dfinir un Deplacement d'adresse
		MOV     [off_coef],ECX   ; [OFF_COEF] = deplacement pour coeff
		ADD     ECX,4
		MOV     [off_mem],ECX    ; [OFF_MEM] = depl. pour mem.

		ADD     ECX,20
		SAR     ECX,1
		MOV     [delta],ECX


	IIR_FIL:
		MOV     CX,[ordre]            ;init compteur
		MOV     EBX,[Vin] 	      ; BX = offset input
		MOVSX   EDX,WORD PTR [EBX]  ; EDX = input avec extension de signe
		ADD     DWORD PTR [Vin],2   ; incrmenter l'offset de input

		MOV     ESI,[zx]    	      ; DS:SI pointe zx

		MOV     DWORD PTR [ESI],EDX           ; mettre  jour zx

		MOV     EDI,[ai]    	      ; ES:DI pointe coeff

		ADD     EDI,[off_coef]
		ADD     ESI,[off_mem]

		MOV     DWORD PTR [acc_low],0   ; initialiser ACC_LOW  0
		SUB     EBX,EBX               ; init EBX = 0

	F_IIR_Y:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zx
		MOV     DWORD PTR [ESI+4],EAX         ;mettre  jour zx
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff

		IMUL    EDX                   ;EDX:EAX = zx*coeff
		SUB     [acc_low],EAX         ; accumuler les LSB
		SBB     EBX,EDX               ; acc avec borrow les MSB
		SUB     EDI,4                  ;Incrementer
		SUB     ESI,4                  ;
		DEC		CX
		JNE		F_IIR_Y


		SUB     ESI,4
		MOV     CX,[ordre]            ;Charger ordre du filtre
		INC     CX

	F_IIR_X:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zy
		MOV     DWORD PTR [ESI+4],EAX         ;update zy
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff
		IMUL    EDX                   ;EDS:EAX = zy*coeff
		ADD     [acc_low],EAX         ;acc LSB
		ADC     EBX,EDX               ;acc avec carry MSB
		SUB     EDI,4                  ;Decrementer
		SUB     ESI,4                  ;
		DEC		CX
		JNE		F_IIR_X

		MOV		EAX,[delta]
		ADD     ESI,EAX
		MOV     EAX,[acc_low]         ; EAX = LSB de l'acc.
		ADD     EAX,8192              ; arrondi
		ADC     EBX,0
		SHRD    EAX,EBX,14            ; cadrer
		MOV     DWORD PTR [ESI],EAX           ; mettre  jour zy

		SAR     EAX,14	              ; cadrer en x4.0
					; logique saturante
		CMP     EAX,32767
		JG      SATUR_POS             ; jump if ov
		CMP     EAX,-32767
		JL      SATUR_NEG
		JMP		NEXT

	SATUR_POS:
		MOV      AX,32767
		JMP      NEXT
	SATUR_NEG:
		MOV      AX,-32767
		JMP      NEXT

	NEXT:
		MOV     ESI,[Vout]             ;di offset output
		MOV     WORD PTR [ESI],AX	      ;sauver output
		ADD     DWORD PTR [Vout],2      ;incrmenter offset
		SUB     WORD PTR [lfen],1
		JNZ	IIR_FIL
	}
}


#if 0
// PhilF: The following is never called!!!
void filt_iir_a(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre)
{
	short off_coef,off_mem,delta;
	long acc_low;

	_asm
	{

		MOV     CX,[ordre]      ;ordre du filtre
		SAL	CX,3            ;Dfinir un Deplacement d'adresse
		MOV     [off_coef],CX   ; [OFF_COEF] = deplacement pour coeff
		ADD     CX,4
		MOV     [off_mem],CX    ; [OFF_MEM] = depl. pour mem.

		ADD     CX,20
		SAR     CX,1
		MOV     [delta],CX


	A_IIR_FIL:
		MOV     CX,[ordre]            ;init compteur
		MOV     EBX,[Vin] 	      ; BX = offset input
		MOVSX   EDX,WORD PTR [EBX]  ; EDX = input avec extension de signe
		ADD     WORD PTR [Vin],2   ; incrmenter l'offset de input

		MOV     ESI,[zx]    	      ; DS:SI pointe zx

		MOV     DWORD PTR [ESI],EDX           ; mettre  jour zx

		MOV     EDI,[ai]    	      ; ES:DI pointe coeff

		ADD     DI,[off_coef]
		ADD     SI,[off_mem]

		MOV     DWORD PTR [acc_low],0   ; initialiser ACC_LOW  0
		SUB     EBX,EBX               ; init EBX = 0

	F_IIR_Y_A:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zx
		MOV     DWORD PTR [ESI+4],EAX         ;mettre  jour zx
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff

		IMUL    EDX                   ;EDX:EAX = zx*coeff
		SUB     [acc_low],EAX         ; accumuler les LSB
		SBB     EBX,EDX               ; acc avec borrow les MSB
		SUB     EDI,4                  ;Incrementer
		SUB     ESI,4                  ;
		DEC	CX
		JNE	F_IIR_Y_A


		SUB     ESI,4
		MOV     CX,[ordre]            ;Charger ordre du filtre
		INC     CX

	F_IIR_X_A:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zy
		MOV     DWORD PTR [ESI+4],EAX         ;update zy
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff
		IMUL    EDX                   ;EDS:EAX = zy*coeff
		ADD     [acc_low],EAX         ;acc LSB
		ADC     EBX,EDX               ;acc avec carry MSB
		SUB     EDI,4                  ;Decrementer
		SUB     ESI,4                  ;
		DEC	CX
		JNE	F_IIR_X_A


		MOVSX	EAX,[delta]
		ADD     ESI,EAX
		MOV     EAX,[acc_low]         ; EAX = LSB de l'acc.
		ADD     EAX,8192              ; arrondi
		ADC     EBX,0
		SHRD    EAX,EBX,14            ; cadrer
		MOV     DWORD PTR [ESI],EAX           ; mettre  jour zy

		ADD     EAX,32768
		SAR     EAX,16	              ; cadrer en x4.0
		MOV     ESI,[Vout]             ;di offset output
		MOV     WORD PTR [ESI],AX	      ;sauver output
		ADD     WORD PTR [Vout],2      ;incrmenter offset
		SUB     WORD PTR [lfen],1
		JNZ     A_IIR_FIL
	}
}
#endif

void mult_fact(short src[],short dest[],short fact,short lng)
{
	_asm
	{
		MOV     ESI,[src]
		MOV     EDI,[dest]
		MOV     BX,[fact]         ; BX = Factor

		MOV     CX,[lng]          ; init compteur

	MULT_F:
		MOV     AX,WORD PTR [ESI]        ; AX = src
		IMUL	BX                ; DX:AX = src*fact
		ADD     AX,4096
		ADC     DX,0
		SHRD    AX,DX,13          ; cadrer
		MOV	WORD PTR [EDI],AX        ;save
		ADD     ESI,2              ;incrmenter
		ADD     EDI,2
		DEC	CX
		JNE	MULT_F
	}
}

void mult_f_acc(short src[],short dest[],short fact,short lng)
{
	_asm
	{
		MOV     EDI,[src]
		MOV     ESI,[dest]
		MOV     BX,[fact]         ; BX = Factor

		MOV     CX,[lng]          ; init compteur

	MULT_F_A:
		MOV     AX,WORD PTR [EDI]        ; AX = src
		IMUL	BX                ; DX:AX = src*fact
		ADD     AX,4096
		ADC     DX,0
		SHRD    AX,DX,13          ; cadrer
		ADD     WORD PTR [ESI],AX        ; Accumuler   dest = dest + src*fact
		ADD     ESI,2              ;incrmenter
		ADD     EDI,2
		DEC	CX
		JNE	MULT_F_A
	}
}

void dec_lsp(short *code,short *tablsp,short *nbit,short *bitdi,short *tabdi)
{
	short compt;
	long pointer;

	_asm
	{
		MOV     EDI,[tablsp]
		MOV     ESI,[code]

		MOVSX   EBX,WORD PTR [ESI]        ; BX = depl.
		ADD	EBX,EBX
		MOV     AX,WORD PTR [EDI+EBX]     ; AX = code[0];
		MOV     WORD PTR [ESI],AX        ;
		ADD     ESI,4              ;

		MOV     CX,4              ; init compteur


	LSP_PAIR:
		MOV     EBX,[nbit]         ; lsptab += nbit[i]
		MOVSX   EAX,WORD PTR [EBX]        ; AX = nbit[i]
		ADD     EAX,EAX
		ADD     EDI,EAX             ;
		ADD     EBX,2              ; increm
		MOV     [nbit],EBX

		MOVSX   EBX,WORD PTR [ESI]        ; BX = depl.
		ADD     EBX,EBX
		MOV     AX,WORD PTR [EDI+EBX]     ; AX = code[i];
		MOV     WORD PTR [ESI],AX       ;
		ADD     ESI,4
		DEC	CX
		JNE	LSP_PAIR

		ADD     DWORD PTR [nbit],2

		MOV     EDI,[tabdi]
		SUB     ESI,20            ; pointer code[0]

		MOV     WORD PTR [compt],5

	REPEAT_DEC:
		MOV     EBX,[bitdi]
		MOV     CX,WORD PTR [EBX]       ;
		MOV     BX,WORD PTR [ESI+4]     ; BX = lsp[2*k+2]
		SUB     BX,WORD PTR [ESI]       ;    = lsp[2*k+2]-lsp[2*k] = delta
					 ; ne pas faire /2 --> pas de corr. signe *
		MOV     EAX,[nbit]
		MOV     [pointer],EAX

	LOOP_DI1:
		MOV     AX,WORD PTR [EDI]       ; AX = TABDI
		ADD     EDI,2
		IMUL    BX               ; DX:AX = tabdi * delta
		ADD     AX,32768
		ADC     DX,0             ;arrondi
		ADD     DX,WORD PTR [ESI]
		XCHG    ESI,[pointer]
		MOV     WORD PTR [ESI],DX       ; sauver
		ADD     ESI,2
		XCHG    ESI,[pointer]
		DEC	CX
		JNE	LOOP_DI1


		MOV     DX,BX
		MOV     EBX,[bitdi]
		MOV     CX,WORD PTR [EBX]       ;
		ADD     ESI,4
		SUB     CX,2
		JLE     IALAO
		MOV     BX,DX
		NEG     BX
	LOOP_DI2:
		MOV     AX,WORD PTR [EDI]       ; AX = TABDI
		ADD     EDI,2
		IMUL    BX               ; DX:AX = tabdi * delta
		ADD     DX,WORD PTR [ESI]
		XCHG    ESI,[pointer]
		MOV     WORD PTR [ESI],DX       ; sauver
		ADD     ESI,2
		XCHG    ESI,[pointer]
		DEC	CX
		JNE	LOOP_DI2

	IALAO:
		ADD     DWORD PTR [bitdi],2        ;

		MOV     EBX,[nbit]        ; BX = adresse de veclsp

		SUB     ESI,2             ; pointer code[2*k+1]
		MOVSX   EAX,WORD PTR [ESI]
		ADD	EAX,EAX            ; AX = depl.

		ADD     EBX,EAX

		MOV     AX,WORD PTR [EBX]       ; AX = veclsp[code[2*k+1]
		MOV     WORD PTR [ESI],AX
		ADD     ESI,2
		SUB     WORD PTR [compt],1
		JNZ     REPEAT_DEC
	}
}

void teta_to_cos(short *tabcos,short *lsp,short netages)
{
	short norm,arrondi,ptm1,lts2;

	_asm
	{
		MOV     EDI,[lsp]

		MOV     CX,[netages]        ;init compteur

	TETA_LOOP:
		MOV     AX,WORD PTR [EDI]        ; AX = lsp[i]
		CMP     AX,04000H         ; comparer  4000h

		JLE     INIT_VAL          ;
		NEG     AX
		ADD     AX,32767          ; prendre le complment
	INIT_VAL:
		MOV     ESI,[tabcos]
		CMP     AX,0738H          ; comparer 
		JG      BIGTABLE

	;SMALLTAB:
		ADD     ESI,550            ; pointer tabteta2
		MOV     WORD PTR [ptm1],3
		MOV     WORD PTR [lts2],16
		MOV     WORD PTR [arrondi],512
		MOV     WORD PTR [norm],10
		JMP     DEBUT_LP

	BIGTABLE:
		ADD     ESI,258             ; pointer tabteta1
		MOV     WORD PTR [ptm1],6
		MOV     WORD PTR [lts2],128
		MOV     WORD PTR [arrondi],64
		MOV     WORD PTR [norm],7

	DEBUT_LP:
		MOVSX   EDX,[lts2]          ; init incrment
		ADD     ESI,EDX              ; SI = index

		MOV     CX,[ptm1]
	LOCAL_L:
		SAR     EDX,1               ; increm >> 1
		CMP     AX,WORD PTR [ESI]
		JG      ADD_INCRM
		SUB     ESI,EDX
		JMP     AURORA
	ADD_INCRM:
		ADD     ESI,EDX
	AURORA:
		DEC	CX
		JNE	LOCAL_L


		CMP     AX,WORD PTR [ESI]
		JG      INTERP_V
		SUB     ESI,2
	INTERP_V:
		SUB     AX,WORD PTR [ESI]         ; AX = teta - tabteta[index]
		MOV	DX,AX
		MOV	AX,0
		MOV     CX,WORD PTR [ESI+2]
		SUB     CX,WORD PTR [ESI]         ; CX = tabteta[index+1]-tabteta[index]
		ADD	CX,CX              ; multiplier par 2 pour ne pas SHRD de DX:AX
		DIV     CX
		ADD     AX,[arrondi]       ;
		MOV     CX,[norm]          ; CX = normalisation
		SAR     AX,CL
		NEG     AX

		CMP     CX,7
		JE      GRAN_TAB
		SUB     ESI,34
		ADD     AX,WORD PTR [ESI]         ;AX = tabcos[index]+delta
		JMP     ADD_SIGN

	GRAN_TAB:
		SUB     ESI,258
		ADD     AX,WORD PTR [ESI]         ;AX = tabcos[index]+delta
	ADD_SIGN:
		CMP     WORD PTR [EDI],04000H
		JLE     END_LOOP
		NEG     AX
	END_LOOP:
		MOV     WORD PTR [EDI],AX          ; save cos
		ADD     EDI,2
		SUB     WORD PTR [netages],1
		JG      TETA_LOOP
	}
}


void cos_to_teta(short *tabcos,short *lsp,short netages)
{
	_asm
	{
		MOV     EDI,[lsp]

		MOV     CX,[netages]        ;init compteur

	COS_LOOP:
		MOV     ESI,[tabcos]
		ADD     ESI,258
		MOV     AX,WORD PTR [EDI]        ; AX = lsp[i]
		ADD     AX,0

		JGE     DEBUT_CS          ; prendre ABS
		NEG     AX
	DEBUT_CS:
		CMP     AX,07DFFH         ; comparer  7DFFh
		JGE     TABLE2
	;TABLE1:
		MOV     BX,AX
		AND     BX,0FFH           ; BX = cos & mask

		MOV     CL,8
		SAR     AX,CL
		ADD	AX,AX
		MOV     EDX,256            ; BX index
		SUB     DX,AX
		ADD     ESI,EDX

		MOV     AX,WORD PTR [ESI]        ; AX=teta[index]
		SUB     AX,WORD PTR [ESI-2]      ;
		IMUL    BX
		ADD     AX,128
		ADC     DX,0
		SHRD    AX,DX,8              ; cadrer
		NEG     AX

		MOV     BX,WORD PTR [ESI]
		ADD     AX,BX

		MOV     BX,WORD PTR [EDI]        ; tester signe de lsp
		ADD     BX,0
		JGE     END_COS
		NEG     AX
		ADD     AX,07FFFH         ; AX = 7fff-AX
		JMP     END_COS

	TABLE2:
		ADD     ESI,292            ; pointer tabteta2
		MOV     BX,AX             ; BX = AX

		SUB     AX,07DFFH         ; retirer delta
		MOV     CL,5
		SAR     AX,CL
		ADD	AX,AX
		MOV     EDX,32             ; DX index
		SUB     DX,AX
		ADD     ESI,EDX

		MOV     AX,WORD PTR [ESI]        ; AX=teta2[index]

		CMP     BX,AX
		JGE     NO_INCRM
		ADD     ESI,2
	NO_INCRM:
		MOV     AX,WORD PTR [ESI]        ; AX=teta2[index]
		MOV     CX,AX             ; pour plus tard
		SUB     AX,WORD PTR [ESI-2]      ;

		SUB     ESI,34             ; pointer tabcos2
		SUB     BX,WORD PTR [ESI]        ;

		IMUL    BX

		ADD     AX,16
		ADC     DX,0
		SHRD    AX,DX,5            ; cadrer
		NEG     AX

		ADD     AX,CX             ; AX = cos + delta

		MOV     BX,WORD PTR [EDI]        ; tester signe de lsp
		ADD     BX,0
		JGE     END_COS
		NEG     AX
		ADD     AX,07FFFH         ; AX = 7fff-AX

	END_COS:
		MOV     WORD PTR [EDI],AX        ;
		ADD     EDI,2
		SUB     WORD PTR [netages],1
		JG      COS_LOOP
	}
}

void lsp_to_ai(short *ai_lsp,long *tmp,short netages)
{
	short cmptr;
	long index;

	_asm
	{
		MOV     ESI,[tmp]
		MOV     EBX,ESI
		ADD     EBX,4*11           ;DS:BX vect. Q

		MOV     EDI,[ai_lsp]
	;LSP_AI:
		MOV     DWORD PTR [ESI],0400000H     ; P(0) = 1
		MOV     DWORD PTR [ESI+8],0400000H   ; P(2) = 1
		MOV     DWORD PTR [EBX],0400000H     ; Q(0) = 1
		MOV     DWORD PTR [EBX+8],0400000H   ; Q(2) = 1

		MOVSX   EAX,WORD PTR [EDI] ; EAX = lsp(0)
		SAL     EAX,8
		NEG     EAX                  ; EAX = -lsp(0)>>8
		MOV     DWORD PTR [ESI+4],EAX        ;P(1) = EAX

		MOVSX   EAX,WORD PTR [EDI+2] ; EAX = lsp(1)
		SAL     EAX,8
		NEG     EAX                  ; EAX = -lsp(1)>>8
		MOV     DWORD PTR [EBX+4],EAX        ; Q(1) = EAX
		MOV     WORD PTR [cmptr],1    ;init compteur
		SUB     WORD PTR [netages],2
		ADD     EBX,8
		MOV     [index],EBX           ; sauver BX = i

		ADD     ESI,8                 ; DS:SI  P(2)
		ADD     EDI,4                 ; ES:DI  lsp(2)
		MOV     CX,[netages]

	GL_LOOP:
		MOV     [netages],CX
		MOV     DWORD PTR [ESI+8],0400000H     ; P(i+2) = 1

		MOVSX   EAX,WORD PTR [EDI] ; EAX = lsp(i)
		MOV     EBX,EAX              ; memoriser lsp(i)
		SAL     EAX,8
		MOV     ECX,DWORD PTR [ESI-4]        ; ECX = P(i-1)
		SUB     ECX,EAX              ; ECX = P(i-1) - lsp(i)<<8
		MOV     DWORD PTR [ESI+4],ECX        ; P(i+1)=ECX


		MOV     CX,[cmptr]           ;
	LOCAL_P:
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = P(j-1)
		IMUL    EBX                  ; EDX:EAX = P(j-1)*lsp(i)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*P(j-1)*lsp(i)
		SUB     DWORD PTR [ESI],EAX          ; P(j)=P(j)-EAX
		MOV     EAX,DWORD PTR [ESI-8]        ; EAX = P(j-2)
		ADD     DWORD PTR [ESI],EAX          ; P(j) += P(j-2)
		SUB     ESI,4
		DEC	CX
		JNE	LOCAL_P

					     ; DS:SI pointe P(1)
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = P(0)
		IMUL    EBX                  ; EDX:EAX = P(0)*lsp(i)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*P(0)*lsp(i)
		SUB     DWORD PTR [ESI],EAX          ; P(1) = P(1)-2*P(0)*lsp(i)

		XCHG    ESI,[index]           ; DS:SI pointe Q(j)

		MOV     DWORD PTR [ESI+8],0400000H   ; Q(i+2) = 1
		MOVSX   EAX,WORD PTR [EDI+2] ; EAX = lsp(i+1)
		MOV     EBX,EAX              ; memoriser lsp(i+1)
		SAL     EAX,8
		MOV     ECX,DWORD PTR [ESI-4]        ; ECX = Q(i-1)
		SUB     ECX,EAX              ; ECX = Q(i-1) - lsp(i+1)<<8
		MOV     DWORD PTR [ESI+4],ECX        ; Q(i+1)=ECX

		MOV     CX,[cmptr]           ;
	LOCAL_Q:
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = Q(j-1)
		IMUL    EBX                  ; EDX:EAX = Q(j-1)*lsp(i+1)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*Q(j-1)*lsp(i+1)
		SUB     DWORD PTR [ESI],EAX          ; Q(j)=Q(j)-EAX
		MOV     EAX,DWORD PTR [ESI-8]        ; EAX = Q(j-2)
		ADD     DWORD PTR [ESI],EAX          ; Q(j) += Q(j-2)
		SUB     ESI,4
		DEC	CX
		JNE	LOCAL_Q

					     ; DS:SI pointe Q(1)
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = Q(0)
		IMUL    EBX                  ; EDX:EAX = Q(0)*lsp(i+1)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*Q(0)*lsp(i+1)
		SUB     DWORD PTR [ESI],EAX          ; Q(1) = Q(1)-2*Q(0)*lsp(i+1)

		MOVSX   ECX,[cmptr]
		ADD     CX,2
		MOV     [cmptr],CX

		SAL     ECX,2
		ADD     ESI,ECX                 ; increm. offset de Q
		XCHG    ESI,[index]            ;
		ADD     ESI,ECX                 ; increm. offset de P
		ADD     EDI,4
		MOV     CX,[netages]
		SUB     CX,2
		JG      GL_LOOP

		MOV     ESI,[tmp]         ;DS:SI vect  P
		MOV     EBX,ESI
		ADD     EBX,4*11           ;DS:BX vect. Q

		MOV     EDI,[ai_lsp]       ;ES:DI lsp et ai
		MOV     WORD PTR [EDI],0400H  ; ai(0) = 1
		ADD     EDI,2

		MOV     CX,10             ; init compteur
		ADD     EBX,4              ;
		ADD     ESI,4
	CALC_AI:
		MOV     EAX,DWORD PTR [ESI]         ; EAX = P(i)
		ADD     EAX,DWORD PTR [ESI-4]       ;       +P(i-1)
		ADD     EAX,DWORD PTR [EBX]         ;       +Q(i)
		SUB     EAX,DWORD PTR [EBX-4]       ;       -Q(i-1)
		ADD     EAX,01000H          ; arrondi
		SAR     EAX,13
		MOV     WORD PTR [EDI],AX          ; save ai
		ADD     EDI,2
		ADD     ESI,4
		ADD     EBX,4
		DEC	CX
		JNE	CALC_AI
	}
}


void ki_to_ai(short *ki,long *ai,short netages)
{
	short cmptk;
	long indam1,indexk,kiim1;

	_asm
	{
		MOV     ESI,[ai]
		MOV     EBX,ESI
		ADD     EBX,44             ; DS:BX vect. interm.

		MOV     EDI,[ki]

		MOV     DWORD PTR [ESI],0400000H     ; ai(0) = 1
		MOVSX   EAX,WORD PTR [EDI] ; EAX = ki(0)
		SAL     EAX,7
		MOV     DWORD PTR [ESI+4],EAX        ; ai(1) = EAX

		ADD     ESI,4                 ; DS:SI  ai(1)
		ADD     EBX,8
		ADD     EDI,2                 ; ES:DI  ki(1)

		MOV     WORD PTR [cmptk],1
		MOV     CX,[netages]

	KI_AI_LP:
		MOV     [netages],CX

		MOVSX   EAX,WORD PTR [EDI] ; EAX = ki(i-1)
		MOV     [kiim1],EAX          ; memoriser ki(i-1)

		SAL     EAX,7
		MOV     DWORD PTR [EBX],EAX          ; tmp(i)=EAX

		SUB     EBX,4

		MOV     [indexk],EBX

		MOVSX   ECX,[cmptk]           ;
		MOV     EBX,ECX
		DEC     EBX
		SAL     EBX,2                 ; DI : deplacement
		MOV     [indam1],ESI
		SUB     ESI,EBX
		MOV     EBX,[indexk]
	LOCAL_AI:
		MOV     EAX,DWORD PTR [ESI]          ; EAX = ai(i-j)
		IMUL    DWORD PTR [kiim1] ; EDX:EAX = ai(i-j)*ki(i-1)
		ADD     EAX,16384
		ADC     EDX,0
		SHRD    EAX,EDX,15           ; EAX = ai(i-j)*ki(i-1)
		ADD     ESI,4
		XCHG    ESI,[indam1]
		ADD     EAX,DWORD PTR [ESI]          ;       + ai(j)
		SUB     ESI,4
		XCHG    ESI,[indam1]

		MOV     DWORD PTR [EBX],EAX          ; tmp(j) = EAX
		SUB     EBX,4

		DEC	CX
		JNE	LOCAL_AI


		XCHG    ESI,[indam1]
		MOV     CX,[cmptk]
		INC     CX
		MOV     [cmptk],CX
		ADD     ESI,4
		ADD     EBX,4
	L_COPY:
		MOV     EAX,DWORD PTR [EBX]              ; EAX = tmp(i)
		MOV     DWORD PTR [ESI],EAX              ; ai(i) = EAX
		ADD     EBX,4
		ADD     ESI,4
		DEC	CX
		JNE	L_COPY


		ADD     EDI,2                     ; increm. i

		SUB     ESI,4

		MOV     CX,[netages]
		DEC	CX
		JNE	KI_AI_LP
	}
}

void ai_to_pq(long *aip,short netages)
{
	_asm
	{
		MOV     ESI,[aip]
		MOV     EDI,ESI
		ADD     EDI,4*11          ;DS:DI vect. Q

		MOV     EDX,DWORD PTR [ESI]       ; EAX = ai(0) = P(0)
		MOV     DWORD PTR [EDI],EDX       ; Q(0) = ai(0)
		MOV     CX,[netages]
		MOVSX   EBX,CX
		DEC     EBX
		SAL     EBX,2              ; BX deplacement
		ADD     ESI,4
		ADD     EDI,4
		SAR     CX,1

	AI_LSP1:
		MOV     EAX,DWORD PTR [ESI]       ; EAX = ai(i) = P(i)
		MOV     EDX,EAX           ; memoriser
		ADD     EAX,DWORD PTR [ESI+EBX]       ; + ai(j)
		SUB     EAX,DWORD PTR [ESI-4]     ; - P(i-1)
		MOV     DWORD PTR [ESI],EAX       ; P(i)=EAX
		SUB     EDX,DWORD PTR [ESI+EBX]    ; EDX = ai(i) - ai(j)
		ADD     EDX,DWORD PTR [EDI-4]     ;        - Q(i-1)
		MOV     DWORD PTR [EDI],EDX       ; Q(i)=EDX

		SUB     EBX,8
		ADD     ESI,4
		ADD     EDI,4
		DEC	CX
		JNE	AI_LSP1

		MOV     ESI,[aip]         ;DS:SI vect. PP = P

		MOV     EAX,DWORD PTR [ESI+20]   ;EAX = P(5)
		ADD     EAX,1
		SAR     EAX,1
		SUB     EAX,DWORD PTR [ESI+12]   ;EAX = P(5)/2 - P(3)
		ADD     EAX,DWORD PTR [ESI+4]    ;      + P(1)
		XCHG    DWORD PTR [ESI],EAX      ; PP(0) = EAX et EAX = P(0)
		MOV     EBX,EAX          	 ; save EBX = P(0)
		SAL     EAX,2            	 ; EAX = 2*P(0)
		ADD     EAX,EBX          	 ; EAX = 5*P(0)
		ADD     EAX,DWORD PTR [ESI+16]   ;       + P(4)
		MOV     EDX,DWORD PTR [ESI+8]    ; EDX = P(2)
		ADD     EDX,EDX          	 ;   *2
		ADD     EDX,DWORD PTR [ESI+8]    ; EDX = 3*P(2)
		SUB     EAX,EDX          	 ; EAX = P(4) - 3*P(2) + 5*P(0)
		XCHG    EAX,DWORD PTR [ESI+4]    ; PP(1)=EAX et EAX = P(1)
		MOV     ECX,EAX          ; ECX = P(1)
		SAL     EAX,3            ; *8
		MOV     DWORD PTR [ESI+16],EAX   ; PP(4) = 8*P(1)
		NEG     EAX
		MOV     EDX,DWORD PTR [ESI+12]   ; EDX = P(3)
		ADD     EDX,EDX          ; * 2
		ADD     EAX,EDX          ; EAX = 2*P(3) - 8*P(1)
		XCHG    EAX,DWORD PTR [ESI+8]    ; PP(2) = EAX et EAX = P(2)
		SAL     EAX,2            ; EAX *= 4*P(2)
		SAL     EBX,2            ; EBX = 4*P0
		MOV     EDX,EBX          ; EDX = 4*P(0)
		SAL     EDX,2            ; EDX = 16*P(0)
		MOV     DWORD PTR [ESI+20],EDX   ; PP(5) = 16*P(0)
		ADD     EBX,EDX          ; EDX = 20*P(0)
		NEG     EBX
		ADD     EAX,EBX
		MOV     DWORD PTR [ESI+12],EAX   ; PP(3) = 4*P(2)-20*P(0)

		MOV     EDI,ESI
		ADD     ESI,4*11          ;DS:SI vect. Q
		ADD     EDI,4*6           ;DS:DI vect  QQ

		MOV     EAX,DWORD PTR [ESI+20]   ;EAX = Q(5)
		ADD     EAX,1
		SAR     EAX,1
		SUB     EAX,DWORD PTR [ESI+12]   ;EAX = Q(5)/2 - Q(3)
		ADD     EAX,DWORD PTR [ESI+4]    ;      + Q(1)
		MOV     DWORD PTR [EDI],EAX      ; QQ(0) = EAX
		MOV     EAX,DWORD PTR [ESI]      ; EAX = Q(0)
		MOV     EBX,EAX
		SAL     EAX,2            ; EAX = 2*Q(0)
		ADD     EAX,DWORD PTR [ESI]      ; EAX = 5*Q(0)
		ADD     EAX,DWORD PTR [ESI+16]   ;       + Q(4)
		MOV     EDX,DWORD PTR [ESI+8]    ; EDX = Q(2)
		ADD     EDX,EDX          ;   *2
		ADD     EDX,DWORD PTR [ESI+8]    ; EDX = 3*Q(2)
		SUB     EAX,EDX          ; EAX = Q(4) - 3*Q(2) + 5*Q(0)
		MOV     DWORD PTR [EDI+4],EAX    ; QQ(1)=EAX
		MOV     EAX,DWORD PTR [ESI+4]    ; EAX = Q(1)
		MOV     ECX,EAX          ; ECX = Q(1)
		SAL     EAX,3            ; *8
		MOV     DWORD PTR [EDI+16],EAX   ; QQ(4) = 8*Q(1)
		NEG     EAX
		MOV     EDX,DWORD PTR [ESI+12]   ; EDX = Q(3)
		ADD     EDX,EDX          ; * 2
		ADD     EAX,EDX          ; EAX = 2*Q(3) - 8*Q(1)
		MOV     DWORD PTR [EDI+8],EAX    ; QQ(2) = EAX
		MOV     EAX,DWORD PTR [ESI+8]    ; EAX = Q(2)
		SAL     EAX,2            ; EAX *= 4*Q(2)
		SAL     EBX,2            ; EBX = 4*Q0
		MOV     EDX,EBX          ; EDX = 4*Q(0)
		SAL     EDX,2            ; EDX = 16*Q(0)
		MOV     DWORD PTR [EDI+20],EDX   ; QQ(5) = 16*Q(0)
		ADD     EBX,EDX          ; EDX = 20*Q(0)
		NEG     EBX
		ADD     EAX,EBX
		MOV     DWORD PTR [EDI+12],EAX   ; QQ(3) = 4*Q(2)-20*Q(0)
	}
}

void horner(long *P,long *T,long *a,short n,short s)
{
	_asm
	{
		MOV     ESI,[P]
		MOV     EDI,[T]

		MOV     CX,[n]
		MOVSX   EBX,CX
		SAL     EBX,2
		ADD     ESI,EBX            ; SI : P(n)
		SUB     EBX,4
		ADD     EDI,EBX            ; DI : Q(n-1)

		MOV     EAX,DWORD PTR [ESI]      ; EAX = P(n)
		MOV     DWORD PTR [EDI],EAX        ; Q(n-1) = P(n)

		SUB     ESI,4

		DEC     CX
		MOVSX   EBX,WORD PTR [s]
	LOOP_HNR:
		MOV     EAX,DWORD PTR [EDI]      ; EAX = Q(i)
		IMUL    EBX              ; EDX:EAX = s*Q(i)
		ADD     EAX,16384        ;
		ADC     EDX,0
		SHRD    EAX,EDX,15       ; cadrer
		SUB     EDI,4
		ADD     EAX,DWORD PTR [ESI]      ; EAX = Q(i) = P(i) + s*Q(i)
		MOV     DWORD PTR [EDI],EAX      ;
		SUB     ESI,4
		DEC	CX
		JNE	LOOP_HNR


		MOV     EAX,DWORD PTR [EDI]      ; EAX = Q(0)
		IMUL    EBX              ; EDX:EAX = s*Q(0)
		ADD     EAX,16384        ;
		ADC     EDX,0
		SHRD    EAX,EDX,15       ; cadrer
		ADD     EAX,DWORD PTR [ESI]      ; EAX = P(0) + s*Q(0)

		MOV     ESI,[a]
		MOV     DWORD PTR [ESI],EAX
	}
}

#pragma warning(disable : 4035)
short calcul_s(long a,long b)
{
	_asm
	{
		MOV     EBX,[b]
		ADD     EBX,0
		JGE     B_POSIT
		NEG     EBX
	B_POSIT:
		MOV     CL,0
		CMP     EBX,40000000H   ;normaliser b
		JGE     OUT_NORM
	NORM_B:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H   ;
		JGE     OUT_NORM
		JMP     NORM_B
	OUT_NORM:
		ADD     EBX,16384
		SAR     EBX,15
		MOV     EDX,[b]
		ADD     EDX,0
		JGE     PUT_SIGN
		NEG     EBX
	PUT_SIGN:
		MOV     EAX,[a]
		SAL     EAX,CL           ; shifter a de CL
		CDQ
		IDIV    EBX              ; AX = a/b

		MOV     BX,AX

		IMUL    BX               ; DX:AX = sqr(a/b)
		ADD     AX,8192
		ADC     DX,0
		SHRD    AX,DX,14         ; AX = 2*sqr(a/b)
		MOV     DX,AX
		ADD     DX,1
		SAR     DX,1
		ADD     AX,DX            ; AX = 3*sqr(a/b)
		NEG     AX
		SUB     AX,BX            ; AX = -a/b - 3*sqr(a/b)
	}
}

#pragma warning(default : 4035)

void binome(short *lsp,long *PP)
{
	short inc_sq;
	long sqr;

	_asm
	{
		MOV     EDI,[lsp]
		MOV     ESI,[PP]

		MOV     EBX,DWORD PTR [ESI+8]    ;EBX = PP(2)
		ADD     EBX,0
		JGE     B_POSIT_P
		NEG     EBX
	B_POSIT_P:
		MOV     CL,0
		CMP     EBX,40000000H   ;normaliser PP(2)
		JGE     OUT_NORM_P
	NORM_B_P:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H   ;
		JGE     OUT_NORM_P
		JMP     NORM_B_P
	OUT_NORM_P:
		ADD     EBX,16384
		SAR     EBX,15

		MOV     EDX,DWORD PTR [ESI+8]
		ADD     EDX,0
		JGE     PUT_SIGN_P
		NEG     EBX
	PUT_SIGN_P:                              ; BX = PP(2)

		MOV     EAX,DWORD PTR [ESI]      ; EAX = PP(0)
		SAL     EAX,CL           ; shifter a de CL
		CDQ
		IDIV    EBX              ; AX = PP(0)/PP(2)
		NEG     AX
		MOV     WORD PTR [EDI],AX       ; ES:[DI] = -PP(0)/PP(2)

		MOV     EAX,DWORD PTR [ESI+4]    ; EAX = PP(1)
		SAL     EAX,CL           ; shifter a de CL
		SAR     EAX,1
		CDQ
		IDIV    EBX
		NEG     EAX               ; va = AX = -PP(1)/2*PP(2)
		MOV     DWORD PTR [ESI],EAX
		MOV     CX,WORD PTR [EDI]        ; vb = CX = -PP(0)/PP(2)

		IMUL    EAX               ; EAX = va*va

		MOVSX   EBX,CX           ; EAX = vb
		SAL     EBX,15           ; EAX = vb*32768

		ADD     EAX,EBX          ; EBX = va*va + vb*32768

		MOV     [sqr],EAX

		MOV     CX,14            ; CX = compteur
		MOV     BX,0             ; BX = racine
		MOV     WORD PTR [inc_sq],4000H ;

	SQRT_L:
		ADD     BX,[inc_sq]      ; rac += incrm
		MOVSX   EAX,BX
		IMUL    EAX              ; EAX = rac*rac
		SUB     EAX,[sqr]        ; EAX = rac*rac - SQR

		JZ      VITA_SQ
		JLE     NEXTIT

		SUB     BX,[inc_sq]       ; rac = rac - incrm
	NEXTIT:
		SAR     WORD PTR [inc_sq],1  ; incrm >> 1
		DEC	CX
		JNE	SQRT_L

	VITA_SQ:

		MOV     EAX,DWORD PTR [ESI]         ; AX = b
		MOV     DX,AX
		SUB     AX,BX               ; AX = b-sqrt()
		MOV     WORD PTR [EDI+4],AX        ; sauver

		ADD     DX,BX               ; DX = b+sqrt()
		MOV     WORD PTR [EDI],DX          ; sauver

						; idem with QQ

		ADD     ESI,24            ;DS:SI  QQ
		MOV     EBX,DWORD PTR [ESI+8]    ;EBX = QQ(2)
		ADD     EBX,0
		JGE     B_POSIT_Q
		NEG     EBX
	B_POSIT_Q:
		MOV     CL,0
		CMP     EBX,40000000H   ;normaliser QQ(2)
		JGE     OUT_NORM_Q
	NORM_B_Q:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H   ;
		JGE     OUT_NORM_Q
		JMP     NORM_B_Q
	OUT_NORM_Q:
		ADD     EBX,16384
		SAR     EBX,15

		MOV     EDX,DWORD PTR [ESI+8]
		ADD     EDX,0
		JGE     PUT_SIGN_Q
		NEG     EBX
	PUT_SIGN_Q:                               ; BX = QQ(2)

		MOV     EAX,DWORD PTR [ESI]      ; EAX = QQ(0)
		SAL     EAX,CL           ; shifter a de CL
		CDQ
		IDIV    EBX              ; AX = QQ(0)/QQ(2)
		NEG     AX
		MOV     WORD PTR [EDI+2],AX       ; ES:[DI+2] = -QQ(0)/QQ(2)

		MOV     EAX,DWORD PTR [ESI+4]    ; EAX = QQ(1)
		SAL     EAX,CL           ; shifter a de CL
		SAR     EAX,1
		CDQ
		IDIV    EBX
		NEG     EAX               ; va = AX = -QQ(1)/2*QQ(2)
		MOV     DWORD PTR [ESI],EAX
		MOV     CX,WORD PTR [EDI+2]        ; vb = CX = -QQ(0)/QQ(2)

		IMUL    EAX               ; EAX = va*va

		MOVSX   EBX,CX           ; EAX = vb
		SAL     EBX,15           ; EAX = vb*32768

		ADD     EAX,EBX          ; EBX = va*va + vb*32768

		MOV     [sqr],EAX

		MOV     CX,14            ; CX = compteur
		MOV     BX,0             ; BX = racine
		MOV     WORD PTR [inc_sq],4000H ;

	SQRT_LQ:
		ADD     BX,[inc_sq]      ; rac += incrm
		MOVSX   EAX,BX
		IMUL    EAX              ; EAX = rac*rac
		SUB     EAX,[sqr]        ; EAX = rac*rac - SQR

		JZ      VITA_SQ2
		JLE     NEXTITQ

		SUB     BX,[inc_sq]       ; rac = rac - incrm
	NEXTITQ:
		SAR     WORD PTR [inc_sq],1  ; incrm >> 1
		DEC	CX
		JNE	SQRT_LQ

	VITA_SQ2:
		MOV     EAX,DWORD PTR [ESI]         ; AX = b
		MOV     DX,AX
		SUB     AX,BX               ; AX = b-sqrt()
		MOV     WORD PTR [EDI+6],AX        ; sauver

		ADD     DX,BX               ; DX = b+sqrt()
		MOV     WORD PTR [EDI+2],DX          ; sauver
	}
}

void deacc(short *src,short *dest,short fact,short lfen,short *last_out)
{
	_asm
	{
		MOV     ESI,[src]
		MOV     EDI,[dest]

		MOV     EBX,[last_out]        ; FS:BX = last_out
		MOV     AX,WORD PTR [EBX]        ; AX = last_out
		MOV     BX,[fact]         ; BX = Fact
		MOV     CX,[lfen]          ; init compteur

	LOOP_DEAC:
		IMUL    BX                ; DX:AX = fact * y(i-1)
		ADD     AX,16384
		ADC     DX,0              ; arrondi
		SHLD    DX,AX,1           ; DX = fact * x(i-1;
		MOV     AX,WORD PTR [ESI]        ; AX = x(i)
		ADD     AX,DX             ; DX = x(i) + fact*x(i-1)
		MOV     WORD PTR [EDI],AX        ;Sauver Xout
		ADD     ESI,2              ;
		ADD     EDI,2              ;Pointer composantes suivantes
		DEC	CX
		JNE	LOOP_DEAC


		MOV     EBX,[last_out]
		MOV     WORD PTR [EBX],AX        ;Sauver dernier chantillon
	}
}

void filt_in(short *mem,short *Vin,short *Vout,short lfen)
{
	_asm
	{
		MOV	CX,[lfen]		;CX=cpteur

		MOV	EDI,[mem]
	FIL_IN_LOOP:
		MOV	ESI,[Vin]
		MOV	BX,WORD PTR [ESI]              ;BX=Xin
		SAR	BX,2			;div par 4
		MOV	AX,WORD PTR [EDI]		;AX=z(1)
		MOV	WORD PTR [EDI],BX              ;mise a jour memoire
		SUB	BX,AX                   ;BX=(Xin-z(1))/4
		ADD	DWORD PTR [Vin],2	  ;pointer echant svt
		MOV	AX,WORD PTR [EDI+2]		;AX=z(2)
		MOV	DX,29491		;DX=0.9
		IMUL	DX  			;DX=0.9*z(2)
		ADD	AX,16384
		ADC	DX,0                    ;arrondi et dble signe
		SHLD	DX,AX,1
		ADD	DX,BX			;reponse=DX=tmp
		MOV	WORD PTR [EDI+2],DX            ;mise a jour memoire
		MOV	ESI,[Vout]
		MOV	WORD PTR [ESI],DX     ;output=tmp/4
		ADD	DWORD PTR [Vout],2  ;pointer echant svt
		DEC	CX
		JNE	FIL_IN_LOOP
	}
}

/*
void cal_dic1(short *y,short *sr,short *espopt,short *posit,short dec,
	short esp,short SIGPI[],short SOULONG,long TLSP[],long VMAX[])
{
	short ss,vene;

	_asm
	{
		PUSH	WORD PTR [INT_SOUL]
		MOV	SI,WORD PTR [INT_SIG]
		ADD	SI,300
		PUSH	SI
		PUSH	WORD PTR [INT_Y]
		CALL	near ptr venergy
		ADD	SP,6
		MOV	BX,WORD PTR [INT_SOUL]
		SAL	BX,2
		ADD	SI,BX
		SUB	SI,4
		MOV	WORD PTR [VENE],SI

		MOV	AX,WORD PTR [INT_SOUL]
		MOV	WORD PTR [INT_SS],AX
		ADD	AX,WORD PTR [INT_SR]
		ADD     WORD PTR [INT_SS],AX

		MOV	DI,0
		MOV	SI,WORD PTR [LG_TLSP]

		PUSH	WORD PTR [LG_VMAX]
		PUSH	SI

DEC1_LOOP:	MOV	BX,WORD PTR [INT_SR]
		MOV	EAX,0
		MOV	DWORD PTR [SI],EAX
		ADD	BX,DI
		ADD	BX,DI
DEC1_BCLE:	MOVSX	EAX,WORD PTR [BX]
		ADD	DWORD PTR [SI],EAX
		MOV	AX,WORD	PTR [INT_ESP]
		ADD	BX,AX
		ADD	BX,AX
		CMP	BX,WORD PTR [INT_SS]
		JL	DEC1_BCLE
		MOV	BX,WORD PTR [VENE]
		SAL	DI,2
		SUB	BX,DI
		SAR	DI,2
		MOV	EAX,DWORD PTR [BX]
		MOV	DWORD PTR [SI+4],EAX

		CALL	upd_max_d

		ADD	AX,0
		JE	NO_LIMIT
		MOV	BX,WORD PTR [INT_POS]
		MOV	WORD PTR [BX],DI
		MOV	BX,WORD PTR [INT_EO]
		MOV	AX,WORD PTR [INT_ESP]
		MOV	WORD PTR [BX],AX

NO_LIMIT:	INC	DI
		CMP	DI,WORD PTR [INT_DEC]
		JL      DEC1_LOOP

		ADD	SP,4

		POP	DI
		POP	SI
		MOV	SP,BP
		POP	BP

		RET

cal_dic1	ENDP



COMMENT #
COMMENT &
___ void cal_dic2(int q,int espace,int phase,int *s_r,int *hy,int *b,
___ int *vois,int *esp,int *qq,int *phas,int SIGPI[],
___ int SOULONG,long TLSP[],long VMAX[],(int PITCH))
___                                       |--->en option...
&

R11		EQU  BP-4
Y1		EQU  BP-6
Y2		EQU  BP-8
IO		EQU  BP-10
ST_CC		EQU  BP-30
ST_SRC		EQU  BP-50

INT_Q		EQU  BP+6
ESPACE		EQU  BP+8
PHASE		EQU  BP+10
INT_SR		EQU  BP+12
S_INT_SR	EQU  BP+14
HY 		EQU  BP+16
S_HY		EQU  BP+18
INT_B		EQU  BP+20
S_INT_B		EQU  BP+22
VOIS		EQU  BP+24
S_VOIS		EQU  BP+26
INT_ESP		EQU  BP+28
S_ESP		EQU  BP+30
QQ	        EQU  BP+32
S_QQ		EQU  BP+34
PHAS		EQU  BP+36
S_PHAS		EQU  BP+38
SIGPI		EQU  BP+40
S_SIGPI		EQU  BP+42
SOULONG		EQU  BP+44
TLSP		EQU  BP+46
S_TLSP		EQU  BP+48
VMAX		EQU  BP+50
S_VMAX		EQU  BP+52
;PITCH		EQU  BP+54

cal_dic2	PROC	FAR

		PUSH	BP
		MOV	BP,SP
		SUB	SP,50
		PUSH	SI
		PUSH	DI
		PUSH	DS
;		PUSH	ES

		MOV	DWORD PTR [R11],0
		PUSH	WORD PTR [SOULONG]
		PUSH	WORD PTR [S_SIGPI]
		MOV	SI,WORD PTR [SIGPI]
		ADD	SI,300
		MOV	WORD PTR [Y1],SI
		SUB	SI,150
		MOV	WORD PTR [Y2],SI
		PUSH	SI
		CALL	init_zero
		ADD	SP,6

		MOV	AX,WORD PTR [PHASE]
		SUB	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX
		PUSH	WORD PTR [SOULONG]
		SUB	SP,2
		PUSH	WORD PTR [S_HY]
		PUSH	WORD PTR [HY]
		PUSH	WORD PTR [S_SIGPI]
		PUSH	SI
		ADD	SP,10

		MOV	SI,0
		MOV	DS,WORD PTR [S_INT_SR]
CAL2_LOOP:	MOV	DI,WORD PTR [INT_SR]
		MOV	AX,WORD PTR [IO]
		ADD	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX
		ADD	DI,AX
		ADD	DI,AX
		MOVSX	EBX,WORD PTR DS:[DI]
		ADD	SI,SI
		MOV	WORD PTR SS:[ST_SRC+SI],BX
		ADD	EBX,0
		JL	SRC_NEG
		MOV	WORD PTR SS:[ST_CC+SI],1
		ADD	DWORD PTR [R11],EBX
		PUSH	AX
		SUB	SP,8
		CALL	add_sf_vect
		ADD	SP,10
		JMP	CAL2_SUITE
SRC_NEG:  	MOV	WORD PTR SS:[ST_CC+SI],-1
		SUB	DWORD PTR [R11],EBX
		PUSH	AX
		SUB	SP,8
		CALL	sub_sf_vect
		ADD	SP,10
CAL2_SUITE:	SAR	SI,1
		ADD	SI,1
		CMP	SI,WORD PTR [INT_Q]
		JL	CAL2_LOOP
		ADD	SP,2


		PUSH	WORD PTR [SOULONG]
		PUSH	WORD PTR [S_TLSP]
		MOV	SI,WORD PTR [TLSP]
		ADD	SI,4
		PUSH	SI
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y2]
		CALL	energy2
		ADD	SP,10


		MOV	DS,WORD PTR [S_TLSP]
		MOV	SI,WORD PTR [TLSP]
		MOV	EAX,DWORD PTR [R11]
		MOV	DS:[SI],EAX

		PUSH	WORD PTR [S_VMAX]
		PUSH	WORD PTR [VMAX]
		PUSH	DS
		PUSH	SI
		CALL	upd_max_d
		ADD	SP,8
		ADD	AX,0
		JE	UPD_NULL
		PUSH	WORD PTR [INT_Q]
		PUSH	WORD PTR [S_INT_B]
		PUSH	WORD PTR [INT_B]
		PUSH	SS
		MOV	AX,BP
		SUB	AX,30
		PUSH	AX
		CALL	int_to_int
		ADD	SP,10
		MOV	SI,WORD PTR [VOIS]
		MOV	DS,WORD PTR [S_VOIS]
		MOV	DS:[SI],WORD PTR 0
		MOV	DS,WORD PTR [S_ESP]
		MOV	SI,WORD PTR [INT_ESP]
		MOV	AX,WORD PTR [ESPACE]
		MOV	DS:[SI],AX
		MOV	DS,WORD PTR [S_QQ]
		MOV	SI,WORD PTR [QQ]
		MOV	AX,WORD PTR [INT_Q]
		MOV	DS:[SI],AX
		MOV	DS,WORD PTR [S_PHAS]
		MOV	SI,WORD PTR [PHAS]
		MOV	AX,WORD PTR [PHASE]
		MOV	DS:[SI],AX

UPD_NULL:     ;	CMP	WORD PTR [PITCH],80
	      ;	JG	FINI
COMMENT &
		MOV	AX,WORD PTR [PHASE]
		SUB	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX

		MOV	SI,0

CAL2_LOOP2:     ADD	SI,SI
		MOV	AX,WORD PTR SS:[ST_CC+SI]
		NEG	AX
		MOV	WORD PTR SS:[ST_CC+SI],AX
		MOV	EDX,DWORD PTR [R11]
		MOVSX	EBX,WORD PTR SS:[ST_SRC+SI]
		ADD	AX,0
		JL	CC_NEG
		ADD	EDX,EBX
		ADD	EDX,EBX
		JMP     CC_NEXT
CC_NEG:         SUB	EDX,EBX
		SUB	EDX,EBX

CC_NEXT:
		MOV	DI,WORD PTR [TLSP]
		MOV	DS,WORD PTR [S_TLSP]
		MOV	DS:[DI],EDX
		MOV	AX,WORD PTR [IO]
		ADD	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX
		MOV	BX,WORD PTR SS:[ST_CC+SI]
		ADD	BX,BX
		PUSH	BX
		PUSH	AX
		PUSH	WORD PTR [SOULONG]
		PUSH	WORD PTR [S_HY]
		PUSH	WORD PTR [HY]
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y2]
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y1]
		CALL	update_dic
		ADD	SP,18
		PUSH	WORD PTR [SOULONG]
		PUSH	DS
		MOV	BX,WORD PTR [TLSP]
		ADD	BX,4
		PUSH	BX
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y1]
		CALL	energy2
		ADD	SP,10

		PUSH	WORD PTR [S_VMAX]
		PUSH	WORD PTR [VMAX]
		PUSH	DS
		PUSH	WORD PTR [TLSP]
		CALL	upd_max_d
		ADD	SP,8
		ADD	AX,0
		JE	CAL2_END
		PUSH	WORD PTR [INT_Q]
		PUSH	WORD PTR [S_INT_B]
		PUSH	WORD PTR [INT_B]
		PUSH	SS
		MOV	AX,BP
		SUB	AX,30
		PUSH	AX
		CALL	int_to_int
		ADD	SP,10
		MOV	DI,WORD PTR [TLSP]
		MOV	EAX,DS:[DI]
		MOV	DWORD PTR [R11],EAX
		MOV	AX,WORD PTR [Y1]
		XCHG	AX,WORD PTR [Y2]
		MOV 	WORD PTR [Y1],AX

		MOV	DI,WORD PTR [VOIS]
		MOV	DS,WORD PTR [S_VOIS]
		MOV	DS:[DI],WORD PTR 0
		MOV	DS,WORD PTR [S_ESP]
		MOV	DI,WORD PTR [INT_ESP]
		MOV	AX,WORD PTR [ESPACE]
		MOV	DS:[DI],AX
		MOV	DS,WORD PTR [S_QQ]
		MOV	DI,WORD PTR [QQ]
		MOV	AX,WORD PTR [INT_Q]
		MOV	DS:[DI],AX
		MOV	DS,WORD PTR [S_PHAS]
		MOV	DI,WORD PTR [PHAS]
		MOV	AX,WORD PTR [PHASE]
		MOV	DS:[DI],AX
		JMP	CAL2_OUT
CAL2_END:	NEG	WORD PTR SS:[ST_CC+SI]
CAL2_OUT:       SAR	SI,1
		ADD	SI,1
		CMP	SI,WORD PTR [INT_Q]
		JL	CAL2_LOOP2

FINI:
&
;		POP	ES
		POP	DS
		POP	DI
		POP	SI
		MOV	SP,BP
		POP	BP

		RET

cal_dic2	ENDP
#

COMMENT &
___ void calc_p(int *p1,int *p2,int pitch,int lim_p1,int lim_p2,int no);
&


P1	EQU	BP+4
P2	EQU	BP+6
PITCH	EQU	BP+8
LIM_P1	EQU	BP+10
LIM_P2	EQU	BP+12
INT_NO	EQU	BP+14

calc_p		PROC    near

		PUSH 	BP             ; save contexte
		MOV	BP,SP          ;
		PUSH	SI             ; save C register
		PUSH	DI

		MOV	BX,WORD PTR [PITCH]
		MOV	SI,WORD PTR [P1]
		MOV	CX,WORD PTR [LIM_P1]
		MOV	AX,WORD PTR [INT_NO]
		ADD	AX,0
		JE	NUM_NULL
		SUB	BX,3
		CMP	BX,CX
		JL	P1_NEG1
		MOV	WORD PTR [SI],BX
		JMP	P1_SUITE1
P1_NEG1:        MOV	WORD PTR [SI],CX
P1_SUITE1:	ADD	BX,7
		MOV	CX,WORD PTR [LIM_P2]
		MOV	SI,WORD PTR [P2]
		CMP	BX,CX
		JG	P2_POS1
		MOV	WORD PTR [SI],BX
		JMP	P_FIN
P2_POS1:	MOV	WORD PTR [SI],CX
		JMP	P_FIN

NUM_NULL:       SUB	BX,5
		CMP	BX,CX
		JL	P1_NEG2
		MOV	WORD PTR [SI],BX
		JMP	P1_SUITE2
P1_NEG2:        MOV	WORD PTR [SI],CX
P1_SUITE2:	ADD	BX,10
		MOV	CX,WORD PTR [LIM_P2]
		MOV	SI,WORD PTR [P2]
		CMP	BX,CX
		JG	P2_POS2
		MOV	WORD PTR [SI],BX
		JMP	P_FIN
P2_POS2:	MOV	WORD PTR [SI],CX

P_FIN:
		POP     DI
		POP     SI
		MOV 	SP,BP
		POP	BP

		RET

calc_p		ENDP
*/

#pragma warning(disable : 4035)
short calc_gltp(short *gltp,short *bq,short *bv,long ttt)
{
	_asm
	{
		MOV	EBX,DWORD PTR [ttt]
		CMP	EBX,32767
		JLE	TEST2
		MOV	AX,32767
		JMP	OUT_TEST
	TEST2:
		CMP	EBX,-32767
		JGE	TEST3
		MOV	AX,-32767
		JMP	OUT_TEST
	TEST3:
		MOV	AX,BX
	OUT_TEST:
		MOV	BX,AX		; BX=GLTP
		ADD	AX,0
		JGE	GLTP_POS
		NEG	AX		; AX=abs(GLTP)

	GLTP_POS:
		MOV	CX,0
		MOV	ESI,[bq]
		MOV	EDI,[bv]
	BOUCLER:
		ADD	CX,1
		CMP	CX,11
		JE	FIN_BOUCLER
		ADD	EDI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JL	BOUCLER
		ADD	ESI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JGE	BOUCLER
		ADD	BX,0
		JLE	GLTP_NEG
		DEC	CX		;CX=k
		MOV	BX,WORD PTR [EDI]
		JMP	FIN_BOUCLER
	GLTP_NEG:
		ADD	CX,9
		MOV	BX,WORD PTR [EDI]
		NEG	BX
	FIN_BOUCLER:
		MOV	ESI,[bq]
		ADD	ESI,20
		MOV	DX,WORD PTR [ESI]
		CMP	BX,DX
		JL 	GLTP_P
		MOV	EDI,[bv]
		ADD	EDI,20
		MOV	BX,WORD PTR [EDI]
		MOV	CX,9
	GLTP_P:
		SUB	ESI,8
		MOV	DX,WORD PTR [ESI]
		NEG	DX
		CMP	BX,DX
		JGE	GLTP_G
		MOV	EDI,[bv]
		ADD	EDI,12
		MOV	BX,WORD PTR [EDI]
		NEG	BX
		MOV	CX,15
	GLTP_G:
		MOV	ESI,[gltp]
		MOV	WORD PTR [ESI],BX

		MOV	AX,CX
	}
}
#pragma warning(default : 4035)


#pragma warning(disable : 4035)

short calc_garde(short MAX)
{
	_asm
	{
		MOV	AX,0
		MOV	BX,WORD PTR [MAX]
		AND	BX,0FE00H
		JE	STORE
		SAR	BX,9

	BCLE_SAR:
		INC	AX
		SAR	BX,1
		JE	STORE
		CMP	AX,5
		JNE	BCLE_SAR
	STORE:
	}
}
#pragma warning(default : 4035)

#pragma warning(disable : 4035)
short calc_gopt(short *c,short *code,short *gq,short *gv,short voise,
	short npopt,short pitch,short espopt,short depl,short position,
	short soudecal,long vmax)
{
	_asm
	{
		MOV	EBX,DWORD PTR [vmax]
		CMP	EBX,32767
		JLE	COMP2
		MOV	AX,32767
		JMP	OUT_COMP
	COMP2:
		CMP	EBX,-32767
		JGE	COMP3
		MOV	AX,-32767
		JMP	OUT_COMP
	COMP3:
		MOV	AX,BX              	;AX=Gopt
	OUT_COMP:
		MOV	BX,WORD PTR [voise]
		ADD	BX,0
		JNE	VOIS_1

		MOV	ESI,[c]
		MOV	BX,WORD PTR [ESI]
		CMP	BX,-1
		JNE	CO_1
		NEG	AX
		MOVSX	ECX,WORD PTR [npopt]
		ADD	ESI,ECX
		ADD	ESI,ECX
	CX_BCLE:
		SUB	ESI,2
		NEG	WORD PTR [ESI]
		DEC	CX
		JNE	CX_BCLE
	CO_1:
		MOV	CX,WORD PTR [npopt]
		CMP	CX,8
		JNE	NPOPT_9
		MOV	DX,128
		JMP	NP_NEXT
	NPOPT_9:
		MOV	DX,256			;DX=cod
	NP_NEXT:
		MOV	DI,1
		MOV	ESI,[c]
		DEC	CX
	CJ_BCLE:
		ADD	ESI,2
		DEC	CX
		MOV	BX,WORD PTR [ESI]
		SUB	BX,1
		JNE	CJ_1
		MOV	BX,1
		SAL	BX,CL
		ADD	DX,BX
	CJ_1:
		INC	DI
		CMP	DI,WORD PTR [npopt]
		JL	CJ_BCLE
		JMP	VOIS_0
	VOIS_1:
		MOV	BX,WORD PTR [espopt]
		MOV	DX,WORD PTR [position]
		CMP	BX,WORD PTR [pitch]
		JE	VOIS_0
		ADD	DX,WORD PTR [soudecal]

	VOIS_0:
		MOVSX	ESI,[depl]			
		ADD	ESI,ESI
		ADD	ESI,24
		ADD	ESI,[c]
		MOV	WORD PTR [ESI],DX		; code[12+depl]=cod

		ADD	AX,0
		JGE	SIGN_0
		NEG	AX
		MOV	BX,1
		JMP	SIGN_1
	SIGN_0:
		MOV	BX,0

	SIGN_1:
		MOV	CX,0
		MOV	ESI,[gq]
		MOV	EDI,[gv]

	BOUCLER2:
		ADD	CX,1
		CMP	CX,17
		JE	FIN_BOUCLER2
		ADD	EDI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JL	BOUCLER2
		ADD	ESI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JGE	BOUCLER2
		DEC	CX			;CX=cod
		MOV	AX,WORD PTR [EDI]		;AX=Gopt

	FIN_BOUCLER2:
		MOV	ESI,[gq]
		ADD	ESI,32
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JL 	G_GQ
		MOV	EDI,[gv]
		ADD	EDI,32
		MOV	AX,WORD PTR [EDI]
		MOV	CX,15

	G_GQ:
		ADD	BX,0
		JE	SIGN_NULL
		NEG	AX
		ADD	CX,16

	SIGN_NULL:
		MOVSX	ESI,WORD PTR [depl]
		ADD	ESI,ESI
		ADD	ESI,26
		ADD	ESI,[c]
		MOV	WORD PTR [ESI],CX
	}
}
#pragma warning(default : 4035)

void decimation(short *vin,short *vout,short nech)
{
	_asm
	{
		MOV	EDI,[vin]
		MOV	ESI,[vout]

	DECIMATE:
		MOV	AX,WORD PTR [EDI]
		MOV	WORD PTR [ESI],AX
		ADD	EDI,8
		ADD	ESI,2
		DEC	WORD PTR [nech]
		JNE	DECIMATE
	}
}
#else

void proc_gain(long *corr_ene,long gain)
{
	// TODO need 64-bit
}

void inver_v_int(short *src,short *dest,short lng)
{
	// TODO need 64-bit
}

short max_vect(short *vech,short nech)
{
	// TODO need 64-bit
	return 0;
}

void upd_max(long *corr_ene,long *vval,short pitch)
{
	// TODO need 64-bit
}

short upd_max_d(long *corr_ene,long *vval)
{
	// TODO need 64-bit
	return 0;
}

void norm_corrl(long *corr,long *vval)
{
	// TODO need 64-bit
}

void norm_corrr(long *corr,long *vval)
{
	// TODO need 64-bit
}

void energy(short *vech,long *ene,short lng)
{
	// TODO need 64-bit
}

void venergy(short *vech,long *vene,short lng)
{
	// TODO need 64-bit
}

void energy2(short *vech,long *ene,short lng)
{
	// TODO need 64-bit
}

void upd_ene(long *ener,long *val)
{
	// TODO need 64-bit
}

short max_posit(long *vcorr,long *maxval,short pitch,short lvect)
{
	// TODO need 64-bit
	return 0;
}

void correlation(short *vech,short *vech2,long *acc,short lng)
{
	// TODO need 64-bit
}

void  schur(short *parcor,long *Ri,short netages)
{
	// TODO need 64-bit
}

void interpol(short *lsp1,short *lsp2,short *dest,short lng)
{
	// TODO need 64-bit
}

void add_sf_vect(short *y1,short *y2,short deb,short lng)
{
	// TODO need 64-bit
}

void sub_sf_vect(short *y1,short *y2,short deb,short lng)
{
	// TODO need 64-bit
}

void short_to_short(short *src,short *dest,short lng)
{
	int i;

	for(i=0; i<lng; i++)
		*dest++ = *src++;
}


void long_to_long(long *src,long *dest,short lng)
{
	// TODO need 64-bit
}

void init_zero(short *src,short lng)
{
	// TODO need 64-bit
}

void update_ltp(short *y1,short *y2,short hy[],short lng,short gdgrd,short fact)
{
	// TODO need 64-bit
}

void proc_gain2(long *corr_ene,long *gain,short bit_garde)
{
	// TODO need 64-bit
}

void decode_dic(short *code,short dic,short npuls)
{
	// TODO need 64-bit
}

void dsynthesis(long *z,short *coef,short *input,short *output,
										short lng,short netages)
{
	// TODO need 64-bit
}

void synthesis(short *z,short *coef,short *input,short *output,
				short lng,short netages,short bdgrd )
{
	// TODO need 64-bit
}

void synthese(short *z,short *coef,short *input,short *output,
						short lng,short netages)
{
	// TODO need 64-bit
}

void f_inverse(short *z,short *coef,short *input,short *output,
						short lng,short netages )
{
	// TODO need 64-bit
}

void filt_iir(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre)
{
	// TODO need 64-bit
}

void mult_fact(short src[],short dest[],short fact,short lng)
{
	// TODO need 64-bit
}

void mult_f_acc(short src[],short dest[],short fact,short lng)
{
	// TODO need 64-bit
}

void dec_lsp(short *code,short *tablsp,short *nbit,short *bitdi,short *tabdi)
{
	// TODO need 64-bit
}

void teta_to_cos(short *tabcos,short *lsp,short netages)
{
	// TODO need 64-bit
}

void cos_to_teta(short *tabcos,short *lsp,short netages)
{
	// TODO need 64-bit
}

void lsp_to_ai(short *ai_lsp,long *tmp,short netages)
{
	// TODO need 64-bit
}

void ki_to_ai(short *ki,long *ai,short netages)
{
	// TODO need 64-bit
}

void ai_to_pq(long *aip,short netages)
{
	// TODO need 64-bit
}

void horner(long *P,long *T,long *a,short n,short s)
{
	// TODO need 64-bit
}

short calcul_s(long a,long b)
{
	// TODO need 64-bit
	return 0;
}

void binome(short *lsp,long *PP)
{
	// TODO need 64-bit
}

void deacc(short *src,short *dest,short fact,short lfen,short *last_out)
{
	// TODO need 64-bit
}

void filt_in(short *mem,short *Vin,short *Vout,short lfen)
{
	// TODO need 64-bit
}

short calc_gltp(short *gltp,short *bq,short *bv,long ttt)
{
	// TODO need 64-bit
	return 0;
}

short calc_garde(short MAX)
{
	// TODO need 64-bit
	return 0;
}

short calc_gopt(short *c,short *code,short *gq,short *gv,short voise,
	short npopt,short pitch,short espopt,short depl,short position,
	short soudecal,long vmax)
{
	// TODO need 64-bit
	return 0;
}

void decimation(short *vin,short *vout,short nech)
{
	// TODO need 64-bit
}
#endif

#ifndef _X86_
/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: DotProduct                                              */
/*  Author: Bill Hallahan                                             */
/*  Date: March 10, 1997                                              */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function returns the dot product of a set of two      */
/*    vectors.                                                        */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    pVector_0    A pointer of type T that points to the first       */
/*                 input vector.                                      */
/*                                                                    */
/*    pVector_1    A pointer of type T that points to the second      */
/*                 input vector.                                      */
/*                                                                    */
/*    uiLength     The length of the input vectors.                   */
/*                                                                    */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*    The dot product of the two input vectors is calculated. The     */
/*    return value is a 64 bit Q30 number.                            */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Start of routine DotProduct().                                    */
/**********************************************************************/

_int64 DotProduct( int * piVector_0,
                   int * piVector_1,
                   unsigned int uiLength )
{
  /********************************************************************/
  /*  Do the multiply-accumulates in groups of 8 values.              */
  /********************************************************************/

  _int64 qSum = 0;

  while ( uiLength >= 8 )
  {
    qSum += *piVector_0 * *piVector_1;
    qSum += *(piVector_0+1) * *(piVector_1+1);
    qSum += *(piVector_0+2) * *(piVector_1+2);
    qSum += *(piVector_0+3) * *(piVector_1+3);
    qSum += *(piVector_0+4) * *(piVector_1+4);
    qSum += *(piVector_0+5) * *(piVector_1+5);
    qSum += *(piVector_0+6) * *(piVector_1+6);
    qSum += *(piVector_0+7) * *(piVector_1+7);
    piVector_0 += 8;
    piVector_1 += 8;
    uiLength -= 8;
  }

  /********************************************************************/
  /*  Conditionally do a group of 4 multiply-accumulates.             */
  /********************************************************************/

  if ( uiLength >= 4 )
  {
    qSum += *piVector_0 * *piVector_1;
    qSum += *(piVector_0+1) * *(piVector_1+1);
    qSum += *(piVector_0+2) * *(piVector_1+2);
    qSum += *(piVector_0+3) * *(piVector_1+3);
    piVector_0 += 4;
    piVector_1 += 4;
    uiLength -= 4;
  }

  /********************************************************************/
  /*  Conditionally do a group of 2 multiply-accumulates.             */
  /********************************************************************/

  if ( uiLength >= 2 )
  {
    qSum += *piVector_0 * *piVector_1;
    qSum += *(piVector_0+1) * *(piVector_1+1);
    piVector_0 += 2;
    piVector_1 += 2;
    uiLength -= 2;
  }

  /********************************************************************/
  /*  Conditionally do a single multiply-accumulate.                  */
  /********************************************************************/

  if ( uiLength >= 1 )
  {
    qSum += *piVector_0 * *piVector_1;
  }

  return qSum;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: FirFilter                                               */
/*  Author: Bill Hallahan                                             */
/*  Date: March 10, 1997                                              */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function returns the dot product of a set of FIR      */
/*    filter coefficients and the data in a circular delay line.      */
/*    All of the input and output data has Q15 scaling.               */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    piFilterCoefficients  A pointer to the FIR filter               */
/*                          coefficients which are in reverse time    */
/*                          order.                                    */
/*                                                                    */
/*    piFilterDelay      A pointer to a delay line that contains the  */
/*                       input samples.                               */
/*                                                                    */
/*    iDelayPosition     An index into the filter delay line.         */
/*                                                                    */
/*    iFilterLength      The length of the filter impulse response.   */
/*                       (Also the number of filter coefficients.     */
/*                                                                    */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*         The dot product of the fir filter coefficients and the     */
/*    data in the circular delay line is returned.                    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Start of routine FirFilter().                                     */
/**********************************************************************/

int FirFilter( int * piFilterCoefficients,
               int * piFilterDelay,
               unsigned int uiDelayPosition,
               unsigned int uiFilterLength )
{
  int iSum;
  _int64 qSum;
  unsigned int uiRemaining;

  uiRemaining = uiFilterLength - uiDelayPosition;

  qSum = DotProduct( piFilterCoefficients,
                     &piFilterDelay[uiDelayPosition],
                     uiRemaining );

  qSum += DotProduct( piFilterCoefficients + uiRemaining,
                      &piFilterDelay[0],
                      uiDelayPosition );

  /********************************************************************/
  /*  Scale the Q30 number to be a Q15 number.                        */
  /********************************************************************/

  iSum = (int)( qSum >> 15 );

  return iSum;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: SampleRate6400To8000                                    */
/*  Author: Bill Hallahan                                             */
/*  Date: March 8, 1997                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*       This function converts a block of audio samples from an      */
/*  6400 Hz. sample rate to an 8000 Hz. sample rate. This is done     */
/*  using a set of polyphase filters that can interpolate up to a     */
/*  32000 Hz. rate ( 32000 is the LCM of 8000 and 6400.)              */
/*                                                                    */
/*       Only the 32000 Hz. samples that correspond to an 8000 Hz.    */
/*  sample rate are calculated. The input 6400 Hz. rate corresponds   */
/*  to every 5th (32000/6400) sample at the 32000 Hz. rate. The       */
/*  output 8000 Hz. rate corresponds to every 4th (32000/8000)        */
/*  sample at the 32000 Hz. rate. Since the LCM of 4 and 5 is 20,     */
/*  then the pattern of sample insertion and polyphase filter         */
/*  selection will repeat every 20 output samples.                    */
/*                                                                    */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    pwInputBuffer       A pointer to an input buffer of samples     */
/*                        that are sampled at an 6400 Hz. rate. The   */
/*                        samples are in Q15 format and must be       */
/*                        in the range of ( 1 - 2^-15) to -1.         */
/*                                                                    */
/*    pwOutputBuffer      A buffer that returns the output data       */
/*                        which is the input buffer data resampled    */
/*                        at 8000 Hz.                                 */
/*                                                                    */
/*                        The output bufer length MUST be large       */
/*                        enough to accept all of the output data.    */
/*                        The minimum length of the output buffer     */
/*                        is 5/4 times the number of samples in the   */
/*                        input buffer. ( 8000/6400 = 5/4 )           */
/*                                                                    */
/*    uiInputLength       The number of samples in the input buffer.  */
/*                                                                    */
/*                                                                    */
/*                       THE FOLLOWING INPUT VARIABLES ARE USED       */
/*                       TO MAINTAIN STATE INFORMATION BETWEEN        */
/*                       CALLS TO THIS ROUTINE.                       */
/*                                                                    */
/*                                                                    */
/*    piFilterDelay       A pointer to a delay line that is used      */
/*                        for FIR filtering. This  must be the        */
/*                        length of the polyphase filter's impulse    */
/*                        response. For this routine this is 56.      */
/*                        This buffer should be initialized to zero   */
/*                        once at system initialization.              */
/*                                                                    */
/*    puiDelayPosition    A pointer to an index into the filter       */
/*                        delay line. This index value should be      */
/*                        initialized to zero at system startup       */
/*                                                                    */
/*    piInputSampleTime   A pointer to the input sample time.         */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to track the input        */
/*                        stream time relative to the output stream   */
/*                        time. This time difference is used to       */
/*                        determine whether a new input sample        */
/*                        should be put into the filter delay line.   */
/*                        This should be initialized to zero once     */
/*                        at system initialization.                   */
/*                                                                    */
/*    piOutputSampleTime  A pointer to the output sample time.        */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to determine if a new     */
/*                        polyphase filter should be applied to the   */
/*                        input sample stream. This is also used to   */
/*                        select the particular polyphase filter      */
/*                        that is applied.                            */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*    This function returns an unsigned integer that is the number    */
/*    of samples in the output buffer. If the number of input samples */
/*    is exactly a multiple of RU_INPUT_SAMPLE_STEP ( 4 ) then this      */
/*    routine will always return the same value. This value will      */
/*    then be 5/4 times the number of input samples.                  */
/*                                                                    */
/*    When this function returns the output buffer contains an array  */
/*    of integers at the new sample rate.                             */
/*                                                                    */
/*                                                                    */
/*  Filter Information:                                               */
/*                                                                    */
/*    The 6400 Hz. -> 32000 Hz. interpolation filter design           */
/*    is shown here.                                                  */
/*                                                                    */
/*             H(  1) = -0.38306729E-03 = H(280)                      */
/*             H(  2) =  0.49756566E-03 = H(279)                      */
/*             H(  3) =  0.13501500E-02 = H(278)                      */
/*             H(  4) =  0.27531907E-02 = H(277)                      */
/*             H(  5) =  0.46118572E-02 = H(276)                      */
/*             H(  6) =  0.67112772E-02 = H(275)                      */
/*             H(  7) =  0.87157665E-02 = H(274)                      */
/*             H(  8) =  0.10221261E-01 = H(273)                      */
/*             H(  9) =  0.10843582E-01 = H(272)                      */
/*             H( 10) =  0.10320566E-01 = H(271)                      */
/*             H( 11) =  0.85992115E-02 = H(270)                      */
/*             H( 12) =  0.58815549E-02 = H(269)                      */
/*             H( 13) =  0.26067111E-02 = H(268)                      */
/*             H( 14) = -0.63367974E-03 = H(267)                      */
/*             H( 15) = -0.32284572E-02 = H(266)                      */
/*             H( 16) = -0.46942858E-02 = H(265)                      */
/*             H( 17) = -0.48050000E-02 = H(264)                      */
/*             H( 18) = -0.36581988E-02 = H(263)                      */
/*             H( 19) = -0.16504158E-02 = H(262)                      */
/*             H( 20) =  0.61691226E-03 = H(261)                      */
/*             H( 21) =  0.25050722E-02 = H(260)                      */
/*             H( 22) =  0.35073524E-02 = H(259)                      */
/*             H( 23) =  0.33904186E-02 = H(258)                      */
/*             H( 24) =  0.22536262E-02 = H(257)                      */
/*             H( 25) =  0.49328664E-03 = H(256)                      */
/*             H( 26) = -0.13216439E-02 = H(255)                      */
/*             H( 27) = -0.26241955E-02 = H(254)                      */
/*             H( 28) = -0.30239364E-02 = H(253)                      */
/*             H( 29) = -0.24250194E-02 = H(252)                      */
/*             H( 30) = -0.10513559E-02 = H(251)                      */
/*             H( 31) =  0.62918884E-03 = H(250)                      */
/*             H( 32) =  0.20572424E-02 = H(249)                      */
/*             H( 33) =  0.27652446E-02 = H(248)                      */
/*             H( 34) =  0.25287948E-02 = H(247)                      */
/*             H( 35) =  0.14388775E-02 = H(246)                      */
/*             H( 36) = -0.12839703E-03 = H(245)                      */
/*             H( 37) = -0.16392219E-02 = H(244)                      */
/*             H( 38) = -0.25793985E-02 = H(243)                      */
/*             H( 39) = -0.26292247E-02 = H(242)                      */
/*             H( 40) = -0.17717101E-02 = H(241)                      */
/*             H( 41) = -0.30041003E-03 = H(240)                      */
/*             H( 42) =  0.12788962E-02 = H(239)                      */
/*             H( 43) =  0.24192522E-02 = H(238)                      */
/*             H( 44) =  0.27206307E-02 = H(237)                      */
/*             H( 45) =  0.20694542E-02 = H(236)                      */
/*             H( 46) =  0.68163598E-03 = H(235)                      */
/*             H( 47) = -0.96732663E-03 = H(234)                      */
/*             H( 48) = -0.23031780E-02 = H(233)                      */
/*             H( 49) = -0.28516089E-02 = H(232)                      */
/*             H( 50) = -0.24051941E-02 = H(231)                      */
/*             H( 51) = -0.11016324E-02 = H(230)                      */
/*             H( 52) =  0.61728584E-03 = H(229)                      */
/*             H( 53) =  0.21542138E-02 = H(228)                      */
/*             H( 54) =  0.29617085E-02 = H(227)                      */
/*             H( 55) =  0.27367356E-02 = H(226)                      */
/*             H( 56) =  0.15328785E-02 = H(225)                      */
/*             H( 57) = -0.24891639E-03 = H(224)                      */
/*             H( 58) = -0.19927153E-02 = H(223)                      */
/*             H( 59) = -0.30787138E-02 = H(222)                      */
/*             H( 60) = -0.31024679E-02 = H(221)                      */
/*             H( 61) = -0.20239211E-02 = H(220)                      */
/*             H( 62) = -0.19259547E-03 = H(219)                      */
/*             H( 63) =  0.17642577E-02 = H(218)                      */
/*             H( 64) =  0.31550473E-02 = H(217)                      */
/*             H( 65) =  0.34669666E-02 = H(216)                      */
/*             H( 66) =  0.25533440E-02 = H(215)                      */
/*             H( 67) =  0.69819519E-03 = H(214)                      */
/*             H( 68) = -0.14703817E-02 = H(213)                      */
/*             H( 69) = -0.31912178E-02 = H(212)                      */
/*             H( 70) = -0.38355463E-02 = H(211)                      */
/*             H( 71) = -0.31353715E-02 = H(210)                      */
/*             H( 72) = -0.12912996E-02 = H(209)                      */
/*             H( 73) =  0.10815051E-02 = H(208)                      */
/*             H( 74) =  0.31569856E-02 = H(207)                      */
/*             H( 75) =  0.41838423E-02 = H(206)                      */
/*             H( 76) =  0.37558281E-02 = H(205)                      */
/*             H( 77) =  0.19692746E-02 = H(204)                      */
/*             H( 78) = -0.59148070E-03 = H(203)                      */
/*             H( 79) = -0.30430311E-02 = H(202)                      */
/*             H( 80) = -0.45054569E-02 = H(201)                      */
/*             H( 81) = -0.44158362E-02 = H(200)                      */
/*             H( 82) = -0.27416693E-02 = H(199)                      */
/*             H( 83) = -0.14716905E-04 = H(198)                      */
/*             H( 84) =  0.28351138E-02 = H(197)                      */
/*             H( 85) =  0.47940183E-02 = H(196)                      */
/*             H( 86) =  0.51221889E-02 = H(195)                      */
/*             H( 87) =  0.36296796E-02 = H(194)                      */
/*             H( 88) =  0.76842826E-03 = H(193)                      */
/*             H( 89) = -0.24999138E-02 = H(192)                      */
/*             H( 90) = -0.50239447E-02 = H(191)                      */
/*             H( 91) = -0.58644302E-02 = H(190)                      */
/*             H( 92) = -0.46395971E-02 = H(189)                      */
/*             H( 93) = -0.16878319E-02 = H(188)                      */
/*             H( 94) =  0.20179905E-02 = H(187)                      */
/*             H( 95) =  0.51868116E-02 = H(186)                      */
/*             H( 96) =  0.66543561E-02 = H(185)                      */
/*             H( 97) =  0.58053876E-02 = H(184)                      */
/*             H( 98) =  0.28218545E-02 = H(183)                      */
/*             H( 99) = -0.13399328E-02 = H(182)                      */
/*             H(100) = -0.52496092E-02 = H(181)                      */
/*             H(101) = -0.74876603E-02 = H(180)                      */
/*             H(102) = -0.71534920E-02 = H(179)                      */
/*             H(103) = -0.42167297E-02 = H(178)                      */
/*             H(104) =  0.42133522E-03 = H(177)                      */
/*             H(105) =  0.51945718E-02 = H(176)                      */
/*             H(106) =  0.83916243E-02 = H(175)                      */
/*             H(107) =  0.87586977E-02 = H(174)                      */
/*             H(108) =  0.59769331E-02 = H(173)                      */
/*             H(109) =  0.83726482E-03 = H(172)                      */
/*             H(110) = -0.49680225E-02 = H(171)                      */
/*             H(111) = -0.93886480E-02 = H(170)                      */
/*             H(112) = -0.10723907E-01 = H(169)                      */
/*             H(113) = -0.82560331E-02 = H(168)                      */
/*             H(114) = -0.25802210E-02 = H(167)                      */
/*             H(115) =  0.45066439E-02 = H(166)                      */
/*             H(116) =  0.10552152E-01 = H(165)                      */
/*             H(117) =  0.13269756E-01 = H(164)                      */
/*             H(118) =  0.11369097E-01 = H(163)                      */
/*             H(119) =  0.51042791E-02 = H(162)                      */
/*             H(120) = -0.36742561E-02 = H(161)                      */
/*             H(121) = -0.12025163E-01 = H(160)                      */
/*             H(122) = -0.16852396E-01 = H(159)                      */
/*             H(123) = -0.15987474E-01 = H(158)                      */
/*             H(124) = -0.90587810E-02 = H(157)                      */
/*             H(125) =  0.21703094E-02 = H(156)                      */
/*             H(126) =  0.14162681E-01 = H(155)                      */
/*             H(127) =  0.22618638E-01 = H(154)                      */
/*             H(128) =  0.23867993E-01 = H(153)                      */
/*             H(129) =  0.16226372E-01 = H(152)                      */
/*             H(130) =  0.87251863E-03 = H(151)                      */
/*             H(131) = -0.18082183E-01 = H(150)                      */
/*             H(132) = -0.34435309E-01 = H(149)                      */
/*             H(133) = -0.41475002E-01 = H(148)                      */
/*             H(134) = -0.33891901E-01 = H(147)                      */
/*             H(135) = -0.94815092E-02 = H(146)                      */
/*             H(136) =  0.29874707E-01 = H(145)                      */
/*             H(137) =  0.78281499E-01 = H(144)                      */
/*             H(138) =  0.12699878E+00 = H(143)                      */
/*             H(139) =  0.16643921E+00 = H(142)                      */
/*             H(140) =  0.18848117E+00 = H(141)                      */
/*                                                                    */
/*                        BAND  1       BAND  2                       */
/*  LOWER BAND EDGE     0.0000000     0.1000000                       */
/*  UPPER BAND EDGE     0.0937500     0.5000000                       */
/*  DESIRED VALUE       1.0000000     0.0000000                       */
/*  WEIGHTING           0.0080000     1.0000000                       */
/*  DEVIATION           0.1223457     0.0009788                       */
/*  DEVIATION IN DB     1.0025328   -60.1864281                       */
/*                                                                    */
/*  EXTREMAL FREQUENCIES--MAXIMA OF THE ERROR CURVE                   */
/*     0.0000000   0.0037946   0.0075893   0.0113839   0.0149554      */
/*     0.0187500   0.0225446   0.0263393   0.0301339   0.0339286      */
/*     0.0377232   0.0415179   0.0450894   0.0488840   0.0526787      */
/*     0.0566966   0.0604912   0.0642859   0.0680805   0.0718751      */
/*     0.0758929   0.0796875   0.0837053   0.0877231   0.0915177      */
/*     0.0937500   0.1000000   0.1006696   0.1024553   0.1049107      */
/*     0.1075892   0.1107142   0.1138391   0.1169641   0.1203123      */
/*     0.1236605   0.1270087   0.1305802   0.1339285   0.1372768      */
/*     0.1408483   0.1444198   0.1477681   0.1513396   0.1549111      */
/*     0.1584826   0.1618309   0.1654024   0.1689740   0.1725455      */
/*     0.1761170   0.1796885   0.1832600   0.1868315   0.1901798      */
/*     0.1937513   0.1973228   0.2008943   0.2044658   0.2080373      */
/*     0.2116089   0.2151804   0.2187519   0.2223234   0.2258949      */
/*     0.2294664   0.2330379   0.2366094   0.2401809   0.2437524      */
/*     0.2473240   0.2508955   0.2544670   0.2580385   0.2616100      */
/*     0.2651815   0.2687530   0.2723245   0.2761193   0.2796908      */
/*     0.2832623   0.2868338   0.2904053   0.2939768   0.2975483      */
/*     0.3011198   0.3046913   0.3082629   0.3118344   0.3154059      */
/*     0.3189774   0.3225489   0.3261204   0.3296919   0.3332634      */
/*     0.3368349   0.3404064   0.3439780   0.3475495   0.3511210      */
/*     0.3549157   0.3584872   0.3620587   0.3656302   0.3692017      */
/*     0.3727733   0.3763448   0.3799163   0.3834878   0.3870593      */
/*     0.3906308   0.3942023   0.3977738   0.4013453   0.4049169      */
/*     0.4084884   0.4120599   0.4158546   0.4194261   0.4229976      */
/*     0.4265691   0.4301406   0.4337122   0.4372837   0.4408552      */
/*     0.4444267   0.4479982   0.4515697   0.4551412   0.4587127      */
/*     0.4622842   0.4658557   0.4694273   0.4732220   0.4767935      */
/*     0.4803650   0.4839365   0.4875080   0.4910795   0.4946510      */
/*     0.4982226                                                      */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Symbol Definitions.                                               */
/**********************************************************************/

#define  RU_INPUT_SAMPLE_STEP        5
#define  RU_OUTPUT_SAMPLE_STEP       4
#define  RU_STEP_PRODUCT             ( RU_INPUT_SAMPLE_STEP * RU_OUTPUT_SAMPLE_STEP )
#define  RU_POLYPHASE_FILTER_LENGTH  56

/**********************************************************************/
/*  Start of SampleRate6400To8000 routine                             */
/**********************************************************************/

unsigned int SampleRate6400To8000( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputSampleTime,
                                   int * piOutputSampleTime )
{
  static int iPolyphaseFilter_0[56] =
  {
    755,
    1690,
    -528,
    101,
    80,
    -172,
    235,
    -290,
    339,
    -394,
    448,
    -508,
    568,
    -628,
    685,
    -738,
    785,
    -823,
    849,
    -860,
    851,
    -813,
    738,
    -601,
    355,
    142,
    -1553,
    30880,
    4894,
    -2962,
    2320,
    -1970,
    1728,
    -1538,
    1374,
    -1226,
    1090,
    -960,
    839,
    -723,
    615,
    -513,
    418,
    -331,
    251,
    -180,
    111,
    -49,
    -21,
    103,
    -216,
    410,
    -769,
    1408,
    1099,
    -62
  };

  static int iPolyphaseFilter_1[56] =
  {
    451,
    1776,
    -103,
    -270,
    369,
    -397,
    414,
    -430,
    445,
    -467,
    485,
    -504,
    516,
    -522,
    517,
    -498,
    464,
    -409,
    330,
    -219,
    69,
    137,
    -422,
    836,
    -1484,
    2658,
    -5552,
    27269,
    12825,
    -5641,
    3705,
    -2761,
    2174,
    -1757,
    1435,
    -1172,
    951,
    -760,
    594,
    -449,
    322,
    -211,
    114,
    -31,
    -40,
    101,
    -158,
    209,
    -268,
    337,
    -429,
    574,
    -787,
    963,
    1427,
    81
  };

  static int iPolyphaseFilter_2[56] =
  {
    221,
    1674,
    427,
    -599,
    555,
    -495,
    453,
    -422,
    396,
    -377,
    352,
    -326,
    289,
    -240,
    177,
    -96,
    -2,
    125,
    -276,
    462,
    -690,
    979,
    -1352,
    1862,
    -2619,
    3910,
    -6795,
    20807,
    20807,
    -6795,
    3910,
    -2619,
    1862,
    -1352,
    979,
    -690,
    462,
    -276,
    125,
    -2,
    -96,
    177,
    -240,
    289,
    -326,
    352,
    -377,
    396,
    -422,
    453,
    -495,
    555,
    -599,
    427,
    1674,
    221
  };

  static int iPolyphaseFilter_3[56] =
  {
    81,
    1427,
    963,
    -787,
    574,
    -429,
    337,
    -268,
    209,
    -158,
    101,
    -40,
    -31,
    114,
    -211,
    322,
    -449,
    594,
    -760,
    951,
    -1172,
    1435,
    -1757,
    2174,
    -2761,
    3705,
    -5641,
    12825,
    27269,
    -5552,
    2658,
    -1484,
    836,
    -422,
    137,
    69,
    -219,
    330,
    -409,
    464,
    -498,
    517,
    -522,
    516,
    -504,
    485,
    -467,
    445,
    -430,
    414,
    -397,
    369,
    -270,
    -103,
    1776,
    451
  };

  static int iPolyphaseFilter_4[56] =
  {
    -62,
    1099,
    1408,
    -769,
    410,
    -216,
    103,
    -21,
    -49,
    111,
    -180,
    251,
    -331,
    418,
    -513,
    615,
    -723,
    839,
    -960,
    1090,
    -1226,
    1374,
    -1538,
    1728,
    -1970,
    2320,
    -2962,
    4894,
    30880,
    -1553,
    142,
    355,
    -601,
    738,
    -813,
    851,
    -860,
    849,
    -823,
    785,
    -738,
    685,
    -628,
    568,
    -508,
    448,
    -394,
    339,
    -290,
    235,
    -172,
    80,
    101,
    -528,
    1690,
    755
  };

  static int * ppiPolyphaseFilter[5] =
  {
    &iPolyphaseFilter_0[0],
    &iPolyphaseFilter_1[0],
    &iPolyphaseFilter_2[0],
    &iPolyphaseFilter_3[0],
    &iPolyphaseFilter_4[0]
  };

  register int * piFilterCoefficients;
  register int iFilterIndex;
  register unsigned int uiDelayPosition;
  register int iInputSampleTime;
  register int iOutputSampleTime;
  register unsigned int uiInputIndex = 0;
  register unsigned int uiOutputIndex = 0;

  /********************************************************************/
  /*  Get the input filter state parameters.                          */
  /********************************************************************/

  uiDelayPosition = *puiDelayPosition;
  iInputSampleTime = *piInputSampleTime;
  iOutputSampleTime = *piOutputSampleTime;

  /********************************************************************/
  /*  Loop and process all of the input samples.                      */
  /********************************************************************/

  while ( uiInputIndex < uiInputBufferLength )
  {
    /******************************************************************/
    /*  Put input samples in interpolator delay buffer until we       */
    /*  catch up to the next output sample time index.                */
    /******************************************************************/

    while (( iInputSampleTime <= iOutputSampleTime )
      && ( uiInputIndex < uiInputBufferLength ))
    {
      /****************************************************************/
      /*  Put a new imput sample in the polyphase filter delay line.  */
      /****************************************************************/

      piFilterDelay[uiDelayPosition++] = (int)pwInputBuffer[uiInputIndex++];

      if ( uiDelayPosition >= RU_POLYPHASE_FILTER_LENGTH )
      {
        uiDelayPosition = 0;
      }

      /****************************************************************/
      /*  Increment the input sample time index.                      */
      /****************************************************************/

      iInputSampleTime += RU_INPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Calculate output samples using the interpolator until we      */
    /*  reach the next input sample time.                             */
    /******************************************************************/

    while ( iOutputSampleTime < iInputSampleTime )
    {
      /****************************************************************/
      /*  Calculate the polyphase filter index that corresponds to    */
      /*  the next output sample.                                     */
      /****************************************************************/

      iFilterIndex = iOutputSampleTime;

      while ( iFilterIndex >= RU_INPUT_SAMPLE_STEP )
      {
        iFilterIndex = iFilterIndex - RU_INPUT_SAMPLE_STEP;
      }

      /****************************************************************/
      /*  Get the polyphase filter coefficients.                      */
      /****************************************************************/

      piFilterCoefficients = ppiPolyphaseFilter[iFilterIndex];

      /****************************************************************/
      /*  Apply the polyphase filter.                                 */
      /****************************************************************/

      pwOutputBuffer[uiOutputIndex++] =
        (short)FirFilter( piFilterCoefficients,
                          piFilterDelay,
                          uiDelayPosition,
                          RU_POLYPHASE_FILTER_LENGTH );

      /****************************************************************/
      /*  Increment the output sample time index.                     */
      /****************************************************************/

      iOutputSampleTime += RU_OUTPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Wrap the input and output times indices so they don't         */
    /*  overflow and go back to process more of the input block.      */
    /******************************************************************/

    if ( iInputSampleTime >= RU_STEP_PRODUCT )
    {
      iInputSampleTime -= RU_STEP_PRODUCT;
      iOutputSampleTime -= RU_STEP_PRODUCT;
    }
  }

  /********************************************************************/
  /*  Save the input filter state parameters.                         */
  /********************************************************************/

  *puiDelayPosition = uiDelayPosition;
  *piInputSampleTime = iInputSampleTime;
  *piOutputSampleTime = iOutputSampleTime;

  /********************************************************************/
  /*  Return the number of samples in the output buffer.              */
  /********************************************************************/

  return uiOutputIndex;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: SampleRate8000To6400                                    */
/*  Author: Bill Hallahan                                             */
/*  Date: March 8, 1997                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*       This function converts a block of audio samples from an      */
/*  8000 Hz. sample rate to a 6400 Hz. sample rate. This is done      */
/*  using a set of polyphase filters that can interpolate up to a     */
/*  32000 Hz. rate ( 32000 is the LCM of 8000 and 6400.)              */
/*                                                                    */
/*       Only the 32000 Hz. samples that correspond to a 6400 Hz.     */
/*  sample rate are calculated. The input 8000 Hz. rate corresponds   */
/*  to every 4th (32000/8000) sample at the 32000 Hz. rate. The       */
/*  output 6400 Hz. rate corresponds to every 5th (32000/6400)        */
/*  sample at the 32000 Hz. rate. Since the LCM of 4 and 5 is 20,     */
/*  then the pattern of sample insertion and polyphase filter         */
/*  selection will repeat every 20 output samples.                    */
/*                                                                    */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    pwInputBuffer       A pointer to an input buffer of samples     */
/*                        that are sampled at an 8000 Hz. rate. The   */
/*                        samples are in Q15 format and must be       */
/*                        in the range of ( 1 - 2^-15) to -1.         */
/*                                                                    */
/*    pwOutputBuffer      A buffer that returns the output data       */
/*                        which is the input buffer data resampled    */
/*                        at 6400 Hz. Since this is a lower sample    */
/*                        rate than the input rate the data is also   */
/*                        low pass filtered during the conversion     */
/*                        process. The low pass filter cutoff         */
/*                        frequency is at 3000 Hz. All alias          */
/*                        products are down at least 60 dB. past      */
/*                        3100 Hz.                                    */
/*                                                                    */
/*                        The output bufer length MUST be large       */
/*                        enough to accept all of the output data.    */
/*                        The minimum length of the output buffer     */
/*                        is 4/5 times the number of samples in the   */
/*                        input buffer. ( 6400/8000 = 4/5 )           */
/*                                                                    */
/*    uiInputLength       The number of samples in the input buffer.  */
/*                                                                    */
/*                                                                    */
/*                       THE FOLLOWING INPUT VARIABLES ARE USED       */
/*                       TO MAINTAIN STATE INFORMATION BETWEEN        */
/*                       CALLS TO THIS ROUTINE.                       */
/*                                                                    */
/*                                                                    */
/*    piFilterDelay       A pointer to a delay line that is used      */
/*                        for FIR filtering. This  must be the        */
/*                        length of the polyphase filter's impulse    */
/*                        response. For this routine this is 23.      */
/*                        This buffer should be initialized to zero   */
/*                        once at system initialization.              */
/*                                                                    */
/*    puiDelayPosition    A pointer to an index into the filter       */
/*                        delay line. This index value should be      */
/*                        initialized to zero at system startup       */
/*                                                                    */
/*    piInputSampleTime   A pointer to the input sample time.         */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to track the input        */
/*                        stream time relative to the output stream   */
/*                        time. This time difference is used to       */
/*                        determine whether a new input sample        */
/*                        should be put into the filter delay line.   */
/*                        This should be initialized to zero once     */
/*                        at system initialization.                   */
/*                                                                    */
/*    piOutputSampleTime  A pointer to the output sample time.        */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to determine if a new     */
/*                        polyphase filter should be applied to the   */
/*                        input sample stream. This is also used to   */
/*                        select the particular polyphase filter      */
/*                        that is applied.                            */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*    This function returns an unsigned integer that is the number    */
/*    of samples in the output buffer. If the number of input samples */
/*    is exactly a multiple of RD_INPUT_SAMPLE_STEP ( 5 ) then this      */
/*    routine will always return the same value. This value will      */
/*    then be 4/5 times the number of input samples.                  */
/*                                                                    */
/*    When this function returns the output buffer contains an array  */
/*    of integers at the new sample rate.                             */
/*                                                                    */
/*                                                                    */
/*  Filter Information:                                               */
/*                                                                    */
/*    The 8000 Hz. -> 32000 Hz. interpolation filter design           */
/*    is shown here.                                                  */
/*                                                                    */
/*               FINITE IMPULSE RESPONSE (FIR)                        */
/*             LINEAR PHASE DIGITAL FILTER DESIGN                     */
/*                 REMEZ EXCHANGE ALGORITHM                           */
/*                                                                    */
/*                      BANDPASS FILTER                               */
/*                                                                    */
/*                    FILTER LENGTH =  92                             */
/*                                                                    */
/*               ***** IMPULSE RESPONSE *****                         */
/*             H(  1) = -0.77523338E-03 = H( 92)                      */
/*             H(  2) = -0.56140189E-03 = H( 91)                      */
/*             H(  3) = -0.26485065E-03 = H( 90)                      */
/*             H(  4) =  0.48529240E-03 = H( 89)                      */
/*             H(  5) =  0.15506579E-02 = H( 88)                      */
/*             H(  6) =  0.25692214E-02 = H( 87)                      */
/*             H(  7) =  0.30662031E-02 = H( 86)                      */
/*             H(  8) =  0.26577783E-02 = H( 85)                      */
/*             H(  9) =  0.12834022E-02 = H( 84)                      */
/*             H( 10) = -0.67870057E-03 = H( 83)                      */
/*             H( 11) = -0.24781306E-02 = H( 82)                      */
/*             H( 12) = -0.32756536E-02 = H( 81)                      */
/*             H( 13) = -0.25334368E-02 = H( 80)                      */
/*             H( 14) = -0.34487492E-03 = H( 79)                      */
/*             H( 15) =  0.24779409E-02 = H( 78)                      */
/*             H( 16) =  0.46604010E-02 = H( 77)                      */
/*             H( 17) =  0.50008399E-02 = H( 76)                      */
/*             H( 18) =  0.29790259E-02 = H( 75)                      */
/*             H( 19) = -0.85979374E-03 = H( 74)                      */
/*             H( 20) = -0.49750470E-02 = H( 73)                      */
/*             H( 21) = -0.74064843E-02 = H( 72)                      */
/*             H( 22) = -0.66624931E-02 = H( 71)                      */
/*             H( 23) = -0.25365327E-02 = H( 70)                      */
/*             H( 24) =  0.35602755E-02 = H( 69)                      */
/*             H( 25) =  0.90023531E-02 = H( 68)                      */
/*             H( 26) =  0.11015911E-01 = H( 67)                      */
/*             H( 27) =  0.80042975E-02 = H( 66)                      */
/*             H( 28) =  0.53222617E-03 = H( 65)                      */
/*             H( 29) = -0.85644918E-02 = H( 64)                      */
/*             H( 30) = -0.15142974E-01 = H( 63)                      */
/*             H( 31) = -0.15514131E-01 = H( 62)                      */
/*             H( 32) = -0.82975281E-02 = H( 61)                      */
/*             H( 33) =  0.44855666E-02 = H( 60)                      */
/*             H( 34) =  0.17722420E-01 = H( 59)                      */
/*             H( 35) =  0.25017589E-01 = H( 58)                      */
/*             H( 36) =  0.21431517E-01 = H( 57)                      */
/*             H( 37) =  0.60814521E-02 = H( 56)                      */
/*             H( 38) = -0.16557660E-01 = H( 55)                      */
/*             H( 39) = -0.37409518E-01 = H( 54)                      */
/*             H( 40) = -0.45595154E-01 = H( 53)                      */
/*             H( 41) = -0.32403238E-01 = H( 52)                      */
/*             H( 42) =  0.50128344E-02 = H( 51)                      */
/*             H( 43) =  0.61689958E-01 = H( 50)                      */
/*             H( 44) =  0.12557802E+00 = H( 49)                      */
/*             H( 45) =  0.18087465E+00 = H( 48)                      */
/*             H( 46) =  0.21291447E+00 = H( 47)                      */
/*                                                                    */
/*                        BAND  1       BAND  2                       */
/*  LOWER BAND EDGE     0.0000000     0.1250000                       */
/*  UPPER BAND EDGE     0.0968750     0.5000000                       */
/*  DESIRED VALUE       1.0000000     0.0000000                       */
/*  WEIGHTING           0.0700000     1.0000000                       */
/*  DEVIATION           0.0136339     0.0009544                       */
/*  DEVIATION IN DB     0.1176231   -60.4056206                       */
/*                                                                    */
/*  EXTREMAL FREQUENCIES--MAXIMA OF THE ERROR CURVE                   */
/*     0.0000000   0.0129076   0.0251359   0.0380435   0.0495924      */
/*     0.0618206   0.0733696   0.0842392   0.0930708   0.0968750      */
/*     0.1250000   0.1270380   0.1331521   0.1413043   0.1501357      */
/*     0.1596465   0.1698367   0.1800269   0.1908964   0.2010865      */
/*     0.2119560   0.2228255   0.2330157   0.2438852   0.2547547      */
/*     0.2656242   0.2764937   0.2873632   0.2982327   0.3091022      */
/*     0.3199717   0.3308412   0.3417107   0.3525802   0.3634497      */
/*     0.3743192   0.3851887   0.3960582   0.4069277   0.4177972      */
/*     0.4293461   0.4402156   0.4510851   0.4619546   0.4728241      */
/*     0.4836936   0.4945631                                          */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Symbol Definitions.                                               */
/**********************************************************************/

#define  RD_INPUT_SAMPLE_STEP        4
#define  RD_OUTPUT_SAMPLE_STEP       5
#define  RD_STEP_PRODUCT             ( RD_INPUT_SAMPLE_STEP * RD_OUTPUT_SAMPLE_STEP )
#define  RD_POLYPHASE_FILTER_LENGTH  23

/**********************************************************************/
/*  Start of SampleRate8000To6400 routine                             */
/**********************************************************************/

unsigned int SampleRate8000To6400( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputSampleTime,
                                   int * piOutputSampleTime )
{
  static int iPolyphaseFilter_0[23] =
  {
    62,
    344,
    -424,
    604,
    -644,
    461,
    68,
    -1075,
    2778,
    -5910,
    16277,
    23445,
    -4200,
    788,
    581,
    -1110,
    1166,
    -960,
    648,
    -328,
    166,
    201,
    -100
  };

  static int iPolyphaseFilter_1[23] =
  {
    -34,
    397,
    -321,
    321,
    -111,
    -328,
    1037,
    -2011,
    3242,
    -4849,
    7996,
    27598,
    649,
    -2146,
    2297,
    -1962,
    1427,
    -863,
    386,
    -44,
    -87,
    333,
    -72
  };

  static int iPolyphaseFilter_2[23] =
  {
    -72,
    333,
    -87,
    -44,
    386,
    -863,
    1427,
    -1962,
    2297,
    -2146,
    649,
    27598,
    7996,
    -4849,
    3242,
    -2011,
    1037,
    -328,
    -111,
    321,
    -321,
    397,
    -34
  };

  static int iPolyphaseFilter_3[23] =
  {
    -100,
    201,
    166,
    -328,
    648,
    -960,
    1166,
    -1110,
    581,
    788,
    -4200,
    23445,
    16277,
    -5910,
    2778,
    -1075,
    68,
    461,
    -644,
    604,
    -424,
    344,
    62
  };

  static int * ppiPolyphaseFilter[4] =
  {
    &iPolyphaseFilter_0[0],
    &iPolyphaseFilter_1[0],
    &iPolyphaseFilter_2[0],
    &iPolyphaseFilter_3[0]
  };

  register int * piFilterCoefficients;
  register int iFilterIndex;
  register unsigned int uiDelayPosition;
  register int iInputSampleTime;
  register int iOutputSampleTime;
  register unsigned int uiInputIndex = 0;
  register unsigned int uiOutputIndex = 0;

  /********************************************************************/
  /*  Get the input filter state parameters.                          */
  /********************************************************************/

  uiDelayPosition = *puiDelayPosition;
  iInputSampleTime = *piInputSampleTime;
  iOutputSampleTime = *piOutputSampleTime;

  /********************************************************************/
  /*  Loop and process all of the input samples.                      */
  /********************************************************************/

  while ( uiInputIndex < uiInputBufferLength )
  {
    /******************************************************************/
    /*  Put input samples in interpolator delay buffer until we       */
    /*  catch up to the next output sample time index.                */
    /******************************************************************/

    while (( iInputSampleTime <= iOutputSampleTime )
      && ( uiInputIndex < uiInputBufferLength ))
    {
      /****************************************************************/
      /*  Put a new imput sample in the polyphase filter delay line.  */
      /****************************************************************/

      piFilterDelay[uiDelayPosition++] = (int)pwInputBuffer[uiInputIndex++];

      if ( uiDelayPosition >= RD_POLYPHASE_FILTER_LENGTH )
      {
        uiDelayPosition = 0;
      }

      /****************************************************************/
      /*  Increment the input sample time index.                      */
      /****************************************************************/

      iInputSampleTime += RD_INPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Calculate output samples using the interpolator until we      */
    /*  reach the next input sample time.                             */
    /******************************************************************/

    while ( iOutputSampleTime < iInputSampleTime )
    {
      /****************************************************************/
      /*  Calculate the polyphase filter index that corresponds to    */
      /*  the next output sample.                                     */
      /****************************************************************/

      iFilterIndex = iOutputSampleTime;

      while ( iFilterIndex >= RD_INPUT_SAMPLE_STEP )
      {
        iFilterIndex = iFilterIndex - RD_INPUT_SAMPLE_STEP;
      }

      /****************************************************************/
      /*  Get the polyphase filter coefficients.                      */
      /****************************************************************/

      piFilterCoefficients = ppiPolyphaseFilter[iFilterIndex];

      /****************************************************************/
      /*  Apply the polyphase filter.                                 */
      /****************************************************************/

      pwOutputBuffer[uiOutputIndex++] =
        (short)FirFilter( piFilterCoefficients,
                          piFilterDelay,
                          uiDelayPosition,
                          RD_POLYPHASE_FILTER_LENGTH );

      /****************************************************************/
      /*  Increment the output sample time index.                     */
      /****************************************************************/

      iOutputSampleTime += RD_OUTPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Wrap the input and output times indices so they don't         */
    /*  overflow and go back to process more of the input block.      */
    /******************************************************************/

    if ( iInputSampleTime >= RD_STEP_PRODUCT )
    {
      iInputSampleTime -= RD_STEP_PRODUCT;
      iOutputSampleTime -= RD_STEP_PRODUCT;
    }
  }

  /********************************************************************/
  /*  Save the input filter state parameters.                         */
  /********************************************************************/

  *puiDelayPosition = uiDelayPosition;
  *piInputSampleTime = iInputSampleTime;
  *piOutputSampleTime = iOutputSampleTime;

  /********************************************************************/
  /*  Return the number of samples in the output buffer.              */
  /********************************************************************/

  return uiOutputIndex;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\yuv12enc.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;//
;////////////////////////////////////////////////////////////////////////////
; yuv12enc -- This function performs "color conversion" in the H26X decoder for
;             consumption by the H26X encoder.  This entails reformatting the decoder's
;             YVU data into the shape required by the encoder - including YUV order.  It
;			  Also includes 7-bit pels.
; $Header:   S:\h26x\src\dec\yuv12enc.asv   1.5   30 Oct 1996 14:31:00   mbodart  $
; $Log:   S:\h26x\src\dec\yuv12enc.asv  $
;// 
;//    Rev 1.5   30 Oct 1996 14:31:00   mbodart
;// Re-checking in changes originally made by Atul, but lost when the server
;// ran out of disk space during a PVCS operation.  Atul's original log msg:
;// 
;// Removed AGI in IA code.  Added MMX code but it is not ready for prime-time.
;// 
;//    Rev 1.4   08 Mar 1996 15:11:10   AGUPTA2
;// Removed segment register override when compiling for WIN32.
;// Should speed-up this routine substantially.
;// 
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include decconst.inc
include iammx.inc
IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataH26x_YUV12ForEnc>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE H26x_YUV12ForEnc (
;							U8 FAR * InstanceBase,
;                           X32 YPlane,
;                           X32 VPlane,
;                           X32 UPlane,
;                           UN  FrameWidth,
;                           UN  FrameHeight,
;                           UN  Pitch,
;                           U8 FAR * ColorConvertedFrame, // encoder's buffers.
;                           X32 YOutputPlane,
;                           X32 VOutputPlane,
;                           X32 UOutputPlane)
;
;  YPlane, VPlane, YOutputPlane, and VOutputPlane are offsets. In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;

PUBLIC  H26x_YUV12ForEnc

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        H26x_YUV12ForEnc proc DIST LANG PUBLIC, 
            							AInstanceBase:         DWORD,
							     		AYPlane:               DWORD,
							     		AVPlane:               DWORD,
							     		AUPlane:               DWORD,
							     		AFrameWidth:           DWORD,
										AFrameHeight:          DWORD,
										APitch:                DWORD,
										AColorConvertedFrame:  DWORD,
										AYOutputPlane:         DWORD,
										AVOutputPLane:         DWORD,
										AUOutputPLane:         DWORD


LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase            = LocalFrameSize + RegisterStorageSize +  4
YPlane                  = LocalFrameSize + RegisterStorageSize +  8
VPlane                  = LocalFrameSize + RegisterStorageSize + 12
UPlane                  = LocalFrameSize + RegisterStorageSize + 16
FrameWidth              = LocalFrameSize + RegisterStorageSize + 20
FrameHeight             = LocalFrameSize + RegisterStorageSize + 24
Pitch                   = LocalFrameSize + RegisterStorageSize + 28
ColorConvertedFrame     = LocalFrameSize + RegisterStorageSize + 32
YOutputPlane            = LocalFrameSize + RegisterStorageSize + 36
VOutputPlane            = LocalFrameSize + RegisterStorageSize + 40
UOutputPlane            = LocalFrameSize + RegisterStorageSize + 44
EndOfArgList            = LocalFrameSize + RegisterStorageSize + 48

LCL EQU <esp+>

  push  esi
  push  edi
  push  ebp
  push  ebx
  sub   esp,LocalFrameSize
  mov   eax,PD [esp+InstanceBase]
  add   PD [esp+YPlane],eax
  add   PD [esp+VPlane],eax
  add   PD [esp+UPlane],eax
  mov   eax,PD [esp+ColorConvertedFrame]
  add	PD [esp+YOutputPlane],eax
  add	PD [esp+VOutputPlane],eax
  add	PD [esp+UOutputPlane],eax

;   We copy 16 pels in one iteration of the inner loop
; Register usage:
;   edi -- Y plane output cursor
;   esi -- Y plane input cursor
;   ebp -- Count down Y plane height
;   ecx -- Count down Y plane width
;   ebx -- Y plane input pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  Lesi  YPlane
   Lebx Pitch
  Ledi  YOutputPlane

YLoopHeader:	
  mov   eax, PD [esi+ecx-8]        ; 
   mov  edx, PD [esi+ecx-4]
ALIGN 4
YLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
                                   ; NEXT 8 PELS
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8-8], eax
   mov  PD [edi+ecx-4-8], edx

  mov   eax, PD [esi+ecx-8-16]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-16]      ; for next iteration

  sub   ecx, 16
   jg   YLoop

  Lecx  FrameWidth
   add  esi, ebx
  add   edi, ebx
   dec  ebp
  jne   YLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- V plane output cursor
;   esi -- V plane input cursor
;   ebp -- Count down V plane height
;   ecx -- Count down V plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi VPlane
  sar   ebp,1
   Ledi VOutputPlane

ALIGN 4
VLoopHeader:
  mov   eax, PD [esi+ecx-8]
   mov  edx, PD [esi+ecx-4]
VLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  sub   ecx, 8
   jg   VLoop

  Lecx  FrameWidth
   add  esi,ebx
  shr   ecx,1
   add  edi,ebx
  dec   ebp
   jne  VLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- U plane output cursor
;   esi -- U plane input cursor
;   ebp -- Count down U plane height
;   ecx -- Count down U plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi UPlane
  sar   ebp,1
   Ledi UOutputPlane

ALIGN 4
ULoopHeader:
  mov   eax,PD [esi+ecx-8]
   mov  edx,PD [esi+ecx-4]
ULoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]
   mov  edx, PD [esi+ecx-4-8]
  sub   ecx, 8
   jg   ULoop

  Lecx  FrameWidth
   add  esi, ebx
  shr   ecx, 1
   add  edi, ebx
  dec   ebp
   jne  ULoopHeader

  add   esp,LocalFrameSize
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

H26x_YUV12ForEnc endp

IFDEF H263P
MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
CLEAR_LOW_BIT_MASK  LABEL DWORD
  DWORD 0FEFEFEFEH, 0FEFEFEFEH
CLEAR_HIGH_BIT_MASK LABEL DWORD
  DWORD 07F7F7F7FH, 07F7F7F7FH
MMXDATA1 ENDS

PUBLIC  MMX_H26x_YUV12ForEnc

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        MMX_H26x_YUV12ForEnc proc DIST LANG PUBLIC, 
            							AInstanceBase:         DWORD,
							     		AYPlane:               DWORD,
							     		AVPlane:               DWORD,
							     		AUPlane:               DWORD,
							     		AFrameWidth:           DWORD,
										AFrameHeight:          DWORD,
										APitch:                DWORD,
										AColorConvertedFrame:  DWORD,
										AYOutputPlane:         DWORD,
										AVOutputPLane:         DWORD,
										AUOutputPLane:         DWORD

LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase            = LocalFrameSize + RegisterStorageSize +  4
YPlane                  = LocalFrameSize + RegisterStorageSize +  8
VPlane                  = LocalFrameSize + RegisterStorageSize + 12
UPlane                  = LocalFrameSize + RegisterStorageSize + 16
FrameWidth              = LocalFrameSize + RegisterStorageSize + 20
FrameHeight             = LocalFrameSize + RegisterStorageSize + 24
Pitch                   = LocalFrameSize + RegisterStorageSize + 28
ColorConvertedFrame     = LocalFrameSize + RegisterStorageSize + 32
YOutputPlane            = LocalFrameSize + RegisterStorageSize + 36
VOutputPlane            = LocalFrameSize + RegisterStorageSize + 40
UOutputPlane            = LocalFrameSize + RegisterStorageSize + 44
EndOfArgList            = LocalFrameSize + RegisterStorageSize + 48

LCL EQU <esp+>

CLEAR_LOW_BIT  EQU mm6
CLEAR_HIGH_BIT EQU mm7

  push  esi
  push  edi
  push  ebp
  push  ebx
  sub   esp,LocalFrameSize
  mov   eax,PD [esp+InstanceBase]
  add   PD [esp+YPlane],eax
  add   PD [esp+VPlane],eax
  add   PD [esp+UPlane],eax
  mov   eax,PD [esp+ColorConvertedFrame]
  add	PD [esp+YOutputPlane],eax
  add	PD [esp+VOutputPlane],eax
  add	PD [esp+UOutputPlane],eax

;   We copy 16 pels of two lines in one iteration of the inner loop
; Register usage:
;   edi -- Y plane output cursor (line 0)
;   edx -- Y plane output cursor (line 1)
;   esi -- Y plane input cursor  (line 0)
;   eax -- Y plane input cursor  (line 1)
;   ebp -- Count down Y plane height / 2
;   ecx -- Count down Y plane width
;   ebx -- Y plane input pitch

  Lebp  FrameHeight
   Lebx Pitch
  Lesi  YPlane
   Lecx FrameWidth
  Ledi  YOutputPlane
   lea  eax, [esi + ebx]                  ; line 1 of input
  movq  mm6, CLEAR_LOW_BIT_MASK
   lea  edx, [edi + ebx]                  ; line 1 of output
  movq  mm7, CLEAR_HIGH_BIT_MASK
   shr  ebp, 1                            ; two lines in one iteration
  

YLoopHeader:	
  movq       mm0, [esi+ecx-16]            ;00
   ;
  movq       mm1, [esi+ecx-8]             ;01
   psrlq     mm0, 1                       ;00 Shift packed pel by 1 to convert to 7-bit
YLoop:
  movq       mm2, [eax+ecx-16]            ;10 
   pand      mm0, CLEAR_HIGH_BIT          ;00 and to get rid of high bit
  movq       mm3, [eax+ecx-8]             ;11
   psrlq     mm1, 1                       ;01
  movq       [edi+ecx-16], mm0            ;00
   pand      mm1, CLEAR_LOW_BIT           ;01 and to get rid of low bit
  movq       mm0, [esi+ecx-16-16]         ;   speculatively load next 8 pels
   psrlq     mm2, 1                       ;10 Shift packed pel by 1 to convert to 7-bit
  movq       [edi+ecx-8 ], mm1            ;01
   pand      mm2, CLEAR_HIGH_BIT          ;10 and to get rid of high bit
  movq       mm1, [esi+ecx-8 -16]         ;   for next iteration
   pand      mm3, CLEAR_LOW_BIT           ;11 and to get rid of low bit
  movq       [edx+ecx-16], mm2            ;10
   psrlq     mm3, 1                       ;11
  psrlq      mm0, 1                       ;00 Shift packed pel by 1 to convert to 7-bit
   ;
  movq       [edx+ecx-8 ], mm3            ;11
   sub       ecx, 16
  jg        YLoop

  Lecx  FrameWidth
   lea  esi, [esi + 2*ebx]
  lea   edi, [edi + 2*ebx]
   lea  eax, [eax + 2*ebx]            ; line 1 of input
  lea   edx, [edx + 2*ebx]            ; line 1 of output
   dec  ebp
  jne   YLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- V plane output cursor
;   esi -- V plane input cursor
;   ebp -- Count down V plane height
;   ecx -- Count down V plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi VPlane
  sar   ebp,1
   Ledi VOutputPlane

ALIGN 4
VLoopHeader:
  mov   eax, PD [esi+ecx-8]
   mov  edx, PD [esi+ecx-4]
VLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  sub   ecx, 8
   jg   VLoop

  Lecx  FrameWidth
   add  esi,ebx
  shr   ecx,1
   add  edi,ebx
  dec   ebp
   jne  VLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- U plane output cursor
;   esi -- U plane input cursor
;   ebp -- Count down U plane height
;   ecx -- Count down U plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi UPlane
  sar   ebp,1
   Ledi UOutputPlane

ALIGN 4
ULoopHeader:
  mov   eax,PD [esi+ecx-8]
   mov  edx,PD [esi+ecx-4]
ULoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]
   mov  edx, PD [esi+ecx-4-8]
  sub   ecx, 8
   jg   ULoop

  Lecx  FrameWidth
   add  esi, ebx
  shr   ecx, 1
   add  edi, ebx
  dec   ebp
   jne  ULoopHeader

  add   esp,LocalFrameSize
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

MMX_H26x_YUV12ForEnc endp
ENDIF ;H263P

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\data.c ===
/*
 *   Project:		Direct Subband about 13000 bps coder and SBCELP 4800 bps coder
 *   Workfile:		data.c
 *   Author:		Georges Zanellato, Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	26 October 1995
 *   DLL Version:	1.00
 *   Revision:          Single DLL for coder and decoder.
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */


//#include <math.h>
#include <windows.h>
#include "data.h"

// ------------------------------------------------------------------------
// ROM tables :
// ------------------------------------------------------------------------

short coef_I[Fil_Lenght] = // QMF filter coefficients
			 {    94,   -62,  -528,  3499,
			   15641, -3122,  1178,  -326 };
/****/

short B3_I[2]={-3072, 3072};
short B4_I[3]={-4233,    0, 4233};

short B5_I[4]={-4915,-1638, 1638, 4915};
short B6_I[5]={-5406,-2703,    0, 2703, 5406};

short B7_I[6]={-5802,-3481,-1160, 1160, 3481, 5802};
short B8_I[7]={-6144,-4096,-2048,    0, 2048, 4096, 6144};

short B9_I[8]={-6451,-4607,-2764, -921,  921, 2764, 4607, 6451};



short V3_I[3]={-6144,    0, 6144};                                    // 75   %
short V4_I[4]={-6349,-2116, 2116, 6349};                              // 77.5 %

short V5_I[5]={-6554,-3277,    0, 3277, 6554};                        // 80   %
short V6_I[6]={-6758,-4055,-1352, 1352, 4055, 6758};                  // 82.5 %

short V7_I[7]={-6963,-4642,-2321,    0, 2321, 4642, 6963};            // 85   %
short V8_I[8]={-7168,-5120,-3072,-1024, 1024, 3072, 5120, 7168};      // 87.5 %

short V9_I[9]={-7373,-5529,-3686,-1843,    0, 1843, 3686, 5529, 7373};// 90   %



/**** Nouvelles tables ****/

//short B9_I[8]={-6707,-4791,-2874, -958,  958, 2874, 4791, 6707};      //lineaires
//short V9_I[9]={-7666,-5749,-3833,-1916,    0, 1916, 3833, 5749, 7666};

//short B9_I[8]={-5702,-3154,-1745, -965,  965, 1745, 3154, 5702};      //log
//short V9_I[9]={-7666,-4241,-2346,-1298,    0, 1298, 2346, 4241, 7666};

/****/



/**** Quantif du maximum des ss bandes avec calcul des distances; ****/
/**** les ech. des ss bandes peuvent etre superieurs a 1          ****/
/****/
short max_level[32] = {
	 10,   30,   60,  100,  117,  138,  162,  190,
	223,  262,  308,  361,  425,  499,  586,  688,
	808,  949, 1114, 1308, 1536, 1804, 2119, 2488,
       2922, 3431, 4030, 4732, 5557, 6526, 7664, 9000
	 };

short d_max_level[32] = {		// Division des petites valeurs pour rduire le bruit
	  2,   10,   30,   60,  100,  138,  162,  190,
	223,  262,  308,  361,  425,  499,  586,  688,
	808,  949, 1114, 1308, 1536, 1804, 2119, 2488,
       2922, 3431, 4030, 4732, 5557, 6526, 7664, 9000
	 };
/****/

/**** Cette table est la meme que la precedente mais avec comparaison ****/
/**** simple (les ech des ss bandes seront alors tjs inferieurs a 1)  ****/
/****
short max_level[32] = {  // Quantified maximum sample level
		    20,   45,   80,  109,  128,  150,  176,  207,
		   243,  285,  335,  393,  462,  543,  637,  748,
		   879, 1032, 1211, 1422, 1670, 1962, 2304, 2705,
		  3177, 3731, 4381, 5145, 6042, 7095, 8332,16000
	 };
/****/

/***   New table with new structure (variable threshold)  ***
short max_level[32] = {
		   100,  125,  150,  200,  250,  285,  326,  372,
		   425,  485,  554,  633,  723,  825,  943, 1076,
		  1229, 1404, 1603, 1830, 2090, 2387, 2726, 3113,
		  3554, 4059, 4635, 5293, 6044, 6902, 7881, 9000,
		};
/****/
// Masques utiliss pour le multiplexage et dmultiplexage des trames codes
// Mask[i] donne accs aux i bits de poids faible d'un long
long Mask[9]={0,1,3,7,15,31,63,127,255};

// PhilF: Since these depend on the bit rate, moved them from global to instance data...
//short quantif[2*NBSB_SP_MAX1]={QUANT_LEVELS};
//short bits[NBSB_SP_MAX1]={CODING_BITS};
//short bytes[NBSB_SP_MAX1+1]={OUTPUT_BYTES};

/*short quantif[16]={9,9,7,7,7,6,5,5,5,5,0,0,0,0,0,0};
short bits[8]={52,46,44,38,38,0,0,0};
short bytes[9]={1,9,15,21,26,32,0,0,0};*/

// Hamming window
short hamming[220] =
{   2621,  2628,  2646,  2677,  2721,  2776,  2844,  2924,  3017,  3121,
    3237,  3366,  3506,  3658,  3821,  3996,  4182,  4379,  4587,  4806,
    5035,  5275,  5525,  5786,  6056,  6335,  6624,  6922,  7229,  7544,
    7868,  8200,  8540,  8887,  9242,  9603,  9971, 10346, 10726, 11113,
   11504, 11901, 12303, 12709, 13119, 13533, 13950, 14370, 14793, 15219,
   15646, 16076, 16506, 16938, 17370, 17802, 18235, 18667, 19098, 19528,
   19956, 20382, 20807, 21229, 21648, 22063, 22475, 22883, 23287, 23686,
   24081, 24470, 24853, 25231, 25602, 25967, 26325, 26676, 27019, 27355,
   27683, 28003, 28314, 28616, 28910, 29194, 29469, 29734, 29989, 30234,
   30469, 30693, 30907, 31109, 31301, 31481, 31650, 31808, 31954, 32088,
   32211, 32321, 32419, 32506, 32580, 32642, 32691, 32728, 32753, 32765,
   32765, 32753, 32728, 32691, 32642, 32580, 32506, 32419, 32321, 32211,
   32088, 31954, 31808, 31650, 31481, 31301, 31109, 30907, 30693, 30469,
   30234, 29989, 29734, 29469, 29194, 28910, 28616, 28314, 28003, 27683,
   27355, 27019, 26676, 26325, 25967, 25602, 25231, 24853, 24470, 24081,
   23686, 23287, 22883, 22475, 22063, 21648, 21229, 20807, 20382, 19956,
   19528, 19098, 18667, 18235, 17802, 17370, 16938, 16506, 16076, 15646,
   15219, 14793, 14370, 13950, 13533, 13119, 12709, 12303, 11901, 11504,
   11113, 10726, 10346,  9971,  9603,  9242,  8887,  8540,  8200,  7868,
    7544,  7229,  6922,  6624,  6335,  6056,  5786,  5525,  5275,  5035,
    4806,  4587,  4379,  4182,  3996,  3821,  3658,  3506,  3366,  3237,
    3121,  3017,  2924,  2844,  2776,  2721,  2677,  2646,  2628,  2621
};

short A0[11] = { 32767, 29491, 26542, 23887, 21499, 19349, 17414, 15672, 14105, 12694, 11425};

short LSP0ROM[10] = {1638,  4915,  8192, 11468, 14745, 18022, 21299, 24576, 27852, 31129};

short tabcos[292] =
{  32767, 32512, 32256, 32000, 31744, 31488, 31232, 30976, 30720, 30464,
   30208, 29952, 29696, 29440, 29184, 28928, 28672, 28416, 28160, 27904,
   27648, 27392, 27136, 26880, 26624, 26368, 26112, 25856, 25600, 25344,
   25088, 24832, 24576, 24320, 24064, 23808, 23552, 23296, 23040, 22784,
   22528, 22272, 22016, 21760, 21504, 21248, 20992, 20736, 20480, 20224,
   19968, 19712, 19456, 19200, 18944, 18688, 18432, 18176, 17920, 17664,
   17408, 17152, 16896, 16640, 16384, 16128, 15872, 15616, 15360, 15104,
   14848, 14592, 14336, 14080, 13824, 13568, 13312, 13056, 12800, 12544,
   12288, 12032, 11776, 11520, 11264, 11008, 10752, 10496, 10240,  9984,
    9728,  9472,  9216,  8960,  8704,  8448,  8192,  7936,  7680,  7424,
    7168,  6912,  6656,  6400,  6144,  5888,  5632,  5376,  5120,  4864,
    4608,  4352,  4096,  3840,  3584,  3328,  3072,  2816,  2560,  2304,
    2048,  1792,  1536,  1280,  1024,   768,   512,   256,     0,     0,
    1304,  1846,  2262,  2614,  2924,  3206,  3465,  3707,  3934,  4150,
    4355,  4552,  4741,  4923,  5100,  5271,  5437,  5598,  5755,  5909,
    6059,  6206,  6350,  6491,  6630,  6766,  6899,  7031,  7160,  7288,
    7414,  7538,  7660,  7781,  7900,  8018,  8135,  8250,  8364,  8477,
    8589,  8699,  8809,  8917,  9025,  9131,  9237,  9342,  9446,  9549,
    9651,  9753,  9854,  9954, 10053, 10152, 10251, 10348, 10445, 10542,
   10638, 10733, 10828, 10922, 11016, 11109, 11202, 11295, 11387, 11478,
   11570, 11660, 11751, 11841, 11931, 12020, 12109, 12198, 12286, 12374,
   12462, 12549, 12637, 12723, 12810, 12896, 12983, 13068, 13154, 13240,
   13325, 13410, 13495, 13579, 13664, 13748, 13832, 13916, 14000, 14083,
   14167, 14250, 14333, 14416, 14499, 14582, 14665, 14747, 14830, 14912,
   14994, 15076, 15158, 15240, 15322, 15404, 15486, 15568, 15650, 15731,
   15813, 15894, 15976, 16058, 16139, 16221, 16302, 16384, 32767, 32735,
   32703, 32671, 32639, 32607, 32575, 32543, 32511, 32479, 32447, 32415,
   32383, 32351, 32319, 32287, 32255,     8,   461,   652,   798,   922,
   1031,  1129,  1220,  1304,  1383,  1458,  1530,  1598,  1663,  1726,
   1787,  1846  };

// First table for LSP quantification
short LSP_Q[56]  =
{   819,  1392,  1843,  2048,  2293,  2785,  3440,  4096,  3440,  3768,
   4096,  4423,  4792,  5242,  5775,  6348,  6963,  7782,  8601,  9420,
  10240, 11059, 11878, 12697,  8192,  8601,  9256,  9912, 10526, 11059,
  11714, 12369, 13025, 13680, 14336, 15155, 15974, 16793, 17612, 18432,
  14745, 15400, 16056, 17203, 18841, 20316, 22118, 23756, 22609, 23592,
  24576, 25395, 26214, 27115, 28098, 29081
};

short TAB_DI[38] =
{ 1604,  3522,  5816,  8559, 11839, 15761, 20451, 26060, 32767,
  1825,  4057,  6787, 10125, 14207, 19199, 25303,
  3110,  7402, 13324, 21494, 32767,
  4057, 10125, 19199,
  3110,  7402, 13324, 21494, 32767,
  4057, 10125, 19199,  5816, 15761, 32767,
  10125, 10125, 32767
};

short GQ[17] =  {     0,    37,    81,   132,   194,   266,   352,   454,   575,
		  717,   887,  1087,  1324,  1606,  1939,  2333,  2800 };
short GV[17] =  {     0,     9,    58,   105,   162,   228,   307,   401,   512,
		  643,   798,   983,  1201,  1459,  1765,  2127,  2557 };
short BQ[11] =  {     0,   328,   757,  1320,  2058,  3026,  4295,  5958,
		 8139, 10998, 14746                                    };
short BV[11] =  {     0,   153,   528,  1020,  1664,  2509,  3617,  5070,
		 6975,  9471, 12745                                    };

short NBB[25] = {8,16,16,8,8,
	       0,0,0,0,0,0,0,0,0,0,
	       0,0,0,0,0,0,0,0,0,0};
short BITDD[5] = {9,5,5,3,2};

long coef_i[9] = { -626684736, 7274874, 1238819712, 7274874, -626684736,
	-4058, -23341, 1585, 10127 };

// } ROM TABLES

// -------------------------------------------------------------------------
// RAM variables :
// -------------------------------------------------------------------------
// All in data structures.

// ------------------------------------------------------------------------
void InitializeROM(void)
// Global initializations of ROM tables : should only be called once
{
   // All data hardcoded. no initialization needed.
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\bib_32.h ===
void PassLow8(short *vin,short *vout,short *mem,short nech);
#if 0
// PhilF: The following functions are never called!!!
void PassLow11(short *vin,short *vout,short *mem,short nech);
void PassHigh8(short *mem, short *Vin, short *Vout, short lfen);
void PassHigh11(short *mem, short *Vin, short *Vout, short lfen);
void Down11_8(short *Vin, short *Vout, short *mem);
void Up8_11(short *Vin, short *Vout, short *mem1, short *mem2);
#endif
void QMFilter(short *in,short *coef,short *out_low,short *out_high,short *mem,short lng);
void QMInverse(short *in_low,short *in_high,short *coef,short *out,short *mem,short lng);
void iConvert64To8(short *in, short *out, short N, short *mem);
void iConvert8To64(short *in, short *out, short N, short *mem);
void fenetre(short *src,short *fen,short *dest,short lng);
void autocor(short *vech,long *ri,short nech,short ordre);
short max_autoc(short *vech,short nech,short debut,short fin);
short max_vect(short *vech,short nech);
void upd_max(long *corr_ene,long *vval,short pitch);
short upd_max_d(long *corr_ene,long *vval);
void norm_corrl(long *corr,long *vval);
void norm_corrr(long *corr,long *vval);
void energy(short *vech,long *ene,short lng);
void venergy(short *vech,long *vene,short lng);
void energy2(short *vech,long *ene,short lng);
void upd_ene(long *ener,long *val);
short max_posit(long *vcorr,long *maxval,short pitch,short lvect);
void correlation(short *vech,short *vech2,long *acc,short lng);
void  schur(short *parcor,long *Ri,short netages);
void interpol(short *lsp1,short *lsp2,short *dest,short lng);
void add_sf_vect(short *y1,short *y2,short deb,short lng);
void sub_sf_vect(short *y1,short *y2,short deb,short lng);
void short_to_short(short *src,short *dest,short lng);
void inver_v_int(short *src,short *dest,short lng);
void long_to_long(long *src,long *dest,short lng);
void init_zero(short *src,short lng);
#if 0
// PhilF: The following function is never called!!!
void update_dic(short *y1,short *y2,short hy[],short lng,short i0,short fact);
#endif
void update_ltp(short *y1,short *y2,short hy[],short lng,short gdgrd,short fact);
void proc_gain2(long *corr_ene,long *gain,short bit_garde);
void proc_gain(long *corr_ene,long *gain);
void decode_dic(short *code,short dic,short npuls);
void dsynthesis(long *z,short *coef,short *input,short *output,
						short lng,short netages);
void synthesis(short *z,short *coef,short *input,short *output,
				short lng,short netages,short bdgrd );
void synthese(short *z,short *coef,short *input,short *output,
						short lng,short netages);
void f_inverse(short *z,short *coef,short *input,short *output,
						short lng,short netages );
void filt_iir(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre);
#if 0
// PhilF: The following is never called!!!
void filt_iir_a(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre);
#endif
void mult_fact(short src[],short dest[],short fact,short lng);
void mult_f_acc(short src[],short dest[],short fact,short lng);
void dec_lsp(short *code,short *tablsp,short *nbit,short *bitdi,short *tabdi);
void teta_to_cos(short *tabcos,short *lsp,short netages);
void cos_to_teta(short *tabcos,short *lsp,short netages);
void lsp_to_ai(short *ai_lsp,long *tmp,short netages);
void ki_to_ai(short *ki,long *ai,short netages);
void ai_to_pq(long *aip,short netages);
void horner(long *P,long *T,long *a,short n,short s);
short calcul_s(long a,long b);
void binome(short *lsp,long *PP);
void deacc(short *src,short *dest,short fact,short lfen,short *last_out);
void filt_in(short *mem,short *Vin,short *Vout,short lfen);
short calc_gltp(short *gltp,short *bq,short *bv,long ttt);
short calc_garde(short MAX);
short calc_gopt(short *c,short *code,short *gq,short *gv,short voise,
	short npopt,short pitch,short espopt,short depl,short position,
	short soudecal,long vmax);
void decimation(short *vin,short *vout,short nech);

#ifndef _X86_
#ifdef __cplusplus
extern "C" {
#endif

unsigned int SampleRate6400To8000( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputStreamTime,
                                   int * piOutputStreamTime );

unsigned int SampleRate8000To6400( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputStreamTime,
                                   int * piOutputStreamTime );

int FirFilter( int * piFilterCoefficients,
               int * piFilterDelay,
               unsigned int uiDelayPosition,
               unsigned int uiFilterLength );

_int64 DotProduct( int * piVector_0,
                   int * piVector_1,
                   unsigned int uiLength );
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\encoder.c ===
/*#define __TEST

#ifdef __TEST
#include <stdio.h>
FILE *test;
FILE *codage;
#endif*/

/*
 *   Project:		Direct Subband 16000 bps coder and SBCELP 4800 bps coder
 *   Workfile:		encoder.c
 *   Author:		Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	4 September 1995
 *   DLL Version:	1.00
 *   Revision:          Single DLL for coder and decoder.
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Included files
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
#include <math.h>
#include <windows.h>
#include <windowsx.h>

#include "fv_x8.h"
#include "data.h"
#include "bib_32.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function prototypes
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
void InitializeCoderInstanceData(PVOID p, DWORD dwMaxBitRate);
void decimation_I(short input_I[],short coef_I[],short low_part_mem_I[],short order);
#if 0
// PhilF: The following is never called!!!
void quant_0a16_I2(short z1, short z2 ,short vec[], short maxv, short B1[], short B2[], long *code);
#endif
void quant_sous_bandes(PC16008DATA p,short *in,short *codes_max, long *codes_sb, short *indic_br/*, short *code_max_br*/);
void code_res_I(PC16008DATA p,short input[],short coef[],short qmf_mem[],short v_code[],long cod_long[], short ind_br[]/*, short c_max_br*/);
#ifdef CELP4800
void COEFF_A(PC4808DATA p),CALPITCH(PC4808DATA p),CHERCHE(PC4808DATA p);
void PERIODE(PC4808DATA p,short no),FRAME(PC4808DATA p);
void lsp_quant(PC4808DATA p,short lsp[],short nbit[],short bitdi[],short vcode[]);
void cal_dic1(PC4808DATA p,short *y,short *sr,short *espopt,short *posit,short dec,short esp,short sigpit[],short soulong,long tlsp[],long vmax[]);
//void cal_dic2(short q,short espace,short phase,short *s_r,short *hy,short *b,short *vois,short *esp,short *qq,short *phas,short sigpit[],short soulong,long tlsp[],long vmax[]);
void cal_dic2(PC4808DATA p,short q,short espace,short phase,short *s_r,short *hy,short *b,short *vois,short *esp,short *qq,short *phas);
#endif
void decimation(short *vin,short *vout,short nech);

/*void iConvert64To8(int *in, int *out, int N, int *mem);
void iConvert8To64(int *in, int *out, int N, int *mem);
void BandPass(int *,int *,int *,int);*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Global variables for coder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

/*#define MAXCODINGHANDLES 10

// Instance data structure
PC16008DATA pCoderData;
C16008DATA CoderData[MAXCODINGHANDLES];
int CodingHandles[MAXCODINGHANDLES];*/

// ROM tables :
extern short coef_I[];		// QMF filter coeffs
extern short B3_I[];		// Five levels quantification table
extern short B4_I[];		// Four  levels quantification table
extern short B5_I[];		// Five levels quantification table
extern short B6_I[];		// Nine levels quantification table
extern short B7_I[];		// Nine levels quantification table
extern short B8_I[];		// Nine levels quantification table
extern short B9_I[];		// Nine levels quantification table
extern short max_level[];			// Quantified maximum sample level
extern long coeffs[];
extern long Mask[];
extern short hamming[];
extern short A0[];
extern short tabcos[];
extern short LSP_Q[];
extern short TAB_DI[];
extern short GQ[];
extern short GV[];
extern short BQ[];
extern short BV[];
extern short NBB[];
extern short BITDD[];
extern short LSP0ROM[];
//extern short quantif[];
//extern short bits[];
//extern short bytes[];

// RAM variables :
/*extern short codes_max[];		// Quantized max. of each subband
extern long codes_sb[];		// Two codes for each of the quantized subband
extern short indic_sp[];		// type of subband (1=noise; 0=to be decoded)
extern short code_max_br;		// 1 bit for coding the noise
extern short DATA_I[];            // Intermediate vector = input and output of QMF
extern char stream[];				// Coded data buffer*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function implementation
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
void InitializeCoderInstanceData(PVOID p, DWORD dwMaxBitRate)
// Instance data initializations
{
  short i;

#ifdef CELP4800
  if (dwMaxBitRate == 4800)
    {
    ((PC4808DATA)p)->dwMaxBitRate = dwMaxBitRate;

    ((PC4808DATA)p)->mem_pit[0]=((PC4808DATA)p)->mem_pit[1]=69;
    for (i=0;i<10;i++)
      ((PC4808DATA)p)->LSP0[i]=LSP0ROM[i];
    }
  else
#endif
    {
    ((PC16008DATA)p)->dwMaxBitRate = dwMaxBitRate;

    for (i=0;i<NBFAC;i++) ((PC16008DATA)p)->nbbit[i]=8; // On met les compteurs a "zero";
    // on suppose demarrer par du bruit

    ((PC16008DATA)p)->MAX_LEVEL   = MAX_LEVEL1; // valeur par defaut si le debit n'augmente pas trop
    ((PC16008DATA)p)->DIV_MAX     = DIV_MAX1; // cad on ne traite pas les sb < 5% du max[i]

    ((PC16008DATA)p)->quantif[0] = 9;
    ((PC16008DATA)p)->quantif[1] = 9;
    ((PC16008DATA)p)->quantif[4] = 5;
    ((PC16008DATA)p)->quantif[5] = 5;
    ((PC16008DATA)p)->quantif[6] = 5;
    ((PC16008DATA)p)->quantif[7] = 5;
    ((PC16008DATA)p)->quantif[8] = 5;
    ((PC16008DATA)p)->quantif[9] = 5;
    ((PC16008DATA)p)->bits[0] = 52;
    ((PC16008DATA)p)->bits[2] = 38;
    ((PC16008DATA)p)->bits[3] = 38;
    ((PC16008DATA)p)->bits[4] = 38;
	// Bug 3214: Just in case we get carried away, init the end of the arrays in both configurations
	((PC16008DATA)p)->quantif[10] = 5;
	((PC16008DATA)p)->quantif[11] = 5;
	((PC16008DATA)p)->bits[5] = 38;
    if (dwMaxBitRate == 16000)
      {
      ((PC16008DATA)p)->NBSB_SP_MAX = NBSB_SP_MAX1_16000; // nbre max de sb pouvant etre du signal
      ((PC16008DATA)p)->quantif[2] = 7;
      ((PC16008DATA)p)->quantif[3] = 7;
      ((PC16008DATA)p)->bits[1] = 46;
      }
    else
      {
      ((PC16008DATA)p)->NBSB_SP_MAX = NBSB_SP_MAX1_8000_12000; // nbre max de sb pouvant etre du signal
      ((PC16008DATA)p)->quantif[2] = 9;
      ((PC16008DATA)p)->quantif[3] = 9;
      ((PC16008DATA)p)->bits[1] = 52;
      }
    }
   return;
}

//------------------------------------------------------------------------
void decimation_I(short input_I[],short coef_I[],short low_part_mem_I[],short order)
//
// Purpose : from data stored in DATA[], create the N_SB subbands
// Remark  : output subband is stored at (input[]+N_SB*L_RES)
//
{
   short i,j,lng;

   short *low_out_part_I;
   short *high_out_part_I;
   short *buffer_I,*sa_vec_I;

   buffer_I = low_part_mem_I;

   for (i=0;i<N_SB;i++)
   {
      low_out_part_I=input_I+L_RES;
      lng = L_RES >> (i+1);
      high_out_part_I=low_out_part_I+lng;
      sa_vec_I=low_out_part_I;
      for (j=0;j<(1<<i);j++)
      {
	 low_part_mem_I=buffer_I;

	 QMFilter(input_I,coef_I,low_out_part_I,high_out_part_I,low_part_mem_I,lng);

	 input_I += 2*lng;  low_out_part_I += lng; high_out_part_I += lng;

	 if (j&1) high_out_part_I += 2*lng;
	 else low_out_part_I += 2*lng;

	 buffer_I += 2*order;
      }
      input_I=sa_vec_I;
   }
}

#if 0
// PhilF: The following is never called!!!
//------------------------------------------------------------------------
void quant_0a16_I2(short z1, short z2, short vec[], short maxv, short B1[], short B2[], long *code)

// Quantifies the 16 samples of a subband on z levels using the table B[]
// Result stored in code[] (two long codes pro subband).
{
   short i,x;
   short ftmp;
   long result;

   result=0;
   for (i=0;i<8;i++)	// Quantify the first eight samples of the subband
      {
      ftmp=(((long)vec[i])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *code=result;	// Store code

   result=0;
   for (i=0;i<8;i++)	// Quantify the last eight samples of the subband
      {
      ftmp=(((long)vec[i+8])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *(code+1)=result;	// Store code

}
#endif

void quant_0a16_I3(short z1, short z2, short vec[], short maxv, long *code)

// Quantifies the 16 samples of a subband on z levels using the table B[]
// Result stored in code[] (two long codes pro subband).
{
   short i,x;
   short ftmp;
   long result;
   short *B1,*B2;

   switch (z1)
   {
      case 3: B1=B3_I; break;
      case 4: B1=B4_I; break;
      case 5: B1=B5_I; break;
      case 6: B1=B6_I; break;
      case 7: B1=B7_I; break;
      case 8: B1=B8_I; break;
      case 9: B1=B9_I; break;
	// Bug 3214: Just in case we're passed a bogus value, set a default quantizer
	default: B1=B5_I; break;
   }
   switch (z2)
   {
      case 3: B2=B3_I; break;
      case 4: B2=B4_I; break;
      case 5: B2=B5_I; break;
      case 6: B2=B6_I; break;
      case 7: B2=B7_I; break;
      case 8: B2=B8_I; break;
      case 9: B2=B9_I; break;
	// Bug 3214: Just in case we're passed a bogus value, set a default quantizer
	default: B2=B5_I; break;
   }

   result=0;
   for (i=0;i<8;i++)	// Quantify the first eight samples of the subband
      {
      ftmp=(((long)vec[i])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *code=result;	// Store code

   result=0;
   for (i=0;i<8;i++)	// Quantify the last eight samples of the subband
      {
      ftmp=(((long)vec[i+8])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *(code+1)=result;	// Store code

}

//------------------------------------------------------------------------
void quant_sous_bandes(PC16008DATA p,short *in,short *codes_max, long *codes_sb, short *indic_sp)

// Quantifies the eight subbands

{
   short max[8];
   short order[8]={0,0,0,0,0,0,0,0};
   short codes_max_loc[8]={0,0,0,0,0,0,0,0};
   short maximum,max_num,ord,maxmax;
   short i,j;
  #ifdef MAX_SB_ABSOLU
   short sb_count;
  #endif

   for (i=0;i<8;i++)	// Quantify the maximums of the subbands
      {
      max[i]=0;
      for (j=0;j<16;j++)
	if (abs(*(in+16*i+j))>max[i]) max[i]=abs(*(in+16*i+j));
      }

   for (i=0;i<8;i++)
     {
     if (max[i]>2*max_level[31]) j = 31;
     else                      for (j=0; max[i]>2*max_level[j]; j++);
     codes_max_loc[i]=j;
     max[i]=2*max_level[j];
     }  // fin quantifiation

   p->nbbit_cf+=8; // 8 bits for the indic_sp

   maxmax=0;
   for (i=0;i<8;i++) // On cherche le plus grand maximum
     {
     if (max[i]>maxmax) maxmax=max[i];
     }
   maxmax/=p->DIV_MAX;  // On le divise par 10 a 20 (cad a peu pres 10 a 5 %)

   ord=8;
   p->nbsb_sp=0;
   for (i=0;i<8;i++)	// Calculates the order of the subbands
     {                  // 1 is higher energy than 2 than 3,..
     maximum=32767;
     for (j=7;j>=0;j--)
       {
       if ((order[j]==0)&&(max[j]<maximum))
	 {
	 max_num=j; maximum=max[j];
	 }
       }
     order[max_num]=ord;
     if ( (ord>p->NBSB_SP_MAX)||(maximum<=p->MAX_LEVEL)||(maximum<=maxmax) )
       {
       indic_sp[max_num]=0; // c'est 1 bande qui sera du bruit
       }
     else
       {
       indic_sp[max_num]=1;
       p->nbsb_sp++;
       }
     ord--;
     }

   j=0;
   for (i=0;i<8;i++)
   {
     if (indic_sp[i]==1)
     {
       codes_max[j]=codes_max_loc[i];  //5* 4 ou 5 bits suffisent
       j++;
       p->nbbit_cf+=5; // 5 bits per coded max
     }
   }

   for (i=p->nbsb_sp-1;i>=0;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     quant_0a16_I3(p->quantif[2*i],p->quantif[2*i+1],in+j*16,max[j],codes_sb+2*i);
     p->nbbit_cf+=p->bits[i];
     }

  if (p->dwMaxBitRate == 16000)
    {
   j=0;
  #ifdef MAX_SB_ABSOLU
   sb_count=p->nbsb_sp;
   if (sb_count>=MAX_SB_ABSOLU) return;
  #endif

   for (i=0;i<8;i++)
   {
     if (indic_sp[i]==0)
     {
       codes_max[p->nbsb_sp+j]=codes_max_loc[i];  //5* 4 ou 5 bits suffisent
       j++;
       p->nbbit_cf+=5; // 5 bits per coded max
      #ifdef MAX_SB_ABSOLU
       sb_count++;
       quant_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,in+i*16,max[i],codes_sb+2*sb_count);
       p->nbbit_cf+=SILENCE_CODING_BIT_16000;
       if (sb_count>=MAX_SB_ABSOLU) break;
      #endif
     }
   }

  #ifndef MAX_SB_ABSOLU
   for (i=7;i>=p->nbsb_sp;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     quant_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,in+j*16,max[j],codes_sb+2*i);
     p->nbbit_cf+=SILENCE_CODING_BIT_16000;
     }
  #endif

  }
}

//------------------------------------------------------------------------

void code_res_I(PC16008DATA p,short input[],short coef[],short qmf_mem[],short v_code[],long cod_long[], short ind_br[]/*, short c_max_br*/)

{
   decimation_I(input,coef,qmf_mem,Fil_Lenght);
   quant_sous_bandes(p,input+3*L_RES,v_code,cod_long,ind_br/*AW,&c_max_br*/);
}

//------------------------------------------------------------------------
short Multiplexing(
	char *Stream,
	long *Codes,
	short *CodeSizes,
	short NumCodes,
	short StreamSize)
{
   short B,P;	// B=bits  coder, P=bits libres
   short i,j;

   #ifdef __CHECK_FORMAT
   long TotalBytes=0;

   for (i=0;i<NumCodes;i++) TotalBytes+=CodeSizes[i];
   if (TotalBytes>StreamSize*8) return 1;
   #endif

   i=0;
   j=0;
   B=CodeSizes[i];	// bits  coder
   P=8;			// 1 octet libre au dpart
   Stream[j]=0;
   while (i<NumCodes)
   {
      if (P>B)
      {
	 Stream[j]|=(Codes[i]&Mask[B])<<(P-B);
	 P-=B;
	 i++;
	 B=CodeSizes[i];
      }
      else if (P<B)
      {
	 Stream[j]|=(Codes[i]>>(B-P))&Mask[P];
	 B-=P;
	 P=8;
	 j++;
	 Stream[j]=0;
      }
      else
      {
	 Stream[j]|=Codes[i]&Mask[P];
	 i++;
	 j++;
	 P=8;
	 B=CodeSizes[i];
	 Stream[j]=0;
      }
   }
   return 0;
}

// ------------------------------------------------------------------------
#ifdef CELP4800
void iteration(PC4808DATA p,long *P,short n,short *s)
{
   short i;

   p->a=0x7fffffffL;
   for(i=0;i<7 ;i++)
   {
      horner(P,p->ttt,&p->a,n,*s);
      horner(p->ttt,p->TLSP+12,&p->b,(short)(n-1),*s);

      *s += calcul_s(p->a,p->b);
   }
   horner(P,p->ttt,&p->a,n,*s);
   *(P+n) = 0;
   long_to_long(p->ttt,P,n);
}

// ------------------------------------------------------------------------
void ai_to_lsp(PC4808DATA p,long *ai_pq,short *lsp)
{
   short s;  short n;

   ai_to_pq(ai_pq,10);

   s=0x7fff;
   p->ptr1 = lsp;
   for(n=5; n>2; n--)
   {
      iteration(p,ai_pq,n,&s);
      *p->ptr1++ = s;
      if (lsp[0]<0) lsp[0]=s=32765;
      iteration(p,ai_pq+6,n,&s);
      *p->ptr1++ = s;
   }
   binome(lsp+6,ai_pq);
}

// ------------------------------------------------------------------------
void cal_dic1(PC4808DATA p,short *y,short *sr,short *espopt,short *posit,short dec,short esp,
		short *sigpi,short soulong,long *tlsp,long *vmax)
{
   short i,k,limite;
   long  *vene;

   vene = (long *)(sigpi+150);
   venergy(y,vene,soulong);

   k=soulong-1;

   for (i=0;i<dec;i++)
   {
      p->ptr1 = sr;limite=i;
      *tlsp = *(p->ptr1+limite); limite += esp;
      while (limite<soulong) { *tlsp += *(p->ptr1+limite); limite += esp;}
      *(tlsp+1) = *(vene+k-i);
      limite=upd_max_d(tlsp,vmax);
      if (limite) {*posit=i; *espopt=esp; *posit=i; *espopt=esp;}
   }
}

// ------------------------------------------------------------------------
void cal_dic2(PC4808DATA p,short q,short espace,short phase,short *s_r,short *hy,
	     short *b,short *vois,short *esp,short *qq,short *phas)
{
   short i,j,i0,k;
   short src[10],*y2; short cc[10];
   long R11;

   y2 = p->SIGPI+75;
   R11 = 0;
   init_zero(y2,p->SOULONG);

   for (j=0;j<q;j++)
   {
      i0=espace*j+phase;
      src[j]=s_r[i0];
   }

   for (j=0;j<q;j++) if (src[j]>0) cc[j]=1;
			     else  cc[j]=-1;


   for (i=0;i<q;i++) R11 += abs(src[i]);

   for (j=0;j<q;j++)
   {
      i0=espace*j+phase;
      k=cc[j];
      if (k>0)
      {
	 add_sf_vect(y2,hy,i0,p->SOULONG);
      }
      else
      {
	 sub_sf_vect(y2,hy,i0,p->SOULONG);
      }
   }

   energy2(y2,p->TLSP+1,p->SOULONG);

   *p->TLSP=R11;
   i = upd_max_d(p->TLSP,p->VMAX);
   if (i)   { short_to_short(cc,b,q); *vois=0; *esp=espace; *qq=q; *phas=phase; }

   /* for (i=0;i<q;i++)
   {
      cc[i]=-cc[i];
      *TLSP = R11 + 2*src[i]*cc[i];
      k=2*cc[i];
      i0=espace*i+phase;
      update_dic(y1,y2,hy,SOULONG,i0,k);
      energy2(y1,TLSP+1,SOULONG);
      k = upd_max_d(TLSP,VMAX);
      if (k)
      {
	 short_to_short(cc,b,q);
	 R11 = *TLSP;
	 my2=y1; y1=y2; y2=my2;
	 *vois=0; *esp=espace; *qq=q; *phas=phase;
      }
      else cc[i]=-cc[i];
   }*/
}

/*-------------------------------------------------------------------------
Review version of CAL_DIC2
{
   R11 = 0;
   init_zero(y2,SOULONG);
   i0=phase-espace;
   for (j=0;j<q;j++)
   {
      i0+=espace;
      src[j]=s_r[i0];
      if (src[j]>0)
      {
	 cc[j]=1;
	 R11 += (long)(src[j]);
	 add_sf_vect(y2,hy,i0,SOULONG);
      }
      else
      {
	 cc[j]=-1;
	 R11 -= (long)(src[j]);
	 sub_sf_vect(y2,hy,i0,SOULONG);
      }
   }
   energy2(y2,TLSP+1,SOULONG);
   *TLSP=R11;
   i = upd_max_d(TLSP,VMAX);
   if (i)   { short_to_short(cc,b,q); *vois=0; *esp=espace; *qq=q; *phas=phase; }

   i0=phase-espace;
   for (i=0;i<q;i++)
   {
      cc[i]=-cc[i];
      *TLSP = R11 + 2*src[i]*cc[i];
      k=2*cc[i];
      i0+=espace;
      update_dic(y1,y2,hy,SOULONG,i0,k);
      energy2(y1,TLSP+1,SOULONG);
      k = upd_max_d(TLSP,VMAX);
      if (k)
      {
	 short_to_short(cc,b,q);
	 R11 = *TLSP;
	 my2=y1; y1=y2; y2=my2;
	 *vois=0; *esp=espace; *qq=q; *phas=phase;
      }
      else cc[i]=-cc[i];
   }
}
-----------------------------------------------------------------------*/

// ------------------------------------------------------------------------
void left_correl(PC4808DATA p,short vech[],short debut,short fin,short pitch,short delta,long *vv)
{
   short i,k,lng;

   lng=fin-debut+1;
   i=pitch-delta;

   energy(vech+debut-i,p->TLSP+2,lng);
   correlation(vech+debut-i,vech+debut,p->TLSP,lng);
   norm_corrl(vv,p->TLSP);

   for (i=pitch-delta+1;i<=pitch+delta;i++)
   {
      correlation(vech+debut-i,vech+debut,p->TLSP,lng);
      p->TLSP[10] = (long)vech[debut-i]*(long)vech[debut-i];
      p->TLSP[11] = (long)vech[fin-i+1]*(long)vech[fin-i+1];
      upd_ene(p->TLSP+2,p->TLSP+10);
      k=i-pitch+delta;
      norm_corrl(vv+2*k,p->TLSP);
   }
}

// ------------------------------------------------------------------------
void right_correl(PC4808DATA p,short vech[],short debut,short fin,short pitch,short delta,long *vv)
{
   short i,k,lng;

   lng=fin-debut+1;
   i=pitch-delta;
   energy(vech+debut+i,p->TLSP+2,lng);
   correlation(vech+debut+i,vech+debut,p->TLSP,lng);

   norm_corrr(vv,p->TLSP);

   for (i=pitch-delta+1;i<=pitch+delta;i++)
   {
      correlation(vech+debut+i,vech+debut,p->TLSP,lng);
      p->TLSP[11]=(long)vech[debut+i-1]*(long)vech[debut+i-1];
      p->TLSP[10]=(long)vech[fin+i]*(long)vech[fin+i];
      upd_ene(p->TLSP+2,p->TLSP+10);
      k=i-pitch+delta;
      norm_corrr(vv+2*k,p->TLSP);
   }
}

// ------------------------------------------------------------------------
void COEFF_A(PC4808DATA p)
{
   fenetre(p->SIG+SOUDECAL1-RECS2,hamming,p->SIGPI,NECHFEN);
   autocor(p->SIGPI,p->TLSP,NECHFEN,NETAGES);

   // TLSP[0]=ldiv(TLSP[0]*1001L,1000L);
   if (*p->TLSP)
     {
     schur(p->LSP,p->TLSP,NETAGES);

     ki_to_ai(p->LSP,p->TLSP,NETAGES);
     ai_to_lsp(p,p->TLSP,p->LSP);
     cos_to_teta(tabcos,p->LSP,10);
     }
   else short_to_short(p->LSP0,p->LSP,10);

   lsp_quant(p,p->LSP,NBB,BITDD,p->code);

   short_to_short(p->LSP,p->A3,10);
   teta_to_cos(tabcos,p->A3,10);
   lsp_to_ai(p->A3,p->TLSP,10);

   interpol(p->LSP0,p->LSP,p->A1,NETAGES);
   teta_to_cos(tabcos,p->A1,10);
   lsp_to_ai(p->A1,p->TLSP,10);

   interpol(p->LSP,p->LSP0,p->A2,NETAGES);
   teta_to_cos(tabcos,p->A2,10);
   lsp_to_ai(p->A2,p->TLSP,10);

   short_to_short(p->LSP,p->LSP0,NETAGES);
}

// ------------------------------------------------------------------------
void lsp_quant(PC4808DATA p,short lsp[],short nbit[],short bitdi[],short vcode[])
{
   short i,iopt,k,nombi,m,m1,k2;
   short *delta,*lsptab,dmin,tmp,demi;

   delta = p->E;
   lsptab = LSP_Q;

   m1 = NETAGES/2;
   for (i=0;i<nbit[0];i++) delta[i]=abs(lsp[0] - *(lsptab+i) );
   dmin=delta[0];
   iopt=0;
   for (i=1;i<nbit[0];i++)
      if (delta[i]<dmin)
      {
	 dmin=delta[i];
	 iopt=i;
      }
   lsp[0] = *(lsptab+iopt);
   vcode[0]=iopt;

   for (k=1;k<m1;k++)
   {
      k2=2*k;
      lsptab += nbit[k-1];
      for (i=0;i<nbit[k];i++) delta[i]=abs(lsp[k2] - *(lsptab+i));
      dmin=32767;
      tmp=lsp[k2-1];
      if (tmp<lsp[k2-2]) tmp=lsp[k2-2];
      for (i=0;i<nbit[k];i++)
	 if (*(lsptab+i)>tmp)
	    if (delta[i]<dmin)
	    {
	       dmin=delta[i];
	       iopt=i;
	    }
      lsp[k2] = *(lsptab+iopt);
      vcode[k2] = iopt;
   }

   lsptab = TAB_DI;
   for (k=0; k<m1-1; k++)
   {
      k2 = k<<1;
      m=bitdi[k];
      nombi = (m-1)<<1;
      demi=(lsp[k2+2]-lsp[k2]+1)>>1;
      for (i=0;i<m;i++)
	 delta[i]=lsp[k2] + (short)(((long)*(lsptab++)* (long)demi+(long)16384<<1)>>16);
      for (i=0;i<m-2;i++) delta[m+i]=lsp[k2+2] - (short)(((long)*(lsptab++) * (long)demi+(long)16384<<1)>>16);
	 dmin=32767;
      for (i=0;i<nombi;i++)
      {
	 tmp = abs(lsp[k2+1]-delta[i]);
	 if (tmp<dmin)
	 {
	    iopt=i;
	    dmin=tmp;
	 }
      }
      lsp[k2+1]=delta[iopt];
      vcode[k2+1]=iopt;
   }
   m=bitdi[k];
   nombi=(m-1)<<1;
   demi=(32767-lsp[8]+1)>>1;
   for (i=0;i<m;i++) delta[i] = lsp[8] + (short)(((long)*(lsptab++) * (long)demi+(long)16384<<1)>>16);
   dmin=32767;
   for (i=0;i<nombi;i++)
   {
      tmp = abs(lsp[9]-delta[i]);
      if (tmp<dmin)
      {
	 iopt=i;
	 dmin=tmp;
      }
   }
   lsp[9]=delta[iopt];
   vcode[9]=iopt;
}

// ------------------------------------------------------------------------
void RESIDU(PC4808DATA p,short no)
{
   short i0;

   switch (no)
   {
   case 0:
	   i0=0;
	   break;
   case 1: short_to_short(p->A2,p->A1,11);
	   i0=SOUDECAL1;
	   break;
   case 2: short_to_short(p->A3,p->A1,11);
	   i0=SOUDECAL1+SOUDECAL;
	   break;
   }
   f_inverse(p->MINV,p->A1,p->SIG+i0,p->E,p->SOULONG,NETAGES);
}

// ------------------------------------------------------------------------
void PERIODE(PC4808DATA p,short no)
{
   short i,P1,P2;
   short *y0,*y1,*y2;
   short MAX,MAX2,j,bit_garde;

   y0=p->SIGPI; y2=y0+75; y1=p->E_PE;

   fenetre(p->A1,A0,p->Aw,11);

   init_zero(p->zz,12);
   p->H[0]=4096;
   init_zero(p->H+1,(short)(p->SOULONG-1));
   synthesis(p->zz,p->Aw,p->H,p->H,35,NETAGES,0);


   if (no)
   {
      P1=p->PITCH-3;
      if (P1<LIM_P1) P1=LIM_P1;
      P2=p->PITCH+4;
      if (P2>LIM_P2) P2=LIM_P2;
   }
   else
   {
      P1=p->PITCH-5;
      if (P1<LIM_P1) P1=LIM_P1;
      P2=p->PITCH+5;
      if (P2>LIM_P2) P2=LIM_P2;
   }

   // calc_p(&P1,&P2,PITCH,LIM_P1,LIM_P2,no);

   MAX = max_vect(p->E,p->SOULONG);

   if (P2<p->SOULONG) MAX2 = max_vect(p->EE+lngEE-P2,P2);
   else
   {
      if (P1<p->SOULONG) j=P1+16;
      else            j=p->SOULONG+16;
      MAX2 = max_vect(p->EE+lngEE-P2,j);
   }

   if (MAX2>MAX) MAX=MAX2;

   if (MAX & 0xe000)
   {
      i=MAX >> 13;
      if (!(i>>1)) bit_garde=1;
      else   bit_garde=2;
   }
   else bit_garde=0;

   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,p->E,y1,p->SOULONG,NETAGES,bit_garde);

   if (P1<p->SOULONG)
   {
      short_to_short(p->EE+lngEE-P1,y0,P1);
      for (i=P1;i<p->SOULONG;i++) y0[i]=0;
   }
   else short_to_short(p->EE+lngEE-P1,y0,p->SOULONG);

   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,y0,y0,p->SOULONG,NETAGES,bit_garde);
   short_to_short(y0,y2,p->SOULONG);

   if (P1<p->SOULONG) add_sf_vect(y2,y0,P1,p->SOULONG);

   if (2*P1<p->SOULONG) add_sf_vect(y2,y0,(short)(P1<<1),p->SOULONG);

   energy(y2,p->TLSP+2,p->SOULONG);
   correlation(y1,y2,p->TLSP,p->SOULONG);

   p->VMAX[1]=-6969;
   p->VMAX[4]=P1;

   upd_max(p->TLSP,p->VMAX,P1);

   for (i=P1+1;i<=P2;i++)
   {
      p->ptr1=y0; y0=y2; y2=p->ptr1;
      update_ltp(y0,y2,p->H+1,p->SOULONG,bit_garde,p->EE[lngEE-i]);
      if (i<p->SOULONG)
      {
	 short_to_short(y0,y2,p->SOULONG);
	 add_sf_vect(y2,y0,i,p->SOULONG);
	 if (2*i<p->SOULONG) add_sf_vect(y2,y0,(short)(i<<1),p->SOULONG);
	 energy(y2,p->TLSP+2,p->SOULONG);
	 correlation(y1,y2,p->TLSP,p->SOULONG);
      }
      else
      {
	 energy(y0,p->TLSP+2,p->SOULONG);
	 correlation(y1,y0,p->TLSP,p->SOULONG);
      }
      upd_max(p->TLSP,p->VMAX,i);
   }

#if 0
  //*(p->VMAX+2) = 28265821L;
  //*(p->VMAX+3) = 61L;
  //*(p->VMAX+2) = 881427L;
  //*(p->VMAX+3) = 1L;
  //*(p->VMAX+2) = 9851363L;
  //*(p->VMAX+3) = 6L;
  //*(p->VMAX+2) = 812881L;
  //*(p->VMAX+3) = 2L;
#if 1
  // Save jmp
   if ((*(p->VMAX+2) < 0L) || (*(p->VMAX+3) == 0L) || (((long)((long)(*(p->VMAX+2))/(long)(*(p->VMAX+3))) & 0xFFFC0000) == 0L))
     proc_gain(p->VMAX+2,p->ttt);
   else
     *(p->ttt) = 0L;  // *(p->VMAX+3) = 0L;
#else
   if ((*(p->VMAX+2) > 0L) && (*(p->VMAX+3)) && ((long)((long)(*(p->VMAX+2))/(long)(*(p->VMAX+3))) & 0x0FFC0000))
   {
     *(p->ttt) = 0L;  // *(p->VMAX+3) = 0L;
   }
   else
     proc_gain(p->VMAX+2,p->ttt);
#endif
#else
  //*(p->VMAX+2) = 28265821L;
  //*(p->VMAX+3) = 61L;
  //*(p->VMAX+2) = 881427L;
  //*(p->VMAX+3) = 1L;
  //*(p->VMAX+2) = 9851363L;
  //*(p->VMAX+3) = 6L;
  //*(p->VMAX+2) = 812881L;
  //*(p->VMAX+3) = 2L;
  proc_gain(p->VMAX+2,p->ttt);
#endif
   p->PITCH=(short)p->VMAX[4];
   /*
   if (ttt[0]>32767) GLTP=32767;
   else
      if (ttt[0]<-32767) GLTP=-32767;
      else GLTP=ttt[0];
   m = abs(GLTP);
   for (i=1;i<=10;i++) if ((m>=BQ[i-1])&&(m<BQ[i]))
   {
      if (GLTP>0) { GLTP=BV[i] ; k=i-1; }
      else        { GLTP=-BV[i]; k=i+10-1; }
      break;
   }
   if (GLTP>=BQ[10])  { GLTP=BV[10]; k=9; }
   if (GLTP<-BQ[6])   { GLTP=-BV[6]; k=15 ; }
   */
   p->code[11+p->depl]=calc_gltp(&p->GLTP,BQ,BV,p->ttt[0]);;
   p->code[10+p->depl]=p->PITCH;

   if (p->PITCH<p->SOULONG)
   {
      short_to_short(p->EE+lngEE-p->PITCH,p->E_PE,p->PITCH);
      short_to_short(p->E_PE,p->E_PE+p->PITCH,(short)(p->SOULONG-p->PITCH));
      mult_fact(p->E_PE,p->E_PE,p->GLTP,p->SOULONG);
   }
   else
   {
      mult_fact(p->EE+lngEE-p->PITCH,p->E_PE,p->GLTP,p->SOULONG);
   }
}

// ------------------------------------------------------------------------
void CHERCHE(PC4808DATA p)
{
   short i;
   short position,esp_opt;
   short k,j;
   short c[10],VOISE,npopt,phas_opt,cod,sign;
   short  Gopt;
   short *sr,*y0;
   short MAX,bit_garde;

   sr=p->SIGPI; y0=sr+75;
   for (i=0;i<p->SOULONG;i++) p->E[i] -= p->E_PE[i];
   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,p->E,sr,p->SOULONG,NETAGES,0);
   MAX = max_vect(sr,p->SOULONG);

   /* if (MAX & 0xfe00)
   {
      i=MAX >> 9;
      if (!(i>>1)) bit_garde=1;
      else if (!(i>>2)) bit_garde=2;
      else if (!(i>>3)) bit_garde=3;
      else if (!(i>>4)) bit_garde=4;
      else if (!(i>>5)) bit_garde=5;
      else   bit_garde=6;
   }
   else bit_garde=0;
   */
   bit_garde=calc_garde(MAX);

   inver_v_int(sr,y0,p->SOULONG);
   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,y0,y0,p->SOULONG,NETAGES,bit_garde);
   inver_v_int(y0,sr,p->SOULONG);

   p->VMAX[0]=-6969;
   Gopt=position=0;

   VOISE=1;
   if ( !p->UNVOIS )
   {
      esp_opt=p->PITCH;
      short_to_short(p->H,y0,p->SOULONG);
      if (p->PITCH<p->SOULONG) add_sf_vect(y0,p->H,p->PITCH,p->SOULONG);
      // cal_dic1(y0,sr,&esp_opt,&position,SOULONG,PITCH);
      cal_dic1(p,y0,sr,&esp_opt,&position,p->SOULONG,p->PITCH,p->SIGPI,p->SOULONG,p->TLSP,p->VMAX);
      /* if (PITCH>=SOULONG)
      {
	 if (PITCH/2<SOULONG) sign = PITCH/2;
	 else sign=PITCH/3;
	 short_to_short(H,y0,SOULONG);
	 add_sf_vect(y0,H,sign,SOULONG);
	 // cal_dic1(y0,sr,&esp_opt,&position,54,sign);
	 cal_dic1(y0,sr,&esp_opt,&position,54,sign,SIGPI,SOULONG,TLSP,VMAX);
      }
      // else  cal_dic1(H,sr,&esp_opt,&position,54,SOULONG+5);
      else  cal_dic1(H,sr,&esp_opt,&position,54,SOULONG+5,SIGPI,SOULONG,TLSP,VMAX);
      */
   }

   cal_dic2(p,8,7,0,sr,p->H,c,&VOISE,&esp_opt,&npopt,&phas_opt);
   cal_dic2(p,7,8,3,sr,p->H,c,&VOISE,&esp_opt,&npopt,&phas_opt);
   /*
   cal_dic2(8,7,0,sr,H,c,&VOISE,&esp_opt,&npopt,&phas_opt,SIGPI,SOULONG,TLSP,VMAX);
   cal_dic2(7,8,3,sr,H,c,&VOISE,&esp_opt,&npopt,&phas_opt,SIGPI,SOULONG,TLSP,VMAX);
   */
   proc_gain2(p->VMAX+1,p->VMAX,bit_garde);

   if (p->VMAX[0]>32767) Gopt=32767;
   else if (p->VMAX[0]<-32767) Gopt=-32767;
   else  Gopt=(short)p->VMAX[0];

   if (VOISE==0)
   {
      if (c[0]==-1)
      {
	 Gopt=-Gopt;
	 for (k=0;k<npopt;k++) c[k]=-c[k];
      }
      if (npopt==7) cod = 64;
      else  cod = 128;
      for (j=1;j<npopt;j++)
	 if (c[j]==1) cod += 1 << (npopt-j-1);
   }
   else
   {
      if (esp_opt == p->PITCH) cod=position;
      else  cod = position+SOUDECAL1;
   }
   p->code[12+p->depl]=cod;

   if (Gopt<0) { Gopt=-Gopt;  sign=1; }
   else  sign=0;

   for (i=1;i<=16;i++) if ((Gopt>=GQ[i-1])&&(Gopt<GQ[i]))
   {
      Gopt=GV[i];
      cod=i-1;
      break;
   }
   if (Gopt>=GQ[16]) { Gopt=GV[16]; cod=15; }

   if (sign) { Gopt = -Gopt; cod += 16; }

   p->code[13+p->depl]=cod;
   // Gopt=calc_gopt(c,code,GQ,GV,VOISE,npopt,PITCH,esp_opt,depl,position,SOUDECAL1,VMAX[0]);
   short_to_short(p->E_PE,p->E,p->SOULONG);

   if (VOISE==1)
   {
      i=0;
      do
      {
	 p->E[position+i] += Gopt;
	 i += esp_opt;
      }
      while ((position+i)<p->SOULONG);
   }
   else
      for (j=0;j<npopt;j++)
	 p->E[esp_opt*j+phas_opt] += c[j]*Gopt;

   short_to_short(p->EE+p->SOULONG,p->EE,(short)(lngEE-p->SOULONG));
   short_to_short(p->E,p->EE+lngEE-p->SOULONG,p->SOULONG);
}

// ------------------------------------------------------------------------
void FRAME(PC4808DATA p)
// Purpose : concatenate all parameters
// Input parameter  :
//          code[]  :  parameters code
//  Output parameter  :
//          output_stream[] :  multiplexed code
//
//  Comments: The LTP or Adaptive codebook is also called PITCH.
//
//  Bit allocation : Codebook or gain "i" is the codebook for suboutput_stream "i".
//  code[0] = LSP(0) : 3bits     code[10] = LTP codebook 1    : 7bits
//  code[1] = LSP(1) : 4bits     code[11] = LTP gain 1        : 4bits
//  code[2] = LSP(2) : 4bits     code[12] = Binary codebook 1 : 8bits
//  code[3] = LSP(3) : 3bits     code[13] = Binary gain 1     : 5bits
//  code[4] = LSP(4) : 4bits     code[14] = LTP codebook 2    : 4bits
//  code[5] = LSP(5) : 3bits     code[15] = LTP gain 2        : 4bits
//  code[6] = LSP(6) : 3bits     code[16] = Binary codebook 2 : 8bits
//  code[7] = LSP(7) : 2bits     code[17] = Binary gain 2     : 5bits
//  code[8] = LSP(8) : 3bits     code[18] = LTP codebook 3    : 4bits
//  code[9] = LSP(9) : 1bits     code[19] = LTP gain 3        : 4bits
//                               code[20] = Binary codebook 3 : 8bits
//                               code[21] = Binary gain 3     : 5bits
//
//  output_stream[0] = LSP[0] | LSP[1] | LSP[2] | (Binary gain 2)
//  output_stream[1] = LSP[3] | (Binary gain 3) | (Binary codebook 1)
//  output_stream[2] = LSP[4] | LSP[5] | LSP[6] | LSP[7] | LSP[8] | LSP[9]
//  output_stream[3] = (LTP codebook 1) | (LTP gain 1) | (Binary gain 1)
//  output_stream[4] = (LTP codebook 2) | (LTP gain 2) | (Binary codebook 2)
//  output_stream[5] = (LTP codebook 3) | (LTP gain 3) | (Binary codebook 3)
{
   p->code[18] = p->code[18]-p->code[14]+7;
   p->code[14] = p->code[14]-p->code[10]+7;
   p->code[10] -= LIM_P1;

   p->output_frame[0] = (p->code[0]<<13) | (p->code[1]<<9) | (p->code[2]<<5) | p->code[17];
   p->output_frame[1] = (p->code[3]<<13) | (p->code[21]<<8) | p->code[12];
   p->output_frame[2] = (p->code[4]<<12) | (p->code[5]<<9) | (p->code[6]<<6) | (p->code[7]<<4) | (p->code[8]<<1) | p->code[9];
   p->output_frame[3] = (p->code[10]<<9) | (p->code[11]<<5) | p->code[13];
   p->output_frame[4] = (p->code[14]<<12) | (p->code[15]<<8) | p->code[16];
   p->output_frame[5] = (p->code[18]<<12) | (p->code[19]<<8) | p->code[20];
   /*
   code[18] = code[18]-code[14]+3;
   code[14] = code[14]-code[10]+3;
   code[10] -= LIM_P1;

   output_frame[0] = (code[0]<<13) | (code[1]<<9) | code[12];
   output_frame[1] = (code[3]<<13) | (code[2]<<9) | code[16];
   output_frame[2] = (code[5]<<13) | (code[4]<<9) | code[20];

   output_frame[3] = (code[10]<<9) | (code[6]<<6) | (code[14]<<3) | code[18];
   output_frame[4] = (code[11]<<12) | (code[15]<<8) | (code[19]<<4) | (code[7]<<2) | code[8];
   output_frame[5] = (code[13]<<11) | (code[17]<<6) | (code[21]<<1) | code[9];
   */
}

// ------------------------------------------------------------------------
void CALPITCH(PC4808DATA p)
{
   short P1,P2,P3,j0,j1,L;
   /* long GG;

   GG=0;
   for (j=0;j<NECHFEN;j++) GG += (long)abs(SIG[SOUDECAL1-RECS2+j]);
   GG /= NECHFEN;
   if (GG<69) UNVOIS=1;
   else UNVOIS=0;*/

   L=NECHFEN+DECAL;

   p->ialf=0;
   deacc(p->M_PIT,p->SIGPI+10,29491,150,&p->ialf);
   deacc(p->SIG+SOUDECAL1-RECS2,p->SIGPI+160,29491,211,&p->ialf);

   j0=(L-80)/2;
   j1=j0+80;
   /*
   filt_iir(memfil_calp,coef_calp,SIGPI+10,SIG_CALP,361,3); // filtrage
   for (j=0;j<90;j++) SIG_CALP[j]=SIG_CALP[4*j];		//dcimation par 4
   */
   //// decime(SIGPI+10,SIG_CALP,coef_calp,Zai,Zbi,361);
   decimation(p->SIGPI+10,p->SIG_CALP,90);

   P1=max_autoc(p->SIG_CALP+40,28,5,14)*4;
   P2=max_autoc(p->SIG_CALP+20,56,13,28)*4;

   /* P1=max_autoc(SIGPI+160,130,LIM_P1,LIM_P1+35);
   P2=max_autoc(SIGPI+160-80,280,LIM_P1+30,LIM_P2);
   */
   P3=P2/2; p->ialf=P2/3;
   if ( (p->ialf>p->mem_pit[0]-17)&&(p->ialf<p->mem_pit[0]+17) && (abs(p->mem_pit[0]-p->ialf)<abs(p->mem_pit[0]-P3))) P3=p->ialf;

   left_correl(p,p->SIGPI,j0,j1,P1,2,p->veci1);
   left_correl(p,p->SIGPI,j0,j1,P2,2,p->veci2);
   left_correl(p,p->SIGPI,j0,j1,P3,2,p->veci3);

   right_correl(p,p->SIGPI,j0,j1,P1,2,p->veci1);
   right_correl(p,p->SIGPI,j0,j1,P2,2,p->veci2);
   right_correl(p,p->SIGPI,j0,j1,P3,2,p->veci3);

   P1=max_posit(p->veci1,p->TLSP,P1,5);
   P2=max_posit(p->veci2,p->TLSP+2,P2,5);
   P3=max_posit(p->veci3,p->TLSP+4,P3,5);

   if (p->TLSP[1]>p->TLSP[3]) p->PITCH =P1;
   else if ((p->TLSP[1]==p->TLSP[3]) && (p->TLSP[0]>p->TLSP[2])) p->PITCH=P1;
   else  { p->PITCH=P2;  p->TLSP[0]=p->TLSP[2]; p->TLSP[1]=p->TLSP[3];}

   if ( (P3>p->mem_pit[0]-17) && (P3<p->mem_pit[0]+17))
   {
      if (abs(p->mem_pit[1]-p->mem_pit[0])<15)  p->TLSP[0] = p->TLSP[0]>>1 + p->TLSP[0]>>2;
      if (abs(P3-P1)>6) p->TLSP[0] = p->TLSP[0]>>1 + p->TLSP[0]>>2;
      if (p->TLSP[0]<0x40000000L) { p->TLSP[0]<<=1; p->TLSP[1]--;}
      // if (TLSP[0]<0x40000000) { TLSP[0]<<=1; TLSP[1]--;}
      if (p->TLSP[1]<p->TLSP[5]) p->PITCH =P3;
	       else if ((p->TLSP[1]==p->TLSP[5]) && (p->TLSP[0]<p->TLSP[4])) p->PITCH=P3;
   }
   p->mem_pit[1]=p->mem_pit[0];
   p->mem_pit[0]=p->PITCH;
}
#endif

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// DLL entry points
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Coder(DWORD dwMaxBitRate)
{
   PVOID pCoderData;
   /*short i,flag=0;

   // Test if there are free handles
   for (i=0;i<MAXCODINGHANDLES;i++)
      if (CodingHandles[i]==0) {CodingHandles[i]=1; flag=1; break;}
   if (flag==0) return 0;
   pCoderData=&CoderData[i];*/

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (dwMaxBitRate != 4800) && 
#endif
	  (dwMaxBitRate != 8000) && (dwMaxBitRate != 12000) && (dwMaxBitRate != 16000))
      return (HANDLE)0;

   // pCoderData=(PVOID)GlobalAllocPtr(GMEM_MOVEABLE, dwMaxBitRate == 4800 ? sizeof(C4808DATA) : sizeof(C16008DATA));
#ifdef CELP4800
   pCoderData=(PVOID)GlobalAllocPtr(GHND, dwMaxBitRate == 4800 ? sizeof(C4808DATA) : sizeof(C16008DATA));
#else
   pCoderData=(PVOID)GlobalAllocPtr(GHND, sizeof(C16008DATA));
#endif
   if (pCoderData==NULL)
      return (HANDLE)0;

   InitializeCoderInstanceData(pCoderData, dwMaxBitRate);

   #ifdef __TEST
   codage=(FILE*)fopen("codage.dat","wb");
   test=(FILE*)fopen("codes_c2.dat","wt");
   #endif

   return((HANDLE)pCoderData);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Encode(
   HANDLE hAccess,
   LPBYTE lpSrcBuf,
   LPWORD lpSrcBufSize,
   LPBYTE lpDstBuf,
   LPWORD lpDstBufSize)
{
    short i,iNBSPF,iMOD_TH1,iMOD_TH2,iMOD_TH3,k,flag=0;
    short iNBSB_SP_MAX1,iNBSB_SP_MAX2,iNBSB_SP_MAX3,iNBSB_SP_MAX4;
    short  *input;
    short *in;
    unsigned short  *ptr2,*ptr4;
    unsigned char  *ptr1,*ptr3;
    long nbb_ave; // Average bit rate on the previous NBFAC frames of speech

    short codesizes[24];
    long codes[24];
    short numcodes,temp;
    short ivect8[160];

	PVOID pCoderData;

    if ((!hAccess) || (!lpSrcBuf) || (!lpDstBuf))
      return LH_EBADARG;

    // First check that the handle provided as argument is correct
    /*for (i=0;i<MAXCODINGHANDLES;i++)
       if ((CodingHandles[i]==1)&&(hAccess==(HANDLE)&CoderData[i])) {flag=1; break;}
    if (flag==0) return LH_BADHANDLE;*/

    pCoderData=(PVOID)hAccess;

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (((PC4808DATA)pCoderData)->dwMaxBitRate != 4800) && 
#endif
	  (((PC16008DATA)pCoderData)->dwMaxBitRate != 8000) && 
	  (((PC16008DATA)pCoderData)->dwMaxBitRate != 12000) &&
	  (((PC16008DATA)pCoderData)->dwMaxBitRate != 16000))
    return (LH_ERRCODE)LH_EBADARG;

#ifdef CELP4800
  if ((((PC4808DATA)pCoderData)->dwMaxBitRate == 4800))
    {
     // then check the buffer sizes passed as argument.
     if ((*lpSrcBufSize<2*NECHDECAL)||(*lpDstBufSize<12))
        return (LH_ERRCODE)LH_EBADARG;

     *lpSrcBufSize=2*NECHDECAL;
     *lpDstBufSize=12;

     input = (short  *)lpSrcBuf;
     in=((PC4808DATA)pCoderData)->SIG+SOUDECAL1+RECS2;
     for (i=0;i<DECAL;i++) *in++=*input++;

     filt_in(((PC4808DATA)pCoderData)->mem2,((PC4808DATA)pCoderData)->SIG+SOUDECAL1+RECS2,((PC4808DATA)pCoderData)->SIG+SOUDECAL1+RECS2,DECAL);

     CALPITCH(((PC4808DATA)pCoderData));

     COEFF_A(((PC4808DATA)pCoderData));

     for (i=0;i<3;i++)
     {
        if (i==0) ((PC4808DATA)pCoderData)->SOULONG=SOUDECAL1;
        else ((PC4808DATA)pCoderData)->SOULONG=SOUDECAL;
        ((PC4808DATA)pCoderData)->depl=i*4;
        RESIDU(((PC4808DATA)pCoderData),i);
        PERIODE(((PC4808DATA)pCoderData),i);
        CHERCHE(((PC4808DATA)pCoderData));
        dsynthesis(((PC4808DATA)pCoderData)->DMSY,((PC4808DATA)pCoderData)->A1,((PC4808DATA)pCoderData)->E,((PC4808DATA)pCoderData)->E_PE,((PC4808DATA)pCoderData)->SOULONG,NETAGES);
        for (k=0;k<=11;k++) ((PC4808DATA)pCoderData)->MINV[12-k] = ((PC4808DATA)pCoderData)->E_PE[((PC4808DATA)pCoderData)->SOULONG-12+k];
        ((PC4808DATA)pCoderData)->MINV[0]=(short)(((PC4808DATA)pCoderData)->DMSY[0] >> 16);
     }
     FRAME(((PC4808DATA)pCoderData));
     short_to_short(((PC4808DATA)pCoderData)->SIG+SOUDECAL1-RECS2,((PC4808DATA)pCoderData)->M_PIT,160);
     short_to_short(((PC4808DATA)pCoderData)->SIG+NECHDECAL,((PC4808DATA)pCoderData)->SIG,SOUDECAL1+RECS2);

     ptr4 = (unsigned short  *)&((PC4808DATA)pCoderData)->output_frame;
     ptr2 = (unsigned short  *)lpDstBuf;

     for (i =0;i<6;i++) ptr2[i] = ptr4[i];
    }
  else
#endif
    {
    input = (short  *)lpSrcBuf;

    ((PC16008DATA)pCoderData)->nbbit_cf=0;

    // then check the buffer sizes passed as argument.
    switch (((PC16008DATA)pCoderData)->dwMaxBitRate)
      {
      case 8000:
        if ((*lpSrcBufSize<2*160)||(*lpDstBufSize<MAX_OUTPUT_BYTES_8000_12000))
          return (LH_ERRCODE)LH_EBADARG;
        *lpSrcBufSize=2*160;
        for (i=0;i<160;i++) ((PC16008DATA)pCoderData)->DATA_I[i]=(*input++)>>1;	// TEST >>2
#ifdef _X86_
        PassLow8(((PC16008DATA)pCoderData)->DATA_I,ivect8,((PC16008DATA)pCoderData)->memBP,160);
        iConvert8To64(ivect8,((PC16008DATA)pCoderData)->DATA_I,160,((PC16008DATA)pCoderData)->imem1);
#else
        SampleRate8000To6400(((PC16008DATA)pCoderData)->DATA_I,
                             ((PC16008DATA)pCoderData)->DATA_I,
                             160,
                             ((PC16008DATA)pCoderData)->imem1,
                             &((PC16008DATA)pCoderData)->uiDelayPosition,
                             &((PC16008DATA)pCoderData)->iInputStreamTime,
                             &((PC16008DATA)pCoderData)->iOutputStreamTime );
#endif

        break;
      case 12000:
        if ((*lpSrcBufSize<2*128)||(*lpDstBufSize<MAX_OUTPUT_BYTES_8000_12000))
          return (LH_ERRCODE)LH_EBADARG;
        *lpSrcBufSize=2*128;
        for (i=0;i<128;i++) ((PC16008DATA)pCoderData)->DATA_I[i]=(*input++)>>1;	// TEST >>2
        break;
      case 16000:
        if ((*lpSrcBufSize<2*128)||(*lpDstBufSize<MAX_OUTPUT_BYTES_16000))
          return (LH_ERRCODE)LH_EBADARG;
        *lpSrcBufSize=2*128;
        for (i=0;i<128;i++) ((PC16008DATA)pCoderData)->DATA_I[i]=(*input++)>>1;	// TEST >>2
        break;
      }

    code_res_I(((PC16008DATA)pCoderData),((PC16008DATA)pCoderData)->DATA_I,coef_I,((PC16008DATA)pCoderData)->QMF_MEM_ANAL_I,((PC16008DATA)pCoderData)->codes_max,
    		((PC16008DATA)pCoderData)->codes_sb,((PC16008DATA)pCoderData)->indic_sp);

     //*#ifdef __VARIABLE__
     for (i=NBFAC-1;i>0;i--)
       {
       ((PC16008DATA)pCoderData)->nbbit[i]=((PC16008DATA)pCoderData)->nbbit[i-1]; // on re-adapte les tranches precedentes
       }
     ((PC16008DATA)pCoderData)->nbbit[0]=((PC16008DATA)pCoderData)->nbbit_cf;     // valeur pour la tranche actuelle

     nbb_ave=0L;
     for (i=0;i<NBFAC;i++) nbb_ave+=(long)((PC16008DATA)pCoderData)->nbbit[i];
    if (((PC16008DATA)pCoderData)->dwMaxBitRate == 8000)
      {
      iNBSPF = NBSPF_4800_8000;
      iMOD_TH1 = MOD_TH1_8000;
      iMOD_TH2 = MOD_TH2_8000;
      iMOD_TH3 = MOD_TH3_8000;
      iNBSB_SP_MAX1 = NBSB_SP_MAX1_8000_12000;
      iNBSB_SP_MAX2 = NBSB_SP_MAX2_8000_12000;
      iNBSB_SP_MAX3 = NBSB_SP_MAX3_8000_12000;
      iNBSB_SP_MAX4 = NBSB_SP_MAX4_8000_12000;
      }
    else
      {
      iNBSPF = NBSPF_12000_16000;
      iMOD_TH1 = MOD_TH1_12000_16000;
      if (((PC16008DATA)pCoderData)->dwMaxBitRate == 12000)
        {
        iMOD_TH2 = MOD_TH2_12000;
        iMOD_TH3 = MOD_TH3_12000;
        iNBSB_SP_MAX1 = NBSB_SP_MAX1_8000_12000;
        iNBSB_SP_MAX2 = NBSB_SP_MAX2_8000_12000;
        iNBSB_SP_MAX3 = NBSB_SP_MAX3_8000_12000;
        iNBSB_SP_MAX4 = NBSB_SP_MAX4_8000_12000;
        }
      else
        {
        iMOD_TH2 = MOD_TH2_16000;
        iMOD_TH3 = MOD_TH3_16000;
        iNBSB_SP_MAX1 = NBSB_SP_MAX1_16000;
        iNBSB_SP_MAX2 = NBSB_SP_MAX2_16000;
        iNBSB_SP_MAX3 = NBSB_SP_MAX3_16000;
        iNBSB_SP_MAX4 = NBSB_SP_MAX4_16000;
        }
      }
    nbb_ave=(short)((nbb_ave*F_ECH)/(NBFAC*iNBSPF));
// On retablit les seuils en fonction de la moyenne calculee
     if (nbb_ave<=iMOD_TH1)
       {
       ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL1; // valeur par defaut si le debit n'augmente pas trop
       ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX1; // cad on ne traite pas les sb < 5% du max[i]
       ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX1; // nbre max de sb pouvant etre du signal
       }
     else
       {
       if (nbb_ave<=iMOD_TH2) // on a depasse le 1er seuils mais pas le 2eme
	 {
	 ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL2; // on rejette plus de tranches
	 ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX2; // cad on ne traite pas les sb < 7% du max[i]
	 ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX2; // nbre max de sb pouvant etre du signal
	 }
       else
	 {
	 if (nbb_ave<=iMOD_TH3) // on a depasse le 1er seuils mais pas le 2eme
	   {
	   ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL3; // on rejette un max
	   ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX3; // cad on ne traite pas les sb < 5% du max[i]
	   ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX3; // nbre max de sb pouvant etre du signal
	   }
	 else                 // on a depasse le troisieme seuil; il faut descendre!
	   {
	   ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL4; // meme seuil de rejet
	   ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX4; // cad on ne traite pas les sb <10% du max[i]
	   ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX4; // nbre max de sb pouvant etre du signal
	   }
	 }
       }/**/
    ((PC16008DATA)pCoderData)->stream[0]=0;
    for (i=0;i<8;i++)
       ((PC16008DATA)pCoderData)->stream[0]|=(((PC16008DATA)pCoderData)->indic_sp[i]&0x01)<<i;

    numcodes=0;
    //temp=bytes[((PC16008DATA)pCoderData)->nbsb_sp];
#if 0
    temp=(short)((float)((PC16008DATA)pCoderData)->nbbit_cf/8.0+0.99);
#else
    // We want to go away of libcmt, msvcrt... and
    // floating point is not really essential here...
    if (((PC16008DATA)pCoderData)->nbbit_cf)
      temp=(short)((((PC16008DATA)pCoderData)->nbbit_cf-1)/8+1);
    else
      temp=0;
#endif

    for (i=0;i<24;i++) codesizes[i]=0;
    for (i=0;i<((PC16008DATA)pCoderData)->nbsb_sp;i++)
    {
       codes[i]=(long)((PC16008DATA)pCoderData)->codes_max[i];
       codes[((PC16008DATA)pCoderData)->nbsb_sp+2*i]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i];
       codes[((PC16008DATA)pCoderData)->nbsb_sp+2*i+1]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i+1];
       codesizes[i]=5;
       codesizes[((PC16008DATA)pCoderData)->nbsb_sp+2*i]=((PC16008DATA)pCoderData)->bits[i]/2;
       codesizes[((PC16008DATA)pCoderData)->nbsb_sp+2*i+1]=((PC16008DATA)pCoderData)->bits[i]/2;
       numcodes+=3;
    }

  if (((PC16008DATA)pCoderData)->dwMaxBitRate == 16000)
    {
    for (i=((PC16008DATA)pCoderData)->nbsb_sp;i<8;i++)
    {
       codes[2*((PC16008DATA)pCoderData)->nbsb_sp+i]=(long)((PC16008DATA)pCoderData)->codes_max[i];
       codes[8+2*i]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i];
       codes[8+2*i+1]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i+1];
       codesizes[2*((PC16008DATA)pCoderData)->nbsb_sp+i]=5;
       codesizes[8+2*i]=SILENCE_CODING_BIT_16000/2;
       codesizes[8+2*i+1]=SILENCE_CODING_BIT_16000/2;
       numcodes+=3;
    }
    Multiplexing(((PC16008DATA)pCoderData)->stream+1,codes,codesizes,numcodes,(short)(temp-1));
    }
  else
    if (((PC16008DATA)pCoderData)->nbsb_sp)
       Multiplexing(((PC16008DATA)pCoderData)->stream+1,codes,codesizes,numcodes,(short)(temp-1));

    *lpDstBufSize=temp;


    ptr3 = (unsigned char  *)&((PC16008DATA)pCoderData)->stream;
    ptr1 = (unsigned char  *)lpDstBuf;
    for (i =0;i<*lpDstBufSize;i++) ptr1[i] = ptr3[i];
    }
    return (LH_SUCCESS);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Coder(HANDLE hAccess)
{
   PVOID pCoderData;
   /*short i,flag=0;

   // Check if right handle
   for (i=0;i<MAXCODINGHANDLES;i++)
      if ((CodingHandles[i]==1)&&(hAccess==(HANDLE)&CoderData[i])) {flag=1; break;}
   if (flag==0) return LH_BADHANDLE;
   // Free handle
   CodingHandles[i]=0;*/

  if (!hAccess)
    return LH_EBADARG;

   pCoderData=(PVOID)hAccess;

   GlobalFreePtr(pCoderData);

   #ifdef __TEST
   fclose(codage);
   fclose(test);
   #endif

   return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\fv_h8.h ===
/*
 *   Project:		LHCODING.DLL  (L&H Speech Coding SDK)  
 *   Workfile:		fv_m8.h     
 *   Author:		Alfred Wiesen 
 *   Created:		13 June 1995    
 *   Last update:	13 June 1995
 *   DLL Version:	1   
 *   Revision:		Version 1.0 of FASTVOX_XXX splitted versions
 *   Comment:   
 *
 *	(C) Copyright 1993-94 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company cnfidential.
 */

# ifndef __FV_H8_H  /* avoid multiple include */

# define __FV_H8_H

/*
 *  Type definition for the L&H functions returned values
 */

typedef DWORD LH_ERRCODE;

typedef struct CodecInfo_tag {
   WORD wPCMBufferSize;
   WORD wCodedBufferSize;
   WORD wBitsPerSamplePCM;
   DWORD dwSampleRate;
   WORD wFormatSubTag;
   char wFormatSubTagName[40];
   DWORD dwDLLVersion;
} CODECINFO, near *PCODECINFO, far *LPCODECINFO;


/*
 *  Possible values for the LH_ERRCODE type
 */

# define LH_SUCCESS 0    /* everything is OK */
# define LH_EFAILURE -1  /* something went wrong */
# define LH_EBADARG -2   /* one of the given argument is incorrect */
# define LH_BADHANDLE -3 /* bad handle passed to function */

/*
 *  Some real types are defined here
 */

# ifdef __cplusplus
	# define LH_PREFIX extern "C"
# else
	# define LH_PREFIX
# endif

# define LH_SUFFIX FAR PASCAL

/*
 *  The function prototypes for 16000 bps, 8000 Hz, Fixed point
 */

LH_PREFIX HANDLE LH_SUFFIX
	LHSB_FIXv0808K_Open_Coder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Encode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Close_Coder( HANDLE hAccess);

LH_PREFIX HANDLE LH_SUFFIX
	LHSB_FIXv0808K_Open_Decoder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Decode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Close_Decoder( HANDLE hAccess);

LH_PREFIX void LH_SUFFIX
	LHSB_FIXv0808K_GetCodecInfo(LPCODECINFO lpCodecInfo);


# endif  /* avoid multiple include */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\data.h ===
/*
 *   Project:		Direct Subband about 13000 bps coder and QUATERDECK 4160 bps decoder (LPC10 based)
 *   Workfile:		data.h
 *   Author:		Georges Zanellato, Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	26 October 1995
 *   DLL Version:	1.00
 *   Revision:
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Constant definitions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
#define Fil_Lenght   8			// QMF filter lenght
#define L_RES       128			// Subband frame lenght
#define N_SB          3			// power(2,N_SB) = Number subband
#define NETAGES      10		// Filter order
#define NECHFEN      220	// Total window length
#define FACTRECO     60		// Overlap length
#define RECS2        30		// Half overlap length
#define NECHDECAL    160	// Input frame size
#define DECAL        160	// Input frame size
#define SOUDECAL1    54 	// First subframe size
#define SOUDECAL     53		// Second and third subframe size
#define LIM_P1       20		// Lowest possible value for PITCH
#define LIM_P2      110		// Highest possible value for PITCH
#define lngEE       148		// Excitation vector length

#include "variable.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Data types definitions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
typedef short VAUTOC [NETAGES+1];
typedef short VEE  [lngEE];
typedef short VSOU  [SOUDECAL1];

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Instance data for coder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
typedef struct C16008Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PC16008DATA or PC4808DATA
    DWORD dwMaxBitRate;
   // Long term
   short zx0_i[2];
   // Long term
   short QMF_MEM_ANAL_I[112];		// Memory of QMF filter during analysis
   short memBP[9];
//   float Zb[5],Za[5];			// long term decimator
//   float mem1[2];
#ifdef _X86_
   short imem1[2];
#else
   int imem1[23];
   unsigned int uiDelayPosition;
   int iInputStreamTime;
   int iOutputStreamTime;
#endif
   long memory[20];

   long nbbit[NBFAC];
   short nbsb_sp;

   short DIV_MAX;     // div. factor for the greatest max of a the sb of a sp frame
   short MAX_LEVEL;   // threshold below which a sb is replaced by white noise
   short NBSB_SP_MAX; // max nbr of sb treated as speech
   short nbbit_cf;    // nber of bits required by the current frame of speech

// PhilF: Since these depend on the bit rate, moved them from global to here...
short quantif[2*NBSB_SP_MAX1_8000_12000]; //={QUANT_LEVELS};
short bits[NBSB_SP_MAX1_8000_12000]; //={CODING_BITS};

short codes_max[8];	// Quantized max. of each subband
long codes_sb[16];	// Two codes for each of the quantified subbands
short indic_sp[8];	// type of subband (0=noise; 1=speech)
short DATA_I[512];                  	// Intermediate vector = input and output of QMF
char stream[MAX_OUTPUT_BYTES_16000];

} C16008DATA, *PC16008DATA;

#ifdef CELP4800
typedef struct C4808Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PC16008DATA or PC4808DATA
    DWORD dwMaxBitRate;
   long DMSY[13];				// Synthesis memory filter
   short   MINV[13];				// Filter memory
   short  SIG[NECHFEN+SOUDECAL],M_PIT[160];	// Computation signal vectors
   VSOU	E,E_PE;					// Excitation vectors
   VEE 	EE;					// Excitation vector
   short mem2[2];					// Input filter memory
   short mem_pit[2];				// Pitch memory
   short LSP0[10];				// LSP memory

short 	SIG_CALP[380];	// RAM
short 	UNVOIS,PITCH,SOULONG;	// RAM
long  	a,b;	// RAM
short 	ialf;
long  	TLSP[24],VMAX[9];	// RAM
long  	veci1[10],veci2[10],veci3[10];	// RAM
long  	ttt[11];				// RAM
short 	SIGPI[2*NECHDECAL+FACTRECO];	// RAM
short 	zz[12];
VAUTOC  A1,A2,A3,Aw,LSP;	// RAM
VSOU	H;			// RAM
short  	GLTP;		// RAM
short 	code[22];		// RAM
short 	output_frame[6];
short 	depl;
short 	*ptr1;		// RAM

} C4808DATA, *PC4808DATA, *LPC4808DATA;
#endif

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Instance data for decoder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
typedef struct D16008Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PD16008DATA or PD4808DATA
    DWORD dwMaxBitRate;
   long memfil[20];
   short QMF_MEM_SYNT_I[112];          // Memory of QMF filter during synthesis
//   float mem2[2];
#ifdef _X86_
   short imem2[2];
#else
   int imem2[56];
   unsigned int uiDelayPosition;
   int iInputStreamTime;
   int iOutputStreamTime;
#endif

   short out_mem[4];
   short out_mem2[20];
   long memory[20];
   short mem1,mem2;

// PhilF: Since these depend on the bit rate, moved them from global to here...
short quantif[2*NBSB_SP_MAX1_8000_12000]; //={QUANT_LEVELS};
short bits[NBSB_SP_MAX1_8000_12000]; //={CODING_BITS}; 
long lRand;

short synth_speech[224];
short d_codes_max[8];	// Quantified max. of each subband
long d_codes_sb[16];	// Two codes for each of the quantified subbands
short d_indic_sp[8];	// type of subband (0=noise; 1=speech)
short d_DATA_I[512];                  	// Intermediate vector = input and output of QMF
char d_stream[MAX_OUTPUT_BYTES_16000];
short d_num_bandes;

} D16008DATA, *PD16008DATA;

#ifdef CELP4800
typedef struct D4808Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PD16008DATA or PD4808DATA
    DWORD dwMaxBitRate;
   long memfil[32]; 	// Synthesis filter memory
   short  MSYNTH[13];	// Filter memory
   VSOU E;		// Excitation vector
   VEE	EE,EEE;		// Excitation vectors
   short LSP0[10];	// LSP memory

short PITCH,SOULONG;	// RAM
long  TLSP[24];		// RAM
VAUTOC  A1,A2,A3,LSP;	// RAM
short  GLTP;
short ss[DECAL];	// RAM
short code[22];		// RAM
short frame[6];		// RAM
short depl;		// RAM

} D4808DATA, *PD4808DATA, *LPD4808DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\decoder.c ===
/*#define __TEST
#ifdef __TEST
#include <stdio.h>
FILE *d_codage;
FILE *d_test;
#endif*/

/*
 *   Project:		Direct Subband 16000 bps coder
 *   Workfile:		sb_encod.c
 *   Author:		Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	4 September 1995
 *   DLL Version:	1.00
 *   Revision:          Single DLL for coder and decoder.
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Included files
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
#include <math.h>
#include <windows.h>
#include <windowsx.h>

//#define USE_CRT_RAND 1

#ifdef USE_CRT_RAND
#include <stdlib.h>	// for rand() function
#endif

#include "fv_x8.h"
#include "data.h"
#include "bib_32.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function prototypes
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
//------------------------------------------------------------------------
void InitializeDecoderInstanceData(PVOID p, DWORD dwMaxBitRate);
void interpolation_I(short low_input[],short coef[],short low_part_mem[],short order);
void bruit_I(PD16008DATA p, short vec[],short max, short deb ,short fin);
#if 0
// PhilF: The following is never called!!!
void dec_0a16_I2(short z1, short z2, short vec[], short maxv, short V1[], short V2[],long *code);
#endif
void dec_sous_bandes(PD16008DATA p,short *out,short *codes_max, long *codes_sb, short *indic_br/*, short *code_max_br*/);
#if 0
// PhilF: The following is not defined anywhere!!!
void decodeframe(short codes_max[],long codes_sb[],short d_indic_sp[],char stream[]);
#endif

#ifdef CELP4800
void demux(PD4808DATA p);
void decode_ai(PD4808DATA p);
void dec_ltp(PD4808DATA p,short no),dec_dic(PD4808DATA p);
void post_synt(PD4808DATA p),post_filt(PD4808DATA p,short no);
#endif

/*void iConvert64To8(short *in, short *out, short N, short *mem);
void iConvert8To64(short *in, short *out, short N, short *mem);
void filt_in(short *mem, short *Vin, short *Vout, short lfen);
//void PassHigh(short *vin,short *vout,short *mem,short nech);
void BandPass(short *,short *,short *,short);*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Global variables for decoder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

/*#define MAXDECODINGHANDLES 10

// Instance data structure
PD16008DATA pDecoderData;
D16008DATA DecoderData[MAXDECODINGHANDLES];
short brol[300];
short DecodingHandles[MAXDECODINGHANDLES];*/

// ROM tables :
//extern long coef_outfil[];
extern short coef_I[];	// QMF filter coefficients
extern short V3_I[];
extern short V4_I[];
extern short V5_I[];
extern short V6_I[];
extern short V7_I[];
extern short V8_I[];
extern short V9_I[];
extern short d_max_level[];  // Quantified maximum sample level
extern long coeffs[];
extern short quantif[];
extern long Mask[];
extern short tabcos[];
extern short LSP_Q[];
extern short TAB_DI[];
extern short GV[];
extern short BV[];
extern long coef_i[];
extern short NBB[],BITDD[];
extern short LSP0ROM[];
//extern short bytes[];
//extern short bits[];

// RAM variables
/*extern char d_stream[];
extern short synth_speech[];
extern short d_DATA_I[];                  // Intermediate vector = input and output of QMF
extern short d_codes_max[];
extern long d_codes_sb[];
extern short d_indic_sp[];
extern short d_num_bandes;
//extern float d_vect6[256], d_vect8[256];*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function implementation
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
void InitializeDecoderInstanceData(PVOID p, DWORD dwMaxBitRate)
// Instance data initializations
{
  short i;

#ifdef CELP4800
  if (dwMaxBitRate == 4800)
    {
    ((PD4808DATA)p)->dwMaxBitRate = dwMaxBitRate;

    for (i=0;i<10;i++)
      ((PD4808DATA)p)->LSP0[i]=LSP0ROM[i];
    }
  else
#endif
    {
    ((PD16008DATA)p)->dwMaxBitRate = dwMaxBitRate;
    ((PD16008DATA)p)->lRand = 1L;

    ((PD16008DATA)p)->quantif[0] = 9;
    ((PD16008DATA)p)->quantif[1] = 9;
    ((PD16008DATA)p)->quantif[4] = 5;
    ((PD16008DATA)p)->quantif[5] = 5;
    ((PD16008DATA)p)->quantif[6] = 5;
    ((PD16008DATA)p)->quantif[7] = 5;
    ((PD16008DATA)p)->quantif[8] = 5;
    ((PD16008DATA)p)->quantif[9] = 5;
    ((PD16008DATA)p)->bits[0] = 52;
    ((PD16008DATA)p)->bits[2] = 38;
    ((PD16008DATA)p)->bits[3] = 38;
    ((PD16008DATA)p)->bits[4] = 38;
    if (dwMaxBitRate == 16000)
      {
      ((PD16008DATA)p)->quantif[2] = 7;
      ((PD16008DATA)p)->quantif[3] = 7;
      ((PD16008DATA)p)->bits[1] = 46;
      }
    else
      {
      ((PD16008DATA)p)->quantif[2] = 9;
      ((PD16008DATA)p)->quantif[3] = 9;
      ((PD16008DATA)p)->quantif[10] = 5;
      ((PD16008DATA)p)->quantif[11] = 5;
      ((PD16008DATA)p)->bits[1] = 52;
      ((PD16008DATA)p)->bits[5] = 38;
      }
    }
   return;
}

//------------------------------------------------------------------------
void interpolation_I(short low_input[],short coef[],short low_part_mem[],short order)
// Purpose : from subbands stored in low_input[], create the corresponding signal
// Remark  : The reconstruct signal is stored at *(input+N_SB*L_RES)
{
   short *output;
   short *high_input;
   short *buffer,*sa_vec;
   short lng,j,i;

   buffer = low_part_mem;
   for (i = 7-N_SB; i<7; i++)
	{
	lng = 1<<i;
	high_input=low_input+lng;
	output=low_input+L_RES;
	sa_vec=output;
	for (j = L_RES >> (i+1); j>0; j--)
		{
		low_part_mem=buffer;

		QMInverse(low_input,high_input,coef,output,low_part_mem,lng);

		output += 2*lng; low_input += lng; high_input += lng;

		if (j&1) high_input += 2*lng;
		else low_input += 2*lng;

		buffer += 2*order;
		}
	low_input=sa_vec;
	}
}

//------------------------------------------------------------------------
void bruit_I(PD16008DATA p, short vec[],short max, short deb ,short fin)
// rand() generates integers from 1 to RAND_MAX (32767)
{
   short i;

   for (i=deb;i<fin;i++)
     {
#ifdef USE_CRT_RAND
     *vec++ =  (short)(((long)max*(long)(rand()-16384))>>15);
#else
    // We provide our own rand() function in order
    // to go away from libcmt, msvcrt...
    p->lRand = p->lRand * 214013L + 2531011L;
     *vec++ =  (short)(((long)max*(long)((long)((p->lRand >> 16) & 0x7fff)-16384))>>15);
#endif
}    }

/*void bruit_I(int vec[],int max, int deb ,int fin)
{
   int i;
   for (i=deb;i<fin;i++) *vec++ = (int)(((long)max*(long)(rand()-16384))>>15);
}*/

//------------------------------------------------------------------------
// PhilF: The following is never called!!!
#if 0
void dec_0a16_I2(short z1, short z2, short vec[], short maxv, short V1[], short V2[],long *code)

// Decodes two long codes to retreive the z level quantified subband

{
//   short vect1[16];
   short i,x;
   long result;
//   long lp1,lp2;

   result=*(code+1);
   for (i=15;i>=8;i--)	// Decodes the 8 last samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }

   result=*(code);
   for (i=7;i>=0;i--)	// Decodes the 8 first samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }
}
#endif

void dec_0a16_I3(short z1, short z2, short vec[], short maxv, long *code)

// Decodes two long codes to retreive the z level quantified subband

{
//   short vect1[16];
   short i,x;
   long result;
   short *V1,*V2;
//   long lp1,lp2;

   switch (z1)
   {
      case 3: V1=V3_I; break;
      case 4: V1=V4_I; break;
      case 5: V1=V5_I; break;
      case 6: V1=V6_I; break;
      case 7: V1=V7_I; break;
      case 8: V1=V8_I; break;
      case 9: V1=V9_I; break;
   }
   switch (z2)
   {
      case 3: V2=V3_I; break;
      case 4: V2=V4_I; break;
      case 5: V2=V5_I; break;
      case 6: V2=V6_I; break;
      case 7: V2=V7_I; break;
      case 8: V2=V8_I; break;
      case 9: V2=V9_I; break;
   }

  result=*(code+1);
  if (z1 && z2)
  {
   for (i=15;i>=8;i--)	// Decodes the 8 last samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }

   result=*(code);
   for (i=7;i>=0;i--)	// Decodes the 8 first samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }
  }
}

//------------------------------------------------------------------------

void dec_sous_bandes(PD16008DATA p,short *out,short *codes_max, long *codes_sb, short *d_indic_sp)

// Decodes the 8 subbands

{
   short max[8]={0,0,0,0,0,0,0,0};
   short max_loc[8]={0,0,0,0,0,0,0,0};
   short order[8]={0,0,0,0,0,0,0,0};
   short maximum,max_num;
   short i,j,nbsb_sp,ord;

  #ifdef MAX_SB_ABSOLU
   short sb_count;
  #endif


   for (i=0;i<8;i++)	// Decodes the maximums
     {
     max_loc[i]=2*d_max_level[codes_max[i]];
     }
   nbsb_sp=0;
   j=0;
   for (i=0;i<8;i++)
     {
     if (d_indic_sp[i]==1)
       {
       max[i]=max_loc[j];
       nbsb_sp++;
       j++;
       }
     }

  if (p->dwMaxBitRate == 16000)
    {
   j=0;

  #ifdef MAX_SB_ABSOLU
   sb_count=nbsb_sp;
   if (sb_count>=MAX_SB_ABSOLU) return;
  #endif

   for (i=0;i<8;i++)
   {
     if (d_indic_sp[i]==0)
     {
       max[i]=max_loc[nbsb_sp+j];
       j++;
      #ifdef MAX_SB_ABSOLU
       sb_count++;
       quant_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,in+i*16,max[i],codes_sb+2*sb_count);
       if (sb_count>=MAX_SB_ABSOLU) break;
      #endif
     }
   }
    }

   ord=8;
   for (i=0;i<8;i++)	// Calculates the order of the subbands
     {                  // 1 is higher energy than 2 than 3,..
     maximum=32767;
     for (j=7;j>=0;j--)
       {
       if ((order[j]==0)&&(max[j]<maximum))
	 {
	 max_num=j; maximum=max[j];
	 }
       }
     order[max_num]=ord;
     ord--;
     }


  if (p->dwMaxBitRate == 16000)
    {
   // On gnre les sous-bandes
   for (i=7;i>=nbsb_sp;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     dec_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,out+j*16,max[j],codes_sb+2*i);
     }
    }
   else
    {
   // On gnre du bruit
   if (nbsb_sp==0) maximum=20; // qd on ne doit generer que du bruit
   else
     {
     maximum=32767;
     for (i=0;i<nbsb_sp;i++) if (max_loc[i]<maximum) maximum=max_loc[i];
     maximum>>=2;   // le 64eme du plus petit max transmis
     }

   //en fait il faudrait diminuer le bruit avec l'ordre

   for (i=0;i<8;i++)              // Replaces the less energetic subbands
     {			          // with white noise
     if (d_indic_sp[i]==0)
       {
       maximum/=order[i];
       bruit_I(p,out+i*16,maximum,0,16);
       }
     }
   }

   for (i=nbsb_sp-1;i>=0;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     dec_0a16_I3(p->quantif[2*i],p->quantif[2*i+1],out+j*16,max[j],codes_sb+2*i);
     }

}

//------------------------------------------------------------------------
short Demultiplexing(
	char *Stream,
	long *Codes,
	short *CodeSizes,
	short NumCodes,
	short StreamSize)
{
   short B,P;	// B=bits  coder, P=bits disponibles
   short i,j;

   #ifdef __CHECK_FORMAT
   long TotalBytes=0;

   for (i=0;i<NumCodes;i++) TotalBytes+=CodeSizes[i];
   if (TotalBytes>StreamSize*8) return 1;
   #endif

   i=0;
   j=0;
   B=CodeSizes[i];	// bits  coder
   P=8;			// 1 octet libre au dpart
   Codes[i]=0;
   while (i<NumCodes)
   {
      if (P>B)
      {
	 Codes[i]|=(Stream[j]>>(P-B))&Mask[B];
	 P-=B;
	 i++;
	 if (i<NumCodes)
	 {
	    B=CodeSizes[i];
	    Codes[i]=0;
	 }
      }
      else if (P<B)
      {
	 Codes[i]|=(Stream[j]&Mask[P])<<(B-P);
	 B-=P;
	 P=8;
	 j++;
      }
      else
      {
	 Codes[i]|=Stream[j]&Mask[P];
	 i++;
	 j++;
	 P=8;
	 if (i<NumCodes)
	 {
	    B=CodeSizes[i];
	    Codes[i]=0;
	 }
      }
   }
   return 0;
}

// ------------------------------------------------------------------------
#ifdef CELP4800
void decode_ai(PD4808DATA p)
{
   short_to_short(p->code,p->LSP,10);
   p->LSP[10]=32767;
   dec_lsp(p->LSP,LSP_Q,NBB,BITDD,TAB_DI);

   short_to_short(p->LSP,p->A3,10);
   teta_to_cos(tabcos,p->A3,10);
   lsp_to_ai(p->A3,p->TLSP,10);

   interpol(p->LSP0,p->LSP,p->A1,NETAGES);
   teta_to_cos(tabcos,p->A1,10);
   lsp_to_ai(p->A1,p->TLSP,10);

   interpol(p->LSP,p->LSP0,p->A2,NETAGES);
   teta_to_cos(tabcos,p->A2,10);
   lsp_to_ai(p->A2,p->TLSP,10);

   short_to_short(p->LSP,p->LSP0,NETAGES);
}

// ------------------------------------------------------------------------
void dec_ltp(PD4808DATA p,short no)
{
   short k;

   switch (no)
   {
   case 0:
      break;
   case 1:
      short_to_short(p->A2,p->A1,11);
      break;
   case 2:
      short_to_short(p->A3,p->A1,11);
      break;
   }


   p->PITCH=p->code[10+p->depl];
   k=p->code[11+p->depl];
   if (k<10) p->GLTP = BV[k+1]; /* les BV sont multiplies par 16384 */
   else p->GLTP = -BV[k-9];

   if (p->PITCH<p->SOULONG)
   {
      short_to_short(p->EE+lngEE-p->PITCH,p->E,p->PITCH);
      short_to_short(p->E,p->E+p->PITCH,(short)(p->SOULONG-p->PITCH));
      mult_fact(p->E,p->E,p->GLTP,p->SOULONG);
   }
   else
   {
      mult_fact(p->EE+lngEE-p->PITCH,p->E,p->GLTP,p->SOULONG);
   }
}

// ------------------------------------------------------------------------
void dec_dic(PD4808DATA p)
{
   short i,esp_opt,j,position,npopt,phas_opt,cod;
   short c[10];
   short Gopt;

   cod=p->code[13+p->depl];
   if (cod<16) Gopt=GV[cod+1];
   else Gopt=-GV[cod-15];

   cod=p->code[12+p->depl];

   if (cod<54) { position=cod; esp_opt=p->PITCH; }
   else
   {
      if (cod<64)
      {
	 position=cod-54;
	 if (p->PITCH<p->SOULONG) esp_opt=p->SOULONG+5;
	 else if (p->PITCH/2<p->SOULONG) esp_opt=p->PITCH/2;
	    else esp_opt=p->PITCH/3;
      }
      else
      {
	 if (cod<128)
	 {
	    npopt=7;
	    phas_opt=3;
	    esp_opt=8;
	    i=cod-64;
	    c[0]=1;
	    decode_dic(c,i,npopt);
	 }
	 else
	 {
	    npopt=8;
	    phas_opt=0;
	    esp_opt=7;
	    i=cod-128;
	    c[0]=1;
	    decode_dic(c,i,npopt);
	 }
      }
   }

   if (cod<64)
   {
      i=0;
      do
      {
	 p->E[position+i] += Gopt;
	 i += esp_opt;
      }
      while ((position+i)<p->SOULONG);
   }
   else
      for (j=0;j<npopt;j++)
	 p->E[esp_opt*j+phas_opt] += c[j]*Gopt;

   short_to_short(p->EE+p->SOULONG,p->EE,(short)(lngEE - p->SOULONG));
   short_to_short(p->E,p->EE+lngEE-p->SOULONG,p->SOULONG);
}

// ------------------------------------------------------------------------
void post_synt(PD4808DATA p)
{
   short GPREF;

   if (abs(p->GLTP)<8192) GPREF = (long)p->GLTP*(long)35/100;
   if (p->GLTP>=8192)  GPREF=2867;
   if (p->GLTP<=-8192) GPREF=-2867;

   if (p->PITCH>=p->SOULONG) mult_f_acc(p->EEE+lngEE-p->PITCH,p->E,GPREF,p->SOULONG);
   else
   {
      mult_f_acc(p->EEE+lngEE-p->PITCH,p->E,GPREF,p->PITCH);
      mult_f_acc(p->E,p->E+p->PITCH,GPREF,(short)(p->SOULONG-p->PITCH));
   }

   short_to_short(p->EEE+p->SOULONG,p->EEE,(short)(lngEE-p->SOULONG));
   short_to_short(p->E,p->EEE+lngEE-p->SOULONG,p->SOULONG);

   synthese(p->MSYNTH,p->A1,p->E,p->E,p->SOULONG,NETAGES);
}

// ------------------------------------------------------------------------
void post_filt(PD4808DATA p,short no)
{
   short i0;

   switch (no)
   {
   case 0: i0=0;
	   break;
   case 1: i0=SOUDECAL1;
	   break;
   case 2: i0=SOUDECAL1+SOUDECAL;
	   break;
   }
   filt_iir(p->memfil,coef_i,p->E,p->ss+i0,p->SOULONG,4);
}

// ------------------------------------------------------------------------
void demux(PD4808DATA p)
// Purpose : deconcatenate the input stream
// Input parameter  :
//          input_stream[]  :  input stream
//  Output parameter :
//          code[]   :  separate parameter code
//
//  Comments: The LTP or Adaptive codebook is also called PITCH.
//
//  Stream format :
//  input_stream[0] = LSP[0] | LSP[1] | LSP[2] | (Binary gain 2)
//  input_stream[1] = LSP[3] | (Binary gain 3) | (Binary codebook 1)
//  input_stream[2] = LSP[4] | LSP[5] | LSP[6] | LSP[7] | LSP[8] | LSP[9]
//  input_stream[3] = (LTP codebook 1) | (LTP gain 1) | (Binary gain 1)
//  input_stream[4] = (LTP codebook 2) | (LTP gain 2) | (Binary codebook 2)
//  input_stream[5] = (LTP codebook 3) | (LTP gain 3) | (Binary codebook 3)
//
//  Bit allocation : Codebook or gain "i" is the codebook for subframe "i".
//  code[0] = LSP(0) : 3bits     code[10] = LTP codebook 1    : 7bits
//  code[1] = LSP(1) : 4bits     code[11] = LTP gain 1        : 4bits
//  code[2] = LSP(2) : 4bits     code[12] = Binary codebook 1 : 8bits
//  code[3] = LSP(3) : 3bits     code[13] = Binary gain 1     : 5bits
//  code[4] = LSP(4) : 4bits     code[14] = LTP codebook 2    : 4bits
//  code[5] = LSP(5) : 3bits     code[15] = LTP gain 2        : 4bits
//  code[6] = LSP(6) : 3bits     code[16] = Binary codebook 2 : 8bits
//  code[7] = LSP(7) : 2bits     code[17] = Binary gain 2     : 5bits
//  code[8] = LSP(8) : 3bits     code[18] = LTP codebook 3    : 4bits
//  code[9] = LSP(9) : 1bits     code[19] = LTP gain 3        : 4bits
//                               code[20] = Binary codebook 3 : 8bits
//                               code[21] = Binary gain 3     : 5bits
//
{
   p->code[0] = (p->frame[0]>>13) & 0x0007;
   p->code[1] = (p->frame[0]>>9) & 0x000f;
   p->code[2] = (p->frame[0]>>5) & 0x000f;
   p->code[17] = p->frame[0] & 0x001f;

   p->code[3] = (p->frame[1]>>13) & 0x0007;
   p->code[21] = (p->frame[1]>>8) & 0x001f;
   p->code[12] = p->frame[1] & 0x00ff;

   p->code[4] = (p->frame[2]>>12) & 0x000f;
   p->code[5] = (p->frame[2]>>9) & 0x0007;
   p->code[6] = (p->frame[2]>>6) & 0x0007;
   p->code[7] = (p->frame[2]>>4) & 0x0003;
   p->code[8] = (p->frame[2]>>1) & 0x0007;
   p->code[9] = p->frame[2] & 0x0001;

   p->code[10] = (p->frame[3]>>9) & 0x007f;
   p->code[11] = (p->frame[3]>>5) & 0x000f;
   p->code[13] = p->frame[3] & 0x001f;

   p->code[14] = (p->frame[4]>>12) & 0x000f;
   p->code[15] = (p->frame[4]>>8) & 0x000f;
   p->code[16] = p->frame[4] & 0x00ff;

   p->code[18] = (p->frame[5]>>12) & 0x000f;
   p->code[19] = (p->frame[5]>>8) & 0x000f;
   p->code[20] = p->frame[5] & 0x00ff;

   p->code[10] += LIM_P1;
   p->code[14] = p->code[14]+p->code[10]-7;
   p->code[18] = p->code[18]+p->code[14]-7;

}
#endif

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// DLL entry points
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Decoder(DWORD dwMaxBitRate)
{
   PVOID pDecoderData;
   /*short i,flag=0;

   // Test if there are free handles
   for (i=0;i<MAXDECODINGHANDLES;i++)
      if (DecodingHandles[i]==0) {DecodingHandles[i]=1; flag=1; break;}
   if (flag==0) return 0;
   pDecoderData=&DecoderData[i];*/

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (dwMaxBitRate != 4800) && 
#endif
	  (dwMaxBitRate != 8000) && 
	  (dwMaxBitRate != 12000) && 
	  (dwMaxBitRate != 16000))
      return (HANDLE)0;

   // pDecoderData=(PVOID)GlobalAllocPtr(GMEM_MOVEABLE, dwMaxBitRate == 4800 ? sizeof(D4808DATA) : sizeof(D16008DATA));
#ifdef CELP4800
   pDecoderData=(PVOID)GlobalAllocPtr(GHND, dwMaxBitRate == 4800 ? sizeof(D4808DATA) : sizeof(D16008DATA));
#else
   pDecoderData=(PVOID)GlobalAllocPtr(GHND, sizeof(D16008DATA));
#endif
   if (pDecoderData==NULL)
      return (HANDLE)0;

   InitializeDecoderInstanceData(pDecoderData, dwMaxBitRate);

   #ifdef __TEST
   d_codage=(FILE*)fopen("codage.dat","rb");
   d_test=(FILE*)fopen("codes_dec.dat","wt");
   #endif

   return((HANDLE)pDecoderData);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Decode(
   HANDLE hAccess,
   LPBYTE lpSrcBuf,
   LPWORD lpSrcBufSize,
   LPBYTE lpDstBuf,
   LPWORD lpDstBufSize)
{
    short i,iOutputSize,flag=0;
    char  *input;
    char  *int_ptr;
    unsigned short  *ptr1;
    unsigned short  *ptr3;
    long interm;

    short codesizes[24];
    long codes[24];
    short numcodes,temp;
    short bits_count;

	PVOID pDecoderData;

    if ((!hAccess) || (!lpSrcBuf) || (!lpDstBuf))
      return LH_EBADARG;

    /*// First check that the handle provided as argument is correct
    for (i=0;i<MAXDECODINGHANDLES;i++)
       if ((DecodingHandles[i]==1)&&(hAccess==(HANDLE)&DecoderData[i])) {flag=1; break;}
    if (flag==0) return LH_BADHANDLE;*/

    pDecoderData=(PVOID)hAccess;

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (((PD4808DATA)pDecoderData)->dwMaxBitRate != 4800) && 
#endif
	  (((PD16008DATA)pDecoderData)->dwMaxBitRate != 8000) && 
	  (((PD16008DATA)pDecoderData)->dwMaxBitRate != 12000) && 
	  (((PD16008DATA)pDecoderData)->dwMaxBitRate != 16000))
    return (LH_ERRCODE)LH_EBADARG;

#ifdef CELP4800
  if ((((PD4808DATA)pDecoderData)->dwMaxBitRate == 4800))
    {
    // then check the buffer sizes passed as argument.
    if ((*lpDstBufSize<2*NECHDECAL)||(*lpSrcBufSize<12))
      return (LH_ERRCODE)LH_EBADARG;
    *lpDstBufSize=2*NECHDECAL;
    *lpSrcBufSize=12;

    ptr1 = (unsigned short *)lpSrcBuf;
    ptr3 = (unsigned short *)&(((PD4808DATA)pDecoderData)->frame);

    for (i=6 ; i>0 ; i--) *ptr3++ = *ptr1++;

    demux(((PD4808DATA)pDecoderData));

    decode_ai(((PD4808DATA)pDecoderData));

    for (i=0;i<3;i++)
	     {
	     if (i==0) ((PD4808DATA)pDecoderData)->SOULONG=SOUDECAL1;
	     else ((PD4808DATA)pDecoderData)->SOULONG=SOUDECAL;
	     ((PD4808DATA)pDecoderData)->depl=4*i;
	     dec_ltp((PD4808DATA)pDecoderData,i);
	     dec_dic((PD4808DATA)pDecoderData);
	     post_synt((PD4808DATA)pDecoderData);
	     post_filt((PD4808DATA)pDecoderData,i);
	     }

    ptr3 = (unsigned short *)&(((PD4808DATA)pDecoderData)->ss);
    ptr1 = (unsigned short *)lpDstBuf;

    for (i =160; i>0;i--) *ptr1++ = *ptr3++;
    }
  else
#endif
    {
    // then check the buffer sizes passed as argument.
    switch (((PD16008DATA)pDecoderData)->dwMaxBitRate)
      {
      case 8000:
        if ((*lpSrcBufSize<1)||(*lpDstBufSize<2*160))
           return (LH_ERRCODE)LH_EBADARG;
        *lpDstBufSize=2*160;
        break;
      case 12000:
      case 16000:
        if ((*lpSrcBufSize<1)||(*lpDstBufSize<2*128))
           return (LH_ERRCODE)LH_EBADARG;
        *lpDstBufSize=2*128;
        break;
      }
    input = (char  *)lpSrcBuf;
    int_ptr=(char  *)(((PD16008DATA)pDecoderData)->d_stream);

    /*for (i=0;i<26;i++)
       *int_ptr++=*input++;*/

    *int_ptr++=*input++;	// read d_stream[0]

    for (i=0;i<8;i++)
       ((PD16008DATA)pDecoderData)->d_indic_sp[i]=(short)((((PD16008DATA)pDecoderData)->d_stream[0]>>i)&0x01);

    ((PD16008DATA)pDecoderData)->d_num_bandes=0;
    for (i=0;i<8;i++)
      if (((PD16008DATA)pDecoderData)->d_indic_sp[i]==1)
	     ((PD16008DATA)pDecoderData)->d_num_bandes++;


    bits_count=8;
    for (i=0;i<((PD16008DATA)pDecoderData)->d_num_bandes;i++)
       bits_count+=5+((PD16008DATA)pDecoderData)->bits[i];

  if (((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000)
    {
    #ifdef MAX_SB_ABSOLU
    for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<MAX_SB_ABSOLU;i++)
    #else
    for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<8;i++)
    #endif
       bits_count+=5+SILENCE_CODING_BIT_16000;
    }         

    //temp=bytes[d_num_bandes]; //9
#if 0
    temp=(short)((float)bits_count/8.0+0.99);
#else
    // We want to go away of libcmt, msvcrt... and
    // floating point is not really essential here...
    if (bits_count)
      temp=(short)((bits_count-1)/8+1);
    else
      temp=0;
#endif

    if (*lpSrcBufSize<temp)
       return (LH_ERRCODE)LH_EBADARG;

    if ((((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000) || ((((PD16008DATA)pDecoderData)->dwMaxBitRate == 8000) && (((PD16008DATA)pDecoderData)->d_num_bandes)) || ((((PD16008DATA)pDecoderData)->dwMaxBitRate == 12000) && (((PD16008DATA)pDecoderData)->d_num_bandes)))
    {
       for (i=0;i<temp-1;i++)		// read 8 last bytes
	  *int_ptr++=*input++;

       numcodes=0;
       for (i=0;i<24;i++) codesizes[i]=0;
       for (i=0;i<((PD16008DATA)pDecoderData)->d_num_bandes;i++)
       {
	  codesizes[i]=5;
	  codesizes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i]=((PD16008DATA)pDecoderData)->bits[i]/2;
	  codesizes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i+1]=((PD16008DATA)pDecoderData)->bits[i]/2;
	  numcodes+=3;
       }
  if (((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000)
    {
       for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<8;i++)
       {
	  codesizes[2*((PD16008DATA)pDecoderData)->d_num_bandes+i]=5;
	  codesizes[8+2*i]=SILENCE_CODING_BIT_16000/2;
	  codesizes[8+2*i+1]=SILENCE_CODING_BIT_16000/2;
	  numcodes+=3;
       }
    }

       if (Demultiplexing(((PD16008DATA)pDecoderData)->d_stream+1,codes,codesizes,numcodes,(short)(temp-1)))
	  return (LH_ERRCODE)LH_BADHANDLE;

       for (i=0;i<((PD16008DATA)pDecoderData)->d_num_bandes;i++)
       {
	  ((PD16008DATA)pDecoderData)->d_codes_max[i]=(short)codes[i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i]=codes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i+1]=codes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i+1];
       }
    if (((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000)
      {
      #ifdef MAX_SB_ABSOLU
       for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<MAX_SB_ABSOLU;i++)
      #else
       for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<8;i++)
      #endif
       {
	  ((PD16008DATA)pDecoderData)->d_codes_max[i]=(short)codes[2*((PD16008DATA)pDecoderData)->d_num_bandes+i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i]=codes[8+2*i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i+1]=codes[8+2*i+1];
       }
       }
    }
    *lpSrcBufSize=temp;

    dec_sous_bandes(((PD16008DATA)pDecoderData),((PD16008DATA)pDecoderData)->d_DATA_I,((PD16008DATA)pDecoderData)->d_codes_max,((PD16008DATA)pDecoderData)->d_codes_sb,((PD16008DATA)pDecoderData)->d_indic_sp);
    interpolation_I(((PD16008DATA)pDecoderData)->d_DATA_I,coef_I,((PD16008DATA)pDecoderData)->QMF_MEM_SYNT_I,Fil_Lenght);

    for (i=0;i<128;i++) ((PD16008DATA)pDecoderData)->d_DATA_I[3*L_RES+i]*=8; //TEST 16; // Because input divided before coding

    switch (((PD16008DATA)pDecoderData)->dwMaxBitRate)
      {
      case 8000:
        iOutputSize = 160;
#ifdef _X86_
        iConvert64To8(((PD16008DATA)pDecoderData)->d_DATA_I+3*L_RES, ((PD16008DATA)pDecoderData)->synth_speech, 128, ((PD16008DATA)pDecoderData)->imem2);
        PassLow8(((PD16008DATA)pDecoderData)->synth_speech, ((PD16008DATA)pDecoderData)->synth_speech,((PD16008DATA)pDecoderData)->out_mem2,160);
#else
        SampleRate6400To8000(((PD16008DATA)pDecoderData)->d_DATA_I+3*L_RES,
                             ((PD16008DATA)pDecoderData)->synth_speech,
                             128,
                             ((PD16008DATA)pDecoderData)->imem2,
                             &((PD16008DATA)pDecoderData)->uiDelayPosition,
                             &((PD16008DATA)pDecoderData)->iInputStreamTime,
                             &((PD16008DATA)pDecoderData)->iOutputStreamTime );
#endif
        break;
      case 12000:
      case 16000:
        iOutputSize = 128;
        for (i=0;i<128;i++)
          ((PD16008DATA)pDecoderData)->synth_speech[i]=((PD16008DATA)pDecoderData)->d_DATA_I[3*L_RES+i];
        break;
      }

    for (i=0;i<iOutputSize;i++)
    {
       interm=((long)((PD16008DATA)pDecoderData)->synth_speech[i] * 2L);//VERS 4 + ( ((long)(rand()-16384))>>8 ) ;
       if (interm>32700L) interm=32700L;
       if (interm<-32700L) interm=-32700L;
       ((PD16008DATA)pDecoderData)->synth_speech[i] = (short)interm ;
    }

    ptr3 = (unsigned short  *)&(((PD16008DATA)pDecoderData)->synth_speech);
    ptr1 = (unsigned short  *)lpDstBuf;

    for (i =0;i<iOutputSize;i++) ptr1[i] = ptr3[i];
    }
    return (LH_SUCCESS);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Decoder(HANDLE hAccess)
{
   PVOID pDecoderData;

   /*short i,flag=0;

   // Check if right handle
   for (i=0;i<MAXDECODINGHANDLES;i++)
      if ((DecodingHandles[i]==1)&&(hAccess==(HANDLE)&DecoderData[i])) {flag=1; break;}
   if (flag==0) return LH_BADHANDLE;
   // Free handle
   DecodingHandles[i]=0;*/

  if (!hAccess)
    return LH_EBADARG;

   pDecoderData=(PVOID)hAccess;

   GlobalFreePtr(pDecoderData);

   #ifdef __TEST
   fclose(d_codage);
   fclose(d_test);
   #endif

   return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\getsize.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include "fv_x8.h"	// for DLL entry points
#include "variable.h"

# define SAMPLING_FREQUENCY F_ECH
# define DLL_MAJOR 1
# define DLL_MINOR 0
# define PCM_BUFFER_SIZE_4800_8000 2*NBSPF_4800_8000
# define PCM_BUFFER_SIZE_12000_16000 2*NBSPF_12000_16000
# define CODED_BUFFER_SIZE_4800 MAX_OUTPUT_BYTES_4800
# define CODED_BUFFER_SIZE_8000_12000 MAX_OUTPUT_BYTES_8000_12000
# define CODED_BUFFER_SIZE_16000 MAX_OUTPUT_BYTES_16000
# define PCM_BITS_PER_SAMPLE 16

# define CODEC_SUB_TAG_4800       800
# define CODEC_SUB_TAG_8000       801
# define CODEC_SUB_TAG_12000      802
# define CODEC_SUB_TAG_16000      803
# define CODEC_SUB_TAG_NAME_4800  "L&H SBCELP Codec 4.8 kbps"
# define CODEC_SUB_TAG_NAME_8000  "L&H SBC var.bitrate, 8 kbps 8 kHz"	// !!! lenght<40
# define CODEC_SUB_TAG_NAME_12000 "L&H SBC var.bitrate, 12 kbps 8 kHz"	// !!! lenght<40
# define CODEC_SUB_TAG_NAME_16000 "L&H SBC var.bitrate, 16 kbps 8 kHz"	// !!! lenght<40

# define MakeVersion(a,b) ((DWORD)a<<16)|(DWORD)b

# define LONG_CODEC_SUB_TAG_NAME_4800   "L&H SBCELP Codec, 4.8 kbps 8 kHz"
# define LONG_CODEC_SUB_TAG_NAME_8000   "L&H SBC var.bitrate, 8 kbps 8 kHz"
# define LONG_CODEC_SUB_TAG_NAME_12000  "L&H SBC var.bitrate, 12 kbps 8 kHz"
# define LONG_CODEC_SUB_TAG_NAME_16000  "L&H SBC var.bitrate, 16 kbps 8 kHz"

# define IS_VAR_BIT_RATE_4800 	0
# define IS_VAR_BIT_RATE_8000_12000_16000 	1
# define MIN_CODED_BUFFER_SIZE_4800 	12
# define MIN_CODED_BUFFER_SIZE_8000_12000_16000 	1
# define MEAN_BIT_RATE_4800 		4800
# define MEAN_BIT_RATE_8000 		8000
# define MEAN_BIT_RATE_12000 		12000
# define MEAN_BIT_RATE_16000 		16000
# define IS_RT_CODING_4800 		FALSE
# define IS_RT_CODING_8000_12000_16000 		TRUE
# define IS_RT_DECODING 	TRUE
# define IS_FLOATING_POINT	FALSE
# define INPUT_PCM_ONLY 	0x0001
# define EXTRA_CODEC_INFO_SIZE 0

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_GetCodecInfo(LPCODECINFO CodecInfo, DWORD dwMaxBitRate)
// Returns the input and output buffer sizes.
{

  if ((!CodecInfo) || ((dwMaxBitRate != 4800) && (dwMaxBitRate != 8000) && (dwMaxBitRate != 12000) && (dwMaxBitRate != 16000)))
    return LH_EBADARG;

  CodecInfo->wBitsPerSamplePCM=PCM_BITS_PER_SAMPLE;
  CodecInfo->dwSampleRate=SAMPLING_FREQUENCY;
  CodecInfo->dwDLLVersion=MakeVersion(DLL_MAJOR,DLL_MINOR);

  switch (dwMaxBitRate)
    {
    case 4800:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_4800_8000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_4800;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_4800;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_4800);
      break;
    case 8000:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_4800_8000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_8000;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_8000);
      break;
    case 12000:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_12000_16000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_12000;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_12000);
      break;
    case 16000:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_12000_16000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_16000;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_16000;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_16000);
      break;
    }

	return LH_SUCCESS;
}

// PhilF: We don't call this guy from the wrapper, so no need to implement it
#if 0
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_GetCodecInfoEx(LPCODECINFOEX CodecInfo,DWORD cbSize, DWORD dwMaxBitRate)
{

  if ((!CodecInfo) || (cbSize!=(DWORD)sizeof(CODECINFOEX)) || ((dwMaxBitRate != 8000) && (dwMaxBitRate != 12000) && (dwMaxBitRate != 16000)))
    return LH_EBADARG;

  if (cbSize==(DWORD)sizeof(CODECINFOEX))
    {
    // Information on implemented codec
    switch (dwMaxBitRate)
      {
      case 8000:
        CodecInfo->wInputBufferSize=PCM_BUFFER_SIZE_8000;
        CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
        CodecInfo->wFormatSubTag=CODEC_SUB_TAG_8000;
        strcpy(CodecInfo->szFormatSubTagName,LONG_CODEC_SUB_TAG_NAME_8000);
        CodecInfo->nAvgBytesPerSec=MEAN_BIT_RATE_8000/8;
        break;
      case 12000:
        CodecInfo->wInputBufferSize=PCM_BUFFER_SIZE_12000_16000;
        CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
        CodecInfo->wFormatSubTag=CODEC_SUB_TAG_12000;
        strcpy(CodecInfo->szFormatSubTagName,LONG_CODEC_SUB_TAG_NAME_12000);
        CodecInfo->nAvgBytesPerSec=MEAN_BIT_RATE_12000/8;
        break;
      case 16000:
        CodecInfo->wInputBufferSize=PCM_BUFFER_SIZE_12000_16000;
        CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_16000;
        CodecInfo->wFormatSubTag=CODEC_SUB_TAG_16000;
        strcpy(CodecInfo->szFormatSubTagName,LONG_CODEC_SUB_TAG_NAME_16000);
        CodecInfo->nAvgBytesPerSec=MEAN_BIT_RATE_16000/8;
        break;
      }
    CodecInfo->bIsVariableBitRate=IS_VAR_BIT_RATE;
    CodecInfo->bIsRealTimeEncoding=IS_RT_CODING;
    CodecInfo->bIsRealTimeDecoding=IS_RT_DECODING;
    CodecInfo->bIsFloatingPoint=IS_FLOATING_POINT;
    // Information on supported input format
    CodecInfo->wInputDataFormat=INPUT_PCM_ONLY;
    CodecInfo->dwInputSampleRate=SAMPLING_FREQUENCY;
    CodecInfo->wInputBitsPerSample=PCM_BITS_PER_SAMPLE;
    // Information on buffer sizes
    CodecInfo->wMinimumCodedBufferSize=MIN_CODED_BUFFER_SIZE;
    CodecInfo->dwDLLVersion=MakeVersion(DLL_MAJOR,DLL_MINOR);
    CodecInfo->cbSize=EXTRA_CODEC_INFO_SIZE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\fv_m8.h ===
/*
 *   Project:		LHCODING.DLL  (L&H Speech Coding SDK)  
 *   Workfile:		fv_m8.h     
 *   Author:		Alfred Wiesen 
 *   Created:		13 June 1995    
 *   Last update:	14 February 1996
 *   DLL Version:	1   
 *   Revision:		
 *   Comment:   
 *
 *	(C) Copyright 1993-94 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company cnfidential.
 */

# ifndef __FV_M8_H  /* avoid multiple include */ 

# define __FV_M8_H

/*
 *  Type definition for the L&H functions returned values
 */

typedef DWORD LH_ERRCODE;

typedef struct CodecInfo_tag {
   WORD wPCMBufferSize;
   WORD wCodedBufferSize;
   WORD wBitsPerSamplePCM;
   DWORD dwSampleRate;
   WORD wFormatSubTag;
   char wFormatSubTagName[40];
   DWORD dwDLLVersion;
} CODECINFO, near *PCODECINFO, far *LPCODECINFO;

typedef struct CodecInfoEx_tag {
   WORD		wFormatSubTag;
   char		szFormatSubTagName[80];
   BOOL 	bIsVariableBitRate;
   BOOL 	bIsRealTimeEncoding;
   BOOL 	bIsRealTimeDecoding;
   WORD		wInputDataFormat;
   DWORD 	dwInputSampleRate;
   WORD 	wInputBitsPerSample;
   DWORD 	nAvgBytesPerSec;
   WORD 	wInputBufferSize;
   WORD 	wCodedBufferSize;
   WORD 	wMinimumCodedBufferSize;
   DWORD 	dwDLLVersion;
} CODECINFOEX, near *PCODECINFOEX, far *LPCODECINFOEX;


/*
 *  Possible values for the LH_ERRCODE type
 */

# define LH_SUCCESS (0)    /* everything is OK */
# define LH_EFAILURE (-1)  /* something went wrong */
# define LH_EBADARG (-2)   /* one of the given argument is incorrect */
# define LH_BADHANDLE (-3) /* bad handle passed to function */

/*
 *  Some real types are defined here
 */

# ifdef __cplusplus
	# define LH_PREFIX extern "C"
# else
	# define LH_PREFIX
# endif

# define LH_SUFFIX FAR PASCAL

/*
 *  The function prototypes for 4800 bps, 8000 Hz, Fixed point
 */

LH_PREFIX HANDLE LH_SUFFIX
	LHCELP_FIX488K_Open_Coder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Encode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Close_Coder( HANDLE hAccess);

LH_PREFIX HANDLE LH_SUFFIX
	LHCELP_FIX488K_Open_Decoder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Decode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Close_Decoder( HANDLE hAccess);

LH_PREFIX void LH_SUFFIX
	LHCELP_FIX488K_GetCodecInfo(LPCODECINFO lpCodecInfo);

LH_PREFIX void LH_SUFFIX
	LHCELP_FIX488K_GetCodecInfoEx(LPCODECINFOEX lpCodecInfoEx,DWORD cbSize);

# endif  /* avoid multiple include */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\fv_x8.h ===
/*
 *   Project:		LHCODING.DLL  (L&H Speech Coding SDK)  
 *   Workfile:		fv_m8.h + fv_h8.h + private     
 *   Author:		Alfred Wiesen
 *   Created:		13 June 1995    
 *   Last update:	14 February 1996
 *   DLL Version:	1   
 *   Revision:		
 *   Comment:   
 *
 *	(C) Copyright 1993-94 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */

# ifndef __FV_X8_H  /* avoid multiple include */ 

# define __FV_X8_H


#pragma pack(push,8)

/*
 *  Type definition for the L&H functions returned values
 */

typedef long LH_ERRCODE;

typedef struct CodecInfo_tag {
   WORD wPCMBufferSize;
   WORD wCodedBufferSize;
   WORD wBitsPerSamplePCM;
   DWORD dwSampleRate;
   WORD wFormatSubTag;
   char wFormatSubTagName[40];
   DWORD dwDLLVersion;
} CODECINFO, near *PCODECINFO, far *LPCODECINFO;

/*
 *  Possible values for the LH_ERRCODE type
 */

# define LH_SUCCESS (0)    /* everything is OK */
# define LH_EFAILURE (-1)  /* something went wrong */
# define LH_EBADARG (-2)   /* one of the given argument is incorrect */
# define LH_BADHANDLE (-3) /* bad handle passed to function */

/*
 *  Some real types are defined here
 */

# ifdef __cplusplus
	# define LH_PREFIX extern "C"
# else
	# define LH_PREFIX
# endif

#if 0
# define LH_SUFFIX FAR PASCAL
#else
# define LH_SUFFIX
#endif

/*
 *  The function prototypes for 4800 bps, 8000 bps, 12000 bps, 16000 bps, 8000 Hz, Fixed point
 */

LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Coder(DWORD dwMaxBitRate);

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Encode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Coder(HANDLE hAccess);

LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Decoder(DWORD dwMaxBitRate);

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Decode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Decoder(HANDLE hAccess);

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_GetCodecInfo(LPCODECINFO lpCodecInfo, DWORD dwMaxBitRate);

#pragma pack(pop)

# endif  /* avoid multiple include */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32 - the only initialization
//      required is to set ghinst, which is done in the DRV_LOAD message
//      of DriverProc (in codec.c).
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "msacmdrv.h"


BOOL APIENTRY DllEntryPoint ( HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpReserved )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LHACM.RC
//
#define IDS_CODEC_SHORTNAME             1
#define IDS_CODEC_LONGNAME              2
#define IDS_CODEC_COPYRIGHT             3
#define IDS_CODEC_LICENSING             4
#define IDS_CODEC_FEATURES              5
#define IDS_CODEC_NAME_CELP             6
#define IDS_CODEC_NAME_SB8              7
#define IDS_CODEC_NAME_SB12             8
#define IDS_CODEC_NAME_SB16             9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         103
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\lhacm.h ===
//==========================================================================
//
//  lhacm.h
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================


#ifndef _LHACM_H_
#define _LHACM_H_

#define _T(s)       __TEXT (s)
#define TRACE_FUN

#ifdef DEBUG
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#ifdef _DEBUG
    #include <assert.h>
    #ifdef TRACE_FUN
    #define FUNCTION_ENTRY(s)   \
                static TCHAR _szFunName_[] = _T ("LH::") _T (s); \
                MyDbgPrintf (_T ("%s\r\n"), (LPTSTR) _szFunName_);
    #else
    #define FUNCTION_ENTRY(s)   \
                static TCHAR _szFunName_[] = _T (s);
    #endif
    #define SZFN        ((LPTSTR) _szFunName_)
    #define DBGMSG(z,s) ((z) ? (MyDbgPrintf s) : 0);
#else
    #define FUNCTION_ENTRY(s)
    #define SZFN
    #define DBGMSG(z,s)
#endif

#define SIZEOFACMSTR(x)  (sizeof(x)/sizeof(WCHAR))

void FAR CDECL MyDbgPrintf ( LPTSTR lpszFormat, ... );

//==========================================================================;
//
//  Version info
//
//==========================================================================;

// !!! Need to assign a WAVE_FORMAT tag to the codec

#include "temp.h"  // from common\h\temp.h

//Use CELP on _x86_ but not Alpha
#ifndef _ALPHA_
#define CELP4800
#endif

#define VERSION_ACM_DRIVER              MAKE_ACM_VERSION(1, 0, 1)
#define VERSION_MSACM                   MAKE_ACM_VERSION(2, 1, 0)

// !!! Need to assign valid MID and PID

#define MM_ACM_MID_LH                   MM_MICROSOFT
#define MM_ACM_PID_LH                   90

// !!! need to assign IDs

#define MM_LERNOUTHAUSPIE_ACM_CELP      0x70
#define MM_LERNOUTHAUSPIE_ACM_SB8       0x71
#define MM_LERNOUTHAUSPIE_ACM_SB12      0x72
#define MM_LERNOUTHAUSPIE_ACM_SB16      0x73


//==========================================================================;
//
//  Helper routines
//
//==========================================================================;

#define SIZEOF_ARRAY(ar)                (sizeof(ar)/sizeof((ar)[0]))

#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))


// !!! need defines for all four l&h codecs

#define LH_BITSPERSAMPLE                16
#define LH_SAMPLESPERSEC                8000

#define LH_PCM_SAMPLESPERSEC            LH_SAMPLESPERSEC
#define LH_PCM_BITSPERSAMPLE            LH_BITSPERSAMPLE

#ifdef CELP4800
#define LH_CELP_SAMPLESPERSEC           LH_SAMPLESPERSEC
#define LH_CELP_BITSPERSAMPLE           LH_BITSPERSAMPLE
#define LH_CELP_BLOCKALIGNMENT          2
#endif

#define LH_SB8_SAMPLESPERSEC            LH_SAMPLESPERSEC
#define LH_SB8_BITSPERSAMPLE            LH_BITSPERSAMPLE
#define LH_SB8_BLOCKALIGNMENT           2

#define LH_SB12_SAMPLESPERSEC           LH_SAMPLESPERSEC
#define LH_SB12_BITSPERSAMPLE           LH_BITSPERSAMPLE
#define LH_SB12_BLOCKALIGNMENT          2

#define LH_SB16_SAMPLESPERSEC           LH_SAMPLESPERSEC
#define LH_SB16_BITSPERSAMPLE           LH_BITSPERSAMPLE
#define LH_SB16_BLOCKALIGNMENT          2

// !!! l&h probably does not need an extended header...tbd
// lonchanc: we don't need an extended header
//           because we will use separate wave format tags for
//           different coding techniques.

//==========================================================================;
//
//  Supported configurations
//
//==========================================================================;

#define LH_MAX_CHANNELS       1


//==========================================================================;
//
//  Global storage and defs
//
//==========================================================================;

typedef HANDLE (LH_SUFFIX * PFN_OPEN) ( void );
typedef LH_ERRCODE (LH_SUFFIX * PFN_CONVERT) ( HANDLE, LPBYTE, LPWORD, LPBYTE, LPWORD );
typedef LH_ERRCODE (LH_SUFFIX * PFN_CLOSE) ( HANDLE );


typedef struct tagCODECDATA
{
    DWORD       wFormatTag;
    CODECINFO   CodecInfo;
}
    CODECDATA, *PCODECDATA;


typedef struct tagSTREAMINSTANCEDATA
{
    BOOL            fInit;      // TRUE if this stream has been initialized
    BOOL            fCompress;  // TRUE if we're compressing
    HANDLE          hAccess;
    PCODECDATA      pCodecData; // shortcut to instance data's celp, sb8, sb12, or sb16.
    PFN_CONVERT     pfnConvert; // pointer to the encoder/decoder function
    PFN_CLOSE       pfnClose;   // pointer to the close function
    DWORD           dwMaxBitRate;     // bit rate of the codec
    WORD            cbData;     // valid data
    BYTE            Data[2];    // max size is wCodedBufferSize
}
    STREAMINSTANCEDATA, FAR *PSTREAMINSTANCEDATA;


typedef struct tagINSTANCEDATA
{
    WORD        cbStruct;
    BOOL        fInit;
    HINSTANCE   hInst;
    CODECDATA   CELP;
    CODECDATA   SB8;
    CODECDATA   SB12;
    CODECDATA   SB16;
    WORD        wPacketData;// packet by packet audio data (decoding only)
}
    INSTANCEDATA, *PINSTANCEDATA;



//==========================================================================;
//
//  Function prototypes
//
//==========================================================================;

BOOL  pcmIsValidFormat( LPWAVEFORMATEX pwfx );
BOOL  lhacmIsValidFormat( LPWAVEFORMATEX pwfx, PINSTANCEDATA pid );
BOOL CALLBACK DlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL acmdDriverOpen( HDRVR hdrvr, LPACMDRVOPENDESC paod );
LRESULT FAR PASCAL acmdDriverClose( PINSTANCEDATA  pid );
LRESULT FAR PASCAL acmdDriverConfigure( PINSTANCEDATA pid, HWND hwnd, LPDRVCONFIGINFO pdci );
LRESULT FAR PASCAL acmdDriverDetails( PINSTANCEDATA pid, LPACMDRIVERDETAILS padd );
LRESULT FAR PASCAL acmdDriverAbout( PINSTANCEDATA pid, HWND hwnd );
LRESULT FAR PASCAL acmdFormatSuggest( PINSTANCEDATA pid, LPACMDRVFORMATSUGGEST padfs );
LRESULT FAR PASCAL acmdFormatTagDetails( PINSTANCEDATA pid, LPACMFORMATTAGDETAILS padft, DWORD fdwDetails );
LRESULT FAR PASCAL acmdFormatDetails( PINSTANCEDATA pid, LPACMFORMATDETAILS padf, DWORD fdwDetails );
LRESULT FAR PASCAL acmdStreamOpen( PINSTANCEDATA pid, LPACMDRVSTREAMINSTANCE padsi );
LRESULT FAR PASCAL acmdStreamClose( PINSTANCEDATA pid, LPACMDRVSTREAMINSTANCE padsi );
LRESULT FAR PASCAL acmdStreamSize( LPACMDRVSTREAMINSTANCE padsi, LPACMDRVSTREAMSIZE padss );
LRESULT FAR PASCAL acmdStreamConvert( PINSTANCEDATA pid, LPACMDRVSTREAMINSTANCE padsi, LPACMDRVSTREAMHEADER padsh );
LRESULT CALLBACK DriverProc(DWORD_PTR dwId, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2 );


#endif // _LHACM_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\verinfo.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VERINFO.H - header file to define the build version
 *
 **************************************************************************/

#define MMVERSION		1
#define MMREVISION		00
#define MMRELEASE		2

#if defined(DEBUG)
#define VERSIONSTR	"Debug Version 1.00.002\0"
#else
#define VERSIONSTR	"1.00\0"
#endif

#ifdef RC_INVOKED

#define VERSIONCOMPANYNAME	"Microsoft Corp\0"
#define VERSIONPRODUCTNAME	"ACM Wrapper for Lernout and Hauspie codec\0"
#define VERSIONCOPYRIGHT	"Copyright \251 1995-1999 Microsoft Corporation\0"

/*
 *  Version flags 
 */

#if defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG    
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VS_FF_PRIVATEBUILD|VS_FF_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\lhacm.c ===
//==========================================================================
//
//  lhacm.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "mmddk.h"
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include "msacmdrv.h"

#include "fv_x8.h"
#include "lhacm.h"

#define NEW_ANSWER 1

#include "resource.h"

enum
{
#ifdef CELP4800
    IDX_LH_CELP,
#endif
    IDX_LH_SB8,
    IDX_LH_SB12,
    IDX_LH_SB16,
    IDX_PCM,
    NumOfTagIndices
};

const UINT gauFormatTagIndexToTag[NumOfTagIndices] =
{
#ifdef CELP4800
    WAVE_FORMAT_LH_CELP,
#endif
    WAVE_FORMAT_LH_SB8,
    WAVE_FORMAT_LH_SB12,
    WAVE_FORMAT_LH_SB16,
    WAVE_FORMAT_PCM
};

const UINT gauTagNameIds[NumOfTagIndices] =
{
#ifdef CELP4800
    IDS_CODEC_NAME_CELP,
#endif
		IDS_CODEC_NAME_SB8,
    IDS_CODEC_NAME_SB12,
    IDS_CODEC_NAME_SB16,
    0
};

#define ACM_DRIVER_MAX_FORMAT_TAGS      SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS      0

//  arrays of sample rates supported.

//  L&H codecs don't do sample rate conversion.

UINT gauPCMFormatIndexToSampleRate[] =
{
    LH_PCM_SAMPLESPERSEC
};

#ifdef CELP4800
UINT gauLHCELPFormatIndexToSampleRate[] =
{
    LH_CELP_SAMPLESPERSEC
};
#endif

UINT gauLHSB8FormatIndexToSampleRate[] =
{
    LH_SB8_SAMPLESPERSEC
};

UINT gauLHSB12FormatIndexToSampleRate[] =
{
    LH_SB12_SAMPLESPERSEC
};

UINT gauLHSB16FormatIndexToSampleRate[] =
{
    LH_SB16_SAMPLESPERSEC
};

#define ACM_DRIVER_MAX_PCM_SAMPLE_RATES     SIZEOF_ARRAY(gauPCMFormatIndexToSampleRate)
#ifdef CELP4800
#define ACM_DRIVER_MAX_LH_CELP_SAMPLE_RATES SIZEOF_ARRAY(gauLHCELPFormatIndexToSampleRate)
#endif
#define ACM_DRIVER_MAX_LH_SB8_SAMPLE_RATES  SIZEOF_ARRAY(gauLHSB8FormatIndexToSampleRate)
#define ACM_DRIVER_MAX_LH_SB12_SAMPLE_RATES SIZEOF_ARRAY(gauLHSB12FormatIndexToSampleRate)
#define ACM_DRIVER_MAX_LH_SB16_SAMPLE_RATES SIZEOF_ARRAY(gauLHSB16FormatIndexToSampleRate)

#define ACM_DRIVER_MAX_CHANNELS             1

//  array of bits per sample supported.

//  the current version of the LH codecs require 16 bit

UINT gauPCMFormatIndexToBitsPerSample[] =
{
    LH_PCM_BITSPERSAMPLE
};

#ifdef CELP4800
UINT gauLHCELPFormatIndexToBitsPerSample[] =
{
    LH_CELP_BITSPERSAMPLE
};
#endif

UINT gauLHSB8FormatIndexToBitsPerSample[] =
{
    LH_SB8_BITSPERSAMPLE
};

UINT gauLHSB12FormatIndexToBitsPerSample[] =
{
    LH_SB12_BITSPERSAMPLE
};

UINT gauLHSB16FormatIndexToBitsPerSample[] =
{
    LH_SB16_BITSPERSAMPLE
};


#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM     SIZEOF_ARRAY(gauPCMFormatIndexToBitsPerSample)
#ifdef CELP4800
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_CELP SIZEOF_ARRAY(gauLHCELPFormatIndexToBitsPerSample)
#endif
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB8  SIZEOF_ARRAY(gauLHSB8FormatIndexToBitsPerSample)
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB12 SIZEOF_ARRAY(gauLHSB12FormatIndexToBitsPerSample)
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB16 SIZEOF_ARRAY(gauLHSB16FormatIndexToBitsPerSample)

//  number of formats we enumerate per format tag is number of sample rates
//  times number of channels times number of types (bits per sample).

#define ACM_DRIVER_MAX_FORMATS_PCM  \
                (ACM_DRIVER_MAX_PCM_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#ifdef CELP4800
#define ACM_DRIVER_MAX_FORMATS_LH_CELP  \
                (ACM_DRIVER_MAX_LH_CELP_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_CELP)
#endif

#define ACM_DRIVER_MAX_FORMATS_LH_SB8  \
                (ACM_DRIVER_MAX_LH_SB8_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB8)

#define ACM_DRIVER_MAX_FORMATS_LH_SB12  \
                (ACM_DRIVER_MAX_LH_SB12_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB12)

#define ACM_DRIVER_MAX_FORMATS_LH_SB16  \
                (ACM_DRIVER_MAX_LH_SB16_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB16)


//////////////////////////////////////////////////////////
//
// lonchanc: special shorthand for L&H codecs
//

static DWORD _GetAvgBytesPerSec ( PCODECINFO pCodecInfo )
{
    return ((pCodecInfo->dwSampleRate * (DWORD) pCodecInfo->wCodedBufferSize)
            /
            ((DWORD) pCodecInfo->wPCMBufferSize / (DWORD) (pCodecInfo->wBitsPerSamplePCM >> 3)));
}

static PCODECINFO _GetCodecInfoFromFormatIdx ( PINSTANCEDATA pid, int idx )
{
    PCODECINFO pCodecInfo = NULL;

    switch (gauFormatTagIndexToTag[idx])
    {
#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP: pCodecInfo = &(pid->CELP.CodecInfo); break;
#endif
    case WAVE_FORMAT_LH_SB8:  pCodecInfo = &(pid->SB8.CodecInfo);  break;
    case WAVE_FORMAT_LH_SB12: pCodecInfo = &(pid->SB12.CodecInfo); break;
    case WAVE_FORMAT_LH_SB16: pCodecInfo = &(pid->SB16.CodecInfo); break;
    default: break;
    }

    return pCodecInfo;
}

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.
//
//      The 32-bit ACM always expects Unicode strings.  Therefore,
//      when UNICODE is defined, this function is compiled to
//      LoadStringW to load a Unicode string.  When UNICODE is
//      not defined, this function loads an ANSI string, converts
//      it to Unicode, and returns the Unicode string to the
//      codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else
int LoadStringCodec ( HINSTANCE hInst, UINT uID, LPWSTR	lpwstr, int cch )
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR) LocalAlloc (LPTR, cch);
    if (NULL == lpstr)
    {
        return 0;
    }

    iReturn = LoadStringA (hInst, uID, lpstr, cch);
    if (0 == iReturn)
    {
        if (0 != cch)
        {
            lpwstr[0] = '\0';
        }
    }
    else
    {
        MultiByteToWideChar (GetACP(), 0, lpstr, cch, lpwstr, cch);
    }

    LocalFree ((HLOCAL) lpstr);

    return iReturn;
}
#endif  // UNICODE


//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL  pcmIsValidFormat( LPWAVEFORMATEX pwfx )
{
    BOOL fReturn = FALSE;

    FUNCTION_ENTRY ("pcmIsValidFormat")

    if (NULL == pwfx)
    {
        DBGMSG (1, (_T ("%s: pwfx is null\r\n"), SZFN));
        goto MyExit;
    }

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        DBGMSG (1, (_T ("%s: bad wFormatTag=%d\r\n"), SZFN, (UINT) pwfx->wFormatTag));
        goto MyExit;
    }

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
    {
        DBGMSG (1, (_T ("%s: bad nChannels=%d\r\n"), SZFN, (UINT) pwfx->nChannels));
        goto MyExit;
    }

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if (pwfx->wBitsPerSample != LH_PCM_BITSPERSAMPLE)
    {
        DBGMSG (1, (_T ("%s: bad wBitsPerSample=%d\r\n"), SZFN, (UINT) pwfx->wBitsPerSample));
        goto MyExit;
    }

// lonchanc: BUG BUG do we really care about the alignment???
    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT (pwfx) != pwfx->nBlockAlign)
    {
        DBGMSG (1, (_T ("%s: bad nBlockAlign=%d\r\n"), SZFN, (UINT) pwfx->nBlockAlign));
        goto MyExit;
    }

// lonchanc: BUG BUG this only check the integrity of the wave format struct
// but does not ensure that this is a good PCM for us.

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC (pwfx) != pwfx->nAvgBytesPerSec)
    {
        DBGMSG (1, (_T ("%s: bad nAvgBytesPerSec=%d\r\n"), SZFN, (UINT) pwfx->nAvgBytesPerSec));
        goto MyExit;
    }

    fReturn = TRUE;

MyExit:

    DBGMSG (1, (_T ("%s: fReturn=%d\r\n"), SZFN, (UINT) fReturn));

    return fReturn;

} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL lhacmIsValidFormat
//
//  Description:
//		This function ensures that the header is a valid LH header
//
//--------------------------------------------------------------------------;

BOOL lhacmIsValidFormat ( LPWAVEFORMATEX pwfx, PINSTANCEDATA pid )
{
    BOOL fReturn = FALSE;
    PCODECINFO pCodecInfo;
    WORD cbSize;

    FUNCTION_ENTRY ("lhacmIsValidFormat()");

    if (NULL == pwfx)
    {
        DBGMSG (1, (_T ("%s: pwfx is null\r\n"), SZFN));
        goto MyExit;
    }

    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
    {
        DBGMSG (1, (_T ("%s: bad nChannels=%d\r\n"), SZFN, (UINT) pwfx->nChannels));
        goto MyExit;
    }

    switch (pwfx->wFormatTag)
    {
#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
        pCodecInfo = &(pid->CELP.CodecInfo);
        break;
#endif
    case WAVE_FORMAT_LH_SB8:
        pCodecInfo = &(pid->SB8.CodecInfo);
        break;
    case WAVE_FORMAT_LH_SB12:
        pCodecInfo = &(pid->SB12.CodecInfo);
        break;
    case WAVE_FORMAT_LH_SB16:
        pCodecInfo = &(pid->SB16.CodecInfo);
        break;
    default:
        DBGMSG (1, (_T ("%s: bad wFormatTag=%d\r\n"), SZFN, (UINT) pwfx->wFormatTag));
        goto MyExit;
    }
    cbSize = 0;

    if (pwfx->wBitsPerSample != pCodecInfo->wBitsPerSamplePCM)
    {
        DBGMSG (1, (_T ("%s: bad wBitsPerSample=%d\r\n"), SZFN, (UINT) pwfx->wBitsPerSample));
        goto MyExit;
    }

    if (pwfx->nBlockAlign != pCodecInfo->wCodedBufferSize)
    {
        DBGMSG (1, (_T ("%s: bad nBlockAlign=%d\r\n"), SZFN, (UINT) pwfx->nBlockAlign));
        goto MyExit;
    }

    if (pwfx->nSamplesPerSec != pCodecInfo->dwSampleRate)
    {
        DBGMSG (1, (_T ("%s: bad nSamplesPerSec=%d\r\n"), SZFN, (UINT) pwfx->nSamplesPerSec));
        goto MyExit;
    }

	if (pwfx->cbSize != cbSize)
	{
        DBGMSG (1, (_T ("%s: bad cbSize=%d\r\n"), SZFN, (UINT) pwfx->cbSize));
        goto MyExit;
    }

    fReturn = TRUE;

MyExit:

    DBGMSG (1, (_T ("%s: fReturn=%d\r\n"), SZFN, (UINT) fReturn));

    return fReturn;

} // lhacmIsValidFormat()


//==========================================================================;
//
//  The followings are message handlers...
//
//
//==========================================================================;

//==========================================================================;
//
//  on DRV_OPEN
//
//==========================================================================;


LRESULT FAR PASCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PINSTANCEDATA pdata = NULL;

    FUNCTION_ENTRY ("acmdDriverOpen")

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (paod->fccType != ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC)
        {
            return 0;
        }
    }

    // !!! add check for LH DLL version here

    // we're not using the instance data for much right
    // now. when we add a configuration dialog it will
    // be more useful

    pdata= LocalAlloc (LPTR, sizeof (INSTANCEDATA));
    if (pdata == NULL)
    {
        if (paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        return 0;
    }

    pdata->cbStruct = sizeof (INSTANCEDATA);
    pdata->hInst = GetDriverModuleHandle (hdrvr);

#ifdef CELP4800
    pdata->CELP.wFormatTag = WAVE_FORMAT_LH_CELP;
    MSLHSB_GetCodecInfo (&(pdata->CELP.CodecInfo), 4800);

    DBGMSG (1, (_T ("%s: CELP's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->CELP.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->CELP.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->CELP.CodecInfo.dwDLLVersion));
#endif

    pdata->SB8.wFormatTag = WAVE_FORMAT_LH_SB8;
    MSLHSB_GetCodecInfo (&(pdata->SB8.CodecInfo), 8000);

    DBGMSG (1, (_T ("%s: SB8's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->SB8.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->SB8.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->SB8.CodecInfo.dwDLLVersion));

    pdata->SB12.wFormatTag = WAVE_FORMAT_LH_SB12;
    MSLHSB_GetCodecInfo (&(pdata->SB12.CodecInfo), 12000);

    DBGMSG (1, (_T ("%s: SB12's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->SB12.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->SB12.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->SB12.CodecInfo.dwDLLVersion));

    pdata->SB16.wFormatTag = WAVE_FORMAT_LH_SB16;
    MSLHSB_GetCodecInfo (&(pdata->SB16.CodecInfo), 16000);

    DBGMSG (1, (_T ("%s: SB16's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->SB16.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->SB16.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->SB16.CodecInfo.dwDLLVersion));

    pdata->fInit = TRUE;

    // let's update some global data
    gauPCMFormatIndexToSampleRate[0]    = pdata->CELP.CodecInfo.dwSampleRate;
#ifdef CELP4800
    gauLHCELPFormatIndexToSampleRate[0] = pdata->CELP.CodecInfo.dwSampleRate;
#endif
    gauLHSB8FormatIndexToSampleRate[0]  = pdata->SB8.CodecInfo.dwSampleRate;
    gauLHSB12FormatIndexToSampleRate[0] = pdata->SB12.CodecInfo.dwSampleRate;
    gauLHSB16FormatIndexToSampleRate[0] = pdata->SB16.CodecInfo.dwSampleRate;

    gauPCMFormatIndexToBitsPerSample[0]    = pdata->CELP.CodecInfo.wBitsPerSamplePCM;
#ifdef CELP4800
    gauLHCELPFormatIndexToBitsPerSample[0] = pdata->CELP.CodecInfo.wBitsPerSamplePCM;
#endif
    gauLHSB8FormatIndexToBitsPerSample[0]  = pdata->SB8.CodecInfo.wBitsPerSamplePCM;
    gauLHSB12FormatIndexToBitsPerSample[0] = pdata->SB12.CodecInfo.wBitsPerSamplePCM;
    gauLHSB16FormatIndexToBitsPerSample[0] = pdata->SB16.CodecInfo.wBitsPerSamplePCM;

    // report success
    if (paod)
    {
        paod->dwError = MMSYSERR_NOERROR;
    }

    return (LRESULT) pdata;

} // acmdDriverOpen()


//==========================================================================;
//
//  on DRV_CLOSE
//
//==========================================================================;

LRESULT FAR PASCAL acmdDriverClose
(
    PINSTANCEDATA   pid
)
{
    FUNCTION_ENTRY ("acmdDriverClose")

    if (pid)
    {
        LocalFree ((HLOCAL) pid);
    }

    return 1;
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  on DRV_CONFIGURE
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdDriverConfigure
(
    PINSTANCEDATA           pid,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{

    //
    //  first check to see if we are only being queried for hardware
    //  configuration support. if hwnd == (HWND)-1 then we are being
    //  queried and should return zero for 'not supported' and non-zero
    //  for 'supported'.
    //
    if (hwnd == (HWND) -1)
    {
        //
        //  this codec does not support hardware configuration so return
        //  zero...
        //
        return 0;
    }

    //
    //  we are being asked to bring up our hardware configuration dialog.
    //  if this codec can bring up a dialog box, then after the dialog
    //  is dismissed we return non-zero. if we are not able to display a
    //  dialog, then return zero.
    //
    return 0;

} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  on ACMDM_DRIVER_DETAILS
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdDriverDetails
(
    PINSTANCEDATA           pid,
    LPACMDRIVERDETAILS      padd
)
{

    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    FUNCTION_ENTRY ("acmdDriverDetails")

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    ZeroMemory (&add, sizeof (add));
    cbStruct            = min (padd->cbStruct, sizeof (ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;

    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;

    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_ACM_MID_LH;
    add.wPid            = MM_ACM_PID_LH;

    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;

    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.

    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.

    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;

    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.

    if (FIELD_OFFSET (ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.

        add.hicon = NULL;

        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.


        LoadStringCodec (pid->hInst, IDS_CODEC_SHORTNAME,
                            add.szShortName, SIZEOFACMSTR (add.szShortName));
        LoadStringCodec (pid->hInst, IDS_CODEC_LONGNAME,
                            add.szLongName,  SIZEOFACMSTR (add.szLongName));

        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.

        if (FIELD_OFFSET (ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec (pid->hInst, IDS_CODEC_COPYRIGHT,
                                add.szCopyright, SIZEOFACMSTR (add.szCopyright));
            LoadStringCodec (pid->hInst, IDS_CODEC_LICENSING,
                                add.szLicensing, SIZEOFACMSTR (add.szLicensing));
            LoadStringCodec (pid->hInst, IDS_CODEC_FEATURES,
                                add.szFeatures,  SIZEOFACMSTR (add.szFeatures));
        }
    }

    //  now copy the correct number of bytes to the caller's buffer

    CopyMemory (padd, &add, (UINT) add.cbStruct);

    //  success!

    return MMSYSERR_NOERROR;

} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  on ACMDM_DRIVER_ABOUT
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdDriverAbout
(
    PINSTANCEDATA           pid,
    HWND                    hwnd
)
{
    FUNCTION_ENTRY ("acmdDriverAbout")

    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //

    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?

    return MMSYSERR_NOTSUPPORTED;

} // acmdDriverAbout()


//--------------------------------------------------------------------------;
//
//  on ACMDM_FORMAT_SUGGEST
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdFormatSuggest
(
    PINSTANCEDATA           pid,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;

    DWORD   nSamplesPerSec;
    WORD    wBitsPerSample;

    FUNCTION_ENTRY ("acmdFormatSuggest")

    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.

    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return MMSYSERR_NOTSUPPORTED;

    //  get the source and destination formats in more convenient variables

    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;

    switch (pwfxSrc->wFormatTag)
    {
    case WAVE_FORMAT_PCM:
        DBGMSG (1, (_T ("%s: src wFormatTag=WAVE_FORMAT_PCM\r\n"), SZFN));
        //  strictly verify that the source format is acceptable for
        //  this driver
        //
        if (! pcmIsValidFormat (pwfxSrc))
        {
            DBGMSG (1, (_T ("%s: src format not valid\r\n"), SZFN));
            return ACMERR_NOTPOSSIBLE;
        }

        //  if the destination format tag is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver can encode to one of four L&H codecs

        if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
        {
            switch (pwfxDst->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
#endif
            case WAVE_FORMAT_LH_SB8:
            case WAVE_FORMAT_LH_SB12:
            case WAVE_FORMAT_LH_SB16:
                break;
            default:
                DBGMSG (1, (_T ("%s: not supported dest wFormatTag=%d\r\n"),
                SZFN, (UINT) pwfxDst->wFormatTag));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
#ifdef CELP4800
            pwfxDst->wFormatTag = WAVE_FORMAT_LH_CELP;
#else
			pwfxDst->wFormatTag = WAVE_FORMAT_LH_SB12;
#endif
        }

        //  if the destination channel count is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver is not able to change the number of channels

        if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
        {
            if ((pwfxSrc->nChannels != pwfxDst->nChannels) ||
                ((pwfxDst->nChannels < 1) &&
                 (pwfxDst->nChannels > ACM_DRIVER_MAX_CHANNELS)))
            {
                DBGMSG (1, (_T ("%s: ERROR src'nChannels=%ld and dest'nChannels=%ld are different\r\n"),
                SZFN, (DWORD) pwfxSrc->nChannels, (DWORD) pwfxDst->nChannels));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nChannels = pwfxSrc->nChannels;
        }

        switch (pwfxDst->wFormatTag)
        {
#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
            nSamplesPerSec = pid->CELP.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->CELP.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->CELP.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
#endif
        case WAVE_FORMAT_LH_SB8:
            nSamplesPerSec = pid->SB8.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->SB8.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->SB8.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
        case WAVE_FORMAT_LH_SB12:
            nSamplesPerSec = pid->SB12.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->SB12.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->SB12.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
        case WAVE_FORMAT_LH_SB16:
            nSamplesPerSec = pid->SB16.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->SB16.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->SB16.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
        default:
            DBGMSG (1, (_T ("%s: not supported dest wFormatTag=%d\r\n"),
            SZFN, (UINT) pwfxDst->wFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }

        //  if the destination samples per second is restricted, verify
        //  that it is within our capabilities...

        if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
        {
            if (pwfxDst->nSamplesPerSec != nSamplesPerSec)
            {
                DBGMSG (1, (_T ("%s: ERROR dest'nSamplesPerSec=%ld must be 8000\r\n"),
                SZFN, (DWORD) pwfxDst->nSamplesPerSec));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nSamplesPerSec = nSamplesPerSec;
        }

        //  if the destination bits per sample is restricted, verify
        //  that it is within our capabilities...

        if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
        {
            if (pwfxDst->wBitsPerSample != wBitsPerSample)
            {
                DBGMSG (1, (_T ("%s: dest wBitsPerSample is not valid\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->wBitsPerSample = wBitsPerSample;
        }

        DBGMSG (1, (_T ("%s: returns no error\r\n"), SZFN));
        return MMSYSERR_NOERROR;


#ifdef CELP4800
	case WAVE_FORMAT_LH_CELP:
#endif
    case WAVE_FORMAT_LH_SB8:
    case WAVE_FORMAT_LH_SB12:
    case WAVE_FORMAT_LH_SB16:
        DBGMSG (1, (_T ("%s: src wFormatTag=0x%X\r\n"), SZFN, (UINT) pwfxSrc->wFormatTag));

        //  strictly verify that the source format is acceptable for
        //  this driver
        //
        if (! lhacmIsValidFormat (pwfxSrc, pid))
        {
            DBGMSG (1, (_T ("%s: src format not valid\r\n"), SZFN));
            return ACMERR_NOTPOSSIBLE;
        }

        //  if the destination format tag is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver is only able to decode to PCM

        if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
        {
            if (pwfxDst->wFormatTag != WAVE_FORMAT_PCM)
            {
                DBGMSG (1, (_T ("%s: not supported dest wFormatTag=%d\r\n"),
                SZFN, (UINT) pwfxDst->wFormatTag));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
        }

        //  if the destination channel count is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver is not able to change the number of channels

        if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
        {
            if ((pwfxSrc->nChannels != pwfxDst->nChannels) ||
                ((pwfxDst->nChannels < 1) &&
                 (pwfxDst->nChannels > ACM_DRIVER_MAX_CHANNELS)))
            {
                DBGMSG (1, (_T ("%s: ERROR src'nChannels=%ld and dest'nChannels=%ld are different\r\n"),
                SZFN, (DWORD) pwfxSrc->nChannels, (DWORD) pwfxDst->nChannels));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nChannels = pwfxSrc->nChannels;
        }

        //  if the destination samples per second is restricted, verify
        //  that it is within our capabilities...
        //
        //  this driver is not able to change the sample rate

        if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
        {
            if (pwfxDst->nSamplesPerSec != pwfxSrc->nSamplesPerSec)
            {
                DBGMSG (1, (_T ("%s: ERROR invalid dest'nSamplesPerSec=%ld\r\n"),
                SZFN, (DWORD) pwfxDst->nSamplesPerSec));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
        }

        //  if the destination bits per sample is restricted, verify
        //  that it is within our capabilities...

        if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
        {
            if (pwfxDst->wBitsPerSample != LH_PCM_BITSPERSAMPLE)
            {
                DBGMSG (1, (_T ("%s: dest wBitsPerSample is not 16\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->wBitsPerSample = pwfxSrc->wBitsPerSample;
        }

        //  at this point, we have filled in all fields except the
        //  following for our 'suggested' destination format:
        //
        //      nAvgBytesPerSec
        //      nBlockAlign
        //      cbSize

        pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT (pwfxDst);
        pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                   pwfxDst->nBlockAlign;

        // pwfxDst->cbSize       = not used;

        DBGMSG (1, (_T ("%s: returns no error\r\n"), SZFN));
        return MMSYSERR_NOERROR;
    }

    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.

    DBGMSG (1, (_T ("%s: bad wFormatTag=%d\r\n"), SZFN, (UINT) pwfxSrc->wFormatTag));

    return ACMERR_NOTPOSSIBLE;

} // acmdFormatSuggest()


//--------------------------------------------------------------------------;
//
//  on ACMDM_FORMATTAG_DETAILS
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdFormatTagDetails
(
    PINSTANCEDATA           pid,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT    uFormatTag;

    FUNCTION_ENTRY ("acmdFormatTagDetails")

    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
    case ACM_FORMATTAGDETAILSF_INDEX:
        DBGMSG (1, (_T ("%s: ACM_FORMATTAGDETAILSF_INDEX\r\n"), SZFN));

        //  if the index is too large, then they are asking for a
        //  non-existant format.  return error.

        if (padft->dwFormatTagIndex >= ACM_DRIVER_MAX_FORMAT_TAGS)
        {
            DBGMSG (1, (_T ("%s: ERROR too big dwFormatTagIndex=%ld\r\n"), SZFN, padft->dwFormatTagIndex));
            return ACMERR_NOTPOSSIBLE;
        }

        uFormatTag = gauFormatTagIndexToTag[padft->dwFormatTagIndex];
        break;


    case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
        DBGMSG (1, (_T ("%s: ACM_FORMATTAGDETAILSF_LARGESTSIZE\r\n"), SZFN));
        switch (padft->dwFormatTag)
        {
        case WAVE_FORMAT_UNKNOWN:
#ifdef CELP4800
            padft->dwFormatTag = WAVE_FORMAT_LH_CELP;
#else
            padft->dwFormatTag = WAVE_FORMAT_LH_SB12;
#endif

#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
#endif
        case WAVE_FORMAT_LH_SB8:
        case WAVE_FORMAT_LH_SB12:
        case WAVE_FORMAT_LH_SB16:
            uFormatTag = padft->dwFormatTag;
            DBGMSG (1, (_T ("%s: dwFormatTag=0x%x\r\n"), SZFN, uFormatTag));
            break;

        case WAVE_FORMAT_PCM:
            DBGMSG (1, (_T ("%s: dwFormatTag=WAVE_FORMAT_PCM\r\n"), SZFN));
            uFormatTag = WAVE_FORMAT_PCM;
            break;

        default:
            DBGMSG (1, (_T ("%s: dwFormatTag=%ld not valid\r\n"), SZFN, padft->dwFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }
        break;


    case ACM_FORMATTAGDETAILSF_FORMATTAG:
        DBGMSG (1, (_T ("%s: ACM_FORMATTAGDETAILSF_FORMATTAG\r\n"), SZFN));
        switch (padft->dwFormatTag)
        {
#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
#endif
        case WAVE_FORMAT_LH_SB8:
        case WAVE_FORMAT_LH_SB12:
        case WAVE_FORMAT_LH_SB16:
        case WAVE_FORMAT_PCM:
            uFormatTag = padft->dwFormatTag;
            DBGMSG (1, (_T ("%s: dwFormatTag=0x%x\r\n"), SZFN, uFormatTag));
            break;
        default:
            DBGMSG (1, (_T ("%s: dwFormatTag=%ld not valid\r\n"), SZFN, padft->dwFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }
        break;

    //  if this ACM driver does not understand a query type, then
    //  return 'not supported'

    default:
        DBGMSG (1, (_T ("%s: this detail option is not supported, fdwDetails=0x%lX\r\n"), SZFN, fdwDetails));
        return MMSYSERR_NOTSUPPORTED;
    }

    // ok, let's fill in the structure based on uFormatTag!

    switch (uFormatTag)
    {
    case WAVE_FORMAT_PCM:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_PCM\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_PCM;
        padft->dwFormatTag      = WAVE_FORMAT_PCM;
        padft->cbFormatSize     = sizeof (PCMWAVEFORMAT);
        padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
        padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;
        //
        //  the ACM is responsible for the PCM format tag name
        //
        padft->szFormatTag[0]   =  0;
        break;


#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_CELP\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_CELP;
#endif

        /* GOTOs - ugh! */
    Label_LH_common:

        padft->dwFormatTag      = uFormatTag;
        padft->cbFormatSize     = sizeof (WAVEFORMATEX);
        padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
#ifdef CELP4800
        padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_LH_CELP;
#else
        padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_LH_SB16;
#endif
        LoadStringCodec (pid->hInst, gauTagNameIds[padft->dwFormatTagIndex],
                            padft->szFormatTag, SIZEOFACMSTR (padft->szFormatTag));
        break;
    case WAVE_FORMAT_LH_SB8:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_SB8\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_SB8;
        goto Label_LH_common;

    case WAVE_FORMAT_LH_SB12:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_SB12\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_SB12;
        goto Label_LH_common;

    case WAVE_FORMAT_LH_SB16:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_SB16\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_SB16;
        goto Label_LH_common;

    default:
        DBGMSG (1, (_T ("%s: uFormatTag=%d not valid\r\n"), SZFN, uFormatTag));
        return ACMERR_NOTPOSSIBLE;
    }

    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure

    padft->cbStruct = min (padft->cbStruct, sizeof (*padft));

    return MMSYSERR_NOERROR;

} // acmdFormatTagDetails()

//--------------------------------------------------------------------------;
//
//  on ACMDM_FORMAT_DETAILS
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdFormatDetails
(
    PINSTANCEDATA           pid,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX          pwfx;
    UINT                    uFormatIndex;
    UINT                    u;
    DWORD                   dwFormatTag;

    FUNCTION_ENTRY ("acmdFormatDetails")

    pwfx = padf->pwfx;

    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
    //  enumerate by index
    //
    //  verify that the format tag is something we know about and
    //  return the details on the 'standard format' supported by
    //  this driver at the specified index...

    case ACM_FORMATDETAILSF_INDEX:
        DBGMSG (1, (_T ("%s: ACM_FORMATDETAILSF_INDEX\r\n"), SZFN));
        //
        //  put some stuff in more accessible variables--note that we
        //  bring variable sizes down to a reasonable size for 16 bit
        //  code...
        //

        dwFormatTag = padf->dwFormatTag;
        uFormatIndex = padf->dwFormatIndex;

        switch (dwFormatTag)
        {
        case WAVE_FORMAT_PCM:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_PCM\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_PCM)
            {
                DBGMSG (1, (_T ("%s: ERROR too big dwFormatIndex=%ld\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            //
            //  now fill in the format structure
            //
            pwfx->wFormatTag      = WAVE_FORMAT_PCM;

            u = uFormatIndex % ACM_DRIVER_MAX_PCM_SAMPLE_RATES;
            pwfx->nSamplesPerSec  = gauPCMFormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
            pwfx->nChannels       = u + 1;

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_PCM;
            pwfx->wBitsPerSample  = gauPCMFormatIndexToBitsPerSample[u];

            pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
            pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

            //
            //  note that the cbSize field is NOT valid for PCM
            //  formats
            //
            //  pwfx->cbSize      = 0;
            break;

#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_CELP\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_CELP)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_CELP;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_CELP_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHCELPFormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_CELP;
            pwfx->wBitsPerSample    = gauLHCELPFormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->CELP.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->CELP.CodecInfo));
            pwfx->cbSize            = 0;
            break;
#endif

        case WAVE_FORMAT_LH_SB8:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_SB8\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_SB8)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_SB8;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_SB8_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHSB8FormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB8;
            pwfx->wBitsPerSample    = gauLHSB8FormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->SB8.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->SB8.CodecInfo));
            pwfx->cbSize            = 0;
            break;

        case WAVE_FORMAT_LH_SB12:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_SB12\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_SB12)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_SB12;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_SB12_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHSB12FormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB12;
            pwfx->wBitsPerSample    = gauLHSB12FormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->SB12.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->SB12.CodecInfo));
            pwfx->cbSize            = 0;
            break;

        case WAVE_FORMAT_LH_SB16:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_SB16\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_SB16)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_SB16;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_SB16_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHSB16FormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB16;
            pwfx->wBitsPerSample    = gauLHSB16FormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->SB16.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->SB16.CodecInfo));
            pwfx->cbSize            = 0;
            break;

        default:
            DBGMSG (1, (_T ("%s: unknown dwFormatTag=%ld\r\n"), SZFN, dwFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }
        break;


    case ACM_FORMATDETAILSF_FORMAT:
        DBGMSG (1, (_T ("%s: ACM_FORMATDETAILSF_FORMAT\r\n"), SZFN));
        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        dwFormatTag = (DWORD) pwfx->wFormatTag;
        switch (dwFormatTag)
        {
        case WAVE_FORMAT_PCM:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_PCM\r\n"), SZFN));
            if (! pcmIsValidFormat (pwfx))
            {
                DBGMSG (1, (_T ("%s: format not valid\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
            break;

#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
#endif
        case WAVE_FORMAT_LH_SB8:
        case WAVE_FORMAT_LH_SB12:
        case WAVE_FORMAT_LH_SB16:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH\r\n"), SZFN));
            if (! lhacmIsValidFormat (pwfx, pid))
            {
                DBGMSG (1, (_T ("%s: format not valid\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
            break;

        default:
            DBGMSG (1, (_T ("%s: bad dwFormatTag=%ld\r\n"), SZFN, dwFormatTag));
            return (ACMERR_NOTPOSSIBLE);
        }
        break;


    default:
        //
        //  don't know how to do the query type passed--return 'not
        //  supported'.
        //
        DBGMSG (1, (_T ("%s: not support this detail option=%ld\r\n"), SZFN, fdwDetails));
        return MMSYSERR_NOTSUPPORTED;
    }

    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.

    padf->cbStruct    = min (padf->cbStruct, sizeof (*padf));
    if (padf->cbStruct == 0)
        padf->cbStruct = sizeof (*padf);
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';

#ifdef _DEBUG
    DBGMSG (1, (_T ("%s: %s, %ld Samp/Sec, %u Channels, %u-bit, Align=%u, %ld Bytes/Sec, cbSize=%u\n"),
        SZFN, (WAVE_FORMAT_PCM == pwfx->wFormatTag ? (LPCTSTR) _T ("PCM") : (LPCTSTR) _T ("LH")),
        pwfx->nSamplesPerSec, pwfx->nChannels,
        pwfx->wBitsPerSample, pwfx->nBlockAlign,
        pwfx->nAvgBytesPerSec, pwfx->cbSize));
#endif

    return MMSYSERR_NOERROR;

} // acmdFormatDetails()


//--------------------------------------------------------------------------;
//
//  on ACMDM_STREAM_OPEN
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      HLOCAL pid: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdStreamOpen
(
    PINSTANCEDATA           pid,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX pwfxSrc = padsi->pwfxSrc;
    LPWAVEFORMATEX pwfxDst = padsi->pwfxDst;
    PSTREAMINSTANCEDATA psi;
    BOOL fCompress;
    UINT uEncodedFormatTag;
    UINT cbMaxData;
    DWORD dwMaxBitRate;
    PFN_CONVERT pfnConvert = NULL;
    PFN_CLOSE pfnClose = NULL;
    HANDLE hAccess = NULL;
    PCODECDATA pCodecData = NULL;

    FUNCTION_ENTRY ("acmdStreamOpen")

    // Validate that the input and output formats are compatible
    DBGMSG (1, (_T ("%s: wFormatTag: Src=%d, Dst=%d\r\n"), SZFN, (UINT) pwfxSrc->wFormatTag, (UINT) pwfxDst->wFormatTag));

    switch (pwfxSrc->wFormatTag)
    {
    case WAVE_FORMAT_PCM:
        // Source is PCM (we'll be compressing): check it and
        // make sure destination type is LH
        if (! pcmIsValidFormat (pwfxSrc))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        if (! lhacmIsValidFormat (pwfxDst, pid))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        uEncodedFormatTag = pwfxDst->wFormatTag;
        fCompress = TRUE;
        break;

#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
#endif
    case WAVE_FORMAT_LH_SB8:
    case WAVE_FORMAT_LH_SB12:
    case WAVE_FORMAT_LH_SB16:
        // Source is LH (we'll be decompressing): check it and
        // make sure destination type is PCM
        if (! lhacmIsValidFormat (pwfxSrc, pid))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        if (! pcmIsValidFormat (pwfxDst))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        uEncodedFormatTag = pwfxSrc->wFormatTag;
        fCompress = FALSE;
        break;

    default:
        return ACMERR_NOTPOSSIBLE;
    }

    //  For this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.

    if (pwfxSrc->nChannels != pwfxDst->nChannels)
    {
        DBGMSG (1, (_T ("%s: bad nChannels: Src=%d, Dst=%d\r\n"), SZFN, (UINT) pwfxSrc->nChannels, (UINT) pwfxDst->nChannels));
        return MMSYSERR_NOTSUPPORTED;
    }

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
    {
        DBGMSG (1, (_T ("%s: bad nSamplesPerSec: Src=%d, Dst=%d\r\n"), SZFN, (UINT) pwfxSrc->nSamplesPerSec, (UINT) pwfxDst->nSamplesPerSec));
        return MMSYSERR_NOTSUPPORTED;
    }

    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.

    if (ACM_STREAMOPENF_QUERY & padsi->fdwOpen)
    {
        DBGMSG (1, (_T ("%s: Query ok\r\n"), SZFN));
        return MMSYSERR_NOERROR;
    }

    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.

    cbMaxData = 0;
    dwMaxBitRate = 0;

    switch (uEncodedFormatTag)
    {
#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
#endif
    case WAVE_FORMAT_LH_SB8:
    case WAVE_FORMAT_LH_SB12:
    case WAVE_FORMAT_LH_SB16:
#ifdef CELP4800
        if (uEncodedFormatTag == WAVE_FORMAT_LH_CELP)
          {
          dwMaxBitRate = 4800;
          pCodecData = &(pid->CELP);
          }
        else
#endif
			if (uEncodedFormatTag == WAVE_FORMAT_LH_SB8)
          {
          dwMaxBitRate = 8000;
          pCodecData = &(pid->SB8);
          }
        else if (uEncodedFormatTag == WAVE_FORMAT_LH_SB12)
          {
          dwMaxBitRate = 12000;
          pCodecData = &(pid->SB12);
          }
        else if (uEncodedFormatTag == WAVE_FORMAT_LH_SB16)
          {
          dwMaxBitRate = 16000;
          pCodecData = &(pid->SB16);
          }
        if (fCompress)
        {
            hAccess = MSLHSB_Open_Coder (dwMaxBitRate);
            pfnConvert = MSLHSB_Encode;
            pfnClose = MSLHSB_Close_Coder;
        }
        else
        {
            hAccess = MSLHSB_Open_Decoder (dwMaxBitRate);
            pfnConvert = MSLHSB_Decode;
            pfnClose = MSLHSB_Close_Decoder;
            cbMaxData = pCodecData->CodecInfo.wCodedBufferSize;
        }
        break;

    }

    if (hAccess == NULL)
    {
        if (pfnClose) (*pfnClose) (hAccess);
        DBGMSG (1, (_T ("%s: open failed, hAccess=0\r\n"), SZFN));
        return ACMERR_NOTPOSSIBLE;
    }

    psi = (PSTREAMINSTANCEDATA) LocalAlloc (LPTR, sizeof (STREAMINSTANCEDATA) + cbMaxData);
    if (psi == NULL)
    {
        DBGMSG (1, (_T ("%s: LocalAlloc failed\r\n"), SZFN));
        if (pfnClose) (*pfnClose) (hAccess);
        return MMSYSERR_NOMEM;
    }

    //  fill out our instance structure
    psi->pfnConvert = pfnConvert;
    psi->pfnClose = pfnClose;
    psi->hAccess = hAccess;
    psi->pCodecData = pCodecData;
    psi->fCompress = fCompress;
    psi->dwMaxBitRate = dwMaxBitRate;
    psi->fInit = TRUE;

    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0;
    padsi->dwDriver  = (DWORD_PTR) psi;

    return MMSYSERR_NOERROR;

} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  on ACMDM_STREAM_CLOSE
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdStreamClose
(
    PINSTANCEDATA           pid,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCEDATA     psi;

    FUNCTION_ENTRY ("acmdStreamClose")
    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCEDATA) padsi->dwDriver;
    if (psi)
    {
        if (psi->fInit && psi->hAccess && psi->pfnClose)
        {
            (*(psi->pfnClose)) (psi->hAccess);
            LocalFree ((HLOCAL) psi);
        }
    }    // if (psi)

    return MMSYSERR_NOERROR;

} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT FAR PASCAL acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;


// #define GetBytesPerBlock(nSamplesPerSec, wBitsPerSample) (RT24_SAMPLESPERBLOCK8 * (wBitsPerSample) >> 3)

LRESULT FAR PASCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{

    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cBlocks;
    DWORD   cbSrcLength;
    DWORD   cbDstLength;
    WORD    wPCMBufferSize;
    WORD    wCodedBufferSize;

    PSTREAMINSTANCEDATA     psi;

	FUNCTION_ENTRY ("acmdStreamSize")

    psi = (PSTREAMINSTANCEDATA) padsi->dwDriver;
    if (psi == NULL) return ACMERR_NOTPOSSIBLE;

    wPCMBufferSize = psi->pCodecData->CodecInfo.wPCMBufferSize;
    wCodedBufferSize = psi->pCodecData->CodecInfo.wCodedBufferSize;

    cbSrcLength = padss->cbSrcLength;
    cbDstLength = padss->cbDstLength;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
    case ACM_STREAMSIZEF_SOURCE:

        if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM)
        {
            switch (pwfxDst->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src pcm -> dst lh celp
#endif
            case WAVE_FORMAT_LH_SB8:
                // src pcm -> dst lh sb8
            case WAVE_FORMAT_LH_SB12:
                // src pcm -> dst lh sb12
            case WAVE_FORMAT_LH_SB16:
                // src pcm -> dst lh sb16

                cBlocks = cbSrcLength / wPCMBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                if (cBlocks * wPCMBufferSize < cbSrcLength) cBlocks++;
                padss->cbDstLength = cBlocks * wCodedBufferSize;
                break;
             }
        }
        else
        {
            switch (pwfxSrc->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src lh celp -> dst pcm
                cBlocks = cbSrcLength / wCodedBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                if (cBlocks * wCodedBufferSize < cbSrcLength) cBlocks++;
                padss->cbDstLength = cBlocks * wPCMBufferSize;
                break;
#endif
            case WAVE_FORMAT_LH_SB8:
                // src lh sb8 -> dst pcm
            case WAVE_FORMAT_LH_SB12:
                // src lh sb12 -> dst pcm
            case WAVE_FORMAT_LH_SB16:
                // src lh sb16 -> dst pcm

                padss->cbDstLength = cbSrcLength * wPCMBufferSize;
                break;
              }
        }
        return MMSYSERR_NOERROR;


    case ACM_STREAMSIZEF_DESTINATION:

        if (pwfxDst->wFormatTag == WAVE_FORMAT_PCM)
        {
            switch (pwfxSrc->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src lh celp <- dst pcm
#endif
            case WAVE_FORMAT_LH_SB8:
                // src lh sb8 <- dst pcm
            case WAVE_FORMAT_LH_SB12:
                // src lh sb12 <- dst pcm
            case WAVE_FORMAT_LH_SB16:
                // src lh sb16 <- dst pcm

                cBlocks = cbDstLength / wPCMBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                padss->cbSrcLength = cBlocks * wCodedBufferSize;
                break;
             }
        }
        else
        {
            switch (pwfxDst->wFormatTag)
            {
#ifdef NEW_ANSWER
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src pcm <- dst lh celp
#endif
            case WAVE_FORMAT_LH_SB8:
                // src pcm <- dst lh sb8
            case WAVE_FORMAT_LH_SB12:
                // src pcm <- dst lh sb12
            case WAVE_FORMAT_LH_SB16:
                // src pcm <- dst lh sb16
                cBlocks = cbDstLength / wCodedBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                padss->cbSrcLength = cBlocks * wPCMBufferSize;
                break;
#else
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src pcm <- dst lh celp
                cBlocks = cbDstLength / wCodedBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                padss->cbSrcLength = cBlocks * wPCMBufferSize;
                break;
#endif
            case WAVE_FORMAT_LH_SB8:
                // src pcm <- dst lh sb8
            case WAVE_FORMAT_LH_SB12:
                // src pcm <- dst lh sb12
            case WAVE_FORMAT_LH_SB16:
                // src pcm <- dst lh sb16

                padss->cbSrcLength = cbDstLength * wPCMBufferSize;
                break;
#endif
              }
        }
        return MMSYSERR_NOERROR;

    }    // switch()

    return MMSYSERR_NOTSUPPORTED;

} // acmdStreamSize()



//--------------------------------------------------------------------------;
//
//  LRESULT FAR PASCAL acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      HLOCAL pid: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

// We want to use as little stack as possible,
// So let's make all our local variables statics


LRESULT FAR PASCAL acmdStreamConvert
(
    PINSTANCEDATA           pid,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    LH_ERRCODE lherr = LH_SUCCESS;
    DWORD    dwInBufSize, dwOutBufSize;
    PBYTE   pbSrc, pbDst, pData;
    DWORD   dwPCMBufferSize, dwCodedBufferSize;

    PSTREAMINSTANCEDATA psi;

    FUNCTION_ENTRY ("acmdStreamConvert")

    // this is a must
    pbDst = padsh->pbDst;
    pbSrc = padsh->pbSrc;

    // zero is a *must*
    padsh->cbSrcLengthUsed = 0;
    padsh->cbDstLengthUsed = 0;

    psi = (PSTREAMINSTANCEDATA) padsi->dwDriver;
    if (psi == NULL) return ACMERR_NOTPOSSIBLE;

    dwPCMBufferSize = (DWORD) psi->pCodecData->CodecInfo.wPCMBufferSize;
    dwCodedBufferSize = (DWORD) psi->pCodecData->CodecInfo.wCodedBufferSize;

    dwInBufSize = (DWORD) padsh->cbSrcLength;
    dwOutBufSize = (DWORD) padsh->cbDstLength;
    DBGMSG (1, (_T ("%s: prior: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
    SZFN, dwInBufSize, dwOutBufSize));

    /////////////////////////////////////////////
    //
    //      ENCODING
    //

    if (psi->fCompress)
    {
        while (dwOutBufSize >= dwCodedBufferSize
                  &&
               dwInBufSize >= dwPCMBufferSize)
        {
            // ignore the data the codec cannot handle
            // if (dwInBufSize > dwPCMBufferSize) dwInBufSize = dwPCMBufferSize;
            dwInBufSize = dwPCMBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            // encode it
            lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                               pbSrc, (PWORD) &dwInBufSize,
                                            pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Encode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // return the info about the amount of data used and created
            padsh->cbSrcLengthUsed += dwInBufSize;
            padsh->cbDstLengthUsed += dwOutBufSize;

            // re-compute the buffer sizes
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);
            dwInBufSize = (DWORD) (padsh->cbSrcLength - padsh->cbSrcLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

        goto MyExit; // spit out debug message
    }


    /////////////////////////////////////////////
    //
    //      DECODING celp
    //

#ifdef CELP4800
    if (psi->pCodecData->wFormatTag == WAVE_FORMAT_LH_CELP)
    {
        while (dwOutBufSize >= dwPCMBufferSize
                  &&
               dwInBufSize >= dwCodedBufferSize)
        {
            // ignore the data that the codec cannot handle
            // if (dwInBufSize > dwCodedBufferSize) dwInBufSize = dwCodedBufferSize;
            dwInBufSize = dwCodedBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            // decode it
            lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                pbSrc, (PWORD) &dwInBufSize,
                                pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Decode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // return the info about the amount of data used and created
            padsh->cbSrcLengthUsed += dwInBufSize;
            padsh->cbDstLengthUsed += dwOutBufSize;

            // re-compute the buffer sizes
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);
            dwInBufSize = (DWORD) (padsh->cbSrcLength - padsh->cbSrcLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

        goto MyExit; // spit out debug message
    }
#endif

    /////////////////////////////////////////////
    //
    //      DECODING subbands
    //

    if (pid->wPacketData != LH_PACKET_DATA_FRAMED)
    {

        //
        // general application, such as sndrec32.exe and audcmp.exe
        //

        pData = &(psi->Data[0]); // use local constant

        while (dwOutBufSize >= dwPCMBufferSize
                  &&
               dwInBufSize + psi->cbData >= dwCodedBufferSize)
       {
            DBGMSG (1, (_T ("%s: cbData=0x%X\r\n"), SZFN, psi->cbData));
            // fill in the internal buffer as possible
            if (psi->cbData < dwCodedBufferSize)
            {
                // buffer the coded data
                dwInBufSize = dwCodedBufferSize - (DWORD) psi->cbData;
                CopyMemory (&(psi->Data[psi->cbData]), pbSrc, dwInBufSize);
                psi->cbData = (WORD) dwCodedBufferSize;
                padsh->cbSrcLengthUsed += dwInBufSize;
            }

            // reset input buffer size
            dwInBufSize = dwCodedBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            // decode it
            lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                pData, (PWORD) &dwInBufSize,
                                pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Decode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // update the amount of the remaining data
            psi->cbData -= (WORD) dwInBufSize;

            // move the remaining data to the beginning of the internal buffer
            // I should have used MoveMemory, but it is an MSVC runtime call.
            // Use CopyMemory instead, which should be ok because the overlapping
            // portion is copied before being overwritten.
            if (psi->cbData)
            {
                CopyMemory (pData, &(psi->Data[dwInBufSize]), psi->cbData);
            }

            // return the info about the amount of data used and created
            padsh->cbDstLengthUsed += dwOutBufSize;
            // note that cbSrcLengthUsed has been updated already!!!

            // re-compute the buffer sizes
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);
            dwInBufSize = (DWORD) (padsh->cbSrcLength - padsh->cbSrcLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

        // accomodate the final left-over bytes
        if (dwInBufSize + psi->cbData < dwCodedBufferSize)
        {
            CopyMemory (&(psi->Data[psi->cbData]), pbSrc, dwInBufSize);
            psi->cbData += (WORD) dwInBufSize;
            padsh->cbSrcLengthUsed += dwInBufSize;
        }

    }
    else
    {

        //
        // special case: datapump's subband packets
        //

        while (dwOutBufSize >= dwPCMBufferSize)
        {
            // hack the input size to be dwCodedBufferSize as required by L&H API
            dwInBufSize = dwCodedBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            DBGMSG (1, (_T ("%s: calling: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));

            // decode it
               lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                    pbSrc, (PWORD) &dwInBufSize,
                                    pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%X, dwOutBufSize=0x%X\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Decode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // return the info about the amount of data used and created
            padsh->cbSrcLengthUsed += dwInBufSize;
            padsh->cbDstLengthUsed += dwOutBufSize;

            // re-compute the buffer size
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

    }


MyExit:

    DBGMSG (1, (_T ("%s: exit: cbSrcLengthUsed=0x%lX, cbDstLengthUsed=0x%lX\r\n"),
    SZFN, (DWORD) padsh->cbSrcLengthUsed, (DWORD) padsh->cbDstLengthUsed));

    return MMSYSERR_NOERROR;
}


//--------------------------------------------------------------------------;
//
//  LRESULT FAR PASCAL DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

LRESULT CALLBACK DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{

    PINSTANCEDATA   pid;
    LRESULT dplr;


    FUNCTION_ENTRY ("DriverProc")

	pid = (PINSTANCEDATA)dwId;

    switch (uMsg)
    {
        case DRV_LOAD:
            DBGMSG (1, (_T ("%s: DRV_LOAD\r\n"), SZFN));
            return 1L;

        case DRV_FREE:
            DBGMSG (1, (_T ("%s: DRV_FREE\r\n"), SZFN));
            return 1L;          // not that it matters since ACM does not check this return value

        case DRV_OPEN:
            DBGMSG (1, (_T ("%s: DRV_OPEN\r\n"), SZFN));
            return acmdDriverOpen (hdrvr, (LPACMDRVOPENDESC)lParam2);

        case DRV_CLOSE:
            DBGMSG (1, (_T ("%s: DRV_CLOSE\r\n"), SZFN));
            dplr = acmdDriverClose (pid);
            return dplr;

        case DRV_INSTALL:
            DBGMSG (1, (_T ("%s: DRV_INSTALL\r\n"), SZFN));
            return ((LRESULT)DRVCNF_RESTART);

        case DRV_REMOVE:
            DBGMSG (1, (_T ("%s: DRV_REMOVE\r\n"), SZFN));
            return ((LRESULT)DRVCNF_RESTART);

        case DRV_ENABLE:
            DBGMSG (1, (_T ("%s: DRV_ENABLE\r\n"), SZFN));
            return 1L;

        case DRV_DISABLE:
            DBGMSG (1, (_T ("%s: DRV_DISABLE\r\n"), SZFN));
            return 1L;

        case DRV_QUERYCONFIGURE:            // Does this driver support configuration?
            DBGMSG (1, (_T ("%s: DRV_QUERYCONFIGURE\r\n"), SZFN));
            lParam1 = -1L;
            lParam2 = 0L;

        // fall through

        case DRV_CONFIGURE:
            DBGMSG (1, (_T ("%s: DRV_CONFIGURE\r\n"), SZFN));
            dplr = acmdDriverConfigure(pid, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return dplr;

        case ACMDM_DRIVER_DETAILS:
            DBGMSG (1, (_T ("%s: ACMDM_DRIVER_DETAILS\r\n"), SZFN));
            dplr = acmdDriverDetails(pid, (LPACMDRIVERDETAILS)lParam1);
            return dplr;

        case ACMDM_DRIVER_ABOUT:
            DBGMSG (1, (_T ("%s: ACMDM_DRIVER_ABOUT\r\n"), SZFN));
            dplr = acmdDriverAbout(pid, (HWND)lParam1);
            return dplr;

        case ACMDM_FORMAT_SUGGEST:
            DBGMSG (1, (_T ("%s: ACMDM_FORMAT_SUGGEST\r\n"), SZFN));
            dplr = acmdFormatSuggest(pid, (LPACMDRVFORMATSUGGEST)lParam1);
            return dplr;

        case ACMDM_FORMATTAG_DETAILS:
            DBGMSG (1, (_T ("%s: ACMDM_FORMATTAG_DETAILS\r\n"), SZFN));
            dplr = acmdFormatTagDetails(pid, (LPACMFORMATTAGDETAILS)lParam1, lParam2);
            return dplr;

        case ACMDM_FORMAT_DETAILS:
            DBGMSG (1, (_T ("%s: ACMDM_FORMAT_DETAILS\r\n"), SZFN));
            dplr = acmdFormatDetails(pid, (LPACMFORMATDETAILS)lParam1, lParam2);
            return dplr;

        case ACMDM_STREAM_OPEN:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_OPEN\r\n"), SZFN));
            dplr = acmdStreamOpen(pid, (LPACMDRVSTREAMINSTANCE)lParam1);
            return dplr;

        case ACMDM_STREAM_CLOSE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_CLOSE\r\n"), SZFN));
            return acmdStreamClose(pid, (LPACMDRVSTREAMINSTANCE)lParam1);

        case ACMDM_STREAM_SIZE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_SIZE\r\n"), SZFN));
            return acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);

        case ACMDM_STREAM_CONVERT:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_CONVERT\r\n"), SZFN));
            dplr = acmdStreamConvert(pid, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return dplr;

        case ACMDM_STREAM_PREPARE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_PREPARE\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case ACMDM_STREAM_UNPREPARE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_UNPREPARE\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

#if defined (_DEBUG) && 0
        // Trap some extra known messages so our debug output can show them

        case ACMDM_STREAM_RESET:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_RESET\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case ACMDM_DRIVER_NOTIFY:
            DBGMSG (1, (_T ("%s: ACMDM_DRIVER_NOTIFY\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case DRV_EXITSESSION:
            DBGMSG (1, (_T ("%s: DRV_EXITSESSION\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case DRV_EXITAPPLICATION:
            DBGMSG (1, (_T ("%s: DRV_EXITAPPLICATION\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case DRV_POWER:
            DBGMSG (1, (_T ("%s: DRV_POWER\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

#endif

    }

    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.


    if (uMsg == ACMDM_LH_DATA_PACKAGING)
    {
        if (pid)
        {
            pid->wPacketData = (WORD) lParam1;
        }
    }
    else
    {
        //DBGMSG (1, (_T ("%s: bad uMsg=%d\r\n"), uMsg));
        return MMSYSERR_NOTSUPPORTED;
    }

    return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

} // DriverProc()





#ifdef _DEBUG

// CurtSm hack ... don't spew all the time
UINT DebugLH = 0;


void FAR CDECL MyDbgPrintf ( LPTSTR lpszFormat, ... )
{
    static TCHAR buf[1024];
	va_list arglist;

    if (!DebugLH)
        return;

	va_start(arglist, lpszFormat);
    wvsprintf ((LPTSTR) buf, (LPCSTR)lpszFormat,
#if 0
                    (LPSTR) (((LPBYTE) &lpszFormat) + sizeof (lpszFormat)));
#else
					arglist);
#endif
    OutputDebugString ((LPTSTR) buf);
}


#endif    //...def _DEBUG


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\lh\variable.h ===
//Use CELP on _x86_ but not Alpha
#ifndef _ALPHA_
#define CELP4800
#endif

#define   F_ECH    8000  // Sampling frequency
#define   NBSPF_4800_8000     160  // !!! Nbr of sample per recorded speech frame
#define   NBSPF_12000_16000     128  // !!! Nbr of sample per recorded speech frame
#define   NBFAC      25  // Nbr of speech frame for computing the average br

#define DEGRADE_8000 1

#ifdef DEGRADE_8000
#define   MOD_TH1_8000  50  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_8000  100  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_8000  150  // the overhead is about 60%, hence max=12000
//#define   MOD_TH1_8000  500  // 1st, 2nd and 3rd thresholds for a 14.4 modem
//#define   MOD_TH2_8000  1000  // (assumed with compression, hence max 19.2)
//#define   MOD_TH3_8000  1500  // the overhead is about 60%, hence max=12000
#else
#define   MOD_TH1_8000  5000  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_8000  6500  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_8000  8000  // the overhead is about 60%, hence max=12000
#endif

#ifdef DEGRADE_12000_16000
#define   MOD_TH1_12000_16000  3000  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_12000  4000  // (assumed with compression, hence max 19.2)
#define   MOD_TH2_16000  5000  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_12000  5000  // the overhead is about 60%, hence max=12000
#define   MOD_TH3_16000  7000  // the overhead is about 60%, hence max=12000
#else
#define   MOD_TH1_12000_16000  8000  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_12000  10000  // (assumed with compression, hence max 19.2)
#define   MOD_TH2_16000  12000  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_12000  12000  // the overhead is about 60%, hence max=12000
#define   MOD_TH3_16000  16000  // the overhead is about 60%, hence max=12000
#endif

#define   MAX_LEVEL1	40	// input /2 instead of /4 20
#define	  DIV_MAX1	60
#define   NBSB_SP_MAX1_8000_12000	6
#define   NBSB_SP_MAX1_16000	5

#define   MAX_LEVEL2	80	// input /2 instead of /4 40
#define	  DIV_MAX2	40
#define   NBSB_SP_MAX2_8000_12000  5
#define   NBSB_SP_MAX2_16000  4

#define   MAX_LEVEL3	120	// input /2 instead of /4 60
#define	  DIV_MAX3	30
#define   NBSB_SP_MAX3_8000_12000	5
#define   NBSB_SP_MAX3_16000	4

#define   MAX_LEVEL4    150	// input /2 instead of /4 75
#define	  DIV_MAX4	20
#ifdef DEGRADE_8000
#define   NBSB_SP_MAX4_8000_12000	3
#else
#define   NBSB_SP_MAX4_8000_12000	4
#endif
#define   NBSB_SP_MAX4_16000	3

//#define	  QUANT_LEVELS_8000_12000  9,9,9,9,5,5,5,5,5,5,5,5
//#define	  QUANT_LEVELS_16000  9,9,7,7,5,5,5,5,5,5

#define   SILENCE_QUANT_LEVEL_16000	3

//#define   CODING_BITS_8000_12000   52,52,38,38,38,38
//#define   CODING_BITS_16000   52,46,38,38,38

#define   SILENCE_CODING_BIT_16000	26

#define   MAX_OUTPUT_BYTES_4800 12
#define   MAX_OUTPUT_BYTES_8000_12000 37
#define   MAX_OUTPUT_BYTES_16000 43
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\16\dcasm.asm ===
;  DCASM.ASM
;
;  Created 31-Jul-96 [JonT]

	PAGE 60, 255
	.MODEL small, pascal
	TITLE DCASM.ASM
	
	.386
	.DATA
	extrn g_dwEntrypoint:DWORD
szName	DB	'DCAPVXD ', 0

	.CODE

	extrn OpenDriver:FAR
	extrn CloseDriver:FAR

	PUBLIC _OpenDriver
_OpenDriver::
	jmp	OpenDriver

	PUBLIC _CloseDriver
_CloseDriver::
	jmp	CloseDriver
	
;  ReturnSel
;	Returns either CS or DS to the C caller

ReturnSel PROC NEAR PASCAL, fCS:WORD
	mov	ax, ds
	cmp	fCS, 0
	jz	RS_Done
	mov	ax, cs
RS_Done:
	ret
ReturnSel ENDP


;  GetVxDEntrypoint
;	Returns device entrypoint in DX:AX or zero on error

GetVxDEntrypoint PROC NEAR PASCAL uses si di

	; Get the entrypoint from the VMM
	xor	bx, bx
	mov     ax, 1684h
	push	ds
	pop	es
	mov	di, OFFSET szName
	int     2Fh
	
	; Return entrypoint in EAX
	mov	dx, es
	mov	ax, di
	ret

GetVxDEntrypoint ENDP


;  SetWin32Event
;	Sets a Win32 event using the VxD

SetWin32Event PROC NEAR PASCAL, pev:DWORD

	; Call the VxD. Note that pev is already a flat pointer
	mov	ah, 1
	mov	ecx, pev
	call	[g_dwEntrypoint]
	ret

SetWin32Event ENDP 


;  _CloseVxDHandle
;	Calls the VxD to close a VxD handle. This is really torturous
;	since it's just going to call into KERNEL32, but there's no
;	export to do this from ring 3. Go figure.

_CloseVxDHandle PROC FAR PASCAL USES ds, pev:DWORD

	mov	ax, DGROUP
	mov	ds, ax
	mov	ah, 2
	mov	ecx, pev
	call	[g_dwEntrypoint]

	ret
	
_CloseVxDHandle ENDP


;  ZeroMemory
;
;	Since we can't call CRT, does a memset(lp, 0, len)

ZeroMemory PROC NEAR PASCAL USES di, lp:DWORD, len:WORD

	les	di, lp
	xor	eax, eax
	mov	cx, len
	shr	cx, 2
	rep	stosd
	mov	cx, len
	and	cx, 3
	rep	stosb
	ret

ZeroMemory ENDP
	
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\16\dcthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:55 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk 

	TITLE	$dcthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk_ThunkData32	;This symbol must be exported.
thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk - offset thk_ThunkData32
	dd	offset FT_Prolog_thk - offset thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk_ThunkConnect32@16
thk_ThunkConnect32@16:
	pop	edx
	push	offset thk_ThkData16
	push	offset thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk_ThkData16 label byte
	db	"thk_ThunkData16",0


		


pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public _OpenDriver@12
_OpenDriver@12:
	mov	cl,14
; _OpenDriver(16) = _OpenDriver(32) {}
;
; dword ptr [ebp+8]:  lpDriverName
; dword ptr [ebp+12]:  dwReserved
; dword ptr [ebp+16]:  lpvop
;
public II_OpenDriver@12
II_OpenDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	dword ptr [ebp+12]	;dwReserved: dword->dword
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _CloseDriver@12
_CloseDriver@12:
	mov	cl,13
; _CloseDriver(16) = _CloseDriver(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  lpReserved1
; dword ptr [ebp+16]:  lpReserved2
;
public II_CloseDriver@12
II_CloseDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;lpReserved1: dword->dword
	push	dword ptr [ebp+16]	;lpReserved2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	12





;
public _SendDriverMessage@16
_SendDriverMessage@16:
	mov	cl,12
; _SendDriverMessage(16) = _SendDriverMessage(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  msg
; dword ptr [ebp+16]:  param1
; dword ptr [ebp+20]:  param2
;
public II_SendDriverMessage@16
II_SendDriverMessage@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;msg: dword->dword
	push	dword ptr [ebp+16]	;param1: dword->dword
	push	dword ptr [ebp+20]	;param2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	16





;
public _GetVideoPalette@12
_GetVideoPalette@12:
	mov	cl,11
; _GetVideoPalette(16) = _GetVideoPalette(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpcp
; dword ptr [ebp+16]:  dwcbSize
;
public II_GetVideoPalette@12
II_GetVideoPalette@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;dwcbSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public _InitializeVideoStream@12
_InitializeVideoStream@12:
	mov	cl,9
; _InitializeVideoStream(16) = _InitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  dwMicroSecPerFrame
; dword ptr [ebp+16]:  dwEvent
;
public II_InitializeVideoStream@12
II_InitializeVideoStream@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	push	dword ptr [ebp+12]	;dwMicroSecPerFrame: dword->dword
	push	dword ptr [ebp+16]	;dwEvent: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	12





;
public _UninitializeVideoStream@4
_UninitializeVideoStream@4:
	mov	cl,8
	jmp	II_UninitializeVideoStream@4
public _InitializeExternalVideoStream@4
_InitializeExternalVideoStream@4:
	mov	cl,10
; _UninitializeVideoStream(16) = _UninitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_UninitializeVideoStream@4
II_UninitializeVideoStream@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _GetVideoFormatSize@4
_GetVideoFormatSize@4:
	mov	cl,7
; _GetVideoFormatSize(16) = _GetVideoFormatSize(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_GetVideoFormatSize@4
II_GetVideoFormatSize@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public _GetVideoFormat@8
_GetVideoFormat@8:
	mov	cl,6
; _GetVideoFormat(16) = _GetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpbmih
;
public II_GetVideoFormat@8
II_GetVideoFormat@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public _SetVideoFormat@12
_SetVideoFormat@12:
	mov	cl,5
; _SetVideoFormat(16) = _SetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideoExtIn
; dword ptr [ebp+12]:  hvideoIn
; dword ptr [ebp+16]:  lpbmih
;
public II_SetVideoFormat@12
II_SetVideoFormat@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideoExtIn: dword->word
	push	word ptr [ebp+12]	;hvideoIn: dword->word
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _AllocateLockableBuffer@4
_AllocateLockableBuffer@4:
	mov	cl,4
; _AllocateLockableBuffer(16) = _AllocateLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  dwSize
;
public II_AllocateLockableBuffer@4
II_AllocateLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _LockBuffer@4
_LockBuffer@4:
	mov	cl,3
; _LockBuffer(16) = _LockBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_LockBuffer@4
II_LockBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _FreeLockableBuffer@4
_FreeLockableBuffer@4:
	mov	cl,1
	jmp	II_FreeLockableBuffer@4
public _UnlockBuffer@4
_UnlockBuffer@4:
	mov	cl,2
; _FreeLockableBuffer(16) = _FreeLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_FreeLockableBuffer@4
II_FreeLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _CloseVxDHandle@4
_CloseVxDHandle@4:
	mov	cl,0
; _CloseVxDHandle(16) = _CloseVxDHandle(32) {}
;
; dword ptr [ebp+8]:  pev
;
public II_CloseVxDHandle@4
II_CloseVxDHandle@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;pev: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef _CloseVxDHandle:far16
externDef _FreeLockableBuffer:far16
externDef _UnlockBuffer:far16
externDef _LockBuffer:far16
externDef _AllocateLockableBuffer:far16
externDef _SetVideoFormat:far16
externDef _GetVideoFormat:far16
externDef _GetVideoFormatSize:far16
externDef _UninitializeVideoStream:far16
externDef _InitializeVideoStream:far16
externDef _InitializeExternalVideoStream:far16
externDef _GetVideoPalette:far16
externDef _SendDriverMessage:far16
externDef _CloseDriver:far16
externDef _OpenDriver:far16


FT_thkTargetTable label word
	dw	offset _CloseVxDHandle
	dw	   seg _CloseVxDHandle
	dw	offset _FreeLockableBuffer
	dw	   seg _FreeLockableBuffer
	dw	offset _UnlockBuffer
	dw	   seg _UnlockBuffer
	dw	offset _LockBuffer
	dw	   seg _LockBuffer
	dw	offset _AllocateLockableBuffer
	dw	   seg _AllocateLockableBuffer
	dw	offset _SetVideoFormat
	dw	   seg _SetVideoFormat
	dw	offset _GetVideoFormat
	dw	   seg _GetVideoFormat
	dw	offset _GetVideoFormatSize
	dw	   seg _GetVideoFormatSize
	dw	offset _UninitializeVideoStream
	dw	   seg _UninitializeVideoStream
	dw	offset _InitializeVideoStream
	dw	   seg _InitializeVideoStream
	dw	offset _InitializeExternalVideoStream
	dw	   seg _InitializeExternalVideoStream
	dw	offset _GetVideoPalette
	dw	   seg _GetVideoPalette
	dw	offset _SendDriverMessage
	dw	   seg _SendDriverMessage
	dw	offset _CloseDriver
	dw	   seg _CloseDriver
	dw	offset _OpenDriver
	dw	   seg _OpenDriver




	.data

public thk_ThunkData16	;This symbol must be exported.
thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable
	dd	0	;First-time flag.



	.code 


externDef ThunkConnect16:far16

public thk_ThunkConnect16
thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk_ThunkData16
	push	offset thk_ThunkData16
	push	seg    thk_ThkData32
	push	offset thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk_ThkData32 label byte
	db	"thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\16\makefile.inc ===
C16_NAME = $(DEVROOT)\bin\c816\i386\cl -nologo
C16_FLAGS = $(C16_FLAGS) -I$(DEVROOT)\inc16 -I$(DEVROOT)\inc -Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 $(ASM_FLAGS)

!IF "$(BUILD_ALT_DIR)" == "d"
C16_FLAGS = $(C16_FLAGS) -Zi -DDEBUG
ASM_FLAGS = $(ASM_FLAGS) -Zi -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(ASM_FLAGS)
<<NOKEEP

{}.c{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(C16_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(C16_FLAGS)
<<NOKEEP
    @$(C16_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C16_FLAGS: =
)
<<NOKEEP


dcthk.asm: ..\thunks\dcthk.thk
     $(DEVROOT)\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk

$(O)\dcap16.res: dcap16.rc
    $(DEVROOT)\bin\c816\i386\rc -r -I $(DEVROOT)\inc16 -I $(ROOT)\h -fo $@ dcap16.rc

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib:	$(TARGETNAME).def
	@echo Undesirable - DCAP16.DLL is a 16-bit DLL always loaded dynamically

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp:	$(TARGETNAME).def
	@echo Undesirable - DCAP16.DLL is a 16-bit DLL always loaded dynamically

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).dll: $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(O)\$(TARGETNAME).res
	$(DEVROOT)\bin\c816\i386\link @<<
	$(OBJECTS) /align:0x1000 /nodefaultlib /NOE/MAP/NOD/AL:16/NOPACKC/ONERROR:NOEXE $(LINK16_FLAGS),
	$(TARGET),
	$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
	$(TARGETLIBS),
	$(TARGETNAME).def
<<
    $(DEVROOT)\bin\c816\i386\rc $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(PDBCOPY_CMD)
    $(DBGCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\debug.cpp ===
#include "Precomp.h"

#ifdef _DEBUG

HDBGZONE  ghDbgZoneCap = NULL;

int WINAPI CapDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("DCAP", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\dcthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:55 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk 

	TITLE	$dcthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk_ThunkData32	;This symbol must be exported.
thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk - offset thk_ThunkData32
	dd	offset FT_Prolog_thk - offset thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk_ThunkConnect32@16
thk_ThunkConnect32@16:
	pop	edx
	push	offset thk_ThkData16
	push	offset thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk_ThkData16 label byte
	db	"thk_ThunkData16",0


		


pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public _OpenDriver@12
_OpenDriver@12:
	mov	cl,14
; _OpenDriver(16) = _OpenDriver(32) {}
;
; dword ptr [ebp+8]:  lpDriverName
; dword ptr [ebp+12]:  dwReserved
; dword ptr [ebp+16]:  lpvop
;
public II_OpenDriver@12
II_OpenDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	dword ptr [ebp+12]	;dwReserved: dword->dword
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _CloseDriver@12
_CloseDriver@12:
	mov	cl,13
; _CloseDriver(16) = _CloseDriver(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  lpReserved1
; dword ptr [ebp+16]:  lpReserved2
;
public II_CloseDriver@12
II_CloseDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;lpReserved1: dword->dword
	push	dword ptr [ebp+16]	;lpReserved2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	12





;
public _SendDriverMessage@16
_SendDriverMessage@16:
	mov	cl,12
; _SendDriverMessage(16) = _SendDriverMessage(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  msg
; dword ptr [ebp+16]:  param1
; dword ptr [ebp+20]:  param2
;
public II_SendDriverMessage@16
II_SendDriverMessage@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;msg: dword->dword
	push	dword ptr [ebp+16]	;param1: dword->dword
	push	dword ptr [ebp+20]	;param2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	16





;
public _GetVideoPalette@12
_GetVideoPalette@12:
	mov	cl,11
; _GetVideoPalette(16) = _GetVideoPalette(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpcp
; dword ptr [ebp+16]:  dwcbSize
;
public II_GetVideoPalette@12
II_GetVideoPalette@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;dwcbSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public _InitializeVideoStream@12
_InitializeVideoStream@12:
	mov	cl,9
; _InitializeVideoStream(16) = _InitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  dwMicroSecPerFrame
; dword ptr [ebp+16]:  dwEvent
;
public II_InitializeVideoStream@12
II_InitializeVideoStream@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	push	dword ptr [ebp+12]	;dwMicroSecPerFrame: dword->dword
	push	dword ptr [ebp+16]	;dwEvent: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	12





;
public _UninitializeVideoStream@4
_UninitializeVideoStream@4:
	mov	cl,8
	jmp	II_UninitializeVideoStream@4
public _InitializeExternalVideoStream@4
_InitializeExternalVideoStream@4:
	mov	cl,10
; _UninitializeVideoStream(16) = _UninitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_UninitializeVideoStream@4
II_UninitializeVideoStream@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _GetVideoFormatSize@4
_GetVideoFormatSize@4:
	mov	cl,7
; _GetVideoFormatSize(16) = _GetVideoFormatSize(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_GetVideoFormatSize@4
II_GetVideoFormatSize@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public _GetVideoFormat@8
_GetVideoFormat@8:
	mov	cl,6
; _GetVideoFormat(16) = _GetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpbmih
;
public II_GetVideoFormat@8
II_GetVideoFormat@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public _SetVideoFormat@12
_SetVideoFormat@12:
	mov	cl,5
; _SetVideoFormat(16) = _SetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideoExtIn
; dword ptr [ebp+12]:  hvideoIn
; dword ptr [ebp+16]:  lpbmih
;
public II_SetVideoFormat@12
II_SetVideoFormat@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideoExtIn: dword->word
	push	word ptr [ebp+12]	;hvideoIn: dword->word
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _AllocateLockableBuffer@4
_AllocateLockableBuffer@4:
	mov	cl,4
; _AllocateLockableBuffer(16) = _AllocateLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  dwSize
;
public II_AllocateLockableBuffer@4
II_AllocateLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _LockBuffer@4
_LockBuffer@4:
	mov	cl,3
; _LockBuffer(16) = _LockBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_LockBuffer@4
II_LockBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _FreeLockableBuffer@4
_FreeLockableBuffer@4:
	mov	cl,1
	jmp	II_FreeLockableBuffer@4
public _UnlockBuffer@4
_UnlockBuffer@4:
	mov	cl,2
; _FreeLockableBuffer(16) = _FreeLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_FreeLockableBuffer@4
II_FreeLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _CloseVxDHandle@4
_CloseVxDHandle@4:
	mov	cl,0
; _CloseVxDHandle(16) = _CloseVxDHandle(32) {}
;
; dword ptr [ebp+8]:  pev
;
public II_CloseVxDHandle@4
II_CloseVxDHandle@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;pev: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef _CloseVxDHandle:far16
externDef _FreeLockableBuffer:far16
externDef _UnlockBuffer:far16
externDef _LockBuffer:far16
externDef _AllocateLockableBuffer:far16
externDef _SetVideoFormat:far16
externDef _GetVideoFormat:far16
externDef _GetVideoFormatSize:far16
externDef _UninitializeVideoStream:far16
externDef _InitializeVideoStream:far16
externDef _InitializeExternalVideoStream:far16
externDef _GetVideoPalette:far16
externDef _SendDriverMessage:far16
externDef _CloseDriver:far16
externDef _OpenDriver:far16


FT_thkTargetTable label word
	dw	offset _CloseVxDHandle
	dw	   seg _CloseVxDHandle
	dw	offset _FreeLockableBuffer
	dw	   seg _FreeLockableBuffer
	dw	offset _UnlockBuffer
	dw	   seg _UnlockBuffer
	dw	offset _LockBuffer
	dw	   seg _LockBuffer
	dw	offset _AllocateLockableBuffer
	dw	   seg _AllocateLockableBuffer
	dw	offset _SetVideoFormat
	dw	   seg _SetVideoFormat
	dw	offset _GetVideoFormat
	dw	   seg _GetVideoFormat
	dw	offset _GetVideoFormatSize
	dw	   seg _GetVideoFormatSize
	dw	offset _UninitializeVideoStream
	dw	   seg _UninitializeVideoStream
	dw	offset _InitializeVideoStream
	dw	   seg _InitializeVideoStream
	dw	offset _InitializeExternalVideoStream
	dw	   seg _InitializeExternalVideoStream
	dw	offset _GetVideoPalette
	dw	   seg _GetVideoPalette
	dw	offset _SendDriverMessage
	dw	   seg _SendDriverMessage
	dw	offset _CloseDriver
	dw	   seg _CloseDriver
	dw	offset _OpenDriver
	dw	   seg _OpenDriver




	.data

public thk_ThunkData16	;This symbol must be exported.
thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable
	dd	0	;First-time flag.



	.code 


externDef ThunkConnect16:far16

public thk_ThunkConnect16
thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk_ThunkData16
	push	offset thk_ThunkData16
	push	seg    thk_ThkData32
	push	offset thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk_ThkData32 label byte
	db	"thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\16\dcap16.c ===
//  DCAP16.C
//
//  Created 31-Jul-96 [JonT]

#include <windows.h>
#define NODRAWDIB
#define NOCOMPMAN
#define NOAVIFILE
#define NOMSACM
#define NOAVIFMT
#define NOMCIWND
#define NOAVICAP
#include <vfw.h>
#include "..\inc\idcap.h"
#include "..\inc\msviddrv.h"

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))

// Equates
#define DCAP16API   __far __pascal __loadds
#define DCAP16LOCAL __near __pascal
#define DLL_PROCESS_ATTACH  1       // Not in 16-bit windows.h



#ifdef DEBUG_SPEW_VERBOSE
#define DEBUGSPEW(str)	DebugSpew((str))
#else
#define DEBUGSPEW(str)
#endif


// Structures thunked down
typedef struct _CAPTUREPALETTE
{
    WORD wVersion;
    WORD wcEntries;
    PALETTEENTRY pe[256];
} CAPTUREPALETTE, FAR* LPCAPTUREPALETTE;

// Special thunking prototypes
BOOL DCAP16API __export DllEntryPoint(DWORD dwReason,
         WORD  hInst, WORD  wDS, WORD  wHeapSize, DWORD dwReserved1,
         WORD  wReserved2);
BOOL __far __pascal thk_ThunkConnect16(LPSTR pszDll16, LPSTR pszDll32,
    WORD  hInst, DWORD dwReason);

// Helper functions
WORD DCAP16LOCAL    ReturnSel(BOOL fCS);
DWORD DCAP16LOCAL   GetVxDEntrypoint(void);
int DCAP16LOCAL     SetWin32Event(DWORD dwEvent);
void DCAP16API      FrameCallback(HVIDEO hvideo, WORD wMsg, LPLOCKEDINFO lpli,
                        LPVIDEOHDR lpvh, DWORD dwParam2);
void DCAP16LOCAL    ZeroMemory(LPSTR lp, WORD wSize);

// Globals
    HANDLE g_hInst;
    DWORD g_dwEntrypoint;

    LPLOCKEDINFO g_lpli;

//  LibMain

int
CALLBACK
LibMain(
    HINSTANCE hinst,
    WORD wDataSeg,
    WORD cbHeapSize,
    LPSTR lpszCmdLine
    )
{
    // Save global hinst
    g_hInst = hinst;
	
    // Still necessary?
    if (cbHeapSize)
        UnlockData(wDataSeg);

    return TRUE;
}


//  DllEntryPoint

BOOL
__far __pascal __export __loadds
DllEntryPoint(
    DWORD dwReason,
    WORD  hInst,
    WORD  wDS,
    WORD  wHeapSize,
    DWORD dwReserved1,
    WORD  wReserved2
    )
{
    if (!thk_ThunkConnect16("DCAP16.DLL", "DCAP32.DLL", hInst, dwReason))
    {
        DebugSpew("DllEntrypoint: thk_ThunkConnect16 failed!");
        return FALSE;
    }

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_dwEntrypoint = GetVxDEntrypoint();
        break;
    }

    return TRUE;
}


// APIs


//  _InitializeExternalVideoStream
//      Initializes a video stream for the external channel. We don't
//      have to deal with locking or ever set a callback on this channel.

BOOL
DCAP16API
_InitializeExternalVideoStream(
    HANDLE hvideo
	)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    vsip.dwMicroSecPerFrame = 0;    // Ignored by driver for this channel
    vsip.dwCallback = NULL;         // No callback for now
    vsip.dwCallbackInst = NULL;
    vsip.dwFlags = 0;
    vsip.hVideo = (DWORD)hvideo;

    return !SendDriverMessage(hvideo, DVM_STREAM_INIT,
        (DWORD) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
        (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}


void
DCAP16API
FrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    LPLOCKEDINFO lpli,      // Note that this is our instance data
    LPVIDEOHDR lpvh,
    DWORD dwParam2
    )
{
    LPCAPBUFFER lpcbuf;
    
    if (!lpli) {
        // Connectix hack: driver doesn't pass our instance data, so we keep it global        
        lpli = g_lpli;
    }
    
    // The client can put us in shutdown mode. This means that we will not queue
    // any more buffers onto the ready queue, even if they were ready.
    // This keeps the buffers from being given back to the driver, so it will eventually
    // stop streaming. Of course, it will spew errors, but we just ignore these.
    // Shutdown mode is defined when there is no event ready to signal.
    if (!lpli->pevWait)
        return;

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGSPEW("Setting hcd->hevWait - no data\r\n");
        SetWin32Event(lpli->pevWait);
        return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (lpli->lp1616Tail != lpli->lp1616Current)
        lpli->lp1616Tail = lpli->lp1616Tail->lp1616Prev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!lpli->lp1616Tail)
        lpli->lp1616Head = NULL;

    // Add the new buffer to the ready queue
    lpcbuf = (LPCAPBUFFER)((LPBYTE)lpvh - ((LPBYTE)&lpcbuf->vh - (LPBYTE)lpcbuf));

    lpcbuf->lp1616Next = lpli->lp1616Head;
    lpcbuf->lp1616Prev = NULL;
    if (lpli->lp1616Head)
        lpli->lp1616Head->lp1616Prev = lpcbuf;
    else
        lpli->lp1616Tail = lpcbuf;
    lpli->lp1616Head = lpcbuf;

#if 1
    if (lpli->lp1616Current) {
    	if (!(lpli->dwFlags & LIF_STOPSTREAM)) {
    	    // if client hasn't consumed last frame, then release it
    	    lpvh = &lpli->lp1616Current->vh;
    	    lpli->lp1616Current = lpli->lp1616Current->lp1616Prev;
    		DEBUGSPEW("Sending DVM_STREAM_ADDBUFFER");
			// Signal that the application is done with the buffer
			lpvh->dwFlags &= ~VHDR_DONE;
    	    if (SendDriverMessage(hvideo, DVM_STREAM_ADDBUFFER, *((DWORD*)&lpvh), sizeof(VIDEOHDR)) != 0)
    		DebugSpew("attempt to reuse unconsumed buffer failed");
    	}
    }
    else {
#else
    if (!lpli->lp1616Current) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
        lpli->lp1616Current = lpli->lp1616Tail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGSPEW("Setting hcd->hevWait - some data\r\n");
    SetWin32Event(lpli->pevWait);
}


//  _InitializeVideoStream
//      Initializes a driver's video stream for the video in channel.
//      This requires us to pagelock the memory for everything that will
//      be touched at interrupt time.

BOOL
DCAP16API
_InitializeVideoStream(
	HANDLE hvideo,
    DWORD dwMicroSecPerFrame,
    LPLOCKEDINFO lpli
	)
{
    DWORD dwRet;
    WORD wsel;
    VIDEO_STREAM_INIT_PARMS vsip;

    ZeroMemory((LPSTR)&vsip, sizeof (VIDEO_STREAM_INIT_PARMS));
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD)FrameCallback;
    vsip.dwCallbackInst = (DWORD)lpli;      // LOCKEDINFO* is instance data for callback
    vsip.dwFlags = CALLBACK_FUNCTION;
    vsip.hVideo = (DWORD)hvideo;

    g_lpli = lpli;
    
    dwRet = SendDriverMessage(hvideo, DVM_STREAM_INIT,
        (DWORD) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
        (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));

    // If we succeeded, we now lock down our code and data
    if (dwRet == 0)
    {
        // Lock CS
        wsel = ReturnSel(TRUE);
        GlobalSmartPageLock(wsel);

        // Lock DS
        wsel = ReturnSel(FALSE);
        GlobalSmartPageLock(wsel);

        return TRUE;
    }

    return FALSE;
}


//  _UninitializeVideoStream
//      Tells the driver we are done streaming. It also unlocks the memory
//      we locked for interrupt time access.

BOOL
DCAP16API
_UninitializeVideoStream(
	HANDLE hvideo
	)
{
    DWORD dwRet;
    WORD wsel;

    dwRet = SendDriverMessage(hvideo, DVM_STREAM_FINI, 0L, 0L);

    // Unlock our code and data
    if (dwRet == 0)
    {
        // Unlock CS
        wsel = ReturnSel(TRUE);
        GlobalSmartPageUnlock(wsel);

        // Unlock DS
        wsel = ReturnSel(FALSE);
        GlobalSmartPageUnlock(wsel);

        return TRUE;
    }

    return FALSE;
}


//  _GetVideoPalette
//      Get the current palette from the driver

HPALETTE
DCAP16API
_GetVideoPalette(
    HANDLE hvideo,
    LPCAPTUREPALETTE lpcp,
    DWORD dwcbSize
    )
{
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = (LPVOID)lpcp;
    vcp.dwSize1 = dwcbSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0;

    return !SendDriverMessage(hvideo, DVM_PALETTE,
        (DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
        (DWORD)(LPVIDEOCONFIGPARMS)&vcp);
}


//  _GetVideoFormatSize
//        Gets the current format header size required by driver

DWORD
DCAP16API
_GetVideoFormatSize(
    HANDLE hvideo
    )
{
	DWORD bufsize;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = &bufsize;
    vcp.lpData1 = NULL;
    vcp.dwSize1 = 0L;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

#if 0
    // it makes sense to query if DVM_FORMAT is available, but not all drivers support it!
	if (SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERY),
							(LPARAM)(LPVOID)&vcp) == DV_ERR_OK) {
#endif
		SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE),
							(LPARAM)(LPVOID)&vcp);
        if (!bufsize)
            bufsize = sizeof(BITMAPINFOHEADER);
		return bufsize;
#if 0
    } else
        return sizeof(BITMAPINFOHEADER);
#endif
}
        
//  _GetVideoFormat
//      Gets the current format (dib header) the capture device is blting to

BOOL
DCAP16API
_GetVideoFormat(
    HANDLE hvideo,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL res;
    VIDEOCONFIGPARMS vcp;

    if (!lpbmih->biSize)
        lpbmih->biSize = sizeof (BITMAPINFOHEADER);
        
    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    res = !SendDriverMessage(hvideo, DVM_FORMAT,
			(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
			(LPARAM)(LPVOID)&vcp);
	if (res) {
	    // hack for Connectix QuickCam - set format needs to be called
		//   to set internal globals so that streaming can be enabled
		SendDriverMessage(hvideo, DVM_FORMAT, (LPARAM)(DWORD)VIDEO_CONFIGURE_SET,
		        	        (LPARAM)(LPVOID)&vcp);
	}
	return res;
}


//  _SetVideoFormat
//      Sets the format (dib header) the capture device is blting to.

BOOL
DCAP16API
_SetVideoFormat(
    HANDLE hvideoExtIn,
    HANDLE hvideoIn,
    LPBITMAPINFOHEADER lpbmih
    )
{
    RECT rect;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    // See if the driver likes the format
    if (SendDriverMessage(hvideoIn, DVM_FORMAT, (LPARAM)(DWORD)VIDEO_CONFIGURE_SET,
        (LPARAM)(LPVOID)&vcp))
        return FALSE;

    // Set the rectangles
    rect.left = rect.top = 0;
    rect.right = (WORD)lpbmih->biWidth;
    rect.bottom = (WORD)lpbmih->biHeight;
    SendDriverMessage(hvideoExtIn, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
    SendDriverMessage(hvideoIn, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);

    return TRUE;
}


//  _AllocateLockableBuffer
//      Allocates memory that can be page locked. Just returns the selector.

WORD
DCAP16API
_AllocateLockableBuffer(
    DWORD dwSize
    )
{
    return GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwSize);
}


//  _LockBuffer
//      Page locks (if necessary) a buffer allocated with _AllocateLockableBuffer.

BOOL
DCAP16API
_LockBuffer(
    WORD wBuffer
    )
{
    return GlobalSmartPageLock(wBuffer);
}

//  _UnlockBuffer
//      Unlocks a buffer locked with _LockBuffer.

void
DCAP16API
_UnlockBuffer(
    WORD wBuffer
    )
{
    GlobalSmartPageUnlock(wBuffer);
}


//  _FreeLockableBuffer
//      Frees a buffer allocated with _AllocateLockableBuffer.

void
DCAP16API
_FreeLockableBuffer(
    WORD wBuffer
    )
{
    GlobalFree(wBuffer);
}


//  _SendDriverMessage
//      Sends a generic, dword only parameters, message to the driver channel of choice

DWORD
DCAP16API
_SendDriverMessage(
    HVIDEO hvideo,
    DWORD wMessage,
    DWORD param1,
    DWORD param2
    )
{
    return SendDriverMessage(hvideo, (WORD)wMessage, param1, param2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\makefile.inc ===
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 -Zi -coff $(ASM_FLAGS)

!IF "$(BUILD_ALT_DIR)" == "d"
C16_FLAGS = $(C16_FLAGS) -Zi -DDEBUG
ASM_FLAGS = $(ASM_FLAGS) -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(ASM_FLAGS)
<<NOKEEP

dcthk.asm: ..\thunks\dcthk.thk
     $(DEVROOT)\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\dcap32.cpp ===
//
//  Created 31-Jul-96 [JonT]

// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

#ifndef WIDTHBYTES
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)
#endif

#ifdef _DEBUG
static PTCHAR _rgZonesCap[] = {
	TEXT("dcap"),
	TEXT("Init"),
	TEXT("Streaming"),
	TEXT("Callback"),
	TEXT("Dialogs"),
	TEXT("Trace")
};
#endif

#ifndef __NT_BUILD__
extern "C" {
// Special thunk prototype
BOOL    thk_ThunkConnect32(LPSTR pszDll16, LPSTR pszDll32,
        HINSTANCE hInst, DWORD dwReason);

//; Magic Function code values for DeviceIOControl code.
//DCAPVXD_THREADTIMESERVICE equ	101h
//DCAPVXD_R0THREADIDSERVICE equ 102h
#define DCAPVXD_THREADTIMESERVICE 0x101
#define DCAPVXD_R0THREADIDSERVICE 0x102


// KERNEL32 prototypes (not in headers but are exported by name on Win95)
void* WINAPI    MapSL(DWORD dw1616Ptr);
HANDLE WINAPI   OpenVxDHandle(HANDLE h);
}
#endif

// Helper function prototypes
BOOL    initializeCaptureDeviceList(void);
HVIDEO  openVideoChannel(DWORD dwDeviceID, DWORD dwFlags);
BOOL    allocateBuffers(HCAPDEV hcd, int nBuffers);
void    freeBuffers(HCAPDEV hcd);

// Globals
	HINSTANCE g_hInst;
    int g_cDevices;
    LPINTERNALCAPDEV g_aCapDevices[DCAP_MAX_DEVICES];

	BOOL g_fInitCapDevList;
#define INIT_CAP_DEV_LIST() if (g_fInitCapDevList) { initializeCaptureDeviceList(); }

#ifndef __NT_BUILD__
    HANDLE s_hVxD = NULL;
#endif //__NT_BUILD__

// Strings
#ifdef __NT_BUILD__
    char g_szVFWRegKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32";
    char g_szVFWRegDescKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc";
    char g_szDriverName[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "WDM Video For Windows Capture Driver (Win32)";
    char g_szVfWToWDMMapperName[] = "VfWWDM32.dll";
#endif
#else
    char g_szVFWRegKey[] = "SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo";
    char g_szRegDescription[] = "Description";
    char g_szRegName[] = "Driver";
    char g_szRegDisabled[] = "Disabled";
    char g_szDevNode[] = "DevNode";
    char g_szSystemIni[] = "system.ini";
    char g_szDriverSection[] = "drivers";
    char g_szDriverKey[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "VfW MM 16bit Driver for WDM V. Cap. Devices";
    char g_szVfWToWDMMapperName[] = "vfwwdm.drv";
#endif
#endif
    char g_szMSOfficeCamcorderDescription[] = "Screen Capture Device Driver for AVI";
    char g_szMSOfficeCamcorderName[] = "Gdicap97.drv";

    char g_szVerQueryForDesc[] = "\\StringFileInfo\\040904E4\\FileDescription";


void DoClose(HCAPDEV hcd);

#define ENTER_DCAP(hcd) InterlockedIncrement(&(hcd)->busyCount);
#define LEAVE_DCAP(hcd) if (InterlockedDecrement(&(hcd)->busyCount) == 0) DoClose((hcd));

//  DllEntryPoint

extern "C" BOOL
DllEntryPoint(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    static int s_nProcesses = 0;

	FX_ENTRY("DllEntryPoint");

#ifndef __NT_BUILD__

    // We want to load the VxD even before initializing the thunks
    // because the 16-bit half initializes the VxD during the thk_ThunkConnect32 call
    if (!s_hVxD)
    {
        s_hVxD = CreateFile("\\\\.\\DCAPVXD.VXD", 0,0,0,0, FILE_FLAG_DELETE_ON_CLOSE, 0);
        if (s_hVxD == INVALID_HANDLE_VALUE)
        {
			ERRORMESSAGE(("%s: Failure loading VxD - Fatal\r\n", _fx_));
            return FALSE;
        }
    }

    // Initialize the thunks
    if (!(thk_ThunkConnect32("DCAP16.DLL", "DCAP32.DLL", hInst, dwReason)))
    {
		ERRORMESSAGE(("%s: thk_ThunkConnect32 failed!\r\n", _fx_));
        return FALSE;
    }
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

		// Save global hinst
		g_hInst = hInst;

        // Only initialize on the first DLL load
        if (s_nProcesses++ == 0)
        {
			DBGINIT(&ghDbgZoneCap, _rgZonesCap);

            DBG_INIT_MEMORY_TRACKING(hInst);

			g_fInitCapDevList = TRUE;
        }
        else
            return FALSE;   // fail to load multiple instances
        break;

    case DLL_PROCESS_DETACH:
        if (--s_nProcesses == 0)    // Are we going away?
        {
#ifndef __NT_BUILD__
            CloseHandle(s_hVxD);
            s_hVxD = NULL;
#endif
            DBG_CHECK_MEMORY_TRACKING(hInst);

			DBGDEINIT(&ghDbgZoneCap);
        }
        break;
    }

    return TRUE;
}


void GetVersionData (LPINTERNALCAPDEV lpcd)
{
    int j;
    DWORD dwVerInfoSize;
    LPSTR lpstrInfo;
    LPSTR lpDesc;

    // Version number
    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(lpcd->szDeviceName, NULL);
    if (dwVerInfoSize && (lpstrInfo  = (LPSTR)LocalAlloc(LPTR, dwVerInfoSize))) {
        // Read from the file into our block
        if (GetFileVersionInfo(lpcd->szDeviceName, 0L, dwVerInfoSize, lpstrInfo)) {
            lpDesc = NULL;
            if (VerQueryValue(lpstrInfo, g_szVerQueryForDesc, (LPVOID *)&lpDesc, (PUINT)&j) && lpDesc) {
                lstrcpyn(lpcd->szDeviceDescription, lpDesc, j);
                    wsprintf(lpcd->szDeviceVersion, TEXT("Version:  %d.%d.%d.%d"),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS));
            }
        }
        LocalFree(lpstrInfo);
    }
}


#ifdef __NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry
//      Returns FALSE iff there are no video devices.
BOOL
initializeCaptureDeviceList(void)
{
	HKEY hkeyVFW, hkeyVFWdesc;
	DWORD dwType;
	DWORD dwSize;
	int i;
	LPINTERNALCAPDEV lpcd;
	HCAPDEV hCapDev;

	FX_ENTRY("initializeCaptureDeviceList");

	// Clear the entire array and start with zero devices
	g_cDevices = 0;
	ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// Open the reg key in question
	if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
	{
		if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegDescKey, &hkeyVFWdesc) != ERROR_SUCCESS)
			hkeyVFWdesc = 0;

		lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));

		if (lpcd)
		{
			// Loop through all possible VFW drivers in registry
			for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
			{
				// Create the key name
				if (i == 0)
					g_szDriverName[sizeof (g_szDriverName) - 2] = 0;
				else
					g_szDriverName[sizeof (g_szDriverName) - 2] = (BYTE)i + '0';

				// Name
				dwSize = sizeof(lpcd->szDeviceName);
				if (RegQueryValueEx(hkeyVFW, g_szDriverName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize) == ERROR_SUCCESS)
				{
					// Description
					if (hkeyVFWdesc)
					{
						dwSize = sizeof(lpcd->szDeviceDescription);
						RegQueryValueEx(hkeyVFWdesc, lpcd->szDeviceName, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);
					}
					else
						lstrcpy (lpcd->szDeviceDescription, lpcd->szDeviceName);

					// Devnode
					lpcd->dwDevNode = 0;
					lpcd->nDeviceIndex = g_cDevices;

					GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
					// Remove bogus Camcorder capture device from list of devices shown to the user
					// The Camcorder driver is a fake capture device used by the MS Office Camcorder
					// to capture screen activity to an AVI file. This not a legit capture device driver
					// and is extremely buggy.
					// We also remove the VfW to WDM mapper if we are on NT5.
					if (lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName) && lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName))
					{
#endif
						g_aCapDevices[g_cDevices] = lpcd;
						g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
						g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
					}
					else
						LocalFree(lpcd);
#endif

					lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
					if (!lpcd)
					{
						ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
						break;  // break out of the FOR loop
					}
				}
			}
		}
		else
		{
			ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
		}

		if (lpcd)
			LocalFree (lpcd);   // free the extra buffer

		RegCloseKey(hkeyVFW);
		if (hkeyVFWdesc)
			RegCloseKey(hkeyVFWdesc);
	}

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

	return TRUE;
}

#else //__NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry and
//      from SYSTEM.INI.
//      Returns FALSE iff there are no video devices.

BOOL
initializeCaptureDeviceList(void)
{
    int i, j, index;
    HKEY hkeyVFW;
    HKEY hkeyEnum;
    DWORD dwType;
    DWORD dwSize;
    LPINTERNALCAPDEV lpcd;
    char szEnumName[MAX_PATH];
    char szDisabled[3];
    HCAPDEV hCapDev;
	OSVERSIONINFO osvInfo = {0};

	FX_ENTRY("initializeCaptureDeviceList");

    // Clear the entire array and start with zero devices
    g_cDevices = 0;
    ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// If we are on a version on Win95 (OSRx) use the mapper to talk to WDM devices.
	// The WDM drivers used on OSR2 are not stream class minidrivers so we fail
	// to handle them properly. Let the mapper do this for us.
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvInfo);

    // Open the reg key in question
    if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
    {
        // Loop through all possible VFW drivers in registry
        for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
        {
            // See if the key is there and if not, we're done. Note that registry
            // keys have to be sequential, no holes allowed since the only way
            // to query is sequential...
            if (RegEnumKey(hkeyVFW, i, szEnumName, MAX_PATH) != ERROR_SUCCESS ||
                RegOpenKey(hkeyVFW, szEnumName, &hkeyEnum) != ERROR_SUCCESS)
                break;

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }

            // Description
            dwSize = sizeof (lpcd->szDeviceDescription);
            RegQueryValueEx(hkeyEnum, g_szRegDescription, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);

            // Name
            dwSize = sizeof (lpcd->szDeviceName);
            RegQueryValueEx(hkeyEnum, g_szRegName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize);

            // Disabled
            dwSize = sizeof (szDisabled);
            if (RegQueryValueEx(hkeyEnum, g_szRegDisabled, NULL, &dwType, (LPBYTE)szDisabled, &dwSize) == ERROR_SUCCESS &&
                szDisabled[0] == '1')
                lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

            // Devnode
            dwSize = sizeof (DWORD);
            RegQueryValueEx(hkeyEnum, g_szDevNode, NULL, &dwType, (BYTE*)&lpcd->dwDevNode, &dwSize);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

            RegCloseKey(hkeyEnum);
        }

        RegCloseKey(hkeyVFW);
    }

    // Now get the rest from system.ini, if any
    for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
    {
        // Create the key name
        if (i == 0)
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = 0;
        else
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = (BYTE)i + '0';

        // See if there's a profile string
        if (GetPrivateProfileString(g_szDriverSection, g_szDriverKey, "",
            szEnumName, MAX_PATH, g_szSystemIni))
        {
            // First check to see if this is a dupe. If it is, go no further.
            if (g_cDevices)
            {
                for (j = 0 ; j < g_cDevices ; j++)
                    if (!lstrcmpi(g_aCapDevices[j]->szDeviceName, szEnumName))
                        goto NextDriver;
            }

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }
            // We have a unique name, copy in the driver name and find the description
            // by reading the driver's versioninfo resource.
            lstrcpy(lpcd->szDeviceName, szEnumName);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

        }
NextDriver: ;
    }

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

    return TRUE;
}
#endif //__NT_BUILD__


//  GetNumCaptureDevice
//      Returns the number of *ENABLED* capture devices

/****************************************************************************
 *  @doc EXTERNAL DCAP32
 *
 *  @func int DCAPI | GetNumCaptureDevices | This function returns the number
 *    of *ENABLED* capture devices.
 *
 *  @rdesc Returns the number of *ENABLE* capture devices.
 ***************************************************************************/
int
DCAPI
GetNumCaptureDevices()
{
	int nNumCapDevices = 0;
	int nDeviceIndex = 0;

	INIT_CAP_DEV_LIST();

	while (nDeviceIndex < g_cDevices)
		if (!(g_aCapDevices[nDeviceIndex++]->dwFlags & CAPTURE_DEVICE_DISABLED))
			nNumCapDevices++;

    return nNumCapDevices;
}


//  FindFirstCaptureDevice
//      Returns the first capture device available that matches the string
//      or the first one registered if szDeviceDescription is NULL

BOOL
DCAPI
FindFirstCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    char* szDeviceDescription
    )
{
    int i;
    static HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Validate size
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

// hack to avoid quickcam driver problem when hardware not installed
    if (g_cDevices && !hcap) {
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);
        if ((i < g_cDevices) && (hcap = OpenCaptureDevice(i))) {
            CloseCaptureDevice (hcap);
        }
        else {
			if (i < g_cDevices) {
				g_aCapDevices[i]->dwFlags |= CAPTURE_DEVICE_DISABLED;
#ifdef _DEBUG
				OutputDebugString((i == 0) ? "DCAP32: 1st capture device fails to open!\r\n" : (i == 1) ? "DCAP32: 2nd capture device fails to open!\r\n" : (i == 2) ? "DCAP32: 3rd capture device fails to open!\r\n" : "DCAP32: 4th capture device fails to open!\r\n");
#endif
			}
        }
    }

    // Search if necessary
    if (szDeviceDescription)
    {
        for (i = 0 ; i < g_cDevices ; i++)
            if (!lstrcmpi(g_aCapDevices[i]->szDeviceDescription, szDeviceDescription) &&
                !(g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED))
                break;
    }
    else
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);

    // Return the info
    if (i == g_cDevices)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }
    else {
        lpfcd->nDeviceIndex = i;
        lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
        lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[i]->szDeviceDescription);
        lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[i]->szDeviceVersion);
        return TRUE;
    }
}


//  FindFirstCaptureDeviceByIndex
//      Returns the device with the specified index.

BOOL
DCAPI
FindFirstCaptureDeviceByIndex(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    int nDeviceIndex
    )
{
	INIT_CAP_DEV_LIST();

    // Validate size and index
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE) ||
        nDeviceIndex >= g_cDevices || (nDeviceIndex < 0) ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Return the info
    lpfcd->nDeviceIndex = nDeviceIndex;
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  FindNextCaptureDevice
//      Returns the next capture device in list.

BOOL
DCAPI
FindNextCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd
    )
{
    HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Parameter validate the passed in structure
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    while (++lpfcd->nDeviceIndex < g_cDevices)
	{
		if ((!(g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED)))
		{
			if (g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_OPEN)
				break;
			else
			{
				if (hcap = OpenCaptureDevice(lpfcd->nDeviceIndex))
				{
					CloseCaptureDevice (hcap);
					break;
				}
				else
					g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags |= CAPTURE_DEVICE_DISABLED;
			}
		}
	}

    // See if we're at the end
    if (lpfcd->nDeviceIndex >= g_cDevices)
    {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    // Otherwise, fill in the info for the next one
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  OpenCaptureDevice

HCAPDEV
DCAPI
OpenCaptureDevice(
    int nDeviceIndex
    )
{
    LPINTERNALCAPDEV hcd;
    LPBITMAPINFOHEADER lpbmih = NULL;
    DWORD err, dwLen;
    BOOL fl;

	FX_ENTRY("OpenCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    // Validate the device index
    if ((unsigned)nDeviceIndex >= (unsigned)g_cDevices ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & (CAPTURE_DEVICE_DISABLED | CAPTURE_DEVICE_OPEN))) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    hcd = g_aCapDevices[nDeviceIndex];
    hcd->busyCount = 1;                 // we start at 1 to say that we're open
                                        // DoClose happens when count goes to 0

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifndef __NT_BUILD__
		// Allocate some memory we can lock for the LOCKEDINFO structure
		hcd->wselLockedInfo = _AllocateLockableBuffer(sizeof (LOCKEDINFO));
		if (!hcd->wselLockedInfo) {
			err = ERROR_OUTOFMEMORY;
			goto Error;
		}

		// Do our own thunking so we can track the selector for this buffer
		hcd->lpli = (LPLOCKEDINFO)MapSL(((DWORD)hcd->wselLockedInfo) << 16);
#endif

		// Open the necessary video channels
		if (!(hcd->hvideoIn = openVideoChannel(nDeviceIndex, VIDEO_IN)) ||
			!(hcd->hvideoCapture = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALIN)))
		{
			ERRORMESSAGE(("%s: Couldn't open video channel(s)\r\n", _fx_));
			if (hcd->hvideoIn)
				_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALOUT))
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device supports overlay!\r\n", _fx_));
		}
		else
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device does not support overlay\r\n", _fx_));
		}
#endif
	}
	else
	{
		if (!WDMOpenDevice(nDeviceIndex))
		{
			ERRORMESSAGE(("%s: Couldn't open WDM device\r\n", _fx_));
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}
	}

    hcd->dwFlags |= CAPTURE_DEVICE_OPEN;

    // Get the initial format and set the values
    dwLen = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen)) {
        lpbmih->biSize = dwLen;
        fl = GetCaptureDeviceFormat(hcd, lpbmih);
        //If we can't get a format, or height and/or width are 0, don't use this device
        if (!fl || lpbmih->biWidth == 0 || lpbmih->biHeight == 0) {
			ERRORMESSAGE(("%s: GetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
        fl = SetCaptureDeviceFormat(hcd, lpbmih, 0, 0);
        if (!fl) {
			ERRORMESSAGE(("%s: SetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
#if 0
        _SetCaptureRect(hcd->hvideoIn, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_SRC_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
#endif
        LocalFree((HANDLE)lpbmih);
    } else {
        err = ERROR_OUTOFMEMORY;
        goto Error;
    }

	// Keep a stream running all the time on EXTERNALIN (capture->frame buffer).
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay)
			_InitializeExternalVideoStream(hcd->hvideoOverlay);
#else
		_InitializeExternalVideoStream(hcd->hvideoCapture);
#endif

#ifndef __NT_BUILD__
		// Lock our structure so it can be touched at interrupt time
		_LockBuffer(hcd->wselLockedInfo);
#endif
	}

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hcd;

Error:
    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;
    if (lpbmih) {
        LocalFree((HANDLE)lpbmih);
        lpbmih = NULL;
    }
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		if (hcd->hvideoIn) {
			_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			hcd->hvideoIn = NULL;
		}
		if (hcd->hvideoCapture) {
			_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0);
			hcd->hvideoCapture = NULL;
		}
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif
	}
	else
	{
		WDMCloseDevice(nDeviceIndex);
	}
    SetLastError(err);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return NULL;
}


void
DoClose(
    HCAPDEV hcd
    )
{
	FX_ENTRY("DoClose");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	// Clean up streaming on main channel, including freeing all buffers
	if (hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
		UninitializeStreaming(hcd);

	// Stop streaming on the capture channel
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_STREAM_FINI, 0L, 0L);
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#else
		_SendDriverMessage((HDRVR)hcd->hvideoCapture, DVM_STREAM_FINI, 0L, 0L);
#endif

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif

		// Close the driver channels
		if (!_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0) ||
			!_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0))
		{
			SetLastError(ERROR_DCAP_NONSPECIFIC);
			ERRORMESSAGE(("%s: Couldn't close channel, error unknown\r\n", _fx_));
			// with delayed close this is catastrophic, we can't just return that the device is still
			// open, but we can't get the device to close either, so we'll have to just leave it in this
			// hung open state - hopefully this never happens...
		}
		hcd->hvideoCapture = NULL;
		hcd->hvideoIn = NULL;
#ifndef __NT_BUILD__
		// Free the LOCKEDINFO structure
		_FreeLockableBuffer(hcd->wselLockedInfo);
		hcd->wselLockedInfo = 0;
#endif
	}
	else
	{
		WDMCloseDevice(hcd->nDeviceIndex);
	}

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}

BOOL
DCAPI
CloseCaptureDevice(
    HCAPDEV hcd
    )
{
	FX_ENTRY("CloseCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;   // clear flag to disable other API's
    LEAVE_DCAP(hcd);                        // dec our enter count, if no other thread is in a DCAP
                                            // service, then this dec will go to 0 and we'll call
                                            // DoClose; else we won't call DoClose until the other
                                            // active service dec's the count to 0
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


DWORD
DCAPI
GetCaptureDeviceFormatHeaderSize(
    HCAPDEV hcd
    )
{
    DWORD res;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		res = _GetVideoFormatSize(reinterpret_cast<HDRVR>(hcd->hvideoIn));
	else
		res = WDMGetVideoFormatSize(hcd->nDeviceIndex);

    LEAVE_DCAP(hcd);

    return res;
}


BOOL
DCAPI
GetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDeviceFormat");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // Call the driver to get the bitmap information
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoFormat(hcd->hvideoIn, lpbmih);
	else
		fRes = WDMGetVideoFormat(hcd->nDeviceIndex, lpbmih);
	
    if (!fRes)
    {
        // This is DOOM if the driver doesn't support this.
        // It might be useful have some sort of fallback code here,
        // or else we should try this when the connection is made and
        // fail it unless this call works.
		ERRORMESSAGE(("%s: Failed to get video format\r\n", _fx_));
        SetLastError(ERROR_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

	if (lpbmih->biCompression == BI_RGB)
		lpbmih->biSizeImage = WIDTHBYTES(lpbmih->biWidth * lpbmih->biBitCount) * lpbmih->biHeight;

	// Keep track of current buffer size needed
	hcd->dwcbBuffers = sizeof(CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


BOOL
DCAPI
SetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih,
    LONG srcwidth,
    LONG srcheight
    )
{
	BOOL fRes;
#ifdef USE_VIDEO_OVERLAY
    RECT rect;
#endif

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // Don't allow this if streaming
    if (hcd->dwFlags & HCAPDEV_STREAMING)
    {
        SetLastError(ERROR_DCAP_NOT_WHILE_STREAMING);
        return FALSE;
    }
    ENTER_DCAP(hcd);

    // Call the driver to set the format
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		fRes = _SetVideoFormat(hcd->hvideoCapture, hcd->hvideoIn, lpbmih);
#ifdef USE_VIDEO_OVERLAY
		if (fRes && hcd->hvideoOverlay)
		{
			// Get the current rectangles
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay dst rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay src rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));

			// Set the rectangles
			rect.left = rect.top = 0;
			rect.right = (WORD)lpbmih->biWidth;
			rect.bottom = (WORD)lpbmih->biHeight;
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			if (hcd->hvideoOverlay)
				_InitializeExternalVideoStream(hcd->hvideoOverlay);
		}
#endif
	}
	else
		fRes = WDMSetVideoFormat(hcd->nDeviceIndex, lpbmih);

    if (!fRes)
    {
        SetLastError(ERROR_DCAP_FORMAT_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

    // Cache the bitmap size we're dealing with now
	if (lpbmih->biCompression == BI_RGB)
		hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biWidth * lpbmih->biHeight * lpbmih->biBitCount / 8;
	else
	    hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


//  GetCaptureDevicePalette
//      Gets the current palette from the capture device. The entries are returned to
//      the caller who normally calls CreatePalette on the structure. It may, however,
//      want to translate the palette entries into some preexisting palette or identity
//      palette before calling CreatePalette, hence the need for passing back the entries.

BOOL
DCAPI
GetCaptureDevicePalette(
    HCAPDEV hcd,
    CAPTUREPALETTE* lpcp
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDevicePalette");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // The caller doesn't have to initialize the structure.
    // The driver should fill it in, but it may want it preininitialized so we do that here.
    lpcp->wVersion = 0x0300;
    lpcp->wcEntries = 256;

    // Get the palette entries from the driver and return to the user
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoPalette(hcd->hvideoIn, lpcp, sizeof (CAPTUREPALETTE));
	else
		fRes = WDMGetVideoPalette(hcd->nDeviceIndex, lpcp, sizeof (CAPTUREPALETTE));

    if (!fRes)
	{
		ERRORMESSAGE(("%s: No palette returned from driver\r\n", _fx_));
		SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
		LEAVE_DCAP(hcd);
		return FALSE;
	}

    LEAVE_DCAP(hcd);
    return TRUE;
}


void
TerminateStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
	BOOL fRes;

	FX_ENTRY("TerminateStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    StopStreaming(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        hcd->dwFlags |= HCAPDEV_STREAMING_PAUSED;

        // Make sure we aren't streaming
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
#ifndef __NT_BUILD__
			hcd->lpli->dwFlags |= LIF_STOPSTREAM;
#endif
			_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_RESET, 0, 0);
		}
		else
			WDMVideoStreamReset(hcd->nDeviceIndex);

        dwTicks = GetTickCount();
        lpcbuf = hcd->lpcbufList;
        while (lpcbuf && GetTickCount() < dwTicks + 1000) {
            dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                if (WaitForSingleObject(hcd->hevWait, 500) == WAIT_TIMEOUT) {
					ERRORMESSAGE(("%s: Timeout waiting for all buffers done after DVM_STREAM_RESET\r\n", _fx_));
                    break;  // looks like it isn't going to happen, so quit waiting
                }
				//else recheck done bit on current buffer
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_DONE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
            }
            else
			{
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
                lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser;    // next buffer
			}
        }

		DEBUGMSG(ZONE_STREAMING, ("%s: Done trying to clear buffers\r\n", _fx_));

		// Clean up flags in order to reuse buffers - drivers do not like to be
		// given buffers with a dirty dwFlags at the start of streaming...
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser)
			lpcbuf->vh.dwFlags = 0;

        // Terminate streaming with the driver
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRes = _UninitializeVideoStream(hcd->hvideoIn);
		else
			fRes = WDMUnInitializeVideoStream(hcd->nDeviceIndex);

        if (!fRes)
		{
			ERRORMESSAGE(("%s: Error returned from XXXUninitializeVideoStream\r\n", _fx_));
		}
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}


BOOL
ReinitStreaming(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
	BOOL fRes;

	FX_ENTRY("ReinitStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        // Tell the driver to prepare for streaming. This sets up the callback

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
#ifdef __NT_BUILD__
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD)hcd);
#else
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD)hcd->wselLockedInfo << 16);
#endif
		else
			fRes = WDMInitializeVideoStream(hcd, hcd->nDeviceIndex, hcd->dw_usecperframe);

        if (!fRes)
        {
			ERRORMESSAGE(("%s: Error returned from XXXInitializeVideoStream\r\n", _fx_));
            SetLastError(ERROR_DCAP_BAD_FRAMERATE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
            return FALSE;
        }
//        Sleep (10);

        hcd->dwFlags &= ~HCAPDEV_STREAMING_PAUSED;

        // If any buffers are not marked DONE, then give them back to the driver; let all
        // DONE buffers get processed by the app first
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				{
					// AVICap32 sets the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_PREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags |= VHDR_PREPARED;
					fRes = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
				}
				else
					fRes = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

                if (!fRes)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Failed with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
					DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
                    return FALSE;
                }
				else
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Succeeded with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
                }
            }
        }
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return TRUE;
}


//  CaptureDeviceDialog
//      Puts up one of the driver's dialogs for the user to twiddle.
//      If I can figure out ANY way to avoid this, I will.

BOOL DCAPI
CaptureDeviceDialog(
    HCAPDEV hcd,
    HWND hwndParent,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbmih   //OPTIONAL
    )
{
    DWORD dwDriverFlags = 0;
    HVIDEO hvid;
    DWORD dwSize;
    LPBITMAPINFOHEADER lpbmihCur;
#ifdef _DEBUG
    LPBITMAPINFOHEADER lpbmihPre = NULL;
#endif
    BOOL res = TRUE;

	FX_ENTRY("CaptureDeviceDialog");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (hcd->dwFlags & HCAPDEV_IN_DRIVER_DIALOG)
        return FALSE;   // don't allow re-entering

    ENTER_DCAP(hcd);

    if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
			dwDriverFlags |= VIDEO_DLG_QUERY;

		// Select the correct channel to query
		if (dwFlags & CAPDEV_DIALOG_SOURCE) {
			hvid = hcd->hvideoCapture;
			if (!(dwFlags & CAPDEV_DIALOG_QUERY)) {
				dwDriverFlags |= VIDEO_DLG_QUERY;
				if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD)hwndParent, dwDriverFlags) == DV_ERR_NOTSUPPORTED) {
					hvid = hcd->hvideoIn;
				}
				dwDriverFlags &= ~VIDEO_DLG_QUERY;
			}
		}
		else
			hvid = hcd->hvideoIn;

		// Don't stop streaming. This make the source dialog totally useless
		// if the user can't see what is going on.

#ifdef _DEBUG
		if (!lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihPre = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihPre->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihPre);
			}
			lpbmih = lpbmihPre;
		}
#endif

		// Call the driver
		hcd->dwFlags |= HCAPDEV_IN_DRIVER_DIALOG;
		if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD)hwndParent, dwDriverFlags)) {
			SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
			res = FALSE;    // restart still ok
		}
		else if (lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihCur = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihCur->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihCur);
				if (lpbmih->biSize != lpbmihCur->biSize ||
					lpbmih->biWidth != lpbmihCur->biWidth ||
					lpbmih->biHeight != lpbmihCur->biHeight ||
					lpbmih->biBitCount != lpbmihCur->biBitCount ||
					lpbmih->biCompression != lpbmihCur->biCompression)
				{
					ERRORMESSAGE(("%s: Format changed in dialog!!\r\n", _fx_));
#ifdef _DEBUG
					DebugBreak();
#endif
					// dialog changed format, so try to set it back
					if (!SetCaptureDeviceFormat(hcd, lpbmih, 0, 0)) {
						SetLastError (ERROR_DCAP_DIALOG_FORMAT);
						res = FALSE;
					}
				}
				LocalFree ((HANDLE)lpbmihCur);
			}
#ifdef _DEBUG
			if (lpbmih == lpbmihPre) {
				LocalFree ((HANDLE)lpbmihPre);
				lpbmih = NULL;
				lpbmihPre = NULL;
			}
#endif
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		if (hcd->dwFlags & HCAPDEV_STREAMING) {
    		// The Intel Smart Video Recorder Pro stops streaming
			// on exit from the source dialog (!?!?). Make sure
    		// we reset the streaming on any kind of device right
			// after we exit the source dialog. I verified this on
    		// the CQC, ISVR Pro, Video Stinger and Video Blaster SE100.
			// They all seem to take this pretty well...
    		TerminateStreaming(hcd);
			if (ReinitStreaming(hcd))
				StartStreaming(hcd);
			else {
				SetLastError(ERROR_DCAP_DIALOG_STREAM);
				res = FALSE;
				ERRORMESSAGE(("%s: Couldn't reinit streaming after dialog!\r\n", _fx_));
			}
		}
	}
	else
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
		{
			// We only expose a settings dialog
			if (dwFlags & CAPDEV_DIALOG_IMAGE)
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}
		else
		{
			if (!WDMShowSettingsDialog(hcd->nDeviceIndex, hwndParent))
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		// No need to restart streaming on WDM devices tested so far
		// Will add this feature if problems come up
	}

    LEAVE_DCAP(hcd);
    return res;
}


//  InitializeStreaming
//      Allocates all memory and other objects necessary for streaming.

BOOL
DCAPI
InitializeStreaming(
    HCAPDEV hcd,
    CAPSTREAM* lpcs,
    DWORD flags
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwRound;
    LPBITMAPINFOHEADER lpbmih;
    BOOL bHaveBuffers = FALSE;

	FX_ENTRY("InitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // It doesn't make sense to stream with less than 2 buffers
    if (lpcs->ncCapBuffers < MIN_STREAMING_CAPTURE_BUFFERS ||
            flags & 0xfffffffe ||
            hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }
    ENTER_DCAP(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING | HCAPDEV_STREAMING_INITIALIZED |
                      HCAPDEV_STREAMING_FRAME_GRAB | HCAPDEV_STREAMING_FRAME_TIME | HCAPDEV_STREAMING_PAUSED);

    // Before allocating, make sure we have the current format.
    // This sets our idea of the current size we need for the buffer by
    // setting hcd->dwcbBuffers as a side effect
    dwRound = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwRound)) {
        lpbmih->biSize = dwRound;
        GetCaptureDeviceFormat(hcd, lpbmih);
        LocalFree ((HANDLE)lpbmih);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

// BUGBUG - add logic to determine if we should automatically use FRAME_GRAB mode

    // Try allocating the number asked for
    if (flags & STREAMING_PREFER_FRAME_GRAB) {
        hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_GRAB;
    }

    if (!allocateBuffers(hcd, lpcs->ncCapBuffers))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Create the event we need so we can signal at interrupt time
    if (!(hcd->hevWait = CreateEvent(NULL, FALSE, FALSE, NULL))) {
		ERRORMESSAGE(("%s: CreateEvent failed!\r\n", _fx_));
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Init CS used to serialize buffer list management
    InitializeCriticalSection(&hcd->bufferlistCS);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    hcd->dw_usecperframe = (unsigned)1000000000 / (unsigned)lpcs->nFPSx100;
    dwRound = hcd->dw_usecperframe % 10;  // Could have done with one less divide,
    hcd->dw_usecperframe /= 10;           // but this is clearer, and this is just
                                          // an init call...
    if (dwRound >= 5)
        hcd->dw_usecperframe++;

    hcd->lpCurrent = NULL;
    hcd->lpHead = NULL;
    hcd->lpTail = NULL;

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->pevWait = 0;
#endif

        // link the buffers into the available list
        // start with empty list
        hcd->lpHead = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR
        hcd->lpTail = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR

        // now insert the buffers
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
	        lpcbuf->lpPrev = hcd->lpTail;
	        hcd->lpTail = lpcbuf;
            lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	        lpcbuf->lpPrev->lpNext = lpcbuf;
	        lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    }
    }
	else
	{
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			hcd->lpli->pevWait = (DWORD)OpenVxDHandle(hcd->hevWait);

			// Lock down the LOCKEDINFO structure
			if (!_LockBuffer(hcd->wselLockedInfo))
			{
				SetLastError(ERROR_OUTOFMEMORY);
				goto Error;
			}
			hcd->lpli->lp1616Head = 0;
			hcd->lpli->lp1616Tail = 0;
			hcd->lpli->lp1616Current = 0;
		}
#endif

        if (!ReinitStreaming(hcd))
            goto Error;
    }
    lpcs->hevWait = hcd->hevWait;

    // Flag that streaming is initialized
    hcd->dwFlags |= HCAPDEV_STREAMING_INITIALIZED;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

Error:
    freeBuffers(hcd);
    if (hcd->hevWait)
    {
        CloseHandle(hcd->hevWait);
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && hcd->lpli->pevWait)
            _CloseVxDHandle(hcd->lpli->pevWait);
#endif
    }
    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return FALSE;
}


//  SetStreamFrameRate
//      Changes the frame rate of a stream initialized channel.
// PhilF-: This call is not used by NMCAP and NAC. So remove it or
// start using it.
BOOL
DCAPI
SetStreamFrameRate(
    HCAPDEV hcd,
    int nFPSx100
    )
{
    DWORD dwNew, dwRound;
    BOOL restart;
    BOOL res = TRUE;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED))
    {
        // must already have the channel initialized for streaming
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ENTER_DCAP(hcd);
    restart = (hcd->dwFlags & HCAPDEV_STREAMING);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    dwNew = (unsigned)1000000000 / (unsigned)nFPSx100;
    dwRound = dwNew % 10;           // Could have done with one less divide,
    dwNew /= 10;                    // but this is clearer, and this is just an init call...
    if (dwRound >= 5)
        dwNew++;

    if (dwNew != hcd->dw_usecperframe) {

        TerminateStreaming(hcd);

        hcd->dw_usecperframe = dwNew;

        res = ReinitStreaming(hcd);

        if (restart && res)
            StartStreaming(hcd);
    }
    LEAVE_DCAP(hcd);
    return res;
}


//  UninitializeStreaming
//      Frees all memory and objects associated with streaming.

BOOL
DCAPI
UninitializeStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("UninitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }

    ENTER_DCAP(hcd);

    TerminateStreaming(hcd);

#ifndef __NT_BUILD__
    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) && !(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
        // Unlock our locked structure
        _UnlockBuffer(hcd->wselLockedInfo);

        // Free the event
        _CloseVxDHandle(hcd->lpli->pevWait);
    }
#endif

    DeleteCriticalSection(&hcd->bufferlistCS);
    CloseHandle(hcd->hevWait);

    // BUGBUG - what about app still owning buffers
    // Loop through freeing all the buffers
    freeBuffers(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING_INITIALIZED + HCAPDEV_STREAMING_PAUSED);

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


void
CALLBACK
TimeCallback(
    UINT uID,	
    UINT uMsg,	
    HCAPDEV hcd,	
    DWORD dw1,	
    DWORD dw2	
    )
{
    hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_TIME;  // flag time for a new frame
    SetEvent (hcd->hevWait);    // signal client to initiate frame grab
}

//  StartStreaming
//      Begins streaming.

BOOL
DCAPI
StartStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;
	DWORD dwRet;

	FX_ENTRY("StartStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        fRet = ((hcd->timerID = timeSetEvent(hcd->dw_usecperframe/1000, 5,
                                    (LPTIMECALLBACK)&TimeCallback,
                                    (DWORD)hcd, TIME_PERIODIC)) != 0);
    } else {
        int i;

        fRet = FALSE;

#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->dwFlags &= ~LIF_STOPSTREAM;
#endif

        for (i = 0; i < 5; i++) {

			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			{
				dwRet = _SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_START, 0, 0);
				fRet = (dwRet == DV_ERR_OK);
				if (dwRet)
				{
					ERRORMESSAGE(("%s: DVM_STREAM_START failed, return code was %ld\r\n", _fx_, dwRet));
				}
			}
			else
				fRet = WDMVideoStreamStart(hcd->nDeviceIndex);

            if (fRet)
                break;
            else if (i > 1)
                Sleep(10);
        }
    }

    if (fRet)
        hcd->dwFlags |= HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  StopStreaming
//      Stops streaming but doesn't free any memory associated with streaming
//      so that it can be restarted with StartStreaming.

BOOL
DCAPI
StopStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;

	FX_ENTRY("StopStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        timeKillEvent(hcd->timerID);
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

        // grab CS to ensure that no frame grab is in progress
        EnterCriticalSection(&hcd->bufferlistCS);
        LeaveCriticalSection(&hcd->bufferlistCS);
        fRet = TRUE;
    }
	else
	{
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_STOP, 0, 0) == DV_ERR_OK);
		else
			fRet = WDMVideoStreamStop(hcd->nDeviceIndex);
	}

    if (fRet)
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  GetNextReadyBuffer
//      Called by the app to find the next buffer that has been marked as
//      done by the driver and has data to be displayed.

LPSTR
DCAPI
GetNextReadyBuffer(
    HCAPDEV hcd,
    CAPFRAMEINFO* lpcfi
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
	BOOL fRet;

	FX_ENTRY("GetNextReadyBuffer");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        lpcbuf = (LPCAPBUFFER)hcd->lpHead;
        if ((hcd->dwFlags & HCAPDEV_STREAMING_FRAME_TIME) &&
            (lpcbuf != (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR))))  /* fake CAPBUFFERHDR */
        {
            // remove buffer from list
            EnterCriticalSection(&hcd->bufferlistCS);
            hcd->dwFlags &= ~HCAPDEV_STREAMING_FRAME_TIME;
            lpcbuf->lpPrev->lpNext = lpcbuf->lpNext;
            lpcbuf->lpNext->lpPrev = lpcbuf->lpPrev;
            lpcbuf->vh.dwFlags &= ~VHDR_INQUEUE;
            lpcbuf->vh.dwFlags |= VHDR_DONE;
            LeaveCriticalSection(&hcd->bufferlistCS);
            dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				fRet = (SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
			else
				fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

            if (!fRet)
			{
                // put buffer back into list
                EnterCriticalSection(&hcd->bufferlistCS);
        	    lpcbuf->lpPrev = hcd->lpTail;
        	    hcd->lpTail = lpcbuf;
                lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
        	    lpcbuf->lpPrev->lpNext = lpcbuf;
           	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
                LeaveCriticalSection(&hcd->bufferlistCS);
                lpcbuf = NULL;
            }
        } else
            lpcbuf = NULL;

    } else {

#ifdef __NT_BUILD__
        // If the current pointer is NULL, there is no frame ready so bail
        if (!hcd->lpCurrent)
	        lpcbuf = NULL;
        else {
            // Get the linear address of the buffer
            lpcbuf = hcd->lpCurrent;

            // Move to the next ready buffer
            hcd->lpCurrent = lpcbuf->lpPrev;
        }
#else
        //--------------------
        // Buffer ready queue:
        // We maintain a doubly-linked list of our buffers so that we can buffer up
        // multiple ready frames when the app isn't ready to handle them. Two things
        // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
        // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
        // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
        // buffers get added to the list asynchronously.
        //
        // To handle this, the scheme implemented here is to have a double-linked list
        // of buffers with all insertions and deletions happening in FrameCallback
        // (interrupt time). This allows the GetNextReadyBuffer routine to simply
        // find the previous block on the list any time it needs a new buffer without
        // fear of getting tromped (as would be the case if it had to dequeue buffers).
        // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
        // is done with. Dequeueing is simple since we don't need to unlink the blocks:
        // no code ever walks the list! All we have to do is move the tail pointer back up
        // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
        // since all the list manipulation is on the 16-bit side AND because MapSL is
        // much more efficient and safer than MapLS since MapLS has to allocate selectors.
        //--------------------

        // If the current pointer is NULL, there is no frame ready so bail
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!hcd->lpli->lp1616Current)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = (LPCAPBUFFER)MapSL(hcd->lpli->lp1616Current);

				// Move to the next ready buffer
				hcd->lpli->lp1616Current = lpcbuf->lp1616Prev;
			}
		}
		else
		{
			// If the current pointer is NULL, there is no frame ready so bail
			if (!hcd->lpCurrent)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = hcd->lpCurrent;

				// Move to the next ready buffer
				hcd->lpCurrent = lpcbuf->lpPrev;
			}
		}
#endif

    }

    if (!lpcbuf) {
        lpcfi->lpData = NULL;
		DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Fails with lpcbuf=NULL\r\n", _fx_));
        LEAVE_DCAP(hcd);
        return NULL;
    }

    // Build the CAPFRAMEINFO from the VIDEOHDR information
    lpcfi->lpData = ((LPSTR)lpcbuf) + sizeof(CAPBUFFERHDR);
    lpcfi->dwcbData = lpcbuf->vh.dwBytesUsed;
    lpcfi->dwTimestamp = lpcbuf->vh.dwTimeCaptured;
    lpcfi->dwFlags = 0;
    lpcbuf->lpNext = NULL;

	DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  lpcbuf->vh.dwBufferLength=%ld\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, lpcbuf->vh.dwBufferLength));
	DEBUGMSG(ZONE_STREAMING, ("  lpcbuf->vh.dwBytesUsed=%ld\r\n  lpcbuf->vh.dwTimeCaptured=%ld\r\n  lpcbuf->vh.dwFlags=0x%08lX\r\n", lpcbuf->vh.dwBytesUsed, lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwFlags));

    LEAVE_DCAP(hcd);
    return lpcfi->lpData;
}


//  PutBufferIntoStream
//      When the app is finished using a buffer, it must allow it to be requeued
//      by calling this API.

BOOL
DCAPI
PutBufferIntoStream(
    HCAPDEV hcd,
    BYTE* lpBits
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
    BOOL res;

	FX_ENTRY("PutBufferIntoStream");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);
    // From the CAPFRAMEINFO, find the appropriate CAPBUFFER pointer
    lpcbuf = (LPCAPBUFFER)(lpBits - sizeof(CAPBUFFERHDR));

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Returning buffer lpcbuf=0x%08lX\r\n", _fx_, lpcbuf));

    lpcbuf->vh.dwFlags &= ~VHDR_DONE;   // mark that app no longer owns buffer
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        EnterCriticalSection(&hcd->bufferlistCS);
	    lpcbuf->lpPrev = hcd->lpTail;
	    hcd->lpTail = lpcbuf;
        lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	    lpcbuf->lpPrev->lpNext = lpcbuf;
	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    res = TRUE;
        LeaveCriticalSection(&hcd->bufferlistCS);
    }
    else if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
        // if streaming is paused, then just return with the busy bit cleared, we'll add the
        // buffer into the stream in ReinitStreaming
        //
        // if streaming isn't paused, then call the driver to add the buffer
        dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			res = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
		else
			res = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

		if (res)
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Failed with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}

    }

    LEAVE_DCAP(hcd);
    return res;
}


//  CaptureFrame
LPBYTE
DCAPI
CaptureFrame(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
    DWORD dwlpvh;
    LPBYTE lpbuf;
    BOOL fRet;

	FX_ENTRY("CaptureFrame");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    dwlpvh = (DWORD)hbuf->vh.lpData - sizeof(CAPBUFFERHDR);
	// 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
	// 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
	else
		fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

    if (!fRet)
	{
		ERRORMESSAGE(("%s: DVM_FRAME failed!\r\n", _fx_));
        lpbuf =  NULL;
    }
    else
        lpbuf = ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr

    LEAVE_DCAP(hcd);
    return lpbuf;
}


LPBYTE
DCAPI
GetFrameBufferPtr(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
        return ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr
    else
        return NULL;
}

HFRAMEBUF
DCAPI
AllocFrameBuffer(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER hbuf = NULL;
    DWORD dpBuf;

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
    if (dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)) {
        hbuf = (LPCAPBUFFER)dpBuf;
#else
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16;
        hbuf = (LPCAPBUFFER)MapSL(dpBuf);
	}
	else
	{
		dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers);
        hbuf = (LPCAPBUFFER)dpBuf;
	}

    if (dpBuf) {
#endif
        // Initialize the VIDEOHDR structure
        hbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        hbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        hbuf->vh.dwFlags = 0UL;
    }

    LEAVE_DCAP(hcd);
    return (HFRAMEBUF)hbuf;
}


VOID
DCAPI
FreeFrameBuffer(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
	{
        ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
		LocalFree((HANDLE)hbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			_FreeLockableBuffer(HIWORD((DWORD)hbuf->vh.lpData));
		else
			LocalFree((HANDLE)hbuf);
#endif

        LEAVE_DCAP(hcd);
    }
}

//=====================================================================
//  Helper functions

HVIDEO
openVideoChannel(
    DWORD dwDeviceID,
    DWORD dwFlags
    )
{
    HVIDEO hvidRet = NULL;
    VIDEO_OPEN_PARMS vop;
#ifdef __NT_BUILD__
    WCHAR devName[MAX_PATH];
#else
#define LPWSTR      LPSTR
#define devName     g_aCapDevices[dwDeviceID]->szDeviceName
#endif

	FX_ENTRY("openVideoChannel");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Validate parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }
    if (dwDeviceID > (DWORD)g_cDevices)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    // Prepare to call the driver
    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = 0;
    vop.dnDevNode = g_aCapDevices[dwDeviceID]->dwDevNode;

#ifdef __NT_BUILD__
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR)&(g_aCapDevices[dwDeviceID]->szDeviceName),
	-1, (LPWSTR)&devName, MAX_PATH);
#endif

    hvidRet = (HVIDEO)_OpenDriver((LPWSTR)&devName, NULL, (LONG)&vop);

#ifndef NO_DRIVER_HACKS
    if (!hvidRet) {
        // backward compatibility hack
        // Some drivers fail to open because of the extra fields that were added to
        // VIDEO_OPEN_PARAMS struct for Win95.  Therefore, if the open fails, try
        // decrementing the dwSize field back to VFW1.1 size and try again.  Also try
        // decrementing the API version field.

        vop.dwSize -= sizeof(DWORD) + sizeof(LPVOID)*2;
#if 0
        while (--vop.dwVersion > 2 && !hvidRet)
#endif
        while (--vop.dwVersion > 0 && !hvidRet)
            hvidRet = (HVIDEO)_OpenDriver((LPWSTR)&devName, NULL, (LONG)&vop);
    }
#endif //NO_DRIVER_HACKS

// BUGBUG [JonT] 31-Jul-96
// Translate error values from DV_ERR_* values
    if (!hvidRet)
        SetLastError(vop.dwError);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hvidRet;
}


//  allocateBuffers

BOOL
allocateBuffers(
    HCAPDEV hcd,
    int nBuffers
    )
{
    int i;
    LPCAPBUFFER lpcbuf;
    DWORD dpBuf;

	FX_ENTRY("allocateBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Try to allocate all they ask for
    for (i = 0 ; i < nBuffers ; i++)
    {

#ifdef __NT_BUILD__
        if (!(dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)))
            goto Error;
        else
			lpcbuf = (LPCAPBUFFER)dpBuf;
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!(dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16) || !_LockBuffer((WORD)(dpBuf >> 16)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)MapSL(dpBuf);
		}
		else
		{
			if (!(dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)dpBuf;
		}
#endif

        // Initialize the VIDEOHDR structure
        lpcbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        lpcbuf->vh.dwUser = (DWORD)hcd->lpcbufList;
        hcd->lpcbufList = lpcbuf;
        lpcbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        lpcbuf->vh.dwFlags = 0UL;
    }

#ifdef _DEBUG
	// Show buffer map
	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming Buffer map:\r\n", _fx_));
	DEBUGMSG(ZONE_STREAMING, ("Root: hcd->lpcbufList=0x%08lX\r\n", hcd->lpcbufList));
    for (i = 0, lpcbuf=hcd->lpcbufList ; i < nBuffers ; i++, lpcbuf=(LPCAPBUFFER)lpcbuf->vh.dwUser)
    {
		DEBUGMSG(ZONE_STREAMING, ("Buffer[%ld]: lpcbuf=0x%08lX\r\n             lpcbuf->vh.lpData=0x%08lX\r\n", i, lpcbuf, lpcbuf->vh.lpData));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwBufferLength=%ld\r\n             lpcbuf->vh.dwBytesUsed=%ld\r\n", lpcbuf->vh.dwBufferLength, lpcbuf->vh.dwBytesUsed));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwTimeCaptured=%ld\r\n             lpcbuf->vh.dwUser=0x%08lX\r\n", lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwUser));
	}	
#endif

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

    // In the error case, we have to get rid of this page locked memory
Error:
    freeBuffers(hcd);
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return FALSE;
}


//  freeBuffers

void
freeBuffers(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("freeBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    while (hcd->lpcbufList)
    {
        lpcbuf = hcd->lpcbufList;
        hcd->lpcbufList = (LPCAPBUFFER)lpcbuf->vh.dwUser;

#ifdef __NT_BUILD__
		LocalFree((HANDLE)lpcbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			_UnlockBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
			_FreeLockableBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
		}
		else
			LocalFree((HANDLE)lpcbuf);
#endif
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\precomp.h ===
// Precompiled header for DCAP32.DLL

// the build environment only defines _DEBUG when
// ALT_PROJECT_TARGET = NT is specified. Bug the debug zones only
// test for DEBUG...

#ifdef _DEBUG
#	ifndef DEBUG
#		define DEBUG
#	endif // !DEBUG
#endif // _DEBUG

#include <windows.h>
#include <confdbg.h>
#include <avutil.h>
#include <memtrack.h>
#include <winioctl.h>	// CTL_CODE, FILE_READ_ACCESS..etc
#include <commctrl.h>	// Page.cpp (UDM_GETRANGE, TBM_GETPOS) and Sheet.cpp (InitCommonControls)
#include <mmsystem.h>	// must go before mmddk.h
#include <mmddk.h>		// for DriverCallback()
#include <vfw.h>
#include <msviddrv.h>	// VIDEO_STREAM_INIT_PARMS
#include <strmif.h>
#include <uuids.h>
#include <ks.h>
#include <ksmedia.h>
#include <help_ids.h>
#include "..\inc\idcap.h"
#include "..\inc\WDMDrivr.h"
#include "..\inc\WDMPin.h"
#include "..\inc\WDMStrmr.h"
#include "..\inc\debug.h"
#include "..\inc\wdmcap.h"
#include "..\inc\resource.h"
#include "..\inc\WDMDialg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\debug.cpp ===
#include "Precomp.h"

#ifdef _DEBUG

HDBGZONE  ghDbgZoneCap = NULL;

int WINAPI CapDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("DCAP", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\precomp.h ===
// Precompiled header for DCAP32.DLL

// the build environment only defines _DEBUG when
// ALT_PROJECT_TARGET = NT is specified. Bug the debug zones only
// test for DEBUG...

#ifdef _DEBUG
#	ifndef DEBUG
#		define DEBUG
#	endif // !DEBUG
#endif // _DEBUG

#include <windows.h>
#include <confdbg.h>
#include <avutil.h>
#include <memtrack.h>
#include <winioctl.h>	// CTL_CODE, FILE_READ_ACCESS..etc
#include <commctrl.h>	// Page.cpp (UDM_GETRANGE, TBM_GETPOS) and Sheet.cpp (InitCommonControls)
#include <mmsystem.h>	// must go before mmddk.h
#include <mmddk.h>		// for DriverCallback()
#include <vfw.h>
#include <msviddrv.h>	// VIDEO_STREAM_INIT_PARMS
#include <strmif.h>
#include <uuids.h>
#include <ks.h>
#include <ksmedia.h>
#include <help_ids.h>
#include "..\inc\idcap.h"
#include "..\inc\WDMDrivr.h"
#include "..\inc\WDMPin.h"
#include "..\inc\WDMStrmr.h"
#include "..\inc\debug.h"
#include "..\inc\wdmcap.h"
#include "..\inc\resource.h"
#include "..\inc\WDMDialg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\wdmcap.cpp ===
// This file adds native support for streaming WDM video capture
// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    );

// Globals
extern HINSTANCE g_hInst;


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetDevices | This function enumerates the installed WDM video
 *   capture devices and adds them to the list of VfW capture devices.
 *
 * @parm PDWORD | [OUT] pdwOverallCPUUsage | Specifies a pointer to a DWORD to
 *   receive the current CPU usage.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 *
 * @devnote MSDN references:
 *   DirectX 5, DirectX Media, DirectShow, Application Developer's Guide
 *   "Enumerate and Access Hardware Devices in DirectShow Applications"
 ***************************************************************************/
BOOL WDMGetDevices(void)
{
	HRESULT hr;
	ICreateDevEnum *pCreateDevEnum;
	IEnumMoniker *pEm;

	FX_ENTRY("WDMGetDevices");

	// First, create a system hardware enumerator
	// This call loads the following DLLs - total 1047 KBytes!!!:
	//   'C:\WINDOWS\SYSTEM\DEVENUM.DLL' = 60 KBytes
	//   'C:\WINDOWS\SYSTEM\RPCRT4.DLL' = 316 KBytes
	//   'C:\WINDOWS\SYSTEM\CFGMGR32.DLL' = 44 KBytes
	//   'C:\WINDOWS\SYSTEM\WINSPOOL.DRV' = 23 KBytes
	//   'C:\WINDOWS\SYSTEM\COMDLG32.DLL' = 180 KBytes
	//   'C:\WINDOWS\SYSTEM\LZ32.DLL' = 24 KBytes
	//   'C:\WINDOWS\SYSTEM\SETUPAPI.DLL' = 400 KBytes
	// According to LonnyM, there's no way to go around SETUPAPI.DLL
	// when dealing with PnP device interfaces....
	if ((CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void**)&pCreateDevEnum)) != S_OK)
	{
		return FALSE;
	}

	// Second, create an enumerator for a specific type of hardware device: video capture cards only
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEm, CDEF_BYPASS_CLASS_MANAGER);
    pCreateDevEnum->Release();

	// Third, enumerate the list itself
    if (hr == S_OK)
	{
		ULONG cFetched;
		IMoniker *pM;
		IPropertyBag *pPropBag = 0;

		hr = pEm->Reset();

        while(hr = pEm->Next(1, &pM, &cFetched), hr==S_OK)
		{

			pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);

			if (pPropBag)
			{
				VARIANT var;
				LPINTERNALCAPDEV lpcd;

				if (!(lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV))))
				{
					ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
					break;  // break from the WHILE loop
				}

				// Get friendly name of the device
				var.vt = VT_BSTR;
				if ((hr = pPropBag->Read(L"FriendlyName", &var, 0)) == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceDescription, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);
				}
				else
					LoadString(g_hInst, IDS_UNKNOWN_DEVICE_NAME, lpcd->szDeviceDescription, CCHMAX(lpcd->szDeviceDescription));

				// Get DevicePath of the device
				hr = pPropBag->Read(L"DevicePath", &var, 0);
				if (hr == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceName, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);

					// There's no reg key for version information for WDM devices

					// Those devices can't be disabled from the MM control panel
					// lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

					// Mark device as a WDM device
					lpcd->dwFlags |= WDM_CAPTURE_DEVICE;

					g_aCapDevices[g_cDevices] = lpcd;
					g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
					g_cDevices++;
				}
            }
            
            pPropBag->Release();       

            pM->Release();
        }

        pEm->Release();
    }
    
	return TRUE;

}

/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMOpenDevice | This function opens a WDM video capture
 * devices and adds them to the list of VfW capture devices.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to open.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMOpenDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMOpenDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) != 0));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) == 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Open streaming class driver
	CWDMPin *pCWDMPin;
	if (!(pCWDMPin = new CWDMPin(dwDeviceID)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMPin class\r\n", _fx_));
		return FALSE;
	}
	else
	{
		// Open the WDM driver and create a video pin
		if (!pCWDMPin->OpenDriverAndPin())
		{
			goto Error0;
		}
	}

	// Create video stream on the pin
    CWDMStreamer *pCWDMStreamer;
	if (!(pCWDMStreamer = new CWDMStreamer(pCWDMPin)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMStreamer\r\n", _fx_));
		goto Error0;
	}

	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)pCWDMStreamer;

	return TRUE;

Error0:
	delete pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;

	return FALSE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMCloseDevice | This function closes a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to close.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMCloseDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMCloseDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close video channel
	if (g_aCapDevices[dwDeviceID]->pCWDMStreamer)
	{
		delete ((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer);
		g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;
	}

	// Close driver and pin
	if (g_aCapDevices[dwDeviceID]->pCWDMPin)
	{
		delete ((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
		g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	}

	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormatSize | This function returns the size of the
 *   structure used to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @rdesc Always returns the size of a BITMAPINFOHEADER structure.
 ***************************************************************************/
DWORD WDMGetVideoFormatSize(DWORD dwDeviceID)
{
	FX_ENTRY("WDMGetVideoFormatSize");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	DEBUGMSG(ZONE_INIT, ("%s: return size=%ld\r\n", _fx_, (DWORD)sizeof(BITMAPINFOHEADER)));

	// Return size of BITMAPINFOHEADER structure
	return (DWORD)sizeof(BITMAPINFOHEADER);
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMGetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Make sure the size information is correct
	if (!pbmih->biSize)
		pbmih->biSize = WDMGetVideoFormatSize(dwDeviceID);

	// Get the BITMAPINFOHEADER structure
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih, (WORD)pbmih->biSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMSetVideoFormat | This function sets the video format on
 *   a WDM video capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure describing the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMSetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMSetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih && pbmih->biSize);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih ||!pbmih->biSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Set the BITMAPINFOHEADER on the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->SetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		// PhilF-: This sometimes fail, but we keep on streaming... fix that
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoPalette(DWORD dwDeviceID, CAPTUREPALETTE* lpcp, DWORD dwcbSize)
{
	FX_ENTRY("WDMGetVideoPalette");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, lpcp=0x%08lX\r\n", _fx_, dwDeviceID, lpcp));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && lpcp);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !lpcp)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the palette information
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetPaletteInfo(lpcp, dwcbSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeExternalVideoStream | This function initializes
 *   an input video stream on the external video channel of a WDM video
 *   capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeExternalVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMInitializeExternalVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));
	DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeVideoStream | This function initializes
 *   an input video stream on the videoin channel of a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeVideoStream(HCAPDEV hcd, DWORD dwDeviceID, DWORD dwMicroSecPerFrame)
{
	FX_ENTRY("WDMInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, FPS=%ld\r\n", _fx_, dwDeviceID, 1000000UL / dwMicroSecPerFrame));

    VIDEO_STREAM_INIT_PARMS vsip = {0};

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize channel
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD)WDMFrameCallback;
    vsip.dwCallbackInst = (DWORD)hcd;
    vsip.dwFlags = CALLBACK_FUNCTION;
    // vsip.hVideo = (DWORD)hvideo;

	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Open(&vsip)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMUnInitializeVideoStream | This function requests a WDM
 *   video capture device to close a capture stream on the videoin channel.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMUnInitializeVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMUnInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close streaming on channel
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Close()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStart | This function requests a WDM video
 *   capture device to start a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to start.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStart(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStart");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Start streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Start()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStop | This function requests a WDM video
 *   capture device to stop a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to freeze.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStop(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStop");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Stop streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Stop()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamReset | This function resets a WDM video capture
 *   devie to stop input of a capture stream and return all buffers to the
 *   client.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to reset.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamReset(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamReset");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Reset()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamAddBuffer | This function requests a WDM video
 *   capture device to add an empty input buffer to its input buffer queue.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamAddBuffer(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMVideoStreamAddBuffer");

	DEBUGMSG(ZONE_STREAMING, ("      %s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->AddBuffer((LPVIDEOHDR)pBuff)))
	{
		DEBUGMSG(ZONE_STREAMING, ("      %s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("      %s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetFrame | This function requests a WDM video
 *   capture device to transfer a single frame to or from the video device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @parm PVOID | [OUT] pBuff | Specifies a pointer to a <t VIDEOHDR> structure.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetFrame(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMGetFrame");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	LPVIDEOHDR lpVHdr = (LPVIDEOHDR)pBuff;

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the frame from the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetFrame(lpVHdr))
		return TRUE;
	else
		return FALSE;

}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMShowSettingsDialog | This function puts up a property
 *   sheet with a VideoProcAmp and CameraControl page for a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMShowSettingsDialog(DWORD dwDeviceID, HWND hWndParent)
{
	PROPSHEETHEADER Psh;
	HPROPSHEETPAGE	Pages[MAX_PAGES];

	FX_ENTRY("WDMShowSettingsDialog");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize property sheet header	and common controls
	Psh.dwSize		= sizeof(Psh);
	Psh.dwFlags		= PSH_DEFAULT;
	Psh.hInstance	= g_hInst;
	Psh.hwndParent	= hWndParent;
	Psh.pszCaption	= g_aCapDevices[dwDeviceID]->szDeviceDescription;
	Psh.nPages		= 0;
	Psh.nStartPage	= 0;
	Psh.pfnCallback	= NULL;
	Psh.phpage		= Pages;

    // Create the video settings property page and add it to the video settings sheet
    CWDMDialog VideoSettings(IDD_VIDEO_SETTINGS, NumVideoSettings, PROPSETID_VIDCAP_VIDEOPROCAMP, g_VideoSettingControls, g_VideoSettingsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = VideoSettings.Create())
		Psh.nPages++;

    // Create the camera control property page and add it to the video settings sheet
    CWDMDialog CamControl(IDD_CAMERA_CONTROL, NumCameraControls, PROPSETID_VIDCAP_CAMERACONTROL, g_CameraControls, g_CameraControlsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = CamControl.Create())
		Psh.nPages++;

	// Put up the property sheet
	if (Psh.nPages && PropertySheet(&Psh) >= 0)
		return TRUE;
	else
		return FALSE;

}


void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    )
{
	FX_ENTRY("WDMFrameCallback");

	DEBUGMSG(ZONE_CALLBACK, ("    %s: wMsg=%s, hcd=0x%08lX, lpcbuf=0x%08lX, hcd->hevWait=0x%08lX\r\n", _fx_, (wMsg == MM_DRVM_OPEN) ? "MM_DRVM_OPEN" : (wMsg == MM_DRVM_CLOSE) ? "MM_DRVM_CLOSE" : (wMsg == MM_DRVM_ERROR) ? "MM_DRVM_ERROR" : (wMsg == MM_DRVM_DATA) ? "MM_DRVM_DATA" : "MM_DRVM_?????", hcd, lpcbuf, hcd->hevWait));

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - no data\r\n", _fx_));
	    SetEvent(hcd->hevWait);
	    return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (hcd->lpTail != hcd->lpCurrent)
	    hcd->lpTail = hcd->lpTail->lpPrev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!hcd->lpTail)
	    hcd->lpHead = NULL;

    // Add the new buffer to the ready queue
    lpcbuf->lpNext = hcd->lpHead;
    lpcbuf->lpPrev = NULL;
    if (hcd->lpHead)
	    hcd->lpHead->lpPrev = lpcbuf;
    else
	    hcd->lpTail = lpcbuf;
    hcd->lpHead = lpcbuf;

#if 1
    if (hcd->lpCurrent) {
        if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
    	    // if client hasn't consumed last frame, then release it
			lpcbuf = hcd->lpCurrent;
    	    hcd->lpCurrent = hcd->lpCurrent->lpPrev;
			DEBUGMSG(ZONE_CALLBACK, ("    %s: We already have current buffer (lpcbuf=0x%08lX). Returning this buffer to driver. Set new current buffer hcd->lpCurrent=0x%08lX\r\n", _fx_, lpcbuf, hcd->lpCurrent));
    	    if (!WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)lpcbuf))
			{
				ERRORMESSAGE(("    %s: Attempt to reuse unconsumed buffer failed\r\n", _fx_));
			}
    	}
    }
    else {
#else
    if (!hcd->lpCurrent) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
	    hcd->lpCurrent = hcd->lpTail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - some data\r\n", _fx_));
    SetEvent(hcd->hevWait);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\wdmdialg.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.cpp | Source file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"

// Globals
extern HINSTANCE g_hInst;

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CWDMDialog | Create | This function creates a new
 *    page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CWDMDialog::Create()
{
    PROPSHEETPAGE psp;
    
    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = g_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(m_DlgID);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc BOOL | CWDMDialog | BaseDlgProc | This function implements
 *    the dialog box procedure for the page of a property sheet.
 *
 *  @parm HWND | hDlg | Handle to dialog box.
 *
 *  @parm UINT | uMessage | Message sent to the dialog box.
 *
 *  @parm WPARAM | wParam | First message parameter.
 *
 *  @parm LPARAM | lParam | Second message parameter.
 *
 *  @rdesc Except in response to the WM_INITDIALOG message, the dialog box
 *    procedure returns nonzero if it processes the message, and zero if it
 *    does not.
 ***************************************************************************/
INT_PTR CALLBACK CWDMDialog::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CWDMDialog * pSV = (CWDMDialog*)GetWindowLong(hDlg,DWL_USER);

	FX_ENTRY("CWDMDialog::BaseDlgProc");

    switch (uMessage)
    {
        case WM_HELP:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("conf.hlp"), HELP_WM_HELP, (DWORD)pSV->m_pdwHelp);
			break;

        case WM_CONTEXTMENU:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)wParam, TEXT("conf.hlp"), HELP_CONTEXTMENU, (DWORD)pSV->m_pdwHelp);
			break;

        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
				pSV=(CWDMDialog*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg,DWL_USER,(LPARAM)pSV);
				pSV->m_bInit = FALSE;
				pSV->m_bChanged = FALSE;
				return TRUE;
			}
			break;

        case WM_COMMAND:
            if (pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam), HIWORD(wParam));
                if (!iRet && pSV->m_bInit)
				{
					PropSheet_Changed(GetParent(pSV->m_hDlg), pSV->m_hDlg);
					pSV->m_bChanged = TRUE;
				}
                return iRet;
            }
			break;

        case WM_HSCROLL:
			if (pSV && pSV->m_pCWDMPin && pSV->m_pPC)
			{
				HWND hwndControl = (HWND) lParam;
				HWND hwndSlider;
				ULONG i;
				TCHAR szTemp[32];
    
				for (i = 0 ; i < pSV->m_dwNumControls ; i++)
				{
					hwndSlider = GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider);

					// find matching slider
					if (hwndSlider == hwndControl)
					{
						LONG lValue = (LONG)SendMessage(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider), TBM_GETPOS, 0, 0);
						pSV->m_pCWDMPin->SetPropertyValue(pSV->m_guidPropertySet, pSV->m_pPC[i].uiProperty, lValue, KSPROPERTY_FLAGS_MANUAL, pSV->m_pPC[i].ulCapabilities);
						pSV->m_pPC[i].lCurrentValue = lValue;
						wsprintf(szTemp,"%d", lValue);
						SetWindowText(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiCurrent), szTemp);
						break;
					}
				}
			}

			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->SetActive();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						// Since we apply the changes on the fly when the user moves the slide bars,
						// there isn't much left to do on PSN_APPLY...
						if (pSV->m_bChanged)
							pSV->m_bChanged = FALSE;
						return FALSE;
						break;

					case PSN_QUERYCANCEL:    
						return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc void | CWDMDialog | CWDMDialog | Property page class constructor.
 *
 *  @parm int | DlgId | Resource ID of the property page dialog.
 *
 *  @parm DWORD | dwNumControls | Number of controls to display in the page.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are showing in
 *    the property page.
 *
 *  @parm PPROPSLIDECONTROL | pPC | Pointer to the list of slider controls
 *    to be displayed in the property page.
 *
 *  @parm PDWORD | pdwHelp | Pointer to the list of help IDs to be displayed
 *    in the property page.
 *
 *  @parm CWDMPin * | pCWDMPin | Pointer to the kernel streaming object
 *    we will query the property on.
 ***************************************************************************/
CWDMDialog::CWDMDialog(int DlgId, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, PDWORD pdwHelp, CWDMPin *pCWDMPin)
{
	FX_ENTRY("CWDMDialog::CWDMDialog");

	ASSERT(dwNumControls);
	ASSERT(pPC);

	m_DlgID = DlgId;
	m_pdwHelp = pdwHelp;
	m_pCWDMPin = pCWDMPin;
	m_dwNumControls = dwNumControls;
	m_guidPropertySet = guidPropertySet;
	m_pPC = pPC;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | SetActive | This function handles
 *    PSN_SETACTIVE by intializing all the property page controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::SetActive()
{
	FX_ENTRY("CWDMDialog::SetActive");

    DEBUGMSG(ZONE_DIALOGS, ("%s()\n", _fx_));

    if (!m_pCWDMPin || !m_pPC) 
        return 0;

    // Returns zero to accept the activation or
    // -1 to activate the next or previous page 
    // (depending on whether the user chose the Next or Back button)
    LONG i;
    EnableWindow(m_hDlg, TRUE);

    if (m_bInit) 
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplay[256];

    for (i = j = 0 ; i < (LONG)m_dwNumControls; i++)
	{
        // Get the current value
        if (m_pCWDMPin->GetPropertyValue(m_guidPropertySet, m_pPC[i].uiProperty, &lValue, &ulFlags, &ulCapabilities))
		{
            LoadString(g_hInst, m_pPC[i].uiString, szDisplay, sizeof(szDisplay));
            DEBUGMSG(ZONE_DIALOGS, ("%s: szDisplay = %s\n", _fx_, szDisplay));
            SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), szDisplay);

            // Get the Range of Values possible.
            if (m_pCWDMPin->GetRangeValues(m_guidPropertySet, m_pPC[i].uiProperty, &lMin, &lMax, &lStep)) 
			{
				HWND hTB = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

				DEBUGMSG(ZONE_DIALOGS, ("(%d, %d) / %d = %d \n", lMin, lMax, lStep, (lMax-lMin)/lStep));

				SendMessage(hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0);
				SendMessage(hTB, TBM_SETRANGE, 0, MAKELONG(lMin, lMax));
			}
            else
			{
                ERRORMESSAGE(("%s:Cannot get range values for this property ID = %d\n", _fx_, m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), TRUE);

			SendMessage(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TBM_SETPOS, TRUE, lValue);
			wsprintf(szDisplay,"%d", lValue);
			SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szDisplay);

            DEBUGMSG(ZONE_DIALOGS, ("%s: Capability = 0x%08lX; Flags=0x%08lX; lValue=%d\r\n", _fx_, ulCapabilities, ulFlags, lValue));
            DEBUGMSG(ZONE_DIALOGS, ("%s: switch(%d): \n", _fx_, ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO))
			{
				case KSPROPERTY_FLAGS_MANUAL:            
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto
					break;

				case KSPROPERTY_FLAGS_AUTO:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; 
					// always auto!
					SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;

				case (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO):
					// Set flags
					if (ulFlags & KSPROPERTY_FLAGS_AUTO)
					{
						DEBUGMSG(ZONE_DIALOGS, ("%s: Auto (checked) and slider disabled\n", _fx_));
						// Set auto check box; greyed out slider
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
					}
					else
					{
						// Unchecked auto; enable slider                    
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
					}
					break;

				case 0:
				default:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;
            }

            j++;

        }
		else
		{                
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);
        }            
    }
        
    // Disable the "default" push button; 
    // or inform user that no control is enabled.
    if (j == 0)
        EnableWindow(GetDlgItem(m_hDlg, IDC_DEFAULT), FALSE);

    return 0;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | DoCommand | This function handles WM_COMMAND. This
 *    is where a click on the Default button or one of the Auto checkboxes
 *    is handled
 *
 *  @parm WORD | wCmdID | Command ID.
 *
 *  @parm WORD | hHow | Notification code.
 *
 *  @rdesc Always returns 1.
 ***************************************************************************/
int CWDMDialog::DoCommand(WORD wCmdID, WORD hHow)
{
    // If a user select default settings of the video format
    if (wCmdID == IDC_DEFAULT)
	{
        if (m_pCWDMPin && m_pPC)
		{
            HWND hwndSlider;
            LONG  lDefValue;
			TCHAR szTemp[32];

            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                hwndSlider = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider))
				{
                    if (m_pCWDMPin->GetDefaultValue(m_guidPropertySet, m_pPC[i].uiProperty, &lDefValue))
					{
                        if (lDefValue != m_pPC[i].lCurrentValue)
						{
                            m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
							SendMessage(hwndSlider, TBM_SETPOS, TRUE, lDefValue);
							wsprintf(szTemp,"%d", lDefValue);
							SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szTemp);
							m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 1;
    }
	else if (hHow == BN_CLICKED)
	{
        if (m_pCWDMPin && m_pPC)
		{
            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID)
				{
                    if (BST_CHECKED == SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_GETCHECK, 1, 0))
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                    }
					else
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                    }    
                    break;
                }
            }
        }
    }

    return 1;    
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | QueryCancel | This function handles
 *    PSN_QUERYCANCEL by resetting the values of the controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::QueryCancel()
{
    if (m_pCWDMPin && m_pPC)
	{
        for (ULONG i = 0 ; i < m_dwNumControls ; i++)
		{
            if (IsWindowEnabled(GetDlgItem(m_hDlg, m_pPC[i].uiSlider)))
			{
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue) 
                    m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\wdmdrivr.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMDRIVER
 *
 *  @module WDMDrivr.cpp | Include file for <c CWDMDriver> class used to
 *    access the streaming class driver using IOctls.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | CWDMDriver | Driver class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMDriver::CWDMDriver(DWORD dwDeviceID) 
{
	m_hDriver = (HANDLE)NULL;
	m_pDataRanges = (PDATA_RANGES)NULL;

	m_dwDeviceID = dwDeviceID;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | ~CWDMDriver | Driver class destructor. Closes
 *    the driver file handle and releases the video data range memory.
 ***************************************************************************/
CWDMDriver::~CWDMDriver()
{
	if (m_hDriver) 
		CloseDriver();

	if (m_pDataRanges)
	{
		delete [] m_pDataRanges;
		m_pDataRanges = (PDATA_RANGES)NULL;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CreateDriverSupportedDataRanges | This
 *    function builds the list of video data ranges supported by the capture
 *    device.
 *
 *  @rdesc Returns the number of valid data ranges in the list.
 ***************************************************************************/
DWORD CWDMDriver::CreateDriverSupportedDataRanges()
{
	FX_ENTRY("CWDMDriver::CreateDriverSupportedDataRanges");

	DWORD cbReturned;
	DWORD dwSize = 0UL;

	// Initialize property structure to get data ranges
	KSP_PIN KsProperty = {0};

	KsProperty.PinId			= 0; // m_iPinNumber;
	KsProperty.Property.Set		= KSPROPSETID_Pin;
	KsProperty.Property.Id		= KSPROPERTY_PIN_DATARANGES ;
	KsProperty.Property.Flags	= KSPROPERTY_TYPE_GET;

	// Get the size of the data range structure
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
	{
		ERRORMESSAGE(("%s: Couldn't get the size for the data ranges\r\n", _fx_));
		return 0UL;
	}

	DEBUGMSG(ZONE_INIT, ("%s: GetData ranges needs %d bytes\r\n", _fx_, dwSize));

	// Allocate memory to hold data ranges
	if (m_pDataRanges)
		delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES) new BYTE[dwSize];

	if (!m_pDataRanges)
	{
		ERRORMESSAGE(("%s: Couldn't allocate memory for the data ranges\r\n", _fx_));
		return 0UL;
	}

	// Really get the data ranges
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), m_pDataRanges, dwSize, &cbReturned) == 0)
	{
		ERRORMESSAGE(("%s: Problem getting the data ranges themselves\r\n", _fx_));
		goto MyError1;
	}

	// Sanity check
	if (cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0)
	{
		ERRORMESSAGE(("%s: cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0\r\n", _fx_));
		goto MyError1;
	}

	return m_pDataRanges->Count;

MyError1:
	delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES)NULL;
	return 0UL;

}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | OpenDriver | This function opens a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::OpenDriver()
{
	FX_ENTRY("CWDMDriver::OpenDriver");

	// Don't re-open the driver
	if (m_hDriver)
	{
		DEBUGMSG(ZONE_INIT, ("%s: Class driver already opened\r\n", _fx_));
		return TRUE;
	}

	// Validate driver path
	if (lstrlen(g_aCapDevices[m_dwDeviceID]->szDeviceName) == 0)
	{
		ERRORMESSAGE(("%s: Invalid driver path\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Opening class driver '%s'\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName));

	// All we care is to wet the hInheritHanle = TRUE;
	SECURITY_ATTRIBUTES SecurityAttributes;
	SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);  // use pointers
	SecurityAttributes.bInheritHandle = TRUE;
	SecurityAttributes.lpSecurityDescriptor = NULL; // GetInitializedSecurityDescriptor();

	// Really open the driver
	if ((m_hDriver = CreateFile(g_aCapDevices[m_dwDeviceID]->szDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &SecurityAttributes, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) == INVALID_HANDLE_VALUE)
	{
		ERRORMESSAGE(("%s: CreateFile failed with Path=%s GetLastError()=%d\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName, GetLastError()));
		m_hDriver = (HANDLE)NULL;
		return FALSE;
	}

	// If there is no valid data range, we cannot stream
	if (!CreateDriverSupportedDataRanges())
	{
		CloseDriver();
		return FALSE;
	}
	else
		return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CloseDriver | This function closes a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::CloseDriver()
{
	FX_ENTRY("CWDMDriver::CloseDriver");

	BOOL bRet = TRUE;

	if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE))
	{
		if (!(bRet = CloseHandle(m_hDriver)))
		{
			ERRORMESSAGE(("%s: CloseHandle() failed with GetLastError()=%d\r\n", _fx_, GetLastError()));
		}
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: Nothing to close\r\n", _fx_));
	}

	m_hDriver = (HANDLE)NULL;

	return bRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | DeviceIoControl | This function wraps around
 *    ::DeviceIOControl.
 *
 *  @parm HANDLE | hFile | Handle to the device that is to perform the
 *    operation.
 *
 *  @parm DWORD | dwIoControlCode | Specifies the control code for the
 *    operation.
 *
 *  @parm LPVOID | lpInBuffer | Pointer to a buffer that contains the data
 *    required to perform the operation.
 *
 *  @parm DWORD | nInBufferSize | Specifies the size, in bytes, of the buffer
 *    pointed to by <p lpInBuffer>.
 *
 *  @parm LPVOID | lpOutBuffer | Pointer to a buffer that receives the
 *    operation's output data.
 *
 *  @parm DWORD | nOutBufferSize | Specifies the size, in bytes, of the
 *    buffer pointed to by <p lpOutBuffer>.
 *
 *  @parm LPDWORD | lpBytesReturned | Pointer to a variable that receives the
 *    size, in bytes, of the data stored into the buffer pointed to by
 *    <p lpOutBuffer>.
 *
 *  @parm BOOL | bOverlapped | If TRUE, the operation is performed
 *    asynchronously, if FALSE, the operation is synchronous.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::DeviceIoControl(HANDLE hFile, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped)
{
	FX_ENTRY("CWDMDriver::DeviceIoControl");

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
	{
		LPOVERLAPPED lpOverlapped=NULL;
		BOOL bRet;
		OVERLAPPED ov;
		DWORD dwErr;

		if (bOverlapped)
		{
			ov.Offset            = 0;
			ov.OffsetHigh        = 0;
			ov.hEvent            = CreateEvent( NULL, FALSE, FALSE, NULL );
			if (ov.hEvent == (HANDLE) 0)
			{
				ERRORMESSAGE(("%s: CreateEvent has failed\r\n", _fx_));
			}
			lpOverlapped        =&ov;
		}

		bRet = ::DeviceIoControl(hFile, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);

		if (bOverlapped)
		{
			BOOL bShouldBlock=FALSE;

			if (!bRet)
			{
				dwErr=GetLastError();
				switch (dwErr)
				{
					case ERROR_IO_PENDING:    // the overlapped IO is going to take place.
						bShouldBlock=TRUE;
						break;

					default:    // some other strange error has happened.
						ERRORMESSAGE(("%s: DevIoControl failed with GetLastError=%d\r\n", _fx_, dwErr));
						break;
				}
			}

			if (bShouldBlock)
			{
#ifdef _DEBUG
				DWORD    tmStart, tmEnd, tmDelta;
				tmStart = timeGetTime();
#endif

				DWORD dwRtn = WaitForSingleObject( ov.hEvent, 1000 * 10);  // USB has a max of 5 SEC bus reset

#ifdef _DEBUG
				tmEnd = timeGetTime();
				tmDelta = tmEnd - tmStart;
				if (tmDelta >= 1000)
				{
					ERRORMESSAGE(("%s: WaitObj waited %d msec\r\n", _fx_, tmDelta));
				}
#endif

				switch (dwRtn)
				{
					case WAIT_ABANDONED:
						ERRORMESSAGE(("%s: WaitObj: non-signaled ! WAIT_ABANDONED!\r\n", _fx_));
						bRet = FALSE;
						break;

					case WAIT_OBJECT_0:                    
						bRet = TRUE;
						break;

					case WAIT_TIMEOUT:
#ifdef _DEBUG
						ERRORMESSAGE(("%s: WaitObj: TIMEOUT after %d msec! rtn FALSE\r\n", _fx_, tmDelta));
#endif
						bRet = FALSE;
						break;

					default:
						ERRORMESSAGE(("%s: WaitObj: unknown return ! rtn FALSE\r\n", _fx_));
						bRet = FALSE;
						break;
				}
			}

			CloseHandle(ov.hEvent);
		}

		return bRet;
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetPropertyValue | This function gets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plValue | Pointer to a LONG to receive the current value.
 *
 *  @parm PULONG | pulFlags | Pointer to a ULONG to receive the current
 *    flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm PULONG | pulCapabilities | Pointer to a ULONG to receive the
 *    capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities)
{
	FX_ENTRY("CWDMDriver::GetPropertyValue");

	ULONG cbReturned;        

	// Inititalize video property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;
	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S));

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
	VideoProperty.Flags          = 0;

	// Get property value from driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: This property is not supported by this minidriver/device\r\n", _fx_));
		return FALSE;
	}

	*plValue         = VideoProperty.Value;
	*pulFlags        = VideoProperty.Flags;
	*pulCapabilities = VideoProperty.Capabilities;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetDefaultValue | This function gets the
 *    default value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plDefValue | Pointer to a LONG to receive the default value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue)    
{
	FX_ENTRY("CWDMDriver::GetDefaultValue");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;

	// Get the default values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	// Sanity check
	if (proList.proDesc.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION))
		return FALSE;
	else
	{
		*plDefValue = proList.ulData;
		return TRUE;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetRangeValues | This function gets the
 *    range values of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plMin | Pointer to a LONG to receive the minimum value.
 *
 *  @parm PLONG | plMax | Pointer to a LONG to receive the maximum value.
 *
 *  @parm PLONG | plStep | Pointer to a LONG to receive the step value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep)
{
	FX_ENTRY("CWDMDriver::GetRangeValues");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;

	// Get range values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	*plMin  = proList.proData.Bounds.SignedMinimum;
	*plMax  = proList.proData.Bounds.SignedMaximum;
	*plStep = proList.proData.SteppingDelta;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | SetPropertyValue | This function sets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm LONG | lValue | New value.
 *
 *  @parm ULONG | ulFlags | New flags. We only care about KSPROPERTY_*_FLAGS_MANUAL
 *    or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm ULONG | ulCapabilities | New capabilities. We only care about 
 *    KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities)
{
	FX_ENTRY("CWDMDriver::SetPropertyValue");

	ULONG cbReturned;        

	// Initialize property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;

	VideoProperty.Flags        = ulFlags;
	VideoProperty.Value        = lValue;
	VideoProperty.Capabilities = ulCapabilities;

	// Set the property value on the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *set* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\wdmpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMPIN
 *
 *  @module WDMPin.cpp | Include file for <c CWDMPin> class used to access
 *    video data on a video streaming pin exposed by the WDM class driver.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | CWDMPin | Video pin class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMPin::CWDMPin(DWORD dwDeviceID) : CWDMDriver(dwDeviceID)
{
	m_hKS			= (HANDLE)NULL;
	m_fStarted		= FALSE;
	m_hKsUserDLL	= (HINSTANCE)NULL;
	m_pKsCreatePin	= (LPFNKSCREATEPIN)NULL;

	ZeroMemory(&m_biHdr, sizeof(KS_BITMAPINFOHEADER));
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | ~CWDMPin | Video pin class destructor. Closes
 *    the video pin and releases the video buffers allocated.
 ***************************************************************************/
CWDMPin::~CWDMPin()
{
	FX_ENTRY("CWDMPin::~CWDMPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroying the video pin, m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	// Nuke the video streaming pin
	DestroyPin();

	// Close the driver
	if (GetDriverHandle())
		CloseDriver();

	// Release kernel streaming DLL (KSUSER.DLL)
	if (m_hKsUserDLL)
		FreeLibrary(m_hKsUserDLL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetFrame | This function gets a frame from the
 *    video streaming pin.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to the destination buffer to receive
 *    the video frame and information.
 *
 *  @parm PDWORD | pdwBytesUsed | Pointer to the number of bytes used to
 *    read the video frame.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetFrame(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMPin::GetFrame");

	ASSERT(lpVHdr && lpVHdr->lpData && GetDriverHandle() && m_hKS && (lpVHdr->dwBufferLength >= m_biHdr.biSizeImage));

	DWORD bRtn;

	// Check input params and state
	if (!lpVHdr || !lpVHdr->lpData || !GetDriverHandle() || !m_hKS || (lpVHdr->dwBufferLength < m_biHdr.biSizeImage))
	{
		ERRORMESSAGE(("%s: No buffer, no driver, no PIN connection, or buffer too small\r\n", _fx_));
		goto MyError0;
	}

	// Put the pin in streaming mode
	if (!Start())
	{
		ERRORMESSAGE(("%s: Cannot set streaming state to KSSTATE_RUN\r\n", _fx_));
		goto MyError0;
	}

	// Initialize structure to do a read on the video pin
	DWORD cbBytesReturned;
	KS_HEADER_AND_INFO SHGetImage;

	ZeroMemory(&SHGetImage,sizeof(SHGetImage));
	SHGetImage.StreamHeader.Data = (LPDWORD)lpVHdr->lpData;
	SHGetImage.StreamHeader.Size = sizeof (KS_HEADER_AND_INFO);
	SHGetImage.StreamHeader.FrameExtent = m_biHdr.biSizeImage;
	SHGetImage.FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

	// Read a frame on the video pin
	bRtn = DeviceIoControl(m_hKS, IOCTL_KS_READ_STREAM, &SHGetImage, sizeof(SHGetImage), &SHGetImage, sizeof(SHGetImage), &cbBytesReturned);

	if (!bRtn)
	{
		ERRORMESSAGE(("%s: DevIo rtn (%d), GetLastError=%d. StreamState->STOP\r\n", _fx_, bRtn, GetLastError()));

		// Stop streaming on the video pin
		Stop();

		goto MyError0;
	}

	// Sanity check
	ASSERT(SHGetImage.StreamHeader.FrameExtent >= SHGetImage.StreamHeader.DataUsed);
	if (SHGetImage.StreamHeader.FrameExtent < SHGetImage.StreamHeader.DataUsed)
	{
		ERRORMESSAGE(("%s: We've corrupted memory!\r\n", _fx_));
		goto MyError0;
	}

	lpVHdr->dwTimeCaptured = timeGetTime();
	lpVHdr->dwBytesUsed  = SHGetImage.StreamHeader.DataUsed;
	lpVHdr->dwFlags |= VHDR_KEYFRAME;

	return TRUE;

MyError0:
	if (lpVHdr)
	{
		lpVHdr->dwBytesUsed = 0UL;
		lpVHdr->dwTimeCaptured = timeGetTime();
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Start | This function puts the video
 *    pin in streaming mode.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Start()
{
	if (m_fStarted)
		return TRUE;

	if (SetState(KSSTATE_PAUSE))
		m_fStarted = SetState(KSSTATE_RUN);

	return m_fStarted;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Stop | This function stops streaming on the
 *    video pin.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Stop()
{
	if (m_fStarted)
	{
		if (SetState(KSSTATE_PAUSE))
			if (SetState(KSSTATE_STOP))
				m_fStarted = FALSE;
	}

	return (BOOL)(m_fStarted == FALSE);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function sets the state of the
 *    video streaming pin.
 *
 *  @parm KSSTATE | ksState | New state.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetState(KSSTATE ksState)
{
	KSPROPERTY	ksProp = {0};
	DWORD		cbRet;

	ksProp.Set		= KSPROPSETID_Connection;
	ksProp.Id		= KSPROPERTY_CONNECTION_STATE;
	ksProp.Flags	= KSPROPERTY_TYPE_SET;

	return DeviceIoControl(m_hKS, IOCTL_KS_PROPERTY, &ksProp, sizeof(ksProp), &ksState, sizeof(KSSTATE), &cbRet);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function either finds a video
 *    data range compatible with the bitamp info header passed in, of the
 *    prefered video data range.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdr | Bitmap info header to match.
 *
 *  @parm BOOL | pfValidMatch | Set to TRUE if a match was found, FALSE
 *    otherwise.
 *
 *  @rdesc Returns a valid pointer to a <t KS_DATARANGE_VIDEO> structure if
 *    successful, or a NULL pointer otherwise.
 *
 *  @comm \\redrum\slmro\proj\wdm10\src\dvd\amovie\proxy\filter\ksutil.cpp(207):KsGetMediaTypes(
 ***************************************************************************/
PKS_DATARANGE_VIDEO CWDMPin::FindMatchDataRangeVideo(PKS_BITMAPINFOHEADER pbiHdr, BOOL *pfValidMatch)
{
	FX_ENTRY("CWDMPin::FindMatchDataRangeVideo");

	ASSERT(pfValidMatch && pbiHdr);

	// Check input params and state
	if (!pbiHdr || !pfValidMatch)
	{
		ERRORMESSAGE(("%s: Bad input params\r\n", _fx_));
		return (PKS_DATARANGE_VIDEO)NULL;
	}

	// Default
	*pfValidMatch = FALSE;

	PDATA_RANGES pDataRanges = GetDriverSupportedDataRanges();

	ASSERT(pDataRanges != 0);

	if (!pDataRanges) 
		return (PKS_DATARANGE_VIDEO)NULL;

	PKS_DATARANGE_VIDEO pSelDRVideo, pDRVideo = &pDataRanges->Data, pFirstDRVideo = 0;
	KS_BITMAPINFOHEADER * pbInfo;

	// PhilF-: This code assumes that all structures are KS_DATARANGE_VIDEO. This
	// may not be a valid assumption foir palettized data types. Check with JayBo
	for (ULONG i = 0; i < pDataRanges->Count; i++)
	{ 
		// Meaningless unless it is *_VIDEOINFO
		if (pDRVideo->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO)
		{
			// We don't care about TV Tuner like devices
			if (pDRVideo->ConfigCaps.VideoStandard == KS_AnalogVideo_None)
			{
				// Save first useable data range
				if (!pFirstDRVideo)
					pFirstDRVideo = pDRVideo;  

				pbInfo = &((pDRVideo->VideoInfoHeader).bmiHeader);

				if ( (pbInfo->biBitCount == pbiHdr->biBitCount) && (pbInfo->biCompression == pbiHdr->biCompression) &&
					( (((pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0))
					&& (pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth) && (pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight)) ||
					((pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth) && (pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx) &&
					(pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight) && (pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy) &&
					((pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0) && ((pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0)) ) )
				{
					*pfValidMatch = TRUE;
					pSelDRVideo = pDRVideo;
					break;
				}
			} // VideoStandard
		} // Specifier

		pDRVideo++;  // Next KS_DATARANGE_VIDEO
	}

	// If no valid match, use the first range found
	if (!*pfValidMatch)
		pSelDRVideo = pFirstDRVideo;

	return (pSelDRVideo);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | CreatePin | This function actually creates a
 *    video streaming pin on the class driver.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiNewHdr | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the frame
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::CreatePin(PKS_BITMAPINFOHEADER pbiNewHdr, DWORD dwAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::CreatePin");

	ASSERT(m_pKsCreatePin);

	PKS_BITMAPINFOHEADER pbiHdr;
	BOOL bMustMatch, bValidMatch;
#ifdef _DEBUG
	char szFourCC[5] = {0};
#endif

	if (pbiNewHdr)
	{
		// We need to find a video data range that matches the bitmap info header passed in
		bMustMatch = TRUE;
		pbiHdr = pbiNewHdr;
	}
	else
	{
		// We'll use the preferred video data range and default bitmap format
		bMustMatch = FALSE;
		pbiHdr = &m_biHdr;
	}

	PKS_DATARANGE_VIDEO pSelDRVideo = FindMatchDataRangeVideo(pbiHdr, &bValidMatch);
	if (!pSelDRVideo)         
		return FALSE;

	if (bMustMatch && !bValidMatch)
		return FALSE;

	// If we already have a pin, nuke it
	if (GetPinHandle()) 
		DestroyPin();

	// Connect to a new PIN.
	DATAPINCONNECT DataConnect;
	ZeroMemory(&DataConnect, sizeof(DATAPINCONNECT));
	DataConnect.Connect.PinId						= 0;								// CODEC0 sink
	DataConnect.Connect.PinToHandle					= NULL;								// no "connect to"
	DataConnect.Connect.Interface.Set				= KSINTERFACESETID_Standard;
	DataConnect.Connect.Interface.Id				= KSINTERFACE_STANDARD_STREAMING;	// STREAMING
	DataConnect.Connect.Medium.Set					= KSMEDIUMSETID_Standard;
	DataConnect.Connect.Medium.Id					= KSMEDIUM_STANDARD_DEVIO;
	DataConnect.Connect.Priority.PriorityClass		= KSPRIORITY_NORMAL;
	DataConnect.Connect.Priority.PrioritySubClass	= 1;
	CopyMemory(&(DataConnect.Data.DataFormat), &(pSelDRVideo->DataRange), sizeof(KSDATARANGE));
	CopyMemory(&(DataConnect.Data.VideoInfoHeader), &pSelDRVideo->VideoInfoHeader, sizeof(KS_VIDEOINFOHEADER));

	// Adjust the image sizes if necessary
	if (bValidMatch)
	{
		DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth		= pbiHdr->biWidth;
		DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight		= abs(pbiHdr->biHeight); // Support only +biHeight!
		DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage	= pbiHdr->biSizeImage;        
	}

	// Overwrite the default frame rate if non-zero
	if (dwAvgTimePerFrame > 0)
		DataConnect.Data.VideoInfoHeader.AvgTimePerFrame = (REFERENCE_TIME)dwAvgTimePerFrame;

#ifdef _DEBUG
    *((DWORD*)&szFourCC) = DataConnect.Data.VideoInfoHeader.bmiHeader.biCompression;
#endif
	DEBUGMSG(ZONE_INIT, ("%s: Request image format: FourCC(%s) %d * %d * %d bits = %d bytes\r\n", _fx_, szFourCC, DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth, DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight, DataConnect.Data.VideoInfoHeader.bmiHeader.biBitCount, DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: Request frame rate:   %d fps\r\n", _fx_, 10000000/dwAvgTimePerFrame));
	DEBUGMSG(ZONE_INIT, ("%s: m_hKS was=0x%08lX\r\n", _fx_, m_hKS));

#ifndef HIDE_WDM_DEVICES
	DWORD dwErr = (*m_pKsCreatePin)(GetDriverHandle(), (PKSPIN_CONNECT)&DataConnect, GENERIC_READ | GENERIC_WRITE, &m_hKS);
#else
	DWORD dwErr = 0UL;
	m_hKS = NULL;
#endif

	if (dwAvgTimePerFrame != 0)
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX set to stream at %d fps\r\n", _fx_, m_hKS, 10000000/dwAvgTimePerFrame));
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX\r\n", _fx_, m_hKS));
	}

	if (dwErr || (m_hKS == NULL))
	{
		ERRORMESSAGE(("%s: KsCreatePin returned 0x%08lX failure and m_hKS=0x%08lX\r\n", _fx_, dwErr, m_hKS));

		if (m_hKS == INVALID_HANDLE_VALUE)
		{  
			m_hKS = (HANDLE)NULL;
		}

		return FALSE;
	}

	// Cache the bitmap info header
	CopyMemory(&m_biHdr, &DataConnect.Data.VideoInfoHeader.bmiHeader, sizeof(KS_BITMAPINFOHEADER));
	m_dwAvgTimePerFrame = (DWORD)DataConnect.Data.VideoInfoHeader.AvgTimePerFrame;

	DEBUGMSG(ZONE_INIT, ("%s: New m_biHdr:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, m_biHdr.biSize, m_biHdr.biWidth, m_biHdr.biHeight, m_biHdr.biPlanes, m_biHdr.biBitCount, m_biHdr.biCompression, m_biHdr.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: New m_dwAvgTimePerFrame=%ld (%fd fps)\r\n", _fx_, m_dwAvgTimePerFrame, 10000000/m_dwAvgTimePerFrame));

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | DestroyPin | This function nukes a video
 *    streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::DestroyPin()
{
	BOOL fRet = TRUE;

	FX_ENTRY("CWDMPin::DestroyPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroy PIN m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	if (m_hKS)
	{
		Stop();

		if (!(fRet = CloseHandle(m_hKS)))
		{
			ERRORMESSAGE(("%s: CloseHandle(m_hKS=0x%08lX) failed with GetLastError()=0x%08lX\r\n", _fx_, m_hKS, GetLastError()));
		}

		m_hKS = NULL;
	}

	return fRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetBitmapInfo | This function sets the video
 *    format of video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdrNew | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetBitmapInfo(PKS_BITMAPINFOHEADER pbiHdrNew)
{
	FX_ENTRY("CWDMPin::SetBitmapInfo");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: New pbiHdrNew:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbiHdrNew->biSize, pbiHdrNew->biWidth, pbiHdrNew->biHeight, pbiHdrNew->biPlanes, pbiHdrNew->biBitCount, pbiHdrNew->biCompression, pbiHdrNew->biSizeImage));

	// Check if we need to change anything
	if ( GetPinHandle() && (m_biHdr.biHeight == pbiHdrNew->biHeight) && (m_biHdr.biWidth == pbiHdrNew->biWidth) &&
		(m_biHdr.biBitCount == pbiHdrNew->biBitCount) && (m_biHdr.biSizeImage == pbiHdrNew->biSizeImage) &&
		(m_biHdr.biCompression == pbiHdrNew->biCompression) )
		return TRUE;
	else 
		return CreatePin(pbiHdrNew, m_dwAvgTimePerFrame);    

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetBitmapInfo | This function gets the video
 *    format of a video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbInfo | This parameter points to a bitmap
 *    info header structure to receive the video format.
 *
 *  @parm WORD | wSize | This parameter specifies the size of the bitmap
 *    info header structure.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo, WORD wSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage)
	{
		ERRORMESSAGE(("%s: No existing PIN handle or no available format\r\n", _fx_));
		return FALSE;
	}

	CopyMemory(pbInfo, &m_biHdr, wSize);  

	// Support only positive +biHeight.  
	if (pbInfo->biHeight < 0)
	{
		pbInfo->biHeight = -pbInfo->biHeight;
		DEBUGMSG(ZONE_INIT, ("%s: Changed biHeight from -%ld to %ld\r\n", _fx_, pbInfo->biHeight, pbInfo->biHeight));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetPaletteInfo | This function gets the video
 *    palette of a video streaming pin.
 *
 *  @parm CAPTUREPALETTE * | pPal | This parameter points to a palette
 *    structure to receive the video palette.
 *
 *  @parm DWORD | dwcbSize | This parameter specifies the size of the video
 *    palette.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetPaletteInfo(CAPTUREPALETTE *pPal, DWORD dwcbSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage && (m_biHdr.biBitCount > 8))
	{
		ERRORMESSAGE(("%s: No existing PIN handle, no available format, or bad biBitCount\r\n", _fx_));
		return FALSE;
	}

	// PhilF-: Copy some real bits there
	// CopyMemory(pbInfo, &m_biHdr, wSize);  

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetAverageTimePerFrame | This function sets the
 *    video frame rate of a video streaming pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the rate
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetAverageTimePerFrame(DWORD dwNewAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::SetAverageTimePerFrame");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Current frame interval=%d; new frame intercal=%d\r\n", _fx_, m_dwAvgTimePerFrame, dwNewAvgTimePerFrame));

    if (m_dwAvgTimePerFrame != dwNewAvgTimePerFrame)
		return CreatePin(&m_biHdr, dwNewAvgTimePerFrame);    
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: No need to change frame rate\r\n", _fx_));
        return TRUE;
    }

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | OpenDriverAndPin | This function opens the class
 *    driver and creates a video streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::OpenDriverAndPin()
{
	FX_ENTRY("CWDMPin::OpenDriverAndPin");

	// Load KSUSER.DLL and get a proc address
	if (m_hKsUserDLL = LoadLibrary("KSUSER"))
	{
		if (m_pKsCreatePin = (LPFNKSCREATEPIN)GetProcAddress(m_hKsUserDLL, "KsCreatePin"))
		{
			// Open the class driver
			if (OpenDriver())
			{
				// Create a video streaming pin on the driver
				if (CreatePin((PKS_BITMAPINFOHEADER)NULL))
				{
					return TRUE;
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: Pin connection creation failed!\r\n", _fx_));

					if (GetDriverHandle()) 
						CloseDriver();
				}
			}
		}

		FreeLibrary(m_hKsUserDLL);
	}


	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32\wdmstrmr.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMStrmr.cpp | Source file for <c CWDMStreamer> class used to get a
 *    stream of video data flowing from WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | CWDMStreamer | WDM filter class constructor.
 *
 *  @parm CWDMPin * | pWDMVideoPin | Pointer to the kernel streaming
 *    object we will get the frames from.
 ***************************************************************************/
CWDMStreamer::CWDMStreamer(CWDMPin * pWDMVideoPin)
{
	m_pWDMVideoPin = pWDMVideoPin;
	m_lpVHdrFirst = (LPVIDEOHDR)NULL;
	m_lpVHdrLast = (LPVIDEOHDR)NULL;
	m_fVideoOpen = FALSE;
	m_fStreamingStarted = FALSE;
	m_pBufTable = (PBUFSTRUCT)NULL;
	m_cntNumVidBuf = 0UL;
	m_idxNextVHdr = 0UL;
    m_hThread = NULL;
	m_bKillThread = FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | videoCallback | This function calls the
 *    callback function provided by the appplication.
 *
 *  @parm WORD | msg | Message value.
 *
 *  @parm DWORD | dwParam1 | 32-bit message-dependent parameter.
 ***************************************************************************/
void CWDMStreamer::videoCallback(WORD msg, DWORD dwParam1)
{
    if (m_CaptureStreamParms.dwCallback)
        DriverCallback (m_CaptureStreamParms.dwCallback, HIWORD(m_CaptureStreamParms.dwFlags), (HDRVR) m_CaptureStreamParms.hVideo, msg, m_CaptureStreamParms.dwCallbackInst, dwParam1, 0UL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc LPVIDEOHDR | CWDMStreamer | DeQueueHeader | This function dequeues a
 *    video buffer from the list of video buffers used for streaming.
 *
 *  @rdesc Returns a valid pointer if successful, or NULL otherwise.
 ***************************************************************************/
LPVIDEOHDR CWDMStreamer::DeQueueHeader()
{
	FX_ENTRY("CWDMStreamer::DeQueueHeader");

    LPVIDEOHDR lpVHdr;

    if (m_pBufTable)
	{
        if (m_pBufTable[m_idxNextVHdr].fReady)
		{
			DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

            lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
            lpVHdr->dwFlags &= ~VHDR_INQUEUE;
            m_pBufTable[m_idxNextVHdr].fReady = FALSE;
        }
		else
		{
            m_idxNextVHdr++;
            if (m_idxNextVHdr >= m_cntNumVidBuf)
                m_idxNextVHdr = 0;

			if (m_pBufTable[m_idxNextVHdr].fReady)
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

				lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
				lpVHdr->dwFlags &= ~VHDR_INQUEUE;
				m_pBufTable[m_idxNextVHdr].fReady = FALSE;
			}
			else
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: idxNextVHdr (idx=%d) has not been returned by client\r\n", _fx_, m_idxNextVHdr));
				lpVHdr = NULL;
			}
		}
    }
	else
	{
        lpVHdr = m_lpVHdrFirst;

        if (lpVHdr) {

            lpVHdr->dwFlags &= ~VHDR_INQUEUE;

            m_lpVHdrFirst = (LPVIDEOHDR)(lpVHdr->dwReserved[0]);
        
            if (m_lpVHdrFirst == NULL)
                m_lpVHdrLast = NULL;                            
        }
    }

    return lpVHdr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | QueueHeader | This function actually adds the
 *    video buffer to the list of video buffers used for streaming.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 ***************************************************************************/
void CWDMStreamer::QueueHeader(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::QueHeader");

	// Initialize status flags
    lpVHdr->dwFlags &= ~VHDR_DONE;
    lpVHdr->dwFlags |= VHDR_INQUEUE;
    lpVHdr->dwBytesUsed = 0;

    // Add buffer to list
    if (m_pBufTable)
	{
		if (lpVHdr->dwReserved[1] < m_cntNumVidBuf)
		{
			if (m_pBufTable[lpVHdr->dwReserved[1]].lpVHdr != lpVHdr)
			{
				DEBUGMSG(ZONE_STREAMING, ("        %s: index (%d) Match but lpVHdr does not(%x)\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
			}
			m_pBufTable[lpVHdr->dwReserved[1]].fReady = TRUE;
			DEBUGMSG(ZONE_STREAMING, ("        %s: Buffer lpVHdr=0x%08lX was succesfully queued\r\n", _fx_, lpVHdr));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("        %s: lpVHdr->dwReserved[1](%d) >= m_cntNumVidBuf (%d)\r\n", _fx_, lpVHdr->dwReserved[1], m_cntNumVidBuf));
		}
	}
	else
	{
		*(lpVHdr->dwReserved) = NULL;

		if (m_lpVHdrLast)
			*(m_lpVHdrLast->dwReserved) = (DWORD)(LPVOID)lpVHdr;
		else
			m_lpVHdrFirst = lpVHdr;

		m_lpVHdrLast = lpVHdr;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | AddBuffer | This function adds a buffer to the
 *    list of video buffers to be used when streaming video data from the WDM
 *    device.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_ADDBUFFER message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::AddBuffer(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::AddBuffer");

	ASSERT(m_fVideoOpen && lpVHdr && !(lpVHdr->dwFlags & VHDR_INQUEUE));

	// Make sure this is a valid call
    if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because m_fVideoOpen=FALSE\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!lpVHdr)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because lpVHdr=NULL\r\n", _fx_, lpVHdr));
		return FALSE;
	}

    if (lpVHdr->dwFlags & VHDR_INQUEUE)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because buffer is already queued\r\n", _fx_, lpVHdr));
		return FALSE;
	}

	// Does the size of the buffer match the size of the buffers the streaming pin will generate?
    if (lpVHdr->dwBufferLength < m_pWDMVideoPin->GetFrameSize())
	{
		ERRORMESSAGE(("%s: Buffer lpVHdr=0x%08lX can't be queued because the length of that buffer is too small\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!m_pBufTable)
	{
        lpVHdr->dwReserved[1] = m_cntNumVidBuf;
        m_cntNumVidBuf++;
		DEBUGMSG(ZONE_STREAMING, ("%s: Queue buffer (%d) lpVHdr=0x%08lX\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
    }

    QueueHeader(lpVHdr);

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stop | This function stops a stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_STOP message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Stop()
{
	FX_ENTRY("CWDMStreamer::Stop");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Reset data members - stop streaming thread
    m_fStreamingStarted = FALSE;

    if (m_hThread)
    {

		DEBUGMSG(ZONE_STREAMING, ("%s: Stopping the thread\r\n", _fx_));

        // Signal the streaming thread to stop
		m_bKillThread = TRUE;

        // wait until thread has self-terminated, and clear the event.
		DEBUGMSG(ZONE_STREAMING, ("%s: WaitingForSingleObject...\r\n", _fx_));

        WaitForSingleObject(m_hThread, INFINITE);

		DEBUGMSG(ZONE_STREAMING, ("%s: ...thread stopped\r\n", _fx_));

		// Close the thread handle
		CloseHandle(m_hThread);
		m_hThread = NULL;

		// Ask the pin to stop streaming.
		m_pWDMVideoPin->Stop();

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
			{
				SetEvent(m_pWDMVideoBuff[i].Overlap.hEvent);
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
				m_pWDMVideoBuff[i].Overlap.hEvent = NULL;
			}
		}

		if (m_pWDMVideoBuff)
		{
			delete []m_pWDMVideoBuff;
			m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;
		}

    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Reset | This function resets a stream of
 *    video data coming from the WDM device so that prepared buffer may be
 *    freed correctly.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_RESET message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Reset()
{
	LPVIDEOHDR lpVHdr;

	FX_ENTRY("CWDMStreamer::Reset");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
    Stop();

	// Return all buffers to the application one last time
	while (lpVHdr = DeQueueHeader ())
	{
		lpVHdr->dwFlags |= VHDR_DONE;
		videoCallback(MM_DRVM_DATA, (DWORD) lpVHdr);
	}

	// Reset data members
    m_lpVHdrFirst = (LPVIDEOHDR)NULL;
    m_lpVHdrLast = (LPVIDEOHDR)NULL;
    if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Open | This function opens a stream of
 *    video data coming from the WDM device.
 *
 *  @parm LPVIDEO_STREAM_INIT_PARMS | lpStreamInitParms | Pointer to
 *    initialization data.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_INIT message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Open(LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms)
{
	FX_ENTRY("CWDMStreamer::Open");

	ASSERT(!m_fVideoOpen);

	// Make sure this is a valid call
	if (m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is already opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Initialize data memmbers
	m_CaptureStreamParms	= *lpStreamInitParms;
	m_fVideoOpen			= TRUE;
	m_lpVHdrFirst			= (LPVIDEOHDR)NULL;
	m_lpVHdrLast			= (LPVIDEOHDR)NULL;
	m_cntNumVidBuf			= 0UL;

	// Set frame rate on the pin
	m_pWDMVideoPin->SetAverageTimePerFrame(lpStreamInitParms->dwMicroSecPerFrame * 10);

	// Let the app know we just opened a stream
	videoCallback(MM_DRVM_OPEN, 0L);

	if (lpStreamInitParms->dwMicroSecPerFrame != 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Capturing at %d frames/sec\r\n", _fx_, 100000 / lpStreamInitParms->dwMicroSecPerFrame));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Close | This function closes the stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_FINI message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Close()
{
	FX_ENTRY("CWDMStreamer::Close");

	ASSERT(m_fVideoOpen && !m_lpVHdrFirst);

	// Make sure this is a valid call
	if (!m_fVideoOpen || m_lpVHdrFirst)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
	Stop();

	// Reset data members
	m_fVideoOpen = FALSE;   
	m_lpVHdrFirst = m_lpVHdrLast = (LPVIDEOHDR)NULL; 
	m_idxNextVHdr = 0UL;

	// Release table of pointers to video buffers
	if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
	}

	// Let the app know that we just closed the stream
	videoCallback(MM_DRVM_CLOSE, 0L);

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | BufferDone | This function lets the application
 *    know that there is video data available coming from the WDM device.
 *
 *  @devnote This method is called by the kernel streaming object (Pin)
 ***************************************************************************/
void CWDMStreamer::BufferDone(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::BufferDone");

	// Make sure this is a valid call
	if (!m_fStreamingStarted)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Video has not been started or just been stopped\r\n", _fx_));
		return;
	}

    if (lpVHdr == NULL)
	{
		// No buffers available - the app hasn't returned the buffers to us yet
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that we don't have any buffers anymore since lpVHdr=NULL\r\n", _fx_));

		// Let the app know something wrong happened
        videoCallback(MM_DRVM_ERROR, 0UL);
        return;
    }

    lpVHdr->dwFlags |= VHDR_DONE;

	// Sanity check
    if (lpVHdr->dwBytesUsed == 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is no valid data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

		// Return frame to the pool before notifying app
		AddBuffer(lpVHdr);
        videoCallback(MM_DRVM_ERROR, 0UL);
    }
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

        lpVHdr->dwTimeCaptured = timeGetTime() - m_dwTimeStart;

		// Let the app know there's some valid video data available
        videoCallback(MM_DRVM_DATA, (DWORD)lpVHdr);
    }
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Start | This function starts streaming
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_START message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Start()
{
	FX_ENTRY("CWDMStreamer::Start");

    ULONG i;
    LPVIDEOHDR lpVHdr;
	DWORD dwThreadID;

	ASSERT(m_fVideoOpen && m_pWDMVideoPin->GetAverageTimePerFrame() && !m_hThread);

	// Make sure this is a valid call
	if (!m_fVideoOpen || !m_pWDMVideoPin->GetAverageTimePerFrame() || m_hThread)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming in %d video buffers at %d frames/sec\r\n", _fx_, m_cntNumVidBuf, 1000000 / m_pWDMVideoPin->GetAverageTimePerFrame()));

	// Allocate and initialize the video buffer structures
    m_pBufTable = (PBUFSTRUCT) new BUFSTRUCT[m_cntNumVidBuf];
    if (m_pBufTable)
	{
		lpVHdr = m_lpVHdrFirst;
		for (i = 0; i < m_cntNumVidBuf && lpVHdr; i++)
		{
			m_pBufTable[i].fReady = TRUE;
			m_pBufTable[i].lpVHdr = lpVHdr;
			lpVHdr = (LPVIDEOHDR) lpVHdr->dwReserved[0];
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_pBufTable allocation failed! AsynIO may be out of sequence\r\n", _fx_));
	}

    m_idxNextVHdr		= 0UL;  // 0..m_cntNumVidBuf-1
    m_dwTimeStart		= timeGetTime();
    m_fStreamingStarted	= TRUE;
	m_bKillThread = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("%s: Creating %d read video buffers\r\n", _fx_, m_cntNumVidBuf));

	if (!(m_pWDMVideoBuff = (WDMVIDEOBUFF *) new WDMVIDEOBUFF[m_cntNumVidBuf]))
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_Overlap allocation failed!\r\n", _fx_));
		return FALSE;
	}

	for(i=0; i<m_cntNumVidBuf; i++)
	{
		// Create the overlapped structures
		ZeroMemory( &(m_pWDMVideoBuff[i].Overlap), sizeof(OVERLAPPED) );
		m_pWDMVideoBuff[i].Overlap.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

		DEBUGMSG(ZONE_STREAMING, ("%s: Event %d is handle 0x%08lX\r\n", _fx_, i, m_pWDMVideoBuff[i].Overlap.hEvent));
	}

	m_dwNextToComplete=0;

    // Create the streaming thread
    m_hThread = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)ThreadStub,
                                this,
                                CREATE_SUSPENDED, 
                                &dwThreadID);

    if (m_hThread == NULL) 
    {
		ERRORMESSAGE(("%s: Couldn't create the thread\r\n", _fx_));

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
		}

		delete []m_pWDMVideoBuff;
		m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;

		m_lpVHdrFirst = (LPVIDEOHDR)NULL;
		m_lpVHdrLast = (LPVIDEOHDR)NULL;
		if (m_pBufTable)
		{
			delete []m_pBufTable;
			m_pBufTable = NULL;
		}

        return FALSE;
    }

    SetThreadPriority(m_hThread, THREAD_PRIORITY_ABOVE_NORMAL);

    ResumeThread(m_hThread);

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread created OK\r\n", _fx_));

    return TRUE;

}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stream | This function does the actual
 *    streaming.
 ***************************************************************************/
void CWDMStreamer::Stream()
{
	FX_ENTRY("CWDMStreamer::Stream");

	DEBUGMSG(ZONE_STREAMING, ("%s: Starting to process StreamingThread\r\n", _fx_));

	// Put the pin in streaming mode
	m_pWDMVideoPin->Start();

	// Queue all the reads
	for (UINT i = 0; i<m_cntNumVidBuf; i++)
	{
		QueueRead(i);
	}

	m_dwNextToComplete=0;
#ifdef _DEBUG
	m_dwFrameCount=0;
#endif
	BOOL  bGotAFrame=FALSE;
	DWORD dwRes;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Starting to wait on reads to complete\r\n", _fx_));

	while (!m_bKillThread)
	{
		bGotAFrame = FALSE;

		if (m_pWDMVideoBuff[m_dwNextToComplete].fBlocking)
		{
			DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Waiting on read to complete...\r\n", _fx_));

			// Waiting for the asynchronous read to complete
			dwRes = WaitForSingleObject(m_pWDMVideoBuff[m_dwNextToComplete].Overlap.hEvent, 1000*1);

			if (dwRes == WAIT_FAILED)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...we couldn't perform the wait as requested\r\n", _fx_));
			}

			if (dwRes == WAIT_OBJECT_0)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...wait is over - we now have a frame\r\n", _fx_));
				bGotAFrame = TRUE;
			}
			else
			{
				// time out waiting for frames.
				if (dwRes == WAIT_TIMEOUT)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Waiting failed with timeout, last error=%d\r\n", _fx_, GetLastError()));
				}
			}
		}
		else
		{
			// We didn't have to wait - this means the read executed synchronously
			bGotAFrame = TRUE;
		}

		if (bGotAFrame)
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Trying to give frame #%ld to the client\r\n", _fx_, m_dwFrameCount++));

			LPVIDEOHDR lpVHdr;

			lpVHdr = m_pWDMVideoBuff[m_dwNextToComplete].pVideoHdr;

			if (lpVHdr)
			{
				lpVHdr->dwBytesUsed = m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.StreamHeader.DataUsed;

				if ((m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.FrameInfo.dwFrameFlags & 0x00f0) == KS_VIDEO_FLAG_I_FRAME) 
					lpVHdr->dwFlags |= VHDR_KEYFRAME;
			}

			// Mark the buffer as done - signal the app
			BufferDone(lpVHdr);

			// Queue a new read
			QueueRead(m_dwNextToComplete);
		}

		m_dwNextToComplete++;
		m_dwNextToComplete %= m_cntNumVidBuf;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: End of the streaming thread\r\n", _fx_));

	ExitThread(0);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | QueueRead | This function queues a read
 *    operation on a video streaming pin.
 *
 *  @parm DWORD | dwIndex | Index of the video structure in read buffer.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMStreamer::QueueRead(DWORD dwIndex)
{
	FX_ENTRY("CWDMStreamer::QueueRead");

	DWORD cbReturned;
	BOOL  bShouldBlock = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Queue read buffer %d on pin handle 0x%08lX\r\n", _fx_, dwIndex, m_pWDMVideoPin->GetPinHandle()));

	// Get a buffer from the queue of video buffers
	m_pWDMVideoBuff[dwIndex].pVideoHdr = DeQueueHeader();

	if (m_pWDMVideoBuff[dwIndex].pVideoHdr)
	{
		ZeroMemory(&m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage));
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Size				= sizeof (KS_HEADER_AND_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.FrameInfo.ExtendedHeaderSize	= sizeof (KS_FRAME_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Data				= m_pWDMVideoBuff[dwIndex].pVideoHdr->lpData;
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.FrameExtent		= m_pWDMVideoPin->GetFrameSize();

		// Submit the read
		BOOL bRet = DeviceIoControl(m_pWDMVideoPin->GetPinHandle(), IOCTL_KS_READ_STREAM, &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &cbReturned, &m_pWDMVideoBuff[dwIndex].Overlap);

		if (!bRet)
		{
			DWORD dwErr = GetLastError();
			switch(dwErr)
			{
				case ERROR_IO_PENDING:
					DEBUGMSG(ZONE_STREAMING, ("%s: An overlapped IO is going to take place\r\n", _fx_));
					bShouldBlock = TRUE;
					break;

				// Something bad happened
				default:
					DEBUGMSG(ZONE_STREAMING, ("%s: DeviceIoControl() failed badly dwErr=%d\r\n", _fx_, dwErr));
					break;
			}
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Overlapped IO won't take place - no need to wait\r\n", _fx_));
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: We won't queue the read - no buffer available\r\n", _fx_));
	}

	m_pWDMVideoBuff[dwIndex].fBlocking = bShouldBlock;

	return bShouldBlock;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | ThreadStub | Thread stub.
 ***************************************************************************/
LPTHREAD_START_ROUTINE CWDMStreamer::ThreadStub(CWDMStreamer *pCWDMStreamer)
{
	FX_ENTRY("CWDMStreamer::ThreadStub");

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread stub called, starting streaming...\r\n", _fx_));

    pCWDMStreamer->Stream();

	DEBUGMSG(ZONE_STREAMING, ("%s: ...capture thread has stopped\r\n", _fx_));

    return(0);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\dcapnt.cpp ===
//
//  Created 5-Nov-96 [RichP]

#include "Precomp.h"

DWORD
_GetVideoFormatSize(
    HDRVR hvideo
    )
{
	DWORD bufsize;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = &bufsize;
    vcp.lpData1 = NULL;
    vcp.dwSize1 = 0;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

#if 0
    // it makes sense to query if DVM_FORMAT is available, but not all drivers support it!
	if (SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERY),
							(LPARAM)(LPVOID)&vcp) == DV_ERR_OK) {
#endif
		SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE),
							(LPARAM)(LPVOID)&vcp);
        if (!bufsize)
            bufsize = sizeof(BITMAPINFOHEADER);
		return bufsize;
#if 0
    } else
        return sizeof(BITMAPINFOHEADER);
#endif
}

BOOL
_GetVideoFormat(
    HVIDEO hvideo,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL res;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    res = !SendDriverMessage((HDRVR)hvideo, DVM_FORMAT,
			(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
			(LPARAM)(LPVOID)&vcp);
	if (res) {
		// hack for Connectix QuickCam - set format needs to be called
		//   to set internal globals so that streaming can be enabled
		SendDriverMessage((HDRVR)hvideo, DVM_FORMAT,
	        (LPARAM)(DWORD)VIDEO_CONFIGURE_SET, (LPARAM)(LPVOID)&vcp);
	}
	return res;
}

BOOL
_SetVideoFormat(
    HVIDEO hvideoExtIn,
    HVIDEO hvideoIn,
    LPBITMAPINFOHEADER lpbmih
    )
{
    RECT rect;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    // See if the driver likes the format
    if (SendDriverMessage((HDRVR)hvideoIn, DVM_FORMAT, (LPARAM)(DWORD)VIDEO_CONFIGURE_SET,
        (LPARAM)(LPVOID)&vcp))
        return FALSE;

    // Set the rectangles
    rect.left = rect.top = 0;
    rect.right = (WORD)lpbmih->biWidth;
    rect.bottom = (WORD)lpbmih->biHeight;
    SendDriverMessage((HDRVR)hvideoExtIn, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
    SendDriverMessage((HDRVR)hvideoIn, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);

    return TRUE;
}

BOOL
_GetVideoPalette(
    HVIDEO hvideo,
    LPCAPTUREPALETTE lpcp,
    DWORD dwcbSize
    )
{
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = (LPVOID)lpcp;
    vcp.dwSize1 = dwcbSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0;

    return !SendDriverMessage((HDRVR)hvideo, DVM_PALETTE,
	(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
	(DWORD_PTR)&vcp);


}


void
FrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    )
{
	FX_ENTRY("FrameCallback");

	DEBUGMSG(ZONE_CALLBACK, ("%s: wMsg=%s, hcd=0x%08lX, lpcbuf=0x%08lX, hcd->hevWait=0x%08lX\r\n", _fx_, (wMsg == MM_DRVM_OPEN) ? "MM_DRVM_OPEN" : (wMsg == MM_DRVM_CLOSE) ? "MM_DRVM_CLOSE" : (wMsg == MM_DRVM_ERROR) ? "MM_DRVM_ERROR" : (wMsg == MM_DRVM_DATA) ? "MM_DRVM_DATA" : "MM_DRVM_?????", hcd, lpcbuf, hcd->hevWait));

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGMSG(ZONE_CALLBACK, ("%s: Setting hcd->hevWait - no data\r\n", _fx_));
	    SetEvent(hcd->hevWait);
	    return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (hcd->lpTail != hcd->lpCurrent)
	    hcd->lpTail = hcd->lpTail->lpPrev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!hcd->lpTail)
	    hcd->lpHead = NULL;

    // Add the new buffer to the ready queue
    lpcbuf->lpNext = hcd->lpHead;
    lpcbuf->lpPrev = NULL;
    if (hcd->lpHead)
	    hcd->lpHead->lpPrev = lpcbuf;
    else
	    hcd->lpTail = lpcbuf;
    hcd->lpHead = lpcbuf;

#if 1
    if (hcd->lpCurrent) {
        if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
    	    // if client hasn't consumed last frame, then release it
			lpcbuf = hcd->lpCurrent;
    	    hcd->lpCurrent = hcd->lpCurrent->lpPrev;
			DEBUGMSG(ZONE_CALLBACK, ("%s: We already have current buffer (lpcbuf=0x%08lX). Returning this buffer to driver. Set new current buffer hcd->lpCurrent=0x%08lX\r\n", _fx_, lpcbuf, hcd->lpCurrent));
			// Signal that the application is done with the buffer
			lpcbuf->vh.dwFlags &= ~VHDR_DONE;
    	    if (SendDriverMessage(reinterpret_cast<HDRVR>(hvideo), DVM_STREAM_ADDBUFFER, (DWORD_PTR)lpcbuf, sizeof(VIDEOHDR)) != 0)
			{
				ERRORMESSAGE(("%s: Attempt to reuse unconsumed buffer failed\r\n", _fx_));
			}
    	}
    }
    else {
#else
    if (!hcd->lpCurrent) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
	    hcd->lpCurrent = hcd->lpTail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGMSG(ZONE_CALLBACK, ("%s: Setting hcd->hevWait - some data\r\n", _fx_));
    SetEvent(hcd->hevWait);
}


BOOL
_InitializeVideoStream(
	HVIDEO hvideo,
    DWORD dwMicroSecPerFrame,
    DWORD_PTR hcd
	)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    ZeroMemory((LPSTR)&vsip, sizeof (VIDEO_STREAM_INIT_PARMS));
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD_PTR)FrameCallback;
    vsip.dwCallbackInst = hcd;
    vsip.dwFlags = CALLBACK_FUNCTION;
    vsip.hVideo = (DWORD_PTR)hvideo;

    return !SendDriverMessage((HDRVR)hvideo, DVM_STREAM_INIT,
		(DWORD_PTR)&vsip,
		(DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}

BOOL
_UninitializeVideoStream(
	HVIDEO hvideo
	)
{
    return !SendDriverMessage((HDRVR)hvideo, DVM_STREAM_FINI, 0L, 0L);
}


BOOL
_InitializeExternalVideoStream(
    HVIDEO hvideo
	)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    vsip.dwMicroSecPerFrame = 0;    // Ignored by driver for this channel
    vsip.dwCallback = 0L;           // No callback for now
    vsip.dwCallbackInst = 0L;
    vsip.dwFlags = 0;
    vsip.hVideo = (DWORD_PTR)hvideo;

    return !SendDriverMessage((HDRVR)hvideo, DVM_STREAM_INIT,
	                          (DWORD_PTR)&vsip,
	                          (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}


BOOL
_PrepareHeader(
	HANDLE hvideo,
    VIDEOHDR *vh
    )
{
    return (SendDriverMessage((HDRVR)hvideo, DVM_STREAM_PREPAREHEADER,
		        (DWORD_PTR)vh, (DWORD) sizeof (VIDEOHDR)) == DV_ERR_OK);
}

LRESULT
_UnprepareHeader(
	HANDLE hvideo,
    VIDEOHDR *vh
    )
{
    return SendDriverMessage((HDRVR)hvideo, DVM_STREAM_UNPREPAREHEADER,
		        (DWORD_PTR)vh, (DWORD) sizeof (VIDEOHDR));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\dcap32.cpp ===
//
//  Created 31-Jul-96 [JonT]

// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

#ifndef WIDTHBYTES
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)
#endif

#ifdef _DEBUG
static PTCHAR _rgZonesCap[] = {
	TEXT("dcap"),
	TEXT("Init"),
	TEXT("Streaming"),
	TEXT("Callback"),
	TEXT("Dialogs"),
	TEXT("Trace")
};
#endif

#ifndef __NT_BUILD__
extern "C" {
// Special thunk prototype
BOOL    thk_ThunkConnect32(LPSTR pszDll16, LPSTR pszDll32,
        HINSTANCE hInst, DWORD dwReason);

//; Magic Function code values for DeviceIOControl code.
//DCAPVXD_THREADTIMESERVICE equ	101h
//DCAPVXD_R0THREADIDSERVICE equ 102h
#define DCAPVXD_THREADTIMESERVICE 0x101
#define DCAPVXD_R0THREADIDSERVICE 0x102


// KERNEL32 prototypes (not in headers but are exported by name on Win95)
void* WINAPI    MapSL(DWORD dw1616Ptr);
HANDLE WINAPI   OpenVxDHandle(HANDLE h);
}
#endif

// Helper function prototypes
BOOL    initializeCaptureDeviceList(void);
HVIDEO  openVideoChannel(DWORD dwDeviceID, DWORD dwFlags);
BOOL    allocateBuffers(HCAPDEV hcd, int nBuffers);
void    freeBuffers(HCAPDEV hcd);

// Globals
	HINSTANCE g_hInst;
    int g_cDevices;
    LPINTERNALCAPDEV g_aCapDevices[DCAP_MAX_DEVICES];

	BOOL g_fInitCapDevList;
#define INIT_CAP_DEV_LIST() if (g_fInitCapDevList) { initializeCaptureDeviceList(); }

#ifndef __NT_BUILD__
    HANDLE s_hVxD = NULL;
#endif //__NT_BUILD__

// Strings
#ifdef __NT_BUILD__
    char g_szVFWRegKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32";
    char g_szVFWRegDescKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc";
    char g_szDriverName[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "WDM Video For Windows Capture Driver (Win32)";
    char g_szVfWToWDMMapperName[] = "VfWWDM32.dll";
#endif
#else
    char g_szVFWRegKey[] = "SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo";
    char g_szRegDescription[] = "Description";
    char g_szRegName[] = "Driver";
    char g_szRegDisabled[] = "Disabled";
    char g_szDevNode[] = "DevNode";
    char g_szSystemIni[] = "system.ini";
    char g_szDriverSection[] = "drivers";
    char g_szDriverKey[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "VfW MM 16bit Driver for WDM V. Cap. Devices";
    char g_szVfWToWDMMapperName[] = "vfwwdm.drv";
#endif
#endif
    char g_szMSOfficeCamcorderDescription[] = "Screen Capture Device Driver for AVI";
    char g_szMSOfficeCamcorderName[] = "Gdicap97.drv";

    char g_szVerQueryForDesc[] = "\\StringFileInfo\\040904E4\\FileDescription";


void DoClose(HCAPDEV hcd);

#define ENTER_DCAP(hcd) InterlockedIncrement(&(hcd)->busyCount);
#define LEAVE_DCAP(hcd) if (InterlockedDecrement(&(hcd)->busyCount) == 0) DoClose((hcd));

//  DllEntryPoint

extern "C" BOOL
DllEntryPoint(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    static int s_nProcesses = 0;

	FX_ENTRY("DllEntryPoint");

#ifndef __NT_BUILD__

    // We want to load the VxD even before initializing the thunks
    // because the 16-bit half initializes the VxD during the thk_ThunkConnect32 call
    if (!s_hVxD)
    {
        s_hVxD = CreateFile("\\\\.\\DCAPVXD.VXD", 0,0,0,0, FILE_FLAG_DELETE_ON_CLOSE, 0);
        if (s_hVxD == INVALID_HANDLE_VALUE)
        {
			ERRORMESSAGE(("%s: Failure loading VxD - Fatal\r\n", _fx_));
            return FALSE;
        }
    }

    // Initialize the thunks
    if (!(thk_ThunkConnect32("DCAP16.DLL", "DCAP32.DLL", hInst, dwReason)))
    {
		ERRORMESSAGE(("%s: thk_ThunkConnect32 failed!\r\n", _fx_));
        return FALSE;
    }
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

		// Save global hinst
		g_hInst = hInst;

        // Only initialize on the first DLL load
        if (s_nProcesses++ == 0)
        {
			DBGINIT(&ghDbgZoneCap, _rgZonesCap);

            DBG_INIT_MEMORY_TRACKING(hInst);

			g_fInitCapDevList = TRUE;
        }
        else
            return FALSE;   // fail to load multiple instances
        break;

    case DLL_PROCESS_DETACH:
        if (--s_nProcesses == 0)    // Are we going away?
        {
#ifndef __NT_BUILD__
            CloseHandle(s_hVxD);
            s_hVxD = NULL;
#endif
            DBG_CHECK_MEMORY_TRACKING(hInst);

			DBGDEINIT(&ghDbgZoneCap);
        }
        break;
    }

    return TRUE;
}


void GetVersionData (LPINTERNALCAPDEV lpcd)
{
    int j;
    DWORD dwVerInfoSize;
    LPSTR lpstrInfo;
    LPSTR lpDesc;

    // Version number
    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(lpcd->szDeviceName, NULL);
    if (dwVerInfoSize && (lpstrInfo  = (LPSTR)LocalAlloc(LPTR, dwVerInfoSize))) {
        // Read from the file into our block
        if (GetFileVersionInfo(lpcd->szDeviceName, 0L, dwVerInfoSize, lpstrInfo)) {
            lpDesc = NULL;
            if (VerQueryValue(lpstrInfo, g_szVerQueryForDesc, (LPVOID *)&lpDesc, (PUINT)&j) && lpDesc) {
                lstrcpyn(lpcd->szDeviceDescription, lpDesc, j);
                    wsprintf(lpcd->szDeviceVersion, TEXT("Version:  %d.%d.%d.%d"),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS));
            }
        }
        LocalFree(lpstrInfo);
    }
}


#ifdef __NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry
//      Returns FALSE iff there are no video devices.
BOOL
initializeCaptureDeviceList(void)
{
	HKEY hkeyVFW, hkeyVFWdesc;
	DWORD dwType;
	DWORD dwSize;
	int i;
	LPINTERNALCAPDEV lpcd;
	HCAPDEV hCapDev;

	FX_ENTRY("initializeCaptureDeviceList");

	// Clear the entire array and start with zero devices
	g_cDevices = 0;
	ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// Open the reg key in question
	if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
	{
		if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegDescKey, &hkeyVFWdesc) != ERROR_SUCCESS)
			hkeyVFWdesc = 0;

		lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));

		if (lpcd)
		{
			// Loop through all possible VFW drivers in registry
			for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
			{
				// Create the key name
				if (i == 0)
					g_szDriverName[sizeof (g_szDriverName) - 2] = 0;
				else
					g_szDriverName[sizeof (g_szDriverName) - 2] = (BYTE)i + '0';

				// Name
				dwSize = sizeof(lpcd->szDeviceName);
				if (RegQueryValueEx(hkeyVFW, g_szDriverName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize) == ERROR_SUCCESS)
				{
					// Description
					if (hkeyVFWdesc)
					{
						dwSize = sizeof(lpcd->szDeviceDescription);
						RegQueryValueEx(hkeyVFWdesc, lpcd->szDeviceName, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);
					}
					else
						lstrcpy (lpcd->szDeviceDescription, lpcd->szDeviceName);

					// Devnode
					lpcd->dwDevNode = 0;
					lpcd->nDeviceIndex = g_cDevices;

					GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
					// Remove bogus Camcorder capture device from list of devices shown to the user
					// The Camcorder driver is a fake capture device used by the MS Office Camcorder
					// to capture screen activity to an AVI file. This not a legit capture device driver
					// and is extremely buggy.
					// We also remove the VfW to WDM mapper if we are on NT5.
					if (lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName) && lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName))
					{
#endif
						g_aCapDevices[g_cDevices] = lpcd;
						g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
						g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
					}
					else
						LocalFree(lpcd);
#endif

					lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
					if (!lpcd)
					{
						ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
						break;  // break out of the FOR loop
					}
				}
			}
		}
		else
		{
			ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
		}

		if (lpcd)
			LocalFree (lpcd);   // free the extra buffer

		RegCloseKey(hkeyVFW);
		if (hkeyVFWdesc)
			RegCloseKey(hkeyVFWdesc);
	}

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

	return TRUE;
}

#else //__NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry and
//      from SYSTEM.INI.
//      Returns FALSE iff there are no video devices.

BOOL
initializeCaptureDeviceList(void)
{
    int i, j, index;
    HKEY hkeyVFW;
    HKEY hkeyEnum;
    DWORD dwType;
    DWORD dwSize;
    LPINTERNALCAPDEV lpcd;
    char szEnumName[MAX_PATH];
    char szDisabled[3];
    HCAPDEV hCapDev;
	OSVERSIONINFO osvInfo = {0};

	FX_ENTRY("initializeCaptureDeviceList");

    // Clear the entire array and start with zero devices
    g_cDevices = 0;
    ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// If we are on a version on Win95 (OSRx) use the mapper to talk to WDM devices.
	// The WDM drivers used on OSR2 are not stream class minidrivers so we fail
	// to handle them properly. Let the mapper do this for us.
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvInfo);

    // Open the reg key in question
    if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
    {
        // Loop through all possible VFW drivers in registry
        for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
        {
            // See if the key is there and if not, we're done. Note that registry
            // keys have to be sequential, no holes allowed since the only way
            // to query is sequential...
            if (RegEnumKey(hkeyVFW, i, szEnumName, MAX_PATH) != ERROR_SUCCESS ||
                RegOpenKey(hkeyVFW, szEnumName, &hkeyEnum) != ERROR_SUCCESS)
                break;

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }

            // Description
            dwSize = sizeof (lpcd->szDeviceDescription);
            RegQueryValueEx(hkeyEnum, g_szRegDescription, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);

            // Name
            dwSize = sizeof (lpcd->szDeviceName);
            RegQueryValueEx(hkeyEnum, g_szRegName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize);

            // Disabled
            dwSize = sizeof (szDisabled);
            if (RegQueryValueEx(hkeyEnum, g_szRegDisabled, NULL, &dwType, (LPBYTE)szDisabled, &dwSize) == ERROR_SUCCESS &&
                szDisabled[0] == '1')
                lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

            // Devnode
            dwSize = sizeof (DWORD);
            RegQueryValueEx(hkeyEnum, g_szDevNode, NULL, &dwType, (BYTE*)&lpcd->dwDevNode, &dwSize);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

            RegCloseKey(hkeyEnum);
        }

        RegCloseKey(hkeyVFW);
    }

    // Now get the rest from system.ini, if any
    for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
    {
        // Create the key name
        if (i == 0)
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = 0;
        else
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = (BYTE)i + '0';

        // See if there's a profile string
        if (GetPrivateProfileString(g_szDriverSection, g_szDriverKey, "",
            szEnumName, MAX_PATH, g_szSystemIni))
        {
            // First check to see if this is a dupe. If it is, go no further.
            if (g_cDevices)
            {
                for (j = 0 ; j < g_cDevices ; j++)
                    if (!lstrcmpi(g_aCapDevices[j]->szDeviceName, szEnumName))
                        goto NextDriver;
            }

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }
            // We have a unique name, copy in the driver name and find the description
            // by reading the driver's versioninfo resource.
            lstrcpy(lpcd->szDeviceName, szEnumName);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

        }
NextDriver: ;
    }

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

    return TRUE;
}
#endif //__NT_BUILD__


//  GetNumCaptureDevice
//      Returns the number of *ENABLED* capture devices

/****************************************************************************
 *  @doc EXTERNAL DCAP32
 *
 *  @func int DCAPI | GetNumCaptureDevices | This function returns the number
 *    of *ENABLED* capture devices.
 *
 *  @rdesc Returns the number of *ENABLE* capture devices.
 ***************************************************************************/
int
DCAPI
GetNumCaptureDevices()
{
	int nNumCapDevices = 0;
	int nDeviceIndex = 0;

	INIT_CAP_DEV_LIST();

	while (nDeviceIndex < g_cDevices)
		if (!(g_aCapDevices[nDeviceIndex++]->dwFlags & CAPTURE_DEVICE_DISABLED))
			nNumCapDevices++;

    return nNumCapDevices;
}


//  FindFirstCaptureDevice
//      Returns the first capture device available that matches the string
//      or the first one registered if szDeviceDescription is NULL

BOOL
DCAPI
FindFirstCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    char* szDeviceDescription
    )
{
    int i;
    static HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Validate size
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

// hack to avoid quickcam driver problem when hardware not installed
    if (g_cDevices && !hcap) {
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);
        if ((i < g_cDevices) && (hcap = OpenCaptureDevice(i))) {
            CloseCaptureDevice (hcap);
        }
        else {
			if (i < g_cDevices) {
				g_aCapDevices[i]->dwFlags |= CAPTURE_DEVICE_DISABLED;
#ifdef _DEBUG
				OutputDebugString((i == 0) ? "DCAP32: 1st capture device fails to open!\r\n" : (i == 1) ? "DCAP32: 2nd capture device fails to open!\r\n" : (i == 2) ? "DCAP32: 3rd capture device fails to open!\r\n" : "DCAP32: 4th capture device fails to open!\r\n");
#endif
			}
        }
    }

    // Search if necessary
    if (szDeviceDescription)
    {
        for (i = 0 ; i < g_cDevices ; i++)
            if (!lstrcmpi(g_aCapDevices[i]->szDeviceDescription, szDeviceDescription) &&
                !(g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED))
                break;
    }
    else
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);

    // Return the info
    if (i == g_cDevices)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }
    else {
        lpfcd->nDeviceIndex = i;
        lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
        lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[i]->szDeviceDescription);
        lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[i]->szDeviceVersion);
        return TRUE;
    }
}


//  FindFirstCaptureDeviceByIndex
//      Returns the device with the specified index.

BOOL
DCAPI
FindFirstCaptureDeviceByIndex(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    int nDeviceIndex
    )
{
	INIT_CAP_DEV_LIST();

    // Validate size and index
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE) ||
        nDeviceIndex >= g_cDevices || (nDeviceIndex < 0) ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Return the info
    lpfcd->nDeviceIndex = nDeviceIndex;
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  FindNextCaptureDevice
//      Returns the next capture device in list.

BOOL
DCAPI
FindNextCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd
    )
{
    HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Parameter validate the passed in structure
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    while (++lpfcd->nDeviceIndex < g_cDevices)
	{
		if ((!(g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED)))
		{
			if (g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_OPEN)
				break;
			else
			{
				if (hcap = OpenCaptureDevice(lpfcd->nDeviceIndex))
				{
					CloseCaptureDevice (hcap);
					break;
				}
				else
					g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags |= CAPTURE_DEVICE_DISABLED;
			}
		}
	}

    // See if we're at the end
    if (lpfcd->nDeviceIndex >= g_cDevices)
    {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    // Otherwise, fill in the info for the next one
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  OpenCaptureDevice

HCAPDEV
DCAPI
OpenCaptureDevice(
    int nDeviceIndex
    )
{
    LPINTERNALCAPDEV hcd;
    LPBITMAPINFOHEADER lpbmih = NULL;
    DWORD err, dwLen;
    BOOL fl;

	FX_ENTRY("OpenCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    // Validate the device index
    if ((unsigned)nDeviceIndex >= (unsigned)g_cDevices ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & (CAPTURE_DEVICE_DISABLED | CAPTURE_DEVICE_OPEN))) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    hcd = g_aCapDevices[nDeviceIndex];
    hcd->busyCount = 1;                 // we start at 1 to say that we're open
                                        // DoClose happens when count goes to 0

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifndef __NT_BUILD__
		// Allocate some memory we can lock for the LOCKEDINFO structure
		hcd->wselLockedInfo = _AllocateLockableBuffer(sizeof (LOCKEDINFO));
		if (!hcd->wselLockedInfo) {
			err = ERROR_OUTOFMEMORY;
			goto Error;
		}

		// Do our own thunking so we can track the selector for this buffer
		hcd->lpli = (LPLOCKEDINFO)MapSL(((DWORD)hcd->wselLockedInfo) << 16);
#endif

		// Open the necessary video channels
		if (!(hcd->hvideoIn = openVideoChannel(nDeviceIndex, VIDEO_IN)) ||
			!(hcd->hvideoCapture = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALIN)))
		{
			ERRORMESSAGE(("%s: Couldn't open video channel(s)\r\n", _fx_));
			if (hcd->hvideoIn)
				_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALOUT))
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device supports overlay!\r\n", _fx_));
		}
		else
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device does not support overlay\r\n", _fx_));
		}
#endif
	}
	else
	{
		if (!WDMOpenDevice(nDeviceIndex))
		{
			ERRORMESSAGE(("%s: Couldn't open WDM device\r\n", _fx_));
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}
	}

    hcd->dwFlags |= CAPTURE_DEVICE_OPEN;

    // Get the initial format and set the values
    dwLen = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen)) {
        lpbmih->biSize = dwLen;
        fl = GetCaptureDeviceFormat(hcd, lpbmih);
        //If we can't get a format, or height and/or width are 0, don't use this device
        if (!fl || lpbmih->biWidth == 0 || lpbmih->biHeight == 0) {
			ERRORMESSAGE(("%s: GetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
        fl = SetCaptureDeviceFormat(hcd, lpbmih, 0, 0);
        if (!fl) {
			ERRORMESSAGE(("%s: SetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
#if 0
        _SetCaptureRect(hcd->hvideoIn, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_SRC_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
#endif
        LocalFree((HANDLE)lpbmih);
    } else {
        err = ERROR_OUTOFMEMORY;
        goto Error;
    }

	// Keep a stream running all the time on EXTERNALIN (capture->frame buffer).
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay)
			_InitializeExternalVideoStream(hcd->hvideoOverlay);
#else
		_InitializeExternalVideoStream(hcd->hvideoCapture);
#endif

#ifndef __NT_BUILD__
		// Lock our structure so it can be touched at interrupt time
		_LockBuffer(hcd->wselLockedInfo);
#endif
	}

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hcd;

Error:
    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;
    if (lpbmih) {
        LocalFree((HANDLE)lpbmih);
        lpbmih = NULL;
    }
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		if (hcd->hvideoIn) {
			_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			hcd->hvideoIn = NULL;
		}
		if (hcd->hvideoCapture) {
			_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0);
			hcd->hvideoCapture = NULL;
		}
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif
	}
	else
	{
		WDMCloseDevice(nDeviceIndex);
	}
    SetLastError(err);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return NULL;
}


void
DoClose(
    HCAPDEV hcd
    )
{
	FX_ENTRY("DoClose");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	// Clean up streaming on main channel, including freeing all buffers
	if (hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
		UninitializeStreaming(hcd);

	// Stop streaming on the capture channel
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_STREAM_FINI, 0L, 0L);
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#else
		_SendDriverMessage((HDRVR)hcd->hvideoCapture, DVM_STREAM_FINI, 0L, 0L);
#endif

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif

		// Close the driver channels
		if (!_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0) ||
			!_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0))
		{
			SetLastError(ERROR_DCAP_NONSPECIFIC);
			ERRORMESSAGE(("%s: Couldn't close channel, error unknown\r\n", _fx_));
			// with delayed close this is catastrophic, we can't just return that the device is still
			// open, but we can't get the device to close either, so we'll have to just leave it in this
			// hung open state - hopefully this never happens...
		}
		hcd->hvideoCapture = NULL;
		hcd->hvideoIn = NULL;
#ifndef __NT_BUILD__
		// Free the LOCKEDINFO structure
		_FreeLockableBuffer(hcd->wselLockedInfo);
		hcd->wselLockedInfo = 0;
#endif
	}
	else
	{
		WDMCloseDevice(hcd->nDeviceIndex);
	}

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}

BOOL
DCAPI
CloseCaptureDevice(
    HCAPDEV hcd
    )
{
	FX_ENTRY("CloseCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;   // clear flag to disable other API's
    LEAVE_DCAP(hcd);                        // dec our enter count, if no other thread is in a DCAP
                                            // service, then this dec will go to 0 and we'll call
                                            // DoClose; else we won't call DoClose until the other
                                            // active service dec's the count to 0
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


DWORD
DCAPI
GetCaptureDeviceFormatHeaderSize(
    HCAPDEV hcd
    )
{
    DWORD res;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		res = _GetVideoFormatSize(reinterpret_cast<HDRVR>(hcd->hvideoIn));
	else
		res = WDMGetVideoFormatSize(hcd->nDeviceIndex);

    LEAVE_DCAP(hcd);

    return res;
}


BOOL
DCAPI
GetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDeviceFormat");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // Call the driver to get the bitmap information
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoFormat(hcd->hvideoIn, lpbmih);
	else
		fRes = WDMGetVideoFormat(hcd->nDeviceIndex, lpbmih);
	
    if (!fRes)
    {
        // This is DOOM if the driver doesn't support this.
        // It might be useful have some sort of fallback code here,
        // or else we should try this when the connection is made and
        // fail it unless this call works.
		ERRORMESSAGE(("%s: Failed to get video format\r\n", _fx_));
        SetLastError(ERROR_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

	if (lpbmih->biCompression == BI_RGB)
		lpbmih->biSizeImage = WIDTHBYTES(lpbmih->biWidth * lpbmih->biBitCount) * lpbmih->biHeight;

	// Keep track of current buffer size needed
	hcd->dwcbBuffers = sizeof(CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


BOOL
DCAPI
SetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih,
    LONG srcwidth,
    LONG srcheight
    )
{
	BOOL fRes;
#ifdef USE_VIDEO_OVERLAY
    RECT rect;
#endif

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // Don't allow this if streaming
    if (hcd->dwFlags & HCAPDEV_STREAMING)
    {
        SetLastError(ERROR_DCAP_NOT_WHILE_STREAMING);
        return FALSE;
    }
    ENTER_DCAP(hcd);

    // Call the driver to set the format
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		fRes = _SetVideoFormat(hcd->hvideoCapture, hcd->hvideoIn, lpbmih);
#ifdef USE_VIDEO_OVERLAY
		if (fRes && hcd->hvideoOverlay)
		{
			// Get the current rectangles
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay dst rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay src rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));

			// Set the rectangles
			rect.left = rect.top = 0;
			rect.right = (WORD)lpbmih->biWidth;
			rect.bottom = (WORD)lpbmih->biHeight;
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			if (hcd->hvideoOverlay)
				_InitializeExternalVideoStream(hcd->hvideoOverlay);
		}
#endif
	}
	else
		fRes = WDMSetVideoFormat(hcd->nDeviceIndex, lpbmih);

    if (!fRes)
    {
        SetLastError(ERROR_DCAP_FORMAT_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

    // Cache the bitmap size we're dealing with now
	if (lpbmih->biCompression == BI_RGB)
		hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biWidth * lpbmih->biHeight * lpbmih->biBitCount / 8;
	else
	    hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


//  GetCaptureDevicePalette
//      Gets the current palette from the capture device. The entries are returned to
//      the caller who normally calls CreatePalette on the structure. It may, however,
//      want to translate the palette entries into some preexisting palette or identity
//      palette before calling CreatePalette, hence the need for passing back the entries.

BOOL
DCAPI
GetCaptureDevicePalette(
    HCAPDEV hcd,
    CAPTUREPALETTE* lpcp
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDevicePalette");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // The caller doesn't have to initialize the structure.
    // The driver should fill it in, but it may want it preininitialized so we do that here.
    lpcp->wVersion = 0x0300;
    lpcp->wcEntries = 256;

    // Get the palette entries from the driver and return to the user
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoPalette(hcd->hvideoIn, lpcp, sizeof (CAPTUREPALETTE));
	else
		fRes = WDMGetVideoPalette(hcd->nDeviceIndex, lpcp, sizeof (CAPTUREPALETTE));

    if (!fRes)
	{
		ERRORMESSAGE(("%s: No palette returned from driver\r\n", _fx_));
		SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
		LEAVE_DCAP(hcd);
		return FALSE;
	}

    LEAVE_DCAP(hcd);
    return TRUE;
}


void
TerminateStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
	BOOL fRes;

	FX_ENTRY("TerminateStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    StopStreaming(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        hcd->dwFlags |= HCAPDEV_STREAMING_PAUSED;

        // Make sure we aren't streaming
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
#ifndef __NT_BUILD__
			hcd->lpli->dwFlags |= LIF_STOPSTREAM;
#endif
			_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_RESET, 0, 0);
		}
		else
			WDMVideoStreamReset(hcd->nDeviceIndex);

        dwTicks = GetTickCount();
        lpcbuf = hcd->lpcbufList;
        while (lpcbuf && GetTickCount() < dwTicks + 1000) {
            dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                if (WaitForSingleObject(hcd->hevWait, 500) == WAIT_TIMEOUT) {
					ERRORMESSAGE(("%s: Timeout waiting for all buffers done after DVM_STREAM_RESET\r\n", _fx_));
                    break;  // looks like it isn't going to happen, so quit waiting
                }
				//else recheck done bit on current buffer
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_DONE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
            }
            else
			{
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
                lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser;    // next buffer
			}
        }

		DEBUGMSG(ZONE_STREAMING, ("%s: Done trying to clear buffers\r\n", _fx_));

		// Clean up flags in order to reuse buffers - drivers do not like to be
		// given buffers with a dirty dwFlags at the start of streaming...
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser)
			lpcbuf->vh.dwFlags = 0;

        // Terminate streaming with the driver
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRes = _UninitializeVideoStream(hcd->hvideoIn);
		else
			fRes = WDMUnInitializeVideoStream(hcd->nDeviceIndex);

        if (!fRes)
		{
			ERRORMESSAGE(("%s: Error returned from XXXUninitializeVideoStream\r\n", _fx_));
		}
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}


BOOL
ReinitStreaming(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
	BOOL fRes;

	FX_ENTRY("ReinitStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        // Tell the driver to prepare for streaming. This sets up the callback

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
#ifdef __NT_BUILD__
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD_PTR)hcd);
#else
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD)hcd->wselLockedInfo << 16);
#endif
		else
			fRes = WDMInitializeVideoStream(hcd, hcd->nDeviceIndex, hcd->dw_usecperframe);

        if (!fRes)
        {
			ERRORMESSAGE(("%s: Error returned from XXXInitializeVideoStream\r\n", _fx_));
            SetLastError(ERROR_DCAP_BAD_FRAMERATE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
            return FALSE;
        }
//        Sleep (10);

        hcd->dwFlags &= ~HCAPDEV_STREAMING_PAUSED;

        // If any buffers are not marked DONE, then give them back to the driver; let all
        // DONE buffers get processed by the app first
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				{
					// AVICap32 sets the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_PREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags |= VHDR_PREPARED;
					fRes = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
				}
				else
					fRes = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

                if (!fRes)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Failed with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
					DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
                    return FALSE;
                }
				else
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Succeeded with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
                }
            }
        }
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return TRUE;
}


//  CaptureDeviceDialog
//      Puts up one of the driver's dialogs for the user to twiddle.
//      If I can figure out ANY way to avoid this, I will.

BOOL DCAPI
CaptureDeviceDialog(
    HCAPDEV hcd,
    HWND hwndParent,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbmih   //OPTIONAL
    )
{
    DWORD dwDriverFlags = 0;
    HVIDEO hvid;
    DWORD dwSize;
    LPBITMAPINFOHEADER lpbmihCur;
#ifdef _DEBUG
    LPBITMAPINFOHEADER lpbmihPre = NULL;
#endif
    BOOL res = TRUE;

	FX_ENTRY("CaptureDeviceDialog");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (hcd->dwFlags & HCAPDEV_IN_DRIVER_DIALOG)
        return FALSE;   // don't allow re-entering

    ENTER_DCAP(hcd);

    if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
			dwDriverFlags |= VIDEO_DLG_QUERY;

		// Select the correct channel to query
		if (dwFlags & CAPDEV_DIALOG_SOURCE) {
			hvid = hcd->hvideoCapture;
			if (!(dwFlags & CAPDEV_DIALOG_QUERY)) {
				dwDriverFlags |= VIDEO_DLG_QUERY;
				if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD_PTR)hwndParent, dwDriverFlags) == DV_ERR_NOTSUPPORTED) {
					hvid = hcd->hvideoIn;
				}
				dwDriverFlags &= ~VIDEO_DLG_QUERY;
			}
		}
		else
			hvid = hcd->hvideoIn;

		// Don't stop streaming. This make the source dialog totally useless
		// if the user can't see what is going on.

#ifdef _DEBUG
		if (!lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihPre = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihPre->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihPre);
			}
			lpbmih = lpbmihPre;
		}
#endif

		// Call the driver
		hcd->dwFlags |= HCAPDEV_IN_DRIVER_DIALOG;
		if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD_PTR)hwndParent, dwDriverFlags)) {
			SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
			res = FALSE;    // restart still ok
		}
		else if (lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihCur = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihCur->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihCur);
				if (lpbmih->biSize != lpbmihCur->biSize ||
					lpbmih->biWidth != lpbmihCur->biWidth ||
					lpbmih->biHeight != lpbmihCur->biHeight ||
					lpbmih->biBitCount != lpbmihCur->biBitCount ||
					lpbmih->biCompression != lpbmihCur->biCompression)
				{
					ERRORMESSAGE(("%s: Format changed in dialog!!\r\n", _fx_));
#ifdef _DEBUG
					DebugBreak();
#endif
					// dialog changed format, so try to set it back
					if (!SetCaptureDeviceFormat(hcd, lpbmih, 0, 0)) {
						SetLastError (ERROR_DCAP_DIALOG_FORMAT);
						res = FALSE;
					}
				}
				LocalFree ((HANDLE)lpbmihCur);
			}
#ifdef _DEBUG
			if (lpbmih == lpbmihPre) {
				LocalFree ((HANDLE)lpbmihPre);
				lpbmih = NULL;
				lpbmihPre = NULL;
			}
#endif
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		if (hcd->dwFlags & HCAPDEV_STREAMING) {
    		// The Intel Smart Video Recorder Pro stops streaming
			// on exit from the source dialog (!?!?). Make sure
    		// we reset the streaming on any kind of device right
			// after we exit the source dialog. I verified this on
    		// the CQC, ISVR Pro, Video Stinger and Video Blaster SE100.
			// They all seem to take this pretty well...
    		TerminateStreaming(hcd);
			if (ReinitStreaming(hcd))
				StartStreaming(hcd);
			else {
				SetLastError(ERROR_DCAP_DIALOG_STREAM);
				res = FALSE;
				ERRORMESSAGE(("%s: Couldn't reinit streaming after dialog!\r\n", _fx_));
			}
		}
	}
	else
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
		{
			// We only expose a settings dialog
			if (dwFlags & CAPDEV_DIALOG_IMAGE)
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}
		else
		{
			if (!WDMShowSettingsDialog(hcd->nDeviceIndex, hwndParent))
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		// No need to restart streaming on WDM devices tested so far
		// Will add this feature if problems come up
	}

    LEAVE_DCAP(hcd);
    return res;
}


//  InitializeStreaming
//      Allocates all memory and other objects necessary for streaming.

BOOL
DCAPI
InitializeStreaming(
    HCAPDEV hcd,
    CAPSTREAM* lpcs,
    DWORD flags
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwRound;
    LPBITMAPINFOHEADER lpbmih;
    BOOL bHaveBuffers = FALSE;

	FX_ENTRY("InitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // It doesn't make sense to stream with less than 2 buffers
    if (lpcs->ncCapBuffers < MIN_STREAMING_CAPTURE_BUFFERS ||
            flags & 0xfffffffe ||
            hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }
    ENTER_DCAP(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING | HCAPDEV_STREAMING_INITIALIZED |
                      HCAPDEV_STREAMING_FRAME_GRAB | HCAPDEV_STREAMING_FRAME_TIME | HCAPDEV_STREAMING_PAUSED);

    // Before allocating, make sure we have the current format.
    // This sets our idea of the current size we need for the buffer by
    // setting hcd->dwcbBuffers as a side effect
    dwRound = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwRound)) {
        lpbmih->biSize = dwRound;
        GetCaptureDeviceFormat(hcd, lpbmih);
        LocalFree ((HANDLE)lpbmih);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

// BUGBUG - add logic to determine if we should automatically use FRAME_GRAB mode

    // Try allocating the number asked for
    if (flags & STREAMING_PREFER_FRAME_GRAB) {
        hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_GRAB;
    }

    if (!allocateBuffers(hcd, lpcs->ncCapBuffers))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Create the event we need so we can signal at interrupt time
    if (!(hcd->hevWait = CreateEvent(NULL, FALSE, FALSE, NULL))) {
		ERRORMESSAGE(("%s: CreateEvent failed!\r\n", _fx_));
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Init CS used to serialize buffer list management
    InitializeCriticalSection(&hcd->bufferlistCS);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    hcd->dw_usecperframe = (unsigned)1000000000 / (unsigned)lpcs->nFPSx100;
    dwRound = hcd->dw_usecperframe % 10;  // Could have done with one less divide,
    hcd->dw_usecperframe /= 10;           // but this is clearer, and this is just
                                          // an init call...
    if (dwRound >= 5)
        hcd->dw_usecperframe++;

    hcd->lpCurrent = NULL;
    hcd->lpHead = NULL;
    hcd->lpTail = NULL;

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->pevWait = 0;
#endif

        // link the buffers into the available list
        // start with empty list
        hcd->lpHead = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR
        hcd->lpTail = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR

        // now insert the buffers
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
	        lpcbuf->lpPrev = hcd->lpTail;
	        hcd->lpTail = lpcbuf;
            lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	        lpcbuf->lpPrev->lpNext = lpcbuf;
	        lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    }
    }
	else
	{
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			hcd->lpli->pevWait = (DWORD)OpenVxDHandle(hcd->hevWait);

			// Lock down the LOCKEDINFO structure
			if (!_LockBuffer(hcd->wselLockedInfo))
			{
				SetLastError(ERROR_OUTOFMEMORY);
				goto Error;
			}
			hcd->lpli->lp1616Head = 0;
			hcd->lpli->lp1616Tail = 0;
			hcd->lpli->lp1616Current = 0;
		}
#endif

        if (!ReinitStreaming(hcd))
            goto Error;
    }
    lpcs->hevWait = hcd->hevWait;

    // Flag that streaming is initialized
    hcd->dwFlags |= HCAPDEV_STREAMING_INITIALIZED;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

Error:
    freeBuffers(hcd);
    if (hcd->hevWait)
    {
        CloseHandle(hcd->hevWait);
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && hcd->lpli->pevWait)
            _CloseVxDHandle(hcd->lpli->pevWait);
#endif
    }
    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return FALSE;
}


//  SetStreamFrameRate
//      Changes the frame rate of a stream initialized channel.
// PhilF-: This call is not used by NMCAP and NAC. So remove it or
// start using it.
BOOL
DCAPI
SetStreamFrameRate(
    HCAPDEV hcd,
    int nFPSx100
    )
{
    DWORD dwNew, dwRound;
    BOOL restart;
    BOOL res = TRUE;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED))
    {
        // must already have the channel initialized for streaming
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ENTER_DCAP(hcd);
    restart = (hcd->dwFlags & HCAPDEV_STREAMING);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    dwNew = (unsigned)1000000000 / (unsigned)nFPSx100;
    dwRound = dwNew % 10;           // Could have done with one less divide,
    dwNew /= 10;                    // but this is clearer, and this is just an init call...
    if (dwRound >= 5)
        dwNew++;

    if (dwNew != hcd->dw_usecperframe) {

        TerminateStreaming(hcd);

        hcd->dw_usecperframe = dwNew;

        res = ReinitStreaming(hcd);

        if (restart && res)
            StartStreaming(hcd);
    }
    LEAVE_DCAP(hcd);
    return res;
}


//  UninitializeStreaming
//      Frees all memory and objects associated with streaming.

BOOL
DCAPI
UninitializeStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("UninitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }

    ENTER_DCAP(hcd);

    TerminateStreaming(hcd);

#ifndef __NT_BUILD__
    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) && !(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
        // Unlock our locked structure
        _UnlockBuffer(hcd->wselLockedInfo);

        // Free the event
        _CloseVxDHandle(hcd->lpli->pevWait);
    }
#endif

    DeleteCriticalSection(&hcd->bufferlistCS);
    CloseHandle(hcd->hevWait);

    // BUGBUG - what about app still owning buffers
    // Loop through freeing all the buffers
    freeBuffers(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING_INITIALIZED + HCAPDEV_STREAMING_PAUSED);

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


void
CALLBACK
TimeCallback(
    UINT uID,	
    UINT uMsg,	
    HCAPDEV hcd,	
    DWORD dw1,	
    DWORD dw2	
    )
{
    hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_TIME;  // flag time for a new frame
    SetEvent (hcd->hevWait);    // signal client to initiate frame grab
}

//  StartStreaming
//      Begins streaming.

BOOL
DCAPI
StartStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;
	DWORD dwRet;

	FX_ENTRY("StartStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        fRet = ((hcd->timerID = timeSetEvent(hcd->dw_usecperframe/1000, 5,
                                    (LPTIMECALLBACK)&TimeCallback,
                                    (DWORD_PTR)hcd, TIME_PERIODIC)) != 0);
    } else {
        int i;

        fRet = FALSE;

#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->dwFlags &= ~LIF_STOPSTREAM;
#endif

        for (i = 0; i < 5; i++) {

			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			{
				dwRet = (DWORD)_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_START, 0, 0);
				fRet = (dwRet == DV_ERR_OK);
				if (dwRet)
				{
					ERRORMESSAGE(("%s: DVM_STREAM_START failed, return code was %ld\r\n", _fx_, dwRet));
				}
			}
			else
				fRet = WDMVideoStreamStart(hcd->nDeviceIndex);

            if (fRet)
                break;
            else if (i > 1)
                Sleep(10);
        }
    }

    if (fRet)
        hcd->dwFlags |= HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  StopStreaming
//      Stops streaming but doesn't free any memory associated with streaming
//      so that it can be restarted with StartStreaming.

BOOL
DCAPI
StopStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;

	FX_ENTRY("StopStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        timeKillEvent(hcd->timerID);
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

        // grab CS to ensure that no frame grab is in progress
        EnterCriticalSection(&hcd->bufferlistCS);
        LeaveCriticalSection(&hcd->bufferlistCS);
        fRet = TRUE;
    }
	else
	{
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_STOP, 0, 0) == DV_ERR_OK);
		else
			fRet = WDMVideoStreamStop(hcd->nDeviceIndex);
	}

    if (fRet)
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  GetNextReadyBuffer
//      Called by the app to find the next buffer that has been marked as
//      done by the driver and has data to be displayed.

LPSTR
DCAPI
GetNextReadyBuffer(
    HCAPDEV hcd,
    CAPFRAMEINFO* lpcfi
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
	BOOL fRet;

	FX_ENTRY("GetNextReadyBuffer");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        lpcbuf = (LPCAPBUFFER)hcd->lpHead;
        if ((hcd->dwFlags & HCAPDEV_STREAMING_FRAME_TIME) &&
            (lpcbuf != (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR))))  /* fake CAPBUFFERHDR */
        {
            // remove buffer from list
            EnterCriticalSection(&hcd->bufferlistCS);
            hcd->dwFlags &= ~HCAPDEV_STREAMING_FRAME_TIME;
            lpcbuf->lpPrev->lpNext = lpcbuf->lpNext;
            lpcbuf->lpNext->lpPrev = lpcbuf->lpPrev;
            lpcbuf->vh.dwFlags &= ~VHDR_INQUEUE;
            lpcbuf->vh.dwFlags |= VHDR_DONE;
            LeaveCriticalSection(&hcd->bufferlistCS);
            dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				fRet = (SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
			else
				fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

            if (!fRet)
			{
                // put buffer back into list
                EnterCriticalSection(&hcd->bufferlistCS);
        	    lpcbuf->lpPrev = hcd->lpTail;
        	    hcd->lpTail = lpcbuf;
                lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
        	    lpcbuf->lpPrev->lpNext = lpcbuf;
           	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
                LeaveCriticalSection(&hcd->bufferlistCS);
                lpcbuf = NULL;
            }
        } else
            lpcbuf = NULL;

    } else {

#ifdef __NT_BUILD__
        // If the current pointer is NULL, there is no frame ready so bail
        if (!hcd->lpCurrent)
	        lpcbuf = NULL;
        else {
            // Get the linear address of the buffer
            lpcbuf = hcd->lpCurrent;

            // Move to the next ready buffer
            hcd->lpCurrent = lpcbuf->lpPrev;
        }
#else
        //--------------------
        // Buffer ready queue:
        // We maintain a doubly-linked list of our buffers so that we can buffer up
        // multiple ready frames when the app isn't ready to handle them. Two things
        // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
        // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
        // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
        // buffers get added to the list asynchronously.
        //
        // To handle this, the scheme implemented here is to have a double-linked list
        // of buffers with all insertions and deletions happening in FrameCallback
        // (interrupt time). This allows the GetNextReadyBuffer routine to simply
        // find the previous block on the list any time it needs a new buffer without
        // fear of getting tromped (as would be the case if it had to dequeue buffers).
        // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
        // is done with. Dequeueing is simple since we don't need to unlink the blocks:
        // no code ever walks the list! All we have to do is move the tail pointer back up
        // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
        // since all the list manipulation is on the 16-bit side AND because MapSL is
        // much more efficient and safer than MapLS since MapLS has to allocate selectors.
        //--------------------

        // If the current pointer is NULL, there is no frame ready so bail
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!hcd->lpli->lp1616Current)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = (LPCAPBUFFER)MapSL(hcd->lpli->lp1616Current);

				// Move to the next ready buffer
				hcd->lpli->lp1616Current = lpcbuf->lp1616Prev;
			}
		}
		else
		{
			// If the current pointer is NULL, there is no frame ready so bail
			if (!hcd->lpCurrent)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = hcd->lpCurrent;

				// Move to the next ready buffer
				hcd->lpCurrent = lpcbuf->lpPrev;
			}
		}
#endif

    }

    if (!lpcbuf) {
        lpcfi->lpData = NULL;
		DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Fails with lpcbuf=NULL\r\n", _fx_));
        LEAVE_DCAP(hcd);
        return NULL;
    }

    // Build the CAPFRAMEINFO from the VIDEOHDR information
    lpcfi->lpData = ((LPSTR)lpcbuf) + sizeof(CAPBUFFERHDR);
    lpcfi->dwcbData = lpcbuf->vh.dwBytesUsed;
    lpcfi->dwTimestamp = lpcbuf->vh.dwTimeCaptured;
    lpcfi->dwFlags = 0;
    lpcbuf->lpNext = NULL;

	DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  lpcbuf->vh.dwBufferLength=%ld\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, lpcbuf->vh.dwBufferLength));
	DEBUGMSG(ZONE_STREAMING, ("  lpcbuf->vh.dwBytesUsed=%ld\r\n  lpcbuf->vh.dwTimeCaptured=%ld\r\n  lpcbuf->vh.dwFlags=0x%08lX\r\n", lpcbuf->vh.dwBytesUsed, lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwFlags));

    LEAVE_DCAP(hcd);
    return lpcfi->lpData;
}


//  PutBufferIntoStream
//      When the app is finished using a buffer, it must allow it to be requeued
//      by calling this API.

BOOL
DCAPI
PutBufferIntoStream(
    HCAPDEV hcd,
    BYTE* lpBits
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
    BOOL res;

	FX_ENTRY("PutBufferIntoStream");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);
    // From the CAPFRAMEINFO, find the appropriate CAPBUFFER pointer
    lpcbuf = (LPCAPBUFFER)(lpBits - sizeof(CAPBUFFERHDR));

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Returning buffer lpcbuf=0x%08lX\r\n", _fx_, lpcbuf));

    lpcbuf->vh.dwFlags &= ~VHDR_DONE;   // mark that app no longer owns buffer
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        EnterCriticalSection(&hcd->bufferlistCS);
	    lpcbuf->lpPrev = hcd->lpTail;
	    hcd->lpTail = lpcbuf;
        lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	    lpcbuf->lpPrev->lpNext = lpcbuf;
	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    res = TRUE;
        LeaveCriticalSection(&hcd->bufferlistCS);
    }
    else if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
        // if streaming is paused, then just return with the busy bit cleared, we'll add the
        // buffer into the stream in ReinitStreaming
        //
        // if streaming isn't paused, then call the driver to add the buffer
        dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			res = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
		else
			res = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

		if (res)
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Failed with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}

    }

    LEAVE_DCAP(hcd);
    return res;
}


//  CaptureFrame
LPBYTE
DCAPI
CaptureFrame(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
    DWORD_PTR dwlpvh;
    LPBYTE lpbuf;
    BOOL fRet;

	FX_ENTRY("CaptureFrame");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    dwlpvh = (DWORD_PTR)hbuf->vh.lpData - sizeof(CAPBUFFERHDR);
	// 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
	// 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
	else
		fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

    if (!fRet)
	{
		ERRORMESSAGE(("%s: DVM_FRAME failed!\r\n", _fx_));
        lpbuf =  NULL;
    }
    else
        lpbuf = ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr

    LEAVE_DCAP(hcd);
    return lpbuf;
}


LPBYTE
DCAPI
GetFrameBufferPtr(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
        return ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr
    else
        return NULL;
}

HFRAMEBUF
DCAPI
AllocFrameBuffer(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER hbuf = NULL;
    DWORD_PTR dpBuf;

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
    if (dpBuf = (DWORD_PTR)LocalAlloc(LPTR, hcd->dwcbBuffers)) {
        hbuf = (LPCAPBUFFER)dpBuf;
#else
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16;
        hbuf = (LPCAPBUFFER)MapSL(dpBuf);
	}
	else
	{
		dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers);
        hbuf = (LPCAPBUFFER)dpBuf;
	}

    if (dpBuf) {
#endif
        // Initialize the VIDEOHDR structure
        hbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        hbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        hbuf->vh.dwFlags = 0UL;
    }

    LEAVE_DCAP(hcd);
    return (HFRAMEBUF)hbuf;
}


VOID
DCAPI
FreeFrameBuffer(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
	{
        ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
		LocalFree((HANDLE)hbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			_FreeLockableBuffer(HIWORD((DWORD)hbuf->vh.lpData));
		else
			LocalFree((HANDLE)hbuf);
#endif

        LEAVE_DCAP(hcd);
    }
}

//=====================================================================
//  Helper functions

HVIDEO
openVideoChannel(
    DWORD dwDeviceID,
    DWORD dwFlags
    )
{
    HVIDEO hvidRet = NULL;
    VIDEO_OPEN_PARMS vop;
#ifdef __NT_BUILD__
    WCHAR devName[MAX_PATH];
#else
#define LPWSTR      LPSTR
#define devName     g_aCapDevices[dwDeviceID]->szDeviceName
#endif

	FX_ENTRY("openVideoChannel");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Validate parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }
    if (dwDeviceID > (DWORD)g_cDevices)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    // Prepare to call the driver
    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = 0;
    vop.dnDevNode = g_aCapDevices[dwDeviceID]->dwDevNode;

#ifdef __NT_BUILD__
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR)&(g_aCapDevices[dwDeviceID]->szDeviceName),
	-1, (LPWSTR)devName, MAX_PATH);
#endif

    hvidRet = (HVIDEO)_OpenDriver((LPWSTR)devName, NULL, (LONG_PTR)&vop);

#ifndef NO_DRIVER_HACKS
    if (!hvidRet) {
        // backward compatibility hack
        // Some drivers fail to open because of the extra fields that were added to
        // VIDEO_OPEN_PARAMS struct for Win95.  Therefore, if the open fails, try
        // decrementing the dwSize field back to VFW1.1 size and try again.  Also try
        // decrementing the API version field.

        vop.dwSize -= sizeof(DWORD) + sizeof(LPVOID)*2;
#if 0
        while (--vop.dwVersion > 2 && !hvidRet)
#endif
        while (--vop.dwVersion > 0 && !hvidRet)
            hvidRet = (HVIDEO)_OpenDriver((LPWSTR)devName, NULL, (LONG_PTR)&vop);
    }
#endif //NO_DRIVER_HACKS

// BUGBUG [JonT] 31-Jul-96
// Translate error values from DV_ERR_* values
    if (!hvidRet)
        SetLastError(vop.dwError);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hvidRet;
}


//  allocateBuffers

BOOL
allocateBuffers(
    HCAPDEV hcd,
    int nBuffers
    )
{
    int i;
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dpBuf;

	FX_ENTRY("allocateBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Try to allocate all they ask for
    for (i = 0 ; i < nBuffers ; i++)
    {

#ifdef __NT_BUILD__
        if (!(dpBuf = (DWORD_PTR)LocalAlloc(LPTR, hcd->dwcbBuffers)))
            goto Error;
        else
			lpcbuf = (LPCAPBUFFER)dpBuf;
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!(dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16) || !_LockBuffer((WORD)(dpBuf >> 16)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)MapSL(dpBuf);
		}
		else
		{
			if (!(dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)dpBuf;
		}
#endif

        // Initialize the VIDEOHDR structure
        lpcbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        lpcbuf->vh.dwUser = (DWORD_PTR)hcd->lpcbufList;
        hcd->lpcbufList = lpcbuf;
        lpcbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        lpcbuf->vh.dwFlags = 0UL;
    }

#ifdef _DEBUG
	// Show buffer map
	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming Buffer map:\r\n", _fx_));
	DEBUGMSG(ZONE_STREAMING, ("Root: hcd->lpcbufList=0x%08lX\r\n", hcd->lpcbufList));
    for (i = 0, lpcbuf=hcd->lpcbufList ; i < nBuffers ; i++, lpcbuf=(LPCAPBUFFER)lpcbuf->vh.dwUser)
    {
		DEBUGMSG(ZONE_STREAMING, ("Buffer[%ld]: lpcbuf=0x%08lX\r\n             lpcbuf->vh.lpData=0x%08lX\r\n", i, lpcbuf, lpcbuf->vh.lpData));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwBufferLength=%ld\r\n             lpcbuf->vh.dwBytesUsed=%ld\r\n", lpcbuf->vh.dwBufferLength, lpcbuf->vh.dwBytesUsed));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwTimeCaptured=%ld\r\n             lpcbuf->vh.dwUser=0x%08lX\r\n", lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwUser));
	}	
#endif

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

    // In the error case, we have to get rid of this page locked memory
Error:
    freeBuffers(hcd);
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return FALSE;
}


//  freeBuffers

void
freeBuffers(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("freeBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    while (hcd->lpcbufList)
    {
        lpcbuf = hcd->lpcbufList;
        hcd->lpcbufList = (LPCAPBUFFER)lpcbuf->vh.dwUser;

#ifdef __NT_BUILD__
		LocalFree((HANDLE)lpcbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			_UnlockBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
			_FreeLockableBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
		}
		else
			LocalFree((HANDLE)lpcbuf);
#endif
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\1632com.h ===
//  1632COM.H
//
//  Created 19-Jul-96 [JonT]

#ifndef _1632COM_H
#define _1632COM_H

// Debug stuff
#if defined (DEBUG) || defined (_DEBUG)
#define Assert(x, msg) { if (!(x)) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); DebugBreak(); } }
#define DebugSpew(msg) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); }
#else
#define Assert(x, msg)
#define DebugSpew(msg)
#endif

#endif // #ifndef _1632COM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\wdmcap.cpp ===
// This file adds native support for streaming WDM video capture
// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    );

// Globals
extern HINSTANCE g_hInst;


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetDevices | This function enumerates the installed WDM video
 *   capture devices and adds them to the list of VfW capture devices.
 *
 * @parm PDWORD | [OUT] pdwOverallCPUUsage | Specifies a pointer to a DWORD to
 *   receive the current CPU usage.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 *
 * @devnote MSDN references:
 *   DirectX 5, DirectX Media, DirectShow, Application Developer's Guide
 *   "Enumerate and Access Hardware Devices in DirectShow Applications"
 ***************************************************************************/
BOOL WDMGetDevices(void)
{
	HRESULT hr;
	ICreateDevEnum *pCreateDevEnum;
	IEnumMoniker *pEm;

	FX_ENTRY("WDMGetDevices");

	// First, create a system hardware enumerator
	// This call loads the following DLLs - total 1047 KBytes!!!:
	//   'C:\WINDOWS\SYSTEM\DEVENUM.DLL' = 60 KBytes
	//   'C:\WINDOWS\SYSTEM\RPCRT4.DLL' = 316 KBytes
	//   'C:\WINDOWS\SYSTEM\CFGMGR32.DLL' = 44 KBytes
	//   'C:\WINDOWS\SYSTEM\WINSPOOL.DRV' = 23 KBytes
	//   'C:\WINDOWS\SYSTEM\COMDLG32.DLL' = 180 KBytes
	//   'C:\WINDOWS\SYSTEM\LZ32.DLL' = 24 KBytes
	//   'C:\WINDOWS\SYSTEM\SETUPAPI.DLL' = 400 KBytes
	// According to LonnyM, there's no way to go around SETUPAPI.DLL
	// when dealing with PnP device interfaces....
	if ((CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void**)&pCreateDevEnum)) != S_OK)
	{
		return FALSE;
	}

	// Second, create an enumerator for a specific type of hardware device: video capture cards only
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEm, CDEF_BYPASS_CLASS_MANAGER);
    pCreateDevEnum->Release();

	// Third, enumerate the list itself
    if (hr == S_OK)
	{
		ULONG cFetched;
		IMoniker *pM;
		IPropertyBag *pPropBag = 0;

		hr = pEm->Reset();

        while(hr = pEm->Next(1, &pM, &cFetched), hr==S_OK)
		{

			pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);

			if (pPropBag)
			{
				VARIANT var;
				LPINTERNALCAPDEV lpcd;

				if (!(lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV))))
				{
					ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
					break;  // break from the WHILE loop
				}

				// Get friendly name of the device
				var.vt = VT_BSTR;
				if ((hr = pPropBag->Read(L"FriendlyName", &var, 0)) == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceDescription, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);
				}
				else
					LoadString(g_hInst, IDS_UNKNOWN_DEVICE_NAME, lpcd->szDeviceDescription, CCHMAX(lpcd->szDeviceDescription));

				// Get DevicePath of the device
				hr = pPropBag->Read(L"DevicePath", &var, 0);
				if (hr == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceName, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);

					// There's no reg key for version information for WDM devices

					// Those devices can't be disabled from the MM control panel
					// lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

					// Mark device as a WDM device
					lpcd->dwFlags |= WDM_CAPTURE_DEVICE;

					g_aCapDevices[g_cDevices] = lpcd;
					g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
					g_cDevices++;
				}
            }

            pPropBag->Release();

            pM->Release();
        }

        pEm->Release();
    }

	return TRUE;

}

/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMOpenDevice | This function opens a WDM video capture
 * devices and adds them to the list of VfW capture devices.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to open.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMOpenDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMOpenDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) != 0));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) == 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Open streaming class driver
	CWDMPin *pCWDMPin;
	if (!(pCWDMPin = new CWDMPin(dwDeviceID)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMPin class\r\n", _fx_));
		return FALSE;
	}
	else
	{
		// Open the WDM driver and create a video pin
		if (!pCWDMPin->OpenDriverAndPin())
		{
			goto Error0;
		}
	}

	// Create video stream on the pin
    CWDMStreamer *pCWDMStreamer;
	if (!(pCWDMStreamer = new CWDMStreamer(pCWDMPin)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMStreamer\r\n", _fx_));
		goto Error0;
	}

	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)pCWDMStreamer;

	return TRUE;

Error0:
	delete pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;

	return FALSE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMCloseDevice | This function closes a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to close.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMCloseDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMCloseDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close video channel
	if (g_aCapDevices[dwDeviceID]->pCWDMStreamer)
	{
		delete ((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer);
		g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;
	}

	// Close driver and pin
	if (g_aCapDevices[dwDeviceID]->pCWDMPin)
	{
		delete ((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
		g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	}

	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormatSize | This function returns the size of the
 *   structure used to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @rdesc Always returns the size of a BITMAPINFOHEADER structure.
 ***************************************************************************/
DWORD WDMGetVideoFormatSize(DWORD dwDeviceID)
{
	FX_ENTRY("WDMGetVideoFormatSize");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	DEBUGMSG(ZONE_INIT, ("%s: return size=%ld\r\n", _fx_, (DWORD)sizeof(BITMAPINFOHEADER)));

	// Return size of BITMAPINFOHEADER structure
	return (DWORD)sizeof(BITMAPINFOHEADER);
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMGetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Make sure the size information is correct
	if (!pbmih->biSize)
		pbmih->biSize = WDMGetVideoFormatSize(dwDeviceID);

	// Get the BITMAPINFOHEADER structure
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih, (WORD)pbmih->biSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMSetVideoFormat | This function sets the video format on
 *   a WDM video capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure describing the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMSetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMSetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih && pbmih->biSize);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih ||!pbmih->biSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Set the BITMAPINFOHEADER on the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->SetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		// PhilF-: This sometimes fail, but we keep on streaming... fix that
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoPalette(DWORD dwDeviceID, CAPTUREPALETTE* lpcp, DWORD dwcbSize)
{
	FX_ENTRY("WDMGetVideoPalette");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, lpcp=0x%08lX\r\n", _fx_, dwDeviceID, lpcp));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && lpcp);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !lpcp)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the palette information
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetPaletteInfo(lpcp, dwcbSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeExternalVideoStream | This function initializes
 *   an input video stream on the external video channel of a WDM video
 *   capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeExternalVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMInitializeExternalVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));
	DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeVideoStream | This function initializes
 *   an input video stream on the videoin channel of a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeVideoStream(HCAPDEV hcd, DWORD dwDeviceID, DWORD dwMicroSecPerFrame)
{
	FX_ENTRY("WDMInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, FPS=%ld\r\n", _fx_, dwDeviceID, 1000000UL / dwMicroSecPerFrame));

    VIDEO_STREAM_INIT_PARMS vsip = {0};

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize channel
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD_PTR)WDMFrameCallback;
    vsip.dwCallbackInst = (DWORD_PTR)hcd;
    vsip.dwFlags = CALLBACK_FUNCTION;
    // vsip.hVideo = (DWORD)hvideo;

	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Open(&vsip)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMUnInitializeVideoStream | This function requests a WDM
 *   video capture device to close a capture stream on the videoin channel.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMUnInitializeVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMUnInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close streaming on channel
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Close()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStart | This function requests a WDM video
 *   capture device to start a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to start.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStart(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStart");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Start streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Start()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStop | This function requests a WDM video
 *   capture device to stop a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to freeze.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStop(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStop");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Stop streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Stop()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamReset | This function resets a WDM video capture
 *   devie to stop input of a capture stream and return all buffers to the
 *   client.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to reset.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamReset(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamReset");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Reset()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamAddBuffer | This function requests a WDM video
 *   capture device to add an empty input buffer to its input buffer queue.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamAddBuffer(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMVideoStreamAddBuffer");

	DEBUGMSG(ZONE_STREAMING, ("      %s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->AddBuffer((LPVIDEOHDR)pBuff)))
	{
		DEBUGMSG(ZONE_STREAMING, ("      %s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("      %s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetFrame | This function requests a WDM video
 *   capture device to transfer a single frame to or from the video device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @parm PVOID | [OUT] pBuff | Specifies a pointer to a <t VIDEOHDR> structure.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetFrame(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMGetFrame");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	LPVIDEOHDR lpVHdr = (LPVIDEOHDR)pBuff;

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the frame from the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetFrame(lpVHdr))
		return TRUE;
	else
		return FALSE;

}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMShowSettingsDialog | This function puts up a property
 *   sheet with a VideoProcAmp and CameraControl page for a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMShowSettingsDialog(DWORD dwDeviceID, HWND hWndParent)
{
	PROPSHEETHEADER Psh;
	HPROPSHEETPAGE	Pages[MAX_PAGES];

	FX_ENTRY("WDMShowSettingsDialog");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize property sheet header	and common controls
	Psh.dwSize		= sizeof(Psh);
	Psh.dwFlags		= PSH_DEFAULT;
	Psh.hInstance	= g_hInst;
	Psh.hwndParent	= hWndParent;
	Psh.pszCaption	= g_aCapDevices[dwDeviceID]->szDeviceDescription;
	Psh.nPages		= 0;
	Psh.nStartPage	= 0;
	Psh.pfnCallback	= NULL;
	Psh.phpage		= Pages;

    // Create the video settings property page and add it to the video settings sheet
    CWDMDialog VideoSettings(IDD_VIDEO_SETTINGS, NumVideoSettings, PROPSETID_VIDCAP_VIDEOPROCAMP, g_VideoSettingControls, g_VideoSettingsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = VideoSettings.Create())
		Psh.nPages++;

    // Create the camera control property page and add it to the video settings sheet
    CWDMDialog CamControl(IDD_CAMERA_CONTROL, NumCameraControls, PROPSETID_VIDCAP_CAMERACONTROL, g_CameraControls, g_CameraControlsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = CamControl.Create())
		Psh.nPages++;

	// Put up the property sheet
	if (Psh.nPages && PropertySheet(&Psh) >= 0)
		return TRUE;
	else
		return FALSE;

}


void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    )
{
	FX_ENTRY("WDMFrameCallback");

	DEBUGMSG(ZONE_CALLBACK, ("    %s: wMsg=%s, hcd=0x%08lX, lpcbuf=0x%08lX, hcd->hevWait=0x%08lX\r\n", _fx_, (wMsg == MM_DRVM_OPEN) ? "MM_DRVM_OPEN" : (wMsg == MM_DRVM_CLOSE) ? "MM_DRVM_CLOSE" : (wMsg == MM_DRVM_ERROR) ? "MM_DRVM_ERROR" : (wMsg == MM_DRVM_DATA) ? "MM_DRVM_DATA" : "MM_DRVM_?????", hcd, lpcbuf, hcd->hevWait));

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - no data\r\n", _fx_));
	    SetEvent(hcd->hevWait);
	    return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (hcd->lpTail != hcd->lpCurrent)
	    hcd->lpTail = hcd->lpTail->lpPrev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!hcd->lpTail)
	    hcd->lpHead = NULL;

    // Add the new buffer to the ready queue
    lpcbuf->lpNext = hcd->lpHead;
    lpcbuf->lpPrev = NULL;
    if (hcd->lpHead)
	    hcd->lpHead->lpPrev = lpcbuf;
    else
	    hcd->lpTail = lpcbuf;
    hcd->lpHead = lpcbuf;

#if 1
    if (hcd->lpCurrent) {
        if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
    	    // if client hasn't consumed last frame, then release it
			lpcbuf = hcd->lpCurrent;
    	    hcd->lpCurrent = hcd->lpCurrent->lpPrev;
			DEBUGMSG(ZONE_CALLBACK, ("    %s: We already have current buffer (lpcbuf=0x%08lX). Returning this buffer to driver. Set new current buffer hcd->lpCurrent=0x%08lX\r\n", _fx_, lpcbuf, hcd->lpCurrent));
    	    if (!WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)lpcbuf))
			{
				ERRORMESSAGE(("    %s: Attempt to reuse unconsumed buffer failed\r\n", _fx_));
			}
    	}
    }
    else {
#else
    if (!hcd->lpCurrent) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
	    hcd->lpCurrent = hcd->lpTail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - some data\r\n", _fx_));
    SetEvent(hcd->hevWait);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef _DEBUG // { _DEBUG

extern HDBGZONE  ghDbgZoneCap;
int WINAPI CapDbgPrintf ( LPTSTR lpszFormat, ... );

#define ZONE_INIT		(GETMASK(ghDbgZoneCap) & 0x0001)
#define ZONE_STREAMING	(GETMASK(ghDbgZoneCap) & 0x0002)
#define ZONE_CALLBACK	(GETMASK(ghDbgZoneCap) & 0x0004)
#define ZONE_DIALOGS	(GETMASK(ghDbgZoneCap) & 0x0008)
#define ZONE_CALLS		(GETMASK(ghDbgZoneCap) & 0x0010)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (CapDbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (CapDbgPrintf m)

#else // }{ _DEBUG

#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)

#endif // } _DEBUG

#include <poppack.h> /* End byte packing */

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\wdmpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMPIN
 *
 *  @module WDMPin.cpp | Include file for <c CWDMPin> class used to access
 *    video data on a video streaming pin exposed by the WDM class driver.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | CWDMPin | Video pin class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMPin::CWDMPin(DWORD dwDeviceID) : CWDMDriver(dwDeviceID)
{
	m_hKS			= (HANDLE)NULL;
	m_fStarted		= FALSE;
	m_hKsUserDLL	= (HINSTANCE)NULL;
	m_pKsCreatePin	= (LPFNKSCREATEPIN)NULL;

	ZeroMemory(&m_biHdr, sizeof(KS_BITMAPINFOHEADER));
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | ~CWDMPin | Video pin class destructor. Closes
 *    the video pin and releases the video buffers allocated.
 ***************************************************************************/
CWDMPin::~CWDMPin()
{
	FX_ENTRY("CWDMPin::~CWDMPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroying the video pin, m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	// Nuke the video streaming pin
	DestroyPin();

	// Close the driver
	if (GetDriverHandle())
		CloseDriver();

	// Release kernel streaming DLL (KSUSER.DLL)
	if (m_hKsUserDLL)
		FreeLibrary(m_hKsUserDLL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetFrame | This function gets a frame from the
 *    video streaming pin.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to the destination buffer to receive
 *    the video frame and information.
 *
 *  @parm PDWORD | pdwBytesUsed | Pointer to the number of bytes used to
 *    read the video frame.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetFrame(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMPin::GetFrame");

	ASSERT(lpVHdr && lpVHdr->lpData && GetDriverHandle() && m_hKS && (lpVHdr->dwBufferLength >= m_biHdr.biSizeImage));

	DWORD bRtn;

	// Check input params and state
	if (!lpVHdr || !lpVHdr->lpData || !GetDriverHandle() || !m_hKS || (lpVHdr->dwBufferLength < m_biHdr.biSizeImage))
	{
		ERRORMESSAGE(("%s: No buffer, no driver, no PIN connection, or buffer too small\r\n", _fx_));
		goto MyError0;
	}

	// Put the pin in streaming mode
	if (!Start())
	{
		ERRORMESSAGE(("%s: Cannot set streaming state to KSSTATE_RUN\r\n", _fx_));
		goto MyError0;
	}

	// Initialize structure to do a read on the video pin
	DWORD cbBytesReturned;
	KS_HEADER_AND_INFO SHGetImage;

	ZeroMemory(&SHGetImage,sizeof(SHGetImage));
	SHGetImage.StreamHeader.Data = (LPDWORD)lpVHdr->lpData;
	SHGetImage.StreamHeader.Size = sizeof (KS_HEADER_AND_INFO);
	SHGetImage.StreamHeader.FrameExtent = m_biHdr.biSizeImage;
	SHGetImage.FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

	// Read a frame on the video pin
	bRtn = DeviceIoControl(m_hKS, IOCTL_KS_READ_STREAM, &SHGetImage, sizeof(SHGetImage), &SHGetImage, sizeof(SHGetImage), &cbBytesReturned);

	if (!bRtn)
	{
		ERRORMESSAGE(("%s: DevIo rtn (%d), GetLastError=%d. StreamState->STOP\r\n", _fx_, bRtn, GetLastError()));

		// Stop streaming on the video pin
		Stop();

		goto MyError0;
	}

	// Sanity check
	ASSERT(SHGetImage.StreamHeader.FrameExtent >= SHGetImage.StreamHeader.DataUsed);
	if (SHGetImage.StreamHeader.FrameExtent < SHGetImage.StreamHeader.DataUsed)
	{
		ERRORMESSAGE(("%s: We've corrupted memory!\r\n", _fx_));
		goto MyError0;
	}

	lpVHdr->dwTimeCaptured = timeGetTime();
	lpVHdr->dwBytesUsed  = SHGetImage.StreamHeader.DataUsed;
	lpVHdr->dwFlags |= VHDR_KEYFRAME;

	return TRUE;

MyError0:
	if (lpVHdr)
	{
		lpVHdr->dwBytesUsed = 0UL;
		lpVHdr->dwTimeCaptured = timeGetTime();
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Start | This function puts the video
 *    pin in streaming mode.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Start()
{
	if (m_fStarted)
		return TRUE;

	if (SetState(KSSTATE_PAUSE))
		m_fStarted = SetState(KSSTATE_RUN);

	return m_fStarted;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Stop | This function stops streaming on the
 *    video pin.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Stop()
{
	if (m_fStarted)
	{
		if (SetState(KSSTATE_PAUSE))
			if (SetState(KSSTATE_STOP))
				m_fStarted = FALSE;
	}

	return (BOOL)(m_fStarted == FALSE);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function sets the state of the
 *    video streaming pin.
 *
 *  @parm KSSTATE | ksState | New state.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetState(KSSTATE ksState)
{
	KSPROPERTY	ksProp = {0};
	DWORD		cbRet;

	ksProp.Set		= KSPROPSETID_Connection;
	ksProp.Id		= KSPROPERTY_CONNECTION_STATE;
	ksProp.Flags	= KSPROPERTY_TYPE_SET;

	return DeviceIoControl(m_hKS, IOCTL_KS_PROPERTY, &ksProp, sizeof(ksProp), &ksState, sizeof(KSSTATE), &cbRet);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function either finds a video
 *    data range compatible with the bitamp info header passed in, of the
 *    prefered video data range.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdr | Bitmap info header to match.
 *
 *  @parm BOOL | pfValidMatch | Set to TRUE if a match was found, FALSE
 *    otherwise.
 *
 *  @rdesc Returns a valid pointer to a <t KS_DATARANGE_VIDEO> structure if
 *    successful, or a NULL pointer otherwise.
 *
 *  @comm \\redrum\slmro\proj\wdm10\src\dvd\amovie\proxy\filter\ksutil.cpp(207):KsGetMediaTypes(
 ***************************************************************************/
PKS_DATARANGE_VIDEO CWDMPin::FindMatchDataRangeVideo(PKS_BITMAPINFOHEADER pbiHdr, BOOL *pfValidMatch)
{
	FX_ENTRY("CWDMPin::FindMatchDataRangeVideo");

	ASSERT(pfValidMatch && pbiHdr);

	// Check input params and state
	if (!pbiHdr || !pfValidMatch)
	{
		ERRORMESSAGE(("%s: Bad input params\r\n", _fx_));
		return (PKS_DATARANGE_VIDEO)NULL;
	}

	// Default
	*pfValidMatch = FALSE;

	PDATA_RANGES pDataRanges = GetDriverSupportedDataRanges();

	ASSERT(pDataRanges != 0);

	if (!pDataRanges) 
		return (PKS_DATARANGE_VIDEO)NULL;

	PKS_DATARANGE_VIDEO pSelDRVideo, pDRVideo = &pDataRanges->Data, pFirstDRVideo = 0;
	KS_BITMAPINFOHEADER * pbInfo;

	// PhilF-: This code assumes that all structures are KS_DATARANGE_VIDEO. This
	// may not be a valid assumption foir palettized data types. Check with JayBo
	for (ULONG i = 0; i < pDataRanges->Count; i++)
	{ 
		// Meaningless unless it is *_VIDEOINFO
		if (pDRVideo->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO)
		{
			// We don't care about TV Tuner like devices
			if (pDRVideo->ConfigCaps.VideoStandard == KS_AnalogVideo_None)
			{
				// Save first useable data range
				if (!pFirstDRVideo)
					pFirstDRVideo = pDRVideo;  

				pbInfo = &((pDRVideo->VideoInfoHeader).bmiHeader);

				if ( (pbInfo->biBitCount == pbiHdr->biBitCount) && (pbInfo->biCompression == pbiHdr->biCompression) &&
					( (((pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0))
					&& (pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth) && (pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight)) ||
					((pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth) && (pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx) &&
					(pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight) && (pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy) &&
					((pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0) && ((pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0)) ) )
				{
					*pfValidMatch = TRUE;
					pSelDRVideo = pDRVideo;
					break;
				}
			} // VideoStandard
		} // Specifier

		pDRVideo++;  // Next KS_DATARANGE_VIDEO
	}

	// If no valid match, use the first range found
	if (!*pfValidMatch)
		pSelDRVideo = pFirstDRVideo;

	return (pSelDRVideo);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | CreatePin | This function actually creates a
 *    video streaming pin on the class driver.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiNewHdr | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the frame
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::CreatePin(PKS_BITMAPINFOHEADER pbiNewHdr, DWORD dwAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::CreatePin");

	ASSERT(m_pKsCreatePin);

	PKS_BITMAPINFOHEADER pbiHdr;
	BOOL bMustMatch, bValidMatch;
#ifdef _DEBUG
	char szFourCC[5] = {0};
#endif

	if (pbiNewHdr)
	{
		// We need to find a video data range that matches the bitmap info header passed in
		bMustMatch = TRUE;
		pbiHdr = pbiNewHdr;
	}
	else
	{
		// We'll use the preferred video data range and default bitmap format
		bMustMatch = FALSE;
		pbiHdr = &m_biHdr;
	}

	PKS_DATARANGE_VIDEO pSelDRVideo = FindMatchDataRangeVideo(pbiHdr, &bValidMatch);
	if (!pSelDRVideo)         
		return FALSE;

	if (bMustMatch && !bValidMatch)
		return FALSE;

	// If we already have a pin, nuke it
	if (GetPinHandle()) 
		DestroyPin();

	// Connect to a new PIN.
	DATAPINCONNECT DataConnect;
	ZeroMemory(&DataConnect, sizeof(DATAPINCONNECT));
	DataConnect.Connect.PinId						= 0;								// CODEC0 sink
	DataConnect.Connect.PinToHandle					= NULL;								// no "connect to"
	DataConnect.Connect.Interface.Set				= KSINTERFACESETID_Standard;
	DataConnect.Connect.Interface.Id				= KSINTERFACE_STANDARD_STREAMING;	// STREAMING
	DataConnect.Connect.Medium.Set					= KSMEDIUMSETID_Standard;
	DataConnect.Connect.Medium.Id					= KSMEDIUM_STANDARD_DEVIO;
	DataConnect.Connect.Priority.PriorityClass		= KSPRIORITY_NORMAL;
	DataConnect.Connect.Priority.PrioritySubClass	= 1;
	CopyMemory(&(DataConnect.Data.DataFormat), &(pSelDRVideo->DataRange), sizeof(KSDATARANGE));
	CopyMemory(&(DataConnect.Data.VideoInfoHeader), &pSelDRVideo->VideoInfoHeader, sizeof(KS_VIDEOINFOHEADER));

	// Adjust the image sizes if necessary
	if (bValidMatch)
	{
		DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth		= pbiHdr->biWidth;
		DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight		= abs(pbiHdr->biHeight); // Support only +biHeight!
		DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage	= pbiHdr->biSizeImage;        
	}

	// Overwrite the default frame rate if non-zero
	if (dwAvgTimePerFrame > 0)
		DataConnect.Data.VideoInfoHeader.AvgTimePerFrame = (REFERENCE_TIME)dwAvgTimePerFrame;

#ifdef _DEBUG
    *((DWORD*)&szFourCC) = DataConnect.Data.VideoInfoHeader.bmiHeader.biCompression;
#endif
	DEBUGMSG(ZONE_INIT, ("%s: Request image format: FourCC(%s) %d * %d * %d bits = %d bytes\r\n", _fx_, szFourCC, DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth, DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight, DataConnect.Data.VideoInfoHeader.bmiHeader.biBitCount, DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: Request frame rate:   %d fps\r\n", _fx_, 10000000/dwAvgTimePerFrame));
	DEBUGMSG(ZONE_INIT, ("%s: m_hKS was=0x%08lX\r\n", _fx_, m_hKS));

#ifndef HIDE_WDM_DEVICES
	DWORD dwErr = (*m_pKsCreatePin)(GetDriverHandle(), (PKSPIN_CONNECT)&DataConnect, GENERIC_READ | GENERIC_WRITE, &m_hKS);
#else
	DWORD dwErr = 0UL;
	m_hKS = NULL;
#endif

	if (dwAvgTimePerFrame != 0)
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX set to stream at %d fps\r\n", _fx_, m_hKS, 10000000/dwAvgTimePerFrame));
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX\r\n", _fx_, m_hKS));
	}

	if (dwErr || (m_hKS == NULL))
	{
		ERRORMESSAGE(("%s: KsCreatePin returned 0x%08lX failure and m_hKS=0x%08lX\r\n", _fx_, dwErr, m_hKS));

		if (m_hKS == INVALID_HANDLE_VALUE)
		{  
			m_hKS = (HANDLE)NULL;
		}

		return FALSE;
	}

	// Cache the bitmap info header
	CopyMemory(&m_biHdr, &DataConnect.Data.VideoInfoHeader.bmiHeader, sizeof(KS_BITMAPINFOHEADER));
	m_dwAvgTimePerFrame = (DWORD)DataConnect.Data.VideoInfoHeader.AvgTimePerFrame;

	DEBUGMSG(ZONE_INIT, ("%s: New m_biHdr:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, m_biHdr.biSize, m_biHdr.biWidth, m_biHdr.biHeight, m_biHdr.biPlanes, m_biHdr.biBitCount, m_biHdr.biCompression, m_biHdr.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: New m_dwAvgTimePerFrame=%ld (%fd fps)\r\n", _fx_, m_dwAvgTimePerFrame, 10000000/m_dwAvgTimePerFrame));

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | DestroyPin | This function nukes a video
 *    streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::DestroyPin()
{
	BOOL fRet = TRUE;

	FX_ENTRY("CWDMPin::DestroyPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroy PIN m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	if (m_hKS)
	{
		Stop();

		if (!(fRet = CloseHandle(m_hKS)))
		{
			ERRORMESSAGE(("%s: CloseHandle(m_hKS=0x%08lX) failed with GetLastError()=0x%08lX\r\n", _fx_, m_hKS, GetLastError()));
		}

		m_hKS = NULL;
	}

	return fRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetBitmapInfo | This function sets the video
 *    format of video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdrNew | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetBitmapInfo(PKS_BITMAPINFOHEADER pbiHdrNew)
{
	FX_ENTRY("CWDMPin::SetBitmapInfo");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: New pbiHdrNew:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbiHdrNew->biSize, pbiHdrNew->biWidth, pbiHdrNew->biHeight, pbiHdrNew->biPlanes, pbiHdrNew->biBitCount, pbiHdrNew->biCompression, pbiHdrNew->biSizeImage));

	// Check if we need to change anything
	if ( GetPinHandle() && (m_biHdr.biHeight == pbiHdrNew->biHeight) && (m_biHdr.biWidth == pbiHdrNew->biWidth) &&
		(m_biHdr.biBitCount == pbiHdrNew->biBitCount) && (m_biHdr.biSizeImage == pbiHdrNew->biSizeImage) &&
		(m_biHdr.biCompression == pbiHdrNew->biCompression) )
		return TRUE;
	else 
		return CreatePin(pbiHdrNew, m_dwAvgTimePerFrame);    

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetBitmapInfo | This function gets the video
 *    format of a video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbInfo | This parameter points to a bitmap
 *    info header structure to receive the video format.
 *
 *  @parm WORD | wSize | This parameter specifies the size of the bitmap
 *    info header structure.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo, WORD wSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage)
	{
		ERRORMESSAGE(("%s: No existing PIN handle or no available format\r\n", _fx_));
		return FALSE;
	}

	CopyMemory(pbInfo, &m_biHdr, wSize);  

	// Support only positive +biHeight.  
	if (pbInfo->biHeight < 0)
	{
		pbInfo->biHeight = -pbInfo->biHeight;
		DEBUGMSG(ZONE_INIT, ("%s: Changed biHeight from -%ld to %ld\r\n", _fx_, pbInfo->biHeight, pbInfo->biHeight));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetPaletteInfo | This function gets the video
 *    palette of a video streaming pin.
 *
 *  @parm CAPTUREPALETTE * | pPal | This parameter points to a palette
 *    structure to receive the video palette.
 *
 *  @parm DWORD | dwcbSize | This parameter specifies the size of the video
 *    palette.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetPaletteInfo(CAPTUREPALETTE *pPal, DWORD dwcbSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage && (m_biHdr.biBitCount > 8))
	{
		ERRORMESSAGE(("%s: No existing PIN handle, no available format, or bad biBitCount\r\n", _fx_));
		return FALSE;
	}

	// PhilF-: Copy some real bits there
	// CopyMemory(pbInfo, &m_biHdr, wSize);  

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetAverageTimePerFrame | This function sets the
 *    video frame rate of a video streaming pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the rate
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetAverageTimePerFrame(DWORD dwNewAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::SetAverageTimePerFrame");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Current frame interval=%d; new frame intercal=%d\r\n", _fx_, m_dwAvgTimePerFrame, dwNewAvgTimePerFrame));

    if (m_dwAvgTimePerFrame != dwNewAvgTimePerFrame)
		return CreatePin(&m_biHdr, dwNewAvgTimePerFrame);    
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: No need to change frame rate\r\n", _fx_));
        return TRUE;
    }

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | OpenDriverAndPin | This function opens the class
 *    driver and creates a video streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::OpenDriverAndPin()
{
	FX_ENTRY("CWDMPin::OpenDriverAndPin");

	// Load KSUSER.DLL and get a proc address
	if (m_hKsUserDLL = LoadLibrary("KSUSER"))
	{
		if (m_pKsCreatePin = (LPFNKSCREATEPIN)GetProcAddress(m_hKsUserDLL, "KsCreatePin"))
		{
			// Open the class driver
			if (OpenDriver())
			{
				// Create a video streaming pin on the driver
				if (CreatePin((PKS_BITMAPINFOHEADER)NULL))
				{
					return TRUE;
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: Pin connection creation failed!\r\n", _fx_));

					if (GetDriverHandle()) 
						CloseDriver();
				}
			}
		}

		FreeLibrary(m_hKsUserDLL);
	}


	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\wdmstrmr.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMStrmr.cpp | Source file for <c CWDMStreamer> class used to get a
 *    stream of video data flowing from WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | CWDMStreamer | WDM filter class constructor.
 *
 *  @parm CWDMPin * | pWDMVideoPin | Pointer to the kernel streaming
 *    object we will get the frames from.
 ***************************************************************************/
CWDMStreamer::CWDMStreamer(CWDMPin * pWDMVideoPin)
{
	m_pWDMVideoPin = pWDMVideoPin;
	m_lpVHdrFirst = (LPVIDEOHDR)NULL;
	m_lpVHdrLast = (LPVIDEOHDR)NULL;
	m_fVideoOpen = FALSE;
	m_fStreamingStarted = FALSE;
	m_pBufTable = (PBUFSTRUCT)NULL;
	m_cntNumVidBuf = 0UL;
	m_idxNextVHdr = 0UL;
    m_hThread = NULL;
	m_bKillThread = FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | videoCallback | This function calls the
 *    callback function provided by the appplication.
 *
 *  @parm WORD | msg | Message value.
 *
 *  @parm DWORD | dwParam1 | 32-bit message-dependent parameter.
 ***************************************************************************/
void CWDMStreamer::videoCallback(WORD msg, DWORD_PTR dwParam1)
{
    if (m_CaptureStreamParms.dwCallback)
        DriverCallback (m_CaptureStreamParms.dwCallback, HIWORD(m_CaptureStreamParms.dwFlags), (HDRVR) m_CaptureStreamParms.hVideo, msg, m_CaptureStreamParms.dwCallbackInst, dwParam1, 0UL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc LPVIDEOHDR | CWDMStreamer | DeQueueHeader | This function dequeues a
 *    video buffer from the list of video buffers used for streaming.
 *
 *  @rdesc Returns a valid pointer if successful, or NULL otherwise.
 ***************************************************************************/
LPVIDEOHDR CWDMStreamer::DeQueueHeader()
{
	FX_ENTRY("CWDMStreamer::DeQueueHeader");

    LPVIDEOHDR lpVHdr;

    if (m_pBufTable)
	{
        if (m_pBufTable[m_idxNextVHdr].fReady)
		{
			DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

            lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
            lpVHdr->dwFlags &= ~VHDR_INQUEUE;
            m_pBufTable[m_idxNextVHdr].fReady = FALSE;
        }
		else
		{
            m_idxNextVHdr++;
            if (m_idxNextVHdr >= m_cntNumVidBuf)
                m_idxNextVHdr = 0;

			if (m_pBufTable[m_idxNextVHdr].fReady)
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

				lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
				lpVHdr->dwFlags &= ~VHDR_INQUEUE;
				m_pBufTable[m_idxNextVHdr].fReady = FALSE;
			}
			else
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: idxNextVHdr (idx=%d) has not been returned by client\r\n", _fx_, m_idxNextVHdr));
				lpVHdr = NULL;
			}
		}
    }
	else
	{
        lpVHdr = m_lpVHdrFirst;

        if (lpVHdr) {

            lpVHdr->dwFlags &= ~VHDR_INQUEUE;

            m_lpVHdrFirst = (LPVIDEOHDR)(lpVHdr->dwReserved[0]);

            if (m_lpVHdrFirst == NULL)
                m_lpVHdrLast = NULL;
        }
    }

    return lpVHdr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | QueueHeader | This function actually adds the
 *    video buffer to the list of video buffers used for streaming.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 ***************************************************************************/
void CWDMStreamer::QueueHeader(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::QueHeader");

	// Initialize status flags
    lpVHdr->dwFlags &= ~VHDR_DONE;
    lpVHdr->dwFlags |= VHDR_INQUEUE;
    lpVHdr->dwBytesUsed = 0;

    // Add buffer to list
    if (m_pBufTable)
	{
		if (lpVHdr->dwReserved[1] < m_cntNumVidBuf)
		{
			if (m_pBufTable[lpVHdr->dwReserved[1]].lpVHdr != lpVHdr)
			{
				DEBUGMSG(ZONE_STREAMING, ("        %s: index (%d) Match but lpVHdr does not(%x)\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
			}
			m_pBufTable[lpVHdr->dwReserved[1]].fReady = TRUE;
			DEBUGMSG(ZONE_STREAMING, ("        %s: Buffer lpVHdr=0x%08lX was succesfully queued\r\n", _fx_, lpVHdr));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("        %s: lpVHdr->dwReserved[1](%d) >= m_cntNumVidBuf (%d)\r\n", _fx_, lpVHdr->dwReserved[1], m_cntNumVidBuf));
		}
	}
	else
	{
		*(lpVHdr->dwReserved) = NULL;

		if (m_lpVHdrLast)
			*(m_lpVHdrLast->dwReserved) = (DWORD_PTR)lpVHdr;
		else
			m_lpVHdrFirst = lpVHdr;

		m_lpVHdrLast = lpVHdr;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | AddBuffer | This function adds a buffer to the
 *    list of video buffers to be used when streaming video data from the WDM
 *    device.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_ADDBUFFER message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::AddBuffer(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::AddBuffer");

	ASSERT(m_fVideoOpen && lpVHdr && !(lpVHdr->dwFlags & VHDR_INQUEUE));

	// Make sure this is a valid call
    if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because m_fVideoOpen=FALSE\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!lpVHdr)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because lpVHdr=NULL\r\n", _fx_, lpVHdr));
		return FALSE;
	}

    if (lpVHdr->dwFlags & VHDR_INQUEUE)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because buffer is already queued\r\n", _fx_, lpVHdr));
		return FALSE;
	}

	// Does the size of the buffer match the size of the buffers the streaming pin will generate?
    if (lpVHdr->dwBufferLength < m_pWDMVideoPin->GetFrameSize())
	{
		ERRORMESSAGE(("%s: Buffer lpVHdr=0x%08lX can't be queued because the length of that buffer is too small\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!m_pBufTable)
	{
        lpVHdr->dwReserved[1] = m_cntNumVidBuf;
        m_cntNumVidBuf++;
		DEBUGMSG(ZONE_STREAMING, ("%s: Queue buffer (%d) lpVHdr=0x%08lX\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
    }

    QueueHeader(lpVHdr);

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stop | This function stops a stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_STOP message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Stop()
{
	FX_ENTRY("CWDMStreamer::Stop");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Reset data members - stop streaming thread
    m_fStreamingStarted = FALSE;

    if (m_hThread)
    {

		DEBUGMSG(ZONE_STREAMING, ("%s: Stopping the thread\r\n", _fx_));

        // Signal the streaming thread to stop
		m_bKillThread = TRUE;

        // wait until thread has self-terminated, and clear the event.
		DEBUGMSG(ZONE_STREAMING, ("%s: WaitingForSingleObject...\r\n", _fx_));

        WaitForSingleObject(m_hThread, INFINITE);

		DEBUGMSG(ZONE_STREAMING, ("%s: ...thread stopped\r\n", _fx_));

		// Close the thread handle
		CloseHandle(m_hThread);
		m_hThread = NULL;

		// Ask the pin to stop streaming.
		m_pWDMVideoPin->Stop();

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
			{
				SetEvent(m_pWDMVideoBuff[i].Overlap.hEvent);
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
				m_pWDMVideoBuff[i].Overlap.hEvent = NULL;
			}
		}

		if (m_pWDMVideoBuff)
		{
			delete []m_pWDMVideoBuff;
			m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;
		}

    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Reset | This function resets a stream of
 *    video data coming from the WDM device so that prepared buffer may be
 *    freed correctly.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_RESET message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Reset()
{
	LPVIDEOHDR lpVHdr;

	FX_ENTRY("CWDMStreamer::Reset");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
    Stop();

	// Return all buffers to the application one last time
	while (lpVHdr = DeQueueHeader ())
	{
		lpVHdr->dwFlags |= VHDR_DONE;
		videoCallback(MM_DRVM_DATA, (DWORD_PTR) lpVHdr);
	}

	// Reset data members
    m_lpVHdrFirst = (LPVIDEOHDR)NULL;
    m_lpVHdrLast = (LPVIDEOHDR)NULL;
    if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Open | This function opens a stream of
 *    video data coming from the WDM device.
 *
 *  @parm LPVIDEO_STREAM_INIT_PARMS | lpStreamInitParms | Pointer to
 *    initialization data.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_INIT message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Open(LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms)
{
	FX_ENTRY("CWDMStreamer::Open");

	ASSERT(!m_fVideoOpen);

	// Make sure this is a valid call
	if (m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is already opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Initialize data memmbers
	m_CaptureStreamParms	= *lpStreamInitParms;
	m_fVideoOpen			= TRUE;
	m_lpVHdrFirst			= (LPVIDEOHDR)NULL;
	m_lpVHdrLast			= (LPVIDEOHDR)NULL;
	m_cntNumVidBuf			= 0UL;

	// Set frame rate on the pin
	m_pWDMVideoPin->SetAverageTimePerFrame(lpStreamInitParms->dwMicroSecPerFrame * 10);

	// Let the app know we just opened a stream
	videoCallback(MM_DRVM_OPEN, 0L);

	if (lpStreamInitParms->dwMicroSecPerFrame != 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Capturing at %d frames/sec\r\n", _fx_, 100000 / lpStreamInitParms->dwMicroSecPerFrame));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Close | This function closes the stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_FINI message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Close()
{
	FX_ENTRY("CWDMStreamer::Close");

	ASSERT(m_fVideoOpen && !m_lpVHdrFirst);

	// Make sure this is a valid call
	if (!m_fVideoOpen || m_lpVHdrFirst)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
	Stop();

	// Reset data members
	m_fVideoOpen = FALSE;
	m_lpVHdrFirst = m_lpVHdrLast = (LPVIDEOHDR)NULL;
	m_idxNextVHdr = 0UL;

	// Release table of pointers to video buffers
	if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
	}

	// Let the app know that we just closed the stream
	videoCallback(MM_DRVM_CLOSE, 0L);

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | BufferDone | This function lets the application
 *    know that there is video data available coming from the WDM device.
 *
 *  @devnote This method is called by the kernel streaming object (Pin)
 ***************************************************************************/
void CWDMStreamer::BufferDone(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::BufferDone");

	// Make sure this is a valid call
	if (!m_fStreamingStarted)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Video has not been started or just been stopped\r\n", _fx_));
		return;
	}

    if (lpVHdr == NULL)
	{
		// No buffers available - the app hasn't returned the buffers to us yet
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that we don't have any buffers anymore since lpVHdr=NULL\r\n", _fx_));

		// Let the app know something wrong happened
        videoCallback(MM_DRVM_ERROR, 0UL);
        return;
    }

    lpVHdr->dwFlags |= VHDR_DONE;

	// Sanity check
    if (lpVHdr->dwBytesUsed == 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is no valid data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

		// Return frame to the pool before notifying app
		AddBuffer(lpVHdr);
        videoCallback(MM_DRVM_ERROR, 0UL);
    }
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

        lpVHdr->dwTimeCaptured = timeGetTime() - m_dwTimeStart;

		// Let the app know there's some valid video data available
        videoCallback(MM_DRVM_DATA, (DWORD_PTR)lpVHdr);
    }
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Start | This function starts streaming
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_START message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Start()
{
	FX_ENTRY("CWDMStreamer::Start");

    ULONG i;
    LPVIDEOHDR lpVHdr;
	DWORD dwThreadID;

	ASSERT(m_fVideoOpen && m_pWDMVideoPin->GetAverageTimePerFrame() && !m_hThread);

	// Make sure this is a valid call
	if (!m_fVideoOpen || !m_pWDMVideoPin->GetAverageTimePerFrame() || m_hThread)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming in %d video buffers at %d frames/sec\r\n", _fx_, m_cntNumVidBuf, 1000000 / m_pWDMVideoPin->GetAverageTimePerFrame()));

	// Allocate and initialize the video buffer structures
    m_pBufTable = (PBUFSTRUCT) new BUFSTRUCT[m_cntNumVidBuf];
    if (m_pBufTable)
	{
		lpVHdr = m_lpVHdrFirst;
		for (i = 0; i < m_cntNumVidBuf && lpVHdr; i++)
		{
			m_pBufTable[i].fReady = TRUE;
			m_pBufTable[i].lpVHdr = lpVHdr;
			lpVHdr = (LPVIDEOHDR) lpVHdr->dwReserved[0];
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_pBufTable allocation failed! AsynIO may be out of sequence\r\n", _fx_));
	}

    m_idxNextVHdr		= 0UL;  // 0..m_cntNumVidBuf-1
    m_dwTimeStart		= timeGetTime();
    m_fStreamingStarted	= TRUE;
	m_bKillThread = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("%s: Creating %d read video buffers\r\n", _fx_, m_cntNumVidBuf));

	if (!(m_pWDMVideoBuff = (WDMVIDEOBUFF *) new WDMVIDEOBUFF[m_cntNumVidBuf]))
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_Overlap allocation failed!\r\n", _fx_));
		return FALSE;
	}

	for(i=0; i<m_cntNumVidBuf; i++)
	{
		// Create the overlapped structures
		ZeroMemory( &(m_pWDMVideoBuff[i].Overlap), sizeof(OVERLAPPED) );
		m_pWDMVideoBuff[i].Overlap.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

		DEBUGMSG(ZONE_STREAMING, ("%s: Event %d is handle 0x%08lX\r\n", _fx_, i, m_pWDMVideoBuff[i].Overlap.hEvent));
	}

	m_dwNextToComplete=0;

    // Create the streaming thread
    m_hThread = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)ThreadStub,
                                this,
                                CREATE_SUSPENDED,
                                &dwThreadID);

    if (m_hThread == NULL)
    {
		ERRORMESSAGE(("%s: Couldn't create the thread\r\n", _fx_));

		for (UINT iVideoBuf=0; iVideoBuf<m_cntNumVidBuf; iVideoBuf++)
		{
			if (m_pWDMVideoBuff[iVideoBuf].Overlap.hEvent)
				CloseHandle(m_pWDMVideoBuff[iVideoBuf].Overlap.hEvent);
		}

		delete []m_pWDMVideoBuff;
		m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;

		m_lpVHdrFirst = (LPVIDEOHDR)NULL;
		m_lpVHdrLast = (LPVIDEOHDR)NULL;
		if (m_pBufTable)
		{
			delete []m_pBufTable;
			m_pBufTable = NULL;
		}

        return FALSE;
    }

    SetThreadPriority(m_hThread, THREAD_PRIORITY_ABOVE_NORMAL);

    ResumeThread(m_hThread);

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread created OK\r\n", _fx_));

    return TRUE;

}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stream | This function does the actual
 *    streaming.
 ***************************************************************************/
void CWDMStreamer::Stream()
{
	FX_ENTRY("CWDMStreamer::Stream");

	DEBUGMSG(ZONE_STREAMING, ("%s: Starting to process StreamingThread\r\n", _fx_));

	// Put the pin in streaming mode
	m_pWDMVideoPin->Start();

	// Queue all the reads
	for (UINT i = 0; i<m_cntNumVidBuf; i++)
	{
		QueueRead(i);
	}

	m_dwNextToComplete=0;
#ifdef _DEBUG
	m_dwFrameCount=0;
#endif
	BOOL  bGotAFrame=FALSE;
	DWORD dwRes;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Starting to wait on reads to complete\r\n", _fx_));

	while (!m_bKillThread)
	{
		bGotAFrame = FALSE;

		if (m_pWDMVideoBuff[m_dwNextToComplete].fBlocking)
		{
			DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Waiting on read to complete...\r\n", _fx_));

			// Waiting for the asynchronous read to complete
			dwRes = WaitForSingleObject(m_pWDMVideoBuff[m_dwNextToComplete].Overlap.hEvent, 1000*1);

			if (dwRes == WAIT_FAILED)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...we couldn't perform the wait as requested\r\n", _fx_));
			}

			if (dwRes == WAIT_OBJECT_0)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...wait is over - we now have a frame\r\n", _fx_));
				bGotAFrame = TRUE;
			}
			else
			{
				// time out waiting for frames.
				if (dwRes == WAIT_TIMEOUT)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Waiting failed with timeout, last error=%d\r\n", _fx_, GetLastError()));
				}
			}
		}
		else
		{
			// We didn't have to wait - this means the read executed synchronously
			bGotAFrame = TRUE;
		}

		if (bGotAFrame)
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Trying to give frame #%ld to the client\r\n", _fx_, m_dwFrameCount++));

			LPVIDEOHDR lpVHdr;

			lpVHdr = m_pWDMVideoBuff[m_dwNextToComplete].pVideoHdr;

			if (lpVHdr)
			{
				lpVHdr->dwBytesUsed = m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.StreamHeader.DataUsed;

				if ((m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.FrameInfo.dwFrameFlags & 0x00f0) == KS_VIDEO_FLAG_I_FRAME)
					lpVHdr->dwFlags |= VHDR_KEYFRAME;
			}

			// Mark the buffer as done - signal the app
			BufferDone(lpVHdr);

			// Queue a new read
			QueueRead(m_dwNextToComplete);
		}

		m_dwNextToComplete++;
		m_dwNextToComplete %= m_cntNumVidBuf;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: End of the streaming thread\r\n", _fx_));

	ExitThread(0);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | QueueRead | This function queues a read
 *    operation on a video streaming pin.
 *
 *  @parm DWORD | dwIndex | Index of the video structure in read buffer.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMStreamer::QueueRead(DWORD dwIndex)
{
	FX_ENTRY("CWDMStreamer::QueueRead");

	DWORD cbReturned;
	BOOL  bShouldBlock = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Queue read buffer %d on pin handle 0x%08lX\r\n", _fx_, dwIndex, m_pWDMVideoPin->GetPinHandle()));

	// Get a buffer from the queue of video buffers
	m_pWDMVideoBuff[dwIndex].pVideoHdr = DeQueueHeader();

	if (m_pWDMVideoBuff[dwIndex].pVideoHdr)
	{
		ZeroMemory(&m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage));
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Size				= sizeof (KS_HEADER_AND_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.FrameInfo.ExtendedHeaderSize	= sizeof (KS_FRAME_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Data				= m_pWDMVideoBuff[dwIndex].pVideoHdr->lpData;
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.FrameExtent		= m_pWDMVideoPin->GetFrameSize();

		// Submit the read
		BOOL bRet = DeviceIoControl(m_pWDMVideoPin->GetPinHandle(), IOCTL_KS_READ_STREAM, &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &cbReturned, &m_pWDMVideoBuff[dwIndex].Overlap);

		if (!bRet)
		{
			DWORD dwErr = GetLastError();
			switch(dwErr)
			{
				case ERROR_IO_PENDING:
					DEBUGMSG(ZONE_STREAMING, ("%s: An overlapped IO is going to take place\r\n", _fx_));
					bShouldBlock = TRUE;
					break;

				// Something bad happened
				default:
					DEBUGMSG(ZONE_STREAMING, ("%s: DeviceIoControl() failed badly dwErr=%d\r\n", _fx_, dwErr));
					break;
			}
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Overlapped IO won't take place - no need to wait\r\n", _fx_));
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: We won't queue the read - no buffer available\r\n", _fx_));
	}

	m_pWDMVideoBuff[dwIndex].fBlocking = bShouldBlock;

	return bShouldBlock;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | ThreadStub | Thread stub.
 ***************************************************************************/
LPTHREAD_START_ROUTINE CWDMStreamer::ThreadStub(CWDMStreamer *pCWDMStreamer)
{
	FX_ENTRY("CWDMStreamer::ThreadStub");

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread stub called, starting streaming...\r\n", _fx_));

    pCWDMStreamer->Stream();

	DEBUGMSG(ZONE_STREAMING, ("%s: ...capture thread has stopped\r\n", _fx_));

    return(0);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\wdmdrivr.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMDRIVER
 *
 *  @module WDMDrivr.cpp | Include file for <c CWDMDriver> class used to
 *    access the streaming class driver using IOctls.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | CWDMDriver | Driver class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMDriver::CWDMDriver(DWORD dwDeviceID) 
{
	m_hDriver = (HANDLE)NULL;
	m_pDataRanges = (PDATA_RANGES)NULL;

	m_dwDeviceID = dwDeviceID;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | ~CWDMDriver | Driver class destructor. Closes
 *    the driver file handle and releases the video data range memory.
 ***************************************************************************/
CWDMDriver::~CWDMDriver()
{
	if (m_hDriver) 
		CloseDriver();

	if (m_pDataRanges)
	{
		delete [] m_pDataRanges;
		m_pDataRanges = (PDATA_RANGES)NULL;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CreateDriverSupportedDataRanges | This
 *    function builds the list of video data ranges supported by the capture
 *    device.
 *
 *  @rdesc Returns the number of valid data ranges in the list.
 ***************************************************************************/
DWORD CWDMDriver::CreateDriverSupportedDataRanges()
{
	FX_ENTRY("CWDMDriver::CreateDriverSupportedDataRanges");

	DWORD cbReturned;
	DWORD dwSize = 0UL;

	// Initialize property structure to get data ranges
	KSP_PIN KsProperty = {0};

	KsProperty.PinId			= 0; // m_iPinNumber;
	KsProperty.Property.Set		= KSPROPSETID_Pin;
	KsProperty.Property.Id		= KSPROPERTY_PIN_DATARANGES ;
	KsProperty.Property.Flags	= KSPROPERTY_TYPE_GET;

	// Get the size of the data range structure
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
	{
		ERRORMESSAGE(("%s: Couldn't get the size for the data ranges\r\n", _fx_));
		return 0UL;
	}

	DEBUGMSG(ZONE_INIT, ("%s: GetData ranges needs %d bytes\r\n", _fx_, dwSize));

	// Allocate memory to hold data ranges
	if (m_pDataRanges)
		delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES) new BYTE[dwSize];

	if (!m_pDataRanges)
	{
		ERRORMESSAGE(("%s: Couldn't allocate memory for the data ranges\r\n", _fx_));
		return 0UL;
	}

	// Really get the data ranges
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), m_pDataRanges, dwSize, &cbReturned) == 0)
	{
		ERRORMESSAGE(("%s: Problem getting the data ranges themselves\r\n", _fx_));
		goto MyError1;
	}

	// Sanity check
	if (cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0)
	{
		ERRORMESSAGE(("%s: cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0\r\n", _fx_));
		goto MyError1;
	}

	return m_pDataRanges->Count;

MyError1:
	delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES)NULL;
	return 0UL;

}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | OpenDriver | This function opens a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::OpenDriver()
{
	FX_ENTRY("CWDMDriver::OpenDriver");

	// Don't re-open the driver
	if (m_hDriver)
	{
		DEBUGMSG(ZONE_INIT, ("%s: Class driver already opened\r\n", _fx_));
		return TRUE;
	}

	// Validate driver path
	if (lstrlen(g_aCapDevices[m_dwDeviceID]->szDeviceName) == 0)
	{
		ERRORMESSAGE(("%s: Invalid driver path\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Opening class driver '%s'\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName));

	// All we care is to wet the hInheritHanle = TRUE;
	SECURITY_ATTRIBUTES SecurityAttributes;
	SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);  // use pointers
	SecurityAttributes.bInheritHandle = TRUE;
	SecurityAttributes.lpSecurityDescriptor = NULL; // GetInitializedSecurityDescriptor();

	// Really open the driver
	if ((m_hDriver = CreateFile(g_aCapDevices[m_dwDeviceID]->szDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &SecurityAttributes, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) == INVALID_HANDLE_VALUE)
	{
		ERRORMESSAGE(("%s: CreateFile failed with Path=%s GetLastError()=%d\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName, GetLastError()));
		m_hDriver = (HANDLE)NULL;
		return FALSE;
	}

	// If there is no valid data range, we cannot stream
	if (!CreateDriverSupportedDataRanges())
	{
		CloseDriver();
		return FALSE;
	}
	else
		return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CloseDriver | This function closes a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::CloseDriver()
{
	FX_ENTRY("CWDMDriver::CloseDriver");

	BOOL bRet = TRUE;

	if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE))
	{
		if (!(bRet = CloseHandle(m_hDriver)))
		{
			ERRORMESSAGE(("%s: CloseHandle() failed with GetLastError()=%d\r\n", _fx_, GetLastError()));
		}
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: Nothing to close\r\n", _fx_));
	}

	m_hDriver = (HANDLE)NULL;

	return bRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | DeviceIoControl | This function wraps around
 *    ::DeviceIOControl.
 *
 *  @parm HANDLE | hFile | Handle to the device that is to perform the
 *    operation.
 *
 *  @parm DWORD | dwIoControlCode | Specifies the control code for the
 *    operation.
 *
 *  @parm LPVOID | lpInBuffer | Pointer to a buffer that contains the data
 *    required to perform the operation.
 *
 *  @parm DWORD | nInBufferSize | Specifies the size, in bytes, of the buffer
 *    pointed to by <p lpInBuffer>.
 *
 *  @parm LPVOID | lpOutBuffer | Pointer to a buffer that receives the
 *    operation's output data.
 *
 *  @parm DWORD | nOutBufferSize | Specifies the size, in bytes, of the
 *    buffer pointed to by <p lpOutBuffer>.
 *
 *  @parm LPDWORD | lpBytesReturned | Pointer to a variable that receives the
 *    size, in bytes, of the data stored into the buffer pointed to by
 *    <p lpOutBuffer>.
 *
 *  @parm BOOL | bOverlapped | If TRUE, the operation is performed
 *    asynchronously, if FALSE, the operation is synchronous.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::DeviceIoControl(HANDLE hFile, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped)
{
	FX_ENTRY("CWDMDriver::DeviceIoControl");

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
	{
		LPOVERLAPPED lpOverlapped=NULL;
		BOOL bRet;
		OVERLAPPED ov;
		DWORD dwErr;

		if (bOverlapped)
		{
			ov.Offset            = 0;
			ov.OffsetHigh        = 0;
			ov.hEvent            = CreateEvent( NULL, FALSE, FALSE, NULL );
			if (ov.hEvent == (HANDLE) 0)
			{
				ERRORMESSAGE(("%s: CreateEvent has failed\r\n", _fx_));
			}
			lpOverlapped        =&ov;
		}

		bRet = ::DeviceIoControl(hFile, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);

		if (bOverlapped)
		{
			BOOL bShouldBlock=FALSE;

			if (!bRet)
			{
				dwErr=GetLastError();
				switch (dwErr)
				{
					case ERROR_IO_PENDING:    // the overlapped IO is going to take place.
						bShouldBlock=TRUE;
						break;

					default:    // some other strange error has happened.
						ERRORMESSAGE(("%s: DevIoControl failed with GetLastError=%d\r\n", _fx_, dwErr));
						break;
				}
			}

			if (bShouldBlock)
			{
#ifdef _DEBUG
				DWORD    tmStart, tmEnd, tmDelta;
				tmStart = timeGetTime();
#endif

				DWORD dwRtn = WaitForSingleObject( ov.hEvent, 1000 * 10);  // USB has a max of 5 SEC bus reset

#ifdef _DEBUG
				tmEnd = timeGetTime();
				tmDelta = tmEnd - tmStart;
				if (tmDelta >= 1000)
				{
					ERRORMESSAGE(("%s: WaitObj waited %d msec\r\n", _fx_, tmDelta));
				}
#endif

				switch (dwRtn)
				{
					case WAIT_ABANDONED:
						ERRORMESSAGE(("%s: WaitObj: non-signaled ! WAIT_ABANDONED!\r\n", _fx_));
						bRet = FALSE;
						break;

					case WAIT_OBJECT_0:                    
						bRet = TRUE;
						break;

					case WAIT_TIMEOUT:
#ifdef _DEBUG
						ERRORMESSAGE(("%s: WaitObj: TIMEOUT after %d msec! rtn FALSE\r\n", _fx_, tmDelta));
#endif
						bRet = FALSE;
						break;

					default:
						ERRORMESSAGE(("%s: WaitObj: unknown return ! rtn FALSE\r\n", _fx_));
						bRet = FALSE;
						break;
				}
			}

			CloseHandle(ov.hEvent);
		}

		return bRet;
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetPropertyValue | This function gets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plValue | Pointer to a LONG to receive the current value.
 *
 *  @parm PULONG | pulFlags | Pointer to a ULONG to receive the current
 *    flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm PULONG | pulCapabilities | Pointer to a ULONG to receive the
 *    capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities)
{
	FX_ENTRY("CWDMDriver::GetPropertyValue");

	ULONG cbReturned;        

	// Inititalize video property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;
	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S));

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
	VideoProperty.Flags          = 0;

	// Get property value from driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: This property is not supported by this minidriver/device\r\n", _fx_));
		return FALSE;
	}

	*plValue         = VideoProperty.Value;
	*pulFlags        = VideoProperty.Flags;
	*pulCapabilities = VideoProperty.Capabilities;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetDefaultValue | This function gets the
 *    default value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plDefValue | Pointer to a LONG to receive the default value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue)    
{
	FX_ENTRY("CWDMDriver::GetDefaultValue");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;

	// Get the default values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	// Sanity check
	if (proList.proDesc.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION))
		return FALSE;
	else
	{
		*plDefValue = proList.ulData;
		return TRUE;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetRangeValues | This function gets the
 *    range values of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plMin | Pointer to a LONG to receive the minimum value.
 *
 *  @parm PLONG | plMax | Pointer to a LONG to receive the maximum value.
 *
 *  @parm PLONG | plStep | Pointer to a LONG to receive the step value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep)
{
	FX_ENTRY("CWDMDriver::GetRangeValues");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;

	// Get range values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	*plMin  = proList.proData.Bounds.SignedMinimum;
	*plMax  = proList.proData.Bounds.SignedMaximum;
	*plStep = proList.proData.SteppingDelta;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | SetPropertyValue | This function sets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm LONG | lValue | New value.
 *
 *  @parm ULONG | ulFlags | New flags. We only care about KSPROPERTY_*_FLAGS_MANUAL
 *    or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm ULONG | ulCapabilities | New capabilities. We only care about 
 *    KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities)
{
	FX_ENTRY("CWDMDriver::SetPropertyValue");

	ULONG cbReturned;        

	// Initialize property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;

	VideoProperty.Flags        = ulFlags;
	VideoProperty.Value        = lValue;
	VideoProperty.Capabilities = ulCapabilities;

	// Set the property value on the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *set* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\32nt\wdmdialg.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.cpp | Source file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"

// Globals
extern HINSTANCE g_hInst;

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CWDMDialog | Create | This function creates a new
 *    page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CWDMDialog::Create()
{
    PROPSHEETPAGE psp;

    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = g_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(m_DlgID);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc BOOL | CWDMDialog | BaseDlgProc | This function implements
 *    the dialog box procedure for the page of a property sheet.
 *
 *  @parm HWND | hDlg | Handle to dialog box.
 *
 *  @parm UINT | uMessage | Message sent to the dialog box.
 *
 *  @parm WPARAM | wParam | First message parameter.
 *
 *  @parm LPARAM | lParam | Second message parameter.
 *
 *  @rdesc Except in response to the WM_INITDIALOG message, the dialog box
 *    procedure returns nonzero if it processes the message, and zero if it
 *    does not.
 ***************************************************************************/
INT_PTR CALLBACK CWDMDialog::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CWDMDialog * pSV = (CWDMDialog*)GetWindowLongPtr(hDlg,DWLP_USER);

	FX_ENTRY("CWDMDialog::BaseDlgProc");

    switch (uMessage)
    {
        case WM_HELP:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("conf.hlp"), HELP_WM_HELP, (DWORD_PTR)pSV->m_pdwHelp);
			break;

        case WM_CONTEXTMENU:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)wParam, TEXT("conf.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)pSV->m_pdwHelp);
			break;

        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
				pSV=(CWDMDialog*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)pSV);
				pSV->m_bInit = FALSE;
				pSV->m_bChanged = FALSE;
				return TRUE;
			}
			break;

        case WM_COMMAND:
            if (pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam), HIWORD(wParam));
                if (!iRet && pSV->m_bInit)
				{
					PropSheet_Changed(GetParent(pSV->m_hDlg), pSV->m_hDlg);
					pSV->m_bChanged = TRUE;
				}
                return iRet;
            }
			break;

        case WM_HSCROLL:
			if (pSV && pSV->m_pCWDMPin && pSV->m_pPC)
			{
				HWND hwndControl = (HWND) lParam;
				HWND hwndSlider;
				ULONG i;
				TCHAR szTemp[32];

				for (i = 0 ; i < pSV->m_dwNumControls ; i++)
				{
					hwndSlider = GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider);

					// find matching slider
					if (hwndSlider == hwndControl)
					{
						LONG lValue = (LONG)SendMessage(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider), TBM_GETPOS, 0, 0);
						pSV->m_pCWDMPin->SetPropertyValue(pSV->m_guidPropertySet, pSV->m_pPC[i].uiProperty, lValue, KSPROPERTY_FLAGS_MANUAL, pSV->m_pPC[i].ulCapabilities);
						pSV->m_pPC[i].lCurrentValue = lValue;
						wsprintf(szTemp,"%d", lValue);
						SetWindowText(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiCurrent), szTemp);
						break;
					}
				}
			}

			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->SetActive();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						// Since we apply the changes on the fly when the user moves the slide bars,
						// there isn't much left to do on PSN_APPLY...
						if (pSV->m_bChanged)
							pSV->m_bChanged = FALSE;
						return FALSE;
						break;

					case PSN_QUERYCANCEL:
						return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc void | CWDMDialog | CWDMDialog | Property page class constructor.
 *
 *  @parm int | DlgId | Resource ID of the property page dialog.
 *
 *  @parm DWORD | dwNumControls | Number of controls to display in the page.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are showing in
 *    the property page.
 *
 *  @parm PPROPSLIDECONTROL | pPC | Pointer to the list of slider controls
 *    to be displayed in the property page.
 *
 *  @parm PDWORD | pdwHelp | Pointer to the list of help IDs to be displayed
 *    in the property page.
 *
 *  @parm CWDMPin * | pCWDMPin | Pointer to the kernel streaming object
 *    we will query the property on.
 ***************************************************************************/
CWDMDialog::CWDMDialog(int DlgId, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, PDWORD pdwHelp, CWDMPin *pCWDMPin)
{
	FX_ENTRY("CWDMDialog::CWDMDialog");

	ASSERT(dwNumControls);
	ASSERT(pPC);

	m_DlgID = DlgId;
	m_pdwHelp = pdwHelp;
	m_pCWDMPin = pCWDMPin;
	m_dwNumControls = dwNumControls;
	m_guidPropertySet = guidPropertySet;
	m_pPC = pPC;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | SetActive | This function handles
 *    PSN_SETACTIVE by intializing all the property page controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::SetActive()
{
	FX_ENTRY("CWDMDialog::SetActive");

    DEBUGMSG(ZONE_DIALOGS, ("%s()\n", _fx_));

    if (!m_pCWDMPin || !m_pPC)
        return 0;

    // Returns zero to accept the activation or
    // -1 to activate the next or previous page
    // (depending on whether the user chose the Next or Back button)
    LONG i;
    EnableWindow(m_hDlg, TRUE);

    if (m_bInit)
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplay[256];

    for (i = j = 0 ; i < (LONG)m_dwNumControls; i++)
	{
        // Get the current value
        if (m_pCWDMPin->GetPropertyValue(m_guidPropertySet, m_pPC[i].uiProperty, &lValue, &ulFlags, &ulCapabilities))
		{
            LoadString(g_hInst, m_pPC[i].uiString, szDisplay, sizeof(szDisplay));
            DEBUGMSG(ZONE_DIALOGS, ("%s: szDisplay = %s\n", _fx_, szDisplay));
            SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), szDisplay);

            // Get the Range of Values possible.
            if (m_pCWDMPin->GetRangeValues(m_guidPropertySet, m_pPC[i].uiProperty, &lMin, &lMax, &lStep))
			{
				HWND hTB = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

				DEBUGMSG(ZONE_DIALOGS, ("(%d, %d) / %d = %d \n", lMin, lMax, lStep, (lMax-lMin)/lStep));

				SendMessage(hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0);
				SendMessage(hTB, TBM_SETRANGE, 0, MAKELONG(lMin, lMax));
			}
            else
			{
                ERRORMESSAGE(("%s:Cannot get range values for this property ID = %d\n", _fx_, m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), TRUE);

			SendMessage(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TBM_SETPOS, TRUE, lValue);
			wsprintf(szDisplay,"%d", lValue);
			SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szDisplay);

            DEBUGMSG(ZONE_DIALOGS, ("%s: Capability = 0x%08lX; Flags=0x%08lX; lValue=%d\r\n", _fx_, ulCapabilities, ulFlags, lValue));
            DEBUGMSG(ZONE_DIALOGS, ("%s: switch(%d): \n", _fx_, ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO))
			{
				case KSPROPERTY_FLAGS_MANUAL:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto
					break;

				case KSPROPERTY_FLAGS_AUTO:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider;
					// always auto!
					SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;

				case (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO):
					// Set flags
					if (ulFlags & KSPROPERTY_FLAGS_AUTO)
					{
						DEBUGMSG(ZONE_DIALOGS, ("%s: Auto (checked) and slider disabled\n", _fx_));
						// Set auto check box; greyed out slider
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
					}
					else
					{
						// Unchecked auto; enable slider
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
					}
					break;

				case 0:
				default:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;
            }

            j++;

        }
		else
		{
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);
        }
    }

    // Disable the "default" push button;
    // or inform user that no control is enabled.
    if (j == 0)
        EnableWindow(GetDlgItem(m_hDlg, IDC_DEFAULT), FALSE);

    return 0;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | DoCommand | This function handles WM_COMMAND. This
 *    is where a click on the Default button or one of the Auto checkboxes
 *    is handled
 *
 *  @parm WORD | wCmdID | Command ID.
 *
 *  @parm WORD | hHow | Notification code.
 *
 *  @rdesc Always returns 1.
 ***************************************************************************/
int CWDMDialog::DoCommand(WORD wCmdID, WORD hHow)
{
    // If a user select default settings of the video format
    if (wCmdID == IDC_DEFAULT)
	{
        if (m_pCWDMPin && m_pPC)
		{
            HWND hwndSlider;
            LONG  lDefValue;
			TCHAR szTemp[32];

            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                hwndSlider = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider))
				{
                    if (m_pCWDMPin->GetDefaultValue(m_guidPropertySet, m_pPC[i].uiProperty, &lDefValue))
					{
                        if (lDefValue != m_pPC[i].lCurrentValue)
						{
                            m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
							SendMessage(hwndSlider, TBM_SETPOS, TRUE, lDefValue);
							wsprintf(szTemp,"%d", lDefValue);
							SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szTemp);
							m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 1;
    }
	else if (hHow == BN_CLICKED)
	{
        if (m_pCWDMPin && m_pPC)
		{
            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID)
				{
                    if (BST_CHECKED == SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_GETCHECK, 1, 0))
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                    }
					else
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                    }
                    break;
                }
            }
        }
    }

    return 1;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | QueryCancel | This function handles
 *    PSN_QUERYCANCEL by resetting the values of the controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::QueryCancel()
{
    if (m_pCWDMPin && m_pPC)
	{
        for (ULONG i = 0 ; i < m_dwNumControls ; i++)
		{
            if (IsWindowEnabled(GetDlgItem(m_hDlg, m_pPC[i].uiSlider)))
			{
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue)
                    m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete...
// #define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
// #define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD_PTR dwCallback;
       DWORD_PTR dwCallbackInst;
       DWORD  dwFlags;
       DWORD_PTR hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dcap32.rc
//
#define IDD_CAMERA_CONTROL              100
#define IDD_VIDEO_SETTINGS              101
#define IDC_DEFAULT                     102
#define IDC_DEVICE_SETTINGS             103
#define IDC_CAMERA_CONTROLS             104
#define IDC_BRIGHTNESS                  110
#define IDC_CONTRAST                    111
#define IDC_HUE                         112
#define IDC_SATURATION                  113
#define IDC_SHARPNESS                   114
#define IDC_WHITE                       115
#define IDC_PAN                         116
#define IDC_TILT                        117
#define IDC_ROLL                        118
#define IDC_HUE_STATIC                  120
#define IDC_BRIGHTNESS_STATIC           121
#define IDC_CONTRAST_STATIC             122
#define IDC_SATURATION_STATIC           123
#define IDC_SHARPNESS_STATIC            124
#define IDC_WHITE_STATIC                125
#define IDC_GAMMA_STATIC                126
#define IDC_BACKLIGHT_STATIC            127
#define IDC_ZOOM_STATIC                 128
#define IDC_FOCUS_STATIC                129
#define IDC_TILT_STATIC                 130
#define IDC_EXPOSURE_STATIC             131
#define IDC_IRIS_STATIC                 132
#define IDC_PAN_STATIC                  133
#define IDC_ROLL_STATIC                 134
#define IDC_SLIDER_WHITEBAL             140
#define IDC_SLIDER_BRIGHTNESS           141
#define IDC_SLIDER_CONTRAST             142
#define IDC_SLIDER_HUE                  143
#define IDC_SLIDER_SATURATION           144
#define IDC_SLIDER_SHARPNESS            145
#define IDC_SLIDER_FOCUS                146
#define IDC_SLIDER_GAMMA                147
#define IDC_SLIDER_BACKLIGHT            148
#define IDC_SLIDER_ZOOM                 149
#define IDC_SLIDER_TILT                 150
#define IDC_SLIDER_EXPOSURE             151
#define IDC_SLIDER_IRIS                 152
#define IDC_SLIDER_PAN                  153
#define IDC_SLIDER_ROLL                 154
#define IDC_TXT_HUE_CURRENT             160
#define IDC_TXT_BRIGHTNESS_CURRENT      161
#define IDC_TXT_CONTRAST_CURRENT        162
#define IDC_TXT_SATURATION_CURRENT      163
#define IDC_TXT_SHARPNESS_CURRENT       164
#define IDC_TXT_ZOOM_CURRENT            165
#define IDC_TXT_WHITE_CURRENT           166
#define IDC_TXT_FOCUS_CURRENT           167
#define IDC_TXT_GAMMA_CURRENT           168
#define IDC_TXT_BACKLIGHT_CURRENT       169
#define IDC_TXT_TILT_CURRENT            170
#define IDC_TXT_EXPOSURE_CURRENT        171
#define IDC_TXT_IRIS_CURRENT            172
#define IDC_TXT_PAN_CURRENT             173
#define IDC_TXT_ROLL_CURRENT            174
#define IDC_CB_AUTO_BRIGHTNESS          180
#define IDC_CB_AUTO_CONTRAST            181
#define IDC_CB_AUTO_HUE                 182
#define IDC_CB_AUTO_SATURATION          183
#define IDC_CB_AUTO_SHARPNESS           184
#define IDC_CB_AUTO_WHITEBAL            185
#define IDC_CB_AUTO_GAMMA               186
#define IDC_CB_AUTO_BACKLIGHT           187
#define IDC_CB_AUTO_ZOOM                188
#define IDC_CB_AUTO_FOCUS               189
#define IDC_CB_AUTO_TILT                190
#define IDC_CB_AUTO_EXPOSURE            191
#define IDC_CB_AUTO_IRIS                192
#define IDC_CB_AUTO_PAN                 193
#define IDC_CB_AUTO_ROLL                194
#define IDS_ZOOM                        200
#define IDS_FOCUS                       201
#define IDS_TILT                        202
#define IDS_EXPOSURE                    203
#define IDS_IRIS                        204
#define IDS_PAN                         205
#define IDS_ROLL                        206
#define IDS_BRIGHTNESS                  207
#define IDS_CONTRAST                    208
#define IDS_HUE                         209
#define IDS_SATURATION                  210
#define IDS_SHARPNESS                   211
#define IDS_WHITEBAL                    212
#define IDS_GAMMA                       213
#define IDS_BACKLIGHT                   214
#define IDS_UNKNOWN_DEVICE_NAME         215
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1089
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\wdmcap.h ===
// WDM video capture

// Constants
// PhilF-: Ultimately, after wdm.h has been fixed to work on both
// Win98 and NT5, get the following value from wdm.h instead.
#define FILE_DEVICE_KS                  0x0000002f

// Functions
BOOL	WDMGetDevices(void);
BOOL	WDMOpenDevice(DWORD dwDeviceID);
DWORD	WDMGetVideoFormatSize(DWORD dwDeviceID);
BOOL	WDMGetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih);
BOOL	WDMSetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih);
BOOL	WDMGetVideoPalette(DWORD dwDeviceID, CAPTUREPALETTE* lpcp, DWORD dwcbSize);
BOOL	WDMCloseDevice(DWORD dwDeviceID);
BOOL	WDMUnInitializeVideoStream(DWORD dwDeviceID);
BOOL	WDMInitializeVideoStream(HCAPDEV hcd, DWORD dwDeviceID, DWORD dwMicroSecPerFrame);
BOOL	WDMVideoStreamReset(DWORD dwDeviceID);
BOOL	WDMVideoStreamAddBuffer(DWORD dwDeviceID, PVOID pBuff);
BOOL	WDMVideoStreamStart(DWORD dwDeviceID);
BOOL	WDMVideoStreamStop(DWORD dwDeviceID);
BOOL	WDMGetFrame(DWORD dwDeviceID, PVOID pBuff);
BOOL	WDMShowSettingsDialog(DWORD dwDeviceID, HWND hWndParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\wdmdialg.h ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.h | Include file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _DIALOGS_H // { _DIALOGS_H
#define _DIALOGS_H

// Constants used to check if the property has an automatic mode or/and a manual mode
#define KSPROPERTY_FLAGS_MANUAL KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL
#define KSPROPERTY_FLAGS_AUTO KSPROPERTY_CAMERACONTROL_FLAGS_AUTO

#if (KSPROPERTY_FLAGS_AUTO != KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) || (KSPROPERTY_FLAGS_MANUAL != KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL)
#error Why did you mess with the kernel streaming include files? - PhilF-
#endif

typedef struct _tagPROPSLIDECONTROL
{
    LONG lLastValue;
    LONG lCurrentValue;
    LONG lMin;
    LONG lMax;
    ULONG ulCapabilities;

    // Dialog item IDs
    UINT uiProperty;
    UINT uiSlider;
    UINT uiString;
    UINT uiStatic;
    UINT uiCurrent;
    UINT uiAuto;
} PROPSLIDECONTROL, * PPROPSLIDECONTROL;

// Video settings (brightness tint hue etc.)
static PROPSLIDECONTROL g_VideoSettingControls[] = 
{    
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,   IDC_SLIDER_BRIGHTNESS, IDS_BRIGHTNESS, IDC_BRIGHTNESS_STATIC, IDC_TXT_BRIGHTNESS_CURRENT, IDC_CB_AUTO_BRIGHTNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_CONTRAST,     IDC_SLIDER_CONTRAST,   IDS_CONTRAST,   IDC_CONTRAST_STATIC,   IDC_TXT_CONTRAST_CURRENT,   IDC_CB_AUTO_CONTRAST},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_HUE,          IDC_SLIDER_HUE,        IDS_HUE,        IDC_HUE_STATIC,        IDC_TXT_HUE_CURRENT,        IDC_CB_AUTO_HUE},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SATURATION,   IDC_SLIDER_SATURATION, IDS_SATURATION, IDC_SATURATION_STATIC, IDC_TXT_SATURATION_CURRENT, IDC_CB_AUTO_SATURATION},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SHARPNESS,    IDC_SLIDER_SHARPNESS,  IDS_SHARPNESS,  IDC_SHARPNESS_STATIC,  IDC_TXT_SHARPNESS_CURRENT,  IDC_CB_AUTO_SHARPNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE, IDC_SLIDER_WHITEBAL,   IDS_WHITEBAL,   IDC_WHITE_STATIC,      IDC_TXT_WHITE_CURRENT,      IDC_CB_AUTO_WHITEBAL},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_GAMMA,        IDC_SLIDER_GAMMA,      IDS_GAMMA,      IDC_GAMMA_STATIC,      IDC_TXT_GAMMA_CURRENT,      IDC_CB_AUTO_GAMMA},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,    IDC_SLIDER_BACKLIGHT,  IDS_BACKLIGHT,  IDC_BACKLIGHT_STATIC,      IDC_TXT_BACKLIGHT_CURRENT,  IDC_CB_AUTO_BACKLIGHT}
};

const ULONG NumVideoSettings = sizeof(g_VideoSettingControls) / sizeof(PROPSLIDECONTROL);

// PhilF-: Assign a bug to Debbie to get this used
static DWORD g_VideoSettingsHelpIDs[] =
{
	IDC_DEVICE_SETTINGS,					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_BRIGHTNESS,					IDH_DEVICE_SETTINGS,
	IDC_BRIGHTNESS_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_BRIGHTNESS_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_BRIGHTNESS, 				IDH_DEVICE_SETTINGS,

	IDC_SLIDER_CONTRAST,					IDH_DEVICE_SETTINGS,
	IDC_CONTRAST_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_CONTRAST_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_CONTRAST, 					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_HUE,							IDH_DEVICE_SETTINGS,
	IDC_HUE_STATIC,							IDH_DEVICE_SETTINGS,
	IDC_TXT_HUE_CURRENT,					IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_HUE, 						IDH_DEVICE_SETTINGS,

	IDC_SLIDER_SATURATION,					IDH_DEVICE_SETTINGS,
	IDC_SATURATION_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_SATURATION_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_SATURATION, 				IDH_DEVICE_SETTINGS,

	IDC_SLIDER_SHARPNESS,					IDH_DEVICE_SETTINGS,
	IDC_SHARPNESS_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_SHARPNESS_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_SHARPNESS, 					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_WHITEBAL,					IDH_DEVICE_SETTINGS,
	IDC_WHITE_STATIC,						IDH_DEVICE_SETTINGS,
	IDC_TXT_WHITE_CURRENT,					IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_WHITEBAL, 					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_GAMMA,						IDH_DEVICE_SETTINGS,
	IDC_GAMMA_STATIC,						IDH_DEVICE_SETTINGS,
	IDC_TXT_GAMMA_CURRENT,					IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_GAMMA, 						IDH_DEVICE_SETTINGS,
	
	IDC_SLIDER_BACKLIGHT,					IDH_DEVICE_SETTINGS,
	IDC_BACKLIGHT_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_BACKLIGHT_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_BACKLIGHT, 					IDH_DEVICE_SETTINGS,

	IDC_DEFAULT,							IDH_DEVICE_SETTINGS,

	0, 0   // terminator
};

// Camera control (focus, zoom etc.)
static PROPSLIDECONTROL g_CameraControls[] = 
{    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_FOCUS,   IDC_SLIDER_FOCUS,   IDS_FOCUS,    IDC_FOCUS_STATIC,   IDC_TXT_FOCUS_CURRENT,    IDC_CB_AUTO_FOCUS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ZOOM,    IDC_SLIDER_ZOOM,    IDS_ZOOM,     IDC_ZOOM_STATIC,    IDC_TXT_ZOOM_CURRENT,     IDC_CB_AUTO_ZOOM},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_EXPOSURE,IDC_SLIDER_EXPOSURE,IDS_EXPOSURE, IDC_EXPOSURE_STATIC,IDC_TXT_EXPOSURE_CURRENT, IDC_CB_AUTO_EXPOSURE},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_IRIS,    IDC_SLIDER_IRIS,    IDS_IRIS,     IDC_IRIS_STATIC,    IDC_TXT_IRIS_CURRENT,     IDC_CB_AUTO_IRIS},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_TILT,    IDC_SLIDER_TILT,    IDS_TILT,     IDC_TILT_STATIC,    IDC_TXT_TILT_CURRENT,     IDC_CB_AUTO_TILT},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_PAN,     IDC_SLIDER_PAN,     IDS_PAN,      IDC_PAN_STATIC,     IDC_TXT_PAN_CURRENT,      IDC_CB_AUTO_PAN},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ROLL,    IDC_SLIDER_ROLL,    IDS_ROLL,     IDC_ROLL_STATIC,    IDC_TXT_ROLL_CURRENT,     IDC_CB_AUTO_ROLL},    
};

const ULONG NumCameraControls = sizeof(g_CameraControls) / sizeof(PROPSLIDECONTROL);

static DWORD g_CameraControlsHelpIDs[] =
{
	IDC_CAMERA_CONTROLS,		IDH_CAMERA_CONTROLS,

	IDC_SLIDER_FOCUS,			IDH_CAMERA_CONTROLS,
	IDC_FOCUS_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_FOCUS_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_FOCUS, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_ZOOM,			IDH_CAMERA_CONTROLS,
	IDC_ZOOM_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_ZOOM_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_ZOOM, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_EXPOSURE,		IDH_CAMERA_CONTROLS,
	IDC_EXPOSURE_STATIC,		IDH_CAMERA_CONTROLS,
	IDC_TXT_EXPOSURE_CURRENT,	IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_EXPOSURE, 		IDH_CAMERA_CONTROLS,

	IDC_SLIDER_IRIS,			IDH_CAMERA_CONTROLS,
	IDC_IRIS_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_IRIS_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_IRIS, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_TILT,			IDH_CAMERA_CONTROLS,
	IDC_TILT_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_TILT_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_TILT, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_PAN,				IDH_CAMERA_CONTROLS,
	IDC_PAN_STATIC,				IDH_CAMERA_CONTROLS,
	IDC_TXT_PAN_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_PAN, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_ROLL,			IDH_CAMERA_CONTROLS,
	IDC_ROLL_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_ROLL_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_ROLL, 			IDH_CAMERA_CONTROLS,

	IDC_DEFAULT,				IDH_CAMERA_CONTROLS,

	0, 0   // terminator
};

// For now, we only expose a video settings and camera control page
#define MAX_PAGES 2

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGCLASS
 *
 *  @class CWDMDialog | This class provides support for property
 *    pages to be displayed within a property sheet.
 *
 *  @mdata BOOL | CWDMDialog | m_bInit | This member is set to TRUE after the
 *    page has been initialized.
 *
 *  @mdata BOOL | CWDMDialog | m_bChanged | This member is set to TRUE after the
 *    page has been changed.
 *
 *  @mdata int | CWDMDialog | m_DlgID | Resource ID of the property page dialog.
 *
 *  @mdata HWND | CWDMDialog | m_hDlg | Window handle of the property page.
 *
 *  @mdata PDWORD | CWDMDialog | m_pdwHelp | Pointer to the list of help IDs
 *    to be displayed in the property page.
 *
 *  @mdata CWDMPin * | CWDMDialog | m_pCWDMPin | Pointer to the kernel
 *    streaming object we will query the property on.
 *
 *  @mdata PPROPSLIDECONTROL | CWDMDialog | m_pPC | Pointer to the list of
 *    slider controls to be displayed in the property page.
 *
 *  @mdata DWORD | CWDMDialog | m_dwNumControls | Number of controls to\
 *    display in the page.
 *
 *  @mdata GUID | CWDMDialog | m_guidPropertySet | GUID of the KS property
 *    we are showing in the property page.
 ***************************************************************************/
class CWDMDialog
{
public:
    CWDMDialog(int DlgID, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, PDWORD pdwHelp, CWDMPin *pCWDMPin=0);
    ~CWDMDialog() {};

	HPROPSHEETPAGE	Create();

private:
	BOOL				m_bInit;
	BOOL				m_bChanged;
	int					m_DlgID;
	HWND				m_hDlg;
	PDWORD				m_pdwHelp;
	CWDMPin				*m_pCWDMPin;
	PPROPSLIDECONTROL	m_pPC;
	DWORD				m_dwNumControls;
	GUID				m_guidPropertySet;

	// Dialog proc helper functions
	int		SetActive();
	int		QueryCancel();
	int		DoCommand(WORD wCmdID,WORD hHow);

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#endif // } _DIALOGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\wdmdrivr.h ===
/****************************************************************************
 *  @doc INTERNAL WDMDRIVER
 *
 *  @module WDMDrivr.h | Include file for <c CWDMDriver> class used to
 *    access the streaming class driver using IOctls.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _WDMDRVR_H // { _WDMDRVR_H
#define _WDMDRVR_H

// Used to query and set video data ranges of a device
typedef struct _tagDataRanges {
    ULONG   Size;
    ULONG   Count;
    KS_DATARANGE_VIDEO Data;
} DATA_RANGES, * PDATA_RANGES;

// Used to query/set video property values and ranges
typedef struct {
    KSPROPERTY_DESCRIPTION      proDesc;
    KSPROPERTY_MEMBERSHEADER  proHdr;
    union {
        KSPROPERTY_STEPPING_LONG  proData;
        ULONG ulData;
    };
} PROCAMP_MEMBERSLIST;

/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERCLASS
 *
 *  @class CWDMDriver | This class provides access to the streaming class
 *    driver, through which we acess the video capture mini-driver properties
 *    using IOCtls.
 *
 *  @mdata DWORD | CWDMDriver | m_dwDeviceID | Capture device ID.
 *
 *  @mdata HANDLE | CWDMDriver | m_hDriver | This member holds the driver
 *    file handle.
 *
 *  @mdata PDATA_RANGES | CWDMDriver | m_pDataRanges | This member points
 *    to the video data range structure.
 ***************************************************************************/
class CWDMDriver
{
public:
    CWDMDriver(DWORD dwDeviceID);
    ~CWDMDriver();

    // Property functions
    BOOL GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities);
    BOOL GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue);
    BOOL GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep);
    BOOL SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities);

	// Device functions
	BOOL	OpenDriver();
	BOOL	CloseDriver();
	HANDLE	GetDriverHandle() { return m_hDriver; }

    // Data range functions
    PDATA_RANGES	GetDriverSupportedDataRanges() { return m_pDataRanges; };

	// Device IO function
    BOOL DeviceIoControl(HANDLE h, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped=TRUE);

private:
	DWORD			m_dwDeviceID;	// Capture device ID
	HANDLE			m_hDriver;		// Driver file handle
	PDATA_RANGES	m_pDataRanges;	// Pin data ranges

    // Data range functions
	ULONG			CreateDriverSupportedDataRanges();
};

#endif // } _WDMDRVR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\idcap.h ===
//  IDCAP.H
//
//  Created 31-Jul-96 [JonT]

#ifndef _IDCAP_H
#define _IDCAP_H

// Set a define saying we're building QKCAP so that
// we use the proper DLL import switches
#define __DCAP_BUILD__

// Debug stuff
#if defined (DEBUG) || defined (_DEBUG)
#define Assert(x, msg) { if (!(x)) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); DebugBreak(); } }
#define DebugSpew(msg) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); }
#else
#define Assert(x, msg)
#define DebugSpew(msg)
#endif


// Equates
#define DCAP_MAX_DEVICES      10        // Arbitrary
#define DCAP_MAX_VFW_DEVICES  10        // MSVIDEO's limit

// INTERNALCAPDEV flags
#define HCAPDEV_STREAMING               0x0001
#define HCAPDEV_STREAMING_INITIALIZED   0x0002
#define HCAPDEV_STREAMING_FRAME_GRAB    0x0004
#define HCAPDEV_STREAMING_FRAME_TIME    0x0008
#define HCAPDEV_STREAMING_PAUSED        0x0010
#define HCAPDEV_IN_DRIVER_DIALOG        0x0020
#define CAPTURE_DEVICE_DISABLED         0x0040
#define CAPTURE_DEVICE_OPEN             0x0080
#define WDM_CAPTURE_DEVICE              0x0100

// LOCKEDINFO flags
#define LIF_STOPSTREAM       0x0001

// Structures

// CAPTUREDEVICE flags
#define MAX_VERSION						80

#ifdef WIN32
typedef struct tagVS_VERSION
{
	WORD wTotLen;
	WORD wValLen;
	TCHAR szSig[16];
	VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;
#endif

#ifdef __NT_BUILD__
#define LPCAPBUFFER16   DWORD
#define LPCAPBUFFER32   LPCAPBUFFER
#endif //__NT_BUILD__

typedef struct _CAPBUFFERHDR FAR* LPCAPBUFFER;

// We will deal with CAPBUFFER pointers as always 16:16 pointers. So, we
// use this #define to make sure that we don't accidentally indirect them on
// the 32-bit side. We need to always MapSL them on the 32-bit side before
// using.

#ifndef WIN32
#define LPCAPBUFFER16   LPCAPBUFFER
#define LPCAPBUFFER32   DWORD
#else
#define LPCAPBUFFER16   DWORD
#define LPCAPBUFFER32   LPCAPBUFFER
#endif


typedef struct _CAPBUFFERHDR
{
    VIDEOHDR vh;
    LPCAPBUFFER32 lpNext;     // Double linked list pointers for ready queue
    LPCAPBUFFER32 lpPrev;
#ifndef __NT_BUILD__
    LPCAPBUFFER16 lp1616Next;       // Double linked list pointers for ready queue
    LPCAPBUFFER16 lp1616Prev;
#endif
} CAPBUFFERHDR, FAR* LPCAPBUFFER;


#ifndef __NT_BUILD__
typedef struct _LOCKEDINFO
{
    LPCAPBUFFER16 lp1616Head;       // Queue of ready items
    LPCAPBUFFER16 lp1616Tail;
    LPCAPBUFFER16 lp1616Current;    // Item being used by 32-bit side
    DWORD pevWait;
    DWORD dwFlags;
} LOCKEDINFO, FAR* LPLOCKEDINFO;
#endif


#ifdef WIN32
typedef struct _INTERNALCAPDEV
{
    DWORD dwFlags;
#ifndef __NT_BUILD__
    LOCKEDINFO* lpli;
    WORD wselLockedInfo;
    WORD wPad;
#endif
    int nDeviceIndex;
    HVIDEO hvideoIn;
    HVIDEO hvideoCapture;
    HVIDEO hvideoOverlay;
    LPCAPBUFFER32 lpcbufList;  // List of all allocated buffers so we can free them
    DWORD dwcbBuffers;
    DWORD dw_usecperframe;
    UINT timerID;
    HANDLE hevWait;
    LONG busyCount;
    LPCAPBUFFER32 lpHead;
    LPCAPBUFFER32 lpTail;
    LPCAPBUFFER32 lpCurrent;
    CRITICAL_SECTION bufferlistCS;
    DWORD dwDevNode;
    char szDeviceName[MAX_PATH];
    char szDeviceDescription[MAX_PATH];
    char szDeviceVersion[MAX_VERSION];
	PVOID pCWDMPin;
	PVOID pCWDMStreamer;
} INTERNALCAPDEV, *HCAPDEV, *LPINTERNALCAPDEV;

#define HFRAMEBUF LPCAPBUFFER

#define INTERNAL_MAGIC 0x50414344

#define VALIDATE_CAPDEV(h) if (!h || !(h->dwFlags & CAPTURE_DEVICE_OPEN)) { \
    SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }

#include <dcap.h>

// Globals
    extern int g_cDevices;
    extern LPINTERNALCAPDEV g_aCapDevices[DCAP_MAX_DEVICES];

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef __NT_BUILD__
#define _OpenDriver OpenDriver
#define _CloseDriver CloseDriver
#define _SendDriverMessage SendDriverMessage
#else
HANDLE __stdcall    _OpenDriver(LPCSTR lpDriverName, LPSTR lpSectionName, LONG lpvop);
DWORD __stdcall     _CloseDriver(HANDLE h, LPVOID lpReserved1, LPVOID lpReserved2);
DWORD __stdcall     _SendDriverMessage(HANDLE h, DWORD msg, DWORD param1, DWORD param2);
void __stdcall      _CloseVxDHandle(DWORD pev);
WORD __stdcall      _AllocateLockableBuffer(DWORD dwSize);
void __stdcall      _FreeLockableBuffer(WORD wBuffer);
BOOL __stdcall      _LockBuffer(WORD wBuffer);
void __stdcall      _UnlockBuffer(WORD wBuffer);
#endif

BOOL __stdcall      _GetVideoPalette(HVIDEO hvideo, CAPTUREPALETTE* lpcp, DWORD dwcbSize);
DWORD _stdcall      _GetVideoFormatSize(HDRVR hvideo);
BOOL __stdcall      _GetVideoFormat(HVIDEO hvideo, LPBITMAPINFOHEADER lpbmih);
BOOL __stdcall      _SetVideoFormat(HVIDEO hvideoExtIn, HVIDEO hvideoIn, LPBITMAPINFOHEADER lpbmih);
BOOL __stdcall      _InitializeVideoStream(HVIDEO hvideo, DWORD dwMicroSecPerFrame, DWORD_PTR dwParam);
BOOL __stdcall      _UninitializeVideoStream(HVIDEO hvideo);
BOOL __stdcall      _InitializeExternalVideoStream(HVIDEO hvideo);
DWORD __stdcall     _GetVideoFrame(HVIDEO hvideo, DWORD lpvideohdr);
#endif //Win32

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif  // #ifndef _IDCAP_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\wdmpin.h ===
/****************************************************************************
 *  @doc INTERNAL WDMPIN
 *
 *  @module WDMPin.h | Include file for <c CWDMPin> class used to access
 *    video data on a video streaming pin exposed by the WDM class driver.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _WDMPIN_H // { _WDMPIN_H
#define _WDMPIN_H

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct DATAPINCONNECT | The <t DATAPINCONNECT> structure is used to
 *   connect to a streaming video pin.
 *
 * @field KSPIN_CONNECT | Connect | Describes how the connection is to be
 *   done.
 *
 * @field KS_DATAFORMAT_VIDEOINFOHEADER | Data | Describes the video format
 *   of the video data streaming from a video pin.
 ***************************************************************************/
// Structure used to connect to a streaming video pin
typedef struct _tagStreamConnect
{
	KSPIN_CONNECT					Connect;
	KS_DATAFORMAT_VIDEOINFOHEADER	Data; 
} DATAPINCONNECT, *PDATAPINCONNECT;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct KS_HEADER_AND_INFO | The <t KS_HEADER_AND_INFO> structure is used
 *   stream data from a video pin.
 *
 * @field KSSTREAM_HEADER | StreamHeader | Describes how the streaming is to be
 *   done.
 *
 * @field KS_FRAME_INFO | FrameInfo | Describes the video format
 *   of the video data streaming from a video pin.
 ***************************************************************************/
// Video streaming data structure
typedef struct
{
	KSSTREAM_HEADER	StreamHeader;
	KS_FRAME_INFO	FrameInfo;
} KS_HEADER_AND_INFO;

// For GetProcAddresss on KsCreatePin
typedef DWORD (WINAPI *LPFNKSCREATEPIN)(IN HANDLE FilterHandle, IN PKSPIN_CONNECT Connect, IN ACCESS_MASK DesiredAccess, OUT PHANDLE ConnectionHandle);

// Default frame rate: 30 fps
#define DEFAULT_AVG_TIME_PER_FRAME 333330UL

/****************************************************************************
 *  @doc INTERNAL CWDMPINCLASS
 *
 *  @class CWDMPin | This class provides support for streaming video
 *    data from WDM device streaming pin.
 *
 *  @mdata BOOL | CWDMPin | m_hKS | Handle to the video streaming pin.
 *
 *  @mdata KS_BITMAPINFOHEADER | CWDMPin | m_biHdr | Video format
 *    of the video data used by the streaming pin.
 *
 *  @mdata DWORD | CWDMPin | m_dwAvgTimePerFrame | Frame rate.
 *
 *  @mdata BOOL | CWDMPin | m_fStarted | Video streaming channel
  *    status.
 ***************************************************************************/
class CWDMPin : public CWDMDriver
{
public:
	CWDMPin(DWORD dwDeviceID);
	~CWDMPin();

	// Pin and class driver management functions
    BOOL   OpenDriverAndPin();
    HANDLE GetPinHandle() const { return m_hKS; }

	// Pin video format functions
    BOOL  GetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo, WORD wSize);
    BOOL  SetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo);
	BOOL  GetPaletteInfo(CAPTUREPALETTE *pPal, DWORD dwcbSize);
    DWORD GetFrameSize() { return m_biHdr.biSizeImage; }
    DWORD GetAverageTimePerFrame() { return m_dwAvgTimePerFrame; }
    BOOL  SetAverageTimePerFrame(DWORD dwNewAvgTimePerFrame);

	// Data access functions
    BOOL GetFrame(LPVIDEOHDR lpVHdr);

	// Streaming state functions
    BOOL Start();
    BOOL Stop();

private:
    HANDLE				m_hKS;    
    KS_BITMAPINFOHEADER	m_biHdr;
    DWORD				m_dwAvgTimePerFrame;
    BOOL				m_fStarted;
	HINSTANCE			m_hKsUserDLL;
	LPFNKSCREATEPIN		m_pKsCreatePin;

	// Pin video format function
    PKS_DATARANGE_VIDEO FindMatchDataRangeVideo(PKS_BITMAPINFOHEADER pbiHdr, BOOL *pfValidMatch);

	// Pin and class driver management functions
    BOOL CreatePin(PKS_BITMAPINFOHEADER pbiNewHdr, DWORD dwAvgTimePerFrame = DEFAULT_AVG_TIME_PER_FRAME);
    BOOL DestroyPin();

	// Streaming state function
    BOOL SetState(KSSTATE ksState);
};

#endif  // } _WDMPIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\inc\wdmstrmr.h ===
/****************************************************************************
 *  @doc INTERNAL WDMSTREAMER
 *
 *  @module WDMStrmr.h | Include file for <c CWDMStreamer> class used to get a
 *    stream of video data flowing from WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _WDMSTRMR_H // { _WDMSTRMR_H
#define _WDMSTRMR_H

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct BUFSTRUCT | The <t BUFSTRUCT> structure holds the status of each
 *   video streaming buffer.
 *
 * @field LPVIDEOHDR | lpVHdr | Specifies a pointer to the video header of a
 *   video streaming buffer.
 *
 * @field BOOL | fReady | Set to TRUE if the video buffer is available for
 *   video streaming, FALSE if is locked by the application or queued for
 *   an asynchronous read.
 ***************************************************************************/
// Holds status of each video streaming buffer
typedef struct _BUFSTRUCT {
	LPVIDEOHDR lpVHdr;	// Pointer to the video header of the buffer
	BOOL fReady;		// Set to TRUE if the buffer is available for streaming, FALSE otherwise
} BUFSTRUCT, * PBUFSTRUCT;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct WDMVIDEOBUFF | The <t WDMVIDEOBUFF> structure is used to queue
 *   asynchronous read on a video streaming pin.
 *
 * @field OVERLAPPED | Overlap | Structure used for overlapping IOs.
 *
 * @field BOOL | fBlocking | Set to TRUE if read is going to block.
 *
 * @field KS_HEADER_AND_INFO | SHGetImage | Video streaming structure used
 *   on the video pin to get video data.
 *
 * @field LPVIDEOHDR | pVideoHdr | Pointer to the video header for this WDM
 *   video buffer.
 ***************************************************************************/
// Read buffer structure
typedef struct tagWDMVIDEOBUFF {
	OVERLAPPED			Overlap;		// Structure used for overlapping IOs
	BOOL				fBlocking;		// Set to TRUE if the read operation will execute asynchronously
	KS_HEADER_AND_INFO	SHGetImage;		// Video streaming structure used on the video pin
	LPVIDEOHDR			pVideoHdr;		// Pointer to the video header for this WDM buffer
} WDMVIDEOBUFF, *PWDMVIDEOBUFF;


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERCLASS
 *
 *  @class CWDMStreamer | This class provides support for streaming video
 *    data from WDM device streaming pin.
 *
 *  @mdata CWDMPin * | CWDMStreamer | m_pWDMVideoPin | Handle to the video
 *    streaming pin.
 *
 *  @mdata ULONG | CWDMStreamer | m_cntNumVidBuf | Number of video buffers
 *    used for streaming.
 *
 *  @mdata PBUFSTRUCT | CWDMStreamer | m_pBufTable | Pointer to a list of
 *    <t BUFSTRUCT> video buffers used for streaming and their status.
 *
 *  @mdata VIDEO_STREAM_INIT_PARMS | CWDMStreamer | m_CaptureStreamParms |
 *    Streaming initialization parameters.
 *
 *  @mdata LPVIDEOHDR | CWDMStreamer | m_lpVHdrFirst | Head pointer to the
 *    list of video buffers.
 *
 *  @mdata LPVIDEOHDR | CWDMStreamer | m_lpVHdrLast | Tail pointer to the
 *    list of video buffers.
 *
 *  @mdata BOOL | CWDMStreamer | m_fVideoOpen | Set to TRUE if the stream is
 *    open, FALSE otherwise.
 *
 *  @mdata BOOL | CWDMStreamer | m_fStreamingStarted | Set to TRUE if we
 *    are currently streaming video data, FALSE otherwise.
 *
 *  @mdata DWORD | CWDMStreamer | m_dwTimeStart | Timestamp of the first
 *    video buffer ever returned to the application.
 *
 *  @mdata DWORD | CWDMStreamer | m_dwNextToComplete | Index of the next
 *    overlapped read to complete.
 *
 *  @mdata WDMVIDEOBUFF | CWDMStreamer | m_pWDMVideoBuff | Pointer to a
 *    list of <t WDMVIDEOBUFF> used to read data from the video pin.
 *
 *  @mdata DWORD | CWDMStreamer | m_dwFrameCount | Number of frames returned
 *    so far to the application - DEBUG only.
 *
 *  @mdata HANDLE | CWDMStreamer | m_hThread | Handle to our streaming
 *    thread.
 *
 *  @mdata BOOL | CWDMStreamer | m_bKillThread | Set to TRUE to kill our
 *    streaming thread.
 ***************************************************************************/
class CWDMStreamer
{
public:
   CWDMStreamer(CWDMPin * pCWDMPin);
   ~CWDMStreamer() {};

	// Stream control functions
	BOOL Open(LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms);
	BOOL Close();
	BOOL Start();
	BOOL Stop();
	BOOL Reset();
	BOOL AddBuffer(LPVIDEOHDR lpVHdr);

private:
	CWDMPin					*m_pWDMVideoPin;
	ULONG					m_cntNumVidBuf;
	ULONG					m_idxNextVHdr;  // index of expected next Hdr ID
	PBUFSTRUCT				m_pBufTable;
	VIDEO_STREAM_INIT_PARMS	m_CaptureStreamParms;
	LPVIDEOHDR				m_lpVHdrFirst;
	LPVIDEOHDR				m_lpVHdrLast;
	BOOL					m_fVideoOpen;
	BOOL					m_fStreamingStarted;
	DWORD					m_dwTimeStart;
	int						m_dwNextToComplete;
	WDMVIDEOBUFF			*m_pWDMVideoBuff;
#ifdef _DEBUG
	DWORD					m_dwFrameCount;
#endif
    HANDLE					m_hThread;
    BOOL					m_bKillThread;

	// Video buffer management functions
	void BufferDone(LPVIDEOHDR lpVHdr);
	LPVIDEOHDR DeQueueHeader();
	void QueueHeader(LPVIDEOHDR lpVHdr);
	BOOL QueueRead(DWORD dwIndex);

	// User callback function
	void videoCallback(WORD msg, DWORD_PTR dw1);

	// Thread functions
    void Stream(void);
    static LPTHREAD_START_ROUTINE ThreadStub(CWDMStreamer *object);

};

#endif  // } _WDMSTRMR_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\filter\inc\ifilter.h ===
//  IFILTER.H
//
//      Contains the interfaces IVideoFilter and IAudioFilter
//
//  Created 12-Dec-96 [JonT]

#ifndef _IFILTER_H
#define _IFILTER_H

// {2B02415C-5308-11d0-B14C-00C04FC2A118}
DEFINE_GUID(IID_IVideoFilter, 0x2b02415c, 0x5308, 0x11d0, 0xb1, 0x4c, 0x0, 0xc0, 0x4f, 0xc2, 0xa1, 0x18);

typedef struct tagSURFACEINFO
{
    long lWidth;
    long lHeight;
    GUID bfid;
} SURFACEINFO;

#undef  INTERFACE
#define INTERFACE   IVideoFilter

DECLARE_INTERFACE_(IVideoFilter, IUnknown)
{
	// IUnknown method
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IVideoFilter methods
	STDMETHOD(Start)(THIS_ DWORD dwFlags, SURFACEINFO* psiIn, SURFACEINFO* psiOut) PURE;
	STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(Transform)(THIS_ IBitmapSurface* pbsIn, IBitmapSurface* pbsOut, DWORD dwTimestamp) PURE;
};

#endif // #ifndef _IFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\filter\inc\effect.h ===
#ifndef __EFFECT_H__
#define __EFFECT_H__

//{1F9DDD20-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapEffect, 
0x1f9ddd20, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapEffectDescription TEXT("Bitmap Effect")

//#define BITMAP_EFFECT_CAN_OVERLAP   1		// Not needed, only one rect provided
#define BITMAP_EFFECT_INPLACE       1		// effect is done in-place src and dst must be the same
#define BITMAP_EFFECT_REALTIME      2		// this can change based on the BFID and size ??  How do we measure 
#define BITMAP_EFFECT_DIRECTDRAW    4       // Need a dd surface

// {ACEA25C0-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapEffect, 
0xacea25c0, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#undef  INTERFACE
#define INTERFACE   IBitmapEffect

DECLARE_INTERFACE_(IBitmapEffect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapEffect methods
    STDMETHOD(SetSite)(THIS_ IUnknown* punk) PURE;
    STDMETHOD(GetMiscStatusBits)(THIS_ DWORD* pdwFlags) PURE;
    STDMETHOD(GetSupportedFormatsCount)(THIS_ unsigned* pcFormats) PURE;
    STDMETHOD(GetSupportedFormats)(THIS_ unsigned cFormats, BFID* pBFIDs) PURE;
    STDMETHOD(Begin)(THIS_ BFID* pBFID, SIZE* psizeEffect) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(DoEffect)(THIS_ IBitmapSurface* pbsIn, IBitmapSurface* pbsOut, RECT* prectFull, RECT* prectInvalid) PURE;
};

#endif //__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\filter\inc\ibitmap.h ===
//  IBITMAP.H
//
//      Contains the interfaces IBitmapSurface and IBitmapSurfaceFactory
//
//      Note that this file is probably a duplicate of one in the Trident project,
//      but I haven't located it yet...
//
//  Created 12-Dec-96 [JonT]

#ifndef _IBITMAP_H
#define _IBITMAP_H

// IIDs
// {3050f2ef-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IBitmapSurface,
0x3050f2ef, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f2f2-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IBitmapSurfaceFactory,
0x3050f2f2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// BFIDs (Bitmap format IDs)
typedef GUID BFID;

// e436eb78-524f-11ce-9f53-0020af0ba770            BFID_RGB1
DEFINE_GUID(BFID_MONOCHROME,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb79-524f-11ce-9f53-0020af0ba770            BFID_RGB4
DEFINE_GUID(BFID_RGB_4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7a-524f-11ce-9f53-0020af0ba770            BFID_RGB8
DEFINE_GUID(BFID_RGB_8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7b-524f-11ce-9f53-0020af0ba770            BFID_RGB565
DEFINE_GUID(BFID_RGB_565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7c-524f-11ce-9f53-0020af0ba770            BFID_RGB555
DEFINE_GUID(BFID_RGB_555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7d-524f-11ce-9f53-0020af0ba770            BFID_RGB24
DEFINE_GUID(BFID_RGB_24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7e-524f-11ce-9f53-0020af0ba770            BFID_RGB32
DEFINE_GUID(BFID_RGB_32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// Forward definitions
#ifndef __IBitmapSurface_FWD_DEFINED__
#define __IBitmapSurface_FWD_DEFINED__
typedef interface IBitmapSurface IBitmapSurface;
#endif 	// __IBitmapSurface_FWD_DEFINED__

#ifndef __IBitmapSurfaceFactory_FWD_DEFINED__
#define __IBitmapSurfaceFactory_FWD_DEFINED__
typedef interface IBitmapSurfaceFactory IBitmapSurfaceFactory;
#endif 	// __IBitmapSurfaceFactory_FWD_DEFINED__

// Interfaces

#undef  INTERFACE
#define INTERFACE   IBitmapSurface

DECLARE_INTERFACE_(IBitmapSurface, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapSurface methods
	STDMETHOD(Clone)(THIS_ IBitmapSurface** ppBitmapSurface) PURE;
	STDMETHOD(GetFormat)(THIS_ BFID* pBFID) PURE;
	STDMETHOD(GetFactory)(THIS_ IBitmapSurfaceFactory** ppBitmapSurfaceFactory) PURE;
	STDMETHOD(GetSize)(THIS_ long* pWidth, long* pHeight) PURE;
	STDMETHOD(LockBits)(THIS_ RECT* prcBounds, DWORD dwLockFlags, void** ppBits, long* pPitch) PURE;
	STDMETHOD(UnlockBits)(THIS_ RECT* prcBounds, void* pBits) PURE;
};

#undef  INTERFACE
#define INTERFACE   IBitmapSurfaceFactory

DECLARE_INTERFACE_(IBitmapSurfaceFactory, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapSurfaceFactory methods
    STDMETHOD(CreateBitmapSurface)(THIS_ long width, long height, BFID* pBFID, DWORD dwHintFlags, IBitmapSurface** ppBitmapSurface) PURE;
	STDMETHOD(GetSupportedFormatsCount)(THIS_ long* pcFormats) PURE;
	STDMETHOD(GetSupportedFormats)(THIS_ long cFormats, BFID* pBFIDs) PURE;
};

#endif // #ifndef _IBITMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\vxd\dcapvxd.asm ===
;  DCAPVxD.ASM
;
;	A VxD whose purpose is to be able to set a Win32 event at
;	interrupt time
;
;  Created 	     13-Aug-96 [JonT]
;  DeviceIO support  29-May-97 [MikeG]

PAGE 58,132
    .386p

WIN40COMPAT EQU 1

    .xlist
    include vmm.inc
    include debug.inc
    include vwin32.inc
    .list

; The following equate makes the VXD dynamically loadable.
DCAPVXD_DYNAMIC		equ	1

; Our version
DCAPVXD_MAJOR   	equ     1
DCAPVXD_MINOR   	equ     0
DCAPVXD_VERSION 	equ     ((DCAPVXD_MAJOR shl 8) + DCAPVXD_MINOR)

; Magic Function code values for DeviceIOControl code.
DCAPVXD_THREADTIMESERVICE equ	101h
DCAPVXD_R0THREADIDSERVICE equ   102h

;============================================================================
;        V I R T U A L   D E V I C E   D E C L A R A T I O N
;============================================================================

DECLARE_VIRTUAL_DEVICE DCAPVXD, 1, 0, DCAPVXD_Control, UNDEFINED_DEVICE_ID, \
                        UNDEFINED_INIT_ORDER,,DCAPVXD_PMAPI_Handler

VxD_LOCKED_CODE_SEG

;===========================================================================
;
;   PROCEDURE: DCAPVXD_Control
;
;   DESCRIPTION:
;    Device control procedure for the DCAPVXD VxD
;
;   ENTRY:
;    EAX = Control call ID
;
;   EXIT:
;    If carry clear then
;        Successful
;    else
;        Control call failed
;
;   USES:
;    EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;============================================================================

BeginProc DCAPVXD_Control

;	Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, DCAPVXD_Dynamic_Init
;	Control_Dispatch SYS_DYNAMIC_DEVICE_EXIT, DCAPVXD_Dynamic_Exit
	Control_Dispatch W32_DEVICEIOCONTROL,     DCAPVXD_DeviceIOControl
	clc
	ret

EndProc DCAPVXD_Control

VxD_LOCKED_CODE_ENDS

VxD_PAGEABLE_CODE_SEG

;===========================================================================
;
;   PROCEDURE: DCAPVXD_PMAPI_Handler
;
;   DESCRIPTION:
;	Win16 API handler
;
;   ENTRY:
;       EBX = VM handle
;       EBP = ptr to client register set
;
;   EXIT:
;       Carry set if  failed
;       else carry clear
;
;   USES:
;    EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;============================================================================

BeginProc DCAPVXD_PMAPI_Handler

	movzx   eax, [ebp.Client_AX]
	or	ah, ah			;AH = 0 is Get Version
	jz	DCAPVXD_Get_Version
	dec	ah                      ;AH = 1 is Set Event
	jz	DCAPVXD_Set_Event
	dec	ah			;AH = 2 is Close VxD Handle
	jz	DCAPVXD_Close_VxD_Handle
	
	public DCAPVXD_PMAPI_FAIL
DCAPVXD_PMAPI_FAIL:
	or      [ebp.Client_EFlags], CF_MASK
	ret
	
	public DCAPVXD_PMAPI_OK	
DCAPVXD_PMAPI_OK:
	and     [ebp.Client_EFlags], NOT CF_MASK
	ret
	
EndProc DCAPVXD_PMAPI_Handler


;  DCAPVXD_Get_Version
;	Returns the version of the device

BeginProc DCAPVXD_Get_Version

	mov	WORD PTR [ebp.Client_AX], DCAPVXD_VERSION
	jmp	DCAPVXD_PMAPI_OK

EndProc DCAPVXD_Get_Version


;  DCAPVXD_Set_Event
;	Sets a Win32 event.
;  Entry:
;	ECX points to a Win32 event (NOT a handle!)
;  Returns:
;	EAX	 0:Event pointer invalid
;		-1:Event queued to be set later
;		 1:Event set now

BeginProc DCAPVXD_Set_Event

	; Set the event
	mov	eax, [ebp.Client_ECX]
	VxDcall	_VWIN32_SetWin32Event
	
	; If the return is NC, EAX is 1, so return
	mov	[ebp.Client_EAX], eax
	jnc	DCAPVXD_PMAPI_OK
	
	; If the return is CY and EAX is 0, bad parameter, return 0
	or	eax, eax
	jc	DCAPVXD_PMAPI_Fail
	
	; If the return is CY and EAX is 1, SetEvent was queued. Return -1
	neg	eax
	mov	[ebp.Client_EAX], eax
	jmp	DCAPVXD_PMAPI_OK
	
EndProc DCAPVXD_Set_Event


;  DCAPVXD_Close_VxD_Handle
;	Frees a locked Win32 object for which we had a pointer. We can only
;	call this from a VxD, unfortunately, even though it's just going to
;	turn around and run it at ring 0.

BeginProc DCAPVXD_Close_VxD_Handle

	mov	eax, [ebp.Client_ECX]
	VxDcall	_VWIN32_CloseVxDHandle
	jmp	DCAPVXD_PMAPI_OK
	
EndProc DCAPVXD_Close_VxD_Handle


;******************************************************************************
;
; DCAPVXD_DeviceIOControl
;
; Handle the 32bit api calls from 32bit applications.  The 32 bit apps cannot
; use int 2f for api calls, so this interface has been provided.
;
; We'll just swizzle the parameters into what our int 2F interface expects and
; call its subroutines.
;
; Entry:
;	EAX = W32_DEVICEIOCONTROL
;	EBX = DDB
;	ECX = dwIoControlCode (DIOC_GETVERSION or DIOC_OPEN)
;	EDX = hDevice (Handle)
;	ESI = Pointer to DIOCParams
;
;	ECX = 	DIOC_GetVersion = 0
;		DIOC_Open	= 0
;		Define our own flags starting at 100h
;
;
;
;
; EXIT:
;	EAX = 0 = success
;	ECX = Version number if version call
;
;==============================================================================

;;If we keep adding codes, fixup the jumps below to be a table
;;If you do this be VERY careful. We are using a magic IOCtl base for
;;functions. Also, define a common header file, or come see me [mikeg] or
;;richp.

	Public DCAPVXD_DeviceIOControl
BeginProc DCAPVXD_DeviceIOControl

	push	edi
	push	esi
	mov	eax, [esi.lpvInBuffer]		;;If functions added, verify input buffer
	mov	edi, [esi.lpcbBytesReturned]	;;size
	mov	edx, [esi.lpvOutBuffer]		;;EDX is HOT! Don't smash


	cmp	ecx,DIOC_OPEN
	jne	short @F
	mov	ecx, 0400h			;;Win95 and later
	mov	dword ptr [edx],ecx
	mov	dword ptr [edi], 4
	xor	eax,eax
	jmp 	short DIOC_Exit

@@:

	cmp	ecx,DCAPVXD_THREADTIMESERVICE
	je 	short 	DIOC_ThreadTime

	cmp	ecx,DCAPVXD_R0THREADIDSERVICE
	je 	short DIOC_GetThreadID
	jmp	short DIOC_NotImp


DIOC_ThreadTime:
	mov	eax,dword ptr [eax]		;;eax points to the handle value...
	VMMCall _GetThreadExecTime, <eax>	;;C convention...
		
	mov	dword ptr [edx],eax
	mov	dword ptr [edi], 4
	xor	eax,eax				;;EAX==0 success
	jmp 	short DIOC_Exit

DIOC_GetThreadID:
	mov	ecx,edi				;;Keep the ptr to the cbBytes....
	VMMCall Get_Cur_Thread_Handle
	mov	dword ptr [edx],edi
	mov	dword ptr [ecx ], 4
	xor	eax,eax
	jmp short DIOC_Exit

DIOC_NotImp:

	mov 	eax,-1				;; Failure. No other calls supported


DIOC_Exit:
	pop	esi
	pop	edi
	clc
	ret

EndProc DCAPVXD_DeviceIOControl
VxD_PAGEABLE_CODE_ENDS

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\balance.cpp ===
#include "precomp.h"
#define MAGIC_CPU_DO_NOT_EXCEED_PERCENTAGE 50   //Don't use more than this % of the CPU for encoding (also in audiocpl.cpp)


/***************************************************************************

	Name	  : GetQOSCPULimit

	Purpose   : Gets the total allowed CPU percentage use from QoS

	Parameters: None

	Returns   : How much of the CPU can be used, in percents. 0 means failure

	Comment   :

***************************************************************************/
ULONG GetQOSCPULimit(void)
{
#define MSECS_PER_SEC    900
	IQoS *pQoS=NULL;
	LPRESOURCELIST pResourceList=NULL;
	ULONG ulCPUPercents=0;
	ULONG i;
	HRESULT hr=NOERROR;

	// create the QoS object and get the IQoS interface
	// CoInitialize is called in conf.cpp
	hr = CoCreateInstance(	CLSID_QoS,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IQoS,
							(void **) &pQoS);

	if (FAILED(hr) || !pQoS)
	{
		// this means that QoS was not instantiated yet. Use predefined value
		// ASSERT, because I want to know if this happens
		ASSERT(pQoS);
		ulCPUPercents = MSECS_PER_SEC;
		goto out;
	}

	// get a list of all resources from QoS
	hr = pQoS->GetResources(&pResourceList);
	if (FAILED(hr) || !pResourceList)
	{
		ERROR_OUT(("GetQoSCPULimit: GetReosurces failed"));
		goto out;
	}

	// find the CPU resource
	for (i=0; i < pResourceList->cResources; i++)
	{
		if (pResourceList->aResources[i].resourceID == RESOURCE_CPU_CYCLES)
		{
			// QoS keps the CPU units as the number of ms in a sec that the
			// CPU can be used. Need to divide by 10 to get percents
			ulCPUPercents = pResourceList->aResources[i].nUnits / 10;
			break;
		}
	}

out:
	if (pResourceList)
		pQoS->FreeBuffer(pResourceList);

	if (pQoS)
		pQoS->Release();

	return ulCPUPercents;		
}

HRESULT CapsCtl::ComputeCapabilitySets (DWORD dwBitsPerSec)
{
    HRESULT hr = hrSuccess;
    UINT nAud = 0;
    UINT nAudCaps = 0;
    UINT nVid = 0;
    UINT nVidCaps = 0;
    UINT x, y, nSets = 0;
    BASIC_AUDCAP_INFO *pac = NULL;
    BASIC_VIDCAP_INFO *pvc = NULL;
    MEDIA_FORMAT_ID *AdvList = NULL;
    int CPULimit;
    LPAPPCAPPIF  pAudIF = NULL;
    LPAPPVIDCAPPIF  pVidIF = NULL;

    if (pAudCaps)
    {
    	hr = pAudCaps->QueryInterface(IID_IAppAudioCap, (void **)&pAudIF);
	    if(!HR_SUCCEEDED(hr))
    	{
	    	goto ComputeDone;
    	}
    }

    if (pVidCaps)
    {
    	hr = pVidCaps->QueryInterface(IID_IAppVidCap, (void **)&pVidIF);
	    if(!HR_SUCCEEDED(hr))
    	{
	    	goto ComputeDone;
    	}
    }

    //Save away the Bandwidth
    dwConSpeed=dwBitsPerSec;

    // Create the default PTERMCAPDESCRIPTORS set

    // Get the number of BASIC_VIDCAP_INFO and BASIC_AUDCAP_INFO structures
    // available
    if (pVidIF)
        pVidIF->GetNumFormats(&nVidCaps);
    if (pAudIF)
        pAudIF->GetNumFormats(&nAudCaps);

    if (nAudCaps)
    {
        // Allocate some memory to hold the list in
        if (pac = (BASIC_AUDCAP_INFO*)MemAlloc(sizeof(BASIC_AUDCAP_INFO) * nAudCaps))
        {
            // Get the list
            if ((hr = pAudIF->EnumFormats(pac, nAudCaps * sizeof (BASIC_AUDCAP_INFO), (UINT*)&nAudCaps)) != hrSuccess)
                goto ComputeDone;
        }
        else
        {
            hr = CAPS_E_SYSTEM_ERROR;
            goto ComputeDone;
        }
    }

    if (nVidCaps)
    {
	    // Allocate some memory to hold the video list in
	    if (pvc = (BASIC_VIDCAP_INFO*) MemAlloc(sizeof(BASIC_VIDCAP_INFO) * nVidCaps))
        {
		    // Get the list
            if ((hr = pVidIF->EnumFormats(pvc, nVidCaps * sizeof (BASIC_VIDCAP_INFO), (UINT*)&nVidCaps)) != hrSuccess)
                goto ComputeDone;
        }
	    else
        {
            hr = CAPS_E_SYSTEM_ERROR;
            goto ComputeDone;
        }
	}

    //Allocate memory for the defined list of Codecs, so we can track them
    if (nAudCaps)
    {
        AdvList = (MEDIA_FORMAT_ID*) MemAlloc(sizeof(MEDIA_FORMAT_ID) * nAudCaps);
        if (!AdvList)
        {
            hr = CAPS_E_SYSTEM_ERROR;
            goto ComputeDone;
        }
    }

    if (pAdvertisedSets && pAdvertisedSets->wLength)
    {
        ResetCombinedEntries();
    }

    // We're about to write over pSetIDs, make sure it's freed.
    if (pSetIDs)
    {
        MemFree(pSetIDs);
        pSetIDs = NULL;
    }


    //Allocate nVidCaps+1 Set Ids
    ASSERT(!pSetIDs);
    pSetIDs = (DWORD*) MemAlloc(sizeof(DWORD) * (nVidCaps + 1));
    if (!pSetIDs)
    {
        hr = CAPS_E_SYSTEM_ERROR;
        goto ComputeDone;
    }

    //
    // If we can get a % limit from the QOS, then use that as the upper bound of
    // CPU consumption for a Codec. If it exceeds this bound, do not enable it.
    //
	CPULimit= (int) GetQOSCPULimit();
	if (CPULimit == 0)
		CPULimit = MAGIC_CPU_DO_NOT_EXCEED_PERCENTAGE;

    //
    // Now, sort that list, according to preference
    // This function adds the sets to the advertised list.  It sorts audio
    // by each video codec.
    //
	for (x=0; ((x<nVidCaps) && (nVid < H245_MAX_ALTCAPS));x++)
	{
        //Check to make sure the video codec can be advertised.
		if ((pvc[x].wCPUUtilizationDecode < CPULimit)
   	   		&& pvc[x].bRecvEnabled
   	   		&& pVidCaps->IsFormatPublic(pvc[x].Id))
   	   	{
   	   	    nVid++;
		
            // Loop through the Audio codecs, checking to see if they can
            // fit alongside the video codec
            // BUGBUG - we only check the total BW and CPU because we rely on
            // QOS to scale back the video in favor of audio. in other words,
            // video can be scaled down to zero BW and CPU.
            for (y=0;((y<nAudCaps) && (nAud < H245_MAX_ALTCAPS)) ;y++)
            {
        	    if ((pac[y].wCPUUtilizationDecode < CPULimit) &&
        	       ((pac[y].uAvgBitrate <= dwBitsPerSec && pac[y].bRecvEnabled)
        	       && pAudCaps->IsFormatPublic(pac[y].Id)))
        	    {
                    // going to advertise this ID in this
        			AdvList[nAud++]=pac[y].Id;
        	    }	
            }

            //Advertise this set, if we can do audio and video
            if (nAud)
            {
                hr = AddCombinedEntry (AdvList,nAud,&pvc[x].Id,1,&pSetIDs[nSets++]);
        	    if(!HR_SUCCEEDED(hr))
                {
                    goto ComputeDone;
        	    }
            }

            nAud = 0;
 		}
    }

//#if(0)
// Advertising only one media type in a simcaps set is redundant.
	//Now, do the no-video case. If we couldn't advertise above.-- Which implies, in this iteration
	// A problem with all the video codecs. We don't do any "combined" compares, so we know
	// it's a video problem (if it's audio, well we won't have anything to advertise anyways)
	if (!nSets)
    {
    	for (y=0;y<nAudCaps;y++)
    	{
       		if ((pac[y].wCPUUtilizationDecode < CPULimit) &&
    	   		((pac[y].uAvgBitrate <= dwBitsPerSec && pac[y].bRecvEnabled)
    	   		&& pAudCaps->IsFormatPublic(pac[y].Id)))
    		{
    	   	   //Advertise this ID
        	   AdvList[nAud++]=pac[y].Id;
        	}
    	}

        //Advertise this set, if we can do any audio codecs alone
        if (nAud)
        {
            //Since the set is 0 based the nVidCaps+1th entry is nVidcaps...
            hr=AddCombinedEntry (AdvList,nAud,NULL,0,&pSetIDs[nSets++]);
            if(!HR_SUCCEEDED(hr))
            {
                goto ComputeDone;
            }
        }
    }

//#endif // if(0)
ComputeDone:

    if (pVidIF)
    {
        pVidIF->Release();
    }

    if (pAudIF)
    {
        pAudIF->Release();
    }

    if (AdvList)
    {
        MemFree(AdvList);
    }

    if (pvc)
    {
        MemFree(pvc);
    }

    if (pac)
    {
        MemFree(pac);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\capif.h ===
#ifndef _CAPIF_H
#define _CAPIF_H



#define AUDIO_PACKET_DURATION_SHORT 	32
#define AUDIO_PACKET_DURATION_MEDIUM 	64
#define AUDIO_PACKET_DURATION_LONG		90
extern UINT g_AudioPacketDurationMs;
extern BOOL g_fRegAudioPacketDuration;


#ifdef DEBUG
extern VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
extern VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
#else
#define DumpNonstdParameters(a, b)
#define DumpChannelParameters(a, b)
#endif

#define NUM_SIMCAP_SETS 6 //Nuber of default pTermcapDescriptorArray Elements to allocate  (AddCombinedEntry (...) )



#ifdef __cplusplus

// RES_PAIR_LIST represents viable local and remote capability IDs for one
// media channel. e.g. a list of resolved audio formats or a list of resolved
// video formats. Each RES_PAIR_LIST is one column in a permutation table. 
typedef struct res_pair_list
{
	LPIH323MediaCap pMediaResolver; // interface pointer of the resolver that handles
	                                // this media type
	UINT uSize;                     // number of RES_PAIR in pResolvedPairs
	UINT uCurrentIndex;             // index into pResolvedPairs[]
	RES_PAIR *pResolvedPairs;       // pointer to array of RES_PAIR
}RES_PAIR_LIST, *PRES_PAIR_LIST;

// RES_CONTEXT represents a permutation table (A list of RES_PAIR_LISTs) 
// This used internally by a combination generator
typedef struct res_context {
	UINT uColumns;	// number of RES_PAIR_LIST in ppPairLists 
	RES_PAIR_LIST **ppPairLists;	// ptr to array of RES_PAIR_LIST pointers
	H245_CAPID_T *pIDScratch;	    // scratch area big enough to contain uColumns * sizeof(H245_CAPID_T)
	PCC_TERMCAPDESCRIPTORS pTermCapsLocal;
	PCC_TERMCAPDESCRIPTORS pTermCapsRemote;
	
}RES_CONTEXT, *PRES_CONTEXT;

// IH323PubCap  is used by H323 call control
class IH323PubCap
{
	public:
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;
    STDMETHOD_(BOOL, Init())=0;

	STDMETHOD(AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList, PCC_TERMCAPDESCRIPTORS
		pTermCapDescriptors, PCC_VENDORINFO pVendorInfo))=0;
	// H.245 parameter grabbing functions
	// Get public version of channel parameters for a specific decode capability
	STDMETHOD(GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, MEDIA_FORMAT_ID id))=0;
	// Get local and remote channel parameters for a specific encode capability
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams,
			UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal))=0;
 	// get local version of channel parameters for a specific decode capability

	STDMETHOD(GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		MEDIA_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize))=0;
	STDMETHOD( EnableMediaType(BOOL bEnable, LPGUID pGuid))=0;

	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID))=0;
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability))=0;

	// The following is an interim solution, definitely must revisit this for the next release.
 	// The data pump requires access to local parameters that results from capability
 	// negotiation. In the absence of a separate interface that the data pump can use,
 	// the following are stuck onto this interface.
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;

	STDMETHOD ( ComputeCapabilitySets (DWORD dwBandwidth))=0;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting))PURE;
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting))PURE;
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote))PURE;
    STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput))PURE;
	STDMETHOD (ReInitialize())PURE;	    
};
typedef IH323PubCap *LPIH323PubCap;


class CapsCtl : public IH323PubCap, public IDualPubCap {
protected:
    PCC_TERMCAPLIST m_pAudTermCaps;
    PCC_TERMCAPLIST m_pVidTermCaps;
	// internal utility functions
	
	UINT GetCapDescBufSize (BOOL bRxCaps);
   	HRESULT GetCombinedBufSize(BOOL bRXCaps, UINT *puBufsize, UINT *puCapsCount);
	UINT GetSimCapBufSize (BOOL bRxCaps);
   	BOOL TestSimultaneousCaps(H245_CAPID_T* pIDArray, UINT uIDArraySize, 
	    PCC_TERMCAPDESCRIPTORS pTermCaps);
	BOOL ResolvePermutations(PRES_CONTEXT pResContext, UINT uNumFixedColumns);
   	BOOL AreSimCaps(H245_CAPID_T* pIDArray, UINT uIDArraySize, 
	        H245_SIMCAP_T **ppAltCapArray,UINT uAltCapArraySize);

public:
   	CapsCtl();
	~CapsCtl();

  	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD_(BOOL, Init());
	STDMETHOD( AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList,PCC_TERMCAPDESCRIPTORS pTermCapDescriptors,PCC_VENDORINFO pVendorInfo));
	STDMETHOD( CreateCapList(PCC_TERMCAPLIST *ppCapBuf, PCC_TERMCAPDESCRIPTORS *ppCombinations));
	STDMETHOD( DeleteCapList(PCC_TERMCAPLIST pCapBuf, PCC_TERMCAPDESCRIPTORS pCombinations));

	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams, UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal));
	STDMETHOD( GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id));
	STDMETHOD(GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,DWORD * pFormatID, LPVOID lpvBuf, UINT uBufSize));
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps));
	STDMETHOD( EnableMediaType(BOOL bEnable, LPGUID pGuid));

	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID));
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability));
	//
	// methods provided to the Data pump, common to H.323 and MSICCP
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	//
	//
	LPIH323MediaCap FindHostForID(MEDIA_FORMAT_ID id);
	LPIH323MediaCap FindHostForMediaType(PCC_TERMCAP pCapability);
    LPIH323MediaCap FindHostForMediaGuid(LPGUID pMediaGuid);

	STDMETHOD ( AddCombinedEntry (MEDIA_FORMAT_ID *puAudioFormatList,UINT uAudNumEntries,MEDIA_FORMAT_ID *puVideoFormatList, UINT uVidNumEntries,PDWORD pIDOut));
	STDMETHOD ( RemoveCombinedEntry (DWORD ID));
	STDMETHOD ( ResetCombinedEntries());
	STDMETHOD ( ComputeCapabilitySets (DWORD dwBandwidth));
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHODIMP ReInitialize();
	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting)
		{
            if (pAudCaps)
    			pAudCaps->EnableTXCaps(bSetting);
            if (pVidCaps)
    			pVidCaps->EnableTXCaps(bSetting);
		};);
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting)
		{
            if (pAudCaps)
    			pAudCaps->EnableRemoteTSTradeoff(bSetting);
            if (pVidCaps)
    			pVidCaps->EnableRemoteTSTradeoff(bSetting);
		};);

	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote));
			        
	STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput));
	
protected:
	UINT uRef;
	static UINT uAdvertizedSize;
	BOOL bAudioPublicize, bVideoPublicize, bT120Publicize;
	MEDIA_FORMAT_ID m_localT120cap;
	MEDIA_FORMAT_ID m_remoteT120cap;
	DWORD m_remoteT120bitrate;
	LPIH323MediaCap pAudCaps;
	LPIH323MediaCap pVidCaps;

	PCC_TERMCAPLIST pACapsBuf,pVCapsBuf;
	static PCC_TERMCAPDESCRIPTORS pAdvertisedSets;
	static UINT uStaticGlobalRefCount;
	PCC_TERMCAPDESCRIPTORS pRemAdvSets;
	DWORD dwNumInUse;				// # of active TERMCAPDESCRIPTORS in use
	DWORD *pSetIDs;					//Id's of the active PCC_TERMCAPDESCRIPTORS
	BOOL m_fNM20;					// set to TRUE if we're talking to NM 2.0
	static DWORD dwConSpeed;

};


LPIH323PubCap CreateCapabilityObject();


#endif	// __cplusplus
#endif	//#ifndef _CAPIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\dcap\vxd\makefile.inc ===
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 $(ASM_FLAGS) -Cx -DMASM6
LINKVXD_FLAGS = -align:0x1000 -nodefaultlib -VXD

!IF "$(BUILD_ALT_DIR)" == "d"
ASM_FLAGS = $(ASM_FLAGS) -Zi -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) $(INCPATH0) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(INCPATH0) $(ASM_FLAGS)
<<NOKEEP

TARGETCOPY_CMD = $(TARGETCOPY_CMD:.exe=.vxd)
MAPCOPY_CMD = $(MAPCOPY_CMD:exe=vxd)
SYMCOPY_CMD = $(SYMCOPY_CMD:exe=vxd)
PDBCOPY_CMD = $(PDBCOPY_CMD:exe=vxd)
DBGCOPY_CMD = $(DBGCOPY_CMD:exe=vxd)

$(O)\dcapvxd.res: dcapvxd.rc
    $(DEVROOT)\bin\c816\i386\rc -r -I $(DEVROOT)\inc16 -I $(ROOT)\h -fo $@ dcapvxd.rc

!IFDEF NOLINK
$(O)\dcapvxd.vxd:
    @echo

!ELSE    
$(O)\dcapvxd.vxd: $(O)\dcapvxd.obj dcapvxd.def $(O)\dcapvxd.res
    editbin $(O)\dcapvxd.obj
    link $(O)\dcapvxd.obj $(LINKVXD_FLAGS) -def:dcapvxd.def -out:$(O)\dcapvxd.vxd -map:$(O)\dcapvxd.map
    $(DEVROOT)\bin\misc\i386\adrc2vxd.exe $(O)\dcapvxd.vxd $(O)\dcapvxd.res
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(PDBCOPY_CMD)
    $(DBGCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
    
!ENDIF

$(O)\dcapvxd.lib:
    @echo no lib
$(O)\dcapvxd.exp:
    @echo no exp
$(O)\dcapvxd.exe:
    @echo no exe
# blank target to avoid linking a useless exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\capsctl.cpp ===
/*
 *    File: capsctl.cpp
 *
 *    capability control object implementations
 *
 *
 *    Revision History:
 *
 *    10/10/96 mikeg created
 * 	  06/24/97 mikev	- Added T.120 capability to serialized caps and simcaps (interim hack until a
 *							T120 resolver is implemented)
 *						- Retired  ResolveEncodeFormat(Audio,Video) and implemented a data-independent
 *						resolution algorithm and exposed method ResolveFormats(). Added support
 * 						routines ResolvePermutations(), TestSimultaneousCaps() and
 *						AreSimcaps().
 */

#include "precomp.h"
UINT g_AudioPacketDurationMs = AUDIO_PACKET_DURATION_LONG;	// preferred packet duration
BOOL g_fRegAudioPacketDuration = FALSE;	// AudioPacketDurationMs from registry


PCC_TERMCAPDESCRIPTORS CapsCtl::pAdvertisedSets=NULL;
DWORD CapsCtl::dwConSpeed = 0;
UINT CapsCtl::uStaticGlobalRefCount=0;
UINT CapsCtl::uAdvertizedSize=0;
extern HRESULT WINAPI CreateMediaCapability(REFGUID, LPIH323MediaCap *);

LPIH323MediaCap CapsCtl::FindHostForID(MEDIA_FORMAT_ID id)
{
	if(pAudCaps && pAudCaps->IsHostForCapID(id))
	{
		return (pAudCaps);
	}
	else if (pVidCaps  && pVidCaps->IsHostForCapID(id))
	{
  		return (pVidCaps);
	}
	return NULL;
}

LPIH323MediaCap CapsCtl::FindHostForMediaType(PCC_TERMCAP pCapability)
{
	if(pCapability->DataType == H245_DATA_AUDIO)
	{
		return (pAudCaps);
	}
	else if(pCapability->DataType == H245_DATA_VIDEO)
	{
  		return (pVidCaps);
	}
	return NULL;
}

LPIH323MediaCap CapsCtl::FindHostForMediaGuid(LPGUID pMediaGuid)
{

	if(MEDIA_TYPE_H323VIDEO == *pMediaGuid)
	{
  		return (pVidCaps);
	}
	else if(MEDIA_TYPE_H323AUDIO == *pMediaGuid)
	{
		return (pAudCaps);
	}
	else
		return NULL;
}

ULONG CapsCtl::AddRef()
{
	uRef++;
	return uRef;
}

ULONG CapsCtl::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	return uRef;
}

STDMETHODIMP CapsCtl::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IDualPubCap)// satisfy symmetric property of QI
	{
		*ppvObject = (IDualPubCap *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if(iid == IID_IAppAudioCap )
	{
		if(pAudCaps)
		{
			return pAudCaps->QueryInterface(iid, ppvObject);
		}
	}
	else if(iid == IID_IAppVidCap )
	{
		if(pVidCaps)
		{
			return pVidCaps->QueryInterface(iid, ppvObject);
		}
	}
	return hr;
}



CapsCtl::CapsCtl () :
uRef(1),
pVidCaps(NULL),
pAudCaps(NULL),
pACapsBuf(NULL),
pVCapsBuf(NULL),
dwNumInUse(0),
bAudioPublicize(TRUE),
bVideoPublicize(TRUE),
bT120Publicize(TRUE),
m_localT120cap(INVALID_MEDIA_FORMAT),
m_remoteT120cap(INVALID_MEDIA_FORMAT),
m_remoteT120bitrate(0),
m_pAudTermCaps(NULL),
m_pVidTermCaps(NULL),
pSetIDs(NULL),
pRemAdvSets(NULL)
{
   uStaticGlobalRefCount++;
}

CapsCtl::~CapsCtl ()
{

   if (pACapsBuf) {
      MemFree (pACapsBuf);
   }
   if (pVCapsBuf) {
      MemFree (pVCapsBuf);
   }

   if (pAudCaps) {
      pAudCaps->Release();
   }

   if (pVidCaps) {
      pVidCaps->Release();
   }
   uStaticGlobalRefCount--;
   if (uStaticGlobalRefCount == 0) {
       //Free up the sim. caps array
       if (pAdvertisedSets) {
          while (pAdvertisedSets->wLength) {
             //wLength is Zero based
             MemFree ((VOID *)pAdvertisedSets->pTermCapDescriptorArray[--pAdvertisedSets->wLength]);
          }
          MemFree ((VOID *)pAdvertisedSets->pTermCapDescriptorArray);
          pAdvertisedSets->pTermCapDescriptorArray = NULL;
          MemFree ((void *) pAdvertisedSets);
          pAdvertisedSets=NULL;
          dwNumInUse=0;
       }
   }

   //And the remote array
   if (pRemAdvSets) {
      while (pRemAdvSets->wLength) {
         MemFree ((VOID *)pRemAdvSets->pTermCapDescriptorArray[--pRemAdvSets->wLength]);
      }
      MemFree ((void *) pRemAdvSets->pTermCapDescriptorArray);
      pRemAdvSets->pTermCapDescriptorArray = NULL;
      MemFree ((void *) pRemAdvSets);
      pRemAdvSets=NULL;
   }
   MemFree (pSetIDs);
   pSetIDs=NULL;
}

BOOL CapsCtl::Init()
{
    HRESULT hrLast;
    int iBase = 1;

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
    	hrLast = ::CreateMediaCapability(MEDIA_TYPE_H323AUDIO, &pAudCaps);
	    if(!HR_SUCCEEDED(hrLast))
    	{
            goto InitDone;
    	}
    }

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
    	hrLast = ::CreateMediaCapability(MEDIA_TYPE_H323VIDEO, &pVidCaps);
	    if(!HR_SUCCEEDED(hrLast))
    	{
            goto InitDone;
    	}
    }

    if (pAudCaps)
    {
    	// Base the capability IDs beginning at 1  (zero is an invalid capability ID!)
	    pAudCaps->SetCapIDBase(iBase);
        iBase += pAudCaps->GetNumCaps();
    }

    if (pVidCaps)
    {
        pVidCaps->SetCapIDBase(iBase);
        iBase += pVidCaps->GetNumCaps();
    }

InitDone:
	m_localT120cap = iBase;
	return TRUE;
}
																								
HRESULT CapsCtl::ReInitialize()
{
	HRESULT hr = hrSuccess;
    int iBase = 1;

	if (pAudCaps && !pAudCaps->ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto EXIT;
	}

	if (pVidCaps && !pVidCaps->ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto EXIT;
	}

	// Base the capability IDs beginning at 1  (zero is an invalid capability ID!)
    if (pAudCaps)
    {
    	pAudCaps->SetCapIDBase(iBase);
        iBase += pAudCaps->GetNumCaps();
    }

    if (pVidCaps)
    {
        pVidCaps->SetCapIDBase(iBase);
        iBase += pVidCaps->GetNumCaps();
    }

	m_localT120cap = iBase;

EXIT:
	return hr;
}

const char szNMProdNum[] = "Microsoft\256 NetMeeting(TM)\0";
const char szNM20VerNum[] = "Version 2.0\0";

HRESULT CapsCtl::AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList,PCC_TERMCAPDESCRIPTORS pTermCapDescriptors, PCC_VENDORINFO pVendorInfo)
{
	FX_ENTRY("CapsCtl::AddRemoteDecodeCaps");
	HRESULT hr;
	void      	  *pData=NULL;
	UINT		  uSize,x,y,z;


   //WLength is # of capabilities, not structure length
	WORD wNDesc;
	LPIH323MediaCap pMediaCap;
	
	if(!pTermCapList && !pTermCapDescriptors) 	// additional capability descriptors may be added
	{											// at any time
	   return CAPS_E_INVALID_PARAM;
	}
	// Check for NM version 2.0
	m_fNM20 = FALSE;
	ASSERT(pVendorInfo);
	if (pVendorInfo->bCountryCode == USA_H221_COUNTRY_CODE
		&& pVendorInfo->wManufacturerCode == MICROSOFT_H_221_MFG_CODE
		&& pVendorInfo->pProductNumber && pVendorInfo->pVersionNumber
		&& pVendorInfo->pProductNumber->wOctetStringLength == sizeof(szNMProdNum)
		&& pVendorInfo->pVersionNumber->wOctetStringLength == sizeof(szNM20VerNum)
		&& memcmp(pVendorInfo->pProductNumber->pOctetString, szNMProdNum, sizeof(szNMProdNum)) == 0
		&& memcmp(pVendorInfo->pVersionNumber->pOctetString, szNM20VerNum, sizeof(szNM20VerNum)) == 0
		)
	{
		m_fNM20 = TRUE;
	}

	// cleanup old term caps if term caps are being added and old caps exist
    if (pAudCaps)
    	pAudCaps->FlushRemoteCaps();
    if (pVidCaps)
    	pVidCaps->FlushRemoteCaps();
	m_remoteT120cap = INVALID_MEDIA_FORMAT;	// note there is no T120 cap resolver and
												// this CapsCtl holds exactly one local and remote T120 cap
	
	// Copy pTermcapDescriptors to a local copy, (and free any old one)
	if (pRemAdvSets) {
	   while (pRemAdvSets->wLength) {
		  //0 based
		  MemFree ((VOID *)pRemAdvSets->pTermCapDescriptorArray[--pRemAdvSets->wLength]);
	   }

	   MemFree ((VOID *)pRemAdvSets->pTermCapDescriptorArray);
	   pRemAdvSets->pTermCapDescriptorArray = NULL;
	   MemFree ((VOID *)pRemAdvSets);
	   pRemAdvSets=NULL;

	}

	//Ok, walk through the PCC_TERMCAPDESCRIPTORS list, first, allocate memory for the Master PCC_TERMCAPDESCRIPTORS
	//structure, then each simcap, and the altcaps therin, then copy the data.

	if (!(pRemAdvSets=(PCC_TERMCAPDESCRIPTORS) MemAlloc (sizeof (CC_TERMCAPDESCRIPTORS) ))){
	   return CAPS_E_SYSTEM_ERROR;
	}

	//How many Descriptors?
	pRemAdvSets->wLength=pTermCapDescriptors->wLength;

	if (!(pRemAdvSets->pTermCapDescriptorArray=((H245_TOTCAPDESC_T **)MemAlloc (sizeof (H245_TOTCAPDESC_T*)*pTermCapDescriptors->wLength))) ) {
	   return CAPS_E_SYSTEM_ERROR;
	}

	//Once per descriptor...
	for (x=0;x < pTermCapDescriptors->wLength;x++) {
	   //Allocate memory for the descriptor entry
	   if (!(pRemAdvSets->pTermCapDescriptorArray[x]=(H245_TOTCAPDESC_T *)MemAlloc (sizeof (H245_TOTCAPDESC_T)))) {
		  return CAPS_E_SYSTEM_ERROR;
	   }

	   //BUGBUG for beta 2 Copy en masse.
	   memcpy (pRemAdvSets->pTermCapDescriptorArray[x],pTermCapDescriptors->pTermCapDescriptorArray[x],sizeof (H245_TOTCAPDESC_T));

/*	post beta 2?
	   //Copy the capability ID
	   pRemAdvSets->pTermCapDescriptorArray[x].CapID=pTermCapDescriptors[x].CapID
	   //Walk the simcaps, then altcaps and copy entries */
	}


	for (wNDesc=0;wNDesc <pTermCapList->wLength;wNDesc++) {
	  pData=NULL;
		pMediaCap = FindHostForMediaType(pTermCapList->pTermCapArray[wNDesc]);
		if(!pMediaCap)
		{
			// special case: there is no T120 resolver. THIS IS A TEMPORARY
			// SITUATION. We cannot track bitrate limits on multiple T120 capability
			// instances because of this.  As of now, we (NetMeeting) do not advertise
			// more than one T.120 capability.

			//This code will keep the last T.120 capability encountered.
			if(((pTermCapList->pTermCapArray[wNDesc])->DataType == H245_DATA_DATA)
			&& ((pTermCapList->pTermCapArray[wNDesc])->Cap.H245Dat_T120.application.choice
				== DACy_applctn_t120_chosen)
			&& ((pTermCapList->pTermCapArray[wNDesc])->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice
				== separateLANStack_chosen))
			{
				// it's data data
				m_remoteT120cap = (pTermCapList->pTermCapArray[wNDesc])->CapId;
				m_remoteT120bitrate =
					(pTermCapList->pTermCapArray[wNDesc])->Cap.H245Dat_T120.maxBitRate;
			}
			
			// continue;
			// handled it in-line
		}
	  	else if(pMediaCap->IsCapabilityRecognized(pTermCapList->pTermCapArray[wNDesc]))
	  	{
			hr = pMediaCap->AddRemoteDecodeFormat(pTermCapList->pTermCapArray[wNDesc]);
			#ifdef DEBUG
			if(!HR_SUCCEEDED(hr))
			{
				ERRORMESSAGE(("%s:AddRemoteDecodeFormat returned 0x%08lx\r\n",_fx_, hr));
			}
			#endif // DEBUG
	  	}
	}
	return (hrSuccess);
}


HRESULT CapsCtl::CreateCapList(PCC_TERMCAPLIST *ppCapBuf, PCC_TERMCAPDESCRIPTORS *ppCombinations)
{
   	PCC_TERMCAPLIST pTermCapList = NULL, pTermListAud=NULL, pTermListVid=NULL;
	PCC_TERMCAPDESCRIPTORS pCombinations = NULL;
	UINT uCount = 0, uSize = 0, uT120Size = 0;
	HRESULT hr;
	WORD wc;
   	UINT x=0,y=0,z=0,uNumAud=0,uNumVid=0;
	H245_TOTCAPDESC_T *pTotCaps, **ppThisDescriptor;
	PPCC_TERMCAP  ppCCThisTermCap;	
	PCC_TERMCAP  pCCT120Cap = NULL;

	uCount = GetNumCaps(TRUE);

	ASSERT((NULL == m_pAudTermCaps) && (NULL == m_pVidTermCaps));
	
	// calc size of CC_TERMCAPLIST header + CC_TERMCAPDESCRIPTORS + array of PCC_TERMCAP
	// allocate mem for the master CC_TERMCAPLIST, including the array of pointers to all CC_TERMCAPs
	uSize = sizeof(CC_TERMCAPLIST)
		+ sizeof (CC_TERMCAPDESCRIPTORS) + (uCount * sizeof(PCC_TERMCAP));
	if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
	{
		uSize += sizeof(CC_TERMCAP);
	}

	pTermCapList = (PCC_TERMCAPLIST)MemAlloc(uSize);
  	if(pTermCapList == NULL)
  	{
		hr = CAPS_E_NOMEM;
		goto ERROR_EXIT;
  	}
	
	// divide up the buffer, CC_TERMCAPLIST first, followed by array of PCC_TERMCAP.
	// The array of PCC_TERMCAP follows fixed size CC_TERMCAPLIST structure and the fixed size
	// CC_TERMCAP structure that holds the one T.120 cap.
	if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
	{
		pCCT120Cap = (PCC_TERMCAP)(((BYTE *)pTermCapList) + sizeof(CC_TERMCAPLIST));
		ppCCThisTermCap = (PPCC_TERMCAP) (((BYTE *)pTermCapList) + sizeof(CC_TERMCAPLIST) +
			sizeof(CC_TERMCAP));
	}
	else
		ppCCThisTermCap = (PPCC_TERMCAP) (((BYTE *)pTermCapList) + sizeof(CC_TERMCAPLIST));
	
	// allocate mem for the simultaneous caps
	// get size of cached advertised sets if it exists and more than one media
	// type is enabled for publication
	if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)
	{
		// use size of cached buffer
		uSize = uAdvertizedSize;
	}
	else if (pAdvertisedSets)
	{
		// This case needs to be fixed. If media types are disabled, the simultaneous capability
		// descriptors in pAdvertisedSets should be rebuilt at that time. There should be no need to test
		// if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)

   		// calculate size of capability descriptors and simultaneous capability structures.

		#pragma message ("Figure out the size this needs to be...")
		#define NUMBER_TERMCAP_DESCRIPTORS 1
		uSize = sizeof(H245_TOTCAPDESC_T) * NUMBER_TERMCAP_DESCRIPTORS+
						  sizeof (CC_TERMCAPDESCRIPTORS)+NUMBER_TERMCAP_DESCRIPTORS*
						  sizeof (H245_TOTCAPDESC_T *);
	}
    else
    {
        uSize = 0;
    }

	
    if (uSize)
    {
    	pCombinations = (PCC_TERMCAPDESCRIPTORS)MemAlloc(uSize);
	    // skip the CC_TERMCAPDESCRIPTORS, which has a variable length array of (H245_TOTCAPDESC_T *) following it
    	// the total size of that glob is uSimCapsSize
	    // The actual array of [H245_TOTCAPDESC_T *] follows the CC_TERMCAPDESCRIPTORS structure
    	// anchor the pCombinations->pTermCapDescriptorArray to this point.
	    if(pCombinations == NULL)
      	{
	    	hr = CAPS_E_NOMEM;
		    goto ERROR_EXIT;
      	}
	
	    ppThisDescriptor = pCombinations->pTermCapDescriptorArray
		    = (H245_TOTCAPDESC_T **)((BYTE *)pCombinations + sizeof(CC_TERMCAPDESCRIPTORS));
    	// the first H245_TOTCAPDESC_T follows the array of [H245_TOTCAPDESC_T *]
	    pTotCaps = (H245_TOTCAPDESC_T *)((BYTE *)ppThisDescriptor + pCombinations->wLength*sizeof(H245_TOTCAPDESC_T **));

    	if(pAudCaps && bAudioPublicize)
	    {
		    hr=pAudCaps->CreateCapList((LPVOID *)&pTermListAud);
    		if(!HR_SUCCEEDED(hr))
	    		goto ERROR_EXIT;
		    ASSERT(pTermListAud != NULL);
    	}
	    if(pVidCaps && bVideoPublicize)
    	{
	    	hr=pVidCaps->CreateCapList((LPVOID *)&pTermListVid);
		    if(!HR_SUCCEEDED(hr))
			    goto ERROR_EXIT;
    		ASSERT(pTermListVid != NULL);
	    }
    }
    else
    {
        pCombinations = NULL;
    }

	// fix pointers in the master caps list

	// Now need to fixup the CC_TERMCAPLIST to refer to the individual capabilities
	// Anchor the CC_TERMCAPLIST member pTermCapArray at the array of PCC_TERMCAP, and
	// start partying on the array.
	pTermCapList->wLength =0;
	pTermCapList->pTermCapArray = ppCCThisTermCap;

	if(pCCT120Cap)
	{
		*ppCCThisTermCap++ = pCCT120Cap;	
		// set T120 capability parameters
		pCCT120Cap->DataType = H245_DATA_DATA;
		pCCT120Cap->ClientType = H245_CLIENT_DAT_T120;
		pCCT120Cap->Dir = H245_CAPDIR_LCLRXTX;
		
		pCCT120Cap->Cap.H245Dat_T120.application.choice = DACy_applctn_t120_chosen;
		pCCT120Cap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice= separateLANStack_chosen;
		pCCT120Cap->Cap.H245Dat_T120.maxBitRate = dwConSpeed;

		pCCT120Cap->CapId = (H245_CAPID_T)m_localT120cap;	
		pTermCapList->wLength++;
	}
	if(pAudCaps && pTermListAud)
	{
		for(wc = 0; wc < pTermListAud->wLength; wc++)
		{
			// copy the array of "pointers to CC_TERMCAP"
			*ppCCThisTermCap++ = pTermListAud->pTermCapArray[wc];
			pTermCapList->wLength++;
		}
	}
	if(pVidCaps && pTermListVid)
	{
		for(wc = 0; wc <  pTermListVid->wLength; wc++)
		{
			// copy the array of "pointers to CC_TERMCAP"
			*ppCCThisTermCap++ = pTermListVid->pTermCapArray[wc];
			pTermCapList->wLength++;			
		}

	}
	// fixup the simultaneous capability descriptors
	//	Create a default set if necessary
	//

	if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)
	{
		pCombinations->wLength = pAdvertisedSets->wLength;
       	// point pCombinations->pTermCapDescriptorArray past the header (CC_TERMCAPDESCRIPTORS)
        pCombinations->pTermCapDescriptorArray
			= (H245_TOTCAPDESC_T **)((BYTE *)pCombinations + sizeof(CC_TERMCAPDESCRIPTORS));
        // the first H245_TOTCAPDESC_T follows the array of [H245_TOTCAPDESC_T *]
        pTotCaps = (H245_TOTCAPDESC_T *)((BYTE *)pCombinations->pTermCapDescriptorArray +
            pAdvertisedSets->wLength*sizeof(H245_TOTCAPDESC_T **));			
		
		for(x = 0; x < pAdvertisedSets->wLength; x++)
		{
			// write into the array of descriptor pointers. pointer[x] = this one
            pCombinations->pTermCapDescriptorArray[x] = pTotCaps;
			
            pTotCaps->CapDescId= pAdvertisedSets->pTermCapDescriptorArray[x]->CapDescId;
	   		pTotCaps->CapDesc.Length=pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.Length;
	   		
	   		for(y = 0; y < pTotCaps->CapDesc.Length;y++)
			{
			   //Copy the length field.
			   pTotCaps->CapDesc.SimCapArray[y].Length=
			   pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[y].Length;

				for(z=0;
					z < pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[y].Length;
					z++)
				{
					pTotCaps->CapDesc.SimCapArray[y].AltCaps[z] =
						pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[y].AltCaps[z];
				}
			}
            pTotCaps++;            	
		}
	}
	else if (pAdvertisedSets)
	{
		// descriptors in pAdvertisedSets should be rebuilt at that time. There should be no need to test
		// if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)

 		// HACK - put all audio or video caps in one AltCaps[], the T.120 cap in another AltCaps[]
	    // and put both of those in one single  capability descriptor (H245_TOTCAPDESC_T)
		// This hack will not extend past the assumption of one audio channel, one video channel, and
		// one T.120 channel.  If arbitrary media is supported, or multiple audio channels are supported,
		// this code will be wrong
		
		pCombinations->wLength=1;
	   	// point pCombinations->pTermCapDescriptorArray past the header (CC_TERMCAPDESCRIPTORS)
        pCombinations->pTermCapDescriptorArray
			= (H245_TOTCAPDESC_T **)((BYTE *)pCombinations + sizeof(CC_TERMCAPDESCRIPTORS));
        // the first H245_TOTCAPDESC_T follows the array of [H245_TOTCAPDESC_T *]
        pTotCaps = (H245_TOTCAPDESC_T *)((BYTE *)pCombinations->pTermCapDescriptorArray +
            pAdvertisedSets->wLength*sizeof(H245_TOTCAPDESC_T **));			
   		pTotCaps->CapDescId=(H245_CAPDESCID_T)x;
   		pTotCaps->CapDesc.Length=0;
		if(pTermListAud)
		{
			uNumAud = min(pTermListAud->wLength, H245_MAX_ALTCAPS);
			pTotCaps->CapDesc.SimCapArray[x].Length=(unsigned short)uNumAud;
			for(y = 0; y<uNumAud;y++)
			{
				pTotCaps->CapDesc.SimCapArray[x].AltCaps[y] = pTermListAud->pTermCapArray[y]->CapId;
			}
			x++;
			pTotCaps->CapDesc.Length++;
		}

		if(pTermListVid && pTermListVid->wLength)
		{
			uNumVid = min(pTermListVid->wLength,  H245_MAX_ALTCAPS);
			pTotCaps->CapDesc.SimCapArray[x].Length=(unsigned short)uNumVid;
			for(y = 0; y<uNumVid;y++)
			{
				pTotCaps->CapDesc.SimCapArray[x].AltCaps[y] = pTermListVid->pTermCapArray[y]->CapId;
			}
			x++;
			pTotCaps->CapDesc.Length++;
		}
		// the T.120 cap
		if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
		{
			pTotCaps->CapDesc.SimCapArray[x].Length=1;
			pTotCaps->CapDesc.SimCapArray[x].AltCaps[0] = (H245_CAPID_T)m_localT120cap;
			pTotCaps->CapDesc.Length++;
		}
		
		// write into the array of descriptor pointers. pointer[x] = this one
		*ppThisDescriptor = pTotCaps;
		
	}
	m_pVidTermCaps = pTermListVid;
	m_pAudTermCaps = pTermListAud;
	
	*ppCapBuf = pTermCapList;
	*ppCombinations = pCombinations;
	return hrSuccess;
	
ERROR_EXIT:
	m_pAudTermCaps = NULL;
	m_pVidTermCaps = NULL;
	if(pTermCapList)
		MemFree(pTermCapList);
	if(pCombinations)
		MemFree(pCombinations);

	if(pAudCaps && pTermListAud)
	{
		hr=pAudCaps->DeleteCapList(pTermListAud);
	}
	if(pVidCaps && pTermListVid)
	{
		hr=pVidCaps->DeleteCapList(pTermListVid);
	}
	return hr;
}

HRESULT CapsCtl::DeleteCapList(PCC_TERMCAPLIST pCapBuf, PCC_TERMCAPDESCRIPTORS pCombinations)
{
	MemFree(pCapBuf);
	MemFree(pCombinations);
	if(m_pAudTermCaps && pAudCaps)
	{
		pAudCaps->DeleteCapList(m_pAudTermCaps);
	}
	if(m_pVidTermCaps)
	{
		pVidCaps->DeleteCapList(m_pVidTermCaps);
	}
	
	m_pAudTermCaps = NULL;
	m_pVidTermCaps = NULL;
	return hrSuccess;
}

HRESULT CapsCtl::GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uLocalSize,DWORD idRemote, DWORD idLocal)
{
	LPIH323MediaCap pMediaCap = FindHostForID(idLocal);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;

	// HACK
	// Adjust audio packetization depending on call scenario
	// unless there is an overriding registry setting
	if (pMediaCap == pAudCaps)
	{
		VIDEO_FORMAT_ID vidLocal=INVALID_MEDIA_FORMAT, vidRemote=INVALID_MEDIA_FORMAT;
		VIDEO_CHANNEL_PARAMETERS vidParams;
		CC_TERMCAP vidCaps;
		UINT audioPacketLength;
		// modify the audio packetization parameters based on local bandwidth
		// and presence of video
		audioPacketLength = AUDIO_PACKET_DURATION_LONG;
		// the registry setting overrides, if it is present
		if (g_fRegAudioPacketDuration)
			audioPacketLength = g_AudioPacketDurationMs;
		else if (!m_fNM20)		// dont try smaller packets for NM20 because it cant handle them
		{
			if (pVidCaps && pVidCaps->ResolveEncodeFormat(&vidLocal,&vidRemote) == S_OK
				&& (pVidCaps->GetEncodeParams(&vidCaps,sizeof(vidCaps), &vidParams, sizeof(vidParams), vidRemote, vidLocal) == S_OK))
			{
				// we may potentially send video
				if (vidParams.ns_params.maxBitRate*100 > BW_ISDN_BITS)
					audioPacketLength = AUDIO_PACKET_DURATION_SHORT;
					
			}
			else
			{
				// no video
				// since we dont know the actual connection bandwidth we use
				// the local user setting.
				// Note: if the remote is on a slow-speed net and the local is on a LAN
				// we may end up with an inappropriate setting.
				if (dwConSpeed > BW_288KBS_BITS)
					audioPacketLength = AUDIO_PACKET_DURATION_SHORT;
				else if (dwConSpeed > BW_144KBS_BITS)
					audioPacketLength = AUDIO_PACKET_DURATION_MEDIUM;
			}
		}
		// Setting the AudioPacketDurationMs  affects the subsequent GetEncodeParams call
		pMediaCap->SetAudioPacketDuration(audioPacketLength);
	}
	
	return pMediaCap->GetEncodeParams (pBufOut,uBufSize, pLocalParams,
			uLocalSize,idRemote,idLocal);
	
}

HRESULT CapsCtl::GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id)
{
	LPIH323MediaCap pMediaCap = FindHostForID(id);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;
		
	return pMediaCap->GetPublicDecodeParams (pBufOut,uBufSize,id);
}

HRESULT CapsCtl::GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,DWORD * pFormatID, LPVOID lpvBuf, UINT uBufSize)
{
	LPIH323MediaCap pMediaCap = FindHostForMediaType(pChannelParams->pChannelCapability);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;
	return pMediaCap->GetDecodeParams (pChannelParams,pFormatID,lpvBuf,uBufSize);
}

HRESULT CapsCtl::ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote)
{
	LPIH323MediaCap pMediaCap = FindHostForID(FormatIDLocal);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;
	return pMediaCap->ResolveToLocalFormat (FormatIDLocal,pFormatIDRemote);

}
UINT CapsCtl::GetSimCapBufSize (BOOL bRxCaps)
{
   	UINT uSize;

	// get size of cached advertised sets if it exists and more than one media
	// type is enabled for publication
	if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)
	{
		// use size of cached buffer
		uSize = uAdvertizedSize;
	}
	else
	{
   		// calculate size of capability descriptors and simultaneous capability structures.

		#pragma message ("Figure out the size this needs to be...")
		#define NUMBER_TERMCAP_DESCRIPTORS 1
		uSize = sizeof(H245_TOTCAPDESC_T) * NUMBER_TERMCAP_DESCRIPTORS+
						  sizeof (CC_TERMCAPDESCRIPTORS)+NUMBER_TERMCAP_DESCRIPTORS*
						  sizeof (H245_TOTCAPDESC_T *);
	}				
   	return uSize;
}

UINT CapsCtl::GetNumCaps(BOOL bRXCaps)
{
	UINT u=0;
	if(pAudCaps && bAudioPublicize)
	{
		u = pAudCaps->GetNumCaps(bRXCaps);
	}
	if(pVidCaps && bVideoPublicize)
	{
		u += pVidCaps->GetNumCaps(bRXCaps);
	}
	if(bT120Publicize)
		u++;
	return u;
}

UINT CapsCtl::GetLocalSendParamSize(MEDIA_FORMAT_ID dwID)
{
	LPIH323MediaCap pMediaCap = FindHostForID(dwID);
	if(!pMediaCap)
		return 0;
	return (pMediaCap->GetLocalSendParamSize(dwID));
}
UINT CapsCtl::GetLocalRecvParamSize(PCC_TERMCAP pCapability)
{
	LPIH323MediaCap pMediaCap = FindHostForMediaType(pCapability);
	if(!pMediaCap)
		return 0;
	return (pMediaCap->GetLocalRecvParamSize(pCapability));
}

STDMETHODIMP CapsCtl::GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	LPIH323MediaCap pMediaCap = FindHostForID(FormatID);
	if(!pMediaCap)
	{
		*ppFormat = NULL;
		*puSize = 0;
		return E_INVALIDARG;
	}
	return pMediaCap->GetEncodeFormatDetails (FormatID, ppFormat, puSize);
}

STDMETHODIMP CapsCtl::GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	LPIH323MediaCap pMediaCap = FindHostForID(FormatID);
	if(!pMediaCap)
	{
		*ppFormat = NULL;
		*puSize = 0;
		return E_INVALIDARG;
	}
	return pMediaCap->GetDecodeFormatDetails (FormatID, ppFormat, puSize);
}

//
//  EnableMediaType controls whether or not capabilities for that media type
//  are publicized.  In a general implementation (next version?) w/ arbitrary
//	number  of media types, each of the media capability objects would keep
//  track of their own state.   This version of Capsctl tracks h323 audio and
//  video only
//

HRESULT CapsCtl::EnableMediaType(BOOL bEnable, LPGUID pGuid)
{
	if(!pGuid)
		return CAPS_E_INVALID_PARAM;
		
	if(*pGuid == MEDIA_TYPE_H323AUDIO)
	{
		bAudioPublicize = bEnable;
	}
	else if (*pGuid == MEDIA_TYPE_H323VIDEO)
	{
		bVideoPublicize = bEnable;
	}
	else
	{
		return CAPS_E_INVALID_PARAM;
	}
	return hrSuccess;
}
//
// Build the PCC_TERMCAPDESCRIPTORS list that we will advertise.
//
// puAudioFormatList/puVideoFormatList MUST BE sorted by preference!
//
//



HRESULT CapsCtl::AddCombinedEntry (MEDIA_FORMAT_ID *puAudioFormatList,UINT uAudNumEntries,MEDIA_FORMAT_ID *puVideoFormatList, UINT uVidNumEntries,DWORD *pIDOut)
{
   static USHORT dwLastIDUsed;
   DWORD x,y;
   BOOL bAllEnabled=TRUE,bRecv,bSend;
   unsigned short Length =0;	
	
   *pIDOut= (ULONG )CCO_E_SYSTEM_ERROR;
   //Validate the Input
   if ((!puAudioFormatList && uAudNumEntries > 0 ) || (!puVideoFormatList && uVidNumEntries > 0 ) || (uVidNumEntries == 0 && uAudNumEntries == 0 )) {
      //What error code should we return here?
      return CCO_E_SYSTEM_ERROR;
   }

   for (x=0;x<uAudNumEntries;x++)
   {
      ASSERT(pAudCaps);
      pAudCaps->IsFormatEnabled (puAudioFormatList[x],&bRecv,&bSend);
      bAllEnabled &= bRecv;

   }
   for (x=0;x<uVidNumEntries;x++) {
      ASSERT(pVidCaps);
      pVidCaps->IsFormatEnabled (puAudioFormatList[x],&bRecv,&bSend);
      bAllEnabled &= bRecv;
   }

   if (!bAllEnabled) {
      return CCO_E_INVALID_PARAM;
   }

   if (uAudNumEntries > H245_MAX_ALTCAPS || uVidNumEntries > H245_MAX_ALTCAPS) {
	  DEBUGMSG (1,("WARNING: Exceeding callcontrol limits!! \r\n"));
      return CCO_E_INVALID_PARAM;
   }

   //If this is the first call, allocate space
	if (!pAdvertisedSets){
	    pAdvertisedSets=(PCC_TERMCAPDESCRIPTORS)MemAlloc (sizeof (CC_TERMCAPDESCRIPTORS));
        if (!pAdvertisedSets){
	 		//Error code?
	 		return  CCO_E_SYSTEM_ERROR;
        }
        uAdvertizedSize = sizeof (CC_TERMCAPDESCRIPTORS);

        //Allocate space of NUM_SIMCAP_SETS
        pAdvertisedSets->pTermCapDescriptorArray=(H245_TOTCAPDESC_T **)
                MemAlloc (sizeof (H245_TOTCAPDESC_T *)*NUM_SIMCAP_SETS);
        if (!pAdvertisedSets->pTermCapDescriptorArray) {
	        //Error code?
	        return CCO_E_SYSTEM_ERROR;
        }

        //Update the indicies
        uAdvertizedSize += sizeof (H245_TOTCAPDESC_T *)*NUM_SIMCAP_SETS;
        dwNumInUse=NUM_SIMCAP_SETS;
        pAdvertisedSets->wLength=0;
    }

    //Find an Index to use.
    for (x=0;x<pAdvertisedSets->wLength;x++){
        if (pAdvertisedSets->pTermCapDescriptorArray[x] == NULL){
	        break;
        }
    }

    //Did we find space, or do we need a new one?
    if (x >= dwNumInUse) {
      	//Increment the number in use
       	dwNumInUse++;

        PVOID  pTempTermCapDescriptorArray = NULL;
        pTempTermCapDescriptorArray = MemReAlloc (pAdvertisedSets->pTermCapDescriptorArray,sizeof (H245_TOTCAPDESC_T *)*(dwNumInUse));

		if(pTempTermCapDescriptorArray)
		{
            pAdvertisedSets->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)pTempTermCapDescriptorArray;
		}
		else
		{
       		 return CCO_E_SYSTEM_ERROR;
		}

       	uAdvertizedSize += (sizeof (H245_TOTCAPDESC_T *)*(dwNumInUse))+sizeof (CC_TERMCAPDESCRIPTORS);
       	//Index is 0 based, point at the new entry
       	x=dwNumInUse-1;
    }


    //x is now the element we are using. Allocate space for a TermCapDescriptorArray
    pAdvertisedSets->pTermCapDescriptorArray[x]=(H245_TOTCAPDESC_T *)MemAlloc (sizeof (H245_TOTCAPDESC_T));
    if (!pAdvertisedSets->pTermCapDescriptorArray[x]){
        return CCO_E_SYSTEM_ERROR;
    }
    uAdvertizedSize += sizeof (H245_TOTCAPDESC_T);
    //Need to update the SetID. (start at 1)...
    pAdvertisedSets->pTermCapDescriptorArray[x]->CapDescId=++dwLastIDUsed;
    //Set the # of sets

    if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
    	Length++;
   	if(uVidNumEntries)
   		Length++;
   	if(uAudNumEntries)
   		Length++;
    pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.Length= Length;

   //Copy the Audio into SimCapArray[0], Video into SimCapArray[1] (if both)

    if ((uVidNumEntries > 0 && uAudNumEntries > 0)) {
        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].Length=(unsigned short)uAudNumEntries;
        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].Length=(unsigned short)uVidNumEntries;
        if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[2].Length=1;
        //Copy the format IDs
        for (y=0;y<uAudNumEntries;y++) {
            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].AltCaps[y]=(USHORT)puAudioFormatList[y];
        }
        for (y=0;y<uVidNumEntries;y++) {
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].AltCaps[y]=(USHORT)puVideoFormatList[y];
        }
        if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[2].AltCaps[0]= (H245_CAPID_T)m_localT120cap;


   } else {
        if (uAudNumEntries > 0)  {
            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].Length=(unsigned short)uAudNumEntries;
            if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].Length=1;
	        //Copy Audio only
	        for (y=0;y<uAudNumEntries;y++) {
	            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].AltCaps[y]=(USHORT)puAudioFormatList[y];
	        }
	        if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)	
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].AltCaps[0]= (H245_CAPID_T)m_localT120cap;

        } else {
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].Length=(unsigned short)uVidNumEntries;
            if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].Length=1;

	        //copy video entries
	        for (y=0;y<uVidNumEntries;y++) {
	            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].AltCaps[y]=(USHORT)puVideoFormatList[y];
	        }
	        if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].AltCaps[0]= (H245_CAPID_T)m_localT120cap;
        }
   }

   //Need to update the wLength
   pAdvertisedSets->wLength++;
   *pIDOut=dwLastIDUsed;

   return hrSuccess;
}


HRESULT CapsCtl::RemoveCombinedEntry (DWORD ID)
{

   DWORD x;

   if (!pAdvertisedSets) {
      return CAPS_E_INVALID_PARAM;
   }

   for (x=0;x<dwNumInUse;x++) {
      if (pAdvertisedSets->pTermCapDescriptorArray[x]) {

		if (pAdvertisedSets->pTermCapDescriptorArray[x]->CapDescId == ID) {
		   //Found the one to remove
		   MemFree ((VOID *)pAdvertisedSets->pTermCapDescriptorArray[x]);
		   uAdvertizedSize -= sizeof (H245_TOTCAPDESC_T *);
		   if (x != (dwNumInUse -1)) {
			  //Not the last one, swap the two pointers
			  pAdvertisedSets->pTermCapDescriptorArray[x]=pAdvertisedSets->pTermCapDescriptorArray[dwNumInUse-1];
			  pAdvertisedSets->pTermCapDescriptorArray[dwNumInUse-1]=NULL;
		   }

		   //Decrement the number in use, and set the wLengthField
		   dwNumInUse--;
		   pAdvertisedSets->wLength--;
		   return hrSuccess;
		}
	  }
   }


   //Shouldn't get here, unless it was not found.
   return CAPS_E_NOCAPS;
}


// Given a sized list of capability IDs (pointer to array of H245_CAPID_T)
// and a sized list of alternate capabilities (AltCaps) within a single simultaneous
// capability set, (pointer to an array of pointers to H245_SIMCAP_T)
// Determine if the entire list of capability IDs can simultaneously coexist
// with respect to the given set of AltCaps.

BOOL CapsCtl::AreSimCaps(
	H245_CAPID_T* pIDArray, UINT uIDArraySize,
	H245_SIMCAP_T **ppAltCapArray,UINT uAltCapArraySize)
{
	UINT i, u;
	SHORT j;
	BOOL bSim;
	
	H245_SIMCAP_T *pAltCapEntry, *pFirstAltCapEntry;

	// If there are fewer AltCaps than capabilities, doom is obvious.  Don't bother searching.
	if(uAltCapArraySize < uIDArraySize)
		return FALSE;
	
	// find an altcaps entry containing the first ID in the list
	for (i=0;i<uAltCapArraySize;i++)
	{
		pAltCapEntry = *(ppAltCapArray+i);
		// scan this altcaps entry for a matching ID
		for(j=0;j<pAltCapEntry->Length;j++)
		{
			if(*pIDArray == pAltCapEntry->AltCaps[j])
			{
				// found a spot for this capability!
				if(uIDArraySize ==1)
					return TRUE; // Done! all the capabilities have been found to coexist
		
				// Otherwise, look for the next capability in the *remaining* AltCaps
				// *This* AltCaps contains the capability we were looking for
				// So, we "used up" this AltCaps and can't select from it anymore

				// Pack the array of H245_SIMCAP_T pointers in place so that
				// "used" entries are at the beginning and "unused" at the end
				// (a la shell sort swap pointers)
				if(i != 0)	// if not already the same, swap
				{
					pFirstAltCapEntry = *ppAltCapArray;
					*ppAltCapArray = pAltCapEntry;
					*(ppAltCapArray+i) = pFirstAltCapEntry;
				}
				// continue the quest using the remaining capabilities
				// and the remaining AltCaps
				bSim = AreSimCaps(pIDArray + 1, uIDArraySize - 1,
					ppAltCapArray + 1,  uAltCapArraySize - 1);
				
				if(bSim)		
				{
					return bSim;// success
				}
				else	// why not?  Either a fit does not exist (common), or the altcaps contain
						// an odd pattern of multiple instances of some capability IDs, and another
						// search order *might* fit.  Do not blindly try all permutations of search
						// order.
				{
					// If it failed simply because the recently grabbed slot in the altcaps
					// (the one in *(ppAltCapArray+i)) could have been needed by subsequent
					// capability IDs, give this one up and look for another instance.
					// If not, we know for sure that the n! approach will not yield
					// fruit and can be avoided.
					for(u=1;(bSim == FALSE)&&(u<uAltCapArraySize);u++)
					{
						for(j=0;(bSim == FALSE)&&(j<pAltCapEntry->Length);j++)
						{	// another capability needed the altcaps we grabbed ?
							if(*(pIDArray+u) == pAltCapEntry->AltCaps[j])	
							{	
								bSim=TRUE;
								break;	// look no more here, bail to try again	because a fit *might* exist
							}
						}
					}
					if(bSim)	// going to continue searching - Swap pointers back if they were swapped above
					{
						if(i != 0)	// if not the same, swap back
						{
							*ppAltCapArray = *(ppAltCapArray+i);
							*(ppAltCapArray+i) = pAltCapEntry;
						}		
						break;	// next i
					}
					else	// don't waste CPU - a fit does not exist
					{
						return bSim;
					}
				}
			}
		}
	}
	return FALSE;
}

// Given a sized list of capability IDs (pointer to array of H245_CAPID_T)
// and a list of simultaneous capabilities, try each simultaneous capability
// and determine if the entire list of capability IDs can simultaneously coexist.
BOOL CapsCtl::TestSimultaneousCaps(H245_CAPID_T* pIDArray, UINT uIDArraySize,
	PCC_TERMCAPDESCRIPTORS pTermCaps)
{
	int iSimSet, iAltSet;
	BOOL bResolved = FALSE;
	H245_SIMCAP_T * pAltCapArray[H245_MAX_SIMCAPS];
	
    if (!pAdvertisedSets)
        return(TRUE);

	// try each independent local SimCaps set (each descriptor) until success
	for (iSimSet=0; (bResolved == FALSE) && (iSimSet < pTermCaps->wLength);iSimSet++)
	{
		// EXTRA STEP:
		// Build a sortable representation of the AltCaps set.  This step will not be necessary if
		// and when we change the native representation of a capability descriptor to a variable
		// length list of pointers to AltCaps.  In the meantime, we know that there are no more
		// than H245_MAX_SIMCAPS AltCaps in this SimCaps.  This is imposed by the 2 dimensional
		// arrays of hardcoded size forced upon us by CALLCONT.DLL.
		for (iAltSet=0;iAltSet < pTermCaps->pTermCapDescriptorArray[iSimSet]->CapDesc.Length;iAltSet++)
		{
			pAltCapArray[iAltSet] = &pTermCaps->pTermCapDescriptorArray[iSimSet]->CapDesc.SimCapArray[iAltSet];
	   	}
		// do the work		
		bResolved = AreSimCaps(pIDArray, uIDArraySize,
			(H245_SIMCAP_T **)pAltCapArray,
			MAKELONG(pTermCaps->pTermCapDescriptorArray[iSimSet]->CapDesc.Length, 0));
	}

	return bResolved;
}

// Function: CapsCtl::ResolvePermutations(PRES_CONTEXT pResContext, UINT uNumFixedColumns)
//
// This functions as both a combination generator and a validation mechanism for the
// combinations it generates.
//
// Given a pointer to a resolution context and the number of fixed (i.e. not permutable,
// if "permutable" is even a real word) columns, generate one combination at a time.
// Try each combination until a working combination is found or until all combinations
// have been tried.
//
// The resolution context structure contains a variable number of columns of variable
// length media format ID lists. Each column tracks its current index.  When this
// function returns TRUE, the winning combination is indicated by the current column
// indices.
//
// The caller can control which combinations are tried first by arranging the columns
// in descending importance.
//
// Incremental searches can be performed without redundant comparisons by adding 1 format
// at a time to a column, arranging the column order so that the appended column is
// first, and "fixing" that one column at the newly added format. For example,
// some calling function could force evaluations on a round-robin column basis by
// calling this function inside a loop which does the following:
//		1 - adds one format at a time to the rightmost column and sets the current index
//			of that column to the new entry
// 		2 - rotates the column order so that the rightmost column is now the leftmost
//  	3 - fixing the new leftmost column before calling this function again
//	The result will be that only the permutations which contain the newly added format
// 	will be generated.


BOOL CapsCtl::ResolvePermutations(PRES_CONTEXT pResContext, UINT uNumFixedColumns)
{
	RES_PAIR *pResolvedPair;
	BOOL bResolved = FALSE;
	UINT i, uColumns;
	UINT uPairIndex;

	// converge on one combination in the permutation
	if(uNumFixedColumns != pResContext->uColumns)
	{
		RES_PAIR_LIST *pThisColumn;
		// take the first non-fixed column, make that column fixed and
		// iterate on it (loop through indices), and try each sub-permutation
		// of remaining columns.  (until success or all permutations tried)
		
		pThisColumn = *(pResContext->ppPairLists+uNumFixedColumns);
		for (i=0; (bResolved == FALSE) && (i<pThisColumn->uSize); i++)
		{
			pThisColumn->uCurrentIndex = i;
			bResolved = ResolvePermutations(pResContext, uNumFixedColumns+1);
		}
		return bResolved;
	}
	else
	{
		// Bottomed out on the final column.  Test the viability of this combination
		
		// Build array of local IDs that contians the combination and test the
		// combination against local simultaneous capabilities, then against
		// remote simultaneous capabilities
		
		// NOTE: be sure to skip empty columns (which represent unresolvable
		// or unsupported/nonexistent media types or unsupported additional
		// instances of media types)
		
		for(i=0, uColumns=0;i<pResContext->uColumns;i++)
		{
			if(((*pResContext->ppPairLists)+i)->uSize)
			{
				// get index (row #) for this column
				uPairIndex = ((*pResContext->ppPairLists)+i)->uCurrentIndex;
				// get the row
				pResolvedPair =  ((*pResContext->ppPairLists)+i)->pResolvedPairs+uPairIndex;
				// add the ID to the array
				*(pResContext->pIDScratch+uColumns) = (H245_CAPID_T)pResolvedPair->idPublicLocal;
				uColumns++;
			}
			// else empty column
		}
		// Determine if this combination can exist simultaneously
		if(TestSimultaneousCaps(pResContext->pIDScratch,
			uColumns, pResContext->pTermCapsLocal))
		{	
			// now test remote
			// build array of remote IDs and test those against remote
			// simultaneous capabilities
			for(i=0, uColumns=0;i<pResContext->uColumns;i++)
			{
				if(((*pResContext->ppPairLists)+i)->uSize)
				{
					// get index (row #) for this column
					uPairIndex = ((*pResContext->ppPairLists)+i)->uCurrentIndex;
					// get the row
					pResolvedPair =  ((*pResContext->ppPairLists)+i)->pResolvedPairs+uPairIndex;
					// add the ID to the array
					*(pResContext->pIDScratch+uColumns) =(H245_CAPID_T) pResolvedPair->idRemote;
					uColumns++;
				}
				// else empty column
			}
			bResolved = TestSimultaneousCaps(pResContext->pIDScratch,
				uColumns, pResContext->pTermCapsRemote);
		}
					
		return bResolved;		
		// if(bResolved == TRUE)
			// The resolved combination of pairs is indicated by the current indices
			// of **ppPairList;
	}
}

//
// Given a counted list of desired instances of media, produce an output array of
// resolved media format IDs which correspond to the input media type IDs.
// This function returns success if at least one media instance is resolved.
// When an instance of media is unresolveable, the output corresponding to that
// instance contains the value INVALID_MEDIA_FORMAT for local and remote media
// format IDs.
//
// The input is treated as being in preferential order: permutations of the latter
// media type instance are varied first. If all permutations do not yield success,
// then one media type instance at a time is removed from the end.
//

HRESULT CapsCtl::ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia,
	PRES_PAIR pResOutput)
{
	HRESULT hr = hrSuccess;
	PRES_PAIR_LIST pResColumnArray = NULL;
	PRES_PAIR_LIST *ppPairLists;
	RES_PAIR *pResPair;
	PRES_CONTEXT pResContext;
	LPIH323MediaCap pMediaResolver;
	UINT i;
	UINT uMaxFormats = 0;
	UINT uFixedColumns =0;
	UINT uFailedMediaCount = 0;
	BOOL bResolved = FALSE;
	
	RES_PAIR UnresolvedPair = {INVALID_MEDIA_FORMAT, INVALID_MEDIA_FORMAT, INVALID_MEDIA_FORMAT};
	// create a context structure for the resolution
	pResContext = (PRES_CONTEXT)MemAlloc(sizeof(RES_CONTEXT)+ (uNumMedia*sizeof(H245_CAPID_T)));
	if(!pResContext)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;
	}
	// initialize resolution context
	pResContext->uColumns = 0;
	pResContext->pIDScratch = (H245_CAPID_T*)(pResContext+1);
	pResContext->pTermCapsLocal = pAdvertisedSets;
	pResContext->pTermCapsRemote = pRemAdvSets;

	// allocate array of RES_PAIR_LIST (one per column/media type) and
	// array of pointers to same
	pResColumnArray = (PRES_PAIR_LIST)MemAlloc((sizeof(RES_PAIR_LIST) * uNumMedia)
		+ (sizeof(PRES_PAIR_LIST) * uNumMedia));
	if(!pResColumnArray)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;
	}
	pResContext->ppPairLists = ppPairLists = (PRES_PAIR_LIST*)(pResColumnArray+uNumMedia);
			
	// build columns of media capabilities
	for(i=0;i<uNumMedia;i++)
	{
		// build array of pointers to RES_PAIR_LIST
		*(ppPairLists+i) = pResColumnArray+i;
		// initialize RES_PAIR_LIST members
		(pResColumnArray+i)->pResolvedPairs = NULL;
		(pResColumnArray+i)->uSize =0;
		(pResColumnArray+i)->uCurrentIndex = 0;

		// Get resolver for this media. Special case: there is no T120 resolver.
		// T120 caps are handled right here in this object
		if(MEDIA_TYPE_H323_T120 == *(pMediaGuidArray+i))
		{
			pMediaResolver = NULL;
			if((m_localT120cap != INVALID_MEDIA_FORMAT) &&(m_remoteT120cap != INVALID_MEDIA_FORMAT) )
			{
				(pResColumnArray+i)->uSize =1;
				uMaxFormats = 1;	// only one T.120 cap
				
				pResPair = (pResColumnArray+i)->pResolvedPairs =
					(RES_PAIR *)MemAlloc(uMaxFormats * sizeof(RES_PAIR));
				if(!pResPair)
				{
					hr = CAPS_E_NOMEM;
					goto ERROR_OUT;
				}
				
				//
				pResPair->idLocal = m_localT120cap;
				pResPair->idRemote = m_remoteT120cap;
				pResPair->idPublicLocal = pResPair->idLocal;
			}
		}
		else
		{
			pMediaResolver = FindHostForMediaGuid(pMediaGuidArray+i);
		}
			
		pResContext->uColumns++;
		(pResColumnArray+i)->pMediaResolver = pMediaResolver;
		
		if(pMediaResolver)
		{
			uMaxFormats = pMediaResolver->GetNumCaps(FALSE);	// get transmit format count
			if(uMaxFormats)
			{
				pResPair = (pResColumnArray+i)->pResolvedPairs =
					(RES_PAIR *)MemAlloc(uMaxFormats * sizeof(RES_PAIR));
				if(!pResPair)
				{
					hr = CAPS_E_NOMEM;
					goto ERROR_OUT;
				}
				
				// resolve the best choice for each media type (gotta start somewhere)
				pResPair->idLocal = INVALID_MEDIA_FORMAT;
				pResPair->idRemote = INVALID_MEDIA_FORMAT;		
				hr=pMediaResolver->ResolveEncodeFormat (&pResPair->idLocal,&pResPair->idRemote);
				if(!HR_SUCCEEDED(hr))
				{
					if((hr == CAPS_W_NO_MORE_FORMATS)	
						|| (hr == CAPS_E_NOMATCH)
						|| (hr == CAPS_E_NOCAPS))
					{	
						// No resolved format for this media type.  Remove this "column"
						(pResColumnArray+i)->pResolvedPairs = NULL;
						MemFree(pResPair);
						(pResColumnArray+i)->uSize =0;

						hr = hrSuccess;
					}
					else
					{
						goto ERROR_OUT;
					}
				}
				else
				{
					// this column has one resolved format
					pResPair->idPublicLocal = pMediaResolver->GetPublicID(pResPair->idLocal);
					(pResColumnArray+i)->uSize =1;
				}
			}
			// else // No formats exist for this media type.  this "column" has zero size
		}
	}

	// Special case test simultaneous caps for the most preferred combination:
	uFixedColumns = pResContext->uColumns;	// << make all columns fixed
	bResolved = ResolvePermutations(pResContext, uFixedColumns);

	// if the single most preferred combination can't be used, need to handle
	// the general case and try permutations until a workable combination is found
	while(!bResolved)
	{
		// make one column at a time permutable, starting with the least-critical media
		// type.  (e.g. it would be typical for the last column to be video because
		// audio+data are more important. Then we try less and less
		// preferable video formats before doing anything that would degrade the audio)

		if(uFixedColumns > 0)	// if not already at the end of the rope...
		{
			uFixedColumns--;	// make another column permutable
		}
		else
		{
			// wow - tried all permutations and still no luck ......
			// nuke the least important remaining media type (e.g. try it w/o video)
			if(pResContext->uColumns <= 1)	// already down to one media type?
			{
				hr = CAPS_E_NOMATCH;
				goto ERROR_OUT;
			}
			// Remove the end column (representing the least important media type)
			// and try it with the remaining columns			
			uFixedColumns = --pResContext->uColumns; 	// one less column

			// set the formats of the nuked column to the unresolved state
			(pResColumnArray+uFixedColumns)->uSize =0;
			(pResColumnArray+uFixedColumns)->uCurrentIndex =0;
			pResPair = (pResColumnArray+uFixedColumns)->pResolvedPairs;
			if (NULL != pResPair)
			{
				pResPair->idLocal = INVALID_MEDIA_FORMAT;
				pResPair->idRemote = INVALID_MEDIA_FORMAT;
				pResPair->idPublicLocal = INVALID_MEDIA_FORMAT;
			}

			uFailedMediaCount++;	// track the nuking of a column to avoid
									// redundantly grabbing all the formats again
									// ... would not be here if all permutations
									// had not been tried!
			// reset the combination indices
			for(i=0;i<uFixedColumns;i++)
			{
				(pResColumnArray+i)->uCurrentIndex = 0;
			}
		}
		
		// get the rest of the formats for the last known fixed column, make that column
		// permutable, etc.
		pMediaResolver = (pResColumnArray+uFixedColumns)->pMediaResolver;
		if(!pMediaResolver || ((pResColumnArray+uFixedColumns)->uSize ==0))
		{
			continue;	// this media type has no further possibility
		}

 		if(uFailedMediaCount ==0)	// If all of the possible resolved pairs
 									// have not yet been obtained, get them!
 		{
 			// get resolved pair IDs for every mutual format of this media type
			// first: get pointer to array of pair IDs, then use ResolveEncodeFormat()
			// to fill up the array
			pResPair =  (pResColumnArray+uFixedColumns)->pResolvedPairs;
			// Get total # of formats less the one that was already obtained
			uMaxFormats = pMediaResolver->GetNumCaps(FALSE) -1;	
			
			while(uMaxFormats--)	// never exceed the # of remaining local formats...
			{
				RES_PAIR *pResPairNext;
						
				// recall that ResolveEncodeFormat parameters are I/O - the input
				// is the local ID of the last resolved mutual format.  (remote id
				// is ignored as input).  Fixup the input.
				pResPairNext = pResPair+1;
				// start where the previous resolve stopped
				pResPairNext->idLocal = pResPair->idLocal;	
				// not necessary, ignored ->>> pResPairNext->idRemote = pResPair->idRemote
				pResPair = pResPairNext;
				hr=pMediaResolver->ResolveEncodeFormat (&pResPair->idLocal,&pResPair->idRemote);
				if((hr == CAPS_W_NO_MORE_FORMATS)	
					|| (hr == CAPS_E_NOMATCH))
				// got all of the formats, but not an error
				{	// this is likely when less than 100% of local formats have a remote match
					hr = hrSuccess;
					break;
				}	
				if(!HR_SUCCEEDED(hr))
					goto ERROR_OUT;

				// get the public ID of the local format (it's *usually* the same, but not always)
				pResPair->idPublicLocal = pMediaResolver->GetPublicID(pResPair->idLocal);
				// this column has another format - count it!
				(pResColumnArray+uFixedColumns)->uSize++;
			}
		}
		// now try the new permutations
		bResolved = ResolvePermutations(pResContext, uFixedColumns);
	}
	if(bResolved)
	{
		// spew the output
		for(i=0;i<uNumMedia;i++)
		{
			if((pResColumnArray+i)->uSize)
			{
				pResPair = (pResColumnArray+i)->pResolvedPairs
					+ (pResColumnArray+i)->uCurrentIndex;
			}
			else
			{
				pResPair = &UnresolvedPair;

			}
			*(pResOutput+i) = *pResPair;
		}
	}
	else
	{
		// if there was some error, preserve that error code,
		if(HR_SUCCEEDED(hr))	
		// otherwise the error is....
			hr = CAPS_E_NOMATCH;		
	}

ERROR_OUT:	// well, the success case falls out here too
	if(pResColumnArray)
	{
		for(i=0;i<uNumMedia;i++)
		{	
			if((pResColumnArray+i)->pResolvedPairs)
				MemFree((pResColumnArray+i)->pResolvedPairs);
		}
		MemFree(pResColumnArray);
	}
	if(pResContext)
	{
		MemFree(pResContext);
	}
	return hr;
}

HRESULT CapsCtl::ResetCombinedEntries (void)
{
    DWORD x;

    if (pAdvertisedSets)
    {
        for (x = 0; x < pAdvertisedSets->wLength; x++)
        {
            if (pAdvertisedSets->pTermCapDescriptorArray[x])
            {
	    	    MemFree (pAdvertisedSets->pTermCapDescriptorArray[x]);
            }
        }
        MemFree (pAdvertisedSets->pTermCapDescriptorArray);

        pAdvertisedSets->wLength=0;
        MemFree (pAdvertisedSets);
        pAdvertisedSets = NULL;
    }

    if (pSetIDs)
    {
        MemFree(pSetIDs);
        pSetIDs = NULL;
    }

    dwNumInUse=0;
    uAdvertizedSize=0;

    return hrSuccess;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\commchan.h ===
/*
 *  	File: commchan.h
 *
 *      Network media channel interface implementation
 *
 *		Revision History:
 *
 *		10/09/96	mikev	created
 */


#ifndef _COMMCHAN_H
#define _COMMCHAN_H


#ifdef COARSE_PROFILE
	typedef struct {
		DWORD dwStart;
		DWORD dwLast;
// 		DWORD dwElapsed;	// to take advantage of thread timers
	}CP_TIME;

#define CPT_LOCAL CP_TIME _cpt_
#define OBJ_CPT CP_TIME m_cpt_

#define OBJ_CPT_RESET	m_cpt_.dwStart = m_cpt_.dwLast = GetTickCount()
#define OBJ_ETIME		((m_cpt_.dwLast = GetTickCount()) - m_cpt_.dwStart)
#define OBJ_ETIME_RESET	m_cpt_.dwStart = m_cpt_.dwLast
	// tricky macro
#define OBJ_NEW_ETIME	((m_cpt_.dwLast = GetTickCount()) - m_cpt_.dwStart); m_cpt_.dwStart = m_cpt_.dwLast

// SHOW_OBJ_ETIME snaps elapsed time since last show or reset, then resets
	#ifdef DEBUG
		#define SHOW_OBJ_ETIME(s) DEBUGMSG(ZONE_PROFILE,("\r\n** (%s) ELAPSED TIME(ms):%d, ticks:%d **\r\n", \
			(s), OBJ_ETIME, m_cpt_.dwLast)); OBJ_ETIME_RESET

	#else
		#define SHOW_OBJ_ETIME(s) RETAILMSG(("\r\n** (%s) ELAPSED TIME(ms):%d, ticks:%d **\r\n", \
			(s), OBJ_ETIME, m_cpt_.dwLast )); OBJ_ETIME_RESET
	#endif

#else	// not COARSE_PROFILE
#define CPT_LOCAL
#define CPT_RESET
#define CPT_DELTA
#define OBJ_CPT
#define OBJ_CPT_RESET
#define OBJ_NEW_ETIME
#define SHOW_OBJ_ETIME(s)
#endif	// COARSE_PROFILE


#undef INTERFACE
#define INTERFACE ICtrlCommChan
DECLARE_INTERFACE_(ICtrlCommChan, IUnknown)
{
    STDMETHOD(StandbyInit)(LPGUID lpMID, LPIH323PubCap pCapObject,
	    IMediaChannel* pMediaStreamSend) PURE;
	STDMETHOD_(BOOL, Init)(LPGUID lpMID, IH323ConfAdvise *pH323ConfAdvise,
	    BOOL fSendDirection) PURE;

    STDMETHOD(GetMediaType)(LPGUID pGuid) PURE;
    // EnableOpen is needed temporaraily until NMCOM is master of channels
    STDMETHOD(EnableOpen)(BOOL bEnable) PURE;
    // The CtrlChanSetProperty() method is only used for 4 things:
    // 1&2 - (Boolean) local and remote Temporal/Spatial tradeoff capability,
    // 3&4 (word) local & remote Temporal/Spatial tradeoff value
	STDMETHOD(CtrlChanSetProperty)(THIS_ DWORD prop, PVOID pBuf, DWORD cbBuf)PURE;

	STDMETHOD( PauseNet)(THIS_ BOOL bPause, BOOL bRemote) PURE;
	STDMETHOD( BeginControlSession)(IControlChannel *pCtlChan, LPIH323PubCap pCapObject) PURE;
	STDMETHOD( EndControlSession)(THIS)  PURE;
   	STDMETHOD_(IControlChannel *, GetControlChannel)(THIS) PURE;

	STDMETHOD( OnChannelOpening)(THIS)  PURE;
	STDMETHOD( OnChannelOpen)(THIS_ DWORD dwStatus) PURE;
	STDMETHOD( OnChannelClose)(THIS_ DWORD dwStatus) PURE;
   	STDMETHOD_(UINT, Reset) (THIS) PURE;
   	
	STDMETHOD_(BOOL, SelectPorts) (THIS_ LPIControlChannel pCtlChannel) PURE;
	STDMETHOD_(PSOCKADDR_IN, GetLocalAddress)(THIS) PURE;
	STDMETHOD_(	PORT, GetLocalRTPPort) (THIS) PURE;
	STDMETHOD_(	PORT, GetLocalRTCPPort) (THIS) PURE;
	
	STDMETHOD( AcceptRemoteAddress) (THIS_ PSOCKADDR_IN pSinD) PURE;
	STDMETHOD( AcceptRemoteRTCPAddress) (THIS_ PSOCKADDR_IN pSinC) PURE;
	
	STDMETHOD_(BOOL, IsChannelOpen)(THIS) PURE;
	STDMETHOD_(BOOL, IsOpenPending)(THIS) PURE;
    STDMETHOD_(BOOL, IsSendChannel) (THIS) PURE;
	STDMETHOD_(BOOL, IsChannelEnabled) (THIS) PURE;
	
	STDMETHOD( ConfigureCapability)(THIS_ LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
		LPVOID lpvLocalParams, UINT uLocalParamSize) PURE;
	STDMETHOD( GetLocalParams)(THIS_ LPVOID lpvChannelParams, UINT uBufSize) PURE;
	STDMETHOD_(LPVOID, GetRemoteParams)(THIS) PURE;
 	STDMETHOD_(VOID, SetNegotiatedLocalFormat)(THIS_ DWORD dwF) PURE;
	STDMETHOD_(VOID, SetNegotiatedRemoteFormat)(THIS_ DWORD dwF) PURE;
	
	// GetHChannel, SetHChannel simply store and retrieve a handle.  This is an Intel
	// call control handle.
   	STDMETHOD_(DWORD_PTR, GetHChannel) (THIS) PURE;
    STDMETHOD_(VOID, SetHChannel) (THIS_ DWORD_PTR dwSetChannel) PURE;	
};




class ImpICommChan : public ICommChannel, public ICtrlCommChan, public IStreamSignal
{

protected:
    UINT m_uRef;
	GUID m_MediaID;
	BOOL bIsSendDirection;		// true if send, false if receive
	OBJ_CPT;		// profiling timer
	LPVOID pRemoteParams;
	LPVOID pLocalParams;
	UINT uLocalParamSize;
	// so far there is no reason to remember size of remote params.
	
protected:
	IMediaChannel *m_pMediaStream;
	IRTPSession *m_pRTPChan;
	IControlChannel *m_pCtlChan;
	LPIH323PubCap m_pCapObject;
	
	IH323ConfAdvise *m_pH323ConfAdvise;
	
	DWORD m_dwFlags;
	#define COMCH_ENABLED        0x00000010		// enabled. (ok to attempt or accept open)
 	#define COMCH_OPEN_PENDING              0x00008000 										
	#define COMCH_STRM_STANDBY	            0x00010000		// preview needs to be on always
	#define COMCH_STRM_LOCAL	            0x00020000
	#define COMCH_STRM_NETWORK	            0x00040000
	#define COMCH_OPEN			            0x00080000
	#define COMCH_RESPONSE_PENDING	        0x00100000
	#define COMCH_SUPPRESS_NOTIFICATION     0x00200000
	#define COMCH_STRM_REMOTE	            0x00400000	
	#define COMCH_PAUSE_LOCAL	            0x00800000	
	#define COMCH_STRM_CONFIGURE_STANDBY	0x01000000		// stream needs to remain configured
	
	#define IsComchOpen() (m_dwFlags & COMCH_OPEN)
	#define IsStreamingStandby() (m_dwFlags & COMCH_STRM_STANDBY)
	#define IsConfigStandby() (m_dwFlags & COMCH_STRM_CONFIGURE_STANDBY)

	#define IsStreamingLocal() (m_dwFlags & COMCH_STRM_LOCAL)
	#define IsStreamingRemote() (m_dwFlags & COMCH_STRM_REMOTE)

	#define IsStreamingNet() (m_dwFlags & COMCH_STRM_NETWORK)
	#define IsResponsePending() (m_dwFlags & COMCH_RESPONSE_PENDING)
	#define IsNotificationSupressed() (m_dwFlags & COMCH_SUPPRESS_NOTIFICATION)
		
	#define StandbyFlagOff() (m_dwFlags &= ~COMCH_STRM_STANDBY)
	#define StandbyFlagOn() (m_dwFlags |= COMCH_STRM_STANDBY)
	#define StandbyConfigFlagOff() (m_dwFlags &= ~COMCH_STRM_CONFIGURE_STANDBY)
	#define StandbyConfigFlagOn() (m_dwFlags |= COMCH_STRM_CONFIGURE_STANDBY)

	#define LocalStreamFlagOff() (m_dwFlags &= ~COMCH_STRM_LOCAL)
	#define LocalStreamFlagOn() (m_dwFlags |= COMCH_STRM_LOCAL)
	#define RemoteStreamFlagOff() (m_dwFlags &= ~COMCH_STRM_REMOTE)
	#define RemoteStreamFlagOn() (m_dwFlags |= COMCH_STRM_REMOTE)
	
	#define LocalPauseFlagOff() (m_dwFlags &= ~COMCH_PAUSE_LOCAL)
	#define LocalPauseFlagOn() (m_dwFlags |= COMCH_PAUSE_LOCAL)
	#define IsPausedLocal() (m_dwFlags & COMCH_PAUSE_LOCAL)

	#define StreamFlagsOff() (m_dwFlags &= ~(COMCH_STRM_LOCAL | COMCH_STRM_NETWORK))
	#define StreamFlagsOn() (m_dwFlags |= (COMCH_STRM_LOCAL | COMCH_STRM_NETWORK))
	#define NetworkStreamFlagOff() (m_dwFlags &= ~COMCH_STRM_NETWORK)
	#define NetworkStreamFlagOn() (m_dwFlags |= COMCH_STRM_NETWORK)
	#define ResponseFlagOn() (m_dwFlags |= COMCH_RESPONSE_PENDING)
	#define ResponseFlagOff() (m_dwFlags &= ~COMCH_RESPONSE_PENDING)
	#define SuppressNotification() (m_dwFlags |= COMCH_SUPPRESS_NOTIFICATION)
	#define AllowNotifications() (m_dwFlags &= ~COMCH_SUPPRESS_NOTIFICATION)

	
		
	MEDIA_FORMAT_ID m_LocalFmt;	// format ID of what we are sending or receiving
	MEDIA_FORMAT_ID m_RemoteFmt;// remote's format ID of the complimentary format
	DWORD m_TemporalSpatialTradeoff;	// For send channels, this is the local value.
									// For receive channels, this is the remote value.
									// A magic number between 1 and 31 that describes
									// the relative tradeoff between compression and
									// bitrate.  This is part of H.323/H.245.
									// The ITU decided on the weird range.
									
	BOOL m_bPublicizeTSTradeoff;	// For send channels, this indicates our willingness
									// to accept remote control of T/S tradeoff, and
									// also signal changes in our local TS value to
									// the remote.
									// For receive channels, it indicates the remote's
									// willingness.
    DWORD m_dwLastUpdateTick;       // tick count of last attempt to request I-Frame
    #define MIN_IFRAME_REQ_TICKS    5000    // minimum #of elapsed ticks between requests

	DWORD_PTR	dwhChannel; //General purpose handle.  Whatever
	// creates an instance of this class can use this for whatever it wants

	STDMETHODIMP StreamStandby(BOOL bStandby);
    STDMETHODIMP ConfigureStream(MEDIA_FORMAT_ID idLocalFormat);
public:	

// ICtrlCommChannel methods
   	STDMETHODIMP_(IControlChannel *) GetControlChannel(VOID) {return m_pCtlChan;};
    STDMETHODIMP StandbyInit(LPGUID lpMID, LPIH323PubCap pCapObject,
	    IMediaChannel* pMediaStreamSend);

    STDMETHODIMP_(BOOL) Init(LPGUID lpMID, IH323ConfAdvise *pH323ConfAdvise, BOOL fSendDirection)
	{
    	m_MediaID = *lpMID;
		bIsSendDirection = fSendDirection;
		m_pH323ConfAdvise = pH323ConfAdvise;
		return TRUE;
	};


    STDMETHODIMP CtrlChanSetProperty(DWORD prop, PVOID pBuf, DWORD cbBuf);
    STDMETHODIMP PauseNet(BOOL bPause, BOOL bRemote);
    STDMETHODIMP BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject);
    STDMETHODIMP EndControlSession();
    STDMETHODIMP OnChannelOpening();
    STDMETHODIMP OnChannelOpen(DWORD dwStatus);
    STDMETHODIMP OnChannelClose(DWORD dwStatus);
    STDMETHODIMP_(UINT) Reset(VOID);

    STDMETHODIMP_(BOOL) SelectPorts(LPIControlChannel pCtlChannel);
    STDMETHODIMP_(PSOCKADDR_IN) GetLocalAddress();
    STDMETHODIMP_(PORT) GetLocalRTPPort();
    STDMETHODIMP_(PORT) GetLocalRTCPPort ();
    STDMETHODIMP AcceptRemoteAddress (PSOCKADDR_IN pSinD);
    STDMETHODIMP AcceptRemoteRTCPAddress(PSOCKADDR_IN pSinC);

    STDMETHODIMP_(BOOL) IsSendChannel () {return bIsSendDirection;};
    STDMETHODIMP_(BOOL) IsChannelOpen(){return ((m_dwFlags & COMCH_OPEN) !=0);};
    STDMETHODIMP_(BOOL) IsOpenPending(){return ((m_dwFlags & COMCH_OPEN_PENDING ) !=0);};
    STDMETHODIMP_(BOOL) IsChannelEnabled(){return ((m_dwFlags & COMCH_ENABLED ) !=0);};

    STDMETHODIMP ConfigureCapability(LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
        LPVOID lpvLocalParams, UINT uLocalParamSize);
    STDMETHODIMP GetLocalParams(LPVOID lpvChannelParams, UINT uBufSize);
    STDMETHODIMP_(PVOID) GetRemoteParams(VOID) {return pRemoteParams;}
    STDMETHODIMP_(VOID) SetNegotiatedLocalFormat(DWORD dwF) {m_LocalFmt = dwF;};
    STDMETHODIMP_(VOID) SetNegotiatedRemoteFormat(DWORD dwF) {m_RemoteFmt = dwF;};
    STDMETHODIMP_(DWORD_PTR) GetHChannel(VOID) {return dwhChannel;};
    STDMETHODIMP_(VOID) SetHChannel (DWORD_PTR dwSetChannel) {dwhChannel = dwSetChannel;};	

// ICommChannel Methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef());
    STDMETHOD_(ULONG,Release());

    STDMETHOD(GetProperty(DWORD prop, PVOID pBuf, LPUINT pcbBuf));
    STDMETHOD(SetProperty(DWORD prop, PVOID pBuf, UINT cbBuf));
    STDMETHOD(IsChannelOpen(BOOL *pbOpen));
    STDMETHOD(Open(MEDIA_FORMAT_ID idLocalFormat,IH323Endpoint *pConnection));
    STDMETHOD(Close());
    STDMETHOD(SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));
    STDMETHOD(EnableOpen(BOOL bEnable));
    STDMETHODIMP GetMediaType(LPGUID pGuid);
    STDMETHODIMP_(IMediaChannel *) GetMediaChannel(VOID) {return m_pMediaStream;};
    STDMETHOD(Preview(MEDIA_FORMAT_ID idLocalFormat, IMediaChannel * pMediaChannel));
    STDMETHOD(PauseNetworkStream(BOOL fPause));
    STDMETHOD_(BOOL, IsNetworkStreamPaused(VOID));
    STDMETHOD_(BOOL, IsRemotePaused(VOID));
    STDMETHODIMP_(MEDIA_FORMAT_ID) GetConfiguredFormatID() {return m_LocalFmt;};
	STDMETHODIMP GetRemoteAddress(PSOCKADDR_IN pAddrOutput);
// IStreamSignal Methods
    STDMETHOD(PictureUpdateRequest());
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO* ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));

	ImpICommChan ();
 	~ImpICommChan ();
};

#endif	// _ICOMCHAN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\cmember.h ===
/*
 *  	File: cmember.h
 *
 *     
 *
 *		Revision History:
 *
 *		05/29/98	mikev	created
 */


#ifndef _CMEMBER_H
#define _CMEMBER_H


/*
 *	Class definitions
 */


class CH323Member
{

private:

//	IControlChannel 	*m_pControlChannel;     //  reference to control channel 
	                                            // (needed only if this is the MC)
	
    LPWSTR m_pTerminalID;
    CC_TERMINAL_LABEL   m_TerminalLabel;
    BOOL                m_fTermLabelExists; // true if m_TerminalLabel contents
                                            // have been assigned
public:
	
	CH323Member();
	~CH323Member();

    STDMETHOD(SetMemberInfo(PCC_OCTETSTRING pTerminalID, 
        PCC_TERMINAL_LABEL pTerminalLabel));
    
	STDMETHOD_(LPWSTR, GetTerminalID());
	STDMETHOD_(PCC_TERMINAL_LABEL, GetTerminalLabel());
};


#endif // _CMEMBER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\debug.h ===
#ifdef DEBUG // { DEBUG
int WINAPI CCDbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneCC;

#define ZONE_INIT (GETMASK(ghDbgZoneCC) & 0x0001)
#define ZONE_CONN (GETMASK(ghDbgZoneCC) & 0x0002)
#define ZONE_COMMCHAN (GETMASK(ghDbgZoneCC) & 0x0004)

#define ZONE_CAPS (GETMASK(ghDbgZoneCC) & 0x0008)
#define ZONE_MEMBER   (GETMASK(ghDbgZoneCC) & 0x0010)
#define ZONE_U2  (GETMASK(ghDbgZoneCC) & 0x0020)
#define ZONE_U3  (GETMASK(ghDbgZoneCC) & 0x0040)
#define ZONE_REFCOUNT (GETMASK(ghDbgZoneCC) & 0x0080)
#define ZONE_U4 (GETMASK(ghDbgZoneCC) & 0x0100)
#define ZONE_PROFILE (GETMASK(ghDbgZoneCC) & 0x0200)

extern HDBGZONE  ghDbgZoneNMCap;
#define ZONE_NMCAP_CDTOR (GETMASK(ghDbgZoneNMCap) & 0x0001)
#define ZONE_NMCAP_REFCOUNT (GETMASK(ghDbgZoneNMCap) & 0x0002)
#define ZONE_NMCAP_STREAMING (GETMASK(ghDbgZoneNMCap) & 0x0004)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (CCDbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (CCDbgPrintf m)
#else // }{ DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\connobj.cpp ===
/*
 *  	File: connobj.cpp
 *
 *		implementation of Microsoft Network Audio connection object.
 *
 *		
 *
 *		Revision History:
 *
 *		05/05/96	mikev	created
 *	 	08/04/96	philf	added support for video
 *      09/22/96	mikev	dual call control protocols (H.323 & MSICCP)
 *      10/14/96	mikev	multiple channel support, property I/F
 */


#include "precomp.h"
#include "ctrlh323.h"
#include "strutil.h"


CREQ_RESPONSETYPE CConnection::FilterConnectionRequest(
    LPIControlChannel lpControlChannel,
     P_APP_CALL_SETUP_DATA pAppData)
{
	FX_ENTRY ("CConnection::FilterConnectionRequest");
	CREQ_RESPONSETYPE cr;
	// validate lpControlChannel - this implementation sets it inside
	// GetAcceptingObject()
	if(m_pControlChannel != lpControlChannel)
	{
		ERRORMESSAGE(("%s:bad param:my pChan:0x%08lX, param pChan:0x%08lX\r\n",
			_fx_, m_pControlChannel, lpControlChannel));
		hrLast = CADV_E_INVALID_PARAM;
		return CRR_ERROR;
	}	
	m_ConnectionState = CLS_Alerting;
	cr = m_pH323CallControl->FilterConnectionRequest(this, pAppData);
	switch (cr)
	{
		case CRR_ASYNC:
			// m_ConnectionState = CLS_Alerting; // stays in this state
		break;
		case CRR_ACCEPT:
			m_ConnectionState = CLS_Connecting;
		break;	

		// set summary codes in reject cases
		case CRR_BUSY:
			m_ConnectionState = CLS_Idle;
			SummaryCode(CCR_LOCAL_BUSY);
		break;
		case CRR_SECURITY_DENIED:
			m_ConnectionState = CLS_Idle;
			SummaryCode(CCR_LOCAL_SECURITY_DENIED);
		break;
		default:
		case CRR_REJECT:
			m_ConnectionState = CLS_Idle;
			SummaryCode(CCR_LOCAL_REJECT);
		break;
	}
	return(cr);
}


HRESULT CConnection::FindAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPVOID lpvConfID)
{
	FX_ENTRY ("CConnection::FindAcceptingObject");
	HRESULT hr = H323CC_E_CONNECTION_NOT_FOUND;
	ULONG ulCount, uNumConnections;
	CConnection **ppConnections = NULL;;
	LPIControlChannel pCtlChan;
	CConnection *pConnection;

	if(!lplpAcceptingObject)
	{
		ERRORMESSAGE(("%s:null lplpAcceptingObject\r\n",_fx_));
		return CADV_E_INVALID_PARAM;
	}
	// zero out the output param
	*lplpAcceptingObject = NULL;
	hr = m_pH323CallControl->GetNumConnections(&uNumConnections);
	if(!HR_SUCCEEDED(hr))
		goto EXIT;
	if(!uNumConnections)
	{
		// initialized value hr = H323CC_E_CONNECTION_NOT_FOUND;
		goto EXIT;
	}
	ppConnections = (CConnection **)MemAlloc(uNumConnections * (sizeof(IH323Endpoint * *)));
	if(!ppConnections)
	{
		hr = H323CC_E_INSUFFICIENT_MEMORY;	
		goto EXIT;
	}
			
	// get list of connections and query each one for matching conference ID
	hr = m_pH323CallControl->GetConnobjArray(ppConnections, uNumConnections * (sizeof(IH323Endpoint * *)));
	if(!HR_SUCCEEDED(hr))
		goto EXIT;
	
	for(ulCount=0;ulCount <uNumConnections;ulCount++)
	{
		pConnection = ppConnections[ulCount];
		if(pConnection &&  (pCtlChan = pConnection->GetControlChannel())
			&& pCtlChan->IsAcceptingConference(lpvConfID))
		{
			*lplpAcceptingObject = pCtlChan;
			hr = hrSuccess;
			break;
		}
	}

EXIT:
	if(ppConnections)
		MemFree(ppConnections);

	return hr;

}


HRESULT CConnection::GetAcceptingObject(LPIControlChannel *lplpAcceptingObject,
	LPGUID pPID)
{
	FX_ENTRY ("CConnection::GetAcceptingObject");
	HRESULT hr;
	CConnection *pNewConnection;
	if(!lplpAcceptingObject)
	{
		ERRORMESSAGE(("%s:null lplpAcceptingObject\r\n",_fx_));
		return CADV_E_INVALID_PARAM;
	}
	// zero out the output param
	*lplpAcceptingObject = NULL;
	
	// create a connection object to accept the connection
	hr = m_pH323CallControl->CreateConnection(&pNewConnection, *pPID);
	if(HR_SUCCEEDED(hr))
	{
		*lplpAcceptingObject = pNewConnection->GetControlChannel();
	}
	else
	{
		ERRORMESSAGE(("%s:CreateConnection failed, hr=0x%08lx\r\n",_fx_, hr));
	}
	return hr;
}

//  This is called by a comm channel.  It is only called by a channel that is being 
//  opened, and only if that channel is not already associated with a control channel.
HRESULT CConnection::AddCommChannel (ICtrlCommChan *pChan)
{
    GUID mid;
	if(!m_fCapsReady)
    {
    	ASSERT(0);
		hrLast = CONN_E_NOT_INITIALIZED;	// need better error to indicate why 
							// (connection is not yet in a state to take new channels)
		goto EXIT;
    }
 	
	// re-initialize channel	
    hrLast = pChan->GetMediaType(&mid);
    
	ASSERT(m_pH323ConfAdvise != NULL);
	if(!pChan->Init(&mid, m_pH323ConfAdvise, TRUE))
	{
		hrLast = CONN_E_SYSTEM_ERROR;
		goto EXIT;
	}

	// non error case continues here
	if(m_pControlChannel)
	{
		m_ChannelList.AddTail(pChan);
		pChan->AddRef();
		hrLast = m_pControlChannel->AddChannel(pChan, m_pCapObject);
		if(!HR_SUCCEEDED(hrLast))
			goto EXIT;
	}
    
  EXIT:
    return hrLast;
}


HRESULT CConnection::CreateCommChannel(LPGUID pMediaGuid, ICommChannel **ppICommChannel,
	BOOL fSend)
{
	FX_ENTRY ("CConnection::CreateCommChannel");
	ICommChannel *pICommChannel = NULL;
	ICtrlCommChan *pICtrlCommChannel = NULL;
	
	if(!pMediaGuid || !ppICommChannel)
	{
		hrLast = CONN_E_INVALID_PARAM;
		goto EXIT;
	}

    DBG_SAVE_FILE_LINE
	if(*pMediaGuid == MEDIA_TYPE_H323_T120)
	{
		if(!(pICommChannel = (ICommChannel *)new ImpT120Chan))
		{
			hrLast = CONN_E_OUT_OF_MEMORY;
			goto EXIT;
		}
	}
	else if(!(pICommChannel = (ICommChannel *)new ImpICommChan))
	{
		hrLast = CONN_E_OUT_OF_MEMORY;
		goto EXIT;
	}
	
	hrLast = pICommChannel->QueryInterface(IID_ICtrlCommChannel, (void **)&pICtrlCommChannel);
	if(!HR_SUCCEEDED(hrLast))
	{
		goto EXIT;
	}

	ASSERT(m_pH323ConfAdvise != NULL);
	if(!pICtrlCommChannel->Init(pMediaGuid, m_pH323ConfAdvise, fSend))
	{
		hrLast = CONN_E_SYSTEM_ERROR;
		goto EXIT;
	}

	// it's created via this connection, now associate it and this connection
	if(m_pControlChannel)
	{
		m_ChannelList.AddTail(pICtrlCommChannel);
		hrLast = m_pControlChannel->AddChannel(pICtrlCommChannel, m_pCapObject);
		if(!HR_SUCCEEDED(hrLast))
			goto EXIT;
	}


	// in success case, the calling function gets the ICommChannel reference, and this
	// object gets the ICtrlCommChan reference
	*ppICommChannel = pICommChannel;
	pICommChannel = NULL;
	pICtrlCommChannel = NULL;

	EXIT:
	if(pICommChannel)
		pICommChannel->Release();
	if(pICtrlCommChannel)
		pICtrlCommChannel->Release();	
	return hrLast;
}

HRESULT CConnection:: ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput)
{
	ASSERT(NULL !=m_pCapObject);
	return (m_pCapObject->ResolveFormats(pMediaGuidArray, uNumMedia, pResOutput));
}

HRESULT CConnection::GetVersionInfo(PCC_VENDORINFO *ppLocalVendorInfo,
									  PCC_VENDORINFO *ppRemoteVendorInfo)
{
	if(!m_pControlChannel)
		return CONN_E_NOT_INITIALIZED;
		
	return (m_pControlChannel->GetVersionInfo(ppLocalVendorInfo, ppRemoteVendorInfo));
}

VOID CConnection ::ReleaseAllChannels()
{
	ICtrlCommChan *pChan = NULL;
	while (!m_ChannelList.IsEmpty())
	{
		pChan = (ICtrlCommChan *) m_ChannelList.RemoveHead();
		if(pChan)
		{
			pChan->Release();
			pChan = NULL;
		}
	}
}

//
// Implementation of IConfAdvise::OnControlEvent
//
// CAUTION: because Release() can be called by the registered event handler,
// any code path that accesses class instance data after a call to m_pH323ConfAdvise->CallEvent
// must AddRef() before the call, and Release() after all class instance data access
// is done.  The DoControlNotification() helper method does this, but beware of
// cases where data is touched after a call to DoControlNotification();
//
HRESULT CConnection::OnControlEvent(DWORD dwEvent, LPVOID lpvData, 	LPIControlChannel lpControlObject)
{
	FX_ENTRY ("CConnection::OnControlEvent");
	DWORD dwStatus;
	BOOL fPost = FALSE;
	HRESULT hr=hrSuccess;

	AddRef();
	switch(dwEvent)
	{	
		case  CCEV_RINGING:
			fPost = TRUE;
			dwStatus = CONNECTION_PROCEEDING;
		break;
		case  CCEV_CONNECTED:
			fPost = TRUE;
			dwStatus = CONNECTION_CONNECTED;
			NewUserInfo((LPCTRL_USER_INFO)lpvData);
		break;
		case  CCEV_CALLER_ID:
			NewUserInfo((LPCTRL_USER_INFO)lpvData);
		break;
		case  CCEV_CAPABILITIES_READY:
			m_fCapsReady = TRUE;
		break;

		case  CCEV_CHANNEL_REQUEST:
		// another channel (besides the channels supplied by EnumChannels()) is being 
		// requested -  we can't handle arbitrary channels yet.
			ERRORMESSAGE(("%s, not handling CCEV_CHANNEL_REQUEST \r\n",_fx_));
			hr = CADV_E_NOT_SUPPORTED;
			goto out;
		break;
		
		case  CCEV_DISCONNECTING:
			//in the future architecture, this event will be the opportunity to
			//cleanup channels
			if(lpvData)
			{
				// keep summary code
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
			Disconnect(CCR_UNKNOWN);
			// IConnect doesn't yet define a "disconnecting" event, so don't propagate it
		break;			
		case  CCEV_REMOTE_DISCONNECTING:
			if(lpvData)
			{
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
			// do notification before calling back into Disconnect, so the event
			// notifications are posted in the correct order. This is one of
			// the cases where Ref count protection is required.
			AddRef();
			DoControlNotification(CONNECTION_RECEIVED_DISCONNECT);
			// opportunity to cleanup channels
			Disconnect(CCR_UNKNOWN);
			Release();
		break;			
		case  CCEV_DISCONNECTED:
			fPost = TRUE;
			m_ConnectionState = CLS_Idle;
			dwStatus = CONNECTION_DISCONNECTED;
			if(lpvData)
			{
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
		break;		
		case  CCEV_ALL_CHANNELS_READY:
		 	// all *mandatory* channels are open, but not necessarily
		 	// all channels
			m_ConnectionState = CLS_Inuse;
			dwStatus = CONNECTION_READY;
			fPost = TRUE;
		break;
		case CCEV_ACCEPT_INCOMPLETE:
			if(lpvData)
			{
			// known problem is that control channel has already
			// disconnected and may have notified of the disconnect first.
			// This could be fixed, but it's not an issue because an incomplete
			// accept is not made known to the UI, therefore the summary code
			// is dust anyway.
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
			if(lpControlObject && (m_pControlChannel == lpControlObject))
			{
				// remove interest in control channel events, then nuke it
				m_pControlChannel->DeInit((IConfAdvise *) this);
				m_pControlChannel->Release();
			}
			m_pControlChannel = NULL;
			if(m_pH323CallControl)
			{
				m_pH323CallControl->RemoveConnection(this);
			}
			Release();	// release self - this is by design
					
	 	break;		 	
		case  CCEV_CALL_INCOMPLETE:
			hr = OnCallIncomplete(lpControlObject, (lpvData)?  ((DWORD) *((DWORD *)lpvData)) :0);
			goto out;
		break;		

 	}
	if(fPost)
		DoControlNotification(dwStatus);

out:
	Release();
	return hr;
}

HRESULT CConnection::OnCallIncomplete (LPIControlChannel lpControlObject, HRESULT hIncompleteCode)
{
	FX_ENTRY ("CConnection::OnCallIncomplete ");
	// check the reason for incomplete call attempt (busy? rejected? nobody home?
	HRESULT hSummary;
	CloseAllChannels();

	// map the protocol-specific (h.323, msiccp, sip, etc) code to the 
	// connection interface code
	// test for gatekeeper admission reject
	// FACILITY_GKIADMISSION
	if(CUSTOM_FACILITY(hIncompleteCode) == FACILITY_GKIADMISSION)
	{
		// pass GK codes through intact
		hSummary = hIncompleteCode;
	}
	else
	{
		switch (hIncompleteCode)
		{
			case CCCI_GK_NO_RESOURCES:
				hSummary = CCR_GK_NO_RESOURCES;
			break;
			case CCCI_BUSY:
				hSummary = CCR_REMOTE_BUSY;
			break;
			case CCCI_SECURITY_DENIED:
				hSummary = CCR_REMOTE_SECURITY_DENIED;
			break;
			case CCCI_NO_ANSWER_TIMEOUT:
				hSummary = CCR_NO_ANSWER_TIMEOUT;
			break;
			case CCCI_REJECTED:
				hSummary = CCR_REMOTE_REJECTED;
			break;
			case CCCI_REMOTE_ERROR:
				hSummary = CCR_REMOTE_SYSTEM_ERROR;
			break;
			case CCCI_LOCAL_ERROR:
				hSummary = CCR_LOCAL_SYSTEM_ERROR;
			break;
			case CCCI_INCOMPATIBLE:
				hSummary = CCR_LOCAL_PROTOCOL_ERROR;
			break;
			case CCCI_UNKNOWN:
				hSummary = CCR_UNKNOWN;
			default:
				hSummary = CCR_UNKNOWN;
			break;
		}
	}

	DEBUGMSG(ZONE_CONN,("%s: incomplete code = 0x%08lX\r\n",
		_fx_, hIncompleteCode));
	SummaryCode(hSummary);
	return hrLast;
}

VOID CConnection::NewUserInfo(LPCTRL_USER_INFO lpNewUserInfo)
{
	FX_ENTRY ("CConnection::NewUserInfo");
	
	if(!lpNewUserInfo || !lpNewUserInfo->dwCallerIDSize || !lpNewUserInfo->lpvCallerIDData)
		return;

	if(m_pUserInfo)
	{
		DEBUGMSG(ZONE_CONN,("%s:uninitialized m_pUserInfo (0x%08lX) or multiple notification \r\n",
			_fx_, m_pUserInfo ));
		//
		if(!IsBadWritePtr((LPVOID)m_pUserInfo, m_pUserInfo->dwCallerIDSize + sizeof(CTRL_USER_INFO)))
		{
			// chances are it *is* a multiple notification and not an uninitialized
			// variable.  Ther may be some control channel protocols that *update* user
			// information after connection or accepting, but that is pure speculation.
			// the typical case is that caller ID is available before accepting, and
			// it is resupplied in the subsequent "connected" notification.  We're not
			// wasting time realloc'ing and recopying it.
			return;
		}
		// else fallout and overwrite it
	}
	// copy the structure and caller ID data
	m_pUserInfo = (LPCTRL_USER_INFO)MemAlloc(lpNewUserInfo->dwCallerIDSize + sizeof(CTRL_USER_INFO));		
	
	if(m_pUserInfo)
	{
		m_pUserInfo->lpvRemoteProtocolInfo = NULL;  // nothing touchess this later, but being safe anyway
		m_pUserInfo->lpvLocalProtocolInfo = NULL;
		
		m_pUserInfo->dwCallerIDSize = lpNewUserInfo->dwCallerIDSize;
		// point past the structure
		m_pUserInfo->lpvCallerIDData = ((BYTE *)m_pUserInfo) + sizeof(CTRL_USER_INFO);
		memcpy(m_pUserInfo->lpvCallerIDData,
			lpNewUserInfo->lpvCallerIDData,
			m_pUserInfo->dwCallerIDSize);
	}
	else
	{
		ERRORMESSAGE(("%s:allocation of m_pUserInfo failed\r\n",_fx_));
	}
}	

//
// Utility function for passing control channel events to the registered handler
// This is callable only by the control channel code running in the same thread
// as that which created the connection.
VOID CConnection::DoControlNotification(DWORD dwStatus)
{
	FX_ENTRY ("CConnection::DoControlNotification");
	// issue notification to registered entity
	if(m_pH323ConfAdvise)
	{
		AddRef();	// protect ourselves from calls back into methods that
					// wind up in Release().
		DEBUGMSG(ZONE_CONN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
        m_pH323ConfAdvise->CallEvent((IH323Endpoint *)&m_ImpConnection, dwStatus);
  		Release();

	}
}


CConnection::CConnection()
:m_pH323CallControl(NULL),
hrLast(hrSuccess),
next(NULL),
m_fCapsReady(FALSE),
m_ConnectionState(CLS_Idle),
m_pH323ConfAdvise(NULL),
m_pUserInfo(NULL),
m_pControlChannel(NULL),
m_pCapObject(NULL),
m_hSummaryCode(hrSuccess),
uRef(1)
{
	m_ImpConnection.Init(this);
}

CConnection::~CConnection()
{
	ReleaseAllChannels();
	if(m_pH323CallControl)
		m_pH323CallControl->RemoveConnection(this);
		
	if(m_pCapObject)
		m_pCapObject->Release();
	// we really don't allocate much
	if(m_pUserInfo)
		MemFree(m_pUserInfo);
	
}   

HRESULT CConnection::Init(CH323CallControl *pH323CallControl, GUID PIDofProtocolType)
{
	FX_ENTRY(("CConnection::Init"));
	hrLast = hrSuccess;
    BOOL     bAdvertise;
	m_pH323CallControl = pH323CallControl;
	GUID mid;

	if(!pH323CallControl)
		return CCO_E_INVALID_PARAM;
		
	if(m_pControlChannel)
	{
		ASSERT(0);
		// don't cleanup in this case
		return CONN_E_ALREADY_INITIALIZED;
	}
	
	if(PIDofProtocolType != PID_H323)
	{
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;
	}
	
    DBG_SAVE_FILE_LINE
	if(!(m_pControlChannel = (LPIControlChannel) new CH323Ctrl))
	{
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;
	}

    DBG_SAVE_FILE_LINE
	if(!m_pCapObject && !(m_pCapObject = new CapsCtl()))
	{
		ERRORMESSAGE(("%s:cannot create capability resolver\r\n",_fx_));
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;;
	}
	if(!m_pCapObject->Init())
	{
		ERRORMESSAGE(("%s:cannot init capability resolver\r\n",_fx_));
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;
	}

    bAdvertise = ((g_capFlags & CAPFLAGS_AV_STREAMS) != 0);
	mid = MEDIA_TYPE_H323AUDIO;
	hrLast = m_pCapObject->EnableMediaType(bAdvertise, &mid);
	if(!HR_SUCCEEDED(hrLast))
		goto ERROR_CLEANUP;

    bAdvertise = ((g_capFlags & CAPFLAGS_AV_STREAMS) != 0);
	mid = MEDIA_TYPE_H323VIDEO;
	hrLast = m_pCapObject->EnableMediaType(bAdvertise, &mid);
	if(!HR_SUCCEEDED(hrLast))
		goto ERROR_CLEANUP;

	hrLast = m_pControlChannel->Init((IConfAdvise *) this);
	if(!HR_SUCCEEDED(hrLast))
		goto ERROR_CLEANUP;

	return hrLast;

	ERROR_CLEANUP:
	ERRORMESSAGE(("%s:ERROR_CLEANUP\r\n",_fx_));
	
	if(m_pControlChannel)
		m_pControlChannel->Release();
	if(m_pCapObject)
		m_pCapObject->Release();
	m_pControlChannel = NULL;
	m_pCapObject = NULL;

	return hrLast;
}

BOOL CConnection::ListenOn(PORT port)
{
	if(!m_pControlChannel)
	{
		hrLast = H323CC_E_NOT_INITIALIZED;
		goto EXIT;
	}
	
	hrLast = m_pControlChannel->ListenOn(port);
EXIT:
	return((HR_SUCCEEDED(hrLast))?TRUE:FALSE);
}


// 	start the asynchronous stuff that will instantiate a control channel
HRESULT CConnection::PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData)
{
	if(m_ConnectionState != CLS_Idle)
		return CONN_E_NOT_IDLE;
		
	m_fCapsReady = FALSE;
	// reset summary code
	m_hSummaryCode = CCR_INVALID_REASON;

	hrLast = m_pH323CallControl->GetGKCallPermission();
	if(!HR_SUCCEEDED(hrLast))
	{
		m_hSummaryCode = hrLast;
		return hrLast;
	}
	
	hrLast = m_pControlChannel->PlaceCall (bUseGKResolution, pCallAddr,		
        pDestinationAliases, pExtraAliases,  	
	    pCalledPartyNumber, pAppData);
	    
	if(HR_SUCCEEDED(hrLast))
		m_ConnectionState = CLS_Connecting;
	return hrLast;
}


HRESULT CConnection::AcceptRejectConnection(CREQ_RESPONSETYPE Response)
{
	if(Response == CRR_ACCEPT)
	{
		m_ConnectionState = CLS_Connecting;
		m_fCapsReady = FALSE;
		// reset summary code
		m_hSummaryCode = CCR_INVALID_REASON;
	}
	return m_pControlChannel->AsyncAcceptRejectCall(Response);
}	


HRESULT CConnection::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	ASSERT(pH323ConfAdvise != NULL);	
	if(!pH323ConfAdvise)
	{
		return CONN_E_INVALID_PARAM;
	}
	m_pH323ConfAdvise = pH323ConfAdvise;
	//EXIT:	
	return hrSuccess;
}

HRESULT CConnection::ClearAdviseInterface()
{
	m_pH323ConfAdvise = NULL;
	return hrSuccess;
}	


// LOOKLOOK - the H323 control channel needs to get the combined cap object
// implementation of IConfAdvise::GetCapResolver()
HRESULT CConnection::GetCapResolver(LPVOID *lplpCapObject, GUID CapType)
{
	if(!lplpCapObject)
		return CONN_E_INVALID_PARAM;

	if(!m_pH323CallControl || !m_pCapObject)
		return CONN_E_NOT_INITIALIZED;	
	
	if(CapType == OID_CAP_ACM_TO_H323)
	{
	   *lplpCapObject = m_pCapObject;
	}
	else
	{
		return CONN_E_INVALID_PARAM;
	}
	return hrSuccess;
}


HRESULT CConnection::GetState(ConnectStateType *pState)
{
	HRESULT hResult = hrSuccess;
	if(!pState)
	{
		hResult = CONN_E_INVALID_PARAM;
		goto EXIT;
	}
	
	*pState = m_ConnectionState;
	EXIT:	
	return hResult;
}



// IConfAdvise::GetUserDisplayName()
LPWSTR CConnection::GetUserDisplayName()
{
	if(!m_pH323CallControl)
		return NULL;	
	return m_pH323CallControl->GetUserDisplayName();
}
PCC_ALIASITEM CConnection::GetUserDisplayAlias()
{
	if(!m_pH323CallControl)
		return NULL;	
	return m_pH323CallControl->GetUserDisplayAlias();
}
PCC_ALIASNAMES CConnection:: GetUserAliases() 
{
	if(!m_pH323CallControl)
		return NULL;
	return m_pH323CallControl->GetUserAliases();
}
HRESULT CConnection::GetLocalPort(PORT *lpPort)
{
	if(!m_pControlChannel)
		return CONN_E_NOT_INITIALIZED;
		
	return m_pControlChannel->GetLocalPort(lpPort);	
}	
HRESULT CConnection::GetRemoteUserName(LPWSTR lpwszName, UINT uSize)
{
	
	if(!lpwszName)
	{
		hrLast = MakeResult(CONN_E_INVALID_PARAM);
		goto EXIT;
	}	
	if(!m_pUserInfo)
	{
	// LOOKLOOK - need CONN_E_UNAVAILABLE or something
		hrLast = MakeResult(CONN_E_INVALID_PARAM);
		goto EXIT;
	}
		
	LStrCpyNW((LPWSTR)lpwszName,(LPWSTR)m_pUserInfo->lpvCallerIDData, uSize);	
	hrLast = hrSuccess;	
	EXIT:	
	return hrLast;
}
HRESULT CConnection::GetRemoteUserAddr(PSOCKADDR_IN psinUser)
{
	PSOCKADDR_IN psin = NULL;
	if(!m_pControlChannel)
		return CONN_E_NOT_INITIALIZED;
	
	if(psinUser)
	{	// get ptr to address, then copy it
		hrLast = m_pControlChannel->GetRemoteAddress(&psin);
		if(HR_SUCCEEDED(hrLast) && psin)
		{
			*psinUser = *psin;
		}
	}
	else
	{
		hrLast = H323CC_E_INVALID_PARAM;
	}
	//EXIT:	
	return hrLast;
}


HRESULT CConnection ::Disconnect()
{
	SummaryCode(CCR_LOCAL_DISCONNECT);
	Disconnect(CCR_LOCAL_DISCONNECT);
	return hrSuccess;
}

HRESULT CConnection::CloseAllChannels()
{
	ICtrlCommChan *pChan = NULL;
	HRESULT hr;	// temp return value so error code does not get overwritten
	FX_ENTRY ("CConnection::CloseAllChannels");

	// This doesn't actually cause channel close PDU's to be sent. It only 
	// shuts off all streams associated with all channels.  
	while (!m_ChannelList.IsEmpty())
	{
		pChan = (ICtrlCommChan *) m_ChannelList.RemoveHead();
		if(pChan)
		{
			hr = pChan->OnChannelClose(CHANNEL_CLOSED);
			if(!HR_SUCCEEDED(hr))
				hrLast = hr;
			hr = pChan->EndControlSession();
			if(!HR_SUCCEEDED(hr))	
				hrLast = hr;
			pChan->Release();
		}
	}
	return hrLast;
}

VOID CConnection::Disconnect(DWORD dwResponse)
{
	AddRef();	// prevent releasing while handling disconnect events
	if(!m_pControlChannel)
	{
		m_ConnectionState = CLS_Idle;
		goto EXIT;
	}

	if((m_ConnectionState == CLS_Disconnecting)
		|| (m_ConnectionState == CLS_Idle))
	{
		goto EXIT;
	}
	m_ConnectionState = CLS_Disconnecting;

	// CloseAllChannels() forces the action that would be taken when all 
	// channels are closed via call control.  Anal channel cleanup is not 
	// implemented on disconnect- CloseAllChannels() turns off all streaming,
	//  then we just end the session.  It takes too long to go through the
	// protocol overhead of closing & acking channel close, and it's legal in  
	// H.323 to end the session.  Ending the session implies channel closure  
	// for all channels. 
	// 

	CloseAllChannels();
	
	// this call can result in callbacks to the UI, which can result in
	// calls back in, which results in releasing the object.  If we're
	// about to go in, we need to be sure we can get back out, so AddRef()
	m_pControlChannel->AddRef();
	m_pControlChannel->Disconnect(dwResponse);
	m_pControlChannel->Release();
EXIT:
	Release();
}




STDMETHODIMP CConnection::QueryInterface( REFIID iid,	void ** ppvObject)
{

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if((iid == IID_IPhoneConnection) 
	|| (iid == IID_IUnknown)) // satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if(iid == IID_IConfAdvise)
	{
	    *ppvObject = (IConfAdvise *)this;
   		hr = hrSuccess;
    	AddRef();
	}
	else if((iid == IID_IAppAudioCap ) && m_pCapObject)
	{
	ASSERT(0);
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IAppVidCap ) && m_pCapObject)
	{
///	ASSERT(0);  CVideoProp still uses this
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IDualPubCap) && m_pCapObject)
	{
	ASSERT(0);
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	return (hr);
}

ULONG CConnection::AddRef()
{
	FX_ENTRY ("CConnection::AddRef");
	uRef++;
	DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->AddRef() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
	return uRef;
}

ULONG CConnection::Release()
{
	FX_ENTRY ("CConnection::Release");
	uRef--;
	if(uRef == 0)
	{
		DEBUGMSG(ZONE_CONN,("%s:(0x%08lX)->Releasing in state:%d\r\n",_fx_, this, m_ConnectionState));
		
		// remove our interest in the control channel
		if(m_pControlChannel)
		{
			hrLast = m_pControlChannel->DeInit((IConfAdvise *) this);
			m_pControlChannel->Release();
		}
		
		// m_pControlChannel = NULL;
		delete this;
		return 0;
	}
	else
	{
		DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->Release() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
		return uRef;
	}

}


STDMETHODIMP CConnection::GetSummaryCode(VOID)
{
	return m_hSummaryCode;
}
VOID CConnection::SummaryCode(HRESULT hCode)
{
	// assign code only if it has not yet been assigned
	if(m_hSummaryCode != CCR_INVALID_REASON)
		return;
	m_hSummaryCode = hCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\guids.c ===
#define  INITGUIDS
#include <objbase.h>
#include <initguid.h>
#include <winsock2.h>
#include <mmsystem.h>
#include "common.h"
#include "nacguids.h"
#include <nmqos.h>
#include "codecs.h"
#include <irtp_i.c>

// {D2E97231-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_MSIA = 
//{ 0xd2e97231, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {D2E97230-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_H323 = 
//{ 0xd2e97230, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {A4209190-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_H323 = 
//{ 0xa4209190, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209191-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MSICCP = 
//{ 0xa4209191, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209192-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MNM10_DUAL = 
//{ 0xa4209192, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\connobj.h ===
/*
 *  	File: connobj.h
 *
 *      implementation of Connection Object
 *
 *		Revision History:
 *
 *		05/08/96	mikev	created
 */


#ifndef _CONNOBJ_H
#define _CONNOBJ_H


/*
 *	Class definitions
 */

class ImpIConnection : public IH323Endpoint
{
friend class CH323CallControl;	
public:	

    STDMETHOD(QueryInterface(REFIID riid, LPVOID FAR * ppvObj));	
	STDMETHOD_(ULONG,AddRef());
	STDMETHOD_(ULONG,Release());
	STDMETHOD( SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));
	STDMETHOD( ClearAdviseInterface());
    STDMETHOD(PlaceCall(BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData));	
	STDMETHOD( Disconnect());
	STDMETHOD( GetState(ConnectStateType *pState));
    STDMETHOD( GetRemoteUserName(LPWSTR lpwszName, UINT uSize));
    STDMETHOD( GetRemoteUserAddr(PSOCKADDR_IN psinUser));
    STDMETHOD( AcceptRejectConnection(THIS_ CREQ_RESPONSETYPE RejectReason));

    STDMETHOD_(HRESULT, GetSummaryCode());
   	STDMETHOD( CreateCommChannel(THIS_ LPGUID pMediaGuid, ICommChannel **ppICommChannel,
    	BOOL fSend));
	STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput));
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));
	ImpIConnection();
 	~ImpIConnection(){};
 	void Init(class CConnection FAR * pCon) {m_pConnection = pCon;};

protected:
	CConnection *m_pConnection;
};


class CConnection :
	public IH323Endpoint,
	public IConfAdvise
{

friend class CH323CallControl;
private:
	
	ImpIConnection m_ImpConnection;
	CH323CallControl *m_pH323CallControl;

	LPIH323PubCap m_pCapObject;
	
protected:
	COBLIST m_ChannelList;  
    COBLIST m_MemberList;
   
	UINT uRef;
	HRESULT hrLast;
	CConnection *next;
    BOOL            m_fCapsReady;
	IH323ConfAdvise *m_pH323ConfAdvise;
	LPCTRL_USER_INFO 	m_pUserInfo;	
	LPIControlChannel 	m_pControlChannel;
	HRESULT     m_hSummaryCode;		// best known reason for disconnect or reject
public:
	virtual HRESULT Init(class CH323CallControl *pH323CallControl, GUID PIDofProtocolType);
    void DeInit(VOID) {m_pH323CallControl = NULL;};
	CConnection();
	~CConnection();

protected:
	
	ConnectStateType 	m_ConnectionState;
	VOID DoControlNotification(DWORD dwStatus);
public:
	BOOL ListenOn(PORT Port);
	VOID Disconnect(DWORD dwResponse);
	HRESULT CloseAllChannels();
	VOID NewUserInfo(LPCTRL_USER_INFO lpNewUserInfo);
	
public:	
	LPIControlChannel GetControlChannel( ){return m_pControlChannel;};
    VOID ReleaseAllChannels();
        
	STDMETHOD(GetLocalPort(PORT *lpPort));
	STDMETHOD (OnCallIncomplete (
	    LPIControlChannel lpControlObject, 
	    HRESULT hIncompleteCode));

	VOID SummaryCode(HRESULT hCode);

	
//	IConfAdvise interface methods
//
    STDMETHOD(OnControlEvent(DWORD dwEvent, LPVOID lpvData, LPIControlChannel lpControlObject));
    STDMETHOD(GetCapResolver(LPVOID *lplpCapObject, GUID CapType));
	STDMETHOD_(LPWSTR, GetUserDisplayName());
    STDMETHOD_(PCC_ALIASITEM, GetUserDisplayAlias());
	STDMETHOD_(PCC_ALIASNAMES, GetUserAliases());

	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(
	    LPIControlChannel lpControlChannel, P_APP_CALL_SETUP_DATA pAppData));
	STDMETHOD(GetAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPGUID pPID));
	STDMETHOD(FindAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPVOID lpvConfID));
	STDMETHOD_(IH323Endpoint *, GetIConnIF()) {return &m_ImpConnection;};
	STDMETHOD (AddCommChannel (ICtrlCommChan *pChan));



// Shared IIntConn/IConnection interface methods
	STDMETHOD( Disconnect());
	
// IConnection interface  methods
	STDMETHOD(QueryInterface(REFIID riid, LPVOID FAR * ppvObj));
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD( SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));
	STDMETHOD( ClearAdviseInterface());
    STDMETHOD(PlaceCall(BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData));	
	STDMETHOD( GetState(ConnectStateType *pState));
	STDMETHOD( GetRemoteUserName(LPWSTR lpwszName, UINT uSize));
	STDMETHOD( GetRemoteUserAddr(THIS_ PSOCKADDR_IN psinUser));
    STDMETHOD( AcceptRejectConnection(THIS_ CREQ_RESPONSETYPE RejectReason));
	STDMETHOD( GetSummaryCode());
   	STDMETHOD( CreateCommChannel(THIS_ LPGUID pMediaGuid, ICommChannel **ppICommChannel,
    	BOOL fSend));
	STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput));	
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));
};


#endif // _CONNOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\ctrlh323.cpp ===
/*
 *  	File: ctrlh323.cpp
 *
 *		Implementation of IControlChannel using H.323 call control protocol
 * 		via apis of CALLCONT.DLL
 *		
 *
 *		Revision History:
 *
 *		09/06/96	mikev	created
 *					
 */

#include "precomp.h"
#include "ctrlh323.h"
#include "version.h"
#include "strutil.h"

#ifdef DEBUG
VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
#else
#define DumpNonstdParameters(a, b)
#define DumpChannelParameters(a, b)
#endif

extern HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource);
extern VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed);

static char DefaultProductID[] = H323_PRODUCTNAME_STR;
static char DefaultProductVersion[] = H323_PRODUCTRELEASE_STR;

HRESULT  CCConferenceCallback (BYTE						bIndication,
										HRESULT						hStatus,
										CC_HCONFERENCE                 hConference,
										DWORD_PTR                   dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams);


VOID  CCListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams);

VOID CH323Ctrl::DoAdvise(DWORD dwEvent, LPVOID lpvData)
{
	FX_ENTRY ("CH323Ctrl::DoAdvise");

	if(IsReleasing())	// don't call out while releasing because it could call
						// back in!
	{
		ERRORMESSAGE(("%s:in releasing state\r\n",_fx_));
		return;
	}

	AddRef();	// protect ourselves from reentrant calls to Release().
	if(m_pConfAdvise)
	{
		hrLast = m_pConfAdvise->OnControlEvent(dwEvent, lpvData, this);
	}
	else
	{
		ERRORMESSAGE(("%s:Invalid m_pConfAdvise\r\n",_fx_));
	}
	
	Release();
}

VOID CH323Ctrl::GoNextPhase(CtlChanStateType phase)
{
	FX_ENTRY ("CH323Ctrl::GoNextPhase");
	BOOL fNotifyReady = FALSE;
	#define InvError() ERRORMESSAGE(("%s:Invalid transition from %d to %d\r\n",_fx_,m_Phase,phase))
	switch(phase)
	{
		case CCS_Idle:
			if(m_Phase != CCS_Idle && m_Phase != CCS_Disconnecting && m_Phase != CCS_Listening)
			{
				InvError();
			}
			else
			{
				m_ChanFlags &= ~(CTRLF_OPEN);
			}
		break;
		case CCS_Connecting:
			if((m_Phase != CCS_Idle) && (m_Phase != CCS_Ringing))
			{
				InvError();
			}
		break;
		case CCS_Accepting:
			if(m_Phase != CCS_Listening)
			{
				InvError();
			}
		
		break;
		case CCS_Ringing:
			// transition from CCS_Idle state is actually only valid if
			// there is an incoming call
			if(m_Phase != CCS_Connecting && m_Phase != CCS_Filtering && m_Phase != CCS_Listening)
			{
				InvError();
			}
		break;
		case CCS_Opening:
			if(m_Phase != CCS_Connecting && m_Phase != CCS_Accepting
				&& m_Phase != CCS_Ringing)
			{
				InvError();
			}
		break;
		case CCS_Closing:
			if(m_Phase != CCS_Opening && m_Phase != CCS_Ready && m_Phase != CCS_InUse)
			{
				InvError();
			}
		break;
		case CCS_Ready:
			// can be reentered. if notification is already pending, (state is
			// already CCS_InUse) stay there,  else do the transition
			if(m_Phase != CCS_InUse)
			{
				if(m_Phase != CCS_Opening)
				{
					InvError();
				}
				else
				{
					//signal "all channels ready" to IConfAdvise	
					fNotifyReady = TRUE;
				}
			}
			phase = CCS_InUse;
		break;
		case CCS_InUse:
			// previous state must be CCS_InUse or CCS_Ready
			if(m_Phase != CCS_InUse && m_Phase != CCS_Ready)
			{
				InvError();
			}
		
		break;
		case CCS_Listening:
			if(m_Phase != CCS_Idle)
			{
				InvError();
			}
		break;
		case CCS_Disconnecting:
			//if(m_Phase != CCS_Closing)
			//{
			//	InvError();
			//}
		break;

	}

	m_Phase = phase;

	if (fNotifyReady)
	{
		DoAdvise(CCEV_ALL_CHANNELS_READY, NULL);
	}
}


HRESULT CCConferenceCallback (BYTE bIndication,
	HRESULT	hConfStatus, CC_HCONFERENCE hConference, DWORD_PTR dwConferenceToken,
	PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams)
{
	HRESULT hr = CC_NOT_IMPLEMENTED;
	FX_ENTRY ("CCConferenceCallback ");
	CH323Ctrl *pConnection = (CH323Ctrl *)dwConferenceToken;

	if(IsBadWritePtr(pConnection, sizeof(CH323Ctrl)))
	{
		ERRORMESSAGE(("%s:invalid conf token: 0x%08lx\r\n",_fx_, dwConferenceToken));
		return CC_NOT_IMPLEMENTED;	// must be either CC_NOT_IMPLEMENTED or CC_OK.
	}
	
	if(pConnection && pConnection->GetConfHandle() == hConference)
	{

		if(pConnection->IsReleasing())
		{
			// we are in the cleanup path.  The object is being deleted without
			// waiting for asynchronous stuff to complete, and we called that one
			// final API (most likely Hangup()) that resulted in a callback.  Don't call
			// back into the object.
			DEBUGMSG(ZONE_CONN,("%s:callback while releasing:0x%08lx, hconf:0x%08lx\r\n",_fx_,
				pConnection, hConference));
			return hr;
		}	
		pConnection->AddRef();	// protect against Release()ing while not in
								// a quiescent state.  We do not want to be
								// released while inside ourself
		hr = pConnection->ConfCallback(bIndication, hConfStatus, pConferenceCallbackParams);
		pConnection->Release();
	}
	#ifdef DEBUG
	else
	{	
		if(pConnection)
			DEBUGMSG(ZONE_CONN,("%s:hConference mismatch, hConference:0x%08lx, object hconf:0x%08lx, pObject:0x%08lx\r\n",_fx_,
				hConference, pConnection->GetConfHandle(), pConnection));
		else
			DEBUGMSG(ZONE_CONN,("%s:null dwConferenceToken\r\n",_fx_));
	}
	#endif //DEBUG
	return hr;
}

VOID  CCListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams)
{
	FX_ENTRY ("CCListenCallback");
	CH323Ctrl *pConnection;
	if(!pListenCallbackParams)
	{
		return;
	}
	pConnection = (CH323Ctrl *)pListenCallbackParams->dwListenToken;

	if(IsBadWritePtr(pConnection, sizeof(CH323Ctrl)))
	{
		ERRORMESSAGE(("%s:invalid listen token: 0x%08lx\r\n",_fx_, pListenCallbackParams->dwListenToken));
		return;
	}

	// BUGBUG there's no hListen passed in - we can't validate it
	//	if(pConnection && (pConnection->GetListenHandle() == pListenCallbackParams->h??????))

	if(pConnection)
	{
		pConnection->AddRef();	// protect against Release()ing while not in
								// a quiescent state.  We do not want to be
								// released while inside ourself
		pConnection->ListenCallback(hStatus,pListenCallbackParams);
		pConnection->Release();
	}
	else
	{
		ERRORMESSAGE(("%s:null listen token\r\n",_fx_));
	}

}
VOID CH323Ctrl::ListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::ListenCallback");
	HRESULT hr;
	if(hStatus != CC_OK)
	{
		m_hCallCompleteCode = CCCI_LOCAL_ERROR;
		CH323Ctrl *	pAcceptingConnection = NULL;
		BOOL bDisconnect = FALSE;

		ERRORMESSAGE(("%s:error 0x%08lx\r\n",_fx_,hStatus));
		// aaaaghhh!!! an unsolicited error!!!!!
		// MikeV 10/12/96 - observed behavior is that this will occur if the caller disconnects
		// before the call is accepted (or during acceptance - if a BP is set before the call
		// to AcceptRejectConnection(), the caller times out.  But even after that, tracing
		// over AcceptRejectConnection() shown no error is returned. This is bad, because
		// it is hard to tell if this error needs cleaning up after.  The error code in
		// that case is 0xa085a001, which is CC_PEER_REJECT

		// We also don't know if another object has been created to accept the connection
		// or if this is being called in the context of the object that was created and
		// its handle passed to AcceptRejectConnection().  The typical behavior is that it
		// is called in the context of the listening object.

		// once the accepting object is located, need to check state to see if
		// connection is in the process of being accepted.  Find accepting object
		// by matching pListenCallbackParams->ConferenceID;	
		
		// see if this is the correct context
		if(memcmp(&pListenCallbackParams->ConferenceID, &m_ConferenceID, sizeof(m_ConferenceID))==0)
		{
			// check the current state.  If in the process of accepting
			// (either Idle, or filtering), change state to CCS_Closing to make
			// cleanup occur.  If already accepted (accepting or ringing), initiate
			// InternalDisconnect().  This should never happen in any other state.

			// EnterCriticalSection()	// LOOKLOOK - NYI
			switch(m_Phase)
			{
				case CCS_Idle:
				case CCS_Filtering:
				break;
				default:
				case CCS_Ringing:
				case CCS_Accepting:
					bDisconnect = TRUE;
					switch(hStatus)
					{
						case  CC_PEER_REJECT:
							m_hCallCompleteCode = CCCI_REJECTED;
							ERRORMESSAGE(("%s:Received CC_PEER_REJECT in state %d\r\n",_fx_,m_Phase));
						break;

						default:
						case  CC_INTERNAL_ERROR:
							m_hCallCompleteCode = CCCI_LOCAL_ERROR;
		 				break;
						
					}
				
				break;

			}
			// ExitCriticalSection()
			if(bDisconnect)
					InternalDisconnect();
		}
		else
		{
			hr = m_pConfAdvise->FindAcceptingObject((LPIControlChannel *)&pAcceptingConnection,
				&pListenCallbackParams->ConferenceID);
			if(HR_SUCCEEDED(hr) && pAcceptingConnection)
			{
				// call this function in the correct context
				pAcceptingConnection->AddRef();
				pAcceptingConnection->ListenCallback (hStatus, pListenCallbackParams);
				pAcceptingConnection->Release();
			}
			else
			{
					ERRORMESSAGE(("%s:conference ID 0x%08lx 0x%08lx 0x%08lx 0x%08lx\r\n"
						,_fx_,pListenCallbackParams->ConferenceID.buffer[0],
						pListenCallbackParams->ConferenceID.buffer[4],
						pListenCallbackParams->ConferenceID.buffer[8],
						pListenCallbackParams->ConferenceID.buffer[12]));
					ERRORMESSAGE(("%s:Received 0x%08lx in state %d, accepting object not found\r\n"
					,_fx_,hStatus, m_Phase));
			}
		}
		
		return;
	}
	// non error case falls out
	switch(pListenCallbackParams->wGoal)
	{
		default:
		case CC_GOAL_UNKNOWN:
		break;
		
		case CC_GOAL_CREATE:
		case CC_GOAL_JOIN:
		case CC_GOAL_INVITE:
			m_ConferenceID = pListenCallbackParams->ConferenceID;	
			m_hCall =  pListenCallbackParams->hCall;

			if(pListenCallbackParams->pCallerAliasNames || pListenCallbackParams->pszDisplay)
			{			
				NewRemoteUserInfo(pListenCallbackParams->pCallerAliasNames,
					pListenCallbackParams->pszDisplay);
			}
			else
			{
				ERRORMESSAGE(("%s:null pListenCallbackParams->pCallerAliasNames\r\n",_fx_));
			}
			
			if(!OnCallAccept(pListenCallbackParams))
			{
				ERRORMESSAGE(("ListenCallback:OnCallAccept failed\r\n"));
			}
						
		break;
	}
}


//
//  Main conference indication dispatcher
//
#ifdef DEBUG
TCHAR *i_strs[ ] =
{
"ERROR! - INDICATION ZERO",
"CC_RINGING_INDICATION",
"CC_CONNECT_INDICATION", 						
"CC_TX_CHANNEL_OPEN_INDICATION",				
"CC_RX_CHANNEL_REQUEST_INDICATION",			
"CC_RX_CHANNEL_CLOSE_INDICATION",		
"CC_MUTE_INDICATION",			
"CC_UNMUTE_INDICATION",						
"CC_PEER_ADD_INDICATION",						
"CC_PEER_DROP_INDICATION",						
"CC_PEER_CHANGE_CAP_INDICATION",
"CC_CONFERENCE_TERMINATION_INDICATION",
"CC_HANGUP_INDICATION",					
"CC_RX_NONSTANDARD_MESSAGE_INDICATION",
"CC_MULTIPOINT_INDICATION",	
"CC_PEER_UPDATE_INDICATION",				
"CC_H245_MISCELLANEOUS_COMMAND_INDICATION",
"CC_H245_MISCELLANEOUS_INDICATION_INDICATION",
"CC_H245_CONFERENCE_REQUEST_INDICATION",
"CC_H245_CONFERENCE_RESPONSE_INDICATION",
"CC_H245_CONFERENCE_COMMAND_INDICATION",	
"CC_H245_CONFERENCE_INDICATION_INDICATION",
"CC_FLOW_CONTROL_INDICATION",
"CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION",
"CC_REQUEST_MODE_INDICATION",	
"CC_REQUEST_MODE_RESPONSE_INDICATION",
"CC_VENDOR_ID_INDICATION",			
"CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION",
"CC_T120_CHANNEL_REQUEST_INDICATION",	
"CC_T120_CHANNEL_OPEN_INDICATION",			
"CC_BANDWIDTH_CHANGED_INDICATION",
"CC_ACCEPT_CHANNEL_INDICATION",
"CC_TERMINAL_ID_REQUEST_INDICATION",
"CC_PING_RESPONSE_INDICATION",
"CC_TERMINAL_NUMBER_INDICATION"
};
#endif	//DEBUG

HRESULT CH323Ctrl::ConfCallback (BYTE bIndication,
	HRESULT	hStatus, PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::ConfCallback");
	HRESULT hr = CC_NOT_IMPLEMENTED;
	DEBUGMSG(ZONE_CONN,("%s: %s\r\n", _fx_, i_strs[bIndication]));

	SHOW_OBJ_ETIME(i_strs[bIndication]);

	switch (bIndication)
	{
		case CC_RINGING_INDICATION:
			// (PCC_RINGING_CALLBACK_PARAMS) pConferenceCallbackParams;
			// user info may be available now and it may not be
			OnCallRinging(hStatus, (PCC_RINGING_CALLBACK_PARAMS) pConferenceCallbackParams);
			
		break;
		case CC_CONNECT_INDICATION:
			OnCallConnect(hStatus, (PCC_CONNECT_CALLBACK_PARAMS) pConferenceCallbackParams);
			hr = CC_OK;
		break;
		case CC_PEER_ADD_INDICATION:
		case CC_PEER_UPDATE_INDICATION:
		case CC_PEER_DROP_INDICATION:
		case CC_TERMINAL_NUMBER_INDICATION:
		break;
		
		case CC_HANGUP_INDICATION:
			OnHangup(hStatus);
			hr = CC_OK;
		break;
		case CC_CONFERENCE_TERMINATION_INDICATION:
		// September 1996 comments:
		// I don't know if there will also be a CC_HANGUP_INDICATION after this.
		// We're going to call Hangup() via Disconnect()
		// December 1996: Hangup() (excuse me, CC_Hangup()) no longer gives back a
		// CC_HANGUP_INDICATION in this state.  It returns an error.  The new behavior
		// seems to indicate that the call control channel is already dead at this point
		// so, set our flags as such!!!
			m_ChanFlags &= ~(CTRLF_OPEN);
			//set state to indicate disconnecting.
			GoNextPhase(CCS_Disconnecting);
			DoAdvise(CCEV_REMOTE_DISCONNECTING ,NULL);
			GoNextPhase(CCS_Idle);	// no need to ck retval - we're disconnected
				// notify the UI or application code or whatever..
			DoAdvise(CCEV_DISCONNECTED ,NULL);
			hr = CC_OK;
		break;
		case CC_PEER_CHANGE_CAP_INDICATION:
		break;
		
		//
		// Channel stuff
		//
		case CC_TX_CHANNEL_OPEN_INDICATION:
			OnChannelOpen(hStatus,(PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;
		break;
		case CC_RX_CHANNEL_REQUEST_INDICATION:
			OnChannelRequest(hStatus, (PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;			
		break;
		
		// the following 4 channel-centric indications have the same basic parameter
		// structure.  When we get the final Intel drop, we can clean it up. 1 - collapse
		// the parameters into a common "channel indication" structure. 2 - make sure
		// that a user pointer is stored in that structure for easy finding of channel
		// context.  3 - collapse separate channel event handling functions into one.
		case CC_MUTE_INDICATION:
		    OnMute(hStatus, (PCC_MUTE_CALLBACK_PARAMS)pConferenceCallbackParams);
        	hr = CC_OK;	
		break;
		case CC_UNMUTE_INDICATION:
		    OnUnMute(hStatus, (PCC_UNMUTE_CALLBACK_PARAMS)pConferenceCallbackParams);
        	hr = CC_OK;	
		break;
		case CC_RX_CHANNEL_CLOSE_INDICATION:
			OnRxChannelClose(hStatus,(PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;
		break;
		case CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION:
			OnTxChannelClose(hStatus,(PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;
		// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
		//typedef struct {
		//	CC_HCHANNEL				hChannel;
		//} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;
		break;
		case CC_FLOW_CONTROL_INDICATION:
		// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
		// typedef struct {
		//		CC_HCHANNEL				hChannel;
		//		DWORD					dwRate;
		//	} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;
		break;	
		
		case CC_BANDWIDTH_CHANGED_INDICATION:
		case CC_REQUEST_MODE_INDICATION:
		case CC_REQUEST_MODE_RESPONSE_INDICATION:
		break;
		
		case CC_ACCEPT_CHANNEL_INDICATION:
			hr = CC_OK;	
			OnChannelAcceptComplete(hStatus, (PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		//
		//	Misc commands and indications.  Some are related to channels
		//
		case CC_RX_NONSTANDARD_MESSAGE_INDICATION:
		break;
		case CC_H245_MISCELLANEOUS_COMMAND_INDICATION:
			OnMiscCommand(hStatus,
				(PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		case CC_H245_MISCELLANEOUS_INDICATION_INDICATION: // from the Department of Redundancy Department
			OnMiscIndication(hStatus,
				(PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		case CC_T120_CHANNEL_REQUEST_INDICATION:
			OnT120ChannelRequest(hStatus,(PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		case CC_T120_CHANNEL_OPEN_INDICATION:
			OnT120ChannelOpen(hStatus,(PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS)pConferenceCallbackParams);
		default:
		break;
	}
	return hr;

}


VOID CH323Ctrl::OnT120ChannelRequest(
	HRESULT hStatus,
	PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS pT120RequestParams)
{
	FX_ENTRY ("CH323Ctrl::OnT120ChannelRequest");
	PSOCKADDR_IN	pAddr;
	SOCKADDR_IN		sinD;
	CC_ADDR ChannelAddr;
	PCC_ADDR pChannelAddr;
	GUID mediaID;
	DWORD dwRejectReason = H245_REJ;
	BOOL bFound = FALSE;
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChannel = NULL;

	// look for a matching channel instance.
	while (pos)
	{
		pChannel = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChannel);

		hrLast = pChannel->GetMediaType(&mediaID);
		if(!HR_SUCCEEDED(hrLast))
			goto ERROR_EXIT;
		if(mediaID == MEDIA_TYPE_H323_T120)
		{
			bFound = TRUE;
			break;
		}
	}

	if(!HR_SUCCEEDED(hrLast) || !bFound)
	{
		// Non-default channels Not Yet Implemented!!!!
		// When it is, ask the parent conference object	to create another channel of the
		// specified media type.
		if(hrLast == CCO_E_NODEFAULT_CHANNEL)
			dwRejectReason = H245_REJ_TYPE_NOTAVAIL;

		goto REJECT_CHANNEL;
	}

	// if we are the H.245 master and have requested a T.120 channel already,
	// reject this request.
	if(m_ConferenceAttributes.bMaster && pChannel->GetHChannel())
	{
		goto REJECT_CHANNEL;
	}
	if(!pChannel->IsChannelEnabled())	//   allow this channel ?
	{
		goto REJECT_CHANNEL;
	}

	pChannel->SetHChannel(pT120RequestParams->hChannel);
	if(pT120RequestParams->pAddr)
	{
		// the other end is listening on the specified address
		sinD.sin_family = AF_INET;
		sinD.sin_addr.S_un.S_addr = htonl(pT120RequestParams->pAddr->Addr.IP_Binary.dwAddr);
		sinD.sin_port = htons(pT120RequestParams->pAddr->Addr.IP_Binary.wPort);
		
		DEBUGMSG(ZONE_CONN,("%s, requestor listening on port 0x%04x, address 0x%08lX\r\n",_fx_,
			pT120RequestParams->pAddr->Addr.IP_Binary.wPort,
			pT120RequestParams->pAddr->Addr.IP_Binary.dwAddr));

		hrLast = pChannel->AcceptRemoteAddress(&sinD);
		pChannelAddr = NULL;
	}
	else
	{
		// the channel selects its local address(es)/port(s)
		if(!pChannel->SelectPorts((LPIControlChannel)this))
		{
			ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
			hrLast = CCO_E_BAD_ADDRESS;
			goto REJECT_CHANNEL;
		}
		// get the address and ports of our end of the channel
		pAddr = pChannel->GetLocalAddress();
		// fixup channel addr pair structure.
		ChannelAddr.nAddrType = CC_IP_BINARY;
		ChannelAddr.bMulticast = FALSE;
		ChannelAddr.Addr.IP_Binary.wPort = ntohs(pAddr->sin_port);
		ChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);
		pChannelAddr = &ChannelAddr;
		DEBUGMSG(ZONE_CONN,("%s: accepting on port 0x%04x, address 0x%08lX\r\n",_fx_,
			ChannelAddr.Addr.IP_Binary.wPort,ChannelAddr.Addr.IP_Binary.dwAddr));
	}
	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest accepting");

	hrLast = CC_AcceptT120Channel(
		pChannel->GetHChannel(),
		FALSE,	// BOOL bAssociateConference,
		NULL, 	// PCC_OCTETSTRING					pExternalReference,
		pChannelAddr);

	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s, CC_AcceptT120Channel returned 0x%08lX\r\n",_fx_, hrLast));
		goto ERROR_EXIT;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest accepted");

	// LOOKLOOK !!! the 2 following lines would not be there because we should
	// Wait for CC_ACCEPT_CHANNEL_INDICATION.  But the CC_ACCEPT_CHANNEL_INDICATION
	// is missing if a send audio and send video channel is open at the time this
	// channel is accepted.  A bug in CALLCONT.DLL that needs investigating.
	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest, open done");

	// ******	
	// LOOKLOOK if OnChannelOpen returns an error, need to close the channel
	// but pChannel->Close() is not yet implemented for bidirectional channels	
	// ******
	
	m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_BIDI, pChannel, this);			
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );	//
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest done");

	return;

REJECT_CHANNEL:	
	{
	// need private HRESULT! don't overwrite the reason we're rejecting the channel!!	
		HRESULT hr;	
		ERRORMESSAGE(("%s, rejecting channel\r\n",_fx_));
	
		hr = CC_RejectChannel(pT120RequestParams->hChannel, dwRejectReason);
		if(hr != CC_OK)
		{
			ERRORMESSAGE(("%s, CC_RejectChannel returned 0x%08lX\r\n",_fx_, hr));
		}
	}	
ERROR_EXIT:
	return;
}

VOID CH323Ctrl::OnT120ChannelOpen(
	HRESULT hStatus,
	PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS pT120OpenParams)
{
	FX_ENTRY ("CH323Ctrl::OnT120ChannelOpen");
	SOCKADDR_IN sinD;
	GUID mediaID;
	ICtrlCommChan *pChannel = (ICtrlCommChan *)pT120OpenParams->dwUserToken;	
	// validate channel token - is this what we think it is?
	if(IsBadWritePtr(pChannel, sizeof(ICtrlCommChan)))
	{
		ERRORMESSAGE(("%s:invalid channel token: 0x%08lx\r\n",_fx_, pT120OpenParams->dwUserToken));
		return;
	}

#ifdef DEBUG
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChan;
	BOOL bValid = FALSE;
	// look for a matching channel instance.
	while (pos)
	{
		pChan = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChan);
		if(pChan == pChannel)
		{
			bValid = TRUE;
			break;
		}
	}
	if(!bValid)
	{
		ERRORMESSAGE(("%s:unrecognized token 0x%08lX\r\n",_fx_,
			pT120OpenParams->dwUserToken));
		return;
	}
#endif	//DEBUG

	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen");
	
	if(hStatus != CC_OK)
	{
		DEBUGMSG(ZONE_CONN,("%s: hStatus:0x%08lX\r\n",_fx_,hStatus));
		// LOOKLOOK need to interpret hStatus
		// let the channel know what happened.

		// if the request was rejected due to a collision of T.120 O.L.C. requests,
		// (other end is the master and other end also requested a T.120 channel)
		// then proceed with the call.

		if(m_ConferenceAttributes.bMaster)
		{
			// the slave would only reject in a real error condition
			pChannel->OnChannelOpen(CHANNEL_REJECTED);	
			// the channel knows what happened, so let it do the worrying.
			return;

		}
		else	// just a typical collision
		{
			return;
		}
	}
	// if the other end specified its listen address, use it
	if(pT120OpenParams->pAddr)
	{
		if(pT120OpenParams->pAddr->nAddrType != CC_IP_BINARY)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,
					pT120OpenParams->pAddr->nAddrType));
			goto ERROR_EXIT;
		}	
		
		// we now have the remote port info ( in host byte order)
		sinD.sin_family = AF_INET;
		sinD.sin_addr.S_un.S_addr = htonl(pT120OpenParams->pAddr->Addr.IP_Binary.dwAddr);
		sinD.sin_port = htons(pT120OpenParams->pAddr->Addr.IP_Binary.wPort);
		
		DEBUGMSG(ZONE_CONN,("%s, opened on port 0x%04x, address 0x%08lX\r\n",_fx_,
			pT120OpenParams->pAddr->Addr.IP_Binary.wPort,pT120OpenParams->pAddr->Addr.IP_Binary.dwAddr));

		hrLast = pChannel->AcceptRemoteAddress(&sinD);
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:AcceptRemoteAddress failed\r\n",_fx_));
			goto ERROR_EXIT;
		}
	}
	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen opening");

	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("%s:channel's OnChannelOpen() returned 0x%08lX\r\n", _fx_, hrLast));
		CloseChannel(pChannel);
		goto ERROR_EXIT;
	}

	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen open done");
	
	m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_BIDI, pChannel, this);	
	
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen done");
	return;
	
ERROR_EXIT:
	// need to cleanup, disconnect, etc.
	m_hCallCompleteCode = CCCI_CHANNEL_OPEN_ERROR;
	// let the parent Conference object know about the imminent disconnect
	DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
	hrLast = CCO_E_MANDATORY_CHAN_OPEN_FAILED;

	InternalDisconnect();
	return;

}

//
//	This once did something. Currently, it's called whenever a channel is opened.  The
//  call to GoNextPhase(CCS_Ready) changes state and posts a notification upward, but
//  that notification is currently ignored.  (it's useless)
//  Reminder to mikev: A new notification is needed to indicate that capabilities
//  have been exchanged and it is OK to open channels.
//
VOID CH323Ctrl::CheckChannelsReady()
{
	GoNextPhase(CCS_Ready);
}
// handles local hangup indication
VOID CH323Ctrl::OnHangup(HRESULT hStatus)
{
	FX_ENTRY ("CH323Ctrl::OnHangup");
	DEBUGMSG(ZONE_CONN,("%s:CC_HANGUP_INDICATION in phase %d\r\n", _fx_, m_Phase));
	switch(m_Phase)
	{
		case CCS_Disconnecting:
			GoNextPhase(CCS_Idle);
			Cleanup();
			DoAdvise(CCEV_DISCONNECTED ,NULL);
		break;
		
		default: // do nothing
			ERRORMESSAGE(("%s:Unexpected CC_HANGUP_INDICATION\r\n",_fx_));
		break;
	}
}

HRESULT CH323Ctrl::CloseChannel(ICtrlCommChan* pChannel)
{
	FX_ENTRY ("CH323Ctrl::CloseChannel");
	if(!pChannel->IsChannelOpen())
	{
		ERRORMESSAGE(("%s: channel is not open\r\n",_fx_));
		hrLast = CCO_E_INVALID_PARAM;
		goto EXIT;
	}

	hrLast = CC_CloseChannel(pChannel->GetHChannel());
	if(!HR_SUCCEEDED(hrLast))
	{	
		ERRORMESSAGE(("%s: CC_CloseChannel returned 0x%08lX\r\n",_fx_, hrLast));
		goto EXIT;
	}
	// make the channel handle its own media stream specific shutdown and cleanup chores
	hrLast = pChannel->OnChannelClose(CHANNEL_CLOSED);	
	
EXIT:
	return hrLast;
}

HRESULT CH323Ctrl::AddChannel(ICtrlCommChan * pCommChannel, LPIH323PubCap pCapabilityResolver)
{
	ICtrlCommChan *pChan = NULL;


	// get the ICtrlCommChannel interface of each channel
	hrLast = pCommChannel->QueryInterface(IID_ICtrlCommChannel,(void **)&pChan);
	if(!HR_SUCCEEDED(hrLast))
		goto ADD_ERROR;
	
	// make the channel aware of its new scope
	hrLast = pChan->BeginControlSession(this, pCapabilityResolver);
	if(!HR_SUCCEEDED(hrLast))
		goto ADD_ERROR;
	// add it to the list			
	m_ChannelList.AddTail(pChan);
	return hrSuccess;

ADD_ERROR:
	if(pChan)
		pChan->Release();
	return CHAN_E_INVALID_PARAM;

}



HRESULT CH323Ctrl::OpenChannel(ICtrlCommChan* pChan, IH323PubCap *pCapResolver,
	MEDIA_FORMAT_ID dwIDLocalSend, MEDIA_FORMAT_ID dwIDRemoteRecv)
{
	FX_ENTRY ("CH323Ctrl::OpenChannel");
	CC_TERMCAP				H245ChannelCap;
	PSOCKADDR_IN			pAddr;
	CC_ADDR 				ChannelAddr;
	LPVOID pChannelParams;
	PCC_TERMCAP pSaveChannelCapability = NULL;
	UINT uLocalParamSize;
	BYTE SessionID;
	BYTE payload_type;
	DWORD_PTR dwhChannel;
	GUID mediaID;

	ASSERT((pChan->IsChannelOpen()== FALSE) && (pChan->IsOpenPending()== FALSE));
	hrLast = pChan->GetMediaType(&mediaID);
	if(!HR_SUCCEEDED(hrLast))
		goto CHANNEL_ERROR;
		
	if (mediaID == MEDIA_TYPE_H323_T120)
	{
		if(pChan->GetHChannel())	// already accepted a T.120 channel?
		{
			ERRORMESSAGE(("%s, already have a pending channel\r\n",_fx_));
			goto CHANNEL_ERROR;	// this is not an error, excuse the label
		}

		// test the no common capability case.  notify the conference object of the
		// inability to open the channel, and return success
		
		if(dwIDLocalSend == INVALID_MEDIA_FORMAT)
		{
			pChan->OnChannelOpen(CHANNEL_NO_CAPABILITY);
			return hrSuccess;
		}
		// There is no "standard" rule regarding which end specifies the "listen"
		// address of a T.120 channel. However: we want NetMeeting-NetMeeting calls
		// to behave consistently (the "caller" always "places the T.120 call").
		// Therefore, specify the address if this end is not the originator.  That will
		// force the other end to specify it's address.
		
		if(IsOriginating(m_ChanFlags))
		{
			pAddr = NULL;	// the other end "listens" and we "connect"
		}
		else	// listen on local address
		{
			// select ports if they are not already selected
			if(!pChan->SelectPorts((LPIControlChannel)this))
			{
				ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
				hrLast = CCO_E_BAD_ADDRESS;
				goto CHANNEL_ERROR;
			}
			
			// get the address and port
			pAddr = pChan->GetLocalAddress();
			// fixup channel addr structure.
			ChannelAddr.nAddrType = CC_IP_BINARY;
			ChannelAddr.bMulticast = FALSE;
			ChannelAddr.Addr.IP_Binary.wPort = ntohs(pAddr->sin_port);
			ChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);
		}

		hrLast =  CC_OpenT120Channel(
			// CC_HCONFERENCE	hConference,
			m_hConference,
	        // PCC_HCHANNEL     phChannel,
	        &dwhChannel,
			// BOOL				bAssociateConference,
			FALSE,
			// PCC_OCTETSTRING	pExternalReference,
			NULL,
			// PCC_ADDR			pAddr,
			IsOriginating(m_ChanFlags) ? NULL : &ChannelAddr,
			// DWORD			dwChannelBitRate,
			0,
			// DWORD			dwUserToken);
			(DWORD_PTR)pChan);

		// and fall out to test hrLast, etc.
	}
	else	// is an audio or video channel
	{
		// test the no common capability case.  If the channel is mandatory,
		// return an error, else notify the conference object of the
		// inability to open the channel, and return success
		
		if((dwIDLocalSend == INVALID_MEDIA_FORMAT) ||(dwIDRemoteRecv == INVALID_MEDIA_FORMAT))
		{
			pChan->OnChannelOpen(CHANNEL_NO_CAPABILITY);
			return hrSuccess;
		}
				
		//
		//   test if we need to try to open this !!!
		//
		if(!pChan->IsChannelEnabled())
		{
			return hrSuccess;
		}
		
		SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel");
			
		// Get the remote channel parameters for
		// the send channel -  these parameters are used to request a channel
		uLocalParamSize = pCapResolver->GetLocalSendParamSize((MEDIA_FORMAT_ID)dwIDLocalSend);
		pChannelParams=MemAlloc (uLocalParamSize);
		if (pChannelParams == NULL) {
		   //Doom
		   hrLast = CCO_E_SYSTEM_ERROR;
		   goto CHANNEL_ERROR;
		}
		hrLast = pCapResolver->GetEncodeParams(
				(LPVOID)&H245ChannelCap, sizeof(H245ChannelCap),
				(LPVOID)pChannelParams, uLocalParamSize,
				(AUDIO_FORMAT_ID)dwIDRemoteRecv,
				(AUDIO_FORMAT_ID)dwIDLocalSend);
	 	if(!HR_SUCCEEDED(hrLast))
		{	
			ERRORMESSAGE(("%s: GetEncodeParams returned 0x%08lX\r\n",_fx_, hrLast));
			goto CHANNEL_ERROR;
		}

		// set session ID and payload type.  Note that payload type is relevant only for
		// dynamic payloads.  Otherwise, it must be zero.
		if (H245ChannelCap.DataType == H245_DATA_AUDIO)
		{
			payload_type = ((PAUDIO_CHANNEL_PARAMETERS)pChannelParams)->RTP_Payload;
			// Session ID is 1 for Audio, 2 for Video . H245 7.3.1 (H2250 Logical Channel Param)
		   	SessionID=1;
		}
		else if (H245ChannelCap.DataType == H245_DATA_VIDEO)
		{
			payload_type = ((PVIDEO_CHANNEL_PARAMETERS)pChannelParams)->RTP_Payload;
		 	SessionID=2;
		}
		// payload_type must be zero for fixed payload types.  Weird.
		if(!IsDynamicPayload(payload_type))
			payload_type = 0;
			
		// create a marshalled version of channel parameters and store it in the channel
		// for later reference
		if(H245ChannelCap.ClientType == H245_CLIENT_AUD_NONSTD)
		{
			// Make a flat copy of the nonstandard capability to store as the channel
			// parameter
			UINT uSize = H245ChannelCap.Cap.H245Aud_NONSTD.data.length;
			pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
			if(!pSaveChannelCapability)
			{
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}	
			// copy fixed part
			memcpy(pSaveChannelCapability, &H245ChannelCap, sizeof(CC_TERMCAP));
			// variable part follows the fixed part
			pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value	
				= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
			// copy variable part
			memcpy(pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value,
				H245ChannelCap.Cap.H245Aud_NONSTD.data.value,
				H245ChannelCap.Cap.H245Aud_NONSTD.data.length);
			// and length
			pSaveChannelCapability->Cap.H245Aud_NONSTD.data.length
				= H245ChannelCap.Cap.H245Aud_NONSTD.data.length;
			
			// make the channel remember the channel parameters.
			// a zero size as the second arg means that a preallocated chunk is being passed
			hrLast = pChan->ConfigureCapability(pSaveChannelCapability, 0,
				pChannelParams, uLocalParamSize);	
			if(!HR_SUCCEEDED(hrLast))
			{
				ERRORMESSAGE(("%s:ConfigureCapability returned 0x%08lx\r\n",_fx_, hrLast));
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}
			pSaveChannelCapability=NULL;  // the channel owns this memory now
		}
		else if(H245ChannelCap.ClientType == H245_CLIENT_VID_NONSTD)
		{
			// Make a flat copy of the nonstandard capability to store as the channel
			// parameter
			UINT uSize = H245ChannelCap.Cap.H245Vid_NONSTD.data.length;
			pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
			if(!pSaveChannelCapability)
			{
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}	
			// copy fixed part
			memcpy(pSaveChannelCapability, &H245ChannelCap, sizeof(CC_TERMCAP));
			// variable part follows the fixed part
			pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value	
				= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
			// copy variable part
			memcpy(pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value,
				H245ChannelCap.Cap.H245Vid_NONSTD.data.value,
				H245ChannelCap.Cap.H245Vid_NONSTD.data.length);
			// and length
			pSaveChannelCapability->Cap.H245Vid_NONSTD.data.length
				= H245ChannelCap.Cap.H245Vid_NONSTD.data.length;
			
			// make the channel remember the channel parameters.
			// a zero size as the second arg means that a preallocated chunk is being passed
			hrLast = pChan->ConfigureCapability(pSaveChannelCapability, 0,
				pChannelParams, uLocalParamSize);	
			if(!HR_SUCCEEDED(hrLast))
			{
				ERRORMESSAGE(("%s:ConfigureCapability returned 0x%08lx\r\n",_fx_, hrLast));
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}
			pSaveChannelCapability=NULL;  // the channel owns this memory now
		}
		else
		{
			// only need to remember the already-flat H.245 cap structure.
			hrLast = pChan->ConfigureCapability(&H245ChannelCap, sizeof(CC_TERMCAP),
				pChannelParams, uLocalParamSize);	
			if(!HR_SUCCEEDED(hrLast))
			{
				ERRORMESSAGE(("%s:ConfigureCapability returned 0x%08lx\r\n",_fx_, hrLast));
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}
		}

		// remember both versions of the resolved send format for the channel
		// we're about to open	
		pChan->SetNegotiatedLocalFormat(dwIDLocalSend);	
		pChan->SetNegotiatedRemoteFormat(dwIDRemoteRecv);
		
		SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel done configuring");

		// select ports if they are not already selected
		if(!pChan->SelectPorts((LPIControlChannel)this))
		{
			ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
			hrLast = CCO_E_BAD_ADDRESS;
			goto CHANNEL_ERROR;
		}
		
		// get the address and port of our RTCP channel
		pAddr = pChan->GetLocalAddress();
		// fixup channel addr structure. There are two ports, but in RTP, it is implicit
		// that the RTCP control port is the next highest port number.
		// The open logical channel request needs the reverse RTCP port to be specified.
		ChannelAddr.nAddrType = CC_IP_BINARY;
		ChannelAddr.bMulticast = FALSE;
		ChannelAddr.Addr.IP_Binary.wPort = pChan->GetLocalRTCPPort();
		ChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);

		DEBUGMSG(ZONE_CONN,("%s: opening using RTCP port 0x%04x, address 0x%08lX\r\n",_fx_,
			ChannelAddr.Addr.IP_Binary.wPort,ChannelAddr.Addr.IP_Binary.dwAddr));
		
		DEBUGMSG(ZONE_CONN,("%s: requesting capability ID:0x%08lX\r\n",
			_fx_, H245ChannelCap.CapId));

		// open a channel
		SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel, opening");
											
		hrLast = CC_OpenChannel(m_hConference, &dwhChannel,
			SessionID,
			0,  //	BYTE bAssociatedSessionID,
			TRUE, //BOOL bSilenceSuppression,  WE ALWAYS DO SILENCE SUPPRESSION
			&H245ChannelCap,	
			&ChannelAddr, 	// the local address on which we're listening for RTCP
			payload_type,	// PAYLOAD TYPE
			0,				//	DWORD dwChannelBitRate,
			(DWORD_PTR)pChan);	// use the channel pointer as the user token
	} // end else is an audio or video channel
	
	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s: OpenChannel returned 0x%08lX\r\n",_fx_, hrLast));
		goto CHANNEL_ERROR;
	}		
	else
	{
		pChan->SetHChannel(dwhChannel);
		pChan->OnChannelOpening();
	}

	SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel done");
	return hrLast;

CHANNEL_ERROR:
	if(pSaveChannelCapability)
		MemFree(pSaveChannelCapability);
		
	return hrLast;
}


VOID CH323Ctrl::CleanupConferenceAttributes()
{
	WORD w;
	if(m_ConferenceAttributes.pParticipantList->ParticipantInfoArray)
	{
		for(w=0;w<m_ConferenceAttributes.pParticipantList->wLength;w++)
		{	
			if(m_ConferenceAttributes.pParticipantList->
				ParticipantInfoArray[w].TerminalID.pOctetString)
			{
				MemFree(m_ConferenceAttributes.pParticipantList->
					ParticipantInfoArray[w].TerminalID.pOctetString);
			}

		}
		
		MemFree(m_ConferenceAttributes.pParticipantList->ParticipantInfoArray);
	}
	m_ConferenceAttributes.pParticipantList->ParticipantInfoArray = NULL;
	m_ConferenceAttributes.pParticipantList->wLength = 0;
	
}	

HRESULT CH323Ctrl::AllocConferenceAttributes()
{
	WORD w;
	#define MAX_PART_LEN 128
	if(m_ConferenceAttributes.pParticipantList->wLength)
	{
		m_ConferenceAttributes.pParticipantList->ParticipantInfoArray =
			(PCC_PARTICIPANTINFO) MemAlloc (sizeof(CC_PARTICIPANTINFO)
				* m_ConferenceAttributes.pParticipantList->wLength);
				
		if(!m_ConferenceAttributes.pParticipantList->ParticipantInfoArray)
			return CCO_E_OUT_OF_MEMORY;
			
		for(w=0;w<m_ConferenceAttributes.pParticipantList->wLength;w++)
		{	
			m_ConferenceAttributes.pParticipantList->
				ParticipantInfoArray[w].TerminalID.pOctetString
				= (BYTE *)MemAlloc(MAX_PART_LEN);
			if(m_ConferenceAttributes.pParticipantList->
				ParticipantInfoArray[w].TerminalID.pOctetString)
			{
				m_ConferenceAttributes.pParticipantList->
					ParticipantInfoArray[w].TerminalID.wOctetStringLength
					= MAX_PART_LEN;
			}
			else
			{
				m_ConferenceAttributes.pParticipantList->
					ParticipantInfoArray[w].TerminalID.wOctetStringLength =0;
				return CCO_E_OUT_OF_MEMORY;
			}
		}
	}
	return hrSuccess;
}

VOID CH323Ctrl::OnCallConnect(HRESULT hStatus, PCC_CONNECT_CALLBACK_PARAMS pConfParams)
{
	FX_ENTRY ("CH323Ctrl::OnCallConnect");
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	CC_TERMCAP				H245ChannelCap;
	PCC_TERMCAP 			pChannelCap = NULL;
	CapsCtl *pCapabilityResolver = NULL;
	GUID mediaID;
	POSITION pos = NULL;
	ICtrlCommChan *pChan = NULL;

	if(hStatus != CC_OK)
	{
		ERRORMESSAGE(("%s hStatus=0x%08lx in phase %d\r\n",_fx_,hStatus,m_Phase));

		// test for gatekeeper admission reject
		// FACILITY_GKIADMISSION
		if(CUSTOM_FACILITY(hStatus) == FACILITY_GKIADMISSION)
		{
			// pass this code intact - do not remap
			m_hCallCompleteCode = hStatus;
		}
		else
		{
			switch (hStatus)
			{
				default:
				// reason is unknown
					m_hCallCompleteCode = CCCI_UNKNOWN;
				break;
				case  CC_PEER_REJECT:
					if(m_Phase == CCS_Connecting)
					{
						switch(pConfParams->bRejectReason)
						{
							case CC_REJECT_ADAPTIVE_BUSY:
							case CC_REJECT_IN_CONF:
							case CC_REJECT_USER_BUSY:
								m_hCallCompleteCode = CCCI_BUSY;
							break;
							case CC_REJECT_SECURITY_DENIED:
								m_hCallCompleteCode = CCCI_SECURITY_DENIED;
							break;
							case CC_REJECT_NO_ANSWER:
							case CC_REJECT_TIMER_EXPIRED:
								m_hCallCompleteCode = CCCI_NO_ANSWER_TIMEOUT;
							break;
							case CC_REJECT_GATEKEEPER_RESOURCES:
								m_hCallCompleteCode = CCCI_GK_NO_RESOURCES;
							break;
							default:
								//#define CC_REJECT_NO_BANDWIDTH              1
								//#define CC_REJECT_GATEKEEPER_RESOURCES      2
								//#define CC_REJECT_UNREACHABLE_DESTINATION   3
								//#define CC_REJECT_DESTINATION_REJECTION     4
								//#define CC_REJECT_INVALID_REVISION          5
								//#define CC_REJECT_NO_PERMISSION             6
								//#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
								//#define CC_REJECT_GATEWAY_RESOURCES         8
								//#define CC_REJECT_BAD_FORMAT_ADDRESS        9
								//#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
	// would be nice to handle this -->> //#define CC_REJECT_CALL_FORWARDED            13
								//#define CC_REJECT_ROUTE_TO_MC               14
								//#define CC_REJECT_UNDEFINED_REASON          15
								//#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
								//#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
								//#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
								//#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
								//#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
								//#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
								//#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call

								m_hCallCompleteCode = CCCI_REJECTED;
							break;
						}
					}
					else
					{
						ERRORMESSAGE(("%s:Received CC_PEER_REJECT in state %d\r\n",_fx_,m_Phase));
					}
				break;
				case  CC_INTERNAL_ERROR:
					m_hCallCompleteCode = CCCI_LOCAL_ERROR;
				break;

			}
		}
		// let the parent Conference object know  (unless this is the answering end)
		if(m_Phase == CCS_Connecting)
		{
			DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
		}

		InternalDisconnect();
		return;
	}
	else if(!pConfParams)
	{
		ERRORMESSAGE(("OnCallConnect: null pConfParams\r\n"));
		m_hCallCompleteCode = CCCI_LOCAL_ERROR;
		DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
		InternalDisconnect();
		return;
	}
	
    SetRemoteVendorID(pConfParams->pVendorInfo);

	GoNextPhase(CCS_Opening);
	m_ChanFlags |= (CTRLF_OPEN);
	DEBUGMSG(ZONE_CONN,("%s:CONNECTION_CONNECTED\r\n", _fx_));
	if((!pConfParams->pLocalAddr) || (pConfParams->pLocalAddr->nAddrType != CC_IP_BINARY))
	{
		if(pConfParams->pLocalAddr)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,pConfParams->pLocalAddr->nAddrType));
		}
		else
		{
			ERRORMESSAGE(("%s: null local address\r\n",_fx_));
		}
	
		ERRORMESSAGE(("%s:where's the local address????\r\n",_fx_));
					PHOSTENT phe;
					PSOCKADDR_IN psin;
				 	char szTemp[200];
					LPCSTR lpHostName;		
					gethostname(szTemp,sizeof(szTemp));
			    	lpHostName = szTemp;
					psin = &local_sin;
					phe = gethostbyname(lpHostName);
					if (phe != NULL)
					{
				   		memcpy((char FAR *)&(psin->sin_addr), phe->h_addr,phe->h_length);
						psin->sin_family = AF_INET;
					}
		
	}	
	else
	{
		// remember our local address
		local_sin.sin_family = AF_INET;
		// in host byte order
		local_sin.sin_addr.S_un.S_addr = htonl(pConfParams->pLocalAddr->Addr.IP_Binary.dwAddr);
		// in host byte order
		local_sin.sin_port = htons(pConfParams->pLocalAddr->Addr.IP_Binary.wPort);
	}
	DEBUGMSG(ZONE_CONN,("%s local port 0x%04x, address 0x%08lX\r\n",_fx_,
	local_sin.sin_port,local_sin.sin_addr.S_un.S_addr));	
	
	// get remote address
	if((!pConfParams->pPeerAddr) || (pConfParams->pPeerAddr->nAddrType != CC_IP_BINARY))
	{
		if(pConfParams->pPeerAddr)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,pConfParams->pPeerAddr->nAddrType));
		}
		else
		{
			ERRORMESSAGE(("%s: null local address\r\n",_fx_));
		}	
	}
	else
	{
		// remember the remote peer address
		remote_sin.sin_family = AF_INET;
		// in host byte order
		remote_sin.sin_addr.S_un.S_addr = htonl(pConfParams->pPeerAddr->Addr.IP_Binary.dwAddr);
		// in host byte order
		remote_sin.sin_port = htons(pConfParams->pPeerAddr->Addr.IP_Binary.wPort);
	}
//
// The only available remote user information in this state is the Q.931 display name.
// If we are the callee, we got the caller alias name (wire format was unicode) in
// the listen callback parameters.  If we are the caller, we really need the callee
// alias name(s), which are not propagated.   Fallback to the Q.931 display name (ASCII)
//

	NewRemoteUserInfo(NULL, pConfParams->pszPeerDisplay);

	// release any stale memory, reset ConferenceAttributes struture
	CleanupConferenceAttributes();
	// get the number of conference participants etc.
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect getting attribs 1");

	hrLast = CC_GetConferenceAttributes(m_hConference, &m_ConferenceAttributes);
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,CC_GetConferenceAttributes returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;

	}
	hrLast = AllocConferenceAttributes();
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,AllocConferenceAttributes returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;

	}
	// now get the real attributes
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect getting attribs 2");
	hrLast = CC_GetConferenceAttributes(m_hConference, &m_ConferenceAttributes);
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,CC_GetConferenceAttributes returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;

	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect got attribs");
	
	m_ConferenceID =m_ConferenceAttributes.ConferenceID;
	m_bMultipointController = m_ConferenceAttributes.bMultipointController;

	hrLast = m_pConfAdvise->GetCapResolver((LPVOID *)&pCapabilityResolver, OID_CAP_ACM_TO_H323);
	if(!HR_SUCCEEDED(hrLast) || (pCapabilityResolver == NULL))
	{// fatal error
		ERRORMESSAGE(("%s,null resolver\r\n", _fx_));
		goto CONNECT_ERROR;

	}
		
	// get the remote capabilities
	// cache the remote capabilities now
	pTermCapList = pConfParams->pTermCapList;
	pTermCapDescriptors = pConfParams->pTermCapDescriptors;
	hrLast = pCapabilityResolver->AddRemoteDecodeCaps(pTermCapList, pTermCapDescriptors, &m_RemoteVendorInfo);
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,AddRemoteDecodeCaps returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect saved caps");
	DoAdvise(CCEV_CAPABILITIES_READY, NULL);	// put connobj in a state to allow other
												// channels to be added & opened
	//	
	//	 notify UI here.  It wants remote user info.
	//
	ConnectNotify(CCEV_CONNECTED);	
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect notified");
	return;

CONNECT_ERROR:
	// release all channels
	ReleaseAllChannels();
	InternalDisconnect();
}

// LOOKLOOK methinks ConnectNotify might need to propagate the conference ID.
// This will be a moot point if we have a real property interface.  Watch
// for this in the meantime
VOID CH323Ctrl::ConnectNotify(DWORD dwEvent)		
{
	FX_ENTRY ("CH323Ctrl::ConnectNotify");
	CTRL_USER_INFO UserInfo;
	LPWSTR lpwstr = NULL;
	WCHAR wc =0;

	// init to zero in case of error
	UserInfo.dwCallerIDSize = 0;
	UserInfo.lpvCallerIDData = NULL;
	UserInfo.lpvRemoteProtocolInfo = NULL;	
	UserInfo.lpvLocalProtocolInfo = NULL;

	// alias address strings, e.g. caller ID, are in UNICODE
	if(	m_pRemoteAliasItem &&
		m_pRemoteAliasItem->pData &&
		*((LPWSTR*)(m_pRemoteAliasItem->pData)))
	{
		lpwstr =(LPWSTR)m_pRemoteAliasItem->pData;
	}
	else
	{
		lpwstr = pwszPeerDisplayName;
	}

	if(lpwstr)
	{
		if(pwszPeerAliasName)
		{
			MemFree(pwszPeerAliasName);
		}
		ULONG ulSize = (lstrlenW(lpwstr) + 1) * sizeof(WCHAR);
		pwszPeerAliasName = (LPWSTR)MemAlloc(ulSize);
		LStrCpyW(pwszPeerAliasName, lpwstr);
		// point to user name stuff
		UserInfo.dwCallerIDSize = ulSize;
		UserInfo.lpvCallerIDData = (LPVOID)pwszPeerAliasName;
	}
	else
	{
		// point to the single NULL character on the stack
		UserInfo.dwCallerIDSize = 1;
		UserInfo.lpvCallerIDData = &wc;
	}
	DoAdvise(dwEvent, &UserInfo);
}		


	
VOID CH323Ctrl::NewRemoteUserInfo(PCC_ALIASNAMES pRemoteAliasNames,
		LPWSTR pwszRemotePeerDisplayName)
{
	FX_ENTRY ("CH323Ctrl::NewRemoteUserInfo");
	ULONG ulSize;
	PCC_ALIASITEM pItem;
	WORD wC;
	// make a copy of the user display name (what else???)  We need to hold this
	// at least until the parent object is notified and has a chance to copy the
	// information

	// Future implementation will store each item as a distinct property.
	// These will be accessable via the IProperty interface
	
	// find the display name if it exists
	if(pRemoteAliasNames)
	{
		wC = pRemoteAliasNames->wCount;
		pItem = pRemoteAliasNames->pItems;
		while (wC--)
		{
			if(!pItem)
			{
				continue;
			}
			if(pItem->wType == CC_ALIAS_H323_ID)
			{
				if(!pItem->wDataLength  || !pItem->pData)
				{
					continue;
				}
				
				if(m_pRemoteAliasItem)
				{
					DEBUGMSG(ZONE_CONN,("%s: Releasing previous user info\r\n",_fx_));
					MemFree(m_pRemoteAliasItem);
				}
				// The H323 ID is UNICODE, and needs to be converted to ANSI
				// for propagation to UI/client app.  The conversion is done
				// in ConnectNotify()

				// need enough mem for the struct, the name, + null terminator
				ulSize = ((pItem->wDataLength +1)*sizeof(WCHAR)) + sizeof(CC_ALIASITEM);
				
				m_pRemoteAliasItem = (PCC_ALIASITEM)MemAlloc(ulSize);
				memcpy(m_pRemoteAliasItem, pItem, sizeof(CC_ALIASITEM));	
				m_pRemoteAliasItem->pData = (WCHAR*)(((char *)m_pRemoteAliasItem)+sizeof(CC_ALIASITEM));
				memcpy(m_pRemoteAliasItem->pData, pItem->pData, pItem->wDataLength*sizeof(WCHAR));
				// need to null terminate it
				*(WCHAR *)(((BYTE *)m_pRemoteAliasItem->pData) + pItem->wDataLength*sizeof(WCHAR))
					= (WCHAR)0;
			}
			pItem++;
		}
	}
	if(pwszRemotePeerDisplayName)
	{
		if(pwszPeerDisplayName)
		{
			DEBUGMSG(ZONE_CONN,("%s: Releasing previous pwszPeerDisplayName\r\n",_fx_));
			MemFree(pwszPeerDisplayName);
		}
		// this WAS the Q.931 display name which WAS always ascii
		// ulSize = lstrlen(szRemotePeerDisplayName) + 1;
		// Now it's unicode
		ulSize = (lstrlenW(pwszRemotePeerDisplayName) + 1)* sizeof(WCHAR);
		pwszPeerDisplayName = (LPWSTR)MemAlloc(ulSize);
		memcpy(pwszPeerDisplayName, pwszRemotePeerDisplayName, ulSize);	
	}
}

VOID CH323Ctrl::OnCallRinging(HRESULT hStatus, PCC_RINGING_CALLBACK_PARAMS pRingingParams)
{
	if(pRingingParams->pNonStandardData)
	{

		// nyi
	}
	DoAdvise(CCEV_RINGING, NULL);
}



HRESULT CH323Ctrl::FindDefaultRXChannel(PCC_TERMCAP pChannelCapability, ICtrlCommChan **lplpChannel)
{
	FX_ENTRY ("CH323Ctrl::FindDefaultRXChannel");
	HRESULT hr = hrSuccess;
	GUID mediaID;
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChannel;
	if(!pChannelCapability | !lplpChannel)
	{
		ERRORMESSAGE(("%s: null param:pcap:0x%08lX, pchan:0x%08lX\r\n",_fx_,
			pChannelCapability, lplpChannel));
		hr = CCO_E_INVALID_PARAM;
		goto EXIT;
	}

	// look for a matching channel instance.
	while (pos)
	{
		pChannel = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChannel);
		if(pChannel->IsSendChannel() == FALSE)
		{
			hr = pChannel->GetMediaType(&mediaID);
			if(!HR_SUCCEEDED(hr))
				goto EXIT;
			if(((mediaID == MEDIA_TYPE_H323AUDIO) && (pChannelCapability->DataType ==H245_DATA_AUDIO))	
			 	|| ((mediaID == MEDIA_TYPE_H323VIDEO) && (pChannelCapability->DataType ==H245_DATA_VIDEO)))
			{
				*lplpChannel = pChannel;
				return hrSuccess;
			}
		}
	}
	// fallout if not found
	hr = CCO_E_NODEFAULT_CHANNEL;
EXIT:
	return hr;
}	

#ifdef DEBUG
VOID DumpWFX(LPWAVEFORMATEX lpwfxLocal, LPWAVEFORMATEX lpwfxRemote)
{
	FX_ENTRY("DumpWFX");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(lpwfxLocal)
	{
		ERRORMESSAGE((" -------- Local --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxLocal->wFormatTag, lpwfxLocal->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxLocal->nSamplesPerSec, lpwfxLocal->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxLocal->nBlockAlign, lpwfxLocal->wBitsPerSample, lpwfxLocal->cbSize));
	}
	if(lpwfxRemote)
	{
			ERRORMESSAGE((" -------- Remote --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxRemote->wFormatTag, lpwfxRemote->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxRemote->nSamplesPerSec, lpwfxRemote->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxRemote->nBlockAlign, lpwfxRemote->wBitsPerSample, lpwfxRemote->cbSize));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpChannelParameters");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap1->DataType,pChanCap1->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap1->Dir,pChanCap1->CapId));
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap2->DataType,pChanCap2->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap2->Dir,pChanCap2->CapId));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpNonstdParameters");
	
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	DumpChannelParameters(pChanCap1, pChanCap2);
	
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		if(pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap1->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("unrecognized nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		if(pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap2->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
#else
#define DumpWFX(x,y)
#define DumpChannelParameters(x,y)
#define DumpNonstdParameters(x,y)
#endif

// make sure requested channel parameters are valid (data type, ID and capability
// structure are consistent).  Also obtains the local channel parameters needed
// to deal with the resulting stream
//
BOOL CH323Ctrl::ValidateChannelParameters(PCC_TERMCAP pChanCapLocal, PCC_TERMCAP pChanCapRemote)
{
	FX_ENTRY ("CH323Ctrl::ValidateChannelParameters");
	if((pChanCapLocal->DataType != pChanCapRemote->DataType)
	|| (pChanCapLocal->ClientType != pChanCapRemote->ClientType))
	{
		DEBUGMSG(ZONE_CONN,("%s:unmatched type\r\n",_fx_));
		DumpChannelParameters(pChanCapLocal, pChanCapRemote);
		return FALSE;
	}
	if(pChanCapLocal->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		PNSC_AUDIO_CAPABILITY pNSCapLocal, pNSCapRemote;
		
		if((pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice
			 != pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice )
		||(pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode
			!= pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode)
		||(pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension
			!= pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension)
		||(pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode
			!= pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode)
		||(pChanCapLocal->Cap.H245Aud_NONSTD.data.length
			!= pChanCapRemote->Cap.H245Aud_NONSTD.data.length))
		{
			DEBUGMSG(ZONE_CONN,("%s:unmatched NonStd capability\r\n",_fx_));
			DumpNonstdParameters(pChanCapLocal, pChanCapRemote);
			return FALSE;
		}

		//
		pNSCapLocal = (PNSC_AUDIO_CAPABILITY)pChanCapLocal->Cap.H245Aud_NONSTD.data.value;
		pNSCapRemote = (PNSC_AUDIO_CAPABILITY)pChanCapRemote->Cap.H245Aud_NONSTD.data.value;

		// we only know about NSC_ACM_WAVEFORMATEX at this time
		if(pNSCapRemote->cap_type != NSC_ACM_WAVEFORMATEX)
		{
			DEBUGMSG(ZONE_CONN,("%s:unrecognized NonStd capability type %d\r\n",_fx_, pNSCapRemote->cap_type));
			return FALSE;
		}
		if((pNSCapLocal->cap_data.wfx.cbSize != pNSCapRemote->cap_data.wfx.cbSize)
		|| (memcmp(&pNSCapLocal->cap_data.wfx, &pNSCapRemote->cap_data.wfx, sizeof(WAVEFORMATEX)) != 0))
		{
			DumpWFX(&pNSCapLocal->cap_data.wfx, &pNSCapRemote->cap_data.wfx);
			return FALSE;
		}
		
	}
	else
	{
		
	}
	// if it falls out, it's valid
	return TRUE;

}


BOOL CH323Ctrl::ConfigureRecvChannelCapability(
	ICtrlCommChan *pChannel,
	PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams)
{
	FX_ENTRY ("CH323Ctrl::ConfigureRecvChannelCapability");
	//IH323PubCap *pCapObject = NULL;
	CapsCtl *pCapObject = NULL;
	// CCapability *pCapObject = NULL;			
	DWORD dwFormatID =INVALID_AUDIO_FORMAT;
	PCC_TERMCAP pChannelCapability = pChannelParams->pChannelCapability, pSaveChannelCapability = NULL;
	UINT uSize, uLocalParamSize;
	LPVOID lpvData;
	LPVOID pLocalParams;			
	
	DEBUGMSG(ZONE_CONN,("%s: requested capability ID:0x%08lX, dir %d, type %d\r\n",
		_fx_, pChannelCapability->CapId, pChannelCapability->Dir,
			pChannelCapability->DataType));
			

	// at one time, we thought the capability ID would be valid
	// and we would be receiving the format specified in pChannelCapability->CapId
	// but it IS NOT VALID.   The only viable info is in the channel parameters.
	// The  code would be --->>>  dwFormatID = pChannelCapability->CapId;

	// the ID *should* be all that is necessary to configure ourselves.
	// However.....
	
	// validate media (data) type - why? shouldn't this be prevalidated?
	// shouldn't this be eventually used to select a channel object from
	// among multiple channel objects?
	if((pChannelCapability->DataType != H245_DATA_AUDIO) && (pChannelCapability->DataType != H245_DATA_VIDEO))
	{
		hrLast = CCO_E_UNSUPPORTED_MEDIA_TYPE;
		DumpChannelParameters(NULL, pChannelCapability);
		goto BAD_CAPABILITY_EXIT;
	}

  	// Look at the local capability referenced by pChannelCapability->CapId
 	// and Validate the format details

 	hrLast = m_pConfAdvise->GetCapResolver((LPVOID *)&pCapObject, OID_CAP_ACM_TO_H323);
 	if(!HR_SUCCEEDED(hrLast) || (pCapObject == NULL))
	{
		ERRORMESSAGE(("%s: null resolver\r\n",_fx_));
		goto BAD_CAPABILITY_EXIT;
	}
	
	// Find the local *receive* capability that matches the remote *send* channel
	// parameters and get the local parameters.

	uLocalParamSize = pCapObject->GetLocalRecvParamSize(pChannelCapability);
	pLocalParams=MemAlloc (uLocalParamSize);
	if (pLocalParams == NULL)
	{
	   hrLast = CCO_E_SYSTEM_ERROR;
	   goto BAD_CAPABILITY_EXIT;
	}
	hrLast = ((CapsCtl *)pCapObject)->GetDecodeParams( pChannelParams,
		(MEDIA_FORMAT_ID *)&dwFormatID, pLocalParams, uLocalParamSize);

 	if(!HR_SUCCEEDED(hrLast) || (dwFormatID == INVALID_AUDIO_FORMAT))
	{
		ERRORMESSAGE(("%s:GetDecodeParams returned 0x%08lx\r\n",_fx_, hrLast));
		goto BAD_CAPABILITY_EXIT;
	}

	
	// create a marshalled version of channel parameters and store it in the channel for later
	// reference
	if(pChannelCapability->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		// The nonstandard capability already passed all the recognition tests so
		// don't need to test again.
		// Make a flat copy of the nonstandard capability
		uSize = pChannelCapability->Cap.H245Aud_NONSTD.data.length;
		// lpData = pChannelCapability->Cap.H245Aud_NONSTD.data.value;

		pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
		if(!pSaveChannelCapability)
		{
			hrLast = CCO_E_SYSTEM_ERROR;
			goto BAD_CAPABILITY_EXIT;
		}	
		// copy fixed part
		memcpy(pSaveChannelCapability, pChannelCapability, sizeof(CC_TERMCAP));
		// variable part follows the fixed part
		pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value	
			= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
		// copy variable part
		memcpy(pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value,
			pChannelCapability->Cap.H245Aud_NONSTD.data.value,
			pChannelCapability->Cap.H245Aud_NONSTD.data.length);
		// and length
		pSaveChannelCapability->Cap.H245Aud_NONSTD.data.length
			= pChannelCapability->Cap.H245Aud_NONSTD.data.length;
		
		// make the channel remember the channel parameters.
		// a zero size as the second arg means that a preallocated chunk is being passed
		hrLast = pChannel->ConfigureCapability(pSaveChannelCapability, 0,
			pLocalParams, uLocalParamSize);	
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:ConfigureCapability (recv) returned 0x%08lx\r\n",_fx_, hrLast));
			goto BAD_CAPABILITY_EXIT;
		}
		pSaveChannelCapability=NULL;  // the channel owns this memory now
	}
	else if(pChannelCapability->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// The nonstandard capability already passed all the recognition tests so
		// don't need to test again.
		// Make a flat copy of the nonstandard capability
		uSize = pChannelCapability->Cap.H245Vid_NONSTD.data.length;
		// lpData = pChannelCapability->Cap.H245Vid_NONSTD.data.value;

		pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
		if(!pSaveChannelCapability)
		{
			hrLast = CCO_E_SYSTEM_ERROR;
			goto BAD_CAPABILITY_EXIT;
		}	
		// copy fixed part
		memcpy(pSaveChannelCapability, pChannelCapability, sizeof(CC_TERMCAP));
		// variable part follows the fixed part
		pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value	
			= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
		// copy variable part
		memcpy(pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value,
			pChannelCapability->Cap.H245Vid_NONSTD.data.value,
			pChannelCapability->Cap.H245Vid_NONSTD.data.length);
		// and length
		pSaveChannelCapability->Cap.H245Vid_NONSTD.data.length
			= pChannelCapability->Cap.H245Vid_NONSTD.data.length;
		
		// make the channel remember the channel parameters.
		// a zero size as the second arg means that a preallocated chunk is being passed
		hrLast = pChannel->ConfigureCapability(pSaveChannelCapability, 0,
			pLocalParams, uLocalParamSize);	
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:ConfigureCapability (recv) returned 0x%08lx\r\n",_fx_, hrLast));
			goto BAD_CAPABILITY_EXIT;
		}
		pSaveChannelCapability=NULL;  // the channel owns this memory now
	}
	else
	{
		// only need to remember the already-flat H.245 cap structure.
		hrLast = pChannel->ConfigureCapability(pChannelCapability, sizeof(CC_TERMCAP),
			pLocalParams, uLocalParamSize);	
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:ConfigureCapability(recv) returned 0x%08lx\r\n",_fx_, hrLast));
			goto BAD_CAPABILITY_EXIT;
		}
	}
	// Remember the receive format ID
	pChannel->SetNegotiatedLocalFormat(dwFormatID);
	
	// very special case check for video Temporal/Spatial tradeoff capability.
	// Set the property of the channel accordingly
	if(pChannelCapability->DataType == H245_DATA_VIDEO )
	{
		BOOL bTSCap;
		bTSCap = ((PVIDEO_CHANNEL_PARAMETERS)pLocalParams)->TS_Tradeoff;
		pChannel->CtrlChanSetProperty(PROP_REMOTE_TS_CAPABLE,&bTSCap, sizeof(bTSCap));
		// don't bother checking or panicking over this SetProperty error
	}
	return TRUE;

///////////////////
BAD_CAPABILITY_EXIT:
	ERRORMESSAGE(("%s:received bad capability\r\n",_fx_));
	hrLast = CCO_E_INVALID_CAPABILITY;
	if(pSaveChannelCapability)
		MemFree(pSaveChannelCapability);
	return FALSE;
}

//
// we're being requested to open a channel for receive
//
VOID CH323Ctrl::OnChannelRequest(HRESULT hStatus,
	PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS pChannelReqParams)
{
	FX_ENTRY("CH323Ctrl::OnChannelRequest");
	
	CC_ADDR CChannelAddr, DChannelAddr;
	PCC_ADDR pCChannelAddr = pChannelReqParams->pPeerRTCPAddr;;
	PCC_TERMCAP				pChannelCapability;
	PSOCKADDR_IN	pAddr;
	SOCKADDR_IN sinC;
	pChannelCapability = pChannelReqParams->pChannelCapability;
	DWORD dwRejectReason = H245_REJ;
	ICtrlCommChan *pChannel;	
		
	if(!pChannelCapability)
	{
		ERRORMESSAGE(("OnChannelRequest: null capability\r\n"));
		goto REJECT_CHANNEL;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest");

//
	// Try to find a default channel to handle this open request.
	hrLast = FindDefaultRXChannel(pChannelCapability, &pChannel);	
	if(!HR_SUCCEEDED(hrLast) || !pChannel)
	{
		// Non-default channels Not Yet Implemented!!!!
		// Ask the parent conference object	to create another channel of the
		// specified media type.  The H.245 media type should map to one of the
		// media type GUIDs that the parent conference object understands.
		// 		GUID typeGuid;
		//		if(!MapGuidType(pChannelCapability, &typeGUID))
		//			goto REJECT_CHANNEL;
		// 		hrLast = m_pConfAdvise->GetChannel(&typeGuid, &pChannel);
		//  	if(!HR_SUCCEEDED(hrLast))
		//			goto REJECT_CHANNEL;
		if(hrLast == CCO_E_NODEFAULT_CHANNEL)
			dwRejectReason = H245_REJ_TYPE_NOTAVAIL;

		goto REJECT_CHANNEL;
	}
	
	if(pChannel->GetHChannel())
	{
		ERRORMESSAGE(("%s: existing channel or leak:0x%08lX\r\n",_fx_,
			pChannel->GetHChannel()));
		goto REJECT_CHANNEL;
	}

	//
	//   test if we want to allow this !!!
	//
	if(!pChannel->IsChannelEnabled())
	{
		goto REJECT_CHANNEL;
	}

	pChannel->SetHChannel(pChannelReqParams->hChannel);
	
	// configure based on the requested capability. (store capability ID, validate requested
	// capabilities
	if(!ConfigureRecvChannelCapability(pChannel, pChannelReqParams))
	{
		goto REJECT_CHANNEL;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest done configuring");

	// select our receive ports for this RTP session
	
	if(!pChannel->SelectPorts((LPIControlChannel)this))
	{
		ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
		hrLast = CCO_E_BAD_ADDRESS;
		goto REJECT_CHANNEL;
	}

	if(pCChannelAddr)
	{
		if(pCChannelAddr->nAddrType != CC_IP_BINARY)
		{
			ERRORMESSAGE(("%s:invalid address type %d\r\n",_fx_, pCChannelAddr->nAddrType));
			hrLast = CCO_E_BAD_ADDRESS;
			goto REJECT_CHANNEL;
		}
		// pass the remote RTCP address to the channel instance
		sinC.sin_family = AF_INET;
		sinC.sin_addr.S_un.S_addr = htonl(pCChannelAddr->Addr.IP_Binary.dwAddr);
		sinC.sin_port = htons(pCChannelAddr->Addr.IP_Binary.wPort);

		DEBUGMSG(ZONE_CONN,("%s, request reverse port 0x%04x, address 0x%08lX\r\n",_fx_,
			pCChannelAddr->Addr.IP_Binary.wPort,pCChannelAddr->Addr.IP_Binary.dwAddr));
	
		hrLast = pChannel->AcceptRemoteRTCPAddress(&sinC);
		if(hrLast != CC_OK)
		{
			ERRORMESSAGE(("%s, AcceptRemoteRTCPAddress returned 0x%08lX\r\n",_fx_, hrLast));
			goto ERROR_EXIT;
		}
	}
	
	// get the address and ports of our end of the channel
	pAddr = pChannel->GetLocalAddress();
	// fixup channel addr pair structure.
	DChannelAddr.nAddrType = CC_IP_BINARY;
	DChannelAddr.bMulticast = FALSE;
	DChannelAddr.Addr.IP_Binary.wPort = pChannel->GetLocalRTPPort();
	DChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);

	CChannelAddr.nAddrType = CC_IP_BINARY;
	CChannelAddr.bMulticast = FALSE;
	CChannelAddr.Addr.IP_Binary.wPort = pChannel->GetLocalRTCPPort();
	CChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);

	DEBUGMSG(ZONE_CONN,("%s: accepting on port 0x%04x, address 0x%08lX\r\n",_fx_,
		DChannelAddr.Addr.IP_Binary.wPort,DChannelAddr.Addr.IP_Binary.dwAddr));

	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest accepting");
			
	hrLast = CC_AcceptChannel(pChannelReqParams->hChannel,&DChannelAddr, &CChannelAddr,
		0 /*  this param is the bitrate that will be used by THIS channel !! */);
	
	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s, CC_AcceptChannel returned 0x%08lX\r\n",_fx_, hrLast));
		goto ERROR_EXIT;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest accepted");
	return;
	
REJECT_CHANNEL:	
	{
	// need private HRESULT! don't overwrite the reason we're rejecting the channel!!	
		HRESULT hr;	

	    if(NULL != pChannelCapability)
	    {
    		ERRORMESSAGE(("%s, rejecting channel, Dir:%d, DataType:%d, ClientType:%d, CapId:%d\r\n",
    		_fx_, pChannelCapability->Dir, pChannelCapability->DataType,
    		pChannelCapability->ClientType, pChannelCapability->CapId));
	    }
	    
		hr = CC_RejectChannel(pChannelReqParams->hChannel, dwRejectReason);
		if(hr != CC_OK)
		{
			ERRORMESSAGE(("%s, CC_RejectChannel returned 0x%08lX\r\n",_fx_, hr));
		}
	}	
ERROR_EXIT:
	return;
}

VOID CH323Ctrl::OnChannelAcceptComplete(HRESULT hStatus,
	PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams)
{
	FX_ENTRY("CH323Ctrl::OnChannelAcceptComplete");
	ICtrlCommChan *pChannel;	
	if(hStatus != CC_OK)	
	{
		return;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelAcceptComplete");

	pChannel = FindChannel(pChannelParams->hChannel);	
	if(!pChannel)
	{
		ERRORMESSAGE(("OnChannelAcceptComplete: hChannel 0x%08lx not found\r\n", pChannelParams->hChannel));
		return;
	}
	
	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	// the receive side is open	
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelAcceptComplete, open done");
	if(HR_SUCCEEDED(hrLast))
	{
		m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_RX, pChannel, this);			
	}
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelAcceptComplete done");
}

VOID CH323Ctrl::OnChannelOpen(HRESULT hStatus,
	PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS pChannelParams )
{
	FX_ENTRY("CH323Ctrl::OnChannelOpen");
	PCC_ADDR	pChannelRTPAddr;
	PCC_ADDR	pChannelRTCPAddr;
    SOCKADDR_IN sinC, sinD;

	ICtrlCommChan *pChannel = (ICtrlCommChan *)pChannelParams->dwUserToken;	
	// validate channel token - is this what we think it is?
	if(IsBadWritePtr(pChannel, sizeof(ICtrlCommChan)))
	{
		ERRORMESSAGE(("%s:invalid channel token: 0x%08lx\r\n",_fx_, pChannelParams->dwUserToken));
		return;
	}
	if(pChannel->IsSendChannel() == FALSE)
	{
		ERRORMESSAGE(("%s:not a send channel:token 0x%08lX\r\n",_fx_,
			pChannelParams->dwUserToken));
		return;
	}
#ifdef DEBUG
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChan;
	BOOL bValid = FALSE;
	// look for a matching channel instance.
	while (pos)
	{
		pChan = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChan);
		if(pChan == pChannel)
		{
			bValid = TRUE;
			break;
		}
	}
	if(!bValid)
	{
		ERRORMESSAGE(("%s:unrecognized token 0x%08lX\r\n",_fx_,
			pChannelParams->dwUserToken));
		return;
	}
#endif	//DEBUG

	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen");

	if((hStatus != CC_OK) || (!(pChannelRTPAddr = pChannelParams->pPeerRTPAddr))
		|| (!(pChannelRTCPAddr = pChannelParams->pPeerRTCPAddr)))
	{
		ERRORMESSAGE(("%s: hStatus:0x%08lX, address:0x%08lX\r\n",_fx_,
			hStatus, pChannelRTPAddr));
		// LOOKLOOK need to interpret hStatus
		// let the channel know what happened.
		pChannel->OnChannelOpen(CHANNEL_REJECTED);	
		
		// the channel knows what happened, so let it do the worrying.
		return;
	}
	// what's the need for the different address types ????
	if((pChannelRTPAddr->nAddrType != CC_IP_BINARY)
		|| (pChannelRTCPAddr->nAddrType != CC_IP_BINARY))
	{
		ERRORMESSAGE(("%s: invalid address types %d, %d\r\n",_fx_,
				pChannelRTPAddr->nAddrType, pChannelRTCPAddr->nAddrType));
		goto ERROR_EXIT;
	}	
	
	// we now have the remote port info ( in host byte order)
	sinD.sin_family = AF_INET;
	sinD.sin_addr.S_un.S_addr = htonl(pChannelRTPAddr->Addr.IP_Binary.dwAddr);
	sinD.sin_port = htons(pChannelRTPAddr->Addr.IP_Binary.wPort);
	
	sinC.sin_family = AF_INET;
	sinC.sin_addr.S_un.S_addr = htonl(pChannelRTCPAddr->Addr.IP_Binary.dwAddr);
	//  There are two ports, but in RTP, it is implicit
	// that the RTCP control port is the next highest port number
	// sinC.sin_port = htons(ntohs(pChannelAddr->Addr.IP_Binary.wPort) +1);
	sinC.sin_port = htons(pChannelRTCPAddr->Addr.IP_Binary.wPort);

	DEBUGMSG(ZONE_CONN,("%s, opened on port 0x%04x, address 0x%08lX\r\n",_fx_,
		pChannelRTPAddr->Addr.IP_Binary.wPort,pChannelRTPAddr->Addr.IP_Binary.dwAddr));

	hrLast = pChannel->AcceptRemoteAddress(&sinD);
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("OnChannelOpen: AcceptRemoteAddress failed\r\n"));
		goto ERROR_EXIT;
	}
	hrLast = pChannel->AcceptRemoteRTCPAddress(&sinC);
	if(!HR_SUCCEEDED(hrLast))
	{	
		ERRORMESSAGE(("OnChannelOpen: AcceptRemoteRTCPAddress failed\r\n"));
		goto ERROR_EXIT;
	}
	
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen opening");
	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	// the send side is open
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("OnChannelOpen:channel's OnChannelOpen() returned 0x%08lX\r\n", hrLast));
		CloseChannel(pChannel);
		goto ERROR_EXIT;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen open done");
	m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_TX, pChannel, this);	
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );	
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen done");
	return;
	
ERROR_EXIT:
	// need to cleanup, disconnect, etc.
	m_hCallCompleteCode = CCCI_CHANNEL_OPEN_ERROR;
	// let the parent Conference object know about the imminent disconnect
	DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
	hrLast = CCO_E_MANDATORY_CHAN_OPEN_FAILED;

	InternalDisconnect();
	return;
}
VOID CH323Ctrl::OnRxChannelClose(HRESULT hStatus,
	PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS pChannelParams )
{
	FX_ENTRY("CH323Ctrl::OnRxChannelClose");
	PCC_ADDR	pChannelRTPAddr;
	PCC_ADDR	pChannelRTCPAddr;
    SOCKADDR_IN sinC, sinD;

	ICtrlCommChan *pChannel;
	if(hStatus != CC_OK)
	{
		ERRORMESSAGE(("%s: hStatus:0x%08lX\r\n",_fx_,hStatus));
		// LOOKLOOK need to interpret hStatus
	}
	if(!(pChannel = FindChannel(pChannelParams->hChannel)))
	{
		ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
		return;
	}
		
	// validate channel - is this really a receive channel?
	if(pChannel->IsSendChannel() == TRUE)
	{
		ERRORMESSAGE(("%s:not a receive channel:hChannel 0x%08lX\r\n",_fx_,
			pChannelParams->hChannel));
		return;
	}
	pChannel->OnChannelClose(CHANNEL_CLOSED);	
	return;
}


VOID CH323Ctrl::OnTxChannelClose(HRESULT hStatus,
	PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams )
{
	FX_ENTRY("CH323Ctrl::OnTxChannelClose");
	PCC_ADDR	pChannelRTPAddr;
	PCC_ADDR	pChannelRTCPAddr;
    SOCKADDR_IN sinC, sinD;

	ICtrlCommChan *pChannel;
	if(hStatus != CC_OK)
	{
		ERRORMESSAGE(("%s: hStatus:0x%08lX\r\n",_fx_,hStatus));
		// LOOKLOOK need to interpret hStatus
	}
	
	if(!(pChannel = FindChannel(pChannelParams->hChannel)))
	{
		CC_CloseChannelResponse(pChannelParams->hChannel, FALSE);
		ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
		return;
	}
	
	// validate channel - is this really a send channel?
	if(pChannel->IsSendChannel() == FALSE)
	{
		ERRORMESSAGE(("%s:not a send channel:hChannel 0x%08lX\r\n",_fx_,
			pChannelParams->hChannel));
		CC_CloseChannelResponse(pChannelParams->hChannel, FALSE);
		return;
	}
	CC_CloseChannelResponse(pChannelParams->hChannel, TRUE);
	pChannel->OnChannelClose(CHANNEL_CLOSED);	
	return;
}

BOOL CH323Ctrl::OnCallAccept(PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::OnCallAccept");
	BOOL bRet = FALSE;
	CH323Ctrl *pNewConnection = NULL;
	if(m_Phase != CCS_Listening)
	{
		ERRORMESSAGE(("OnCallAccept: unexpected call, m_Phase = 0x%08lX\r\n", m_Phase));
		goto EXIT;
	}

	if((!pListenCallbackParams->pCalleeAddr)
	    || (pListenCallbackParams->pCalleeAddr->nAddrType != CC_IP_BINARY))
	{
		if(pListenCallbackParams->pCalleeAddr)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,pListenCallbackParams->pCalleeAddr->nAddrType));
		}
		else
		{
			ERRORMESSAGE(("%s: null local address\r\n",_fx_));
		}

	
		ERRORMESSAGE(("OnCallAccept:where's the local address????\r\n"));
					PHOSTENT phe;
					PSOCKADDR_IN psin;
				 	char szTemp[200];
					LPCSTR lpHostName;		
					gethostname(szTemp,sizeof(szTemp));
			    	lpHostName = szTemp;
					psin = &local_sin;
					phe = gethostbyname(lpHostName);
					if (phe != NULL)
					{
				   		memcpy((char FAR *)&(psin->sin_addr), phe->h_addr,phe->h_length);
						psin->sin_family = AF_INET;
					}
	
	
	}
	else
	{
		// remember our local address
		local_sin.sin_family = AF_INET;
		// in host byte order
		local_sin.sin_addr.S_un.S_addr = htonl(pListenCallbackParams->pCalleeAddr->Addr.IP_Binary.dwAddr);
		// in host byte order
		local_sin.sin_port = htons(pListenCallbackParams->pCalleeAddr->Addr.IP_Binary.wPort);
	}

	
	hrLast = m_pConfAdvise->GetAcceptingObject((LPIControlChannel *)&pNewConnection,
		&m_PID);
	if(HR_SUCCEEDED(hrLast) && pNewConnection)
	{
		// NOTE: The UI does not yet know this new object exists, and we may
		// need to silently delete it if there is a disconnect or error
		// Its ref count is 1 at this point.  The decision to delete could be
		// made inside pNewConnection->AcceptConnection(), (because sometimes
		// socket reads complete synchronously depending on timing) SO, we need to
		// protect the "unwind path" via AddRef() and Release() around the call
		//
		pNewConnection->AddRef();	//
		hrLast = pNewConnection->AcceptConnection(this, pListenCallbackParams);
		pNewConnection->Release();
		if(HR_SUCCEEDED(hrLast))
		{
			// The Intel Call control DLL already did a socket accept, the
			// Accept() methods simply initialize the handles and states of
			// pNewConnection and get user information (caller ID)
			// BUGBUG - the caller ID may change in Intel's code - it might
			// come via a conference event
			DEBUGMSG(ZONE_CONN,("OnCallAccept:accepted on connection 0x%08lX\r\n",pNewConnection));
			bRet = TRUE;						
		}
		else
		{
			ERRORMESSAGE(("OnCallAccept:Accept failed\r\n"));
			// LOOK -  Q: where does the accepting object get cleaned up?
			// A: pNewConnection->AcceptConnection((LPIControlChannel)this)
			// must call pNewConnection->DoAdvise(CCEV_ACCEPT_INCOMPLETE, NULL)
			// if the error occurred before the conference object got involved,
			// and must call InternalDisconnect() if the error occurred after
			// the conference object got involved,
		}

	}
	else
	{
		ERRORMESSAGE(("OnCallAccept:GetAcceptingObject failed, hr=0x%08lx\r\n",hrLast));
	}
	
	EXIT:
	return bRet;		
}	


HRESULT CH323Ctrl::NewConference()
{
	FX_ENTRY ("CH323Ctrl::NewConference");
	CapsCtl *pCapObject = NULL;
	PCC_TERMCAPLIST pTermCaps = NULL;
	CC_OCTETSTRING TerminalID;
	PCC_TERMCAPDESCRIPTORS pCapsList = NULL;
	LPWSTR lpwUserDisplayName;

	hrLast = m_pConfAdvise->GetCapResolver((LPVOID *)&pCapObject, OID_CAP_ACM_TO_H323);
	if(!HR_SUCCEEDED(hrLast) || (pCapObject == NULL))
	{
		ERRORMESSAGE(("%s: null resolver\r\n",_fx_));
		goto EXIT;
	}
	if(m_hConference)
	{
		ERRORMESSAGE(("%s:leak or uninitialized m_hConference:0x%08lx\r\n",_fx_,
				m_hConference));
	}
	
	hrLast = pCapObject->CreateCapList(&pTermCaps, &pCapsList);
	if(!HR_SUCCEEDED(hrLast))
	{
		goto EXIT;
	}
	
	lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
	if(lpwUserDisplayName)
	{
		TerminalID.pOctetString = (BYTE *)lpwUserDisplayName;
		TerminalID.wOctetStringLength = (WORD)lstrlenW(lpwUserDisplayName)*sizeof(WCHAR);
	}
	
	// create a conference
	hrLast = CC_CreateConference(&m_hConference, NULL,
		0,			// DWORD dwConferenceConfiguration,
		pTermCaps,		// PCC_TERMCAPLIST	
		pCapsList,		// ptr to term cap descriptors (PCC_TERMCAPDESCRIPTORS)
		&m_VendorInfo, 		// PVENDORINFO
		(lpwUserDisplayName)? &TerminalID: NULL, 	// PCC_OCTETSTRING pTerminalID,
		(DWORD_PTR)this,
		NULL, 	// CC_TERMCAP_CONSTRUCTOR TermCapConstructor,
		NULL, 	// CC_SESSIONTABLE_CONSTRUCTOR	SessionTableConstructor,		
		CCConferenceCallback);

	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s: CreateConference returned 0x%08lX\r\n", _fx_, hrLast));
	
	}

EXIT:	
	pCapObject->DeleteCapList(pTermCaps, pCapsList);
	return hrLast;

}

HRESULT CH323Ctrl::AcceptConnection(LPIControlChannel pIListenCtrlChan,
    LPVOID lpvListenCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::AcceptConnection");
	BOOL bRet = FALSE;
	CREQ_RESPONSETYPE Response;
	DWORD dwCode = CCR_LOCAL_SYSTEM_ERROR;	// error variable only used in error case
	ULONG ulNameSize, ulSize;
	PSOCKADDR_IN psin;
	LPWSTR lpwUserDisplayName;
	CH323Ctrl *pListenConnection = (CH323Ctrl *)pIListenCtrlChan;	
	P_APP_CALL_SETUP_DATA pAppData = NULL;
	APP_CALL_SETUP_DATA AppData;
	
	PCC_NONSTANDARDDATA	pNSData = ((PCC_LISTEN_CALLBACK_PARAMS)
	    lpvListenCallbackParams)->pNonStandardData;
	
	if(pNSData
	    && pNSData->bCountryCode == USA_H221_COUNTRY_CODE
        // why be this picky -> && pNSData->bExtension == USA_H221_COUNTRY_EXTENSION;
        && pNSData->wManufacturerCode == MICROSOFT_H_221_MFG_CODE
        && pNSData->sData.pOctetString
        && pNSData->sData.wOctetStringLength >= sizeof(MSFT_NONSTANDARD_DATA))
	{
        if(((PMSFT_NONSTANDARD_DATA)pNSData->sData.pOctetString)->
            data_type == NSTD_APPLICATION_DATA)
        {
            AppData.lpData = &((PMSFT_NONSTANDARD_DATA)pNSData->sData.pOctetString)->
                nonstd_data.AppData.data;
            AppData.dwDataSize = (DWORD)
                ((PMSFT_NONSTANDARD_DATA)pNSData->sData.pOctetString)->dw_nonstd_data_size;
            pAppData = &AppData;
        }
    }

    SetRemoteVendorID(((PCC_LISTEN_CALLBACK_PARAMS)lpvListenCallbackParams)->pVendorInfo);
	
	// this object is assuming everything from the listening object, including
	// the "Listening" state

	// enter critical section and make sure another thread is not handling a caller disconnect
	// or timeout
	// EnterCriticalSection()
	if(m_Phase == CCS_Idle)
	{
    	GoNextPhase(CCS_Listening);
		// once in this state, a disconnect on another thread will change the state
		// to something besides CCS_Listening

		pListenConnection->GetLocalAddress(&psin);
		SetLocalAddress(psin);
		
		// steal the conference ID from the listen object
		// m_ConferenceID = pListenConnection->GetConfID();
		memcpy(&m_ConferenceID, pListenConnection->GetConfIDptr(),sizeof(m_ConferenceID));
		ZeroMemory(pListenConnection->GetConfIDptr(),sizeof(m_ConferenceID));

		m_hCall = pListenConnection->GetHCall();

		// steal the user info from the listen object
		m_pRemoteAliasItem = pListenConnection->m_pRemoteAliasItem;
		pListenConnection->m_pRemoteAliasItem = NULL;	// make the listen object forget this

		// steal the peer display name
		pwszPeerDisplayName = pListenConnection->pwszPeerDisplayName;
		pListenConnection->pwszPeerDisplayName = NULL;
		
		lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
	}
	
	// else	already timing out
	// LeaveCriticalSection()

	if (m_Phase != CCS_Listening)	// cleanup before it gets accepted
	{
		goto ACCEPT_ERROR;
	}
	
	// let the conference object know that caller ID info is available
	ConnectNotify(CCEV_CALLER_ID);	

	// Now going to do stuff that might put cleanup responsibility on the
	// conference object or UI. (i.e. the call could be accepted)

	// EnterCriticalSection()
	if(m_Phase == CCS_Listening)
	{	
		// state is still OK
    	GoNextPhase(CCS_Filtering);
		// once in this state, a disconnect on another thread will change the state
		// to something besides CCS_Filtering
	}
	// else	already timing out
	// LeaveCriticalSection()

    if (m_Phase != CCS_Filtering)	// one last chance to cleanup before it gets accepted
	{
		goto ERROR_REJECT;
	}

	// can't (should not) do this inside a critical section
	// create a conference to accept the call
	hrLast = NewConference();
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("%s, NewConference returned 0x%08lX\r\n", _fx_, hrLast));
		goto ERROR_REJECT;
	}

	m_pConfAdvise->AddRef();
	Response = m_pConfAdvise->FilterConnectionRequest(this, pAppData);
	m_pConfAdvise->Release();
	
	// Now it may be in the hands of the Conference object, and the accepted connection will
	// need to go through the "disconnecting" state if cleanup is needed.
	// Because connection code is reentrant, the connection could also have
	// been torn down (via connection methods) while inside
	// m_pConfAdvise->FilterConnectionRequest();
	// In each case below, check validity of the connection state - it might have changed
	// because a connection method was called or because the caller timed out

	switch(Response)
	{	
		default:
		case CRR_ACCEPT:
			if(m_Phase != CCS_Filtering)
			{
				ERRORMESSAGE(("%s, accepting state no longer valid 0x%08lX\r\n", _fx_, hrLast));
				goto CANCEL_ACCEPT;
			}
								
			// accept this request
			hrLast = CC_AcceptCall(m_hConference,
				NULL, 	// PCC_NONSTANDARDDATA	pNonStandardData
				lpwUserDisplayName,
				m_hCall,
				0, 		// DWORD dwBandwidth,
				(DWORD_PTR)this);
				
			if(hrLast != CC_OK)
			{
    	    	m_ChanFlags &= ~CTRLF_OPEN;
				goto CANCEL_ACCEPT;			
			}
				
			GoNextPhase(CCS_Accepting);
			bRet = TRUE;

		break;	
		case CRR_ASYNC:
			if(m_Phase == CCS_Accepting)
			{
				// then call has already been accepted inside FilterConnectionRequest callback
				bRet = TRUE;
			}
			else
			{
				if(m_Phase != CCS_Filtering)
				{
					ERRORMESSAGE(("%s, accepting state no longer valid 0x%08lX\r\n", _fx_, hrLast));
					goto CANCEL_ACCEPT;
				}
				GoNextPhase(CCS_Ringing);
				bRet = TRUE;
			}
		
		break;
		case CRR_BUSY:
			hrLast = CC_RejectCall(CC_REJECT_USER_BUSY,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			// always clean up this object that's not accepting the call
			GoNextPhase(CCS_Idle);
			goto ACCEPT_ERROR;			
		break;
		case CRR_REJECT:
			hrLast = CC_RejectCall(CC_REJECT_DESTINATION_REJECTION,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			// always clean up this object that's not accepting the call
			GoNextPhase(CCS_Idle);
			goto ACCEPT_ERROR;	
		break;
		case CRR_SECURITY_DENIED:
			hrLast = CC_RejectCall(CC_REJECT_SECURITY_DENIED,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			// always clean up this object that's not accepting the call
			GoNextPhase(CCS_Idle);
			goto ACCEPT_ERROR;			
		break;
	}

	return hrLast;		
ERROR_REJECT:
	hrLast = CC_RejectCall(CC_REJECT_UNDEFINED_REASON,
		NULL, // PCC_NONSTANDARDDATA pNonStandardData
		m_hCall);	// always clean up this object that's not accepting the call
	GoNextPhase(CCS_Idle);
			
ACCEPT_ERROR:
	
	DoAdvise(CCEV_ACCEPT_INCOMPLETE, &dwCode);
	return hrLast;	

CANCEL_ACCEPT:
	// InternalDisconnect() can be called from any state, and will do fine if
	// it is already in a disconnecting state.
	InternalDisconnect();
	return hrLast;														
}


VOID CH323Ctrl::Cleanup()
{	
	POSITION pos = m_ChannelList.GetHeadPosition();
	ICtrlCommChan *pChan = NULL;
	
	CleanupConferenceAttributes();
	if(m_hConference)
	{
		hrLast = CC_DestroyConference(m_hConference, FALSE);
		// LOOKLOOK - need to check return code!!!
		m_hConference = 0;
	}

	// reset each channel (cleanup underlying socket references)
	while (pos)
	{
		pChan = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChan);
		// cleanup RTP sockets
		pChan->Reset();
	}
	// clear "socket(s) are open flags
	m_ChanFlags &= ~CTRLF_OPEN;
}

HRESULT CH323Ctrl::GetLocalPort(PORT * lpPort)
{
	*lpPort = ntohs(local_sin.sin_port);
	return hrSuccess;	
}
HRESULT CH323Ctrl::GetRemotePort(PORT * lpPort)
{
	*lpPort = ntohs(remote_sin.sin_port);
	return hrSuccess;	
}

HRESULT CH323Ctrl::GetLocalAddress(PSOCKADDR_IN *lplpAddr)
{
	*lplpAddr = &local_sin;
	return hrSuccess;
}

HRESULT CH323Ctrl::GetRemoteAddress(PSOCKADDR_IN *lplpAddr)
{
	*lplpAddr = &remote_sin;
	return hrSuccess;
}
		
HRESULT CH323Ctrl::ListenOn(PORT Port)
{
	FX_ENTRY ("CH323Ctrl::ListenOn");	
	PCC_ALIASNAMES pAliasNames = m_pConfAdvise->GetUserAliases();
	// temporary hack to override UI's ignorance of multiple protocol types
	if(Port != H323_PORT)
	{
		ERRORMESSAGE(("%s, overriding port %d(d) with H323 port %d\r\n",_fx_,
			Port, H323_PORT));
		Port = H323_PORT;
	}

	// do we need to remember this?
	local_sin.sin_addr.S_un.S_addr =	INADDR_ANY;
	local_sin.sin_family = AF_INET;
	local_sin.sin_port = htons((u_short)Port); // set port
	
	CC_ADDR		ListenAddr;
	
	ListenAddr.nAddrType = CC_IP_BINARY;
	ListenAddr.bMulticast = FALSE;
	// in host byte order
	ListenAddr.Addr.IP_Binary.wPort = (u_short)Port;
	ListenAddr.Addr.IP_Binary.dwAddr = ntohl(INADDR_ANY);

	hrLast = CC_CallListen(&m_hListen, &ListenAddr,
		pAliasNames, (DWORD_PTR)this, CCListenCallback);

	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("CH323Ctrl::ListenOn:CallListen returned 0x%08lX\r\n", hrLast));
		goto EXIT;
	}	
	

	GoNextPhase(CCS_Listening);
	m_ChanFlags = CTRLF_RESET;
	hrLast = hrSuccess;
EXIT:
	return hrLast;
}		
HRESULT CH323Ctrl::StopListen(VOID)
{
	if(m_Phase == CCS_Listening)
	{
		hrLast = CC_CancelListen(m_hListen);
	}
	else
	{
		hrLast = CCO_E_NOT_LISTENING;
	}

//EXIT:
	return hrLast;
}


HRESULT  CH323Ctrl::AsyncAcceptRejectCall(CREQ_RESPONSETYPE Response)
{
	FX_ENTRY ("CH323Ctrl::AsyncAcceptRejectCall");
	HRESULT hr = CCO_E_CONNECT_FAILED;	
	LPWSTR lpwUserDisplayName;
	
	if(Response == CRR_ACCEPT)
	{	
		DEBUGMSG(ZONE_CONN,("%s:accepting\r\n",_fx_));
		lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
		// check call setup phase - send ready if user's acceptance is what
		// was holding us up
		if((m_Phase == CCS_Ringing) || (m_Phase == CCS_Filtering))
		{
			// accept this request
			hrLast = CC_AcceptCall(m_hConference,
				NULL, 	// PCC_NONSTANDARDDATA	pNonStandardData
				lpwUserDisplayName,
				m_hCall,
				0, 		// DWORD dwBandwidth,
				(DWORD_PTR)this);
						
			if(hrLast != CC_OK)
			{
				ERRORMESSAGE(("%s, CC_AcceptCall() returned 0x%08lX\r\n",_fx_, hrLast));
				goto EXIT;
			}
			GoNextPhase(CCS_Accepting);
			hr = hrSuccess;
		}
	}
	else
	{
		// reject only if in accepting state(s)
		// deletion is possible while in advise callback, so protect w/ AddRef()
		AddRef();
		DEBUGMSG(ZONE_CONN,("%s:rejecting\r\n",_fx_));

		if((m_Phase == CCS_Ringing) || (m_Phase == CCS_Filtering))
		{
			hrLast = CC_RejectCall((Response == CRR_BUSY) ?	
				CC_REJECT_USER_BUSY : CC_REJECT_DESTINATION_REJECTION,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			if(hrLast != CC_OK)
			{
				ERRORMESSAGE(("%s, CC_RejectCall() returned 0x%08lX\r\n",_fx_, hrLast));
			}
			GoNextPhase(CCS_Idle);
			// notify the UI or application code or whatever..
			DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
		}
		else
		{
			hr = CCO_E_INVALID_PARAM;	// LOOKLOOK - need INVALID_STATE error code
		}
			
		Release();
	}
EXIT:
	return (hr);
}


ULONG CH323Ctrl ::AddRef()
{
	FX_ENTRY ("CH323Ctrl::AddRef");
	uRef++;
	DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->AddRef() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
	return uRef;
}

ULONG CH323Ctrl ::Release()
{
	FX_ENTRY("CH323Ctrl ::Release");
	uRef--;
	if(uRef == 0)
	{
		DEBUGMSG(ZONE_CONN,("%s:(0x%08lX)->Releasing in phase:%d\r\n",_fx_, this, m_Phase ));

		if(m_Phase != CCS_Idle)
		{
			ERRORMESSAGE(("CMSIACtrl::uRef zero in non idle (%d) state!\r\n",m_Phase));
			InternalDisconnect();
		}
		delete this;
		return 0;
	}
	DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->Release() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
	return uRef;
}



// implement IControlChannel::Disconnect().  Map reason codes to the protocol.
VOID CH323Ctrl::Disconnect(DWORD dwReason)
{
	// no way to propagate reason through H.323 stack?????
	InternalDisconnect();
}

VOID CH323Ctrl::InternalDisconnect()
{
	FX_ENTRY ("CH323Ctrl::Disconnect");
	SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect");
	
	m_ChanFlags &= ~CTRLF_ORIGINATING;	// reset "originating" flag.
	
	DEBUGMSG(ZONE_CONN,("%s, called in state %d, uRef = 0x%08lX\r\n",_fx_, m_Phase, uRef));
	switch(m_Phase)
	{
		case CCS_Connecting:
		case CCS_Accepting:
			// if we believe the control channel is still connected, disconnect
			if(IsCtlChanOpen(m_ChanFlags))
			{
				//set state to indicate disconnecting.
				GoNextPhase(CCS_Disconnecting);
				DEBUGMSG(ZONE_CONN,("%s, Expecting a CC_HANGUP_INDICATION\r\n",_fx_));
				hrLast = CC_Hangup(m_hConference, FALSE, (DWORD_PTR)this);
				if(hrLast != CC_OK)
				{
					ERRORMESSAGE(("%s:Hangup() returned 0x%08lX\r\n",_fx_, hrLast));
				}
				SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect hangup done");
			}
			else
			{
				CC_CancelCall(m_hCall);
				GoNextPhase(CCS_Idle);	// no need to ck retval - we're disconnected
				// notify the UI or application code or whatever..
				DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
			}
		break;
		case CCS_Ringing:
			// The call has not yet been accepted!!! Reject it!
			hrLast = CC_RejectCall(CC_REJECT_UNDEFINED_REASON,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect reject done");
		
			GoNextPhase(CCS_Idle);
			// notify the UI or application code or whatever..
			DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
		break;
		case CCS_Idle:
		case CCS_Disconnecting:
			ERRORMESSAGE(("%s:called in unconnected state %d\r\n",_fx_, m_Phase));
		break;
		default:
			//CCS_Ringing
			//CCS_Opening
			//CCS_Closing
			//CCS_Ready
			//CCS_InUse
			//CCS_Listening

			// if we believe the control channel is still connected, disconnect
			if(IsCtlChanOpen(m_ChanFlags))
			{
				//set state to indicate disconnecting.
				GoNextPhase(CCS_Disconnecting);
				hrLast = CC_Hangup(m_hConference, FALSE, (DWORD_PTR)this);
				if(hrLast != CC_OK)
				{
					ERRORMESSAGE(("%s:Hangup() returned 0x%08lX\r\n",_fx_, hrLast));
					DoAdvise(CCEV_DISCONNECTED ,NULL);
				}
				SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect hangup done");
			}
			else
			{
				GoNextPhase(CCS_Idle);	// no need to ck retval - we're disconnected
				// notify the UI or application code or whatever..
				DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
			}
		break;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect done");
}



// 	start the asynchronous stuff that will instantiate a control channel
HRESULT CH323Ctrl::PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData)
{
	FX_ENTRY ("CH323Ctrl::PlaceCall");	
	CC_ALIASNAMES pstn_alias;
	PCC_ALIASITEM pPSTNAlias = NULL;
	PCC_ALIASNAMES pRemoteAliasNames = NULL;
	PCC_ALIASNAMES pTranslatedAliasNames = NULL;
	PCC_ALIASNAMES pLocalAliasNames = NULL;
	PCC_ADDR pDestinationAddr = NULL;
	PCC_ADDR pConnectAddr = NULL;
	LPWSTR lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
    PCC_NONSTANDARDDATA		pNSData = NULL;
    PMSFT_NONSTANDARD_DATA lpNonstdContent = NULL;
	int iLen;
	LPWSTR lpwszDest;
	HRESULT hResult = hrSuccess;
	// validate current state, don't allow bad actions
	if(m_Phase != CCS_Idle)
	{
		hResult = CCO_E_NOT_IDLE;
		goto EXIT;
	}

	OBJ_CPT_RESET;	// reset elapsed timer

	m_ChanFlags |= CTRLF_INIT_ORIGINATING;
	if(!pCallAddr)
	{
		hResult =  CCO_E_BAD_ADDRESS;
		goto EXIT;
	}
	else
	{
		// keep a copy of the address
		SetRemoteAddress(pCallAddr);
	}
	// temporary hack to override UI's ignorance of multiple protocol types
	if(remote_sin.sin_port != htons(H323_PORT))
	{
		ERRORMESSAGE(("%s, overriding port %d(d) with H323 port %d\r\n",_fx_,
			ntohs(remote_sin.sin_port), H323_PORT));
		remote_sin.sin_port = htons(H323_PORT);
	}

	// check for connecting to self (not supported)
	if(local_sin.sin_addr.s_addr == remote_sin.sin_addr.s_addr)
	{
		hResult =  CCO_E_BAD_ADDRESS;
		goto EXIT;
	}

	if(m_pRemoteAliasItem)
	{
		MemFree(m_pRemoteAliasItem);
		m_pRemoteAliasItem = NULL;
	}

	// Is this a PSTN or H.320 gateway call?
	if(pCalledPartyNumber)
	{
		// Then, due to the bogus way that CC_PlaceCall() is overloaded, the remote alias names
		// must be overridden with the E.164 phone number.  The hack is buried in
		// Q931ConnectCallback() in CALLCONT.DLL (thank you Intel).  That hack propagates
		// the phone number to the "CalledPartyNumber" of the SETUP message only if there is
		// exactly one alias, and that one alias is of type E.164.
		
		// get # of characters
		iLen = lstrlenW(pCalledPartyNumber);
		// need buffer of size CC_ALIASITEM plus the size (in bytes) of the string
		pPSTNAlias = (PCC_ALIASITEM)MemAlloc(sizeof(CC_ALIASITEM)
			+ sizeof(WCHAR)* (iLen+1));
		if(!pPSTNAlias)
		{
	        ERRORMESSAGE(("%s:failed alloc of pPSTNAlias:0x%08lx\r\n",_fx_));
			hResult = CCO_E_OUT_OF_MEMORY;
			goto EXIT;
		}
		
		WORD wIndex, wLength =1;  // init wLength to count the null terminator
		WCHAR E164Chars[] = {CC_ALIAS_H323_PHONE_CHARS};
		LPCWSTR lpSrc = pCalledPartyNumber;
		pPSTNAlias->wType = CC_ALIAS_H323_PHONE;
		// set offsets - the E.164 address (a phone number) is the only thing
		// in the alias name buffer
		lpwszDest = (LPWSTR)(((char *)pPSTNAlias)+ sizeof(CC_ALIASITEM));
		pPSTNAlias->pData = lpwszDest;
		while(iLen--)
		{
			wIndex = (sizeof(E164Chars)/sizeof (WCHAR)) -1;	//scan E164Chars[]
			do
			{
				if(*lpSrc == E164Chars[wIndex])
				{
					*lpwszDest++ = *lpSrc;
					wLength++;
					break;
				}
			}while(wIndex--);
			
			lpSrc++;
		}
		// terminate it
		*lpwszDest = 0;
		
		// wDataLength is the # of UNICODE characters
		pPSTNAlias->wDataLength = wLength;
		pstn_alias.wCount = 1;
		pstn_alias.pItems = pPSTNAlias;
		pRemoteAliasNames = &pstn_alias;
			
	}
	else if (pDestinationAliases && bUseGKResolution)// use the supplied callee alias names
	{
		hrLast = AllocTranslatedAliasList(&pTranslatedAliasNames, pDestinationAliases);
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s, AllocTranslatedAliasList returned 0x%08lX\r\n", _fx_, hrLast));
			hResult = CCO_E_SYSTEM_ERROR;
			goto EXIT;
		}
		pRemoteAliasNames = pTranslatedAliasNames;
	}
	// else pRemoteAliasNames is initialized to NULL
	

	pLocalAliasNames = m_pConfAdvise->GetUserAliases();
	// start!!!
	CC_ADDR ConfAddr;
	// fixup the intel version of the address
	// also note that it's all in host byte order
	ConfAddr.bMulticast = FALSE;
	ConfAddr.nAddrType = CC_IP_BINARY;
	//hrLast = GetRemotePort(&ConfAddr.Addr.IP_Binary.wPort);
	ConfAddr.Addr.IP_Binary.wPort = htons(remote_sin.sin_port);
	ConfAddr.Addr.IP_Binary.dwAddr = ntohl(remote_sin.sin_addr.S_un.S_addr);
	
	#ifdef DEBUG	
		if(m_hConference)
			ERRORMESSAGE(("%s:leak or uninitialized m_hConference:0x%08lx\r\n",_fx_,
				m_hConference));
	#endif  // DEBUG
	
	// create a conference to place the call
	SHOW_OBJ_ETIME("PlaceCall ready to create conference");
	hrLast = NewConference();
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("%s, NewConference returned 0x%08lX\r\n", _fx_, hrLast));
		hResult = CCO_E_SYSTEM_ERROR;
		goto EXIT;
	}


	// Set connect timeout value
	// LOOKLOOK - this is a hardcoded value - !!!  Where should this actualy come from?
	// 30 secs == 30000mS
	SHOW_OBJ_ETIME("PlaceCall setting timeout");

	hrLast = CC_SetCallControlTimeout(CC_Q931_ALERTING_TIMEOUT, 30000);
										
    if(pAppData)
    {
        // typical case - app data should be really small
        if(pAppData->dwDataSize <= APPLICATION_DATA_DEFAULT_SIZE)
        {
            m_NonstdContent.data_type = NSTD_APPLICATION_DATA;
            m_NonstdContent.dw_nonstd_data_size = pAppData->dwDataSize;
            memcpy(&m_NonstdContent.nonstd_data.AppData.data,
                pAppData->lpData, pAppData->dwDataSize);
        	m_NonstandardData.sData.pOctetString  = (LPBYTE) &m_NonstdContent;
        	m_NonstandardData.sData.wOctetStringLength  = sizeof(m_NonstdContent);
        }
        else // need some heap
        {
            UINT uTotalSize = sizeof(MSFT_NONSTANDARD_DATA)+ pAppData->dwDataSize;
            lpNonstdContent = (PMSFT_NONSTANDARD_DATA)MemAlloc(uTotalSize);
            if(lpNonstdContent)
            {
                lpNonstdContent->data_type = NSTD_APPLICATION_DATA;
                lpNonstdContent->dw_nonstd_data_size = pAppData->dwDataSize;
                memcpy(&lpNonstdContent->nonstd_data.AppData.data, pAppData->lpData,pAppData->dwDataSize);
        	    m_NonstandardData.sData.pOctetString  = (LPBYTE) lpNonstdContent;
            	m_NonstandardData.sData.wOctetStringLength  = LOWORD(uTotalSize);
            }
            else
            {
                ERRORMESSAGE(("%s, alloc failed\r\n", _fx_));
        		hResult = CCO_E_SYSTEM_ERROR;
        		goto EXIT;
            }
        }
        pNSData = &m_NonstandardData;
    }

	m_NonstandardData.bCountryCode = USA_H221_COUNTRY_CODE;
    m_NonstandardData.bExtension = USA_H221_COUNTRY_EXTENSION;
    m_NonstandardData.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;

	SHOW_OBJ_ETIME("CH323Ctrl::PlaceCall ready to place call");

	// set destination address pointers
	if(bUseGKResolution)
	{
		// the address passed in pCallAddr is the GK's address
		pConnectAddr = &ConfAddr;
	}
	else
	{
		pDestinationAddr = &ConfAddr;
	}
	hrLast = CC_PlaceCall(
		m_hConference,
		&m_hCall,
		pLocalAliasNames, 	// 	PCC_ALIASNAMES			pLocalAliasNames,
		pRemoteAliasNames,
		NULL, 				// PCC_ALIASNAMES			pExtraCalleeAliasNames,
		NULL, 				// PCC_ALIASITEM			pCalleeExtension,
		pNSData,	        // PCC_NONSTANDARDDATA		pNonStandardData,
		lpwUserDisplayName, // PWSTR pszDisplay,
		pDestinationAddr, 	//  Destination call signalling address
		pConnectAddr, 		// 	address to send the SETUP message to, if different than
		 			// 	the destination address.  (used for gatekeeper calls?)
		0, 			//	DWORD                   dwBandwidth,
		(DWORD_PTR) this);

	SHOW_OBJ_ETIME("CH323Ctrl::PlaceCall placed call");

	//  clear these out so that cleanup does not try to free later
	if(lpNonstdContent)
   	    MemFree(lpNonstdContent);
	m_NonstandardData.sData.pOctetString  = NULL;
	m_NonstandardData.sData.wOctetStringLength = 0;

	// check return from CC_PlaceCall
	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("CH323Ctrl::PlaceCall, PlaceCall returned 0x%08lX\r\n", hrLast));
		hResult = CCO_E_CONNECT_FAILED;	
		goto EXIT;
	}
	// wait for an indication
	GoNextPhase(CCS_Connecting);

	EXIT:	
	if(pTranslatedAliasNames)
	{
		FreeTranslatedAliasList(pTranslatedAliasNames);
	}
	if(pPSTNAlias)
	{
	  MemFree(pPSTNAlias);
	}
	return hResult;
}

//
//	Given HCHANNEL, find the channel object.
//

ICtrlCommChan *CH323Ctrl::FindChannel(CC_HCHANNEL hChannel)
{
	FX_ENTRY ("CH323Ctrl::FindChannel");	
	// find the channel

	POSITION pos = m_ChannelList.GetHeadPosition();
	ICtrlCommChan *pChannel;
	while (pos)
	{
		pChannel = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChannel);
		if(pChannel->GetHChannel() == hChannel)
			return pChannel;
	}

	#ifdef DEBUG
	// fallout to error case
	ERRORMESSAGE(("%s, did not find hChannel 0x%08lX\r\n",_fx_,hChannel));
	#endif // DEBUG
	
	return NULL;
}

VOID  CH323Ctrl::OnMute(HRESULT hStatus,
				PCC_MUTE_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnMute");	
	ICtrlCommChan *pChannel;
	HRESULT hr;
	if(!(pChannel = FindChannel(pParams->hChannel)))
	{
	    ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
        return;
	}
	hr = pChannel->PauseNet(TRUE, TRUE);
	if(!HR_SUCCEEDED(hr))
	{
        ERRORMESSAGE(("%s, Pausenet returned 0x%08lx\r\n", _fx_, hr));
	}
}
VOID  CH323Ctrl::OnUnMute(HRESULT hStatus,
				PCC_UNMUTE_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnUnMute");	
	ICtrlCommChan *pChannel;
	HRESULT hr;

	if(!(pChannel = FindChannel(pParams->hChannel)))
	{
	    ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
        return;
	}
	hr = pChannel->PauseNet(FALSE, TRUE);
	if(!HR_SUCCEEDED(hr))
	{
        ERRORMESSAGE(("%s, Pausenet returned 0x%08lx\r\n", _fx_, hr));
	}
}


VOID  CH323Ctrl::OnMiscCommand(HRESULT hStatus,
				PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnMiscCommand");	
	ICtrlCommChan *pChannel;

	// not every command references an individual channel. The 4 exceptions are:
	// case equaliseDelay_chosen:		
	// case zeroDelay_chosen:
	// case multipointModeCommand_chosen:
	// case cnclMltpntMdCmmnd_chosen:
	//
	// if we were betting on receiving few of the exceptional cases, we would always
	// try to find the channel.
	//if(!(pChannel = FindChannel(pParams->hChannel)))
	//{
	//	ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
		// but don't error because of the exceptions
	//}
	
	switch(pParams->pMiscellaneousCommand->type.choice)
 	{
		// the name and spelling of these constants was invented by the OSS compiler
		//
		case videoFreezePicture_chosen:
			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
	
		break;
		case videoFastUpdatePicture_chosen:		// the receiver wants an I-Frame
		{
			HRESULT hr;
			IVideoChannel *pIVC=NULL;
			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
			hr = pChannel->QueryInterface(IID_IVideoChannel, (void **)&pIVC);
			if(HR_SUCCEEDED(hr))
			{
				pIVC->SendKeyFrame();
				pIVC->Release();
			}
			// else it must not be a video channel
			
		}
		break;
		case MCd_tp_vdTmprlSptlTrdOff_chosen:	
		{
			DWORD dwTradeoff;
			HRESULT hr;
			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
			// set TS value of the channel, also propagate to Datapump
			dwTradeoff  = MAKELONG(
				pParams->pMiscellaneousCommand->type.u.MCd_tp_vdTmprlSptlTrdOff, 0);
			// set channel property
			// NOTE: when PROP_TS_TRADEOFF is set, the channel does all the
			// local tweaking to make it happen. The channel will also signal the
			// new value to the remote as if the local end initiated it.
			hr = pChannel->CtrlChanSetProperty(PROP_TS_TRADEOFF, &dwTradeoff, sizeof(dwTradeoff));
		}
		break;
		
		default:
		// the following are not currently handled
		//	case equaliseDelay_chosen:		
		//	case zeroDelay_chosen:
		//	case videoSendSyncEveryGOB_chosen:
		//	case vdSndSyncEvryGOBCncl_chosen:
		//	case videoFastUpdateGOB_chosen:		// suposedly required by H.323
		//	case videoFastUpdateMB_chosen:		// suposedly required by H.323

		// and the remaining 2 are handled by the call control layer
		// so we will never see these
		//		case multipointModeCommand_chosen:	
		//		case cnclMltpntMdCmmnd_chosen:

		break;

	}

}
VOID  CH323Ctrl::OnMiscIndication(HRESULT hStatus,
				PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnMiscIndication");	
	ICtrlCommChan *pChannel;
	HRESULT hr;
	unsigned short choice = pParams->pMiscellaneousIndication->type.choice;
	
	if(!(pChannel = FindChannel(pParams->hChannel)))
	{
		ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
	    // check the exceptional cases for which this is OK
	    if((choice == multipointConference_chosen)
	        || (choice == cnclMltpntCnfrnc_chosen)
	        || (choice == multipointZeroComm_chosen)
	        || (choice == cancelMultipointZeroComm_chosen)
	        || (choice == mltpntScndryStts_chosen)
	        || (choice == cnclMltpntScndryStts_chosen))
	    {
            return;     // as long as the above choices are not supported......
	    }

	}
	switch(choice)
	{
    	case logicalChannelActive_chosen:
    	    if(NULL != pChannel)
    	    {
		        hr = pChannel->PauseNet(FALSE, TRUE);
    	    }
		break;
		case logicalChannelInactive_chosen:
		    if(NULL != pChannel)
		    {
		        hr = pChannel->PauseNet(TRUE, TRUE);
		    }
		break;

		case MIn_tp_vdTmprlSptlTrdOff_chosen:
		{
			DWORD dwTradeoff = MAKELONG(0,
				pParams->pMiscellaneousIndication->type.u.MIn_tp_vdTmprlSptlTrdOff);

			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
			// Set the indicated TS value of the channel.
			// This should never occur for send channels.
			//
			hr = pChannel->CtrlChanSetProperty(PROP_TS_TRADEOFF_IND, &dwTradeoff, sizeof(dwTradeoff));
		}
		break;

		// the following are not currently handled
		//	case multipointConference_chosen:
		//	case cnclMltpntCnfrnc_chosen:
		//	case multipointZeroComm_chosen:
		//	case cancelMultipointZeroComm_chosen:
		//	case mltpntScndryStts_chosen:
		//	case cnclMltpntScndryStts_chosen:
		//	case vdIndctRdyTActvt_chosen:
		//	case videoNotDecodedMBs_chosen:

	}
}

HRESULT CH323Ctrl::MiscChannelCommand(
	ICtrlCommChan *pChannel,
	VOID * pCmd)
{

#ifdef BETA_2_ASN_PRESENT
    if(m_fAvoidCrashingPDUs)
        return hrSuccess;
#endif // BETA_2_ASN_PRESENT

	return CC_H245MiscellaneousCommand(m_hCall, pChannel->GetHChannel(),
		(MiscellaneousCommand *)pCmd);
}

HRESULT CH323Ctrl::MiscChannelIndication(
	ICtrlCommChan *pChannel,
	VOID * pInd)
{
    MiscellaneousIndication *pMI = (MiscellaneousIndication *)pInd;
            			
#ifdef BETA_2_ASN_PRESENT
    if(m_fAvoidCrashingPDUs)
        return hrSuccess;
#endif

    // Intel decided that they had to wrap two Misc commands with two separate,
    // additional APIs. And it won't allow those to be issued any other way.
    // (it returns an error).  Until we fix that, need to catch and reroute those
    // two special ones
    if(pMI->type.choice  == logicalChannelActive_chosen)
    {
		 return CC_UnMute(pChannel->GetHChannel());
    }
    else if (pMI->type.choice  == logicalChannelInactive_chosen )
    {
        return CC_Mute(pChannel->GetHChannel());
    }
    else
        return CC_H245MiscellaneousIndication(m_hCall,pChannel->GetHChannel(),pMI);
    					
}

VOID CH323Ctrl::SetRemoteVendorID(PCC_VENDORINFO pVendorInfo)
{
    if(!pVendorInfo)
        return;

    m_RemoteVendorInfo.bCountryCode = pVendorInfo->bCountryCode;
    m_RemoteVendorInfo.bExtension = pVendorInfo->bExtension;
    m_RemoteVendorInfo.wManufacturerCode = pVendorInfo->wManufacturerCode;
    if(pVendorInfo->pProductNumber
        && pVendorInfo->pProductNumber->wOctetStringLength
        && pVendorInfo->pProductNumber->pOctetString)
    {
        if(m_RemoteVendorInfo.pProductNumber)
        {
            MemFree(m_RemoteVendorInfo.pProductNumber);
        }
        m_RemoteVendorInfo.pProductNumber = (PCC_OCTETSTRING)
            MemAlloc(sizeof(CC_OCTETSTRING)
            + pVendorInfo->pProductNumber->wOctetStringLength);
        if(m_RemoteVendorInfo.pProductNumber)
        {
            m_RemoteVendorInfo.pProductNumber->wOctetStringLength
              = pVendorInfo->pProductNumber->wOctetStringLength;
            m_RemoteVendorInfo.pProductNumber->pOctetString =
                ((BYTE *)m_RemoteVendorInfo.pProductNumber + sizeof(CC_OCTETSTRING));
            memcpy(m_RemoteVendorInfo.pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->wOctetStringLength);
        }

    }
    if(pVendorInfo->pVersionNumber)
    {
        if(m_RemoteVendorInfo.pVersionNumber)
        {
            MemFree(m_RemoteVendorInfo.pVersionNumber);
        }
        m_RemoteVendorInfo.pVersionNumber = (PCC_OCTETSTRING)
            MemAlloc(sizeof(CC_OCTETSTRING)
            + pVendorInfo->pVersionNumber->wOctetStringLength);
        if(m_RemoteVendorInfo.pVersionNumber)
        {
            m_RemoteVendorInfo.pVersionNumber->wOctetStringLength
              = pVendorInfo->pVersionNumber->wOctetStringLength;
            m_RemoteVendorInfo.pVersionNumber->pOctetString =
                ((BYTE *)m_RemoteVendorInfo.pVersionNumber + sizeof(CC_OCTETSTRING));
            memcpy(m_RemoteVendorInfo.pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->wOctetStringLength);
        }
    }
#ifdef BETA_2_ASN_PRESENT
    char IntelCrashingID[] = "Intel Internet Video Phone";
    char IntelCrashingVer[] = "1.0";

    m_fAvoidCrashingPDUs = FALSE;  // innocent until proven guilty
    if(m_RemoteVendorInfo.bCountryCode == USA_H221_COUNTRY_CODE)
    {
        // then it's possible that it is Intel or Microsoft
        if(m_RemoteVendorInfo.wManufacturerCode == MICROSOFT_H_221_MFG_CODE)
        {
            if((!pVendorInfo->pProductNumber) && (!pVendorInfo->pVersionNumber))
            {
                // safe to assume this is Beta2 or Beta3
                m_fAvoidCrashingPDUs = TRUE;
            }
            else if((pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->wOctetStringLength == 0)
                && (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->wOctetStringLength == 0))
            {
                // safe to assume this is Beta2 or Beta3
                m_fAvoidCrashingPDUs = TRUE;
            }
        }
        else if(m_RemoteVendorInfo.wManufacturerCode == INTEL_H_221_MFG_CODE)
        {
            if(pVendorInfo->pProductNumber
                && pVendorInfo->pVersionNumber
                && pVendorInfo->pProductNumber->wOctetStringLength
                && pVendorInfo->pProductNumber->pOctetString
                && pVendorInfo->pVersionNumber->wOctetStringLength
                && pVendorInfo->pVersionNumber->pOctetString)

            {
                // compare strings, don't care about null terminator
                if((0 == memcmp(pVendorInfo->pProductNumber->pOctetString,
                    IntelCrashingID, min(sizeof(IntelCrashingID)-1,pVendorInfo->pProductNumber->wOctetStringLength)))
                 && (0 == memcmp(pVendorInfo->pVersionNumber->pOctetString,
                    IntelCrashingVer,
                    min(sizeof(IntelCrashingVer)-1, pVendorInfo->pVersionNumber->wOctetStringLength)) ))
                {
                   m_fAvoidCrashingPDUs = TRUE;
                }
            }
        }
    }
#endif  //BETA_2_ASN_PRESENT



}

HRESULT CH323Ctrl::Init(IConfAdvise *pConfAdvise)
{
	hrLast = hrSuccess;
	
	if(!(m_pConfAdvise = pConfAdvise))
	{
		hrLast = CCO_E_INVALID_PARAM;
		goto EXIT;
	}

EXIT:	
	return hrLast;
}

HRESULT CH323Ctrl::DeInit(IConfAdvise *pConfAdvise)
{
	hrLast = hrSuccess;
	if(m_pConfAdvise != pConfAdvise)
	{
		hrLast = CCO_E_INVALID_PARAM;
		goto EXIT;
	}
	m_pConfAdvise = NULL;

EXIT:	
	return hrLast;
}

BOOL CH323Ctrl::IsAcceptingConference(LPVOID lpvConfID)
{
	if(memcmp(lpvConfID, &m_ConferenceID, sizeof(m_ConferenceID))==0)
	{	
		return TRUE;
	}
	return FALSE;
}

HRESULT CH323Ctrl::GetProtocolID(LPGUID lpPID)
{
	if(!lpPID)
		return CCO_E_INVALID_PARAM;

	*lpPID = m_PID;
	hrLast = hrSuccess;
	return hrLast;
}
	
IH323Endpoint * CH323Ctrl::GetIConnIF()
{
	if(!m_pConfAdvise)
		return NULL;
	return m_pConfAdvise->GetIConnIF();
}	

STDMETHODIMP CH323Ctrl::GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo,
        PCC_VENDORINFO *ppRemoteVendorInfo)
{

	FX_ENTRY ("CH323Ctrl::GetVersionInfo");
	if(!ppLocalVendorInfo || !ppRemoteVendorInfo)
	{
		return CCO_E_INVALID_PARAM;
	}
	*ppLocalVendorInfo = &m_VendorInfo;
	*ppRemoteVendorInfo = &m_RemoteVendorInfo;
	return hrSuccess;
}



CH323Ctrl::CH323Ctrl()
:m_hListen(0),
m_hConference(0),
m_hCall(0),
m_pRemoteAliases(NULL),
m_pRemoteAliasItem(NULL),
pwszPeerDisplayName(NULL),
pwszPeerAliasName(NULL),
m_bMultipointController(FALSE),
m_fLocalT120Cap(TRUE),
m_fRemoteT120Cap(FALSE),
hrLast(hrSuccess),
m_ChanFlags(0),
m_hCallCompleteCode(0),
m_pConfAdvise(NULL),
m_Phase( CCS_Idle ),
#ifdef BETA_2_ASN_PRESENT
    m_fAvoidCrashingPDUs(FALSE),
#endif

uRef(1)
{
	m_PID = PID_H323;
	ZeroMemory(&m_ConferenceID,sizeof(m_ConferenceID));
	ZeroMemory(&local_sin, sizeof(local_sin));
	ZeroMemory(&remote_sin, sizeof(remote_sin));
	ZeroMemory(&m_RemoteVendorInfo, sizeof(m_RemoteVendorInfo));
	local_sin_len =  sizeof(local_sin);
	remote_sin_len = sizeof(remote_sin);
	
	m_VendorInfo.bCountryCode = USA_H221_COUNTRY_CODE;
    m_VendorInfo.bExtension =  USA_H221_COUNTRY_EXTENSION;
    m_VendorInfo.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;

    m_VendorInfo.pProductNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING)
        + sizeof(DefaultProductID));
    if(m_VendorInfo.pProductNumber)
    {
        m_VendorInfo.pProductNumber->wOctetStringLength = sizeof(DefaultProductID);
        m_VendorInfo.pProductNumber->pOctetString =
            ((BYTE *)m_VendorInfo.pProductNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pProductNumber->pOctetString,
            DefaultProductID, sizeof(DefaultProductID));
    }

    m_VendorInfo.pVersionNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING)
            + sizeof(DefaultProductVersion));
    if(m_VendorInfo.pVersionNumber)
    {
        m_VendorInfo.pVersionNumber->wOctetStringLength = sizeof(DefaultProductVersion);
        m_VendorInfo.pVersionNumber->pOctetString =
                ((BYTE *)m_VendorInfo.pVersionNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pVersionNumber->pOctetString,
              DefaultProductVersion, sizeof(DefaultProductVersion));
    }

	m_NonstandardData.bCountryCode = USA_H221_COUNTRY_CODE;
	m_NonstandardData.bExtension =  USA_H221_COUNTRY_EXTENSION;
	m_NonstandardData.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;
	m_NonstandardData.sData.pOctetString  = NULL;
	m_NonstandardData.sData.wOctetStringLength  = 0;
	m_ParticipantList.wLength = 0;
	m_ParticipantList.ParticipantInfoArray = NULL;
	m_ConferenceAttributes.pParticipantList = &m_ParticipantList;
}


VOID CH323Ctrl ::ReleaseAllChannels()
{
	ICtrlCommChan *pChan = NULL;
	if (!m_ChannelList.IsEmpty())
	{
		while (!m_ChannelList.IsEmpty())
		{
			pChan = (ICtrlCommChan *) m_ChannelList.RemoveHead();
			if(pChan)
			{
				pChan->EndControlSession();
				pChan->Release();
				pChan = NULL;
			}
		}
	}
}

CH323Ctrl ::~CH323Ctrl()
{
	Cleanup();
	ReleaseAllChannels();
	if(m_pRemoteAliases)
		FreeTranslatedAliasList(m_pRemoteAliases);
	if(pwszPeerDisplayName)
		MemFree(pwszPeerDisplayName);
	if(pwszPeerAliasName)
		MemFree(pwszPeerAliasName);
	if(m_pRemoteAliasItem)
		MemFree(m_pRemoteAliasItem);
	if(m_NonstandardData.sData.pOctetString)
		MemFree(m_NonstandardData.sData.pOctetString);
    if(m_VendorInfo.pProductNumber)
        MemFree(m_VendorInfo.pProductNumber);
    if(m_VendorInfo.pVersionNumber)
        MemFree(m_VendorInfo.pVersionNumber);
    if(m_RemoteVendorInfo.pProductNumber)
        MemFree(m_RemoteVendorInfo.pProductNumber);
    if(m_RemoteVendorInfo.pVersionNumber)
        MemFree(m_RemoteVendorInfo.pVersionNumber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\ctrlh323.h ===
/*
 *  	File: ctrlh323.h
 *
 *      H.323/H.245 implementation of IControlChannel.
 *
 *		Revision History:
 *
 *		05/03/96	mikev	created
 */


#ifndef _CTRLH323_H
#define _CTRLH323_H

//
//  Build with BETA_2_ASN_PRESENT defined to detect a peer that is using 
//  downlevel ASN.1.  It has been discovered that some PDUs encoded with the 
//  old encoder (OSS version 4.2.1 beta) cause the new decoder (OSS 4.2.2) to 
//  crash. The only known products to beware of are:  
//      Microsoft NetMeeting Version 2, (beta 2 and beta 3.)  These do not set
//      either version field.
//      Intel Internet Video Phone Beta 1 (expires 4/19/97)
// 
//  The only PDUs known (so far) to crash are the acks for "MiscellaneousCommand"
//  and "MiscelaneousIndication".  We avoid the acks by not sending the Command or 
//  Indication.

#define BETA_2_ASN_PRESENT
#ifdef BETA_2_ASN_PRESENT

// Intel products: (country code: 0xb5, manufacturer code: 0x8080)
// Intel Internet Video Phone Beta 1 (expires 4/19/97): product number: "Intel 
// Internet Video Phone"; version number: "1.0" 
#define INTEL_H_221_MFG_CODE 0x8080  
#endif

//
//	control channel flags
//

typedef ULONG CCHFLAGS;
						
#define CTRLF_OPEN			0x10000000	// control channel is open
#define CTRLF_ORIGINATING  0x00000001 	// call originated at this end
#define IsCtlChanOpen(f) (f & CTRLF_OPEN)
#define IsOriginating(f) (f & CTRLF_ORIGINATING)

#define CTRLF_INIT_ORIGINATING		CTRLF_ORIGINATING
#define CTRLF_INIT_NOT_ORIGINATING 	0
#define CTRLF_INIT_ACCEPT			CTRLF_OPEN
#define CTRLF_RESET					0

//
//   Extensible Nonstandard data structure
//

typedef enum
{
	NSTD_ID_ONLY = 0, 	// placeholder so that H.221 stuff like Mfr.Id
						// can be exchanged without sacrificing extensibility later
	NSTD_VENDORINFO,    // wrapped CC_VENDORINFO, redundant. 
	NSTD_APPLICATION_DATA   // array of bytes passed from application layer to 
	                        // application layer
} NSTD_DATA_TYPE;

typedef struct 
{
    #define APPLICATION_DATA_DEFAULT_SIZE 4
    DWORD dwDataSize;
    BYTE  data[APPLICATION_DATA_DEFAULT_SIZE];       // variable sized
}APPLICATION_DATA;

typedef struct {
	NSTD_DATA_TYPE data_type;
	DWORD dw_nonstd_data_size;
	union {
		CC_VENDORINFO VendorInfo;
		APPLICATION_DATA AppData; 
	}nonstd_data;
}MSFT_NONSTANDARD_DATA, *PMSFT_NONSTANDARD_DATA;

class CH323Ctrl : public IControlChannel
{

protected:
	OBJ_CPT;		// profiling timer
	
#ifdef BETA_2_ASN_PRESENT
    BOOL m_fAvoidCrashingPDUs;
#endif
//
// Handles and data specific to CALLCONT.DLL apis (H245 call control DLL)
//
	CC_HLISTEN m_hListen;
	CC_HCONFERENCE m_hConference;
	CC_CONFERENCEID m_ConferenceID;
	CC_HCALL m_hCall;
    PCC_ALIASNAMES m_pRemoteAliases;
	PCC_ALIASITEM m_pRemoteAliasItem;
	LPWSTR pwszPeerAliasName;	// unicode peer ID - this is always used for caller ID
	LPWSTR pwszPeerDisplayName;	// unicode peer display name - used for called party ID
								// in the absence of szPeerAliasName
	BOOL m_bMultipointController;

	CC_VENDORINFO m_VendorInfo;
	CC_VENDORINFO m_RemoteVendorInfo;
 	CC_NONSTANDARDDATA m_NonstandardData;
	MSFT_NONSTANDARD_DATA m_NonstdContent;	// empty for now
	CC_CONFERENCEATTRIBUTES	m_ConferenceAttributes;
	CC_PARTICIPANTLIST m_ParticipantList;
public:	
//
//	access methods specific to support of CALLCONT.DLL apis (H245 call control DLL)
//
	CC_HCONFERENCE GetConfHandle() {return(m_hConference);};
	CC_CONFERENCEID GetConfID() {return(m_ConferenceID);};
	CC_CONFERENCEID *GetConfIDptr() {return(&m_ConferenceID);};
	CC_HLISTEN GetListenHandle() {return(m_hListen);};
	CC_HCALL GetHCall() {return(m_hCall);};

//	Callbacks and event handling functions specific to support of
//  CALLCONT.DLL callbacks
//	
	HRESULT ConfCallback (BYTE bIndication,
		HRESULT	hStatus, PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams);
	VOID ListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams);
	VOID OnCallConnect(HRESULT hStatus, PCC_CONNECT_CALLBACK_PARAMS pConfParams);
	VOID OnCallRinging(HRESULT hStatus, PCC_RINGING_CALLBACK_PARAMS pRingingParams);

	VOID OnChannelRequest(HRESULT hStatus,PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS pChannelReqParams);
	VOID OnChannelAcceptComplete(HRESULT hStatus, PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams);
	VOID OnChannelOpen(HRESULT hStatus,PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS pChannelParams );
	VOID OnT120ChannelRequest(HRESULT hStatus,PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS pT120RequestParams);
    VOID OnT120ChannelOpen(HRESULT hStatus, PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS pT120OpenParams);

	BOOL OnCallAccept(PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams);
	VOID OnHangup(HRESULT hStatus);
	VOID OnRxChannelClose(HRESULT hStatus,PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS pChannelParams );
	VOID OnTxChannelClose(HRESULT hStatus,PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams );
	VOID OnMiscCommand(HRESULT hStatus, 
				PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS pParams);
	VOID OnMiscIndication(HRESULT hStatus, 
				PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS pParams);
    VOID OnMute(HRESULT hStatus, PCC_MUTE_CALLBACK_PARAMS pParams);
    VOID OnUnMute(HRESULT hStatus, PCC_UNMUTE_CALLBACK_PARAMS pParams);
// support functions
	HRESULT NewConference(VOID);
    VOID SetRemoteVendorID(PCC_VENDORINFO pVendorInfo);

//
//	End of CALLCONT.DLL specific members
//		
	BOOL IsReleasing() {return((uRef==0)?TRUE:FALSE);};	// object is being released and should not
											// be reentered
// this implementation has a coarse concept of call setup protocol phase because it's
// using apis of CALLCONT.DLL.
	CtlChanStateType	m_Phase;	// our perception of protocol phase
	BOOL m_fLocalT120Cap;
	BOOL m_fRemoteT120Cap;
	
public:
	CH323Ctrl();
	~CH323Ctrl();


protected:
	SOCKADDR_IN local_sin;
	SOCKADDR_IN remote_sin;	
	int local_sin_len;
	int remote_sin_len;
	
	LPVOID lpvRemoteCustomFormats;
	
	virtual VOID Cleanup();
	BOOL ConfigureRecvChannelCapability(ICtrlCommChan *pChannel , PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams);
	BOOL ValidateChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
	
	STDMETHOD(FindDefaultRXChannel(PCC_TERMCAP pChannelCapability, ICtrlCommChan **lplpChannel));
	GUID m_PID;
private:
	UINT 		uRef;
	HRESULT 	hrLast;
	CCHFLAGS 	m_ChanFlags;
	HRESULT 	m_hCallCompleteCode;
	COBLIST m_ChannelList;            
	IConfAdvise *m_pConfAdvise;
	ICtrlCommChan *FindChannel(CC_HCHANNEL hChannel);
	VOID DoAdvise(DWORD dwEvent, LPVOID lpvData);
	VOID CheckChannelsReady(VOID);
	VOID NewRemoteUserInfo(PCC_ALIASNAMES pRemoteAliasNames, LPWSTR szRemotePeerDisplayName);
	VOID ConnectNotify(DWORD dwEvent);
	VOID GoNextPhase(CtlChanStateType phase);
	VOID InternalDisconnect();
	HRESULT AllocConferenceAttributes();
	VOID CleanupConferenceAttributes();
    VOID ReleaseAllChannels();
    
public:

	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());

	STDMETHOD( Init(IConfAdvise *pConfAdvise));
	STDMETHOD( DeInit(IConfAdvise *pConfAdvise));
	VOID SetRemoteAddress(PSOCKADDR_IN psin) {remote_sin = *psin;};
	VOID SetLocalAddress(PSOCKADDR_IN psin) {local_sin = *psin;};
	
	// so we know what address we accepted on
	STDMETHOD( GetLocalAddress(PSOCKADDR_IN *lplpAddr));	
	// so we know the address of the caller
	STDMETHOD( GetRemoteAddress(PSOCKADDR_IN *lplpAddr));
	STDMETHOD( GetRemotePort(PORT * lpPort));
	STDMETHOD( GetLocalPort(PORT * lpPort));
    STDMETHOD(PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData));
	STDMETHOD_(VOID, Disconnect(DWORD dwReason));
	STDMETHOD( ListenOn(PORT Port));
	STDMETHOD( StopListen(VOID));
   	STDMETHOD( AsyncAcceptRejectCall(CREQ_RESPONSETYPE Response));	
   	
	// accept from the listening connection.  The ideal is that the accepting
	// object would QueryInterface for a private interface, then grab all the
	// pertinent connection info through that interface.  Temporarily expose this
	// using the IControlChannel interface.  The call control state will vary greatly
	// between implementations. For some implementations, this may perform
	// a socket accept before user information has been exchanged. User information will
	// be read into the accepting object directly.  For other implementations, the
	// socket accept is decoupled and has already been performed, and user information
	// has already been read into the listening object. In that case, this method
	// copies the user info and advises the parent "Conference" object of the
	// incoming call
	STDMETHOD( AcceptConnection(LPIControlChannel pIListenCtrlChan, LPVOID lpvListenCallbackParams));
	STDMETHOD_(BOOL, IsAcceptingConference(LPVOID lpvConfID));
	STDMETHOD( GetProtocolID(LPGUID lpPID));
	STDMETHOD_(IH323Endpoint *, GetIConnIF());
	STDMETHOD( MiscChannelCommand(ICtrlCommChan *pChannel,VOID * pCmd));
	STDMETHOD( MiscChannelIndication(ICtrlCommChan *pChannel,VOID * pCmd));
	STDMETHOD( OpenChannel(ICtrlCommChan * pCommChannel, IH323PubCap *pCapResolver,
		MEDIA_FORMAT_ID dwIDLocalSend, MEDIA_FORMAT_ID dwIDRemoteRecv));
	STDMETHOD (CloseChannel(ICtrlCommChan* pCommChannel));
    STDMETHOD (AddChannel(ICtrlCommChan * pCommChannel, LPIH323PubCap pCapabilityResolver));
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));    
	};


#endif	//#ifndef _CTRLH323_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\h323cc.h ===
/*
 *  	File: h323cc.h
 *
 *      Main H.323 call control interface implementation header file
 *
 *		Revision History:
 *
 *		11/28/95	mikev	created (as NAC.H). 
 *		05/19/98	mikev	H323CC.H -  cleaned obsolete references to
 *              streaming components, changed interface and object names
 */


#ifndef _H323CC_H
#define _H323CC_H
#ifdef __cplusplus
class CConnection;
class CH323CallControl;
typedef class CConnection CIPPhoneConnection;
#endif	// __cplusplus

//
//  utility functions
//
VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed);
HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource);

#define DEF_AP_BWMAX	14400

extern UINT g_capFlags;

/*
 *	Class definitions
 */

#ifdef __cplusplus

class CH323CallControl : public IH323CallControl
{
	
protected:
    PCC_ALIASNAMES m_pLocalAliases;
    PCC_ALIASNAMES m_pRegistrationAliases;
   	CC_VENDORINFO m_VendorInfo;
	LPWSTR	m_pUserName;
	UINT	m_uRef;
	HRESULT hrLast;
    BOOL    m_fForCalling;
	UINT m_uMaximumBandwidth;
	// application data
	CNOTIFYPROC m_pProcNotifyConnect;	// connection notification callback
	// subcomponent object references
	LPIH323PubCap m_pCapabilityResolver;
	CConnection *m_pListenLine;	// connection object listening for incoming
	CConnection *m_pLineList;	
	int m_numlines;	// # of objects in m_pLineList

	ImpICommChan 	*m_pSendAudioChannel;	
	ImpICommChan	*m_pSendVideoChannel;	
	
//  Internal interfaces	
	BOOL Init();	// internal initialization

	OBJ_CPT;		// profiling timer
	
public:
	CConnection *m_pNextToAccept;
	LPWSTR GetUserDisplayName() {return m_pUserName;};
    PCC_ALIASNAMES GetUserAliases() {return m_pLocalAliases;};
    PCC_ALIASITEM GetUserDisplayAlias();
	CH323CallControl(BOOL fForCalling, UINT capFlags);
	~CH323CallControl();
	HRESULT CreateConnection(CConnection **lplpConnection, GUID PIDofProtocolType);
	HRESULT RemoveConnection(CConnection *lpConnection);
	HRESULT LastHR() {return hrLast;};
	VOID SetLastHR(HRESULT hr) {hrLast = hr;};
	HRESULT GetConnobjArray(CConnection **lplpArray, UINT uSize);
	ICtrlCommChan *QueryPreviewChannel(LPGUID lpMID);

	STDMETHOD_( CREQ_RESPONSETYPE, ConnectionRequest(CConnection *pConnection));
	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(CConnection *pConnection,
	    P_APP_CALL_SETUP_DATA pAppData));
    STDMETHODIMP GetGKCallPermission();
	static VOID CALLBACK RasNotify(DWORD dwRasEvent, HRESULT hReason);
	static BOOL m_fGKProhibit;
	static RASNOTIFYPROC m_pRasNotifyProc;

// IH323CallControl stuff
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD( Initialize(PORT *lpPort));
	STDMETHOD( SetMaxPPBandwidth(UINT Bandwidth));
	STDMETHOD( RegisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( DeregisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( GetNumConnections(ULONG *lp));
	STDMETHOD( GetConnectionArray(IH323Endpoint * *lplpArray, UINT uSize));
	STDMETHOD( CreateConnection(IH323Endpoint * *lplpLine, GUID PIDofProtocolType));
	STDMETHOD( SetUserDisplayName(LPWSTR lpwName));
	STDMETHODIMP CreateLocalCommChannel(ICommChannel** ppCommChan, LPGUID lpMID,
		IMediaChannel* pMediaStream);
	STDMETHODIMP SetUserAliasNames(P_H323ALIASLIST pAliases);
	STDMETHODIMP EnableGatekeeper(BOOL bEnable, PSOCKADDR_IN pGKAddr, 
	    P_H323ALIASLIST pAliases, RASNOTIFYPROC pRasNotifyProc);
};

#else	// not __cplusplus


#endif	//  __cplusplus


#endif	//#ifndef _H323CC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\intelcc.h ===
#define INTELCC
#ifdef INTELCC
#include "apierror.h"
//#include "q931.h"
#include "incommon.h"
#include "callcont.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\intif.h ===
/*
 *  	File: intif.h
 *
 *      
 *
 *		Revision History:
 *
 *		05/06/96	mikev	created
 */
 

#ifndef _INTIF_H
#define _INTIF_H

//
//	Internal interface classes
//
class IConfAdvise;
class IControlChannel;
class IH323PubCap;

typedef IControlChannel *LPIControlChannel;
typedef IConfAdvise* LPIConfAdvise;
typedef IH323PubCap *LPIH323PubCap;

#endif //_INTIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\h323cc.cpp ===
// File: h323cc.cpp


#include "precomp.h"
#include "confreg.h"
#include "version.h"

EXTERN_C HINSTANCE g_hInst=NULL;	// global module instance

IRTP *g_pIRTP = NULL;
UINT g_capFlags = CAPFLAGS_AV_ALL;

#ifdef DEBUG
HDBGZONE  ghDbgZoneCC = NULL;
static PTCHAR _rgZonesCC[] = {
	TEXT("H323"),
	TEXT("Init"),
	TEXT("Conn"),
	TEXT("Channels"),
	TEXT("Caps"),
	TEXT("Member"),
	TEXT("unused"),
	TEXT("unused"),
	TEXT("Ref count"),
	TEXT("unused"),
	TEXT("Profile spew")	
};


int WINAPI CCDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("H323CC", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */

//  The product ID fields are defined in the standard as an array of bytes. ASCII
//  characters are used regardless of local character set.
// default Product ID and version ID strings

static char DefaultProductID[] = H323_PRODUCTNAME_STR;
static char DefaultProductVersion[] = H323_PRODUCTRELEASE_STR;

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL,
                                     DWORD  fdwReason,
                                     LPVOID  lpvReserved);

BOOL WINAPI DllEntryPoint(
    HINSTANCE  hinstDLL,	// handle to DLL module
    DWORD  fdwReason,	// reason for calling function
    LPVOID  lpvReserved 	// reserved
   )
{
	switch(fdwReason)
	{

		case DLL_PROCESS_ATTACH:
			DBGINIT(&ghDbgZoneCC, _rgZonesCC);

            DBG_INIT_MEMORY_TRACKING(hinstDLL);

			DisableThreadLibraryCalls(hinstDLL);
			g_hInst = hinstDLL;
            break;

		case DLL_PROCESS_DETACH:
            DBG_CHECK_MEMORY_TRACKING(hinstDLL);

			DBGDEINIT(&ghDbgZoneCC);
			break;

		default:
			break;

	}

 	return TRUE;
}


HRESULT WINAPI CreateH323CC(IH323CallControl ** ppCC, BOOL fForCalling, UINT capFlags)
{
	if(!ppCC)
		return H323CC_E_INVALID_PARAM;

    DBG_SAVE_FILE_LINE
	*ppCC = new CH323CallControl(fForCalling, capFlags);
	if(!(*ppCC))
		return	H323CC_E_CREATE_FAILURE;

	return hrSuccess;
	
}


BOOL CH323CallControl::m_fGKProhibit = FALSE;
RASNOTIFYPROC CH323CallControl::m_pRasNotifyProc = NULL;

CH323CallControl::CH323CallControl(BOOL fForCalling, UINT capFlags) :
    m_uRef(1),
    m_fForCalling(fForCalling),
    m_numlines(0),
 m_pProcNotifyConnect(NULL),
 m_pCapabilityResolver(NULL),
 m_pListenLine(NULL),
 m_pLineList(NULL),
 m_pNextToAccept(NULL),
 m_pUserName(NULL),
 m_pLocalAliases(NULL),
 m_pRegistrationAliases(NULL),
 hrLast(hrSuccess),
 m_pSendAudioChannel(NULL),
 m_pSendVideoChannel(NULL),
 m_uMaximumBandwidth(0)
{
    //
    // Set up caps.
    //
    if (fForCalling)
    {
        g_capFlags = capFlags;
    }

	m_VendorInfo.bCountryCode = USA_H221_COUNTRY_CODE;
    m_VendorInfo.bExtension =  USA_H221_COUNTRY_EXTENSION;
    m_VendorInfo.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;

    m_VendorInfo.pProductNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING) 
        + sizeof(DefaultProductID));
    if(m_VendorInfo.pProductNumber)
    {
        m_VendorInfo.pProductNumber->wOctetStringLength = sizeof(DefaultProductID);
        m_VendorInfo.pProductNumber->pOctetString = 
            ((BYTE *)m_VendorInfo.pProductNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pProductNumber->pOctetString,
            DefaultProductID, sizeof(DefaultProductID));
    }
        
    m_VendorInfo.pVersionNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING) 
            + sizeof(DefaultProductVersion));
    if(m_VendorInfo.pVersionNumber)
    {
        m_VendorInfo.pVersionNumber->wOctetStringLength = sizeof(DefaultProductVersion);
        m_VendorInfo.pVersionNumber->pOctetString = 
                ((BYTE *)m_VendorInfo.pVersionNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pVersionNumber->pOctetString,
              DefaultProductVersion, sizeof(DefaultProductVersion));
    }

	RegEntry reCC(szRegInternetPhone TEXT("\\") szRegInternetPhoneNac, 
						HKEY_LOCAL_MACHINE,
						FALSE,
						KEY_READ);

	UINT uAPD = reCC.GetNumberIniStyle(TEXT ("AudioPacketDurationMs"), 0);
	if (uAPD)
	{
		g_AudioPacketDurationMs = uAPD;
		g_fRegAudioPacketDuration = TRUE;
	}

    DBG_SAVE_FILE_LINE
    m_pCapabilityResolver = new CapsCtl();
    if (!m_pCapabilityResolver)
    {
	   	ERRORMESSAGE(("CH323CallControl::CH323CallControl:cannot create capability resolver\r\n"));
	    hrLast = H323CC_E_INIT_FAILURE;
    }

	if(!m_pCapabilityResolver->Init())
   	{
    	ERRORMESSAGE(("CH323CallControl::CH323CallControl cannot init capability resolver\r\n"));
	    hrLast = H323CC_E_INIT_FAILURE;
    }
		
}

HRESULT CH323CallControl::Initialize(PORT *lpPort)
{
	FX_ENTRY("CH323CallControl::Initialize");

	OBJ_CPT_RESET;
	
    ASSERT(m_fForCalling);

	if(!HR_SUCCEEDED(LastHR()))
	{
		goto EXIT;
	}
	if(!lpPort)
	{
		SetLastHR(H323CC_E_INVALID_PARAM);
		goto EXIT;
	}

	if(!Init())
	{
		goto EXIT;
	}
	else
	{
        ASSERT(m_pListenLine);
		hrLast = m_pListenLine->GetLocalPort(lpPort);
	}

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
    	SetLastHR( ::CoCreateInstance(CLSID_RTP,
	                        NULL, 
	                        CLSCTX_INPROC_SERVER,
	                        IID_IRTP, 
	                        (void**)&g_pIRTP) );
    }
	SHOW_OBJ_ETIME("CH323CallControl::Initialize");
	
	EXIT:	
	return LastHR();
				
}

HRESULT CH323CallControl::SetMaxPPBandwidth(UINT Bandwidth)
{
	HRESULT hr = hrSuccess;
	LPAPPVIDCAPPIF  lpIVidAppCap = NULL;
	DWORD dwcFormats = 0;
    DWORD dwcFormatsReturned = 0;
    DWORD x;
	BASIC_VIDCAP_INFO *pvidcaps = NULL;
	
	m_uMaximumBandwidth =Bandwidth;

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
      	//Set the bandwidth on every video format
	    hr = QueryInterface(IID_IAppVidCap, (void **)&lpIVidAppCap);
    	if (! HR_SUCCEEDED (hr))
	    	goto EXIT;

        // Get the number of BASIC_VIDCAP_INFO structures available
        hr = lpIVidAppCap->GetNumFormats((UINT*)&dwcFormats);
    	if (! HR_SUCCEEDED (hr))
	    	goto EXIT;

        if (dwcFormats > 0)
        {
            // Allocate some memory to hold the list in
            if (!(pvidcaps = (BASIC_VIDCAP_INFO*)MemAlloc(dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
            {
		    	hr = H323CC_E_INSUFFICIENT_MEMORY;
			    goto EXIT;
            }
            // Get the list
            hr=lpIVidAppCap->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
        	    (UINT*)&dwcFormatsReturned);
    		if (! HR_SUCCEEDED (hr))
	    		goto EXIT;

            //Set the bandwidth on each format
            for (x=0;x<dwcFormatsReturned;x++)
            {
		    	pvidcaps[x].uMaxBitrate=m_uMaximumBandwidth;
            }

            // Ok, now submit this list
            hr = lpIVidAppCap->ApplyAppFormatPrefs(pvidcaps, dwcFormats);
       		if (! HR_SUCCEEDED (hr))
	    		goto EXIT;
    	}
    }

    //Initialize the default H.323 simcaps.
    hr = m_pCapabilityResolver->ComputeCapabilitySets(m_uMaximumBandwidth);
   	//if(!HR_SUCCEEDED(hr))
    //	goto EXIT;

EXIT:
	// let the interface go
	if (lpIVidAppCap)
	{
		lpIVidAppCap->Release();
		// (going out of scope) lpIVidAppCap = NULL;
	}
	if(pvidcaps)
	{
	    // Free the memory, we're done
        MemFree(pvidcaps);
    }
	return hr;
}

BOOL CH323CallControl::Init()
{
	HRESULT hResult;
	
	DEBUGMSG(ZONE_INIT,("Init: this:0x%08lX\r\n", this));
	SetLastHR(hrSuccess);

    if (m_fForCalling)
    {
        //
        // Only call control code should init CC_ stuff.  Codec manipulation
        // via audiocpl should not.
        //
    	hResult = CC_Initialize();
	    if(!HR_SUCCEEDED(hResult))
    	{
	    	goto CLEANUP;
    	}
    }

   	ASSERT(m_pCapabilityResolver);
		
	// Initialize capability data using default number, but clear the saved
	// bandwidth number afterwards.  This detects attempts to place or  
	// accept calls before the application initializes the real bandwidth
	hResult = SetMaxPPBandwidth(DEF_AP_BWMAX);
	m_uMaximumBandwidth = 0;
	if(!HR_SUCCEEDED(hResult))
	{
		goto CLEANUP;
	}

	// Create dual connection objects for listening for new connections
    if (m_fForCalling)
    {
    	hResult = CreateConnection(&m_pListenLine,PID_H323);
	    if(!HR_SUCCEEDED(hResult))
    	{
	    	goto CLEANUP;
    	}
	    if(!m_pListenLine)
    	{
	    	hResult = H323CC_E_INIT_FAILURE;
		    goto CLEANUP;
    	}
	    if(!(m_pListenLine->ListenOn(H323_PORT)))
    	{
	    	hResult = H323CC_E_NETWORK_ERROR;
		    goto CLEANUP;
    	}
    }
	
	return TRUE;	

CLEANUP:
	if (m_pListenLine)
	{
		m_pListenLine->Release();
		m_pListenLine = NULL;
	}
	SetLastHR(hResult);
	return FALSE;
}


CH323CallControl::~CH323CallControl()
{
	if(m_VendorInfo.pProductNumber)
        MemFree(m_VendorInfo.pProductNumber);
    if(m_VendorInfo.pVersionNumber)
        MemFree(m_VendorInfo.pVersionNumber);
 	if(m_pUserName)
 		MemFree(m_pUserName);
	if(m_pLocalAliases)
		FreeTranslatedAliasList(m_pLocalAliases);
	if(m_pRegistrationAliases)
		FreeTranslatedAliasList(m_pRegistrationAliases);

	if (m_pCapabilityResolver)
    {
		m_pCapabilityResolver->Release();
        m_pCapabilityResolver = NULL;
    }

    if (m_pSendAudioChannel)
    {
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);
 	   	m_pSendAudioChannel->Release();
        m_pSendAudioChannel = NULL;
    }

    if (m_pSendVideoChannel)
    {
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);
	   	m_pSendVideoChannel->Release();
        m_pSendVideoChannel = NULL;
    }

    if (m_fForCalling)
    {
    	// toast backward references to this in all 
	    // connection objects
    	CConnection *pLine = m_pLineList;
 	    CConnection *pNext;
    	while(pLine)
 	    {
 		    pNext = pLine->next;
     		pLine->DeInit();
 	    	pLine = pNext;
     	}

	    // release the listening object if it exists
    	if(m_pListenLine)
	    	m_pListenLine->Release();

    	// shutdown CALLCONT.DLL
	    CC_Shutdown();

      	if (g_pIRTP)
        {
            ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);
    	    g_pIRTP->Release();
   	    	g_pIRTP = NULL;
        }

        // Put capflags back
        g_capFlags = CAPFLAGS_AV_ALL;
    }
    else
    {
        ASSERT(!m_pLineList);
        ASSERT(!m_pListenLine);
    }
}

ULONG CH323CallControl::AddRef()
{
	m_uRef++;
	return m_uRef;
}

ULONG CH323CallControl::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		delete this;
		return 0;
	}
	return m_uRef;
}

HRESULT CH323CallControl::SetUserDisplayName(LPWSTR lpwName)
{
	LPWSTR lpwD;
	ULONG ulSize;
	if(!lpwName)
	{
		return (MakeResult(H323CC_E_INVALID_PARAM));
	}
	if(lpwName)
	{
		ulSize = ((lstrlenW(lpwName) +1)*sizeof(WCHAR));
		lpwD = (LPWSTR)MemAlloc(ulSize);
		if(!lpwD)
			return H323CC_E_INSUFFICIENT_MEMORY;
			
		if(m_pUserName)
		{
			MemFree(m_pUserName);
		}
		
		m_pUserName = lpwD;
		memcpy(m_pUserName, lpwName, ulSize);
	}
	return (MakeResult(hrSuccess));
}

// Find the most suitable alias for display. Return the first H323ID if it exists, 
// else return the first E.164 address
PCC_ALIASITEM CH323CallControl::GetUserDisplayAlias()
{
	WORD wC;
	PCC_ALIASITEM pItem, pFoundItem = NULL;
	if(m_pLocalAliases)
	{
		wC = m_pLocalAliases->wCount;
		pItem = m_pLocalAliases->pItems;
		while (wC--)
		{
			if(!pItem)
			{
				continue;
			}
			if(pItem->wType == CC_ALIAS_H323_ID)
			{
				if(!pItem->wDataLength  || !pItem->pData)
				{
					continue;
				}
				else 
				{
					pFoundItem = pItem;	// done, done, done
					break;				// I said done
				}
			}
			else if(pItem->wType == CC_ALIAS_H323_PHONE)
			{
				if(!pItem->wDataLength  || !pItem->pData)
				{
					continue;
				}
				else 
				{
					if(!pFoundItem)	// if nothing at all was found so far 
						pFoundItem = pItem;	// remember this
				}
			}
			pItem++;
		}
	}
	return pFoundItem;
}

CREQ_RESPONSETYPE CH323CallControl::ConnectionRequest(CConnection *pConnection)
{
	CREQ_RESPONSETYPE Response;
	// decide what to do internally
	// LOOKLOOK hardcoded acceptance
	Response = CRR_ACCEPT;
	return Response;
}	
CREQ_RESPONSETYPE CH323CallControl::FilterConnectionRequest(CConnection *pConnection,
     P_APP_CALL_SETUP_DATA pAppData)
{
	CREQ_RESPONSETYPE Response = CRR_ASYNC;
	ASSERT(m_uMaximumBandwidth);
	// run it past the notification callback (if there is one)
	if(m_pProcNotifyConnect)
	{
		// pass ptr to IConnection
		Response = (m_pProcNotifyConnect)((IH323Endpoint *)&pConnection->m_ImpConnection,
		     pAppData);
		if(Response != CRR_ACCEPT)
		{
			return Response;
		}
	}
	return Response;
}	

		
HRESULT CH323CallControl::RegisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler)
{

	// reject if there's an existing registration
	if (m_pProcNotifyConnect || (!pConnectRequestHandler))
	{
		return H323CC_E_INVALID_PARAM;
	}
	m_pProcNotifyConnect = pConnectRequestHandler;
	return hrSuccess;
}	

HRESULT CH323CallControl::DeregisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler)
{
	// reject if there's not an existing registration
	if (!m_pProcNotifyConnect)
		return H323CC_E_INVALID_PARAM;
	if (pConnectRequestHandler == m_pProcNotifyConnect)
	{
		m_pProcNotifyConnect = NULL;
	}		
	else
	{
		return H323CC_E_INVALID_PARAM;
	}
	return hrSuccess;
}	

HRESULT CH323CallControl::GetNumConnections(ULONG *lp)
{
	ULONG ulRet = m_numlines;
	// hide the "listening" connection object from the client/ui/whatever
	if(ulRet && m_pListenLine)
		ulRet--;
	if(lp)
	{
		*lp = ulRet;
	}
	return hrSuccess;
}	

HRESULT CH323CallControl::GetConnobjArray(CConnection **lplpArray, UINT uSize)
{
	UINT uPublicConnections;	// # of visible objects
	if(!lplpArray)
		return H323CC_E_INVALID_PARAM;

	uPublicConnections = m_numlines;
	if(m_pListenLine)
		uPublicConnections--;
		
	if(uSize < (sizeof(CConnection **) * uPublicConnections))
	{
		return H323CC_E_MORE_CONNECTIONS;
	}
	
	CConnection *pLine = m_pLineList;
	CConnection *pNext;
	int i=0;		
	while(pLine)
	{
		DEBUGCHK(uSize--);
		pNext = pLine->next;
		// return everything but the objects used for listening
		if(pLine != m_pListenLine) 
		{
			lplpArray[i++] = pLine;
		}
		pLine = pNext;
	}
	
	return hrSuccess;
};



HRESULT CH323CallControl::GetConnectionArray(IH323Endpoint * *lplpArray, UINT uSize)
{

	UINT uPublicConnections;	// # of visible objects
	if(!lplpArray)
		return H323CC_E_INVALID_PARAM;

	uPublicConnections = m_numlines;
	if(m_pListenLine)
		uPublicConnections--;

	if(uSize < (sizeof(IH323Endpoint * *) * uPublicConnections))
	{
		return H323CC_E_MORE_CONNECTIONS;
	}
	
	CConnection *pLine = m_pLineList;
	CConnection *pNext;
	int i=0;		
	while(pLine)
	{
		DEBUGCHK(uSize--);
		pNext = pLine->next;
		// return everything but the objects used for listening
		if(pLine != m_pListenLine)
		{
			lplpArray[i++] = (IH323Endpoint *)&pLine->m_ImpConnection;
		}
		pLine = pNext;
	}
	
	return hrSuccess;
};

//
// protocol specific CreateConnection
//
HRESULT CH323CallControl::CreateConnection(CConnection **lplpConnection, GUID PIDofProtocolType)
{
	SetLastHR(hrSuccess);
	CConnection *lpConnection, *lpList;
	if(!lplpConnection)
	{
		SetLastHR(MakeResult(H323CC_E_INVALID_PARAM));
		goto EXIT;
	}
	
	*lplpConnection = NULL;
			
    DBG_SAVE_FILE_LINE
	if(!(lpConnection = new CConnection))
	{
		SetLastHR(MakeResult(H323CC_E_INSUFFICIENT_MEMORY));
		goto EXIT;
	}

	hrLast = lpConnection->Init(this, PIDofProtocolType);

	// LOOKLOOK need to insert this connection in the connection list
	if(!HR_SUCCEEDED(hrSuccess))
	{
		delete lpConnection;
		lpConnection = NULL;
	}
	else	
	{
		*lplpConnection = lpConnection;
		// insert in connection list
		lpList = m_pLineList;
		m_pLineList = lpConnection;
		lpConnection->next =lpList;
		m_numlines++;
	}
	EXIT:
	return (LastHR());


}


//
//	IH323CallControl->CreateConnection(), EXTERNAL create connection interface.  
//
HRESULT CH323CallControl::CreateConnection(IH323Endpoint * *lplpLine, GUID PIDofProtocolType)
{
	SetLastHR(hrSuccess);
	CConnection *lpConnection;
	ASSERT(m_uMaximumBandwidth);
	if(!m_uMaximumBandwidth)
	{
		SetLastHR(MakeResult(H323CC_E_NOT_INITIALIZED));
		goto EXIT;
	}
	if(!lplpLine)
	{
		SetLastHR(MakeResult(H323CC_E_INVALID_PARAM));
		goto EXIT;
	}
	*lplpLine = NULL;
	
	hrLast = CreateConnection(&lpConnection, PIDofProtocolType);
	
	if(HR_SUCCEEDED(LastHR()) && lpConnection)
	{
		*lplpLine = (IH323Endpoint *)&lpConnection->m_ImpConnection;
	}
	EXIT:	
	return (LastHR());
}

//
// CreateLocalCommChannel creates the send side of a media channel outside the context
// of any call.
//

HRESULT CH323CallControl::CreateLocalCommChannel(ICommChannel** ppCommChan, LPGUID lpMID,
	IMediaChannel* pMediaStream)
{

	if(!ppCommChan || !lpMID || !pMediaStream)
		return H323CC_E_INVALID_PARAM;
		
	if (*lpMID == MEDIA_TYPE_H323AUDIO)
	{
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);

		// allow only one of each media type to be created.  This is an artificial
		// limitation.
		if(m_pSendAudioChannel)
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}

        DBG_SAVE_FILE_LINE
		if(!(m_pSendAudioChannel = new ImpICommChan))
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}
		
		hrLast = m_pSendAudioChannel->StandbyInit(lpMID, m_pCapabilityResolver, 
			pMediaStream);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendAudioChannel->Release();
			m_pSendAudioChannel = NULL;
			goto EXIT;
		}
		
		hrLast = m_pSendAudioChannel->QueryInterface(IID_ICommChannel, (void **)ppCommChan);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendAudioChannel->Release();
			m_pSendAudioChannel = NULL;
			goto EXIT;
		}
	}
	else if (*lpMID == MEDIA_TYPE_H323VIDEO)
	{
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);

		// allow only one of each media type to be created.  This is an artificial
		// limitation.
		if(m_pSendVideoChannel)
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}

        DBG_SAVE_FILE_LINE
		if(!(m_pSendVideoChannel = new ImpICommChan))
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}
		hrLast = m_pSendVideoChannel->StandbyInit(lpMID, m_pCapabilityResolver,
			pMediaStream);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendVideoChannel->Release();
			m_pSendVideoChannel = NULL;
			goto EXIT;
		}
		hrLast = m_pSendVideoChannel->QueryInterface(IID_ICommChannel, (void **)ppCommChan);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendVideoChannel->Release();
			m_pSendVideoChannel = NULL;
			goto EXIT;
		}
	}
	else
		hrLast = H323CC_E_INVALID_PARAM;
EXIT:
	return hrLast;
}


ICtrlCommChan *CH323CallControl::QueryPreviewChannel(LPGUID lpMID)
{
	HRESULT hr;
	ICtrlCommChan *pCommChan = NULL;
	if(*lpMID == MEDIA_TYPE_H323AUDIO)
	{
		if(m_pSendAudioChannel)
		{
			hr = m_pSendAudioChannel->QueryInterface(IID_ICtrlCommChannel, (void **)&pCommChan);
			if(HR_SUCCEEDED(hr))
			{
				return pCommChan;
			}
		}
	}
	else if (*lpMID == MEDIA_TYPE_H323VIDEO)
	{
		if(m_pSendVideoChannel)
		{
			hr = m_pSendVideoChannel->QueryInterface(IID_ICtrlCommChannel, (void **)&pCommChan);
			if(HR_SUCCEEDED(hr))
			{
				return pCommChan;
			}
		}
	}
	// fallout to error case
	return NULL;
}


HRESULT CH323CallControl::RemoveConnection(CConnection *lpConnection)
{
	SetLastHR(hrSuccess);
	CConnection *lpList;
	UINT nLines;
	

	if((lpConnection == NULL) || lpConnection->m_pH323CallControl  != this)
	{
		SetLastHR(MakeResult(H323CC_E_INVALID_PARAM));
		goto EXIT;
	}
	
	m_numlines--; // update count NOW
	

	// use # of lines for bug detection in list management code
	nLines = m_numlines;

	
	if(m_pListenLine == lpConnection)
		m_pListenLine = NULL;
		
	// zap the back pointer of the connection NOW - this is crucial for
	// implementing "asynchronous delete" of connection objects
	lpConnection->m_pH323CallControl = NULL;	

	// find it in the connection list and remove it	
	
	// sp. case head
	if(m_pLineList== lpConnection)
	{
		m_pLineList = lpConnection->next;
	}
	else
	{
		lpList = m_pLineList;
		while(lpList->next && nLines)
		{
			if(lpList->next == lpConnection)
			{
				lpList->next = lpConnection->next;
				break;
			}
			lpList = lpList->next;
			nLines--;
		}	
	}

	EXIT:	
	return (LastHR());
}
	

STDMETHODIMP CH323CallControl::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if ((iid == IID_IH323CC) || (iid == IID_IUnknown))// satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if (iid == IID_IAppAudioCap )
    {
	   	hr = m_pCapabilityResolver->QueryInterface(iid, ppvObject);
    }
    else if(iid == IID_IAppVidCap )
	{
	    hr = m_pCapabilityResolver->QueryInterface(iid, ppvObject);
    }
	else if(iid == IID_IDualPubCap )
    {
	   	hr = m_pCapabilityResolver->QueryInterface(iid, ppvObject);
    }

	return (hr);
}


//
// 	Create a copy of the alias names in the (somewhat bogus) format that 
//	CALLCONT expects.  The destination format has a two-part string for every 
//	entry, but the lower layers concatenate the parts. Someday H323CC and CALLCONT
// 	will be one, and all the extraneous layers, copies of data, and redundant 
//  validations won't be needed.
//

HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource)
{
	HRESULT hr = H323CC_E_INVALID_PARAM;
	WORD w;
	PCC_ALIASNAMES pNewAliases = NULL;
	PCC_ALIASITEM pDestItem;
	P_H323ALIASNAME pSrcItem;
	
	if(!ppDest || !pSource || pSource->wCount == 0)
	{
		goto ERROR_OUT;
	}
	*ppDest = NULL;
	pNewAliases = (PCC_ALIASNAMES)MemAlloc(sizeof(CC_ALIASNAMES));
	if(!pNewAliases)
	{
		hr = H323CC_E_INSUFFICIENT_MEMORY;
		goto ERROR_OUT;
	}
	pNewAliases->wCount = 0;
	pNewAliases->pItems = (PCC_ALIASITEM)MemAlloc(pSource->wCount*sizeof(CC_ALIASITEM));
    if(!pNewAliases->pItems)
	{
		hr = H323CC_E_INSUFFICIENT_MEMORY;
		goto ERROR_OUT;
	}        
	for(w=0;w<pSource->wCount;w++)
	{
		pDestItem = pNewAliases->pItems+w;
		pSrcItem = pSource->pItems+w;
		// don't tolerate empty entries - error out if any exist
		if(pSrcItem->wDataLength && pSrcItem->lpwData)
		{
			if(pSrcItem->aType ==AT_H323_ID)
			{
				pDestItem->wType = CC_ALIAS_H323_ID;
			}
			else if(pSrcItem->aType ==AT_H323_E164)
			{
				pDestItem->wType = CC_ALIAS_H323_PHONE;
			}
			else
			{	// don't know how to translate this.  I hope that the need for translation 
				// goes away before new alias types are added.  Adding an alias type 
				// (H323_URL for example) requires many changes in lower layers anyway, 
				// so that would be a good time to merge H323CC and CALLCONT.
				goto ERROR_OUT;	// return invalid param
			}
			pDestItem->wPrefixLength = 0;	// this prefix thing is bogus
            pDestItem->pPrefix = NULL;
			pDestItem->pData = (LPWSTR)MemAlloc(pSrcItem->wDataLength *sizeof(WCHAR));
			if(pDestItem->pData == NULL)
			{
				hr = H323CC_E_INSUFFICIENT_MEMORY;
				goto ERROR_OUT;
			}
			// got good data. Copy the data, set size/length, and count it
            memcpy(pDestItem->pData, pSrcItem->lpwData, pSrcItem->wDataLength * sizeof(WCHAR));			
            pDestItem->wDataLength = pSrcItem->wDataLength;
			pNewAliases->wCount++;
		}
		else
		{
			goto ERROR_OUT;
		}
	}
	// got here, so output good data 
	hr = hrSuccess;
	*ppDest = pNewAliases;
	//pNewAliases = NULL;   // not needed if returning here instead of falling out
	return hr;
	
ERROR_OUT:
	if(pNewAliases)	// then it's an error condition needing cleanup
	{
		FreeTranslatedAliasList(pNewAliases);
	}
	return hr;
}
VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed)
{
	WORD w;
	PCC_ALIASITEM pDoomedItem;
	if(!pDoomed)
		return;
		
	for(w=0;w<pDoomed->wCount;w++)
	{
		pDoomedItem = pDoomed->pItems+w;
	
		// don't tolerate empty entries - error out if any exist
		if(pDoomedItem->wDataLength && pDoomedItem->pData)
		{
			MemFree(pDoomedItem->pData);
		}
		else
			ASSERT(0);
	}
	MemFree(pDoomed->pItems);
	MemFree(pDoomed);
}


STDMETHODIMP CH323CallControl::SetUserAliasNames(P_H323ALIASLIST pAliases)
{
	HRESULT hr = hrSuccess;
	PCC_ALIASNAMES pNewAliases = NULL;
	PCC_ALIASITEM pItem;
	
	hr = AllocTranslatedAliasList(&pNewAliases, pAliases);
	if(!HR_SUCCEEDED(hr))
		return hr;

	ASSERT(pNewAliases);
	if(m_pLocalAliases)
		FreeTranslatedAliasList(m_pLocalAliases);
		
	m_pLocalAliases = pNewAliases;
	return hr;	
}

STDMETHODIMP CH323CallControl::EnableGatekeeper(BOOL bEnable,  
	PSOCKADDR_IN  pGKAddr, P_H323ALIASLIST pAliases,
	 RASNOTIFYPROC pRasNotifyProc)
{
	HRESULT hr = hrSuccess;

	PCC_ALIASNAMES pNewAliases = NULL;
	PCC_ALIASITEM pItem;

	m_pRasNotifyProc = pRasNotifyProc;
	if(bEnable)
	{
		if(!pRasNotifyProc || !pGKAddr || !pAliases)
		{
			return H323CC_E_INVALID_PARAM;
		}
		if((pGKAddr->sin_addr.s_addr == INADDR_NONE) 
			|| (pGKAddr->sin_addr.s_addr == INADDR_ANY))
		{
			return H323CC_E_INVALID_PARAM;
		}
		hr = AllocTranslatedAliasList(&pNewAliases, pAliases);
		if(!HR_SUCCEEDED(hr))
			return hr;

		ASSERT(pNewAliases);
		if(m_pRegistrationAliases)
			FreeTranslatedAliasList(m_pRegistrationAliases);
			
		m_pRegistrationAliases = pNewAliases;
		// reset "I can place calls" state
		m_fGKProhibit = FALSE;
		hr = CC_EnableGKRegistration(bEnable, 
		    pGKAddr, m_pRegistrationAliases, 
			&m_VendorInfo,
			0,			// no multipoint/MC funtionality
		    RasNotify);
	}
	else
	{
		// we are turning off knowledge of what a gatekeeper is, 
		// so reset "I can place calls" state.  
		m_fGKProhibit = FALSE;
		hr = CC_EnableGKRegistration(bEnable, 
		    NULL, NULL, NULL, 0, RasNotify);
		if(m_pRegistrationAliases)
			FreeTranslatedAliasList(m_pRegistrationAliases);
			
		m_pRegistrationAliases = NULL;
	}
	return hr;
}

STDMETHODIMP CH323CallControl::GetGKCallPermission()
{
	if(m_fGKProhibit)
		return CONN_E_GK_NOT_REGISTERED;
	else
		return hrSuccess;
}

VOID CALLBACK CH323CallControl::RasNotify(DWORD dwRasEvent, HRESULT hReason)
{

	switch(dwRasEvent)
	{
		case RAS_REG_CONFIRM: // received RCF (registration confirmed)
			// reset "I can place calls" state
			m_fGKProhibit = FALSE;
		break;
		
		case RAS_REG_TIMEOUT: // GK did not respond
		case RAS_UNREG_CONFIRM: // received UCF (unregistration confirmed) 
		default:
			// do nothing. (except pass notification upward
		break;
		
		case RAS_REJECTED:  // received RRJ (registration rejected)
			m_fGKProhibit = TRUE;
		break;
		case RAS_UNREG_REQ:  // received URQ 
			m_fGKProhibit = TRUE;
		break;
	}
	if(m_pRasNotifyProc)
	{
		(m_pRasNotifyProc)(dwRasEvent, hReason);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\iconnect.cpp ===
#include "precomp.h"
//
//	Interface stuff
//

HRESULT ImpIConnection::QueryInterface( REFIID iid,	void ** ppvObject)
{
    HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if((iid == IID_IPhoneConnection) 
	|| (iid == IID_IUnknown)) // satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else 
        hr = m_pConnection->QueryInterface(iid, ppvObject);
    return hr;
}


ULONG ImpIConnection::AddRef()
{
	 return (m_pConnection->AddRef());
}
ULONG ImpIConnection::Release()
{
	 return (m_pConnection->Release());
}
HRESULT ImpIConnection::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	 return (m_pConnection->SetAdviseInterface(pH323ConfAdvise));
}
HRESULT ImpIConnection::ClearAdviseInterface()
{
	 return (m_pConnection->ClearAdviseInterface());
}

HRESULT ImpIConnection::PlaceCall(BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData)
{
	return (m_pConnection->PlaceCall(bUseGKResolution, pCallAddr,		
        pDestinationAliases, pExtraAliases,  	
	    pCalledPartyNumber, pAppData));
}
HRESULT ImpIConnection::Disconnect()
{
	 return (m_pConnection->Disconnect());
}
HRESULT ImpIConnection::GetState(ConnectStateType *pState)
{
	 return (m_pConnection->GetState(pState));
}

HRESULT ImpIConnection::GetRemoteUserName(LPWSTR lpwszName, UINT uSize)
{
	return (m_pConnection->GetRemoteUserName(lpwszName, uSize));
}
HRESULT ImpIConnection::GetRemoteUserAddr(PSOCKADDR_IN psinUser)
{
	return (m_pConnection->GetRemoteUserAddr(psinUser));
}

HRESULT ImpIConnection::AcceptRejectConnection(CREQ_RESPONSETYPE Response)
{
	return (m_pConnection->AcceptRejectConnection(Response));
}
HRESULT ImpIConnection::GetSummaryCode()
{
	 return (m_pConnection->GetSummaryCode());
}
HRESULT ImpIConnection::CreateCommChannel(LPGUID pMediaGuid, ICommChannel **ppICommChannel,
	BOOL fSend)
{
	return (m_pConnection->CreateCommChannel(pMediaGuid, ppICommChannel, fSend));
}
HRESULT ImpIConnection:: ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput)
{
	return (m_pConnection->ResolveFormats(pMediaGuidArray, uNumMedia, pResOutput));
}
HRESULT ImpIConnection::GetVersionInfo(PCC_VENDORINFO *ppLocalVendorInfo,
									  PCC_VENDORINFO *ppRemoteVendorInfo)
{
	return (m_pConnection->GetVersionInfo(ppLocalVendorInfo, ppRemoteVendorInfo));
}

ImpIConnection::ImpIConnection()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\ictlchan.h ===
/*
 *  	File: ictlchan.h
 *
 *      Network AV conference control channel interface header file.
 *
 *		Revision History:
 *
 *		04/15/96	mikev	created
 */


#ifndef _ICTLCHAN_H
#define _ICTLCHAN_H

// Call progress states
typedef enum {
	CCS_Idle,
	CCS_Connecting,
	CCS_Accepting,
	CCS_Ringing,
	CCS_Opening,
	CCS_Closing,
	CCS_Ready,	// the diff between Ready and InUse is that going to the CCS_Ready
	// state notifies the parent object (The one that implements IConfAdvise) and
	// then the state goes immediately to CCS_InUse

	CCS_InUse,
	CCS_Listening,
	CCS_Disconnecting,
	CCS_Filtering
}CtlChanStateType;


//
// 	event status codes passed to IConfAdvise::OnControlEvent
//


#define CCEV_RINGING			0x00000001	// waiting for user to accept
#define CCEV_CONNECTED			0x00000002	// accepted.  Remote user info is available.
// undefined whether or not capabilities have been exchanged.
// undefined whether or not default channels are open at this time   Should there be a
// CCEV_MEMBER_ADD indication even on a point to point connection then?

#define CCEV_CAPABILITIES_READY		0x00000003	// capabilities are available. it's
// best to cache them now, default channels will be opened next (may already be open)
// attempts at opening ad-hoc channels can now be made
#define CCEV_CHANNEL_READY_RX		0x00000004// (or call channel->OnChannelOpen ???)
#define CCEV_CHANNEL_READY_TX		0x00000005//
#define CCEV_CHANNEL_READY_BIDI		0x00000006//

// parent obj supplies expected channels in EnumChannels().  Requests are fulfilled
// using the supplied channels if possible, and if not, the request is passed upward
#define CCEV_CHANNEL_REQUEST		0x00000007		// another channel is being requested
// what about invalid requests, like unsupported formats? reject and report the error
// upward or just pass upward and require the parent to reject?

// what's the H.323 behavior of mute?
//#define CCEV_MUTE_INDICATION 		0x00000008
//#define CCEV_UNMUTE_INDICATION	0x00000009

//#define CCEV_MEMBER_ADD    	   	0x0000000a
//#define CCEV_MEMBER_DROP			0x0000000b


#define CCEV_DISCONNECTING			0x0000000e	// opportunity to cleanup channels
#define CCEV_REMOTE_DISCONNECTING	0x0000000f	// opportunity to cleanup channels
#define CCEV_DISCONNECTED			0x00000010	//
#define CCEV_ALL_CHANNELS_READY 	0x00000011	// all *mandatory* channels are open
												// but not necessarily all channels
#define CCEV_CALL_INCOMPLETE	 	0x00000012	// busy, no answer, rejected, etc.
#define CCEV_ACCEPT_INCOMPLETE	 	0x00000013	//
#define CCEV_CALLER_ID				0x00000014


//
//  Extended information for CCEV_CALL_INCOMPLETE event.  Not all are applicable to all
//	call control implementations
//

#define CCCI_UNKNOWN		    MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000000)
#define CCCI_BUSY				MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000001)
#define CCCI_REJECTED			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000002)
#define CCCI_REMOTE_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000003)
#define CCCI_LOCAL_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000004)
#define CCCI_CHANNEL_OPEN_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000005)	// all mandatory channels could not be opened.
#define CCCI_INCOMPATIBLE		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000006)
#define CCCI_REMOTE_MEDIA_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000007)
#define CCCI_LOCAL_MEDIA_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000008)
#define CCCI_PROTOCOL_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000009)
#define CCCI_USE_ALTERNATE_PROTOCOL		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000a)
#define CCCI_NO_ANSWER_TIMEOUT  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000b)
#define CCCI_GK_NO_RESOURCES    MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000c)
#define CCCI_SECURITY_DENIED	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000d)


//
//	User information structure.  This needs to be replaced by a real property interface.
//  The only viable content at this time is a user name string. There is still some
//  volatility in the H.323 draft regarding how the user name gets propagated
typedef struct _user_info {
	DWORD dwCallerIDSize;		// total size of this structure
	LPVOID lpvCallerIDData;	// pointer to caller ID
	LPVOID lpvRemoteProtocolInfo;	// protocol specific extra info
	LPVOID lpvLocalProtocolInfo;	//	
}CTRL_USER_INFO, *LPCTRL_USER_INFO;


#ifdef __cplusplus

class IConfAdvise
{
	public:
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;

    STDMETHOD(OnControlEvent(DWORD dwEvent, LPVOID lpvData, LPIControlChannel lpControlObject))=0;
	STDMETHOD(GetCapResolver(LPVOID *lplpCapObject, GUID CapType))=0;
	STDMETHOD_(LPWSTR, GetUserDisplayName()) =0;
    STDMETHOD_(PCC_ALIASNAMES, GetUserAliases()) =0;
    STDMETHOD_(PCC_ALIASITEM, GetUserDisplayAlias()) =0;
	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(
	    LPIControlChannel lpControlChannel,  P_APP_CALL_SETUP_DATA pAppData))=0;

	// GetAcceptingObject may create a new conf object, but always creates a new control
	// channel and initializes it with a back pointer to the new or existing conf object.
	// the accepting object is the new control channel object.  Whatever the accepting
	// objects back pointer points to will get the CCEV_CONNECTED notification and then
	// will be able to get the caller ID etc., and then decide if it wants to accept the
	// call.
	STDMETHOD(GetAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPGUID pPID))=0;

	STDMETHOD(FindAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPVOID lpvConfID))=0;
	STDMETHOD_(IH323Endpoint *, GetIConnIF()) =0;
	STDMETHOD(AddCommChannel) (THIS_ ICtrlCommChan *pChan) PURE;
};

class IControlChannel
{
	public:
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;

	STDMETHOD( Init(IConfAdvise *pConfAdvise))=0;
	STDMETHOD( DeInit(IConfAdvise *pConfAdvise))=0;
	// so we know what address we accepted on
	STDMETHOD( GetLocalAddress(PSOCKADDR_IN *lplpAddr))=0;	
	// so we know the address of the caller
	STDMETHOD( GetRemoteAddress(PSOCKADDR_IN *lplpAddr))=0;
	STDMETHOD( GetRemotePort(PORT * lpPort))=0;
	STDMETHOD( GetLocalPort(PORT * lpPort))=0;
    STDMETHOD(PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData))=0;
	    
	STDMETHOD_(VOID,  Disconnect(DWORD dwReason))=0;
	STDMETHOD( ListenOn(PORT Port))=0;
	STDMETHOD( StopListen(VOID))=0;
   	STDMETHOD( AsyncAcceptRejectCall(CREQ_RESPONSETYPE Response))=0;	
   	
	// accept from the listening connection.  The ideal is that the accepting
	// object would QueryInterface for a private interface, then grab all the
	// pertinent connection info through that interface.  Temporarily expose this
	// using the IControlChannel interface.  The call control state will vary greatly
	// between implementations. For some implementations, this may perform
	// a socket accept before user information has been exchanged. User information will
	// be read into the accepting object directly.  For other implementations, the
	// socket accept is decoupled and has already been performed, and user information
	// has already been read into the listening object. In that case, this method
	// copies the user info and advises the parent "Conference" object of the
	// incoming call
	
	STDMETHOD( AcceptConnection(IControlChannel *pListenObject, LPVOID lpvAcceptData))=0;
	// true if this channel is resonsible for accepting connections into the conference
	// indicated by lpvConfID. In the future this may be split into two methods:
	// GetConfID() and IsAccepting()
	STDMETHOD_(BOOL, IsAcceptingConference(LPVOID lpvConfID))=0;
	STDMETHOD( GetProtocolID(LPGUID lpPID))=0;
	STDMETHOD_(IH323Endpoint *, GetIConnIF()) =0;	
	STDMETHOD( MiscChannelCommand(ICtrlCommChan *pChannel,VOID * pCmd)) =0;
	STDMETHOD( MiscChannelIndication(ICtrlCommChan *pChannel,VOID * pCmd)) =0;
	STDMETHOD( OpenChannel(ICtrlCommChan* pCommChannel, IH323PubCap *pCapResolver, 
		MEDIA_FORMAT_ID dwIDLocalSend, MEDIA_FORMAT_ID dwIDRemoteRecv))=0;
	STDMETHOD (CloseChannel(ICtrlCommChan* pCommChannel))=0;
    STDMETHOD (AddChannel(ICtrlCommChan * pCommChannel, LPIH323PubCap pCapabilityResolver))=0;
    STDMETHOD(GetVersionInfo)(THIS_
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo) PURE;    
};

#endif	// __cplusplus

#endif	//#ifndef _ICTLCHAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\icomchan.cpp ===
#include "precomp.h"

#ifndef OLDSTUFF
extern IRTP *g_pIRTP;
#endif
STDMETHODIMP  ImpICommChan::StandbyInit(LPGUID lpMID, LPIH323PubCap pCapObject, 
	    IMediaChannel* pMediaStreamSend)
{
	if((!lpMID) || (!pCapObject))
		return CHAN_E_INVALID_PARAM;
		
	m_MediaID = *lpMID;
	bIsSendDirection = TRUE;
	m_pMediaStream = pMediaStreamSend;
	m_pMediaStream->AddRef();
	
	// keeps a cap object ref
	pCapObject->AddRef();
	m_pCapObject = pCapObject;
	return hrSuccess;
}

STDMETHODIMP ImpICommChan::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM 
	// interfaces.  The reflexive property of QueryInterface would be broken in 
	// that case.
	
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IUnknown) 
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICommChannel))
	{
		*ppvObject = (ICommChannel *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICtrlCommChannel))
	{
		*ppvObject = (ICtrlCommChan *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_IStreamSignal))
	{
		*ppvObject = (IStreamSignal *)this;
		hr = hrSuccess;
		AddRef();
	} 
	else if((iid == IID_IAppAudioCap ) && m_pCapObject)
	{
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IAppVidCap ) && m_pCapObject)
	{
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IDualPubCap) && m_pCapObject)
	{
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if(iid == IID_IVideoRender)
	{
		hr=hrSuccess;	
		if(!m_pMediaStream && m_pH323ConfAdvise)
		{
			hr = m_pH323ConfAdvise->GetMediaChannel(&m_MediaID, 
				bIsSendDirection, &m_pMediaStream);
		}
		if(HR_SUCCEEDED(hr))
		{
			hr = m_pMediaStream->QueryInterface(iid, ppvObject);
		}
	}
	else if(iid == IID_IVideoChannel)
	{
		hr=hrSuccess;	
		if(!m_pMediaStream && m_pH323ConfAdvise)
		{
			hr = m_pH323ConfAdvise->GetMediaChannel(&m_MediaID, 
				bIsSendDirection, &m_pMediaStream);
		}
		if(HR_SUCCEEDED(hr))
		{
			hr = m_pMediaStream->QueryInterface(iid, ppvObject);
		}
	}
	return (hr);
}


ULONG ImpICommChan::AddRef()
{
	m_uRef++;
	DEBUGMSG(ZONE_REFCOUNT,("ImpICommChan::AddRef:(0x%08lX)->AddRef() m_uRef = 0x%08lX\r\n",this, m_uRef ));
	return m_uRef;
}

ULONG ImpICommChan::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		DEBUGMSG(ZONE_REFCOUNT,("ImpICommChan::Release:(0x%08lX)->Releasing\r\n", this));
		delete this;
		return 0;
	}
	else
	{
		DEBUGMSG(ZONE_REFCOUNT,("ImpICommChan::Release:(0x%08lX)->Release() m_uRef = 0x%08lX\r\n",this, m_uRef ));
		return m_uRef;
	}
}

HRESULT ImpICommChan::GetMediaType(LPGUID pGuid)
{
	if(!pGuid)
		return CHAN_E_INVALID_PARAM;
		
	*pGuid = m_MediaID;
	return hrSuccess;
}



HRESULT ImpICommChan::IsChannelOpen(BOOL *pbOpen)
{
	if(!pbOpen)
		return CHAN_E_INVALID_PARAM;
	*pbOpen = (IsComchOpen()) ? TRUE:FALSE;
	return hrSuccess;	
}


STDMETHODIMP ImpICommChan::GetProperty(DWORD prop, PVOID pBuf, LPUINT pcbBuf)
{
	#define CHECKSIZE(type) if(*pcbBuf != sizeof(type))	return CHAN_E_INVALID_PARAM;
	#define OUTPROP(type) *(type *)pBuf
	if(!pBuf || !pcbBuf)
		return CHAN_E_INVALID_PARAM;
	switch (prop) 
	{

		case PROP_TS_TRADEOFF:
			CHECKSIZE(DWORD);
		  	OUTPROP(DWORD) = m_TemporalSpatialTradeoff;
		break;
		case PROP_REMOTE_TS_CAPABLE:
			CHECKSIZE(BOOL);
			OUTPROP(BOOL) = m_bPublicizeTSTradeoff;
		break;
		case PROP_CHANNEL_ENABLED:
			CHECKSIZE(BOOL);
		  	OUTPROP(BOOL) = (m_dwFlags & COMCH_ENABLED )? TRUE:FALSE;
		break;
		case PROP_LOCAL_FORMAT_ID:
			CHECKSIZE(MEDIA_FORMAT_ID);
		  	OUTPROP(MEDIA_FORMAT_ID) = m_LocalFmt;
		break;
		case PROP_REMOTE_FORMAT_ID:
			CHECKSIZE(MEDIA_FORMAT_ID);
		  	OUTPROP(MEDIA_FORMAT_ID) = m_RemoteFmt;
		break;
		case PROP_REMOTE_PAUSED:
		    CHECKSIZE(BOOL);
		  	OUTPROP(BOOL) = (IsStreamingRemote())? FALSE:TRUE;
		break;
        case PROP_LOCAL_PAUSE_RECV:
		case PROP_LOCAL_PAUSE_SEND:
            CHECKSIZE(BOOL);
            OUTPROP(BOOL) = IsPausedLocal();
        break;
		case PROP_VIDEO_PREVIEW_ON:
			CHECKSIZE(BOOL);
			OUTPROP(BOOL) = IsStreamingStandby();
		break;
		case PROP_VIDEO_PREVIEW_STANDBY:
			CHECKSIZE(BOOL);
			OUTPROP(BOOL) = IsConfigStandby();
		break;
		default:
			if(m_pMediaStream)
			{
				// we don't recognize this property, pass to media control 
				return m_pMediaStream->GetProperty(prop, pBuf, (LPUINT)pcbBuf);
			}
			else
				return CHAN_E_INVALID_PARAM;
		break;
	}
	return hrSuccess;
}

// Some properties are not writeable by client code. CtrlChanSetProperty allows setting of 
// those properties.  This method is *not* exposed in ICommChannel
STDMETHODIMP ImpICommChan::CtrlChanSetProperty(DWORD prop, PVOID pBuf, DWORD cbBuf)
{
	FX_ENTRY("ImpICommChan::CtrlChanSetProperty");
	BOOL bTemp;
	HRESULT hr = hrSuccess;
	if(!pBuf || !pBuf || !cbBuf)
		return CHAN_E_INVALID_PARAM;

	#define CHECKSIZEIN(type) if(cbBuf != sizeof(type))	return CHAN_E_INVALID_PARAM;
	#define INPROP(type) *(type *)pBuf
	switch (prop) 
	{
		case PROP_TS_TRADEOFF_IND:	// remote sender changed T/S tradeoff of what it is
			if(bIsSendDirection)	// sending  (valid for receive channels only)
				return CHAN_E_INVALID_PARAM;
				
			m_TemporalSpatialTradeoff = INPROP(DWORD);
			if(m_pH323ConfAdvise && m_pCtlChan)
			{
				DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, CHANNEL_VIDEO_TS_TRADEOFF));
				m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), CHANNEL_VIDEO_TS_TRADEOFF);
			}
		break;

		case PROP_REMOTE_FORMAT_ID:
			CHECKSIZEIN(DWORD);
			m_RemoteFmt = INPROP(DWORD);
		break;
		case PROP_REMOTE_TS_CAPABLE:	// only valid for receive channels
			if(bIsSendDirection)
				return CHAN_E_INVALID_PARAM;
			else
			{
				CHECKSIZEIN(BOOL);
				m_bPublicizeTSTradeoff = INPROP(BOOL);
				DEBUGMSG (ZONE_COMMCHAN,("%s:remote TS tradeoff cap %d\r\n", _fx_, m_bPublicizeTSTradeoff));
	
			}
			break;
		default:
			return SetProperty(prop, pBuf, cbBuf);
		break;
	}
	return hr;
	
}

STDMETHODIMP ImpICommChan::Preview(MEDIA_FORMAT_ID idLocalFormat, IMediaChannel * pMediaStream)
{
	HRESULT hr = hrSuccess;
	FX_ENTRY("ImpICommChan::Preview");
	SHOW_OBJ_ETIME("ImpICommChan::Preview");
	LPVOID lpvFormatDetails;
	UINT uFormatSize;
	
	if(!bIsSendDirection)
	{
		hr = CHAN_E_INVALID_PARAM;
		goto EXIT;
	}
	if(NULL == pMediaStream)
	{
		// preview off

		if(IsStreamingStandby())
		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to preview OFF\r\n",_fx_,
				(bIsSendDirection)?"send":"recv"));

			//turn preview off. 
		
			// if network side is paused or closed, stop all streaming
			if(!IsComchOpen() || !IsStreamingNet())
			{	
				DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)stopping local stream\r\n",_fx_,
						(bIsSendDirection)?"send":"recv"));
				//	Stop the stream, but DO NOT UNCONFIGURE becase we want to 
				//  be able to start later
				hr = m_pMediaStream->Stop();
				if(!HR_SUCCEEDED(hr)) 
				{
					DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)Stop() returned 0x%08lx\r\n",_fx_,
						(bIsSendDirection)?"send":"recv", hr));
				}
				SHOW_OBJ_ETIME("ImpICommChan::Preview - stopped");
				LocalStreamFlagOff();
			}
			
			// else just need to turn off flag
			StandbyFlagOff();
		}
		else
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s) no change (%s)\r\n",_fx_, 
				(bIsSendDirection)?"send":"recv", "OFF"));
	}
	else
	{
		// preview on
		ASSERT(m_pCapObject);
		if(idLocalFormat == INVALID_MEDIA_FORMAT)
		{
			hr = CHAN_E_INVALID_PARAM;
			goto EXIT;
		}

		ASSERT(!(m_pMediaStream && (m_pMediaStream != pMediaStream)));

		if (m_pMediaStream == NULL)
		{
			m_pMediaStream = pMediaStream;
			m_pMediaStream->AddRef();
		}
		
		if(!IsStreamingStandby())
		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to preview ON\r\n",_fx_,
				(bIsSendDirection)?"send":"recv"));
			// turn preview on.
			if(!IsStreamingLocal())
			{
				ASSERT(!IsStreamingNet());
				if(IsComchOpen())
				{
					// if the channel is open, local streaming should only be off
					// if the network side of the channel is paused.
					//ASSERT(!IsStreamingNet());
				}
				else
				{

					// ensure that the stream does not come up with network send enabled
					// (!!!!! override default stream behavior !!!!!)
			
					BOOL bPause = TRUE;
					hr = m_pMediaStream->SetProperty( 
						(bIsSendDirection)? PROP_PAUSE_SEND:PROP_PAUSE_RECV, 
						&bPause, sizeof(bPause));
				
					// get format info for the specified format
					m_pCapObject->GetEncodeFormatDetails(idLocalFormat, &lpvFormatDetails, &uFormatSize);

					// fire up the local stream
					// this is now a two step process
					hr = m_pMediaStream->Configure((BYTE*)lpvFormatDetails, uFormatSize, 
						NULL, 0, (IUnknown*)(ImpICommChan *)this);
						
					if(!HR_SUCCEEDED(hr))
					{	
						ERRORMESSAGE(("%s: m_pMediaStream->Configure returned 0x%08lX\r\n", _fx_, hr));
						goto EXIT;
					}

					m_pMediaStream->SetNetworkInterface(NULL);
					if(!HR_SUCCEEDED(hr))
					{	
						ERRORMESSAGE(("%s: m_pMediaStream->SetNetworkInterface returned 0x%08lX\r\n", _fx_, hr));
						goto EXIT;
					}


					SHOW_OBJ_ETIME("ImpICommChan::Preview - config'd for preview");
				}
				//	Start the stream
				hr = m_pMediaStream->Start();
				if(!HR_SUCCEEDED(hr))
				{	
					ERRORMESSAGE(("%s: m_pMediaStream->Start returned 0x%08lX\r\n", _fx_, hr));
					goto EXIT;
				}	
				SHOW_OBJ_ETIME("ImpICommChan::Preview - started preview");

				LocalStreamFlagOn();
			}
			// else	// just need to set flag to make preview sticky
			StandbyFlagOn();
		}
		else
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s) no change (%s)\r\n",_fx_, 
				(bIsSendDirection)?"send":"recv", "ON"));
	}

EXIT:
	return hr;
}
STDMETHODIMP ImpICommChan::PauseNetworkStream(BOOL fPause)
{
	if(fPause)
    	LocalPauseFlagOn();
	else
		LocalPauseFlagOff();
		
	return PauseNet(fPause, FALSE);    

}

BOOL ImpICommChan::IsNetworkStreamPaused(VOID)
{
	return IsPausedLocal();
}

BOOL ImpICommChan::IsRemotePaused(VOID)
{
	return (IsStreamingRemote())? FALSE:TRUE;
}

STDMETHODIMP ImpICommChan::PauseNet(BOOL bPause, BOOL bRemoteInitiated)
{
	HRESULT hr = hrSuccess;

	FX_ENTRY("ImpICommChan::PauseNet");

    // issue notification
	if(bRemoteInitiated)
	{
	    // keep track of remote state
        if(bPause)
            RemoteStreamFlagOff();
        else
            RemoteStreamFlagOn();
            
	    if(!IsNotificationSupressed())
	    {
			if(m_pH323ConfAdvise && m_pCtlChan)
			{
        		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing %s notification \r\n",_fx_,
        		    (bPause)?"pause":"un-pause"));
				m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), 
        		    (bPause)? CHANNEL_REMOTE_PAUSE_ON: CHANNEL_REMOTE_PAUSE_OFF);		
        	}
        	else
        		DEBUGMSG(ZONE_COMMCHAN,("%s:not issuing %s notification: m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
        			,_fx_, (bPause)?"pause":"un-pause", m_pH323ConfAdvise,m_pCtlChan));
        }
    }
	if(bPause && IsStreamingNet())
	{
		ASSERT(IsComchOpen());
		// deactivate the channel  
		DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to pause\r\n",_fx_,
			(bIsSendDirection)?"send":"recv" ));

		if(!bRemoteInitiated)
		{
		    // locally initiated, so signal remote
		
			if(bIsSendDirection)
			{
				DEBUGMSG (ZONE_COMMCHAN,("%s:signaling pause of %s channel\r\n", 
	    			_fx_, (bIsSendDirection)?"send":"recv" ));
    			// signal remote
       			MiscellaneousIndication mi;
       			mi.type.choice  = logicalChannelInactive_chosen;
           		hr = m_pCtlChan->MiscChannelIndication(this, &mi); 
        		if(!HR_SUCCEEDED(hr))
        		{
                    DEBUGMSG (ZONE_COMMCHAN,("%s:(%s) CC_Mute returned 0x%08lx\r\n", 
    				    _fx_, (bIsSendDirection)?"send":"recv", hr));
    				hr = hrSuccess;  // don't care about signaling error, act normal
        		}
    
        	}
		}
		
		//
		hr = m_pMediaStream->SetProperty( 
			(bIsSendDirection)? PROP_PAUSE_SEND:PROP_PAUSE_RECV, 
			&bPause, sizeof(bPause));
				
		NetworkStreamFlagOff();
// LOOKLOOK - can't stop receive streams because they can't be restarted
// check this with GeorgeJ

//		if(!IsStreamingStandby())	// need local stream for anything?
		if(!IsStreamingStandby() && bIsSendDirection)	// need local stream for anything?

		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)stopping local stream\r\n",_fx_,
				(bIsSendDirection)?"send":"recv"));
			// can shut off local streaming now
			hr = m_pMediaStream->Stop();
			LocalStreamFlagOff();
		}
		
	}
	else if(!bPause && !IsStreamingNet())
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to unpause\r\n",_fx_,
			(bIsSendDirection)?"send":"recv"));

		if(IsComchOpen())
		{
			// activate the channel
	   		if(!bRemoteInitiated)
			{	
    		    // locally initiated, so signal remote
	    		if(bIsSendDirection)
    			{
   		    		DEBUGMSG (ZONE_COMMCHAN,("%s:signaling UNpause of %s channel\r\n", 
	    	    		_fx_, (bIsSendDirection)?"send":"recv" ));
       				// signal remote
       				MiscellaneousIndication mi;
           			mi.type.choice  = logicalChannelActive_chosen;
               		hr = m_pCtlChan->MiscChannelIndication(this, &mi); 
            		if(!HR_SUCCEEDED(hr))
            		{
                        DEBUGMSG (ZONE_COMMCHAN,("%s:(%s) CC_UnMute returned 0x%08lx\r\n", 
        				    _fx_, (bIsSendDirection)?"send":"recv", hr));
        				hr = hrSuccess;  // don't care about signaling error, act normal
            		}
            	}
			}
       		else
    		{
    		    // remotely initiated OR special case first time channel is unpaused
    		    // after opening
                AllowNotifications();   // stop supressing notifications
        	}
        	if(!IsPausedLocal())
			{					
				// MUST ensure unpaused state before starting stream ????
				hr = m_pMediaStream->SetProperty( 
					(bIsSendDirection)? PROP_PAUSE_SEND:PROP_PAUSE_RECV, 
					&bPause, sizeof(bPause));
					
				// check local streaming state, start it if needed
				if(!IsStreamingLocal())
				{
					DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)starting local stream\r\n",_fx_,
						(bIsSendDirection)?"send":"recv"));
					// need to startup stream 
					hr = m_pMediaStream->Start();
					LocalStreamFlagOn();
				}
				else
				{	
					if(bIsSendDirection)
					{
						DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)already streaming locally\r\n",_fx_,
		                    (bIsSendDirection)?"send":"recv" ));
						DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)RESTARTING local stream\r\n",_fx_,
					        (bIsSendDirection)?"send":"recv"));
						// This is temporary until it is possible to start the 
						// network side of a running stream 
			        	hr = m_pMediaStream->Stop();
						hr = m_pMediaStream->Start();
					}
				}
				NetworkStreamFlagOn();

				//
				//	if this is a receive video channel, make the sender send an I-frame now
				//
				if(!bIsSendDirection && (GetTickCount() > (m_dwLastUpdateTick + MIN_IFRAME_REQ_TICKS)))
				{
					if((MEDIA_TYPE_H323VIDEO == m_MediaID)) 
					{
						MiscellaneousCommand *pmc = (MiscellaneousCommand *) MemAlloc(sizeof(MiscellaneousCommand));

						if(NULL != pmc)
						{
    						// pmc.logicalChannelNumber = ?;  ** call control fills this in **
    						pmc->type.choice  = videoFastUpdatePicture_chosen;
    						// do the control channel signaling for THIS channel
    						hr = m_pCtlChan->MiscChannelCommand(this, pmc); 
    						MemFree(pmc);
						}
						else
						{
						    hr = E_OUTOFMEMORY;
						}
					}
					m_dwLastUpdateTick = GetTickCount();
				}
			}
		}
		else
			ERRORMESSAGE(("%s:(%s) Not open: bPause=%d, streaming=%d\r\n", _fx_,
				(bIsSendDirection)?"send":"recv", bPause, 	IsStreamingNet()));

	}
	else
	{
		ERRORMESSAGE(("%s:(%s) bPause=%d, streaming=%d\r\n", _fx_, 
			(bIsSendDirection)?"send":"recv", bPause, IsStreamingNet()));
	}
	return hr;
}

STDMETHODIMP ImpICommChan::SetProperty(DWORD prop, PVOID pBuf, UINT cbBuf)
{
	FX_ENTRY("ImpICommChan::SetProperty");
	BOOL bTemp;
	HRESULT hr = hrSuccess;
	if(!pBuf || !pBuf || !cbBuf)
		return CHAN_E_INVALID_PARAM;

	#define CHECKSIZEIN(type) if(cbBuf != sizeof(type))	return CHAN_E_INVALID_PARAM;
	#define INPROP(type) *(type *)pBuf
	#define SetMediaProperty() 	\
			if(m_pMediaStream) \
				{return m_pMediaStream->SetProperty(prop, pBuf, cbBuf);	} \
			else  hr = CHAN_E_INVALID_PARAM;
			
	switch (prop) 
	{
		// (read only) case PROP_REMOTE_FORMAT_ID:
		// (read only) case PROP_LOCAL_FORMAT_ID:
		// (read only) case PROP_REMOTE_TS_CAPABLE:
		
		case PROP_TS_TRADEOFF:
			CHECKSIZEIN(DWORD);
			if(bIsSendDirection)	// set local T/S tradeoff, then signal remote
			{
				// scale value - input is 0-31, (lower number = higher quality and lower frame rate)
				m_TemporalSpatialTradeoff = INPROP(DWORD);
				DEBUGMSG (ZONE_COMMCHAN,("%s:TS tradeoff (tx) %d\r\n", _fx_, m_TemporalSpatialTradeoff));

				// change our compression
				if (m_pMediaStream)
				{
					hr = m_pMediaStream->SetProperty(PROP_VIDEO_IMAGE_QUALITY, 
						&m_TemporalSpatialTradeoff, sizeof (m_TemporalSpatialTradeoff));
				}
				if(m_bPublicizeTSTradeoff && m_pCtlChan)	// check our own capability and if in a call
				{
					// we said we supported TS tradeoff, so we have to signal our
					// new value
					MiscellaneousIndication mi;
					// mi.logicalChannelNumber = ?;  ** call control fills this in **
					mi.type.choice  = MIn_tp_vdTmprlSptlTrdOff_chosen;
					mi.type.u.MIn_tp_vdTmprlSptlTrdOff = LOWORD(m_TemporalSpatialTradeoff);
					// do the control channel signaling for THIS channel
					hr = m_pCtlChan->MiscChannelIndication(this, &mi); 
				}
			}	
			else	// signal remote to change its T/S tradoff of its send channel
			{
				m_TemporalSpatialTradeoff = INPROP(DWORD);
				DEBUGMSG (ZONE_COMMCHAN,("%s:TS tradeoff (rx) %d\r\n", _fx_, m_TemporalSpatialTradeoff));

				if(m_bPublicizeTSTradeoff && m_pCtlChan)// check remote's TS capability
				{
					MiscellaneousCommand *pmc = (MiscellaneousCommand *) MemAlloc(sizeof(MiscellaneousCommand));

					if(NULL != pmc)
					{
    					// pmc.logicalChannelNumber = ?;  ** call control fills this in **
    					pmc->type.choice  = MCd_tp_vdTmprlSptlTrdOff_chosen;
    					pmc->type.u.MCd_tp_vdTmprlSptlTrdOff = LOWORD(m_TemporalSpatialTradeoff);
    					
    					hr = m_pCtlChan->MiscChannelCommand(this, pmc); 
    					MemFree(pmc);
					}
					else
					{
					    hr = E_OUTOFMEMORY;
					}
				}
				else	// remote said it does not support TS tradeoff
					return CHAN_E_INVALID_PARAM;
			}
		break;
		case PROP_CHANNEL_ENABLED:
			CHECKSIZEIN(BOOL);
			if(INPROP(BOOL))
			{
				m_dwFlags |= COMCH_ENABLED;
			}
			else
			{
				m_dwFlags &= ~COMCH_ENABLED;
			}
		break;
		//
		//	Media streaming properties
		//
		case PROP_LOCAL_PAUSE_RECV:
		case PROP_LOCAL_PAUSE_SEND:
            CHECKSIZEIN(BOOL);
            bTemp = INPROP(BOOL);
            if(bTemp)
                LocalPauseFlagOn();
            else
                LocalPauseFlagOff();
                
            hr = PauseNet(bTemp, FALSE);    
        break;

		case PROP_PAUSE_RECV:
		case PROP_PAUSE_SEND:
			CHECKSIZEIN(BOOL);
			hr = PauseNet(INPROP(BOOL), FALSE);
		break;
	//	case PROP_PAUSE_RECV:
	//		SetMediaProperty();
	//	break;
	
		case PROP_VIDEO_PREVIEW_ON:
			ASSERT(0);
		break;
		case PROP_VIDEO_PREVIEW_STANDBY:
			CHECKSIZEIN(BOOL);
			bTemp = INPROP(BOOL);
			if(bTemp)
				StandbyConfigFlagOn();
			else
				StandbyConfigFlagOff();
		break;
		default:
			// we don't recognize this property, pass to media control 
			if(m_pMediaStream)
			{
				return m_pMediaStream->SetProperty(prop, pBuf, cbBuf);
			}
			else
				hr = CHAN_E_INVALID_PARAM;
		break;
	}
	return hr;
}

HRESULT ImpICommChan::EnableOpen(BOOL bEnable)
{
	if(bEnable)
	{
		m_dwFlags |= COMCH_ENABLED;
	}
	else
	{
		m_dwFlags &= ~COMCH_ENABLED;
	}	
	return hrSuccess;
}

HRESULT ImpICommChan::GetLocalParams(LPVOID lpvChannelParams, UINT uBufSize)
{
	if(!lpvChannelParams || !pLocalParams || !uBufSize)
		return CHAN_E_INVALID_PARAM;
	if(uBufSize < uLocalParamSize)
		return CHAN_E_INVALID_PARAM;
	
	memcpy(lpvChannelParams, pLocalParams, uLocalParamSize);			
	return hrSuccess;
}

HRESULT ImpICommChan::ConfigureStream(MEDIA_FORMAT_ID idLocalFormat)
{
	FX_ENTRY("ImpICommChan::ConfigureStream");
	HRESULT hr;
	ASSERT(m_pRTPChan && m_pCapObject);

	LPVOID lpvFormatGoo;
	UINT uFormatGooSize;
	IUnknown *pUnknown=NULL;
	
	// get format info for Configure()
	
	if(bIsSendDirection)
	{
		m_pCapObject->GetEncodeFormatDetails(idLocalFormat, &lpvFormatGoo, &uFormatGooSize);
	}
	else
	{
		m_pCapObject->GetDecodeFormatDetails(idLocalFormat, &lpvFormatGoo, &uFormatGooSize);
	}
	
	hr = m_pMediaStream->Configure((BYTE*)lpvFormatGoo, uFormatGooSize,
	                               (BYTE*)pLocalParams, uLocalParamSize,
	                               (IUnknown*)(ImpICommChan *)this);
	if(!HR_SUCCEEDED(hr))
	{
		ERRORMESSAGE(("%s: Configure returned 0x%08lX\r\n", _fx_, hr));
	}



	// SetNetworkInterface expects an IUnknown pointer
	// the IUnknown wil be QI'd for either an IRTPSend or an IRTPRecv
	// interface.  The IUnknown should be free'd by the caller.

	if (m_pRTPChan)
	{
		m_pRTPChan->QueryInterface(IID_IUnknown, (void**)&pUnknown);
		ASSERT(pUnknown);
	}

	hr = m_pMediaStream->SetNetworkInterface(pUnknown);
	if(!HR_SUCCEEDED(hr))
	{
		ERRORMESSAGE(("%s: SetNetworkInterface returned 0x%08lX\r\n", _fx_, hr));
	}
	if (pUnknown)
	{
		pUnknown->Release();
	}

	return hr;
}
HRESULT ImpICommChan::ConfigureCapability(LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
	LPVOID lpvLocalParams, UINT uGivenLocalParamSize)
{
	HRESULT hr= hrSuccess;
	
	if(!lpvRemoteChannelParams)
		return CHAN_E_INVALID_PARAM;
	if(pRemoteParams)
	{
		MemFree(pRemoteParams);
		pRemoteParams = NULL;
	}

	// if uParamSize ==0, it means that the memory that lpvRemoteChannelParams points to
	// is being supplied
	if(uRemoteParamSize)
	{
		pRemoteParams = MemAlloc(uRemoteParamSize);
		if(pRemoteParams)
		{
			memcpy(pRemoteParams, lpvRemoteChannelParams, uRemoteParamSize);
		}
	}
	else
		pRemoteParams = lpvRemoteChannelParams;
		
	if(lpvLocalParams)
	{
		// memory for local parameters is always supplied by the caller
		if (!uGivenLocalParamSize)
		{
			 hr = CHAN_E_INVALID_PARAM;
			 goto EXIT;
		}
		if(pLocalParams)
		{	
			MemFree(pLocalParams);
			// not needed pLocalParams= NULL;
		}
	
		uLocalParamSize = uGivenLocalParamSize;
		pLocalParams = lpvLocalParams;

	}
EXIT:
	return hr;
}	

HRESULT ImpICommChan::OnChannelClose(DWORD dwStatus)
{
	HRESULT hr = hrSuccess;
	FX_ENTRY("ImpICommChan::OnChannelClose");
	BOOL fCloseAction = FALSE;

	SHOW_OBJ_ETIME("ImpICommChan::OnChannelClose");

	m_dwFlags &= ~COMCH_OPEN_PENDING;
	
	switch(dwStatus)
	{
		case CHANNEL_CLOSED:
		DEBUGMSG(ZONE_COMMCHAN,("%s:closing (%s)\r\n"
				,_fx_, (bIsSendDirection)?"send":"recv"));
			if(IsComchOpen())
			{
				fCloseAction = TRUE;
				m_dwFlags &= ~COMCH_OPEN;
			}
			else
			{
				ERRORMESSAGE(("%s: %d notification when not open (%s)\r\n", _fx_, 
					dwStatus,(bIsSendDirection)?"send":"recv"));
			}
		break;
		//case CHANNEL_REJECTED:
		//case CHANNEL_NO_CAPABILITY:
		default:
		break;
	}
	// clear general purpose channel handle 
	dwhChannel = 0;
	
// LOOKLOOK  **** RIGHT HERE ***
// ** need to notify the UI of the channel event ON_CLOSING so that the last
// frame can be grabbed for rendering (a still picture is better than a black window)
// LOOKLOOK  **** RIGHT HERE ***

	// Now check preview state
	if(IsStreamingStandby() && bIsSendDirection )
	{
		if (m_pMediaStream != NULL) 
		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:transition back to preview\r\n"	,_fx_));
			// need to stop sending and reconfigure for preview
			// make sure send is paused
			DWORD dwProp = TRUE;
			hr = m_pMediaStream->SetProperty (PROP_PAUSE_SEND,&dwProp, sizeof(dwProp));
			if(!HR_SUCCEEDED(hr))
			{	
				ERRORMESSAGE(("%s: m_pMediaStream->SetProperty returned 0x%08lX\r\n", _fx_, hr));
				// do what now? 
			}

			NetworkStreamFlagOff();
			hr = m_pMediaStream->Stop();	
			LocalStreamFlagOff();
			StandbyFlagOff();
			ASSERT(hr == S_OK);
		}
		else
		{
			NetworkStreamFlagOff();
			LocalStreamFlagOff();
		}
		
		if(fCloseAction)
		{
			// Cleanup RTP session. This is a NOP if the opposite direction is still open.
			if (m_pRTPChan) 
			{
				m_pRTPChan->Release();
				m_pRTPChan = NULL;
			}
		}
	}
	else // not previewing
	{
		//
		//	Stop the media stream
		//
		if (m_pMediaStream) 
		{
			hr = m_pMediaStream->Stop();	// probably not necessary
			ASSERT(hr == S_OK);
			// implement "capture device standby": don't unconfigure if
			// the standby flag is set and it is a send stream.  
			if(!IsConfigStandby() || !bIsSendDirection)
			{
				if(!bIsSendDirection)       // keep send stream reference until *this* object is released
				{
					m_pMediaStream->Release();    
					m_pMediaStream = NULL;
				}
			}
		}
		SHOW_OBJ_ETIME("ImpICommChan::OnChannelClose - stream stopped");

		if(fCloseAction)
		{
			// Cleanup RTP session. This is a NOP if the opposite direction is still open.
			if (m_pRTPChan) 
			{
				m_pRTPChan->Release();
				m_pRTPChan = NULL;
			}
		}
		StreamFlagsOff();
	}// end if not previewing

	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}

	return hr;
}
HRESULT ImpICommChan::OnChannelOpening()
{
	ASSERT((m_dwFlags & COMCH_OPEN_PENDING) ==0);
	m_dwFlags |= COMCH_OPEN_PENDING;
	return hrSuccess;
}

HRESULT ImpICommChan::OnChannelOpen(DWORD dwStatus)
{
	HRESULT hr;
	BOOL bConfigured = FALSE, bNewStream = FALSE;	// these bools make error cleanup cleaner
	FX_ENTRY("ImpICommChan::OnChannelOpen");

	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen");
	// the open is no longer pending, regardless of success or failure
	m_dwFlags &= ~COMCH_OPEN_PENDING;
	m_dwLastUpdateTick = 0;		// reset tick count of last I-frame request so that one 
								// will be requested
	if(IsComchOpen())
	{
		ERRORMESSAGE(("%s: %d notification when open (%s)\r\n", _fx_, 
			dwStatus, (bIsSendDirection)?"send":"recv"));
	}		
	switch(dwStatus)
	{
		case CHANNEL_OPEN:
			m_dwFlags |= (COMCH_OPEN | COMCH_SUPPRESS_NOTIFICATION);
		break;
			
		default:
			dwStatus = CHANNEL_OPEN_ERROR;
			// fall through to notification
		case CHANNEL_REJECTED:
		case CHANNEL_NO_CAPABILITY:
			goto NOTIFICATION;			
		break;
	}
	
	// The channel is open as far as call control is concerned. 	

	// if previewing, the stream already exists.  We don't want another, nor do we 
	// want to tear it down at channel close time or in error cases
	if(!m_pMediaStream)
	{
		ASSERT(!IsStreamingLocal() &&m_pH323ConfAdvise); // can't be streaming without a stream
		bNewStream = TRUE;
		// Associate the media streaming endpoint with this channel 
		// see above		
		hr = m_pH323ConfAdvise->GetMediaChannel(&m_MediaID, 
				bIsSendDirection, &m_pMediaStream);
		if(!HR_SUCCEEDED(hr))
		{	
			ERRORMESSAGE(("%s: m_pH323ConfAdvise->GetMediaChannel returned 0x%08lX\r\n", _fx_, hr));
			goto ERROR_NOTIFICATION;
		}				
				
	}
	
    if(IsStreamingLocal())
    {
		DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition:preview -> send\r\n",_fx_,
			(bIsSendDirection)?"send":"recv"));
		// need to stop stream while configuring  ( ***** check w/ RichP ******)
		hr = m_pMediaStream->Stop();
		LocalStreamFlagOff();
    }

	// notify upper layers of channel open now
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing CHANNEL_OPEN notification\r\n",_fx_));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}

   	dwStatus = CHANNEL_ACTIVE;	// new status! notification is posted below
	ASSERT(m_pRTPChan);

	// get format info for Configure()
	
	hr = ConfigureStream(m_LocalFmt);
	if(!HR_SUCCEEDED(hr))
	{
		ERRORMESSAGE(("%s: Configure returned 0x%08lX\r\n", _fx_, hr));
		goto ERROR_NOTIFICATION;
	}
	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen - configured stream");
		bConfigured = TRUE;
	// turn on flow to the network
	// SupressNotification()  // pre-initialized above in both CHANNEL_OPEN_xxx cases
	PauseNet(FALSE, TRUE);  // unpause, 
	//dwStatus = CHANNEL_ACTIVE;
	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen - unpaused");
	
NOTIFICATION:
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);	
	}
	else
		DEBUGMSG(ZONE_COMMCHAN,("%s: *** not issuing notification 0x%08lX m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
			,_fx_, dwStatus,m_pH323ConfAdvise,m_pCtlChan));
			
	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen - done ");

	return hr;	
	
ERROR_NOTIFICATION:
	dwStatus = CHANNEL_OPEN_ERROR;
	if(m_pMediaStream)
	{
		if(bNewStream)	// was the media stream just created?
		{		
			m_pMediaStream->Release();
			m_pMediaStream = NULL;
		}
	}
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}
	else
		DEBUGMSG(ZONE_COMMCHAN,("%s: *** not issuing notification 0x%08lX m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
			,_fx_, dwStatus,m_pH323ConfAdvise,m_pCtlChan));
			
	// close the channel. 
	if(m_pCtlChan)
	{
		// close channel, but hr already contains the relevant return code
		m_pCtlChan->CloseChannel(this);
	}
	
	return hr;	
}


HRESULT ImpICommChan::Open(MEDIA_FORMAT_ID idLocalFormat, IH323Endpoint *pConnection)
{
    HRESULT hr; 
    MEDIA_FORMAT_ID idRemoteFormat;
    IConfAdvise * pConfAdvise = NULL;
    if((m_dwFlags & COMCH_OPEN_PENDING) || IsComchOpen() || (idLocalFormat == INVALID_MEDIA_FORMAT) || !pConnection)
        return CHAN_E_INVALID_PARAM;

    if(!m_pCtlChan) // this channel is not part of a call 
    {
        hr = pConnection->QueryInterface(IID_IConfAdvise, (void **)&pConfAdvise);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;       
        hr = pConfAdvise->AddCommChannel(this);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;  
            
        ASSERT(m_pCtlChan && m_pCapObject);
	}
	hr = m_pCapObject->ResolveToLocalFormat(idLocalFormat, &idRemoteFormat);
	if(!HR_SUCCEEDED(hr))
            goto EXIT;  
            
	// start the control channel stuff needed to open the channel
	hr = m_pCtlChan->OpenChannel((ICtrlCommChan*)this, m_pCapObject,
		idLocalFormat, idRemoteFormat);
    
EXIT:    
    if(pConfAdvise)
        pConfAdvise->Release();
        
	return hr;
}
HRESULT ImpICommChan::Close()
{
	HRESULT hr = CHAN_E_INVALID_PARAM;
    if(!IsComchOpen() || !m_pCtlChan)
		goto EXIT;
	if(!bIsSendDirection)
		goto EXIT;
	hr = m_pCtlChan->CloseChannel(this);

EXIT:
	return hr;
}

HRESULT ImpICommChan::BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject)
{
	// this channel is now "in a call".
// LOOKLOOK - it might help to notify (ICommChannel notifications to client) 
// that the channel is part of a call now.
	ASSERT((m_pCtlChan == NULL) && pCtlChan && pCapObject);
	if(m_pCapObject)
	{
		m_pCapObject->Release();
	}
	m_pCtlChan = pCtlChan;
	m_pCapObject = pCapObject;
	m_pCapObject->AddRef();
	return hrSuccess;
}
HRESULT ImpICommChan::EndControlSession()
{
	// this channel is no longer "in a call".
	m_pCtlChan = NULL;
	return hrSuccess;
}


BOOL ImpICommChan::SelectPorts(LPIControlChannel pCtlChannel)
{
	// create the RTP channel
	HRESULT hr;
 	PSOCKADDR_IN psin=NULL;
	pCtlChannel->GetLocalAddress(&psin);

	PORT savedPort = psin->sin_port;
	if (!m_pRTPChan) {
		UINT sessFlags = bIsSendDirection ? SESSIONF_SEND : SESSIONF_RECV;
		UINT sessId;
	    GUID mediaGuid;
	    GetMediaType(&mediaGuid);
		if (mediaGuid == MEDIA_TYPE_H323VIDEO)
		{
			sessFlags |= SESSIONF_VIDEO;
			sessId = 2;
		}
		else
		{
			sessId = 1;
			sessFlags |= SESSIONF_AUDIO;
		}
		psin->sin_port = 0;		// zero port forces RTP to choose a port
		hr = g_pIRTP->OpenSession(sessId, sessFlags,
				(BYTE *)psin, sizeof(PSOCKADDR_IN),
				&m_pRTPChan);
	}
	else
		hr = m_pRTPChan->SetLocalAddress((BYTE *)psin,sizeof(SOCKADDR_IN));
	psin->sin_port = savedPort;


	return hr==S_OK;
}

// get the address and port of the base port that was selected by SelectPorts().
// in this typical implementation, that is the address/port of the RTCP channel
PSOCKADDR_IN ImpICommChan::GetLocalAddress()
{
#ifdef OLDSTUFF
	return m_pRTPChan ? m_pRTPChan->GetChannelDescription()->pLocalAddr : NULL;
#else
	const BYTE *pAddr;
	UINT cbAddr;
	HRESULT hr;
	hr = m_pRTPChan->GetLocalAddress(&pAddr, &cbAddr);
	return (SUCCEEDED(hr)) ? (PSOCKADDR_IN) pAddr : NULL;
#endif
}

STDMETHODIMP ImpICommChan::GetRemoteAddress(PSOCKADDR_IN pAddrOutput)
{
	HRESULT hr;
	if (!pAddrOutput)
	{
		return CHAN_E_INVALID_PARAM;
	}
	const BYTE *pAddr;
	UINT cbAddr;
	hr = m_pRTPChan->GetRemoteRTPAddress(&pAddr, &cbAddr);
	if(SUCCEEDED(hr))
	{
		ASSERT(cbAddr == sizeof(SOCKADDR_IN));
		*pAddrOutput = *((PSOCKADDR_IN) pAddr);
	}
	return hrSuccess;
}

UINT ImpICommChan::Reset()
{
	UINT uret;
	ASSERT(!IsComchOpen());
	if (m_pRTPChan) {
		uret = m_pRTPChan->Release();
		m_pRTPChan = NULL;
	} else
		uret = 0;
	return uret;
}
	
PORT ImpICommChan::GetLocalRTPPort()
{
#ifdef OLDSTUFF

	return (m_pRTPChan ? ntohs(m_pRTPChan->GetChannelDescription()->pLocalAddr->sin_port) : 0);
#else
	const BYTE *pAddr;
	UINT cbAddr;
	HRESULT hr;
	hr = m_pRTPChan->GetLocalAddress(&pAddr, &cbAddr);
	return (SUCCEEDED(hr)) ? ntohs(((PSOCKADDR_IN) pAddr)->sin_port) : 0;
#endif
}

PORT ImpICommChan::GetLocalRTCPPort()
{
#ifdef OLDSTUFF
	return (m_pRTPChan ? ntohs(m_pRTPChan->GetChannelDescription()->pLocalRTCPAddr->sin_port) : 0);
#else
	const BYTE *pAddr;
	UINT cbAddr;
	HRESULT hr;
	hr = m_pRTPChan->GetLocalAddress(&pAddr, &cbAddr);
	return (SUCCEEDED(hr)) ? ntohs(((PSOCKADDR_IN) pAddr)->sin_port)+1 : 0;
#endif
}

HRESULT ImpICommChan::AcceptRemoteRTCPAddress(PSOCKADDR_IN pSinC)
{
	HRESULT hr;
#ifdef OLDSTUFF
    if (!m_pRTPChan) {
    	RTPCHANNELDESC chanDesc = {0};
    	GetMediaType(&chanDesc.mediaId);
    	chanDesc.pRemoteRTCPAddr = pSinC;
    	hr = CreateRTPChannel(&chanDesc, &m_pRTPChan);
	} else
		hr = m_pRTPChan->SetRemoteAddresses(NULL,pSinC);
#else
	hr = m_pRTPChan->SetRemoteRTCPAddress((BYTE *)pSinC, sizeof(SOCKADDR_IN));
#endif
	return hr;
}

HRESULT ImpICommChan::AcceptRemoteAddress(PSOCKADDR_IN pSinD)
{
    HRESULT hr;
	hr = m_pRTPChan->SetRemoteRTPAddress((BYTE *)pSinD, sizeof(SOCKADDR_IN));
	return hr;
}

HRESULT ImpICommChan::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	if (!pH323ConfAdvise)
	{
		return CHAN_E_INVALID_PARAM;
	}
	m_pH323ConfAdvise = pH323ConfAdvise;	
	return hrSuccess;
}
STDMETHODIMP ImpICommChan::PictureUpdateRequest()
{
	FX_ENTRY ("ImpICommChan::PictureUpdateRequest");
	HRESULT hr;
	if (!m_pCtlChan)
	{
		return CHAN_E_NOT_OPEN;
	}
	if(bIsSendDirection || (MEDIA_TYPE_H323VIDEO != m_MediaID))
	{
		return CHAN_E_INVALID_PARAM;
	}
	
	// issue miscellaneous command for picture update
	MiscellaneousCommand *pmc = (MiscellaneousCommand *) MemAlloc(sizeof(MiscellaneousCommand));

	if(NULL != pmc)
	{
    	// pmc.logicalChannelNumber = ?;  ** call control fills this in **
    	pmc->type.choice  = videoFastUpdatePicture_chosen;
    	// do the control channel signaling for THIS channel
    	hr = m_pCtlChan->MiscChannelCommand(this, pmc); 

    	// record the tick count of this command
    	m_dwLastUpdateTick = GetTickCount();
    	
    	MemFree(pmc);
    	pmc = NULL;
	}
	else
	{
	    hr = E_OUTOFMEMORY;
	}
	
	return hr;
}

STDMETHODIMP ImpICommChan::GetVersionInfo( 
        PCC_VENDORINFO *ppLocalVendorInfo, 
        PCC_VENDORINFO *ppRemoteVendorInfo)
{
	FX_ENTRY ("ImpICommChan::GetVersionInfo");
	if (!m_pCtlChan)
	{
		return CHAN_E_INVALID_PARAM;
	}
	return m_pCtlChan->GetVersionInfo(ppLocalVendorInfo, ppRemoteVendorInfo);
}

ImpICommChan::ImpICommChan ()
:pRemoteParams(NULL),
m_pMediaStream(NULL),
pLocalParams(NULL),
uLocalParamSize(0),
m_pCtlChan(NULL),
m_pH323ConfAdvise(NULL),
m_pCapObject(NULL),
m_dwFlags(0),
dwhChannel(0),
m_LocalFmt(INVALID_MEDIA_FORMAT),
m_RemoteFmt(INVALID_MEDIA_FORMAT),
m_TemporalSpatialTradeoff(0),	// default to highest resolution
m_bPublicizeTSTradeoff(FALSE),
m_uRef(1)
{
	ZeroMemory(&m_MediaID, sizeof(m_MediaID));
}


ImpICommChan::~ImpICommChan ()
{
	if(pRemoteParams)
		MemFree(pRemoteParams);
	if(pLocalParams)
		MemFree(pLocalParams);
    if(m_pMediaStream)
	{
	    m_pMediaStream->Stop();	// probably not necessary
		m_pMediaStream->Release();
		m_pMediaStream = NULL;
	}
	if(m_pCapObject)
		m_pCapObject->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\ccerror.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/ccerror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   16 Dec 1996 18:59:34  $
 *      $Author:   EHOWARDX  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCERROR_H
#define CCERROR_H

#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

// Status codes
#define CC_OK							NOERROR
#define CC_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_OUTOFMEMORY)
#define CC_PEER_REJECT					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 1)
#define CC_BAD_PARAM					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 2)
#define CC_BAD_SIZE						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 3)
#define CC_ACTIVE_CONNECTIONS			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 4)
#define CC_INTERNAL_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 5)
#define CC_NOT_IMPLEMENTED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 6)
#define CC_DUPLICATE_CONFERENCE_ID		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 7)
#define CC_ILLEGAL_IN_MULTIPOINT		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 8)
#define CC_NOT_MULTIPOINT_CAPABLE		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 9)
#define CC_PEER_CANCEL					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 10)
#define CC_GKI_STATE                    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 21)
#define CC_GKI_CALL_STATE               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 22)
#define CC_GKI_LISTEN_NOT_FOUND         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 23)
#define CC_GATEKEEPER_REFUSED           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 24)
#define CC_INVALID_WITHOUT_GATEKEEPER   MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 25)
#define CC_GKI_IP_ADDRESS               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 26)
#define CC_GKI_LOAD                     MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 27)


#ifdef __cplusplus
}
#endif

#endif CCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\plog.cpp ===
#include "precomp.h"

#ifdef PLS_DEBUG
#include "plog.h"



CCallLog::CCallLog(int size)
{
	m_bValid = false;

    DBG_SAVE_FILE_LINE
	m_pLogEntry = new CPacketLogEntry[size];
	if (m_pLogEntry == NULL)
	{
		WARNING_OUT(("CCallLog:Out of memory"));
		return;
	}

	m_currentIndex = 0;
	m_size = size;
	m_bValid = true;
}

CCallLog::~CCallLog()
{
	if (m_bValid)
	{
		delete [] m_pLogEntry;
	}
}



bool CCallLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	CPacketLogEntry Entry;

	if (m_bValid == false) return false;

	Entry.dwTimeStamp = dwTimeStamp;
	Entry.dwSequenceNumber = dwSeqNum;
	Entry.LL_ArrivalTime = LL_ArrivalTime;
	Entry.dwSize = dwSize;
	Entry.dwLosses = 0;
	Entry.bLate = false;
	Entry.bMark = fMark;

	if (SizeCheck() == false)
		return false;

	m_pLogEntry[m_currentIndex++] = Entry;
	return true;

}

bool CCallLog::SizeCheck()
{
	if (m_bValid == false)
		return false;

	if (m_currentIndex < m_size)
		return true;
	return false;
}


bool CCallLog::Flush(HANDLE hFile)
{
	int index;
	CPacketLogEntry *pEntry;
	char szOutputLine[80];
	DWORD dwNumWritten;
   __int64 ArrivalTime64;
	__int64 PerfFreq64;
	LARGE_INTEGER LL_PerfFreq;
	
	if (m_bValid == false)
		return false;

	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	PerformStats();

	// what's the performance frequency of this machine
	QueryPerformanceFrequency(&LL_PerfFreq);
	PerfFreq64 = LL_PerfFreq.QuadPart;

	for (index = 0; index < m_currentIndex; index++)
	{
		pEntry = &m_pLogEntry[index];

		ArrivalTime64 = pEntry->LL_ArrivalTime.QuadPart * 1000;
		ArrivalTime64 = ArrivalTime64 / PerfFreq64;

		sprintf(szOutputLine, "%d\t%d\t%d\t%d\t%d",
		        pEntry->dwTimeStamp,
		        pEntry->dwSequenceNumber,
		        (int)ArrivalTime64,
		        pEntry->dwSize,
		        pEntry->dwLosses);
		
		if (pEntry->bMark)
			strcat(szOutputLine, "\tMARK");
		else strcat(szOutputLine, "\t");

		if (pEntry->bLate)
			strcat(szOutputLine, "\tLATE");
		
		strcat(szOutputLine, "\n");

		WriteFile(hFile, szOutputLine, strlen(szOutputLine), &dwNumWritten, NULL);

	}
	return true;
}


CCallLog& CCallLog::operator=(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Assignment not supported"));
	return *this;
}

CCallLog::CCallLog(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Copy constructor not supported"));
	return;
}

bool CCallLog::PerformStats()
{
	int index, probeIndex;
	DWORD nextExpected;
	bool bFound;

	if (m_bValid == false)
		return false;

	if (m_currentIndex == 0)
		return false;

	// Set the current "loss" value for each entry to 0
	for (index = 0; index < m_currentIndex; index++)
	{
		m_pLogEntry[index].dwLosses = 0;
		m_pLogEntry[index].bLate = false;
	}

	// the first packet will always be a match with nextExpected
	nextExpected = m_pLogEntry[0].dwSequenceNumber;

	for (index = 0; index < m_currentIndex; index++)
	{
		if (nextExpected > 65535)
			nextExpected = 0;
		// if the packet has the next expected seq num, then everything is ok
		if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
		{
			nextExpected++;
			continue;
		}

		// we've detected a missing packet... time to go hunting
		else if (m_pLogEntry[index].dwSequenceNumber > nextExpected)
		{
			bFound = false;
			probeIndex = index+1;
			while ((probeIndex < m_currentIndex) &&
			       (probeIndex < (index+PLOG_MAX_NOT_LATE)) )
			{
				if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
					bFound = true;
				probeIndex++;
			}

			// the packet was merely out of sequence
			if (bFound == true)
			{
				nextExpected++;
				continue;
			}

			// the packet is probably lost
			// notice that we are simply incrementing dwLoss measure,
			// rolling the index back one
			m_pLogEntry[index].dwLosses++;
			nextExpected++;
			index--; // this is so we can continue to count additional
			         // loss packets for the same index
			continue; // back to the top of the for-loop
		}

		// a packet that was either previously thought of as lost or late
		else
		{
			m_pLogEntry[index].bLate = true;	
		}


	}


	return true;
}


// --------------------------------------------------------------

CPacketLog::CPacketLog(LPTSTR szDiskFile):
	m_hFile(INVALID_HANDLE_VALUE),
	m_nExtension(0)
{
	m_pCallLog = NULL;
	strcpy(m_szDiskFile, szDiskFile);
}


// initializes an output file.  Closes the current file if still open
bool CPacketLog::InitFile()
{
	char szFileName[120];

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
	m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);

	while ((m_hFile != INVALID_HANDLE_VALUE) && (m_nExtension < 100))
	{
		CloseHandle(m_hFile);
		sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
		m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);
		m_nExtension++;
	}
			

	m_hFile = CreateFile(szFileName,
	                     GENERIC_READ|GENERIC_WRITE, 
	                     FILE_SHARE_READ,
	                     NULL,
	                     CREATE_ALWAYS,
	                     FILE_ATTRIBUTE_NORMAL,
	                     NULL);
	                     
	                     
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		WARNING_OUT(("CPacketLog:Unable to initialize output file"));
		return false;
	}

	return true;

}


CPacketLog::CPacketLog(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via a copy constructor"));
	return;
}



CPacketLog& CPacketLog::operator=(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via the assignment operator"));
	return *this;	
}


CPacketLog::~CPacketLog()
{
	if (m_pCallLog != NULL)
	{
		Flush();
		delete (m_pCallLog);
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);

}


bool CPacketLog::Flush()
{
	char *szCallHeader = "CALLSTART\n";
	DWORD dwNumWritten;

	if (m_pCallLog == NULL)
		return false;

	WriteFile(m_hFile, szCallHeader, strlen(szCallHeader), &dwNumWritten, NULL);
	m_pCallLog->Flush(m_hFile);		

	return true;
}



bool CPacketLog::MarkCallStart()
{
	// write the previous call to file
	if (m_pCallLog != NULL)
	{
		Flush();
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		delete m_pCallLog;
	}

	if (false == InitFile())
	{
		return false;
	}

    DBG_SAVE_FILE_LINE
	m_pCallLog = new CCallLog(PLOG_MAX_PACKETS_CALL);
	if (m_pCallLog == NULL)
		return false;

	return true;
}


bool CPacketLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	if (m_pCallLog == NULL)
	{
		if (false == MarkCallStart())
			return false;
	}

	return (m_pCallLog->AddEntry(dwTimeStamp, dwSeqNum, LL_ArrivalTime, dwSize, fMark));

}


// if-def pls_debug
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\plog.h ===
#ifndef PLOG_H
#define PLOG_H

#define PLOG_MAX_CALLS	20
#define PLOG_MAX_PACKETS_CALL 20000
#define PLOG_FILE_AUDIO "C:\\AuPacketLog"
#define PLOG_FILE_VIDEO "C:\\VidPacketLog"
#define PLOG_FILE_EXT    ".txt"

// number of packets until the missing packet
// is declared "lost" instead of late
#define PLOG_MAX_NOT_LATE	20

struct CPacketLogEntry
{
	DWORD dwSequenceNumber;
	DWORD dwTimeStamp;
	LARGE_INTEGER LL_ArrivalTime;
	DWORD dwSize;
	DWORD dwLosses;
	bool bLate;  // is the packet late ?
	bool bMark;  // is the M bit set in the RTP packet
};


class CCallLog
{
private:
	CPacketLogEntry *m_pLogEntry;
	int m_size;  // max num of entries this list can hold
	int m_currentIndex;
	bool m_bValid;
public:
	CCallLog(int size=PLOG_MAX_PACKETS_CALL);
	~CCallLog();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 
	bool Flush(HANDLE hFile);
	bool SizeCheck();

	CCallLog& operator=(const CCallLog&);
	CCallLog(const CCallLog&);

	bool PerformStats();
};



// PacketLog maintains a list of CPacketLogEntry's
class CPacketLog
{
private:
	HANDLE m_hFile;         // handle to disk file where logs are kept
	CCallLog *m_pCallLog;   // pointer to CCallLog instance
	char m_szDiskFile[80];  // base name of the disk file
	int m_nExtension;	// current file extension index number

	bool InitFile();

public :
	CPacketLog(LPTSTR szDiskFile);
	CPacketLog(const CPacketLog&);

	CPacketLog& operator=(const CPacketLog&);

	~CPacketLog();
	bool Flush();

	bool MarkCallStart();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\t120chan.cpp ===
/*
 *  	File: t120chan.cpp
 *
 *		T.120 implementation of ICommChannel, ICtrlCommChannel 
 *
 *		Revision History:
 *
 *		06/11/97	mikev	created
 *					
 */


#include "precomp.h"

ImpT120Chan::ImpT120Chan()
:m_MediaID(MEDIA_TYPE_H323_T120),
m_pCtlChan(NULL),
m_pCapObject(NULL),
m_pH323ConfAdvise(NULL),
m_dwFlags(COMCH_ENABLED),
dwhChannel(0), 
uRef(1)
{
	ZeroMemory(&local_sin, sizeof(local_sin));
	ZeroMemory(&remote_sin, sizeof(remote_sin));
}

ImpT120Chan::~ImpT120Chan ()
{
}

STDMETHODIMP ImpT120Chan::GetMediaType(LPGUID pGuid)
{
	if(!pGuid)
		return CHAN_E_INVALID_PARAM;
	*pGuid = m_MediaID;
	return hrSuccess;
}

STDMETHODIMP ImpT120Chan::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM 
	// interfaces.  The reflexive property of QueryInterface would be broken in 
	// that case.
	
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IUnknown) 
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICommChannel))
	{
		*ppvObject = (ICommChannel *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICtrlCommChannel))
	{
		*ppvObject = (ICtrlCommChan *)this;
		hr = hrSuccess;
		AddRef();
	}
	return (hr);
}

ULONG ImpT120Chan::AddRef()
{
	uRef++;
	return uRef;
}

ULONG ImpT120Chan::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	else
	{
		return uRef;
	}
}

HRESULT ImpT120Chan::BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject)
{
	// this channel is now "in a call".
	m_pCtlChan = pCtlChan;
	m_pCapObject = pCapObject;
	return hrSuccess;
}
HRESULT ImpT120Chan::EndControlSession()
{
	// this channel is no longer "in a call".
	m_pCtlChan = NULL;
	m_pCapObject = NULL;
	return hrSuccess;
}

HRESULT ImpT120Chan::OnChannelClose(DWORD dwStatus)
{
	HRESULT hr = hrSuccess;
	FX_ENTRY("ImpT120Chan::OnChannelClose");
	BOOL fCloseAction = FALSE;

	SHOW_OBJ_ETIME("ImpT120Chan::OnChannelClose");

	m_dwFlags &= ~COMCH_OPEN_PENDING;
	
	switch(dwStatus)
	{
		default:
			ERRORMESSAGE(("%s: unexpected unidirectional notification\r\n", _fx_)); 
		case CHANNEL_CLOSED:
			DEBUGMSG(ZONE_COMMCHAN,("%s:closing\r\n",_fx_));
			if(IsComchOpen())
			{
				fCloseAction = TRUE;
				m_dwFlags &= ~COMCH_OPEN;
			}
			else
			{
				ERRORMESSAGE(("%s: notification when not open\r\n", _fx_)); 
			}
		break;
	}
	// clear general purpose channel handle 
	dwhChannel = 0;
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}

	return hr;
}
HRESULT ImpT120Chan::OnChannelOpening()
{
	m_dwFlags |= COMCH_OPEN_PENDING;
	return hrSuccess;
}

HRESULT ImpT120Chan::OnChannelOpen(DWORD dwStatus)
{
	FX_ENTRY("ImpT120Chan::OnChannelOpen");

	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen");
	// the open is no longer pending, regardless of success or failure
	m_dwFlags &= ~COMCH_OPEN_PENDING;

	if(IsComchOpen())
	{
		ERRORMESSAGE(("%s: %d notification when open\r\n", _fx_, 
					dwStatus));
	}		
	switch(dwStatus)
	{
		case CHANNEL_OPEN:
			m_dwFlags |= (COMCH_OPEN | COMCH_SUPPRESS_NOTIFICATION);
		break;
			
		default:
			dwStatus = CHANNEL_OPEN_ERROR;
			// fall through to notification
		case CHANNEL_REJECTED:
		case CHANNEL_NO_CAPABILITY:
			goto NOTIFICATION;			
		break;
	}
	
NOTIFICATION:
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}
	else
		DEBUGMSG(ZONE_COMMCHAN,("%s: *** not issuing notification 0x%08lX m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
			,_fx_, dwStatus,m_pH323ConfAdvise,m_pCtlChan));
			
	SHOW_OBJ_ETIME("ImpT120Chan::OnChannelOpen - done ");
	return hrSuccess;	

}

BOOL ImpT120Chan::SelectPorts(LPIControlChannel pCtlChannel)
{
	PSOCKADDR_IN psin;
	HRESULT hr;
	hr = pCtlChannel->GetLocalAddress(&psin);
	{
		if(!HR_SUCCEEDED(hr))
			return FALSE;
	}
	local_sin = *psin;
// HACK uses well known port
	local_sin.sin_port = htons(1503);
	return TRUE;
}

HRESULT ImpT120Chan::AcceptRemoteAddress (PSOCKADDR_IN pSin)
{
	if(!pSin)
		return CHAN_E_INVALID_PARAM;
	remote_sin = *pSin;	
	return hrSuccess;
}


STDMETHODIMP ImpT120Chan::GetRemoteAddress(PSOCKADDR_IN pAddrOutput)
{
	if (!pAddrOutput)
	{
		return CHAN_E_INVALID_PARAM;
	}
	*pAddrOutput = remote_sin;
	return hrSuccess;
}

HRESULT ImpT120Chan::EnableOpen(BOOL bEnable)
{
	if(bEnable)
	{
		m_dwFlags |= COMCH_ENABLED;
	}
	else
	{
		m_dwFlags &= ~COMCH_ENABLED;
	}	
	return hrSuccess;
}

HRESULT ImpT120Chan::IsChannelOpen(BOOL *pbOpen)
{
	if(!pbOpen)
		return CHAN_E_INVALID_PARAM;
	*pbOpen = (IsComchOpen()) ? TRUE:FALSE;
	return hrSuccess;	
}

HRESULT ImpT120Chan::Open(MEDIA_FORMAT_ID idLocalFormat, IH323Endpoint *pConnection)
{
    HRESULT hr; 
    IConfAdvise * pConfAdvise = NULL;
    if((m_dwFlags & COMCH_OPEN_PENDING) || IsComchOpen() || !pConnection)
        return CHAN_E_INVALID_PARAM;

    if(!m_pCtlChan) // this channel is not part of a call 
    {
        hr = pConnection->QueryInterface(IID_IConfAdvise, (void **)&pConfAdvise);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;       
        hr = pConfAdvise->AddCommChannel(this);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;  
            
        ASSERT(m_pCtlChan && m_pCapObject);
	}
            
	// Start the control channel stuff needed to open the channel.
	// The media format ID arguments are irrelevant for T.120 channels
	hr = m_pCtlChan->OpenChannel((ICtrlCommChan*)this, m_pCapObject,
		idLocalFormat, INVALID_MEDIA_FORMAT);
    
EXIT:    
    if(pConfAdvise)
        pConfAdvise->Release();
        
	return hr;
}

HRESULT ImpT120Chan::Close()
{
	HRESULT hr = CHAN_E_INVALID_PARAM;
    if(!IsComchOpen() || !m_pCtlChan)
		goto EXIT;

	hr = m_pCtlChan->CloseChannel((ICtrlCommChan*)this);

EXIT:
	return hr;
}

HRESULT ImpT120Chan::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	if (!pH323ConfAdvise)
	{
		return CHAN_E_INVALID_PARAM;
	}
	m_pH323ConfAdvise = pH323ConfAdvise;	
	return hrSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\precomp.h ===
/* precomp.h for H323CC.DLL */


#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <winsock2.h>

// NetMeeting standard includes
#include <oprahcom.h>
#include <confdbg.h>
#include <avutil.h>
#include <oblist.h>
#include <regentry.h>

#include <limits.h>
#include "debug.h"
#include "nacguids.h"
#include "mperror.h"
#include "common.h"
#include "vidinout.h"
#include "irtp.h"
#include "iacapapi.h"
#include "capflags.h"
#include "ih323cc.h"
#include "iconnect.h"
#include "icomchan.h"
#include "incommon.h"
#include "callcont.h"
#include "h245api.h"
#include "intif.h"
#include "imstream.h"
#include "commchan.h"
#include "t120chan.h"
#include "codecs.h"
#include "mediacap.h"
#include "capif.h"
#include "ictlchan.h"
#include "cmember.h"
#include "nmqos.h"
#include "h323cc.h"
#include "connobj.h"
#include "auformats.h"
#include "intelcc.h"
#include "iprop.h"
#include "ividrdr.h"
#include "avcommon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\av_asn1.h ===
#ifndef _MS_AV_ASN1_H_
#define _MS_AV_ASN1_H_

#include "nmasn1.h"

#ifdef __cplusplus
extern "C" {
#endif

// lonchanc: copied from ossdll.h
#define DLL_ENTRY       WINAPI
#define DLL_ENTRY_FDEF  WINAPI
#define DLL_ENTRY_FPTR  WINAPI


extern ASN1module_t     Q931ASN_Module;

#define q931asn         Q931ASN_Module
#define ObjectID_       ASN1objectidentifier_s

typedef ASN1bool_t      ASN1_BOOL;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}
    ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}
    ASN1_BUF;

int Q931_InitModule(void);
int Q931_TermModule(void);
int Q931_InitWorld(ASN1_CODER_INFO *pWorld);
int Q931_TermWorld(ASN1_CODER_INFO *pWorld);
int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize);
int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize);

int H245_InitModule(void);
int H245_TermModule(void);
int H245_InitWorld(ASN1_CODER_INFO *pWorld);
int H245_TermWorld(ASN1_CODER_INFO *pWorld);
int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);




__inline int freePDU(ASN1_CODER_INFO *pWorld, int nPDU, void *pDecoded, ASN1module_t pModule)
{
    return pModule->decfree(pWorld->pDecInfo, pDecoded, nPDU);
}


#ifdef __cplusplus
}
#endif

#endif // _MS_AV_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\gkerror.h ===
/***********************************************************************
 *																		*
 *	INTEL CORPORATION PROPRIETARY INFORMATION							*
 *																		*
 *	This software is supplied under the terms of a license			   	*
 *	agreement or non-disclosure agreement with Intel Corporation		*
 *	and may not be copied or disclosed except in accordance	   			*
 *	with the terms of that agreement.									*
 *																		*
 *	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
 *																		*
 *	$Archive:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 *
 *	$Revision:   1.18  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 * 
 *    Rev 1.18   16 Jan 1997 15:25:06   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.17   19 Dec 1996 18:46:44   BPOLING
 * added error code for no call signal address left in a user.
 * 
 *    Rev 1.16   18 Dec 1996 21:48:16   AKLEMENT
 * Fixed an error code for GWInfo.cpp
 * 
 *    Rev 1.14   18 Dec 1996 17:02:58   AKLEMENT
 * Added more GKInfo error codes.
 * 
 *    Rev 1.13   17 Dec 1996 19:20:02   AKLEMENT
 * Added GWInfo error codes.
 * 
 *    Rev 1.12   11 Dec 1996 13:32:44   AKLEMENT
 * Fixed the Prop Info header.
 * 
 *    Rev 1.11   10 Dec 1996 15:55:02   AKLEMENT
 * Added Resource Reading error define.
 * 
 *    Rev 1.10   10 Dec 1996 01:23:58   BPOLING
 * added a new error code for sending RRJ Undefined Reason.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:34   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   04 Dec 1996 10:43:18   BPOLING
 * added a new message id to post to h/i.
 * 
 *    Rev 1.7   04 Dec 1996 10:14:46   BPOLING
 * added error code for invalid ip address
 * 
 *    Rev 1.6   21 Nov 1996 13:06:18   BPOLING
 * added error code for HI PostMessage decoding.
 * 
 *    Rev 1.5   15 Nov 1996 14:38:18   BPOLING
 * vcs log fix.
 *                                                                     * 
 ***********************************************************************/

#ifndef GK_ERROR_H
#define GK_ERROR_H

#define GK_NOERROR					0

// WIN32 system error 000

#define GK_MEMORY_ERROR				1
#define GK_REGCREATEKEY_FAILED 		2
#define GK_GUID_ERROR				3
#define GK_EXCEPTION				4
#define GK_RESOURCE_ERROR			5

// Service related 100

#define GK_INVALID_ARG 				101
#define GK_NOARGS					102
#define GK_STARTSERVICE_FAILED		103
#define GK_EXIT						104

// User Class Errors 200

#define GK_USER_NOTINITIALIZED		201
#define GK_NOUSERFOUND				202
#define GK_EMPTYSEQUENCE			203
#define GK_TRANSPORTNOTFOUND		204
#define GK_ALIASNOTFOUND			205
#define GK_NO_CALLSIG				206

// Engine related Errors 300

#define GK_XRSRESPONSE				301
#define GK_NORESPONSE				303
#define GK_INVALIDMESSAGE			304
#define GK_SENDRRJ_NEEDGRQ			305
#define GK_XRSMESSAGERECEIVED		306
#define GK_NSMMESSAGERECEIVED		307
#define GK_BADENDPOINTID			308
#define GK_SENDGRJ_TERMEX			309
#define GK_SENDRRJ_UNDEFINED		310

// Ras Map related errors 400

#define GK_NORASFOUND		  	401
#define GK_RASFOUND				402
#define GK_DUPLICATERAS			403
#define GK_RAS_NOTINITIALIZED	404
#define GK_RAS_NOT_UNIQUE		405

// Sockets related errors 500

#define GK_NOPORT					501
#define GK_NOHOSTNAME				502
#define GK_UNSUPPORTEDPROTOCOL		503
#define GK_PROTOCOLNOTFOUND			504
#define GK_INVALIDPDUTYPE			505
#define GK_SOCKETSERROR				506
#define GK_RESPONSE					507
#define GK_INVALID_IPADDRESS		508

// Bound Map related errors 600

#define GK_NOBOUNDFOUND				601
#define GK_BOUNDFOUND				602
#define GK_DUPLICATEBOUND			603
#define GK_BOUND_NOTINITIALIZED		604
#define GK_BOUNDLOCKED				607
#define GK_BOUNDNOTLOCKED			608

// CONF Map related errors 700

#define GK_NOCONFFOUND				701
#define GK_CONFFOUND				702
#define GK_DUPLICATECONF			703
#define GK_CONF_NOTINITIALIZED		704
#define GK_NOT_IN_CONF				706
#define GK_INVALID_REQUEST			707
#define GK_CONFDELETE				708
#define GK_CONFCREATEFAILED			709


// PDU Error return codes 800

#define GK_ARJ_REQUEST_DENIED		800
#define GK_ARJ_UNDEFINED_REASON		801

// Alias CMap Errors 900

#define GK_ALIAS_NOTINITIALIZED		900
#define GK_ALIAS_NOT_UNIQUE			901
#define GK_ALIASFOUND				902
#define GK_NOALIASFOUND				903

// Guid Map related errors 1000

#define GK_NOGUIDFOUND				1001
#define GK_GUIDFOUND				1002
#define GK_DUPLICATEGUID			1003
#define GK_GUIDINUSE				1004
#define GK_GUID_NOTINITIALIZED		1005

// Call Sig CMap Errors 1100

#define GK_CALLSIG_NOTINITIALIZED		1100
#define GK_CALLSIG_NOT_UNIQUE			1101
#define GK_CALLSIGFOUND					1102
#define GK_NOCALLSIGFOUND				1103

// Call Errors 1200

#define GK_NOCALLFOUND					1200
#define GK_DIDNOTPURGE					1201
#define GK_CALL_NOTINITIALIZED			1202
#define GK_CALL_CREATE					1203
#define GK_CALL_DELETE					1204
#define GK_CALL_CHANGE					1205
#define GK_CALL_TIMER					1206

// Bandwidth Manager Errors 1300

#define GK_INVALID_BANDWIDTH			1300
#define GK_EXTERNAL_EXCEEDS_INTERNAL	1301
#define GK_NO_AVAILABLE_BANDWIDTH		1302
#define GK_USEDBW_WENT_NEGATIVE			1303
#define GK_LESS_AVAILABLE_BANDWIDTH		1304

// Logger Errors 1400

#define GK_LOGGING_IS_OFF				1400
#define GK_FILE_NOT_OPEN				1401
#define GK_COULD_NOT_OPEN_FILE			1402
#define GK_FILE_ALREADY_OPEN			1403
#define GK_NAME_USED_FOR_LOG			1404
#define GK_COULD_NOT_MAKE_DIR			1405

// GWInfo Errors 1500
#define GK_WRONG_PDU					1500
#define GK_NOT_GATEWAY					1501
#define GK_PROTOCOL_NOT_PRESENT			1502
#define GK_GW_NOT_FOUND					1503
#define GK_GW_NOT_REQUIRED				1504
#define GK_PREFIX_RESERVED				1505
#define GK_NO_DEST_INFO_SPECIFIED		1506

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\h323\t120chan.h ===
/*
 *  	File: t120chan.h
 *
 *      T.120 implementation of media channel.
 *      Interfaces:  ICommChannel, ICtrlCommChan
 *
 *		Revision History:
 *
 *		06/11/97	mikev	created
 */


#ifndef _T120CHAN_H
#define _T120CHAN_H

class ImpT120Chan : public ICommChannel, public ICtrlCommChan
{
	
protected:
	SOCKADDR_IN local_sin;
	SOCKADDR_IN remote_sin;	
	
	UINT uRef;
	GUID m_MediaID;
	IControlChannel *m_pCtlChan;
	LPIH323PubCap   m_pCapObject;
    IH323ConfAdvise *m_pH323ConfAdvise;
	DWORD   m_dwFlags;
	DWORD_PTR dwhChannel; //General purpose handle.  Whatever
	// creates an instance of this class can use this for whatever it wants
	
public:
	ImpT120Chan ();
	~ImpT120Chan ();
	
// ICtrlCommChannel methods
  	STDMETHODIMP_(IControlChannel *) GetControlChannel(VOID) {return m_pCtlChan;};
    STDMETHODIMP StandbyInit(LPGUID lpMID, LPIH323PubCap pCapObject,
	    IMediaChannel* pMediaStreamSend)
	    {
	        return hrSuccess;
	    };
	STDMETHODIMP_(BOOL) Init(LPGUID lpMID, IH323ConfAdvise *pH323ConfAdvise,
	    BOOL fSendDirection)
	    {
        	m_MediaID = *lpMID;
    		m_pH323ConfAdvise = pH323ConfAdvise;
	        return TRUE;
	    };
	
    STDMETHODIMP GetMediaType(LPGUID pGuid);
    STDMETHODIMP CtrlChanSetProperty(DWORD prop, PVOID pBuf, DWORD cbBuf){return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP PauseNet(BOOL bPause, BOOL bRemote)  {return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject);
	STDMETHODIMP EndControlSession();
	STDMETHODIMP OnChannelOpening();
	STDMETHODIMP OnChannelOpen(DWORD dwStatus);
	STDMETHODIMP OnChannelClose(DWORD dwStatus);
  	STDMETHODIMP_(UINT) Reset(VOID) {return 0;};
   	
	STDMETHODIMP_(BOOL) SelectPorts(LPIControlChannel pCtlChannel);
	STDMETHODIMP_(PSOCKADDR_IN) GetLocalAddress(){return &local_sin;};
	
	STDMETHODIMP_(PORT) GetLocalRTPPort() {return 0;};
	STDMETHODIMP_(PORT) GetLocalRTCPPort() {return 0;};
	STDMETHODIMP AcceptRemoteAddress (PSOCKADDR_IN pSinD);
	STDMETHODIMP AcceptRemoteRTCPAddress(PSOCKADDR_IN pSinC) {return CHAN_E_INVALID_PARAM;};

    STDMETHODIMP_(BOOL) IsSendChannel () {return TRUE;};
	STDMETHODIMP_(BOOL) IsChannelOpen(){return ((m_dwFlags & COMCH_OPEN) !=0);};
	STDMETHODIMP_(BOOL) IsOpenPending(){return ((m_dwFlags & COMCH_OPEN_PENDING ) !=0);};
	STDMETHODIMP_(BOOL) IsChannelEnabled(){return ((m_dwFlags & COMCH_ENABLED ) !=0);};

	
	STDMETHODIMP ConfigureCapability(LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
		LPVOID lpvLocalParams, UINT uLocalParamSize){return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP GetLocalParams(LPVOID lpvChannelParams, UINT uBufSize){return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP_(PVOID) GetRemoteParams(VOID) {return NULL;}
 	STDMETHODIMP_(VOID) SetNegotiatedLocalFormat(DWORD dwF) {return;};
	STDMETHODIMP_(VOID) SetNegotiatedRemoteFormat(DWORD dwF) {return;};
   	STDMETHODIMP_(DWORD_PTR) GetHChannel(VOID) {return dwhChannel;};
    STDMETHODIMP_(VOID) SetHChannel (DWORD_PTR dwSetChannel) {dwhChannel = dwSetChannel;};	

// ICommChannel Methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG,AddRef());
	STDMETHOD_(ULONG,Release());
	
	STDMETHOD(GetProperty(DWORD prop, PVOID pBuf, LPUINT pcbBuf)) {return CHAN_E_INVALID_PARAM;};
	STDMETHOD(SetProperty(DWORD prop, PVOID pBuf, UINT cbBuf))  {return CHAN_E_INVALID_PARAM;};
	STDMETHOD(IsChannelOpen(BOOL *pbOpen));
	STDMETHOD(Open(MEDIA_FORMAT_ID idLocalFormat,IH323Endpoint *pConnection));
	STDMETHOD(Close());
	STDMETHOD(SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));

	STDMETHOD(EnableOpen(BOOL bEnable));
    STDMETHOD_(IMediaChannel *, GetMediaChannel(VOID)) {return NULL;};
   	STDMETHOD(Preview(MEDIA_FORMAT_ID idLocalFormat, IMediaChannel * pMediaChannel)){return CHAN_E_INVALID_PARAM;};
   	STDMETHOD(PauseNetworkStream(BOOL fPause)){return CHAN_E_INVALID_PARAM;};
    STDMETHOD_(BOOL, IsNetworkStreamPaused(VOID)){return TRUE;};
    STDMETHOD_(BOOL, IsRemotePaused(VOID)){return TRUE;};
    STDMETHODIMP_(MEDIA_FORMAT_ID) GetConfiguredFormatID() {return INVALID_MEDIA_FORMAT;};
   	STDMETHODIMP GetRemoteAddress(PSOCKADDR_IN pAddrOutput);

};

#endif  // _T120CHAN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\gkierror.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 *
 *	$Revision:   1.2  $
 *	$Date:   08 Feb 1997 12:20:14  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 * 
 *    Rev 1.2   08 Feb 1997 12:20:14   CHULME
 * Added error code for semaphore creation error
 * 
 *    Rev 1.1   16 Jan 1997 15:25:08   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.0   27 Dec 1996 14:37:02   EHOWARDX
 * Initial revision.
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKIERROR_H
#define GKIERROR_H

// Status codes
#define GKI_EXIT_THREAD_CODE			ERROR_LOCAL_BASE_ID + 1	// not actually error code
#define GKI_REDISCOVER_CODE				ERROR_LOCAL_BASE_ID + 2	// not actually error code
#define GKI_DELETE_CALL_CODE			ERROR_LOCAL_BASE_ID + 3	// not actually error code
#define GKI_GCF_RCV_CODE				ERROR_LOCAL_BASE_ID + 4	// not actually error code

#define GKI_ALREADY_REG_CODE			ERROR_LOCAL_BASE_ID + 0x10
#define GKI_VERSION_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x11
#define GKI_ENCODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x12
#define GKI_NOT_REG_CODE				ERROR_LOCAL_BASE_ID + 0x13
#define GKI_BUSY_CODE					ERROR_LOCAL_BASE_ID + 0x14
#define GKI_NO_TA_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x15
#define GKI_NO_RESPONSE_CODE			ERROR_LOCAL_BASE_ID + 0x16
#define GKI_DECODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x17
#define GKI_SEMAPHORE_ERROR_CODE		ERROR_LOCAL_BASE_ID + 0x18
#define GKI_NOT_INITIALIZED_ERROR_CODE	ERROR_LOCAL_BASE_ID + 0x19

#define GKI_OK							NOERROR

#define GKI_EXIT_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_EXIT_THREAD_CODE)
#define GKI_REDISCOVER					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_REDISCOVER_CODE)
#define GKI_DELETE_CALL					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_DELETE_CALL_CODE)
#define GKI_GCF_RCV						MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_GCF_RCV_CODE)

#define GKI_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_OUTOFMEMORY)
#define GKI_NO_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_TOO_MANY_TCBS)
#define GKI_HANDLE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_INVALID_HANDLE)

#define GKI_ALREADY_REG					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ALREADY_REG_CODE)
#define GKI_VERSION_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_VERSION_ERROR_CODE)
#define GKI_ENCODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ENCODER_ERROR_CODE)
#define GKI_NOT_REG						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_REG_CODE)
#define GKI_BUSY						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_BUSY_CODE)
#define GKI_NO_TA_ERROR					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_TA_ERROR_CODE)
#define GKI_NO_RESPONSE					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_RESPONSE_CODE)
#define GKI_DECODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_DECODER_ERROR_CODE)
#define GKI_SEMAPHORE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_SEMAPHORE_ERROR_CODE)

#define GKI_WINSOCK2_ERROR(w)			(MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK2,w))
#define GKI_NOT_INITIALIZED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_INITIALIZED_ERROR_CODE)

#endif // GKIERROR_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\callcont.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/callcont.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.102  $
 *      $Date:   13 Feb 1997 21:28:38  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CALLCONT_H
#define CALLCONT_H

#if defined(CALL_CONTROL_EXPORT)
#define CC_API __declspec (dllexport)
#else // CALL_CONTROL_IMPORT
#define CC_API __declspec (dllimport)
#endif

#pragma pack(push,8)

#ifndef H245API_H
#include "h245api.h"
#endif H245API_H

#ifndef CCERROR_H
#include "ccerror.h"
#endif  CCERROR_H

#ifdef __cplusplus
extern "C" {
#endif

// Indication codes
#define CC_RINGING_INDICATION						1
#define CC_CONNECT_INDICATION						2
#define CC_TX_CHANNEL_OPEN_INDICATION				3
#define CC_RX_CHANNEL_REQUEST_INDICATION			4
#define CC_RX_CHANNEL_CLOSE_INDICATION				5
#define CC_MUTE_INDICATION							6
#define CC_UNMUTE_INDICATION						7
#define CC_PEER_ADD_INDICATION						8
#define CC_PEER_DROP_INDICATION						9
#define CC_PEER_CHANGE_CAP_INDICATION				10
#define CC_CONFERENCE_TERMINATION_INDICATION		11
#define CC_HANGUP_INDICATION						12
#define CC_RX_NONSTANDARD_MESSAGE_INDICATION		13
#define CC_MULTIPOINT_INDICATION					14
#define CC_PEER_UPDATE_INDICATION					15
#define CC_H245_MISCELLANEOUS_COMMAND_INDICATION	16
#define CC_H245_MISCELLANEOUS_INDICATION_INDICATION	17
#define CC_H245_CONFERENCE_REQUEST_INDICATION		18
#define CC_H245_CONFERENCE_RESPONSE_INDICATION		19
#define CC_H245_CONFERENCE_COMMAND_INDICATION		20
#define CC_H245_CONFERENCE_INDICATION_INDICATION	21
#define CC_FLOW_CONTROL_INDICATION					22
#define CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION		23
#define CC_REQUEST_MODE_INDICATION					24
#define CC_REQUEST_MODE_RESPONSE_INDICATION			25
#define CC_VENDOR_ID_INDICATION						26
#define CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION		27
#define CC_T120_CHANNEL_REQUEST_INDICATION			28
#define CC_T120_CHANNEL_OPEN_INDICATION				29
#define CC_BANDWIDTH_CHANGED_INDICATION             30
#define CC_ACCEPT_CHANNEL_INDICATION                31
#define CC_TERMINAL_ID_REQUEST_INDICATION           32
#define CC_PING_RESPONSE_INDICATION					33
#define CC_TERMINAL_NUMBER_INDICATION               34

// Conference configuration values; these are bit mask values
#define CC_CONFIGURE_MULTIPOINT_CAPABLE				0x0001
#define CC_CONFIGURE_FORCE_MC						0x0002

// Timeout type codes
#define CC_Q931_ALERTING_TIMEOUT					1
#define CC_H245_RETRY_COUNT							2
#define CC_H245_TIMEOUT								3

// Conference termination reasons
#define CC_PEER_HANGUP								0
#define CC_GATEKEEPER_HANGUP						1

typedef enum {
	CC_WILL_TRANSMIT_PREFERRED_MODE,
	CC_WILL_TRANSMIT_LESS_PREFERRED_MODE,
	CC_MODE_UNAVAILABLE,
	CC_MULTIPOINT_CONSTRAINT,
	CC_REQUEST_DENIED
} CC_REQUEST_MODE_RESPONSE;

typedef H245_TOTCAP_T   CC_TERMCAP, *PCC_TERMCAP, **PPCC_TERMCAP;

typedef struct {
	WORD					wLength;
	PPCC_TERMCAP			pTermCapArray;
} CC_TERMCAPLIST, *PCC_TERMCAPLIST;

typedef struct {
	WORD					wLength;
	H245_TOTCAPDESC_T		**pTermCapDescriptorArray;
} CC_TERMCAPDESCRIPTORS, *PCC_TERMCAPDESCRIPTORS;

typedef struct {
	BYTE					bMCUNumber;
	BYTE					bTerminalNumber;
} CC_TERMINAL_LABEL, *PCC_TERMINAL_LABEL;

typedef struct {
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_OCTETSTRING			TerminalID;
} CC_PARTICIPANTINFO, *PCC_PARTICIPANTINFO;

typedef struct {
	WORD					wLength;
	PCC_PARTICIPANTINFO		ParticipantInfoArray;
} CC_PARTICIPANTLIST, *PCC_PARTICIPANTLIST;

typedef struct 
{
	BOOL					bMaster;
	BOOL					bMultipointController;
	BOOL					bMultipointConference;
	CC_CONFERENCEID			ConferenceID;
	CC_TERMINAL_LABEL		LocalTerminalLabel;
	WORD					wNumCalls;
	PCC_PARTICIPANTLIST		pParticipantList;
	DWORD					dwConferenceToken;
    DWORD                   dwBandwidthAllocated;
    DWORD                   dwBandwidthUsed;
} CC_CONFERENCEATTRIBUTES, *PCC_CONFERENCEATTRIBUTES;

typedef struct {
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	CC_OCTETSTRING			SessionDescription;
	PCC_TERMCAP				pTermCap;
	PCC_ADDR				pRTPAddr;
	PCC_ADDR				pRTCPAddr;
} CC_SESSIONINFO, *PCC_SESSIONINFO;

typedef struct {
	WORD					wLength;
	PCC_SESSIONINFO			SessionInfoArray;
} CC_SESSIONTABLE, *PCC_SESSIONTABLE;

typedef struct 
{
	CC_HCALL				hCall;
	PCC_ALIASNAMES			pCallerAliasNames;
	PCC_ALIASNAMES			pCalleeAliasNames;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszDisplay;
	PCC_VENDORINFO			pVendorInfo;
	WORD					wGoal;
	CC_CONFERENCEID			ConferenceID;
	PCC_ADDR				pCallerAddr;
	PCC_ADDR				pCalleeAddr;
	DWORD					dwListenToken;
} CC_LISTEN_CALLBACK_PARAMS, *PCC_LISTEN_CALLBACK_PARAMS;

typedef void *  PCC_CONFERENCE_CALLBACK_PARAMS;


// CC_RINGING_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	DWORD					dwUserToken;
} CC_RINGING_CALLBACK_PARAMS, *PCC_RINGING_CALLBACK_PARAMS;

// CC_CONNECT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszPeerDisplay;
	BYTE					bRejectReason;
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	PCC_ADDR				pLocalAddr;
	PCC_ADDR				pPeerAddr;
	PCC_VENDORINFO			pVendorInfo;
	BOOL					bMultipointConference;
	PCC_CONFERENCEID		pConferenceID;
	PCC_ADDR				pMCAddress;
	PCC_ADDR				pAlternateAddress;
	DWORD					dwUserToken;
} CC_CONNECT_CALLBACK_PARAMS, *PCC_CONNECT_CALLBACK_PARAMS;

// CC_TX_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD					dwRejectReason;
	DWORD					dwUserToken;
} CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_RX_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
	PCC_TERMCAP				pChannelCapability;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	PCC_ADDR	            pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	BYTE					bRTPPayloadType;
	BOOL					bSilenceSuppression;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS;

// CC_RX_CHANNEL_CLOSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS, *PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS;

// CC_MUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_MUTE_CALLBACK_PARAMS, *PCC_MUTE_CALLBACK_PARAMS;

// CC_UNMUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_UNMUTE_CALLBACK_PARAMS, *PCC_UNMUTE_CALLBACK_PARAMS;

// CC_PEER_ADD_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_ADD_CALLBACK_PARAMS, *PCC_PEER_ADD_CALLBACK_PARAMS;

// CC_PEER_DROP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_DROP_CALLBACK_PARAMS, *PCC_PEER_DROP_CALLBACK_PARAMS;

// CC_PEER_CHANGE_CAP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
} CC_PEER_CHANGE_CAP_CALLBACK_PARAMS, *PCC_PEER_CHANGE_CAP_CALLBACK_PARAMS;

// CC_CONFERENCE_TERMINATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	DWORD					dwReason;
} CC_CONFERENCE_TERMINATION_CALLBACK_PARAMS, *PCC_CONFERENCE_TERMINATION_CALLBACK_PARAMS;

// CC_HANGUP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	DWORD					dwUserToken;
} CC_HANGUP_CALLBACK_PARAMS, *PCC_HANGUP_CALLBACK_PARAMS;

// CC_RX_NONSTANDARD_MESSAGE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	BYTE					bH245MessageType;
	CC_NONSTANDARDDATA		NonStandardData;
} CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS, *PCC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS;

// CC_MULTIPOINT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	PCC_PARTICIPANTINFO		pTerminalInfo;
	PCC_SESSIONTABLE		pSessionTable;
} CC_MULTIPOINT_CALLBACK_PARAMS, *PCC_MULTIPOINT_CALLBACK_PARAMS;

// CC_PEER_UPDATE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_UPDATE_CALLBACK_PARAMS, *PCC_PEER_UPDATE_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	BOOL					bH323ActionRequired;
	MiscellaneousCommand	*pMiscellaneousCommand;
} CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	MiscellaneousIndication	*pMiscellaneousIndication;
} CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_REQ_ENUM_T	RequestType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_RSP_ENUM_T	ResponseType;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pOctetString;
	CC_TERMINAL_LABEL		*pTerminalList;
	WORD					wTerminalListCount;
} CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	H245_CONFER_CMD_ENUM_T	CommandType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_IND_ENUM_T	IndicationType;
	BYTE					bSBENumber;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS;

// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	DWORD					dwRate;
} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;

// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;

// CC_REQUEST_MODE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	RequestedModesLink		pRequestedModes;
} CC_REQUEST_MODE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_CALLBACK_PARAMS;

// CC_REQUEST_MODE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_REQUEST_MODE_RESPONSE RequestModeResponse;
} CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS;

// CC_VENDOR_ID_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PCC_OCTETSTRING			pProductNumber;
	PCC_OCTETSTRING			pVersionNumber;
} CC_VENDOR_ID_CALLBACK_PARAMS, *PCC_VENDOR_ID_CALLBACK_PARAMS;

// CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel1;
	CC_HCHANNEL				hChannel2;
	WORD					wMaximumSkew;
} CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS, *PCC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS;

// CC_T120_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	CC_HCALL				hCall;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	DWORD					dwRejectReason;
	DWORD					dwUserToken;
} CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_T120_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	BOOL					bMultipointController;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS;

typedef struct {
	CC_HCALL	            hCall;
	DWORD		            dwBandwidthTotal;
    long                    lBandwidthChange;
} CC_BANDWIDTH_CALLBACK_PARAMS, *PCC_BANDWIDTH_CALLBACK_PARAMS;

// CC_ACCEPT_CHANNEL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_ACCEPT_CHANNEL_CALLBACK_PARAMS, *PCC_ACCEPT_CHANNEL_CALLBACK_PARAMS;

// CC_PING_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	BOOL					bResponse;
} CC_PING_RESPONSE_CALLBACK_PARAMS, *PCC_PING_RESPONSE_CALLBACK_PARAMS;

#ifndef NO_APIS

typedef void (*CC_LISTEN_CALLBACK)(		HRESULT							hStatus,
										PCC_LISTEN_CALLBACK_PARAMS		ListenCallbackParams);

typedef HRESULT (*CC_CONFERENCE_CALLBACK)(
										BYTE							bIndication,
										HRESULT							hStatus,
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS	pConferenceCallbackParams);

typedef HRESULT (*CC_SESSIONTABLE_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbSessionTableChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors[],
										PCC_SESSIONTABLE				*ppSessionTable);

typedef HRESULT (*CC_TERMCAP_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbTermCapsChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pInTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
										PCC_TERMCAPLIST					*ppOutTermCapList,
										PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

CC_API
HRESULT CC_AcceptCall(					CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_ACCEPTCALL)(		CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
                                        DWORD                           dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_AcceptChannel(				CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);
									
typedef HRESULT (*CC_ACCEPTCHANNEL) (	CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);

CC_API
HRESULT CC_AcceptT120Channel(			CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
typedef HRESULT (*CC_ACCEPTT120CHANNEL)(CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
CC_API
HRESULT CC_CallListen(					PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD							dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);

typedef HRESULT (*CC_CALLLISTEN)(		PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD							dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);


CC_API
HRESULT CC_CancelCall(					CC_HCALL						hCall);

typedef HRESULT (*CC_CANCELCALL)(		CC_HCALL						hCall);


CC_API
HRESULT CC_CancelListen(				CC_HLISTEN						hListen);

typedef HRESULT (*CC_CANCELLISTEN)(		CC_HLISTEN						hListen);

CC_API
HRESULT CC_ChangeConferenceCapabilities(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

typedef HRESULT (*CC_CHANGECONFERENCECAPABILITIES)(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

CC_API
HRESULT CC_CloseChannel(				CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_CLOSECHANNEL)(		CC_HCHANNEL						hChannel);


CC_API
HRESULT CC_CloseChannelResponse(		CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

typedef HRESULT (*CC_CLOSECHANNELRESPONSE)(
										CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

CC_API
HRESULT CC_CreateConference(			PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD							dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

typedef HRESULT	(*CC_CREATECONFERENCE) (PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD							dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

CC_API
HRESULT CC_DestroyConference(			CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

typedef HRESULT (*CC_DESTROYCONFERENCE)(CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

CC_API
HRESULT CC_EnumerateConferences(		PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

typedef HRESULT (*CC_ENUMERATECONFERENCES)(
										PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

CC_API
HRESULT CC_FlowControl(					CC_HCHANNEL						hChannel,
										DWORD							dwRate);

typedef HRESULT (*CC_FLOWCONTROL)(		CC_HCHANNEL						hChannel,
										DWORD							dwRate);

CC_API
HRESULT CC_GetCallControlVersion(		WORD							wArraySize,
										PWSTR							pszVersion);

typedef HRESULT (*CC_GETCALLCONTROLVERSION)
									   (WORD							wArraySize,
										PWSTR							pszVersion);

CC_API
HRESULT CC_GetConferenceAttributes(		CC_HCONFERENCE					hConference,
										PCC_CONFERENCEATTRIBUTES		pConferenceAttributes);

typedef HRESULT (*CC_GETCONFERENCEATTRIBUTES) 
									   (CC_HCONFERENCE                  hConference,
									    PCC_CONFERENCEATTRIBUTES        pConferenceAttributes);

CC_API
HRESULT CC_H245ConferenceRequest(		CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEREQUEST)(
										CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceResponse(		CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

typedef HRESULT (*CC_H245CONFERENCERESPONSE)(
										CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

CC_API
HRESULT CC_H245ConferenceCommand(		CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCECOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceIndication(	CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEINDICATION)(
										CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245MiscellaneousCommand(	CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

typedef HRESULT (*CC_H245MISCELLANEOUSCOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

CC_API
HRESULT CC_H245MiscellaneousIndication(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

typedef HRESULT (*CC_H245MISCELLANEOUSINDICATION)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

CC_API
HRESULT CC_Hangup(						CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD							dwUserToken);

typedef HRESULT (*CC_HANGUP)(			CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD							dwUserToken);

CC_API
HRESULT CC_MaximumAudioVideoSkew(		CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

typedef HRESULT (*CC_MAXIMUMAUDIOVIDEOSKEW)(
										CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

CC_API
HRESULT CC_Mute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_MUTE)(				CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_OpenChannel(					CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

typedef HRESULT (*CC_OPENCHANNEL)(		CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

CC_API
HRESULT CC_OpenT120Channel(				CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

typedef HRESULT (*CC_OPENT120CHANNEL)(	CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

CC_API
HRESULT CC_Ping(						CC_HCALL						hCall,
										DWORD							dwTimeout);

typedef HRESULT (*CC_PING)(				CC_HCALL						hCall,
										DWORD							dwTimeout);

CC_API
HRESULT CC_PlaceCall(					CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_PLACECALL)(		CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_RejectCall(					BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

typedef HRESULT (*CC_REJECTCALL)(		BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

CC_API
HRESULT CC_RejectChannel(				CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

typedef HRESULT (*CC_REJECTCHANNEL)(	CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

CC_API
HRESULT CC_RequestMode(					CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

typedef HRESULT (*CC_REQUESTMODE)(		CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

CC_API
HRESULT CC_RequestModeResponse(			CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

typedef HRESULT (*CC_REQUESTMODERESPONSE)(
										CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

CC_API
HRESULT CC_SendNonStandardMessage(		CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

typedef HRESULT (*CC_SENDNONSTANDARDMESSAGE)(
										CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

CC_API
HRESULT CC_SendVendorID(				CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);

typedef HRESULT (*CC_SENDVENDORID)(		CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);
CC_API
HRESULT CC_SetCallControlTimeout(		WORD							wType,
										DWORD							dwDuration);

typedef HRESULT (*CC_SETCALLCONTROLTIMEOUT)
									   (WORD							wType,
										DWORD							dwDuration);

CC_API
HRESULT CC_SetTerminalID(				CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

typedef HRESULT (*CC_SETTERMINALID)(	CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

CC_API
HRESULT CC_Shutdown();
CC_API
HRESULT CC_Initialize();

typedef HRESULT (*CC_SHUTDOWN)();
typedef HRESULT (*CC_INITIALIZE)();

CC_API
HRESULT CC_UnMute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_UNMUTE)(			CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_UpdatePeerList(				CC_HCONFERENCE					hConference);

typedef HRESULT (*CC_UPDATEPEERLIST)(	CC_HCONFERENCE					hConference);

CC_API
HRESULT CC_UserInput(					CC_HCALL						hCall,
										PWSTR							pszUserInput);

typedef HRESULT (*CC_USERINPUT)(		CC_HCALL						hCall,
										PWSTR							pszUserInput);


// structure used for holding the entry points to the CallControl module
typedef struct _CALLCONTROLAPI
{
	CC_ACCEPTCALL							CC_AcceptCall;
	CC_ACCEPTCHANNEL						CC_AcceptChannel;
	CC_ACCEPTT120CHANNEL					CC_AcceptT120Channel;
	CC_CALLLISTEN                           CC_CallListen;
	CC_CANCELCALL                           CC_CancelCall;
	CC_CANCELLISTEN                         CC_CancelListen;
	CC_CLOSECHANNEL                         CC_CloseChannel;
	CC_CLOSECHANNELRESPONSE					CC_CloseChannelResponse;
	CC_CHANGECONFERENCECAPABILITIES			CC_ChangeConferenceCapabilities;
	CC_CREATECONFERENCE                     CC_CreateConference;
	CC_DESTROYCONFERENCE					CC_DestroyConference;
	CC_ENUMERATECONFERENCES					CC_EnumerateConferences;
	CC_FLOWCONTROL							CC_FlowControl;
	CC_GETCALLCONTROLVERSION				CC_GetCallControlVersion;
	CC_GETCONFERENCEATTRIBUTES				CC_GetConferenceAttributes;
	CC_H245CONFERENCEREQUEST				CC_H245ConferenceRequest;
	CC_H245CONFERENCERESPONSE				CC_H245ConferenceResponse;
	CC_H245CONFERENCECOMMAND				CC_H245ConferenceCommand;
	CC_H245CONFERENCEINDICATION				CC_H245ConferenceIndication;
	CC_H245MISCELLANEOUSCOMMAND				CC_H245MiscellaneousCommand;
	CC_H245MISCELLANEOUSINDICATION			CC_H245MiscellaneousIndication;
	CC_HANGUP                               CC_Hangup;
	CC_MAXIMUMAUDIOVIDEOSKEW				CC_MaximumAudioVideoSkew;
	CC_MUTE                                 CC_Mute;
	CC_OPENCHANNEL                          CC_OpenChannel;
	CC_OPENT120CHANNEL						CC_OpenT120Channel;
	CC_PING									CC_Ping;
	CC_PLACECALL                            CC_PlaceCall;
	CC_REJECTCALL							CC_RejectCall;
	CC_REJECTCHANNEL						CC_RejectChannel;
	CC_REQUESTMODE							CC_RequestMode;
	CC_REQUESTMODERESPONSE					CC_RequestModeResponse;
	CC_SENDNONSTANDARDMESSAGE				CC_SendNonStandardMessage;
	CC_SENDVENDORID							CC_SendVendorID;
	CC_SETCALLCONTROLTIMEOUT				CC_SetCallControlTimeout;
	CC_SETTERMINALID						CC_SetTerminalID;
	CC_SHUTDOWN								CC_Shutdown;
	CC_INITIALIZE                           CC_Initialize;
	CC_UNMUTE                               CC_UnMute;
	CC_UPDATEPEERLIST						CC_UpdatePeerList;
	CC_USERINPUT							CC_UserInput;
} CALLCONTROLAPI, *LPCALLCONTROLAPI; 

#endif


#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CALLCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\cpls.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __CPLS_H
#define __CPLS_H

#include <limits.h>

#ifdef WIN32
	#include <windows.h>
	#include <windowsx.h> 
	#include "port32.h"
#endif

#ifdef _WINDOWS
	#ifndef _MSWINDOWS_
		#define _MSWINDOWS_
	#endif
#endif

typedef int HLOG;                          

#ifndef FALSE
	#define FALSE   0
#endif

#ifndef TRUE
	#define TRUE    1
#endif
#ifdef WIN32
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT __declspec(dllexport)
		#define CPLS_EXPORT __declspec(dllexport)
	#else
		#define CPLS_FAREXPORT __declspec(dllimport)
		#define CPLS_EXPORT __declspec(dllimport)
	#endif
	#ifndef EXPORT
		#define EXPORT
	#endif	// EXPORT
#elif _MSWINDOWS_
	#ifndef CALLBACK
		#define CALLBACK _far _pascal
	#endif
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT _far _export _pascal
		#define CPLS_EXPORT _export
	#else
		#define CPLS_FAREXPORT _far _pascal
		#define CPLS_EXPORT
	#endif
	#ifndef EXPORT
		#define EXPORT _export
	#endif	// EXPORT
	#ifndef FAR
		#define FAR _far
	#endif
#else    
	#ifndef CALLBACK
		#define CALLBACK      
	#endif
	#define CPLS_FAREXPORT
	#ifndef EXPORT
		#define EXPORT  
	#endif
	#ifndef FAR
		#define FAR
	#endif
#endif  // _MSWINDOWS_  


typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef const char FAR* CPLProtocol;
typedef int CPLProtocolID;

#define CONFIG_FILENAME "CPLS.INI"    // internal use only

// Pre-defined event and event category constants.
//
#define String_Event USHRT_MAX
#define Binary_Event USHRT_MAX-1

#define String_Category USHRT_MAX
#define Binary_Category USHRT_MAX-1

#ifdef __cplusplus      
	class CProtocolLog;
	class CProtocolEvent;
	typedef CProtocolEvent FAR* (CALLBACK *CPLEventGenesisProc)( 
															BYTE FAR* pObject,              // in
															CProtocolLog FAR* pSourceLog,   // in
															BOOL bCopyObject );             // in
extern "C"{

// This first one is only for C++ clients...
void CPLS_FAREXPORT CPLRegisterEventGenesisProc( CPLProtocolID ProtocolID, CPLEventGenesisProc pfnGenesisProc );

#endif  // __cplusplus

// Possible file mode values for CPLOpen().
//
#define CPLS_CREATE 0		// Will overwrite an existing file.
#define CPLS_APPEND 1		// Will append to an existing file, or create a new one.

/////////////////////////////////////////////////////////////////////////////
// 					PROTOCOL LOGGING FUNCTIONS
//
// Here is the sequence of functions to call for use of a protocol logger:
//		1) CPLInitialize() or CPLINTInitialize()
//		2) CPLOpen()
//		3) CPLOutput*() or CPLINTOutput*() -- repeat as necessary
//		4) CPLClose()
//		5) CPLUninitialize()
//
// CPLInitialize() - Creates a protocol logger.
// CPLINTInitialize() - The version of CPLInitialize() which must be called
//		by clients which will be calling the CPLINTOuptut*() functions within
//		interrupt context.  CPLINTInitialize may not be called within
//		interrupt context.
// CPLUninitialize() - Releases a protocol logger.  This must be called for
//		every initialized logger before shutdown in order to free associated
//		memory.
// CPLOpen() - Associates a protocol logger with a file (output stream).
// CPLClose() - Releases a logger's usage of a stream.  This function does
//		not block.  A "close" event is placed on the event queue of the
//		stream.  Release of the stream occurs when this "close" event is
//		serviced.
// CPLOutputDebug() - 
// CPLINTOutputDebug() - The version of CPLOutputDebug() safely callable
//		within interrupt context.
// CPLOutputAscii() - 
// CPLINTOutputAscii() - The version of CPLOutputAscii() safely callable
//		within interrupt context.
// CPLOutput() - 
// CPLINTOutput() - The version of CPLOutput() safely callable
//		within interrupt context.
// CPLFlush() - Flushes all events to the stream of the specified logger.
//		Blocks until the flush is complete.
// CPLINTFlush() -  The version of CPLFlush() safely callable within
//		interrupt context.  This version does not block.  A "flush" message
//		is sent to CPLS.  The flush occurs when this flush message is
//		serviced.
// CPLFlushAndClose() -
// CPLEnable() - Enables or disables protocol logging at runtime.
// CPLEnableAsync() - Sets synchronous or asynchronous logging output mode.
//		CURRENTLY NOT SUPPORTED.
// CPLLogAscii() - 
// CPLINTLogAscii() - The version of CPLLogAscii() safely callable
//		within interrupt context.
//
// Only these functions may be called from within interrupt context:
//		CPLINTOutputDebug()
//		CPLINTOutputAscii()
//		CPLINTOutput()
//		CPLINTFlush()
//		CPLEnable()
//		CPLINTLogAscii()
/////////////////////////////////////////////////////////////////////////////
CPLProtocolID CPLS_FAREXPORT WINAPI CPLInitialize( CPLProtocol Protocol );

CPLProtocolID CPLS_FAREXPORT CPLINTInitialize( CPLProtocol Protocol );

int  CPLS_FAREXPORT WINAPI CPLUninitialize( HLOG hlog );

HLOG CPLS_FAREXPORT WINAPI CPLOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
HLOG CPLS_FAREXPORT CPLINTOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
int  CPLS_FAREXPORT WINAPI CPLClose( HLOG hLog );

int  CPLS_FAREXPORT CPLOutputDebug( HLOG hLog, 
							const char FAR* szString );
int  CPLS_FAREXPORT CPLINTOutputDebug( HLOG hLog, 
							const char FAR* szString );

int  CPLS_FAREXPORT CPLOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );

int  CPLS_FAREXPORT WINAPI CPLOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );

int  CPLS_FAREXPORT CPLFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLINTFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLFlushAndClose( HLOG hLog );

void CPLS_FAREXPORT CPLEnable( BOOL bEnable );
//void CPLS_FAREXPORT CPLEnableAsync( BOOL bEnable );

#ifdef __cplusplus
};      // extern "C"
#endif  // __cplusplus

#define CPLLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )

#define CPLINTLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLINTOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )
		
#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\cclock.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/cclock.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   31 Jan 1997 12:36:14  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCLOCK_H
#define CCLOCK_H

// Status codes
#define CCLOCK_OK						NOERROR
#define CCLOCK_NO_MEMORY				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CCLOCK,ERROR_OUTOFMEMORY)
#define CCLOCK_INTERNAL_ERROR			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CCLOCK,ERROR_LOCAL_BASE_ID + 1)

#ifdef __cplusplus
extern "C" {
#endif

#if defined(CCLOCK_EXPORT)
#define CCLOCK_API __declspec (dllexport)
#else // CCLOCK_IMPORT
#define CCLOCK_API __declspec (dllimport)
#endif

#pragma pack(push,8)


CCLOCK_API
HRESULT CCLOCK_AcquireLock();

CCLOCK_API
HRESULT CCLOCK_RelinquishLock();

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CCLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\coder.hpp ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\coder.hpv  $
 *
 *	$Revision:   1.4  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *	$Log:   S:\sturgeon\src\include\vcs\coder.hpv  $
// 
//    Rev 1.4   16 Jan 1997 15:25:06   BPOLING
// changed copyrights to 1997
// 
//    Rev 1.3   18 Dec 1996 21:49:58   BPOLING
// builds with msdev and for windows only
// 
//    Rev 1.2   09 Dec 1996 14:13:54   EHOWARDX
// Updated copyright notice.
 * 
 *    Rev 1.1   15 Nov 1996 16:16:14   BPOLING
 * vcs header added.
 *                                                                     *
 ***********************************************************************
 *																	   *
 *	coder.hpp														   *
 *																	   * 
 *	PURPOSE:	Encode/Decode ANS.1 Gatekeeper PDU using the OSS ANS.1 *
 *				compiler functions.									   *
 *																	   *
 *	FUNCTIONS:														   *
 *																	   *
 *	COMMENTS: 														   *
 *																	   *
 ***********************************************************************/

/************************************************************************
 * 						Include Files		           				   	*
 ***********************************************************************/

/************************************************************************
 * 						Manifest Constants								*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/

/************************************************************************
 * 						Class Definitions								*
 ***********************************************************************/

#ifndef _CODER_HPP
#define _CODER_HPP

#include "av_asn1.h"
#include "gk_asn1.h"

extern "C" {
int GK_InitModule(void);
int GK_TermModule(void);
int GK_InitWorld(ASN1_CODER_INFO *pWorld);
int GK_TermWorld(ASN1_CODER_INFO *pWorld);
int GK_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int GK_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);
}

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			8     // H225.0
#define RECOMM_NUMBER   2250
#define VERSION         0
#define ADDITIONAL      1


typedef struct InfoRequestResponse_perCallInfo      SEQPERCALLINFO, *PSEQPERCALLINFO;

typedef struct _seqtransadds{
    struct _seqtransadds  	*next;
    TransportAddress 		value;
} SEQTRANSADDS, *PSEQTRANSADDS;

typedef struct _seqaliasadds {
    struct _seqaliasadds  	*next;
    AliasAddress    		value;
} SEQALIASADDS, *PSEQALIASADDS;

class Coder{

private:
	ASN1_CODER_INFO		m_World;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

	int InitCoder();
	// Creates an OssBuf
	int Encode(RasMessage *pInputData, ASN1_BUF *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(ASN1_BUF *pInputOssBuf, RasMessage **pOutputData);
	// Used to free buffer created by decode
	int Free(RasMessage *pData);
	// Used to free buffer created by encode
	void Free(ASN1_BUF Asn1Buf);
	// Returns the sequence number out of any RasMessage
	// Returns zero on error
	RequestSeqNum GetSequenceNumber(RasMessage *prasStruct);
	RequestSeqNum SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum);
	// Returns a pointer EndpointIdentifier for any RasMessage
	// NULL for RasMessage that have no EndpointIdentifier
	EndpointIdentifier *GetEndpointID(RasMessage *prasStruct);
	// Returns a pointer to a valid H323 protocolIdentifier linked list 
	// when a valid Rasmessage is passed in and sets the protocol Identifier
	// item in RasMessages that have an protocol Identifier
	// If in an RasMessage that doesn't have a protocol identifer is passed in,
	// NULL is returned.
	ProtocolIdentifier SetProtocolIdentifier(RasMessage &rasStruct);
	// Returns TRUE if protocols match, FALSE - otherwise
	BOOL VerifyProtocolIdentifier(RasMessage &rasStruct);
	// finds the requested protocol rasAddress and copies it
	DWORD CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice);
	// finds the requested protocol callSignalAddress and copies it
	DWORD CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\gkiexp.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 *
 *	$Revision:   1.7  $
 *	$Date:   11 Feb 1997 15:37:30  $
 *
 *	$Author:   CHULME  $															*
 *
 *	$Log:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 * 
 *    Rev 1.7   11 Feb 1997 15:37:30   CHULME
 * Added GKI_CleanupRequest function
 * 
 *    Rev 1.6   16 Jan 1997 15:25:00   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.5   17 Dec 1996 18:23:36   CHULME
 * Change interface to use Remote rather than destination for AdmissionRequest
 * 
 *    Rev 1.4   09 Dec 1996 14:13:40   EHOWARDX
 * Updated copyright notice.
 *                                                                     * 
 ***********************************************************************/

// gkiexp.h : header file
//

#ifndef GKIEXP_H
#define GKIEXP_H

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif

// ------------------------ Variable Imports --------------------------
extern DLL_IMPORT DWORD dwGKIDLLFlags;
extern DLL_IMPORT BOOL  fGKIEcho;
extern DLL_IMPORT BOOL  fGKIDontSend;
#if 0 //NSMWrap
extern DLL_IMPORT BOOL  fNSMWrapper;
#endif

// ------------------------ Function Imports --------------------------
HRESULT DLL_IMPORT GKI_RegistrationRequest(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_UnregistrationRequest(void);

HRESULT DLL_IMPORT GKI_LocationRequest(SeqAliasAddr         *pLocationInfo);

HRESULT DLL_IMPORT GKI_AdmissionRequest(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pRemoteInfo,
                                    TransportAddress     *pRemoteCallSignalAddress,
                                    SeqAliasAddr         *pDestExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_BandwidthRequest(HANDLE              hModCall, 
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

HRESULT DLL_IMPORT GKI_DisengageRequest(HANDLE hCall);
HRESULT DLL_IMPORT GKI_Initialize(void);
HRESULT DLL_IMPORT GKI_CleanupRequest(void);

#ifdef _DEBUG
WORD DLL_IMPORT Dump_GKI_RegistrationRequest(long        lVersion, 
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);

WORD DLL_IMPORT Dump_GKI_AdmissionRequest(unsigned short usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //GKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\gkpdu.h ===
#ifndef _GKPDU_Module_H_
#define _GKPDU_Module_H_

#include "nmasn1.h"
#ifdef __cplusplus
extern "C" {
#endif

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct RTPSession_associatedSessionIds * PRTPSession_associatedSessionIds;

typedef struct InfoRequestResponse_endpointAlias * PInfoRequestResponse_endpointAlias;

typedef struct LocationRequest_destinationInfo * PLocationRequest_destinationInfo;

typedef struct AdmissionRequest_srcInfo * PAdmissionRequest_srcInfo;

typedef struct AdmissionRequest_destExtraCallInfo * PAdmissionRequest_destExtraCallInfo;

typedef struct AdmissionRequest_destinationInfo * PAdmissionRequest_destinationInfo;

typedef struct UnregistrationRequest_endpointAlias * PUnregistrationRequest_endpointAlias;

typedef struct RegistrationRejectReason_duplicateAlias * PRegistrationRejectReason_duplicateAlias;

typedef struct RegistrationConfirm_terminalAlias * PRegistrationConfirm_terminalAlias;

typedef struct RegistrationRequest_terminalAlias * PRegistrationRequest_terminalAlias;

typedef struct GatekeeperRequest_endpointAlias * PGatekeeperRequest_endpointAlias;

typedef struct InfoRequestResponse_perCallInfo_Seq_data * PInfoRequestResponse_perCallInfo_Seq_data;

typedef struct InfoRequestResponse_perCallInfo_Seq_video * PInfoRequestResponse_perCallInfo_Seq_video;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio * PInfoRequestResponse_perCallInfo_Seq_audio;

typedef struct InfoRequestResponse_perCallInfo * PInfoRequestResponse_perCallInfo;

typedef struct InfoRequestResponse_callSignalAddress * PInfoRequestResponse_callSignalAddress;

typedef struct UnregistrationRequest_callSignalAddress * PUnregistrationRequest_callSignalAddress;

typedef struct RegistrationConfirm_callSignalAddress * PRegistrationConfirm_callSignalAddress;

typedef struct RegistrationRequest_rasAddress * PRegistrationRequest_rasAddress;

typedef struct RegistrationRequest_callSignalAddress * PRegistrationRequest_callSignalAddress;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1uint16_t RTPSession_associatedSessionIds_Seq;

typedef struct ConferenceIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} ConferenceIdentifier;

typedef ASN1uint16_t RequestSeqNum;

typedef ASN1char16string_t GatekeeperIdentifier;

typedef ASN1uint32_t BandWidth;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1char16string_t EndpointIdentifier;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct RTPSession_associatedSessionIds {
    PRTPSession_associatedSessionIds next;
    RTPSession_associatedSessionIds_Seq value;
} RTPSession_associatedSessionIds_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
    } u;
} AliasAddress;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct GatekeeperRejectReason {
    ASN1choice_t choice;
#   define GatekeeperRejectReason_resourceUnavailable_chosen 1
#   define terminalExcluded_chosen 2
#   define GatekeeperRejectReason_invalidRevision_chosen 3
#   define GatekeeperRejectReason_undefinedReason_chosen 4
} GatekeeperRejectReason;

typedef struct RegistrationRejectReason {
    ASN1choice_t choice;
    union {
#	define discoveryRequired_chosen 1
#	define RegistrationRejectReason_invalidRevision_chosen 2
#	define invalidCallSignalAddress_chosen 3
#	define invalidRASAddress_chosen 4
#	define duplicateAlias_chosen 5
	PRegistrationRejectReason_duplicateAlias duplicateAlias;
#	define invalidTerminalType_chosen 6
#	define RegistrationRejectReason_undefinedReason_chosen 7
#	define transportNotSupported_chosen 8
    } u;
} RegistrationRejectReason;

typedef struct UnregRejectReason {
    ASN1choice_t choice;
#   define notCurrentlyRegistered_chosen 1
#   define callInProgress_chosen 2
#   define UnregRejectReason_undefinedReason_chosen 3
} UnregRejectReason;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct CallModel {
    ASN1choice_t choice;
#   define direct_chosen 1
#   define gatekeeperRouted_chosen 2
} CallModel;

typedef struct AdmissionRejectReason {
    ASN1choice_t choice;
#   define calledPartyNotRegistered_chosen 1
#   define AdmissionRejectReason_invalidPermission_chosen 2
#   define AdmissionRejectReason_requestDenied_chosen 3
#   define AdmissionRejectReason_undefinedReason_chosen 4
#   define callerNotRegistered_chosen 5
#   define routeCallToGatekeeper_chosen 6
#   define invalidEndpointIdentifier_chosen 7
#   define AdmissionRejectReason_resourceUnavailable_chosen 8
} AdmissionRejectReason;

typedef struct BandRejectReason {
    ASN1choice_t choice;
#   define notBound_chosen 1
#   define invalidConferenceID_chosen 2
#   define BandRejectReason_invalidPermission_chosen 3
#   define insufficientResources_chosen 4
#   define BandRejectReason_invalidRevision_chosen 5
#   define BandRejectReason_undefinedReason_chosen 6
} BandRejectReason;

typedef struct LocationRejectReason {
    ASN1choice_t choice;
#   define LocationRejectReason_notRegistered_chosen 1
#   define LocationRejectReason_invalidPermission_chosen 2
#   define LocationRejectReason_requestDenied_chosen 3
#   define LocationRejectReason_undefinedReason_chosen 4
} LocationRejectReason;

typedef struct DisengageReason {
    ASN1choice_t choice;
#   define forcedDrop_chosen 1
#   define normalDrop_chosen 2
#   define DisengageReason_undefinedReason_chosen 3
} DisengageReason;

typedef struct DisengageRejectReason {
    ASN1choice_t choice;
#   define DisengageRejectReason_notRegistered_chosen 1
#   define requestToDropOther_chosen 2
} DisengageRejectReason;

typedef struct UnknownMessageResponse {
    RequestSeqNum requestSeqNum;
} UnknownMessageResponse;

typedef struct InfoRequestResponse_endpointAlias {
    PInfoRequestResponse_endpointAlias next;
    AliasAddress value;
} InfoRequestResponse_endpointAlias_Element;

typedef struct LocationRequest_destinationInfo {
    PLocationRequest_destinationInfo next;
    AliasAddress value;
} LocationRequest_destinationInfo_Element;

typedef struct AdmissionRequest_srcInfo {
    PAdmissionRequest_srcInfo next;
    AliasAddress value;
} AdmissionRequest_srcInfo_Element;

typedef struct AdmissionRequest_destExtraCallInfo {
    PAdmissionRequest_destExtraCallInfo next;
    AliasAddress value;
} AdmissionRequest_destExtraCallInfo_Element;

typedef struct AdmissionRequest_destinationInfo {
    PAdmissionRequest_destinationInfo next;
    AliasAddress value;
} AdmissionRequest_destinationInfo_Element;

typedef struct UnregistrationRequest_endpointAlias {
    PUnregistrationRequest_endpointAlias next;
    AliasAddress value;
} UnregistrationRequest_endpointAlias_Element;

typedef struct RegistrationRejectReason_duplicateAlias {
    PRegistrationRejectReason_duplicateAlias next;
    AliasAddress value;
} RegistrationRejectReason_duplicateAlias_Element;

typedef struct RegistrationConfirm_terminalAlias {
    PRegistrationConfirm_terminalAlias next;
    AliasAddress value;
} RegistrationConfirm_terminalAlias_Element;

typedef struct RegistrationRequest_terminalAlias {
    PRegistrationRequest_terminalAlias next;
    AliasAddress value;
} RegistrationRequest_terminalAlias_Element;

typedef struct GatekeeperRequest_endpointAlias {
    PGatekeeperRequest_endpointAlias next;
    AliasAddress value;
} GatekeeperRequest_endpointAlias_Element;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct GatekeeperReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define GatekeeperReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    GatekeeperRejectReason rejectReason;
} GatekeeperReject;

typedef struct RegistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    PRegistrationConfirm_callSignalAddress callSignalAddress;
#   define RegistrationConfirm_terminalAlias_present 0x40
    PRegistrationConfirm_terminalAlias terminalAlias;
#   define RegistrationConfirm_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    EndpointIdentifier endpointIdentifier;
} RegistrationConfirm;

typedef struct RegistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    RegistrationRejectReason rejectReason;
#   define RegistrationReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
} RegistrationReject;

typedef struct UnregistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    PUnregistrationRequest_callSignalAddress callSignalAddress;
#   define UnregistrationRequest_endpointAlias_present 0x80
    PUnregistrationRequest_endpointAlias endpointAlias;
#   define UnregistrationRequest_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
#   define UnregistrationRequest_endpointIdentifier_present 0x20
    EndpointIdentifier endpointIdentifier;
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define UnregistrationConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} UnregistrationConfirm;

typedef struct UnregistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    UnregRejectReason rejectReason;
#   define UnregistrationReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} UnregistrationReject;

typedef struct AdmissionReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    AdmissionRejectReason rejectReason;
#   define AdmissionReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} AdmissionReject;

typedef struct BandwidthRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
#   define callType_present 0x80
    CallType callType;
    BandWidth bandWidth;
#   define BandwidthRequest_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} BandwidthRequest;

typedef struct BandwidthConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
#   define BandwidthConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} BandwidthConfirm;

typedef struct BandwidthReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth allowedBandWidth;
#   define BandwidthReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} BandwidthReject;

typedef struct LocationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    LocationRejectReason rejectReason;
#   define LocationReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} LocationReject;

typedef struct DisengageRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
#   define DisengageRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} DisengageRequest;

typedef struct DisengageConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define DisengageConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} DisengageConfirm;

typedef struct DisengageReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    DisengageRejectReason rejectReason;
#   define DisengageReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} DisengageReject;

typedef struct NonStandardMessage {
    RequestSeqNum requestSeqNum;
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H310Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H320Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H321Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H322Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H323Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H324Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} T120OnlyCaps;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct GatekeeperConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define GatekeeperConfirm_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    TransportAddress rasAddress;
} GatekeeperConfirm;

typedef struct AdmissionRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    CallType callType;
#   define callModel_present 0x80
    CallModel callModel;
    EndpointIdentifier endpointIdentifier;
#   define destinationInfo_present 0x40
    PAdmissionRequest_destinationInfo destinationInfo;
#   define destCallSignalAddress_present 0x20
    TransportAddress destCallSignalAddress;
#   define destExtraCallInfo_present 0x10
    PAdmissionRequest_destExtraCallInfo destExtraCallInfo;
    PAdmissionRequest_srcInfo srcInfo;
#   define srcCallSignalAddress_present 0x8
    TransportAddress srcCallSignalAddress;
    BandWidth bandWidth;
    CallReferenceValue callReferenceValue;
#   define AdmissionRequest_nonStandardData_present 0x4
    NonStandardParameter nonStandardData;
#   define AdmissionRequest_callServices_present 0x2
    QseriesOptions callServices;
    ConferenceIdentifier conferenceID;
    ASN1bool_t activeMC;
    ASN1bool_t answerCall;
} AdmissionRequest;

typedef struct AdmissionConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
    CallModel callModel;
    TransportAddress destCallSignalAddress;
#   define irrFrequency_present 0x80
    ASN1uint16_t irrFrequency;
#   define AdmissionConfirm_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} AdmissionConfirm;

typedef struct LocationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define LocationRequest_endpointIdentifier_present 0x80
    EndpointIdentifier endpointIdentifier;
    PLocationRequest_destinationInfo destinationInfo;
#   define LocationRequest_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
    TransportAddress replyAddress;
} LocationRequest;

typedef struct LocationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
#   define LocationConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} LocationConfirm;

typedef struct InfoRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    CallReferenceValue callReferenceValue;
#   define InfoRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define replyAddress_present 0x40
    TransportAddress replyAddress;
} InfoRequest;

typedef struct TransportChannelInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sendAddress_present 0x80
    TransportAddress sendAddress;
#   define recvAddress_present 0x40
    TransportAddress recvAddress;
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    ASN1ztcharstring_t cname;
    ASN1uint32_t ssrc;
    ASN1uint16_t sessionId;
    PRTPSession_associatedSessionIds associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse_perCallInfo_Seq_data {
    PInfoRequestResponse_perCallInfo_Seq_data next;
    TransportChannelInfo value;
} InfoRequestResponse_perCallInfo_Seq_data_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_video {
    PInfoRequestResponse_perCallInfo_Seq_video next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_video_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio {
    PInfoRequestResponse_perCallInfo_Seq_audio next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_audio_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define InfoRequestResponse_perCallInfo_Seq_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
#   define originator_present 0x40
    ASN1bool_t originator;
#   define audio_present 0x20
    PInfoRequestResponse_perCallInfo_Seq_audio audio;
#   define video_present 0x10
    PInfoRequestResponse_perCallInfo_Seq_video video;
#   define data_present 0x8
    PInfoRequestResponse_perCallInfo_Seq_data data;
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType callType;
    BandWidth bandWidth;
    CallModel callModel;
} InfoRequestResponse_perCallInfo_Seq;

typedef struct InfoRequestResponse_perCallInfo {
    PInfoRequestResponse_perCallInfo next;
    InfoRequestResponse_perCallInfo_Seq value;
} InfoRequestResponse_perCallInfo_Element;

typedef struct InfoRequestResponse_callSignalAddress {
    PInfoRequestResponse_callSignalAddress next;
    TransportAddress value;
} InfoRequestResponse_callSignalAddress_Element;

typedef struct UnregistrationRequest_callSignalAddress {
    PUnregistrationRequest_callSignalAddress next;
    TransportAddress value;
} UnregistrationRequest_callSignalAddress_Element;

typedef struct RegistrationConfirm_callSignalAddress {
    PRegistrationConfirm_callSignalAddress next;
    TransportAddress value;
} RegistrationConfirm_callSignalAddress_Element;

typedef struct RegistrationRequest_rasAddress {
    PRegistrationRequest_rasAddress next;
    TransportAddress value;
} RegistrationRequest_rasAddress_Element;

typedef struct RegistrationRequest_callSignalAddress {
    PRegistrationRequest_callSignalAddress next;
    TransportAddress value;
} RegistrationRequest_callSignalAddress_Element;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
    } u;
} SupportedProtocols;

typedef struct GatekeeperRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    TransportAddress rasAddress;
    EndpointType endpointType;
#   define GatekeeperRequest_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define GatekeeperRequest_callServices_present 0x20
    QseriesOptions callServices;
#   define GatekeeperRequest_endpointAlias_present 0x10
    PGatekeeperRequest_endpointAlias endpointAlias;
} GatekeeperRequest;

typedef struct RegistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    ASN1bool_t discoveryComplete;
    PRegistrationRequest_callSignalAddress callSignalAddress;
    PRegistrationRequest_rasAddress rasAddress;
    EndpointType terminalType;
#   define RegistrationRequest_terminalAlias_present 0x40
    PRegistrationRequest_terminalAlias terminalAlias;
#   define RegistrationRequest_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    VendorIdentifier endpointVendor;
} RegistrationRequest;

typedef struct InfoRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define InfoRequestResponse_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    RequestSeqNum requestSeqNum;
    EndpointType endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    PInfoRequestResponse_callSignalAddress callSignalAddress;
#   define InfoRequestResponse_endpointAlias_present 0x40
    PInfoRequestResponse_endpointAlias endpointAlias;
#   define perCallInfo_present 0x20
    PInfoRequestResponse_perCallInfo perCallInfo;
} InfoRequestResponse;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct RasMessage {
    ASN1choice_t choice;
    union {
#	define gatekeeperRequest_chosen 1
	GatekeeperRequest gatekeeperRequest;
#	define gatekeeperConfirm_chosen 2
	GatekeeperConfirm gatekeeperConfirm;
#	define gatekeeperReject_chosen 3
	GatekeeperReject gatekeeperReject;
#	define registrationRequest_chosen 4
	RegistrationRequest registrationRequest;
#	define registrationConfirm_chosen 5
	RegistrationConfirm registrationConfirm;
#	define registrationReject_chosen 6
	RegistrationReject registrationReject;
#	define unregistrationRequest_chosen 7
	UnregistrationRequest unregistrationRequest;
#	define unregistrationConfirm_chosen 8
	UnregistrationConfirm unregistrationConfirm;
#	define unregistrationReject_chosen 9
	UnregistrationReject unregistrationReject;
#	define admissionRequest_chosen 10
	AdmissionRequest admissionRequest;
#	define admissionConfirm_chosen 11
	AdmissionConfirm admissionConfirm;
#	define admissionReject_chosen 12
	AdmissionReject admissionReject;
#	define bandwidthRequest_chosen 13
	BandwidthRequest bandwidthRequest;
#	define bandwidthConfirm_chosen 14
	BandwidthConfirm bandwidthConfirm;
#	define bandwidthReject_chosen 15
	BandwidthReject bandwidthReject;
#	define disengageRequest_chosen 16
	DisengageRequest disengageRequest;
#	define disengageConfirm_chosen 17
	DisengageConfirm disengageConfirm;
#	define disengageReject_chosen 18
	DisengageReject disengageReject;
#	define locationRequest_chosen 19
	LocationRequest locationRequest;
#	define locationConfirm_chosen 20
	LocationConfirm locationConfirm;
#	define locationReject_chosen 21
	LocationReject locationReject;
#	define infoRequest_chosen 22
	InfoRequest infoRequest;
#	define infoRequestResponse_chosen 23
	InfoRequestResponse infoRequestResponse;
#	define nonStandardMessage_chosen 24
	NonStandardMessage nonStandardMessage;
#	define unknownMessageResponse_chosen 25
	UnknownMessageResponse unknownMessageResponse;
    } u;
} RasMessage;
#define RasMessage_PDU 0
#define SIZE_GKPDU_Module_PDU_0 sizeof(RasMessage)

extern ASN1module_t GKPDU_Module;
extern void ASN1CALL GKPDU_Module_init();
extern void ASN1CALL GKPDU_Module_finit();

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
    extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val);
    extern void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val);
    extern void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val);
    extern void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val);
    extern void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val);
    extern void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val);
    extern void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val);
    extern void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val);
    extern void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val);
    extern void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val);
    extern void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val);
    extern void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val);
    extern void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val);
    extern void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val);
    extern void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
    extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _GKPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\gk_asn1.h ===
#ifndef _GK_ASN1_H_
#define _GK_ASN1_H_

#include "av_asn1.h"
#include "gkpdu.h"

#ifdef __cplusplus
extern "C" {
#endif


// GatekeeperInfo, H310Caps, H320Caps, H321Caps, H322Caps, H323Caps, H324Caps, VoiceCaps, T120OnlyCaps, McuInfo, TerminalInfo
#define GtkprInf_nnStndrdDt_present     GatekeeperInfo_nonStandardData_present
#define GtkprInf_nnStndrdDt             nonStandardData

// GatewayInfo
#define GtwyInf_nonStandardData_present GatewayInfo_nonStandardData_present
#define GtwyInf_nonStandardData         nonStandardData
#define _seqof2                         GatewayInfo_protocol

// EndpointType
#define EndpntTyp_nnStndrdDt_present    EndpointType_nonStandardData_present
#define EndpntTyp_nnStndrdDt            nonStandardData

// GatekeeperRequest
#define GtkprRqst_nnStndrdDt_present    GatekeeperRequest_nonStandardData_present
#define GtkprRqst_gtkprIdntfr_present   GatekeeperRequest_gatekeeperIdentifier_present
#define GtkprRqst_callServices_present  GatekeeperRequest_callServices_present
#define GtkprRqst_endpointAlias_present GatekeeperRequest_endpointAlias_present
#define GtkprRqst_nnStndrdDt            nonStandardData
#define GtkprRqst_gtkprIdntfr           gatekeeperIdentifier
#define GtkprRqst_callServices          callServices
#define GtkprRqst_endpointAlias         endpointAlias
#define _seqof3                         GatekeeperRequest_endpointAlias

// GatekeeperConfirm
#define GtkprCnfrm_nnStndrdDt_present   GatekeeperConfirm_nonStandardData_present
#define GtkprCnfrm_gtkprIdntfr_present  GatekeeperConfirm_gatekeeperIdentifier_present
#define GtkprCnfrm_nnStndrdDt           nonStandardData
#define GtkprCnfrm_gtkprIdntfr          gatekeeperIdentifier

// GatekeeperRejectReason
#define GtkprRjctRsn_rsrcUnvlbl_chosen  GatekeeperRejectReason_resourceUnavailable_chosen
#define GtkprRjctRsn_invldRvsn_chosen   GatekeeperRejectReason_invalidRevision_chosen
#define GtkprRjctRsn_undfndRsn_chosen   GatekeeperRejectReason_undefinedReason_chosen

// GatekeeperReject
#define GtkprRjct_nnStndrdDt_present    GatekeeperReject_nonStandardData_present
#define GtkprRjct_gtkprIdntfr_present   GatekeeperReject_gatekeeperIdentifier_present
#define GtkprRjct_nnStndrdDt            nonStandardData
#define GtkprRjct_gtkprIdntfr           gatekeeperIdentifier

// RegistrationRequest
#define RgstrtnRqst_nnStndrdDt_present  RegistrationRequest_nonStandardData_present
#define RgstrtnRqst_trmnlAls_present    RegistrationRequest_terminalAlias_present
#define RgstrtnRqst_gtkprIdntfr_present RegistrationRequest_gatekeeperIdentifier_present
#define RgstrtnRqst_nnStndrdDt          nonStandardData
#define _seqof4                         RegistrationRequest_callSignalAddress
#define _seqof5                         RegistrationRequest_rasAddress
#define _seqof6                         RegistrationRequest_terminalAlias
#define RgstrtnRqst_trmnlAls            terminalAlias
#define RgstrtnRqst_gtkprIdntfr         gatekeeperIdentifier

// RegistrationConfirm
#define RgstrtnCnfrm_nnStndrdDt_present RegistrationConfirm_nonStandardData_present
#define RgstrtnCnfrm_trmnlAls_present   RegistrationConfirm_terminalAlias_present
#define RCm_gtkprIdntfr_present         RegistrationConfirm_gatekeeperIdentifier_present
#define RgstrtnCnfrm_nnStndrdDt         nonStandardData
#define _seqof7                         RegistrationConfirm_callSignalAddress
#define _seqof8                         RegistrationConfirm_terminalAlias
#define RgstrtnCnfrm_trmnlAls           terminalAlias
#define RCm_gtkprIdntfr                 gatekeeperIdentifier

// RegistrationRejectReason
#define RgstrtnRjctRsn_invldRvsn_chosen RegistrationRejectReason_invalidRevision_chosen
#define RgstrtnRjctRsn_undfndRsn_chosen RegistrationRejectReason_undefinedReason_chosen
#define _seqof9                         RegistrationRejectReason_duplicateAlias

// RegistrationReject
#define RgstrtnRjct_nnStndrdDt_present  RegistrationReject_nonStandardData_present
#define RgstrtnRjct_gtkprIdntfr_present RegistrationReject_gatekeeperIdentifier_present
#define RgstrtnRjct_nnStndrdDt          nonStandardData
#define RgstrtnRjct_gtkprIdntfr         gatekeeperIdentifier

// UnregistrationRequest
#define UnrgstrtnRqst_endpntAls_present UnregistrationRequest_endpointAlias_present
#define URt_nnStndrdDt_1_present        UnregistrationRequest_nonStandardData_present
#define URt_endpntIdntfr_present        UnregistrationRequest_endpointIdentifier_present
#define _seqof10                        UnregistrationRequest_callSignalAddress
#define _seqof11                        UnregistrationRequest_endpointAlias
#define UnrgstrtnRqst_endpntAls         endpointAlias
#define URt_nnStndrdDt_1                nonStandardData
#define URt_endpntIdntfr                endpointIdentifier

// UnregistrationConfirm
#define UCm_nnStndrdDt_present          UnregistrationConfirm_nonStandardData_present
#define UCm_nnStndrdDt                  nonStandardData

// UnregRejectReason
#define UnrgRjctRsn_undfndRsn_chosen    UnregRejectReason_undefinedReason_chosen

// UnregistrationReject
#define URt_nnStndrdDt_2_present        UnregistrationReject_nonStandardData_present
#define URt_nnStndrdDt_2                nonStandardData

// AdmissionRequest
#define AdmssnRqst_nnStndrdDt_present   AdmissionRequest_nonStandardData_present
#define AdmssnRqst_callServices_present AdmissionRequest_callServices_present
#define _seqof12                        AdmissionRequest_destinationInfo
#define _seqof13                        AdmissionRequest_destExtraCallInfo
#define _seqof14                        AdmissionRequest_srcInfo
#define AdmssnRqst_nnStndrdDt           nonStandardData
#define AdmssnRqst_callServices         callServices

// AdmissionConfirm
#define AdmssnCnfrm_nnStndrdDt_present  AdmissionConfirm_nonStandardData_present
#define AdmssnCnfrm_nnStndrdDt          nonStandardData

// AdmissionRejectReason
#define ARRn_invldPrmssn_chosen         AdmissionRejectReason_invalidPermission_chosen
#define AdmssnRjctRsn_rqstDnd_chosen    AdmissionRejectReason_requestDenied_chosen
#define AdmssnRjctRsn_undfndRsn_chosen  AdmissionRejectReason_undefinedReason_chosen
#define invldEndpntIdntfr_chosen        invalidEndpointIdentifier_chosen
#define AdmssnRjctRsn_rsrcUnvlbl_chosen AdmissionRejectReason_resourceUnavailable_chosen

// AdmissionReject
#define AdmssnRjct_nnStndrdDt_present   AdmissionReject_nonStandardData_present
#define AdmssnRjct_nnStndrdDt           nonStandardData

// BandwidthRequest
#define BndwdthRqst_nnStndrdDt_present  BandwidthRequest_nonStandardData_present
#define BndwdthRqst_nnStndrdDt          nonStandardData

// BandwidthConfirm
#define BndwdthCnfrm_nnStndrdDt_present BandwidthConfirm_nonStandardData_present
#define BndwdthCnfrm_nnStndrdDt         nonStandardData

// BandRejectReason
#define BndRjctRsn_invldPrmssn_chosen   BandRejectReason_invalidPermission_chosen
#define BndRjctRsn_invldRvsn_chosen     BandRejectReason_invalidRevision_chosen
#define BndRjctRsn_undfndRsn_chosen     BandRejectReason_undefinedReason_chosen

// BandwidthReject
#define BndwdthRjct_nnStndrdDt_present  BandwidthReject_nonStandardData_present
#define BndwdthRjct_nnStndrdDt          nonStandardData

// DisengageReason
#define DsnggRsn_undefinedReason_chosen DisengageReason_undefinedReason_chosen

// DisengageRequest
#define DsnggRqst_nnStndrdDt_present    DisengageRequest_nonStandardData_present
#define DsnggRqst_nnStndrdDt            nonStandardData

// DisengageConfirm
// #define UCm_nnStndrdDt_present          DisengageConfirm_nonStandardData_present
#define UCm_nnStndrdDt                  nonStandardData

// DisengageRejectReason
#define DsnggRjctRsn_ntRgstrd_chosen    DisengageRejectReason_notRegistered_chosen

// DisengageReject
#define DsnggRjct_nnStndrdDt_present    DisengageReject_nonStandardData_present
#define DsnggRjct_nnStndrdDt            nonStandardData

// LocationRequest
#define LctnRqst_endpntIdntfr_present   LocationRequest_endpointIdentifier_present
#define LctnRqst_nnStndrdDt_present     LocationRequest_nonStandardData_present
#define LctnRqst_endpntIdntfr           endpointIdentifier
#define _seqof15                        LocationRequest_destinationInfo
#define LctnRqst_nnStndrdDt             nonStandardData

// LocationConfirm
#define LctnCnfrm_nnStndrdDt_present    LocationConfirm_nonStandardData_present
#define LctnCnfrm_nnStndrdDt            nonStandardData

// LocationRejectReason
#define LctnRjctRsn_ntRgstrd_chosen     LocationRejectReason_notRegistered_chosen
#define LctnRjctRsn_invldPrmssn_chosen  LocationRejectReason_invalidPermission_chosen
#define LctnRjctRsn_rqstDnd_chosen      LocationRejectReason_requestDenied_chosen
#define LctnRjctRsn_undfndRsn_chosen    LocationRejectReason_undefinedReason_chosen

// LocationReject
#define LctnRjct_nnStndrdDt_present     LocationReject_nonStandardData_present
#define LctnRjct_nnStndrdDt             nonStandardData

// InfoRequest
#define InfRqst_nonStandardData_present InfoRequest_nonStandardData_present
#define InfRqst_nonStandardData         nonStandardData

// InfoRequestResponse
#define InfRqstRspns_nnStndrdDt_present InfoRequestResponse_nonStandardData_present
#define InfRqstRspns_endpntAls_present  InfoRequestResponse_endpointAlias_present
#define InfRqstRspns_nnStndrdDt         nonStandardData
#define _seqof20                        InfoRequestResponse_callSignalAddress
#define _seqof21                        InfoRequestResponse_endpointAlias
#define InfRqstRspns_endpntAls          endpointAlias
#define _seqof22                        InfoRequestResponse_perCallInfo

// _seqof22 vs InfoRequestResponse_perCallInfo_Seq
#define prCllInf_nnStndrdDt_present     InfoRequestResponse_perCallInfo_Seq_nonStandardData_present
#define prCllInf_nnStndrdDt             nonStandardData


#ifdef __cplusplus
}
#endif


#endif // _GK_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\gkicom.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 *
 *	$Revision:   1.3  $
 *	$Date:   10 Jan 1997 17:41:10  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 17:41:10   CHULME
 * Changed CallReturnInfo structure to contain CRV and conferenceID
 * 
 *    Rev 1.2   10 Jan 1997 16:06:54   CHULME
 * Removed stdafx.h check for non MFC GKI implementation
 * 
 *    Rev 1.1   27 Dec 1996 14:37:22   EHOWARDX
 * Split out error codes into GKIERROR.H.
 * 
 *    Rev 1.0   11 Dec 1996 14:49:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   22 Nov 1996 15:25:44   CHULME
 * Added VCS log to the header
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKICOM_H
#define GKICOM_H

#include "apierror.h"
#include "gkierror.h"
#include "gkpdu.h"
#include "gk_asn1.h"

// The following GKVER_xxx constants define the expiration date of GKI.DLL
#define GKVER_EXPIRE_YEAR          1997
#define GKVER_EXPIRE_MONTH         10
#define GKVER_EXPIRE_DAY           31

typedef struct SeqTransportAddr {
	struct SeqTransportAddr	*next;
	TransportAddress		value;
} SeqTransportAddr;

typedef struct SeqAliasAddr {
	struct SeqAliasAddr		*next;
	AliasAddress			value;
} SeqAliasAddr;

typedef struct CallReturnInfo {
	HANDLE					hCall;
	CallModel				callModel;
	TransportAddress		destCallSignalAddress;
	BandWidth				bandWidth;
	CallReferenceValue		callReferenceValue;
	ConferenceIdentifier	conferenceID;
	WORD					wError;
} CallReturnInfo;

// Version Information for GKI Interface
#define GKI_VERSION				21	// TBD - reset to 1 after testing

// wMsg literals - these are added to the wBaseMessage supplied by the user
#define GKI_REG_CONFIRM			1
#define GKI_REG_DISCOVERY		2
#define GKI_REG_REJECT			3
#define GKI_REG_BYPASS			4

#define GKI_UNREG_CONFIRM		5
#define GKI_UNREG_REJECT		6

#define GKI_ADM_CONFIRM			7
#define GKI_ADM_REJECT			8

#define GKI_BW_CONFIRM			9
#define GKI_BW_REJECT			0xa

#define GKI_DISENG_CONFIRM		0xb
#define GKI_DISENG_REJECT		0xc

#define GKI_LOCATION_CONFIRM	0xd
#define GKI_LOCATION_REJECT		0xe

#define GKI_ERROR				0xf
#define MAX_ASYNC_MSGS			0xf

#define HR_SEVERITY_MASK				0x80000000
#define HR_R_MASK						0x40000000
#define HR_C_MASK						0x20000000
#define HR_N_MASK						0x10000000
#define HR_R2_MASK						0x08000000
#define HR_FACILITY_MASK				0x07ff0000
#define HR_CODE_MASK					0x0000ffff

#endif // GKICOM_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\port32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  
//   This source is supplied under the terms of a licence agreement or
//   non-disclosure statement with Intel Corporation and may not be copied
//   nor disclosed except in accordance with the terms of that agreement.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PORT32.H
// Stuff to make porting from Win3.1 to Win32 a little less hellish.
//////////////////////////////////////////////////////////////////////////////
#ifndef PORT32_H
#define PORT32_H


//////////////////////////////////////////////////////////////////////////////
// some convenient, explicit types
//////////////////////////////////////////////////////////////////////////////
typedef short INTEGER_16;
typedef int INTEGER_32;
typedef unsigned short UINTEGER_16;
typedef unsigned int UINTEGER_32;
typedef short BOOLEAN_16;

#ifndef _BASETSD_H_
typedef short INT16;
typedef int INT32;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
#endif

typedef short BOOL16;
	
//////////////////////////////////////////////////////////////////////////////
// macros to make old keywords go away
//////////////////////////////////////////////////////////////////////////////
#define __pascal
#define _pascal
#define _far
#define __far
#define _export
#define __export
#define _huge
#define huge
#define __huge
#define  __segment
#define _HFAR_
#define _loadds
#define __loadds

//////////////////////////////////////////////////////////////////////////////
// other macros that may or may not be handy
//////////////////////////////////////////////////////////////////////////////
#define WRITE OF_WRITE

#define OFFSETOF(lp)        (int) (lp)
#define SELECTOROF

#define GLOBALHANDLE(lp)      GlobalHandle(lp)
#define GLOBALHANDLEFUNC(lp)  GlobalHandle(lp)
#define LOCALHANDLE(lp)       LocalHandle(lp)
#define LOCALHANDLEFUNC(lp)   LocalHandle(lp)


#define _AfxGetPtrFromFarPtr(p)   ((void*)(p))
#define GETWINDOWHINSTANCE(hWnd)  GetWindowLong(hWnd ,GWL_HINSTANCE)
#define GETWINDOWHPARENT(hWnd)    GetWindowLong(hWnd, GWL_HWNDPARENT)
#define GETWINDOWID(hWnd)         GetWindowLong(hWnd, GWL_ID)

#define SETCLASSCURSOR(hWnd,NewVal)  SetClassLong(hWnd ,GCL_HCURSOR,NewVal)

//////////////////////////////////////////////////////////////////////////////
// Name of shared mutex for serializing access to 16-bit data stack
//////////////////////////////////////////////////////////////////////////////
#define STR_DATASTACKMUX "_mux_DataStack"

#endif // PORT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\h245api.h ===
#ifndef H245API_H
#define H245API_H

/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245api.h  $
 *  $Revision:   1.64  $
 *  $Modtime:   04 Mar 1997 16:51:38  $
 *  $Log:   S:/sturgeon/src/include/vcs/h245api.h_v  $
 * 
 *    Rev 1.64   04 Mar 1997 17:32:36   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 * 
 *    Rev 1.63   26 Feb 1997 10:56:20   MANDREWS
 * Added H245_MAX_CAPID.
 * 
 *    Rev 1.62   Feb 24 1997 18:28:26   tomitowx
 * multiple modedescriptor support
 * 
 *    Rev 1.61   19 Dec 1996 17:16:10   EHOWARDX
 * Now using ASN.1 compiler C++ flag.
 * 
 *    Rev 1.60   17 Dec 1996 17:14:12   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 * 
 *    Rev 1.59   12 Dec 1996 11:24:38   EHOWARDX
 * Backed out H245_CONF_H323_OLD change.
 * 
 *    Rev 1.57   11 Dec 1996 13:46:46   SBELL1
 * Changed H245Init to return linkLayer Physical ID
 * 
 *    Rev 1.56   24 Oct 1996 15:57:54   MANDREWS
 * Fixed typo in last update.
 * 
 *    Rev 1.55   Oct 21 1996 17:11:00   mandrews
 * Fixed type in last check-in.
 * 
 *    Rev 1.54   Oct 21 1996 16:41:20   mandrews
 * Added H245_MASTER_SLAVE_CONFLICT as an additional openChannelReject
 * reason code.
 * 
 *    Rev 1.53   17 Oct 1996 18:17:54   EHOWARDX
 * Changed general string to always be Unicode.
 * 
 *    Rev 1.52   14 Oct 1996 14:00:28   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.51   03 Sep 1996 18:09:54   EHOWARDX
 * 
 * Changed some parameters to const.
 * Changed H245_REQ_ENTRY_H243_CONFERENCE_ID to H245_REQ_ENTER_H243_CONFERENCE
 * 
 *    Rev 1.50   15 Aug 1996 14:33:48   EHOWARDX
 * Changed definition of H245_COMM_MODE_ENTRY_T as per Mike Andrews' request.
 * 
 *    Rev 1.49   24 Jul 1996 15:18:16   EHOWARDX
 * Backed out change of IndNonstandardRequest to IndNonstandardReq,
 * IndNonstandardResponse to IndNonStandardRsp, and IndNonstandardCommand to
 * IndNonstandardCmd to make less work for upper layers (CCTEST).
 * 
 *    Rev 1.48   19 Jul 1996 14:12:20   EHOWARDX
 * 
 * Added indication callback structure for CommunicationModeResponse and
 * CommunicationModeCommand.
 * 
 *    Rev 1.47   19 Jul 1996 12:50:30   EHOWARDX
 * 
 * Multipoint clean-up.
 * 
 *    Rev 1.46   16 Jul 1996 17:53:48   unknown
 * Added FNS indication.
 * 
 *    Rev 1.45   16 Jul 1996 11:51:58   EHOWARDX
 * 
 * Changed ERROR_LOCAL_BASE_ID to ERROR_BASE_ID.
 * 
 *    Rev 1.44   16 Jul 1996 11:46:10   EHOWARDX
 * 
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET (changing the existing
 * mux cap should not be an error).
 * 
 *    Rev 1.43   11 Jul 1996 18:42:14   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.42   10 Jul 1996 11:33:42   unknown
 * Changed error base.
 * 
 *    Rev 1.41   01 Jul 1996 22:07:24   EHOWARDX
 * Added Conference and CommunicationMode structures and API functions.
 * 
 *    Rev 1.40   18 Jun 1996 14:48:54   EHOWARDX
 * 
 * Bumped version number to 2 and modified H245MaintenanceLoopRelease()
 * and associated Confirms.
 * 
 *    Rev 1.39   14 Jun 1996 18:59:38   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.38   31 May 1996 18:19:46   EHOWARDX
 * Brought error codes in line with STURERR.DOC guidelines.
 * 
 *    Rev 1.37   30 May 1996 23:37:26   EHOWARDX
 * Clean up.
 * 
 *    Rev 1.36   30 May 1996 13:55:02   EHOWARDX
 * Changed H245EndConnection to H245EndSession.
 * Removed H245_CONF_ENDCONNECTION.
 * 
 *    Rev 1.35   29 May 1996 14:23:58   EHOWARDX
 * Changed definition of H245_ERROR_OK back to 0 (NOERROR == S_OK == 0).
 * 
 *    Rev 1.34   29 May 1996 13:19:50   EHOWARDX
 * RESULT to HRESULT conversion.
 * 
 *    Rev 1.33   24 May 1996 23:12:56   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.32   21 May 1996 18:23:58   EHOWARDX
 * 
 * Added dwTransId parameter to H245RequestMultiplexEntry,
 * H245RequestMode, and H245MaintenanceLoopRequest.
 * 
 *    Rev 1.31   20 May 1996 14:14:42   EHOWARDX
 * Fixed typo.
 * 
 *    Rev 1.30   20 May 1996 14:05:20   EHOWARDX
 * Removed dwTransId formal parameter from H245EndConnection().
 * 
 *    Rev 1.29   16 May 1996 15:51:56   EHOWARDX
 * Fixed typo in H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.28   16 May 1996 10:57:46   unknown
 * Added H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.27   14 May 1996 20:20:14   EHOWARDX
 * Removed H245_IND_SYS.
 * 
 *    Rev 1.26   14 May 1996 19:00:58   EHOWARDX
 * Deleted unused H245_SYSCON_xxx values.
 * 
 *    Rev 1.25   14 May 1996 16:58:48   EHOWARDX
 * Changed H245_IND_CAPDESC_T To H245_TOTCAPDESC_T.
 * H245EnumCaps() cap desc callback now takes single pointer to
 * H245_TOTCAPDESC_T instead of separate H245_CAPDESCID_T and
 * H245_CAPDESC_T pointer.
 * 
 *    Rev 1.24   13 May 1996 23:13:46   EHOWARDX
 * Everything ready for Micrsoft drop on the 17th.
 * 
 *    Rev 1.23   13 May 1996 15:43:16   EHOWARDX
 * Changed return type of H245CopyCapDescriptor from H245_CAPDESC_T pointer
 * to H245_TOTCAPDESC_T pointer.
 * 
 *    Rev 1.22   13 May 1996 14:05:16   EHOWARDX
 * Added H245CopyCapDescriptor() and H245FreeCapDescriptor().
 * 
 *    Rev 1.21   11 May 1996 20:00:34   EHOWARDX
 * Changed IS1381 to IS13818 (correct name for capability).
 * Changed H245SystemControl() - eliminated dwTransId and added
 * H245_SYSCON_GET_XXX requests.
 * 
 *    Rev 1.20   10 May 1996 17:38:28   unknown
 * Changed H245GetCaps and H245EnumCaps to also return Cap Descriptors.
 * 
 *    Rev 1.19   09 May 1996 20:22:58   EHOWARDX
 * Latest and greatest...
 * 
 *    Rev 1.35   09 May 1996 19:38:14   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.34   06 May 1996 13:19:44   EHOWARDX
 * Moved enums out of structures.
 * Added H245NonStandardH221() and H245NonStandardObject().
 * 
 *    Rev 1.33   01 May 1996 19:29:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address to H245_xxx.
 * 
 *    Rev 1.32   27 Apr 1996 21:04:26   EHOWARDX
 * Changed channel numbers to words, added new open/open ack fields.
 * 
 *    Rev 1.31   26 Apr 1996 15:57:14   EHOWARDX
 * Added new Terminal Capabilities.
 * 
 *    Rev 1.27.1.6   25 Apr 1996 17:53:06   EHOWARDX
 * Added H245_INVALID_ID, currently set to zero, should be 0xFFFFFFFF later.
 * 
 *    Rev 1.27.1.5   25 Apr 1996 16:50:04   EHOWARDX
 * Added new functions as per API Changes spec.
 * 
 *    Rev 1.27.1.4   24 Apr 1996 20:57:30   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 * 
 *    Rev 1.27.1.3   18 Apr 1996 15:56:42   EHOWARDX
 * Updated to 1.30.
 * 
 *    Rev 1.27.1.2   16 Apr 1996 20:09:52   EHOWARDX
 * Added new H2250LogicalChannelParameter fields.
 * 
 *    Rev 1.27.1.1   16 Apr 1996 18:45:24   EHOWARDX
 * Added silenceSupression to H.225.0 Logical Channel Parameters.
 * 
 *    Rev 1.27.1.0   03 Apr 1996 15:56:14   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.27   02 Apr 1996 08:29:44   cjutzi
 * - Changed CapDescriptor API
 * 
 *    Rev 1.26   01 Apr 1996 16:46:50   cjutzi
 * 
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 * 
 *    Rev 1.25   29 Mar 1996 14:55:52   cjutzi
 * 
 * - added USERINPUT stuff
 * - Added hooks for stats in SYSCON H245SystemControl
 * 
 *    Rev 1.24   27 Mar 1996 10:55:40   cjutzi
 * - added c++ wrapper for API calls..
 *
 *    Rev 1.23   20 Mar 1996 14:42:46   cjutzi
 * - added ERROR NO_CAPDESC
 *
 *    Rev 1.22   18 Mar 1996 15:14:56   cjutzi
 *
 * - added RxPort and TEST_TIMER
 *
 *    Rev 1.21   12 Mar 1996 15:49:24   cjutzi
 *
 * - implemented locking
 * - added EndSession
 * - added Shutdown
 *
 *
 *    Rev 1.20   08 Mar 1996 14:06:04   cjutzi
 *
 * - Removed Simultanious capability api
 * - added CapabilityDescriptor api.. (very similar.. made more sence)
 * - compeleted Mux Table upcall information..
 *
 *    Rev 1.19   06 Mar 1996 08:45:58   cjutzi
 *
 * - added ERROR ASN1
 *
 *    Rev 1.18   05 Mar 1996 17:32:24   cjutzi
 *
 * - master slave indication message from Hani.. implemented..
 *   added H245_IND_MSTSLV ..
 *
 *    Rev 1.17   05 Mar 1996 16:36:46   cjutzi
 *
 * - removed MUX_ENTRY_DESC_T .. cleaned it up.. don't need it..
 *
 *    Rev 1.16   05 Mar 1996 10:06:30   cjutzi
 *
 * - added mux table entry stuff
 * - changed errors to map to 10000
 *
 *    Rev 1.15   01 Mar 1996 13:46:20   cjutzi
 * - added more error messages
 *
 *    Rev 1.14   29 Feb 1996 17:27:38   cjutzi
 *
 * - bi-directional channel working
 *
 *    Rev 1.13   29 Feb 1996 11:33:50   cjutzi
 * - fixed bug w/ H245_CONF_IND_T .. as global union.. fixed to be
 *   struct
 *
 *    Rev 1.12   29 Feb 1996 08:26:48   cjutzi
 *
 * - added 2 error messages (SIMCAPID and DATA_FORMAT)
 *
 *    Rev 1.11   27 Feb 1996 13:28:50   cjutzi
 * - added global protocol id H245_PROTOID
 *
 *    Rev 1.10   26 Feb 1996 17:24:10   cjutzi
 *
 * -  added MiscCommand.. had to add channel to H245_IND_MISC_T..
 *
 *    Rev 1.9   26 Feb 1996 11:07:24   cjutzi
 *
 * - added simultanoius caps..
 *
 *    Rev 1.8   16 Feb 1996 12:59:26   cjutzi
 * - added tracing and debug..
 * - got close to work.. Added structure to H245_IND_T.. new CLOSE indication
 *
 *    Rev 1.7   15 Feb 1996 14:13:08   cjutzi
 *
 * - re-arranged the AL_T entries for more clairity..
 *
 *    Rev 1.6   15 Feb 1996 10:48:30   cjutzi
 *
 * - major changes..
 * - added MUX_T
 * - changed H245_IND_T
 * - changed IND_OPEN/IND_OPEN_NEEDSRSP etc..
 *
 *    Rev 1.5   09 Feb 1996 16:14:04   cjutzi
 *
 * - removed init_success
 * - removed shutdown success
 * - added masterslave type for callback/confirm
 * - added SYSCON TraceLvl
 *
 *****************************************************************************/

//
// H.245 return codes
//
#if defined(OIL)

#include "common.x"
#define HRESULT RESULT
#define ERROR_BASE_ID             0x8000
#define MAKE_H245_ERROR(error)          (error)
#define H245_ERROR_OK                   0
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_BASE_ID+0x01) /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_BASE_ID+0x02) /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_BASE_ID+0x03) /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_BASE_ID+0x04) /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_BASE_ID+0x05) /* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_BASE_ID+0x06) /* system is not in the connected state             */

#else

#pragma warning( disable : 4115 4201 4214 4514 )
#include "apierror.h"
#define H245_ERROR_OK                   NOERROR
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_INVALID_DATA)       /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_OUTOFMEMORY)        /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_NOT_SUPPORTED)      /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_INVALID_PARAMETER)  /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_ALREADY_INITIALIZED)/* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_NOT_CONNECTED)      /* system is not in the connected state             */

#endif

#define H245_ERROR_NORESOURCE           MAKE_H245_ERROR(ERROR_BASE_ID+0x10) /* No resources left for this call                  */
#define H245_ERROR_NOTIMP               MAKE_H245_ERROR(ERROR_BASE_ID+0x11) /* H245 feature should be implemented.. but is not  */
#define H245_ERROR_SUBSYS               MAKE_H245_ERROR(ERROR_BASE_ID+0x12) /* subsystem failure.. error unknown                */
#define H245_ERROR_FATAL                MAKE_H245_ERROR(ERROR_BASE_ID+0x13) /* fatal error.. system will be coming down..       */
#define H245_ERROR_MAXTBL               MAKE_H245_ERROR(ERROR_BASE_ID+0x14) /* you have reached the maxium number of tbl entries*/
#define H245_ERROR_CHANNEL_INUSE        MAKE_H245_ERROR(ERROR_BASE_ID+0x15) /* channel is currently in use                      */
#define H245_ERROR_INVALID_CAPID        MAKE_H245_ERROR(ERROR_BASE_ID+0x16) /* Invalid Cap ID.. can not be found                */
#define H245_ERROR_INVALID_OP           MAKE_H245_ERROR(ERROR_BASE_ID+0x17) /* Invalid operation at this time..                 */
#define H245_ERROR_UNKNOWN              MAKE_H245_ERROR(ERROR_BASE_ID+0x18) /* unknown error                                    */
#define H245_ERROR_NOBANDWIDTH          MAKE_H245_ERROR(ERROR_BASE_ID+0x19) /* Bandwidth will not allow this                    */
#define H245_ERROR_LOSTCON              MAKE_H245_ERROR(ERROR_BASE_ID+0x1A) /* System connection .. channel 0 was lost          */
#define H245_ERROR_INVALID_MUXTBLENTRY  MAKE_H245_ERROR(ERROR_BASE_ID+0x1B) /* Invalid Multiplex Table Entry                    */
#define H245_ERROR_INVALID_INST         MAKE_H245_ERROR(ERROR_BASE_ID+0x1C) /* instance is either no longer valid or is invalid */
#define H245_ERROR_INPROCESS            MAKE_H245_ERROR(ERROR_BASE_ID+0x1D) /* request is denied.. action already in process    */
#define H245_ERROR_INVALID_STATE        MAKE_H245_ERROR(ERROR_BASE_ID+0x1E) /* Not proper state to process request              */
#define H245_ERROR_TIMEOUT              MAKE_H245_ERROR(ERROR_BASE_ID+0x1F) /* Timeout occured                                  */
#define H245_ERROR_INVALID_CHANNEL      MAKE_H245_ERROR(ERROR_BASE_ID+0x20) /* Invalid channel                                  */
#define H245_ERROR_INVALID_CAPDESCID    MAKE_H245_ERROR(ERROR_BASE_ID+0x21) /* Invalid Capbility Descriptor ID                  */
#define H245_ERROR_CANCELED             MAKE_H245_ERROR(ERROR_BASE_ID+0x22) /* operation you are responding to has been canceled*/
#define H245_ERROR_MUXELEMENT_DEPTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x23) /* Mux Table Entry is too complex.. MAX recursion   */
#define H245_ERROR_MUXELEMENT_WIDTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x24) /* Mux Table Entry has reached max subelement width */
#define H245_ERROR_ASN1                 MAKE_H245_ERROR(ERROR_BASE_ID+0x25) /* ASN1 PDU compiler error - see PDU log            */
#define H245_ERROR_NO_MUX_CAPS          MAKE_H245_ERROR(ERROR_BASE_ID+0x26) /* Mux Capabilities have not been loaded            */
#define H245_ERROR_NO_CAPDESC           MAKE_H245_ERROR(ERROR_BASE_ID+0x27) /* No Capability Descriptors set                    */



// declare exported functions
#if defined(H245DLL_EXPORT)
#define H245DLL __declspec (dllexport)
#else   // (H245DLL_EXPORT)
#define H245DLL __declspec (dllimport)
#endif  // (H245DLL_EXPORT)



/************************************/
/* ASN.1 DATASTRUCTURES ABSTRACTION */
/************************************/

#include "h245asn1.h"

typedef struct NonStandardIdentifier    H245_NONSTANDID_T;

typedef struct NonStandardParameter     H245_NONSTANDARD_PARAMETER_T;

typedef H245_NONSTANDARD_PARAMETER_T    H245_CAP_NONSTANDARD_T;

typedef struct H261VideoCapability      H245_CAP_H261_T;

typedef struct H262VideoCapability      H245_CAP_H262_T;

typedef struct H263VideoCapability      H245_CAP_H263_T;

typedef struct IS11172VideoCapability   H245_CAP_VIS11172_T;

typedef struct IS11172AudioCapability   H245_CAP_AIS11172_T;

typedef struct IS13818AudioCapability   H245_CAP_IS13818_T;

typedef struct DataApplicationCapability H245_CAP_DATAAPPLICATION_T;

typedef struct H222Capability           H245_CAP_H222_T;

typedef struct H223Capability           H245_CAP_H223_T;

typedef struct V76Capability            H245_CAP_VGMUX_T;

typedef struct H2250Capability          H245_CAP_H2250_T;

typedef struct ConferenceCapability     H245_CAP_CONFERENCE_T;

typedef struct TerminalLabel            H245_TERMINAL_LABEL_T;

#define PDU_T           MltmdSystmCntrlMssg
#define H245_ACCESS_T   NetworkAccessParameters
typedef unsigned long  H245_INST_T;
typedef unsigned short H245_CHANNEL_T;
typedef unsigned long  H245_PORT_T;
#define H245_INVALID_ID          ((H245_INST_T)0)
#define H245_INVALID_CHANNEL     ((H245_CHANNEL_T)0)
#define H245_INVALID_PORT_NUMBER ((H245_PORT_T)-1)

typedef struct
{
  unsigned int    length;
  unsigned char  *value;
} H245_OCTET_STRING_T;



/************************/
/* H245 ABSTRACTION     */
/************************/

/* H245_CAPDIR_T */
typedef enum
{
  H245_CAPDIR_DONTCARE = 0,
  H245_CAPDIR_RMTRX,
  H245_CAPDIR_RMTTX,
  H245_CAPDIR_RMTRXTX,
  H245_CAPDIR_LCLRX,
  H245_CAPDIR_LCLTX,
  H245_CAPDIR_LCLRXTX
} H245_CAPDIR_T;

/* H245_DATA_T */
typedef enum
{
  H245_DATA_DONTCARE = 0,
  H245_DATA_NONSTD,
  H245_DATA_NULL,
  H245_DATA_VIDEO,
  H245_DATA_AUDIO,
  H245_DATA_DATA,
  H245_DATA_ENCRYPT_D,
  H245_DATA_CONFERENCE,
  H245_DATA_MUX         /* mux parameters */
} H245_DATA_T;

/* H245_CLIENT_T */
typedef enum
{
  H245_CLIENT_DONTCARE = 0,     // For H245EnumCap/H245GetCap
  H245_CLIENT_NONSTD,

  H245_CLIENT_VID_NONSTD,
  H245_CLIENT_VID_H261,
  H245_CLIENT_VID_H262,
  H245_CLIENT_VID_H263,
  H245_CLIENT_VID_IS11172,

  H245_CLIENT_AUD_NONSTD,
  H245_CLIENT_AUD_G711_ALAW64,
  H245_CLIENT_AUD_G711_ALAW56,
  H245_CLIENT_AUD_G711_ULAW64,
  H245_CLIENT_AUD_G711_ULAW56,
  H245_CLIENT_AUD_G722_64,
  H245_CLIENT_AUD_G722_56,
  H245_CLIENT_AUD_G722_48,
  H245_CLIENT_AUD_G723,
  H245_CLIENT_AUD_G728,
  H245_CLIENT_AUD_G729,
  H245_CLIENT_AUD_GDSVD,
  H245_CLIENT_AUD_IS11172,
  H245_CLIENT_AUD_IS13818,

  H245_CLIENT_DAT_NONSTD,
  H245_CLIENT_DAT_T120,
  H245_CLIENT_DAT_DSMCC,
  H245_CLIENT_DAT_USERDATA,
  H245_CLIENT_DAT_T84,
  H245_CLIENT_DAT_T434,
  H245_CLIENT_DAT_H224,
  H245_CLIENT_DAT_NLPID,
  H245_CLIENT_DAT_DSVD,
  H245_CLIENT_DAT_H222,

  H245_CLIENT_ENCRYPTION_TX,
  H245_CLIENT_ENCRYPTION_RX,
  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_CLIENT_MUX_NONSTD,
  H245_CLIENT_MUX_H222,
  H245_CLIENT_MUX_H223,
  H245_CLIENT_MUX_VGMUX,
  H245_CLIENT_MUX_H2250,
  H245_CLIENT_MUX_H223_ANNEX_A

} H245_CLIENT_T;


/* H245_CAP_T */
typedef union
{
  H245_CAP_NONSTANDARD_T        H245_NonStd;            /* not implemented */

  H245_CAP_NONSTANDARD_T        H245Vid_NONSTD;
  H245_CAP_H261_T               H245Vid_H261;
  H245_CAP_H262_T               H245Vid_H262;
  H245_CAP_H263_T               H245Vid_H263;
  H245_CAP_VIS11172_T           H245Vid_IS11172;

  H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
  unsigned short                H245Aud_G711_ALAW64;
  unsigned short                H245Aud_G711_ALAW56;
  unsigned short                H245Aud_G711_ULAW64;
  unsigned short                H245Aud_G711_ULAW56;
  unsigned short                H245Aud_G722_64;
  unsigned short                H245Aud_G722_56;
  unsigned short                H245Aud_G722_48;
  H245_CAP_G723_T               H245Aud_G723;
  unsigned short                H245Aud_G728;
  unsigned short                H245Aud_G729;
  unsigned short                H245Aud_GDSVD;
  H245_CAP_AIS11172_T           H245Aud_IS11172;
  H245_CAP_IS13818_T            H245Aud_IS13818;

  H245_CAP_DATAAPPLICATION_T    H245Dat_NONSTD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T120;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSMCC;
  H245_CAP_DATAAPPLICATION_T    H245Dat_USERDATA;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T84;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T434;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H224;
  H245_CAP_DATAAPPLICATION_T    H245Dat_NLPID;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSVD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H222;

  ASN1_BOOL                     H245Encryption_TX;
  unsigned char                 H245Encryption_RX;
  H245_CAP_CONFERENCE_T         H245Conference;

  // Multiplex capabilities
  H245_CAP_NONSTANDARD_T        H245Mux_NONSTD;
  H245_CAP_H222_T               H245Mux_H222;
  H245_CAP_H223_T               H245Mux_H223;
  H245_CAP_VGMUX_T              H245Mux_VGMUX;
  H245_CAP_H2250_T              H245Mux_H2250;

} H245_CAP_T;

/* H245_CAPID_T */
typedef unsigned short H245_CAPID_T;
#define H245_INVALID_CAPID      ((H245_CAPID_T)-1)
#define H245_MAX_CAPID			(((H245_CAPID_T)-1) / 2)

/* H245_CAPDESCID_T */
typedef unsigned short H245_CAPDESCID_T;
#define H245_INVALID_CAPDESCID  ((H245_CAPDESCID_T)-1)

/* H245_SIMCAP_T */
#define H245_MAX_ALTCAPS        16
typedef struct
{
  unsigned short Length;                     /* number of CapId's in Array   */
  H245_CAPID_T AltCaps[H245_MAX_ALTCAPS];   /* list of alternatives CapId's */

} H245_SIMCAP_T;

#define H245_MAX_SIMCAPS        16
/* H245_CAPDESC_T */
typedef struct
{
  unsigned short Length;
  H245_SIMCAP_T SimCapArray[H245_MAX_SIMCAPS];

} H245_CAPDESC_T;

/* H245_TOTCAPDESC_T */
typedef struct
{
  H245_CAPDESCID_T      CapDescId;
  H245_CAPDESC_T        CapDesc;

} H245_TOTCAPDESC_T;

/* H245_TOTCAP_T */
typedef struct
{
  H245_CAPDIR_T   Dir;
  H245_DATA_T     DataType;
  H245_CLIENT_T   ClientType;
  H245_CAPID_T    CapId;
  H245_CAP_T      Cap;

} H245_TOTCAP_T;



/* H245_CONFIG_T */
typedef enum
{
  H245_CONF_H324 = 1,
  H245_CONF_H323,
  H245_CONF_H310,
  H245_CONF_GVD

} H245_CONFIG_T;




/* H245_ACC_REJ_T */

typedef unsigned long H245_ACC_REJ_T;

#define H245_ACC                        0
#define H245_REJ                        1 // unspecified

// Master Slave Determination reject causes
#define H245_REJ_MSD_IDENTICAL          identicalNumbers_chosen

// Terminal Capability Set reject causes
#define H245_REJ_UNDEF_TBL_ENTRY        undefinedTableEntryUsed_chosen
#define H245_REJ_DIS_CAP_EXCEED         dscrptrCpctyExcdd_chosen
#define H245_REJ_TBLENTRY_CAP_EXCEED    tblEntryCpctyExcdd_chosen

// Open Logical Channel reject causes
#define H245_REJ_REV_PARAM              unstblRvrsPrmtrs_chosen
#define H245_REJ_TYPE_NOTSUPPORT        dataTypeNotSupported_chosen
#define H245_REJ_TYPE_NOTAVAIL          dataTypeNotAvailable_chosen
#define H245_REJ_TYPE_UNKNOWN           unknownDataType_chosen
#define H245_REJ_AL_COMB                dtTypALCmbntnNtSpprtd_chosen
#define H245_REJ_MULTICAST              mltcstChnnlNtAllwd_chosen
#define H245_REJ_BANDWIDTH              insufficientBandwidth_chosen
#define H245_REJ_STACK                  sprtStckEstblshmntFld_chosen
#define H245_REJ_SESSION_ID             invalidSessionID_chosen
#define H245_REJ_MASTER_SLAVE_CONFLICT  masterSlaveConflict_chosen

// Request Channel Close reject causes - use H245_REJ

// Multiplex Table Entry Send reject causes
#define H245_REJ_MUX_COMPLICATED        descriptorTooComplex_chosen

// Request Mode reject causes
#define H245_REJ_UNAVAILABLE            modeUnavailable_chosen
#define H245_REJ_MULTIPOINT             multipointConstraint_chosen
#define H245_REJ_DENIED                 requestDenied_chosen




/* H245_ACC_REJ_MUX_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_ACC_REJ_MUX_T[15];

/* H245_H222_LOGICAL_PARAM_T */
typedef struct
{
  unsigned short        resourceID;
  unsigned short        subChannelID;
  ASN1_BOOL             pcr_pidPresent;
  unsigned short        pcr_pid;                // optional
  H245_OCTET_STRING_T   programDescriptors;     // optional
  H245_OCTET_STRING_T   streamDescriptors;      // optional
} H245_H222_LOGICAL_PARAM_T;

/* H245_H223_LOGICAL_PARAM_T */
typedef enum
{
  H245_H223_AL_NONSTD        = H223LCPs_aLTp_nnStndrd_chosen,
  H245_H223_AL_AL1FRAMED     = H223LCPs_aLTp_al1Frmd_chosen,
  H245_H223_AL_AL1NOTFRAMED  = H223LCPs_aLTp_al1NtFrmd_chosen,
  H245_H223_AL_AL2NOSEQ      = H223LCPs_aLTp_a2WSNs_1_chosen,
  H245_H223_AL_AL2SEQ        = H223LCPs_aLTp_a2WSNs_2_chosen,
  H245_H223_AL_AL3           = H223LCPs_aLTp_al3_chosen

} H245_H223_AL_T;

typedef struct
{
  H245_H223_AL_T                AlType;
  unsigned int                  SndBufSize;   // 0..16777215
  unsigned char                 CtlFldOctet;  // 0..2
  ASN1_BOOL                     SegmentFlag;
  H245_NONSTANDARD_PARAMETER_T  H223_NONSTD;

} H245_H223_LOGICAL_PARAM_T;

/* H245_VGMUX_LOGICAL_PARAM_T */
typedef enum
{
  H245_V76_CRC8BIT  = crc8bit_chosen,
  H245_V76_CRC16BIT = crc16bit_chosen,
  H245_V76_CRC32BIT = crc32bit_chosen
} H245_V76_CRC_LENGTH_T;

typedef enum
{
  H245_V76_WITH_ADDRESS    = wAddress_chosen,
  H245_V76_WITHOUT_ADDRESS = woAddress_chosen
} H245_V76_SUSPEND_RESUME_T;

typedef enum
{
  H245_V76_ERM   = eRM_chosen,
  H245_V76_UNERM = uNERM_chosen
} H245_V76_MODE_T;

typedef enum
{
  H245_V76_REJ   = rej_chosen,
  H245_V76_SREJ  = sREJ_chosen,
  H245_V76_MSREJ = mSREJ_chosen
} H245_V76_RECOVERY_T;

typedef struct
{
  H245_V76_CRC_LENGTH_T       crcLength;
  unsigned short              n401;
  ASN1_BOOL                   loopbackTestProcedure;
  H245_V76_SUSPEND_RESUME_T   suspendResume;
  ASN1_BOOL                   uIH;
  H245_V76_MODE_T             mode;
  unsigned short              windowSize;       // Only valid if mode = ERM
  H245_V76_RECOVERY_T         recovery;         // Only valid if mode = ERM
  ASN1_BOOL                   audioHeaderPresent;
} H245_VGMUX_LOGICAL_PARAM_T;


typedef struct
{
  unsigned char               type;
  /* Note: All unicast types should be odd */
#define H245_IP_UNICAST       1
#define H245_IP_MULTICAST     2
#define H245_IP6_UNICAST      3
#define H245_IP6_MULTICAST    4
#define H245_IPSSR_UNICAST    5  // IP Strict Source Route
#define H245_IPLSR_UNICAST    6  // IP Loose  Source Route
#define H245_IPX_UNICAST      9
#define H245_NETBIOS_UNICAST 11
  union
  {
    // type == H245_IP_UNICAST or H245_IP_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
    } ip;

    // type == H245_IP6_UNICAST or H245_IP6_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[16];
    } ip6;

    // type == H245_IPSSR_UNICAST or H245_IPLSR_UNICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
       unsigned char *        route;            // Routing info
       unsigned long          dwCount;          // Number of addresses in above
    } ipSourceRoute;

    // type == H245_IPX_UNICAST
    struct
    {
       unsigned char          node[6];
       unsigned char          netnum[4];
       unsigned char          tsapIdentifier[2];
    } ipx;

    // type == H245_NETBIOS_UNICAST
    unsigned char             netBios[16];
  } u;
} H245_TRANSPORT_ADDRESS_T;

/* H245_H2250_LOGICAL_PARAM_T */
typedef struct
{
  // Note: first 8 fields MUST be same as H245_H2250ACK_LOGICAL_PARAM_T
  H2250LCPs_nnStndrdLink      nonStandardList;              // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;        // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent; // TRUE if previous field used
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
  ASN1_BOOL                   silenceSuppression;           // TRUE if using silence suppression
  ASN1_BOOL                   silenceSuppressionPresent;    // TRUE if previous field used
  H245_TERMINAL_LABEL_T       destination;                  // Terminal label for destination
  ASN1_BOOL                   destinationPresent;           // TRUE if previous field used
  ASN1_BOOL                   h261aVideoPacketization;
} H245_H2250_LOGICAL_PARAM_T;

/* H245_H2250ACK_LOGICAL_PARAM_T */
typedef struct
{
  H2250LCAPs_nnStndrdLink     nonStandardList;             // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                // Transport address
  ASN1_BOOL                   mediaChannelPresent;         // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;         // Forward RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;  // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;       // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent;// TRUE if previous field used
  unsigned char               sessionID;                   // 1..255
  ASN1_BOOL                   sessionIDPresent;            // TRUE if previous field used
} H245_H2250ACK_LOGICAL_PARAM_T;


/* H245_MUX_T */
typedef enum
{
  H245_H222     = fLCPs_mPs_h222LCPs_chosen,
  H245_H223     = fLCPs_mPs_h223LCPs_chosen,
  H245_VGMUX    = fLCPs_mPs_v76LCPs_chosen,
  H245_H2250    = fLCPs_mPs_h2250LCPs_chosen,
  H245_H2250ACK = fLCPs_mPs_h223AALCPs_chosen
} H245_MUX_KIND_T;

typedef struct
{
  H245_MUX_KIND_T Kind;
  union
  {
    H245_H222_LOGICAL_PARAM_T     H222;
    H245_H223_LOGICAL_PARAM_T     H223;
    H245_VGMUX_LOGICAL_PARAM_T    VGMUX;
    H245_H2250_LOGICAL_PARAM_T    H2250;
    H245_H2250ACK_LOGICAL_PARAM_T H2250ACK;
  } u;
} H245_MUX_T;


/*
   H245_MUX_ENTRY_ELEMENT_T

   This structure defines the multiplex pattern
   which will be used to decode bit patterns in
   a given mux table entry.  the Kind defines
   whether this is a recursive structure (i.e.
   pointing to yet another Mux Entry Element) or
   whether it is a terminating leaf in the recursive
   mux tree.

   RepeatCount indicates how many bits should be
   used for this channel.  If bit count == 0 this
   indicates repeat sequence until close flag
*/

typedef enum
{
  H245_MUX_LOGICAL_CHANNEL = 1,     /* logical channel number (Terminate list) */
  H245_MUX_ENTRY_ELEMENT            /* recursive.. yet another one             */
} H245_MUX_ENTRY_KIND_T;

typedef struct H245_MUX_ENTRY_ELEMENT_T
{
  struct H245_MUX_ENTRY_ELEMENT_T      *pNext;
  H245_MUX_ENTRY_KIND_T                 Kind;
  union
  {
      H245_CHANNEL_T                    Channel;
      struct H245_MUX_ENTRY_ELEMENT_T  *pMuxTblEntryElem;
  } u;

  /* RepeatCount                                */
  /* RepeatCount == 0 -> repeat until close     */
  /* RepeatCount != 0 -> repeate count          */
  unsigned long                         RepeatCount;

} H245_MUX_ENTRY_ELEMENT_T;


/*
   H245_MUX_TABLE_T

   an H245 Mux Table is defined as a linked list of
   Mux Entry Descriptors.  Each descriptor has an
   associated entry number.  These entry numbers
   range from 1-15 and must be unique within the table.
   The end of the list is designated by a pNext == NULL
*/

typedef  struct H245_MUX_TABLE_T
{
  struct H245_MUX_TABLE_T       *pNext;
  unsigned long                  MuxEntryId;
  H245_MUX_ENTRY_ELEMENT_T      *pMuxTblEntryElem;      /* NULL indicates delete entry */

} H245_MUX_TABLE_T;

/********************/
/********************/
/*  Indicator Code  */
/********************/
/********************/

#define H245_IND_MSTSLV                 0x01
#define H245_IND_CAP                    0x02
#define H245_IND_CESE_RELEASE           0x30
#define H245_IND_OPEN                   0x03
#define H245_IND_OPEN_CONF              0x04
#define H245_IND_CLOSE                  0x05
#define H245_IND_REQ_CLOSE              0x06
#define H245_IND_CLCSE_RELEASE          0x31
#define H245_IND_MUX_TBL                0x07
#define H245_IND_MTSE_RELEASE           0x08
#define H245_IND_RMESE                  0x09
#define H245_IND_RMESE_RELEASE          0x0A
#define H245_IND_MRSE                   0x0B
#define H245_IND_MRSE_RELEASE           0x0C
#define H245_IND_MLSE                   0x0D
#define H245_IND_MLSE_RELEASE           0x0E
#define H245_IND_NONSTANDARD_REQUEST    0x0F
#define H245_IND_NONSTANDARD_RESPONSE   0x10
#define H245_IND_NONSTANDARD_COMMAND    0x11
#define H245_IND_NONSTANDARD            0x12
#define H245_IND_MISC_COMMAND           0x13
#define H245_IND_MISC                   0x14
#define H245_IND_COMM_MODE_REQUEST      0x15
#define H245_IND_COMM_MODE_RESPONSE     0x16
#define H245_IND_COMM_MODE_COMMAND      0x17
#define H245_IND_CONFERENCE_REQUEST     0x18
#define H245_IND_CONFERENCE_RESPONSE    0x19
#define H245_IND_CONFERENCE_COMMAND     0x1A
#define H245_IND_CONFERENCE             0x1B
#define H245_IND_SEND_TERMCAP           0x1C
#define H245_IND_ENCRYPTION             0x1D
#define H245_IND_FLOW_CONTROL           0x1E
#define H245_IND_ENDSESSION             0x1F
#define H245_IND_FUNCTION_NOT_UNDERSTOOD 0x20
#define H245_IND_JITTER                 0x21
#define H245_IND_H223_SKEW              0x22
#define H245_IND_NEW_ATM_VC             0x23
#define H245_IND_USERINPUT              0x24
#define H245_IND_H2250_MAX_SKEW         0x25
#define H245_IND_MC_LOCATION            0x26
#define H245_IND_VENDOR_ID              0x27
#define H245_IND_FUNCTION_NOT_SUPPORTED 0x28
#define H245_IND_H223_RECONFIG          0x29
#define H245_IND_H223_RECONFIG_ACK      0x2A
#define H245_IND_H223_RECONFIG_REJECT   0x2B

/* H245_MSTSLV_T */
typedef enum
{
  H245_INDETERMINATE = 0,       // Master/Slave Determination failed
  H245_MASTER = master_chosen,  // Local terminal is Master
  H245_SLAVE  = slave_chosen    // Local terminal is Slave

} H245_MSTSLV_T;

/* H245_IND_OPEN_T */
typedef struct
{
  /* for receive */
  H245_CHANNEL_T RxChannel;
  H245_PORT_T    RxPort;        // optional
  H245_DATA_T    RxDataType;
  H245_CLIENT_T  RxClientType;
  H245_CAP_T    *pRxCap;
  H245_MUX_T    *pRxMux;

  /* for bi-directional channel */
  /* requested transmit stuff   */

  H245_DATA_T    TxDataType;
  H245_CLIENT_T  TxClientType;
  H245_CAP_T    *pTxCap;
  H245_MUX_T    *pTxMux;

  H245_ACCESS_T *pSeparateStack; // optional

} H245_IND_OPEN_T;

/* H245_IND_OPEN_CONF_T */
typedef struct
{
  /* receive channel              */
  /* remote requested channel #   */
  H245_CHANNEL_T          RxChannel;

  /* transmit channel                     */
  /* locally opened transmit channel #    */
  H245_CHANNEL_T          TxChannel;

} H245_IND_OPEN_CONF_T;

/* H245_IND_CLOSE_T */
typedef enum
{
  H245_USER = user_chosen,
  H245_LCSE = lcse_chosen

} H245_IND_CLOSE_REASON_T;

typedef struct
{
  H245_CHANNEL_T          Channel;
  H245_IND_CLOSE_REASON_T Reason;

} H245_IND_CLOSE_T;

/* H245_IND_MUX_TBL */
typedef struct
{
  H245_MUX_TABLE_T      *pMuxTbl;
  unsigned long          Count;

} H245_IND_MUXTBL_T;

/* H245_RMESE_T */
typedef struct
{
  unsigned short        awMultiplexTableEntryNumbers[15];
  unsigned long         dwCount;

} H245_RMESE_T;

/* H245_IND_MRSE_T */
typedef struct
{
  RequestedModesLink pRequestedModes;

} H245_IND_MRSE_T;

/* H245_MLSE_T */
typedef enum
{
  H245_SYSTEM_LOOP  = systemLoop_chosen,
  H245_MEDIA_LOOP   = mediaLoop_chosen,
  H245_CHANNEL_LOOP = logicalChannelLoop_chosen

} H245_LOOP_TYPE_T;

typedef struct
{
  H245_LOOP_TYPE_T      LoopType;
  H245_CHANNEL_T        Channel;

} H245_MLSE_T;

/* H245_IND_ENDSESSION_T */
typedef enum
{
  H245_ENDSESSION_NONSTD     = EndSssnCmmnd_nonStandard_chosen,
  H245_ENDSESSION_DISCONNECT = disconnect_chosen,
  H245_ENDSESSION_TELEPHONY,
  H245_ENDSESSION_V8BIS,
  H245_ENDSESSION_V34DSVD,
  H245_ENDSESSION_V34DUPFAX,
  H245_ENDSESSION_V34H324

} H245_ENDSESSION_T;

typedef struct
{
  H245_ENDSESSION_T             SessionMode;
  /* if non standard chosen */
  H245_NONSTANDARD_PARAMETER_T  SessionNonStd;

} H245_IND_ENDSESSION_T;

/* H245_IND_NONSTANDARD_T */
typedef struct
{
  unsigned char *        pData;
  unsigned long          dwDataLength;
  unsigned short *       pwObjectId;
  unsigned long          dwObjectIdLength;
  unsigned char          byCountryCode;
  unsigned char          byExtension;
  unsigned short         wManufacturerCode;
} H245_IND_NONSTANDARD_T;

typedef struct
{
  CMTEy_nnStndrdLink          pNonStandard;                 // NULL if not present
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  H245_TERMINAL_LABEL_T       terminalLabel;
  ASN1_BOOL                   terminalLabelPresent;
  unsigned short *            pSessionDescription;
  unsigned short              wSessionDescriptionLength;
  H245_TOTCAP_T               dataType;
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
} H245_COMM_MODE_ENTRY_T;

typedef struct
{
  H245_COMM_MODE_ENTRY_T *pTable;
  unsigned char          byTableCount;
} H245_IND_COMM_MODE_T;

typedef enum
{
  H245_REQ_TERMINAL_LIST            = terminalListRequest_chosen,
  H245_REQ_MAKE_ME_CHAIR            = makeMeChair_chosen,
  H245_REQ_CANCEL_MAKE_ME_CHAIR     = cancelMakeMeChair_chosen,
  H245_REQ_DROP_TERMINAL            = dropTerminal_chosen,
  H245_REQ_TERMINAL_ID              = requestTerminalID_chosen,
  H245_REQ_ENTER_H243_PASSWORD      = enterH243Password_chosen,
  H245_REQ_ENTER_H243_TERMINAL_ID   = enterH243TerminalID_chosen,
  H245_REQ_ENTER_H243_CONFERENCE_ID = enterH243ConferenceID_chosen
} H245_CONFER_REQ_ENUM_T;

typedef struct
{
  H245_CONFER_REQ_ENUM_T  RequestType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_REQ_T;

typedef enum
{
  H245_RSP_MC_TERMINAL_ID           = mCTerminalIDResponse_chosen,
  H245_RSP_TERMINAL_ID              = terminalIDResponse_chosen,
  H245_RSP_CONFERENCE_ID            = conferenceIDResponse_chosen,
  H245_RSP_PASSWORD                 = passwordResponse_chosen,
  H245_RSP_TERMINAL_LIST            = terminalListResponse_chosen,
  H245_RSP_VIDEO_COMMAND_REJECT     = videoCommandReject_chosen,
  H245_RSP_TERMINAL_DROP_REJECT     = terminalDropReject_chosen,
  H245_RSP_DENIED_CHAIR_TOKEN,
  H245_RSP_GRANTED_CHAIR_TOKEN
} H245_CONFER_RSP_ENUM_T;

typedef struct
{
  H245_CONFER_RSP_ENUM_T  ResponseType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
  unsigned char          *pOctetString;
  unsigned char           byOctetStringLength;
  TerminalLabel          *pTerminalList;
  unsigned short          wTerminalListCount;
} H245_CONFER_RSP_T;

typedef enum
{
  H245_CMD_BROADCAST_CHANNEL        = brdcstMyLgclChnnl_chosen,
  H245_CMD_CANCEL_BROADCAST_CHANNEL = cnclBrdcstMyLgclChnnl_chosen,
  H245_CMD_BROADCASTER              = makeTerminalBroadcaster_chosen,
  H245_CMD_CANCEL_BROADCASTER       = cnclMkTrmnlBrdcstr_chosen,
  H245_CMD_SEND_THIS_SOURCE         = sendThisSource_chosen,
  H245_CMD_CANCEL_SEND_THIS_SOURCE  = cancelSendThisSource_chosen,
  H245_CMD_DROP_CONFERENCE          = dropConference_chosen
} H245_CONFER_CMD_ENUM_T;

typedef struct
{
  H245_CONFER_CMD_ENUM_T  CommandType;
  H245_CHANNEL_T          Channel;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_CMD_T;

typedef enum
{
  H245_IND_SBE_NUMBER               = sbeNumber_chosen,
  H245_IND_TERMINAL_NUMBER_ASSIGN   = terminalNumberAssign_chosen,
  H245_IND_TERMINAL_JOINED          = terminalJoinedConference_chosen,
  H245_IND_TERMINAL_LEFT            = terminalLeftConference_chosen,
  H245_IND_SEEN_BY_ONE_OTHER        = seenByAtLeastOneOther_chosen,
  H245_IND_CANCEL_SEEN_BY_ONE_OTHER = cnclSnByAtLstOnOthr_chosen,
  H245_IND_SEEN_BY_ALL              = seenByAll_chosen,
  H245_IND_CANCEL_SEEN_BY_ALL       = cancelSeenByAll_chosen,
  H245_IND_TERMINAL_YOU_ARE_SEEING  = terminalYouAreSeeing_chosen,
  H245_IND_REQUEST_FOR_FLOOR        = requestForFloor_chosen
} H245_CONFER_IND_ENUM_T;

typedef struct
{
  H245_CONFER_IND_ENUM_T  IndicationType;
  unsigned char           bySbeNumber;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_IND_T;

typedef enum
{
  H245_SCOPE_CHANNEL_NUMBER   = FCCd_scp_lgclChnnlNmbr_chosen,
  H245_SCOPE_RESOURCE_ID      = FlwCntrlCmmnd_scp_rsrcID_chosen,
  H245_SCOPE_WHOLE_MULTIPLEX  = FCCd_scp_whlMltplx_chosen
} H245_SCOPE_T;

#define H245_NO_RESTRICTION 0xFFFFFFFFL

typedef struct
{
  H245_SCOPE_T           Scope;
  H245_CHANNEL_T         Channel;       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
  unsigned short         wResourceID;   // only used if Scope is H245_SCOPE_RESOURCE_ID
  unsigned long          dwRestriction; // H245_NO_RESTRICTION if no restriction
} H245_IND_FLOW_CONTROL_T;

/* H245_USERINPUT_T */
typedef enum
{
  H245_USERINPUT_NONSTD = UsrInptIndctn_nnStndrd_chosen,
  H245_USERINPUT_STRING = alphanumeric_chosen
} H245_USERINPUT_KIND_T;

typedef struct
{
  H245_USERINPUT_KIND_T     Kind;
  union
  {
    WCHAR *                           pGenString;
    H245_NONSTANDARD_PARAMETER_T      NonStd;
  } u;
} H245_IND_USERINPUT_T;

typedef struct
{
  H245_CHANNEL_T        LogicalChannelNumber1;
  H245_CHANNEL_T        LogicalChannelNumber2;
  unsigned short        wSkew;
} H245_IND_SKEW_T;

typedef struct
{
  H245_NONSTANDID_T      Identifier;
  unsigned char         *pProductNumber;
  unsigned char          byProductNumberLength;
  unsigned char         *pVersionNumber;
  unsigned char          byVersionNumberLength;
} H245_IND_VENDOR_ID_T;

typedef enum
{
  UNKNOWN,
  REQ_NONSTANDARD,
  REQ_MASTER_SLAVE,
  REQ_TERMCAP_SET,
  REQ_OPEN_LOGICAL_CHANNEL,
  REQ_CLOSE_LOGICAL_CHANNEL,
  REQ_REQUEST_CHANNEL_CLOSE,
  REQ_MULTIPLEX_ENTRY_SEND,
  REQ_REQUEST_MULTIPLEX_ENTRY,
  REQ_REQUEST_MODE,
  REQ_ROUND_TRIP_DELAY,
  REQ_MAINTENANCE_LOOP,
  REQ_COMMUNICATION_MODE,
  REQ_CONFERENCE,
  REQ_H223_ANNEX_A_RECONFIG,
  RSP_NONSTANDARD,
  RSP_MASTER_SLAVE_ACK,
  RSP_MASTER_SLAVE_REJECT,
  RSP_TERMCAP_SET_ACK,
  RSP_TERMCAP_SET_REJECT,
  RSP_OPEN_LOGICAL_CHANNEL_ACK,
  RSP_OPEN_LOGICAL_CHANNEL_REJECT,
  RSP_CLOSE_LOGICAL_CHANNEL_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_REJECT,
  RSP_MULTIPLEX_ENTRY_SEND_ACK,
  RSP_MULTIPLEX_ENTRY_SEND_REJECT,
  RSP_REQUEST_MULTIPLEX_ENTRY_ACK,
  RSP_REQUEST_MULTIPLEX_ENTRY_REJECT,
  RSP_REQUEST_MODE_ACK,
  RSP_REQUEST_MODE_REJECT,
  RSP_ROUND_TRIP_DELAY,
  RSP_MAINTENANCE_LOOP_ACK,
  RSP_MAINTENANCE_LOOP_REJECT,
  RSP_COMMUNICATION_MODE,
  RSP_CONFERENCE,
  RSP_H223_ANNEX_A_RECONFIG_ACK,
  RSP_H223_ANNEX_A_RECONFIG_REJECT,
  CMD_NONSTANDARD,
  CMD_MAINTENANCE_LOOP_OFF,
  CMD_SEND_TERMCAP,
  CMD_ENCRYPTION,
  CMD_FLOW_CONTROL,
  CMD_END_SESSION,
  CMD_MISCELLANEOUS,
  CMD_COMMUNICATION_MODE,
  CMD_CONFERENCE,
  IND_NONSTANDARD,
  IND_FUNCTION_NOT_UNDERSTOOD,
  IND_MASTER_SLAVE_RELEASE,
  IND_TERMCAP_SET_RELEASE,
  IND_OPEN_LOGICAL_CHANNEL_CONFIRM,
  IND_REQUEST_CHANNEL_CLOSE_RELEASE,
  IND_MULTIPLEX_ENTRY_SEND_RELEASE,
  IND_REQUEST_MULTIPLEX_ENTRY_RELEASE,
  IND_REQUEST_MODE_RELEASE,
  IND_MISCELLANEOUS,
  IND_JITTER,
  IND_H223_SKEW,
  IND_NEW_ATM_VC,
  IND_USER_INPUT,
  IND_H2250_MAX_SKEW,
  IND_MC_LOCATION,
  IND_CONFERENCE_INDICATION,
  IND_VENDOR_IDENTIFICATION,
  IND_FUNCTION_NOT_SUPPORTED,
} H245_SUBMESSAGE_T;

typedef enum
{
  H245_SYNTAX_ERROR     = syntaxError_chosen,
  H245_SEMANTIC_ERROR   = semanticError_chosen,
  H245_UNKNOWN_FUNCTION = unknownFunction_chosen
} H245_FNS_CAUSE_T;

typedef struct
{
  H245_FNS_CAUSE_T      Cause;
  H245_SUBMESSAGE_T     Type;
} H245_IND_FNS_T;

/**************/
/* H245_IND_T */
/**************/

typedef struct
{
  unsigned long         Indicator;              // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  union
  {
    H245_MSTSLV_T            IndMstSlv;         // H245_IND_MSTSLV
                                                // H245_IND_CAP
                                                // H245_IND_CESE_RELEASE
    H245_IND_OPEN_T          IndOpen;           // H245_IND_OPEN
    H245_IND_OPEN_CONF_T     IndOpenConf;       // H245_IND_OPEN_CONF
    H245_IND_CLOSE_T         IndClose;          // H245_IND_CLOSE
    H245_CHANNEL_T           IndReqClose;       // H245_IND_REQ_CLOSE
                                                // H245_IND_CLCSE_RELEASE
    H245_IND_MUXTBL_T        IndMuxTbl;         // H245_IND_MUX_TBL
                                                // H245_IND_MTSE_RELEASE
    H245_RMESE_T             IndRmese;          // H245_IND_RMESE
                                                // H245_IND_RMESE_RELEASE
    H245_IND_MRSE_T          IndMrse;           // H245_IND_MRSE
                                                // H245_IND_MRSE_RELEASE
    H245_MLSE_T              IndMlse;           // H245_IND_MLSE
                                                // H245_IND_MLSE_RELEASE
    H245_IND_NONSTANDARD_T   IndNonstandardRequest; // H245_IND_NONSTANDARD_REQUEST
    H245_IND_NONSTANDARD_T   IndNonstandardResponse; // H245_IND_NONSTANDARD_RESPONSE
    H245_IND_NONSTANDARD_T   IndNonstandardCommand; // H245_IND_NONSTANDARD_COMMAND
    H245_IND_NONSTANDARD_T   IndNonstandard;    // H245_IND_NONSTANDARD
                                                // H245_IND_MISC_COMMAND
                                                // H245_IND_MISC
                                                // H245_IND_COMM_MODE_REQUEST
    H245_IND_COMM_MODE_T     IndCommRsp;        // H245_IND_COMM_MODE_RESPONSE
    H245_IND_COMM_MODE_T     IndCommCmd;        // H245_IND_COMM_MODE_COMMAND
    H245_CONFER_REQ_T        IndConferReq;      // H245_IND_CONFERENCE_REQUEST
    H245_CONFER_RSP_T        IndConferRsp;      // H245_IND_CONFERENCE_RESPONSE
    H245_CONFER_CMD_T        IndConferCmd;      // H245_IND_CONFERENCE_COMMAND
    H245_CONFER_IND_T        IndConfer;         // H245_IND_CONFERENCE
                                                // H245_IND_SEND_TERMCAP
                                                // H245_IND_ENCRYPTION
    H245_IND_FLOW_CONTROL_T  IndFlowControl;    // H245_IND_FLOW_CONTROL
    H245_IND_ENDSESSION_T    IndEndSession;     // H245_IND_ENDSESSION
                                                // H245_IND_FUNCTION_NOT_UNDERSTOOD
                                                // H245_IND_JITTER
    H245_IND_SKEW_T          IndH223Skew;       // H245_IND_H223_SKEW
                                                // H245_IND_NEW_ATM_VC
    H245_IND_USERINPUT_T     IndUserInput;      // H245_IND_USERINPUT
    H245_IND_SKEW_T          IndH2250MaxSkew;   // H245_IND_H2250_MAX_SKEW
    H245_TRANSPORT_ADDRESS_T IndMcLocation;     // H245_IND_MC_LOCATION
    H245_IND_VENDOR_ID_T     IndVendorId;       // H245_IND_VENDOR_ID
    H245_IND_FNS_T           IndFns;            // H245_IND_FUNCTION_NOT_SUPPORTED
                                                // H245_IND_H223_RECONFIG
                                                // H245_IND_H223_RECONFIG_ACK
                                                // H245_IND_H223_RECONFIG_REJECT
  } u;
} H245_IND_T;


/********************/
/********************/
/*  Confirm   Code  */
/********************/
/********************/

#define H245_CONF_INIT_MSTSLV    0x101
#define H245_CONF_SEND_TERMCAP   0x102
#define H245_CONF_OPEN           0x103
#define H245_CONF_NEEDRSP_OPEN   0x104
#define H245_CONF_CLOSE          0x105
#define H245_CONF_REQ_CLOSE      0x106
#define H245_CONF_MUXTBL_SND     0x107

#define H245_CONF_RMESE          0x109
#define H245_CONF_RMESE_REJECT   0x10A
#define H245_CONF_RMESE_EXPIRED  0x10B
#define H245_CONF_MRSE           0x10C
#define H245_CONF_MRSE_REJECT    0x10D
#define H245_CONF_MRSE_EXPIRED   0x10E
#define H245_CONF_MLSE           0x10F
#define H245_CONF_MLSE_REJECT    0x110
#define H245_CONF_MLSE_EXPIRED   0x111
#define H245_CONF_RTDSE          0x112
#define H245_CONF_RTDSE_EXPIRED  0x113

/* H245_CONF_SEND_TERMCAP_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;

} H245_CONF_SEND_TERMCAP_T;

/* H245_CONF_OPEN_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        TxChannel;
  H245_MUX_T *          pTxMux;         // optional
  H245_CHANNEL_T        RxChannel;      // bi-dir only
  H245_MUX_T *          pRxMux;         // bi-dir only
  H245_PORT_T           RxPort;         // bi-dir only
  H245_ACCESS_T *       pSeparateStack; // optional

} H245_CONF_OPEN_T;

typedef H245_CONF_OPEN_T H245_CONF_NEEDRSP_OPEN_T;

/* H245_CONF_CLOSE_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        Channel;

} H245_CONF_CLOSE_T;

/* H245_CONF_REQ_CLOSE_T */
typedef H245_CONF_CLOSE_T H245_CONF_REQ_CLOSE_T;

/* H245_CONF_MUXTBL_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_CONF_MUXTBL_T;



/***************/
/* H245_CONF_T */
/***************/

typedef struct
{
  unsigned long         Confirm;                // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  unsigned long         dwTransId;              // User supplied dwTransId from originating call
  HRESULT               Error;                  // Error code
  union                                         // Data for specific indications:
  {
    H245_MSTSLV_T             ConfMstSlv;       // H245_CONF_INIT_MSTSLV
    H245_CONF_SEND_TERMCAP_T  ConfSndTcap;      // H245_CONF_SEND_TERMCAP
    H245_CONF_OPEN_T          ConfOpen;         // H245_CONF_OPEN
    H245_CONF_NEEDRSP_OPEN_T  ConfOpenNeedRsp;  // H245_CONF_NEEDRSP_OPEN
    H245_CONF_CLOSE_T         ConfClose;        // H245_CONF_CLOSE
    H245_CONF_REQ_CLOSE_T     ConfReqClose;     // H245_CONF_REQ_CLOSE
    H245_CONF_MUXTBL_T        ConfMuxSnd;       // H245_CONF_MUXTBL_SND
    H245_RMESE_T              ConfRmese;        // H245_CONF_RMESE
    H245_RMESE_T              ConfRmeseReject;  // H245_CONF_RMESE_REJECT
                                                // H245_CONF_RMESE_EXPIRED
    unsigned short            ConfMrse;         // H245_CONF_MRSE
    unsigned short            ConfMrseReject;   // H245_CONF_MRSE_REJECT
                                                // H245_CONF_MRSE_EXPIRED
    H245_MLSE_T               ConfMlse;         // H245_CONF_MLSE
    H245_MLSE_T               ConfMlseReject;   // H245_CONF_MLSE_REJECT
                                                // H245_CONF_MLSE_EXPIRED
                                                // H245_CONF_RTDSE
                                                // H245_CONF_RTDSE_EXPIRED
  } u;
} H245_CONF_T;



typedef enum
{
  H245_MESSAGE_REQUEST     = MltmdSystmCntrlMssg_rqst_chosen,
  H245_MESSAGE_RESPONSE    = MSCMg_rspns_chosen,
  H245_MESSAGE_COMMAND     = MSCMg_cmmnd_chosen,
  H245_MESSAGE_INDICATION  = indication_chosen
} H245_MESSAGE_TYPE_T;



/*******************/
/* H245_CONF_IND_T */
/*******************/
typedef enum
{
  H245_CONF = 1,
  H245_IND
} H245_CONF_IND_KIND_T;

typedef struct
{
  H245_CONF_IND_KIND_T  Kind;
  union
  {
    H245_CONF_T         Confirm;
    H245_IND_T          Indication;
  } u;

} H245_CONF_IND_T;



/***************************/
/* SYSTEM CONTROL MESSAGES */
/***************************/

typedef struct
{
  unsigned long NumPduTx;       /* number of tranmitted pdu's    */
  unsigned long NumPduRx;       /* number of received pdu's      */
  unsigned long NumCRCErrors;   /* number of crc errors          */
  unsigned long NumPduReTx;     /* number of pdu's retransmitted */

} H245_SYSCON_STATS_T;

#define H245_SYSCON_TRACE_LVL           0x0100  /* pData = &dwTraceLevel   */
#define H245_SYSCON_DUMP_TRACKER        0x0200  /* pData = NULL (debug)    */
#define H245_SYSCON_GET_STATS           0x0300  /* pData = &H245_SYSCON_STATS_T */
#define H245_SYSCON_RESET_STATS         0x0400  /* pData = NULL            */

#define H245_SYSCON_SET_FSM_N100        0x1000  /* pData = &dwRetryCount   */
#define H245_SYSCON_SET_FSM_T101        0x1100  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T102        0x1200  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T103        0x1300  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T104        0x1400  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T105        0x1500  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T106        0x1600  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T107        0x1700  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T108        0x1800  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T109        0x1900  /* pData = &dwMilliseconds */

#define H245_SYSCON_GET_FSM_N100        0x2000  /* pData = &dwRetryCount   */
#define H245_SYSCON_GET_FSM_T101        0x2100  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T102        0x2200  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T103        0x2300  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T104        0x2400  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T105        0x2500  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T106        0x2600  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T107        0x2700  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T108        0x2800  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T109        0x2900  /* pData = &dwMilliseconds */



/************************/
/* PROTOCOL ID FOR H245 */
/************************/

#define H245_PROTOID                    "0.0.8.245.0.2"



/**************************************************/
/* API Procedure Call Typedefs and API Prototypes */
/**************************************************/

typedef unsigned long H245_INST_T;
typedef HRESULT (*H245_CONF_IND_CALLBACK_T)(H245_CONF_IND_T *, void *);
typedef int (*H245_CAP_CALLBACK_T)(unsigned long, H245_TOTCAP_T *);
typedef int (*H245_CAPDESC_CALLBACK_T)(unsigned long, H245_TOTCAPDESC_T *);

#ifdef __cplusplus
extern "C" {
#endif

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwPhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         unsigned long            dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        );

H245DLL H245_INST_T
H245GetInstanceId       (unsigned long          dwPhysicalId);

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst);

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        );

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        );

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        );

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        );

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         unsigned long            dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        );

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T      * * ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T  * * ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        );

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T		   **ppDestTotCap,
						 const H245_TOTCAP_T   *pTotCap);

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T          *pTotCap);

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T		 **ppDestCapDesc,
						 const H245_TOTCAPDESC_T *pCapDesc);

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T     *pCapDesc);

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *     pMux);

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux);

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        );

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        );

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        );

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

/*
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const ModeElement *    pModeElements,
                         unsigned long          dwCount
                        );
*/
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        ) ;



H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        );

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst);

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        );

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        );

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst);

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        );

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                  pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        );

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        );

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        );

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        );

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,       // optional
                         unsigned char          byProductNumberLength,// optional
                         const unsigned char   *pVersionNumber,       // optional
                         unsigned char          byVersionNumberLength // optional
                        );

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        );

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        );

#ifdef __cplusplus
        }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\rasplog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1994:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR	Steve Nesland, Sam Sakthivel
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by MBFT and
//		the MBFT PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the MBFT protocol as the one to be logged.  In the 
// MBFT code, it is used only in the CPLInitialize() call.  
// For example:  MBFTProtocolLogger = CPLInitialize( MBFT_PROTOCOL );
//
#define RASLOG_PROTOCOL "RAS_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// MBFT to the logging via user data.  Bit zero of the user data represents
// the ASN encoding type.  Bit 1 represents pdu type (Connect or Domain).
// Bit 2 represents whether the PDU was sent or received.
//

#define RASLOG_SENT_PDU                1UL
#define RASLOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\h245asn.h ===
#ifndef _H245ASN_Module_H_
#define _H245ASN_Module_H_

#include "nmasn1.h"
#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define noMultiplex_chosen 1
#   define transportStream_chosen 2
#   define programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
    } u;
} MiscellaneousIndication_type;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
    } u;
} MiscellaneousCommand_type;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct H223AnnexAReconfiguration_headerCRC {
    ASN1choice_t choice;
#   define H223AnnexAReconfiguration_headerCRC_nil_chosen 1
#   define threebits_chosen 2
#   define H223AnnexAReconfiguration_headerCRC_eightbits_chosen 3
} H223AnnexAReconfiguration_headerCRC;

typedef struct H223AnnexAReconfiguration_headerFEC {
    ASN1choice_t choice;
#   define rate5by15_chosen 1
#   define rate6by31_chosen 2
#   define rate7by63_chosen 3
#   define rate7by15_chosen 4
#   define rate10by63_chosen 5
#   define rate11by31_chosen 6
#   define rate11by15_chosen 7
#   define rate16by63_chosen 8
#   define rate16by31_chosen 9
#   define rate18by63_chosen 10
} H223AnnexAReconfiguration_headerFEC;

typedef struct H223AnnexAReconfiguration_headerInterleaving {
    ASN1choice_t choice;
#   define bitInterleaving_chosen 1
#   define byteInterleaving_chosen 2
#   define noInterleaving_chosen 3
} H223AnnexAReconfiguration_headerInterleaving;

typedef struct H223AnnexAReconfiguration_synchFlagLength {
    ASN1choice_t choice;
#   define length15_chosen 1
#   define length31_chosen 2
} H223AnnexAReconfiguration_synchFlagLength;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct AL3MParameters_arqType {
    ASN1choice_t choice;
#   define AL3MParameters_arqType_noArq_chosen 1
#   define AL3MParameters_arqType_typeIArq_chosen 2
#   define AL3MParameters_arqType_typeIIArq_chosen 3
} AL3MParameters_arqType;

typedef struct AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define AL3MParameters_crcLength_nil_chosen 1
#   define AL3MParameters_crcLength_eightbits_chosen 2
#   define AL3MParameters_crcLength_sixteenbits_chosen 3
#   define AL3MParameters_crcLength_thirtytwobits_chosen 4
} AL3MParameters_crcLength;

typedef struct AL1MParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define AL1MParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} AL1MParameters_numberOfRetransmissions;

typedef struct AL1MParameters_arqType {
    ASN1choice_t choice;
#   define AL1MParameters_arqType_noArq_chosen 1
#   define AL1MParameters_arqType_typeIArq_chosen 2
#   define AL1MParameters_arqType_typeIIArq_chosen 3
} AL1MParameters_arqType;

typedef struct AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define AL1MParameters_crcLength_nil_chosen 1
#   define AL1MParameters_crcLength_eightbits_chosen 2
#   define AL1MParameters_crcLength_sixteenbits_chosen 3
#   define AL1MParameters_crcLength_thirtytwobits_chosen 4
} AL1MParameters_crcLength;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
#   define h261aVideoPacketization_chosen 1
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define wAddress_chosen 1
#   define woAddress_chosen 2
} V76LogicalChannelParameters_suspendResume;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen 1
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen 2
	H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced enhanced;
    } u;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223Capability_h223MultiplexTableCapability_basic_chosen 1
#	define H223Capability_h223MultiplexTableCapability_enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223Capability {
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct MediaPacketizationCapability {
    ASN1bool_t h261aVideoPacketization;
} MediaPacketizationCapability;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H223AnnexACapability {
    ASN1bool_t transferWithI_frames;
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
    ASN1uint16_t maximumDelayJitter;
    ASN1bool_t reconfigurationCapability;
    H223AnnexACapability_h223AnnexAMultiplexTableCapability h223AnnexAMultiplexTableCapability;
} H223AnnexACapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
} H263VideoCapability;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelClose {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelClose;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct AL1MParameters {
    AL1MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL1MParameters_arqType arqType;
    AL1MParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL1MParameters;

typedef struct AL3MParameters {
    AL3MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL3MParameters_arqType arqType;
    ASN1uint16_t numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL3MParameters;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define suspendResumewAddress_chosen 1
#   define suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
} H263VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct H223AnnexAReconfiguration {
    H223AnnexAReconfiguration_synchFlagLength synchFlagLength;
    ASN1uint16_t informationFieldSize;
    H223AnnexAReconfiguration_headerInterleaving headerInterleaving;
    H223AnnexAReconfiguration_headerFEC headerFEC;
    H223AnnexAReconfiguration_headerCRC headerCRC;
    ASN1uint16_t headerCounterForward;
} H223AnnexAReconfiguration;

typedef struct H223AnnexAReconfigurationAck {
    char placeholder;
} H223AnnexAReconfigurationAck;

typedef struct H223AnnexAReconfigurationReject {
    char placeholder;
} H223AnnexAReconfigurationReject;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
    } u;
} ConferenceCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
    } u;
} ConferenceIndication;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
} NewATMVCIndication;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H2250Capability {
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
} H2250Capability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729AnnexAwSilenceSuppression_chosen 15
	ASN1uint16_t g729AnnexAwSilenceSuppression;
    } u;
} AudioCapability;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
    } u;
} DataProtocolCapability;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define g722_64k_chosen 6
#	define g722_56k_chosen 7
#	define g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729AnnexAwSilenceSuppression_chosen 15
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
    } u;
} ConferenceRequest;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
    } u;
} EndSessionCommand;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataMode_application;

typedef struct H223AnnexAModeParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexAModeParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexAModeParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexAModeParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexAModeParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexAModeParameters_adaptationLayertype;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct H223AnnexALogicalChannelParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexALogicalChannelParameters_adaptationLayertype;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataApplicationCapability_application;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
#	define h223AnnexACapability_chosen 6
	H223AnnexACapability h223AnnexACapability;
    } u;
} MultiplexCapability;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
    } u;
} DataType;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} TransportAddress;

typedef struct H223AnnexALogicalChannelParameters {
    H223AnnexALogicalChannelParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexALogicalChannelParameters;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct H223AnnexAModeParameters {
    H223AnnexAModeParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexAModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MCLocationIndication {
    TransportAddress signalAddress;
} MCLocationIndication;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define videoMode_chosen 2
	VideoMode videoMode;
#	define audioMode_chosen 3
	AudioMode audioMode;
#	define dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
    } u;
} ModeElement_type;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
    } u;
} CommandMessage;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
    } u;
} Capability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
} NetworkAccessParameters;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
} H2250LogicalChannelParameters;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h223AnnexAModeParameters_present 0x4000
    H223AnnexAModeParameters h223AnnexAModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
} CommunicationModeTableEntry;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 5
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 4
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
} OpenLogicalChannelAck;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
#	define h223AnnexAReconfiguration_chosen 14
	H223AnnexAReconfiguration h223AnnexAReconfiguration;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
#	define h223AnnexAReconfigurationAck_chosen 22
	H223AnnexAReconfigurationAck h223AnnexAReconfigurationAck;
#	define h223AnnexAReconfigurationReject_chosen 23
	H223AnnexAReconfigurationReject h223AnnexAReconfigurationReject;
    } u;
} ResponseMessage;

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 0
#define SIZE_H245ASN_Module_PDU_0 sizeof(MultimediaSystemControlMessage)

extern ASN1module_t H245ASN_Module;
extern void ASN1CALL H245ASN_Module_init();
extern void ASN1CALL H245ASN_Module_finit();

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
    extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
    extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
    extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
    extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
    extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
    extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
    extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
    extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
    extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
    extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
    extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
    extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
    extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
    extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\incommon.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/incommon.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1996 Intel Corporation.
 *
 *      $Revision:   1.41  $
 *      $Date:   12 Feb 1997 09:34:42  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:    INCOMMON.H
 *
 *      Abstract:        commonly used structures
 *              
 *
 *      Notes:
 *
 ***************************************************************************/
#ifndef INCOMMON_H
#define INCOMMON_H

#pragma pack(push,8)

#define CC_INVALID_HANDLE                    0

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define CC_REJECT_NO_BANDWIDTH              1
#define CC_REJECT_GATEKEEPER_RESOURCES      2
#define CC_REJECT_UNREACHABLE_DESTINATION   3
#define CC_REJECT_DESTINATION_REJECTION     4
#define CC_REJECT_INVALID_REVISION          5
#define CC_REJECT_NO_PERMISSION             6
#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
#define CC_REJECT_GATEWAY_RESOURCES         8
#define CC_REJECT_BAD_FORMAT_ADDRESS        9
#define CC_REJECT_ADAPTIVE_BUSY             10
#define CC_REJECT_IN_CONF                   11
#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
#define CC_REJECT_CALL_FORWARDED            13
#define CC_REJECT_ROUTE_TO_MC               14
#define CC_REJECT_UNDEFINED_REASON          15
#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define CC_REJECT_USER_BUSY                 18    // User is busy with another call
#define CC_REJECT_NO_ANSWER                 19    // Callee does not answer
#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define CC_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call

// Q931 call types
#define CC_CALLTYPE_UNKNOWN                 0
#define CC_CALLTYPE_PT_PT                   1
#define CC_CALLTYPE_1_N                     2
#define CC_CALLTYPE_N_1                     3
#define CC_CALLTYPE_N_N                     4

// alias contants
#define CC_ALIAS_MAX_H323_ID                256
#define CC_ALIAS_MAX_H323_PHONE             128

// unicode character mask contants
#define CC_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define CC_ODOTTO_CHARS                     L".0123456789"


// alias type codes
#define CC_ALIAS_H323_ID                    1    // Return call information.
#define CC_ALIAS_H323_PHONE                 2    // H323 Phone Number.

// default port id's
#define CC_H323_GATE_DISC    1718 // Gatekeeper IP Discovery Port
#define CC_H323_GATE_STAT    1719 // Gatekeeper UDP Reg. and Status Port
#define CC_H323_HOST_CALL    1720 // Endpoint TCP Call Signalling Por

// Call creation goals
#define CC_GOAL_UNKNOWN                     0
#define CC_GOAL_CREATE                      1
#define CC_GOAL_JOIN                        2
#define CC_GOAL_INVITE                      3
    
// H245 non-standard message types
#define CC_H245_MESSAGE_REQUEST             0
#define CC_H245_MESSAGE_RESPONSE            1
#define CC_H245_MESSAGE_COMMAND             2
#define CC_H245_MESSAGE_INDICATION          3

// Call Control handle typedefs
typedef DWORD        CC_HLISTEN, *PCC_HLISTEN;
typedef DWORD        CC_HCONFERENCE, *PCC_HCONFERENCE;
typedef DWORD        CC_HCALL, *PCC_HCALL;
typedef DWORD        CC_HCHANNEL, *PCC_HCHANNEL;

// IP address in domain name format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[255];     // UNICODE zstring
} CC_IP_DomainName_t;

// IP address in conventional dot notation
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} CC_IP_Dot_t;

// IP address in binary format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} CC_IP_Binary_t;

typedef enum
{
    CC_IP_DOMAIN_NAME,
    CC_IP_DOT,
    CC_IP_BINARY
} CC_ADDRTYPE;

typedef struct _ADDR
{
    CC_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union 
    {
        CC_IP_DomainName_t   IP_DomainName;
        CC_IP_Dot_t          IP_Dot;
        CC_IP_Binary_t       IP_Binary;
    } Addr;
} CC_ADDR, *PCC_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;
} CC_OCTETSTRING, *PCC_OCTETSTRING;

typedef struct
{
    CC_OCTETSTRING          sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} CC_NONSTANDARDDATA, *PCC_NONSTANDARDDATA;

#define CC_MAX_PRODUCT_LENGTH 256
#define CC_MAX_VERSION_LENGTH 256
#define CC_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PCC_OCTETSTRING         pProductNumber;
    PCC_OCTETSTRING         pVersionNumber;
} CC_VENDORINFO, *PCC_VENDORINFO;

typedef struct
{
    PCC_VENDORINFO          pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} CC_ENDPOINTTYPE, *PCC_ENDPOINTTYPE;

typedef struct
{
    WORD                    wType;
    WORD                    wPrefixLength;
    LPWSTR                  pPrefix;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  pData;         // UNICODE data.
} CC_ALIASITEM, *PCC_ALIASITEM;

typedef struct
{
    WORD                    wCount;
    PCC_ALIASITEM           pItems;
} CC_ALIASNAMES, *PCC_ALIASNAMES;

typedef struct _CONFERENCE_ID
{
    BYTE                    buffer[16];  // This is OCTET data, not ASCII.
} CC_CONFERENCEID, *PCC_CONFERENCEID;

#pragma pack(pop)

#endif    INCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\interop.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif

#else   // ! (defined(_DEBUG) || defined(PCS_COMPLIANCE))
#define InteropLoad()
#define InteropUnload()
#define InteropOutput()

#endif  // (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\h245asn1.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef H245ASN1_H
#define H245ASN1_H

#include "h245asn.h"
#include "av_asn1.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif


// LONCHANC: ORIGINAL MAPPING WITH NEW STRUCTURE NAMES

#define VCCapabilityLink                PH222Capability_vcCapability
#define SmltnsCpbltsLink                PCapabilityDescriptor_simultaneousCapabilities
#define CapabilityTableLink             PTerminalCapabilitySet_capabilityTable
#define MultiplexEntryDescriptorLink    PMultiplexEntrySend_multiplexEntryDescriptors
#define CommunicationModeTableLink      PCommunicationModeResponse_communicationModeTable
#define TerminalListResponseLink        PConferenceResponse_terminalListResponse
#define CpbltyTblEntryNmbrsLink         PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
#define CommunicationModeCommandLink    PCommunicationModeCommand_communicationModeTable
#define CentralizedDataLink             PMediaDistributionCapability_centralizedData
#define DistributedDataLink             PMediaDistributionCapability_distributedData
#define MediaDistributionCapabilityLink PMultipointCapability_mediaDistributionCapability
#define NonStandardDataLink             PConferenceCapability_nonStandardData
#define RouteLink                       PUnicastAddress_iPSourceRouteAddress_route
#define H2250LCPs_nnStndrdLink          PH2250LogicalChannelParameters_nonStandard
#define MultiplexElementLink            PMultiplexElement_type_subElementList
#define RequestedModesLink              PRequestMode_requestedModes
#define H2250LCAPs_nnStndrdLink         PH2250LogicalChannelAckParameters_nonStandard
#define CMTEy_nnStndrdLink              PCommunicationModeTableEntry_nonStandard
#define OBJECTID                        struct ObjectID_
#define POBJECTID                       struct ObjectID_ *
typedef DataApplicationCapability_application_t84       H245_CAP_T84_T;
typedef DataApplicationCapability_application_nlpid     H245_CAP_NLPID_T;
typedef AudioCapability_g7231                           H245_CAP_G723_T;


// LONCHANC: NEW MAPPING FOR FIELDS AND DEFINITIONS

// _choice2 vs H223Capability_h223MultiplexTableCapability
#define h223MltplxTblCpblty_bsc_chosen  H223Capability_h223MultiplexTableCapability_basic_chosen
#define h223MTCy_enhncd_chosen          H223Capability_h223MultiplexTableCapability_enhanced_chosen
#define h223MTCy_enhncd                 enhanced

// V76Capability
#define sspndRsmCpbltywAddrss           suspendResumeCapabilitywoAddress

// DataProtocolCapability
#define DtPrtclCpblty_nnStndrd_chosen   DataProtocolCapability_nonStandard_chosen
#define sgmnttnAndRssmbly_chosen        segmentationAndReassembly_chosen          
#define DtPrtclCpblty_nnStndrd          nonStandard

// _choice3 vs DataApplicationCapability_application
#define DACy_applctn_nnStndrd_chosen    DataApplicationCapability_application_nonStandard_chosen
#define DACy_applctn_t120_chosen        DataApplicationCapability_application_t120_chosen
#define DACy_applctn_dsm_cc_chosen      dsm_cc_chosen
#define DACy_applctn_usrDt_chosen       DataApplicationCapability_application_userData_chosen
#define DACy_applctn_t84_chosen         DataApplicationCapability_application_t84_chosen
#define DACy_applctn_t434_chosen        DataApplicationCapability_application_t434_chosen
#define DACy_applctn_h224_chosen        DataApplicationCapability_application_h224_chosen
#define DACy_applctn_nlpd_chosen        DataApplicationCapability_application_nlpid_chosen
#define DACy_applctn_dsvdCntrl_chosen   DataApplicationCapability_application_dsvdControl_chosen
#define DACy_an_h222DtPrttnng_chosen    DataApplicationCapability_application_h222DataPartitioning_chosen
#define DACy_applctn_nnStndrd           nonStandard
#define DACy_applctn_t120               t120
#define DACy_applctn_dsm_cc             dsm_cc
#define DACy_applctn_usrDt              userData
#define DACy_applctn_t84                t84
#define DACy_applctn_t434               t434
#define DACy_applctn_h224               h224
#define DACy_applctn_nlpd               nlpid
#define DACy_an_h222DtPrttnng           h222DataPartitioning

// H2250Capability
#define rcvAndTrnsmtMltpntCpblty        receiveAndTransmitMultipointCapability

// _choice4 vs H223AnnexACapability_h223AnnexAMultiplexTableCapability
#define h223AAMTCy_bsc_chosen           H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen
#define h223AAMTCy_enhncd_chosen        H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen
#define h223AAMTCy_enhncd               enhanced

// MultiplexCapability
#define MltplxCpblty_nonStandard_chosen MultiplexCapability_nonStandard_chosen
#define MltplxCpblty_nonStandard        nonStandard

// H261VideoCapability
#define H261VdCpblty_qcifMPI_present    H261VideoCapability_qcifMPI_present
#define H261VdCpblty_cifMPI_present     H261VideoCapability_cifMPI_present
#define H261VdCpblty_qcifMPI            qcifMPI
#define H261VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability

// H262VideoCapability
#define H262VdCpblty_vdBtRt_present     H262VideoCapability_videoBitRate_present
#define H262VdCpblty_vbvBffrSz_present  H262VideoCapability_vbvBufferSize_present
#define H262VdCpblty_smplsPrLn_present  H262VideoCapability_samplesPerLine_present
#define H262VdCpblty_lnsPrFrm_present   H262VideoCapability_linesPerFrame_present
#define H262VdCpblty_frmsPrScnd_present H262VideoCapability_framesPerSecond_present
#define H262VCy_lmnncSmplRt_present     H262VideoCapability_luminanceSampleRate_present
#define H262VdCpblty_vdBtRt             videoBitRate
#define H262VdCpblty_vbvBffrSz          vbvBufferSize
#define H262VdCpblty_smplsPrLn          samplesPerLine
#define H262VdCpblty_lnsPrFrm           linesPerFrame
#define H262VdCpblty_frmsPrScnd         framesPerSecond
#define H262VCy_lmnncSmplRt             luminanceSampleRate

// H263VideoCapability
#define H263VdCpblty_qcifMPI_present    H263VideoCapability_qcifMPI_present
#define H263VdCpblty_cifMPI_present     H263VideoCapability_cifMPI_present
#define H263VCy_errrCmpnstn_present     H263VideoCapability_errorCompensation_present
#define H263VdCpblty_qcifMPI            qcifMPI
#define H263VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability
#define H263VCy_errrCmpnstn             errorCompensation

// IS11172VideoCapability
#define IS11172VdCpblty_vdBtRt_present  IS11172VideoCapability_videoBitRate_present
#define IS11172VCy_vbvBffrSz_present    IS11172VideoCapability_vbvBufferSize_present
#define IS11172VCy_smplsPrLn_present    IS11172VideoCapability_samplesPerLine_present
#define IS11172VCy_lnsPrFrm_present     IS11172VideoCapability_linesPerFrame_present
#define IS11172VdCpblty_pctrRt_present  IS11172VideoCapability_pictureRate_present
#define IS11172VCy_lmnncSmplRt_present  IS11172VideoCapability_luminanceSampleRate_present
#define IS11172VdCpblty_vdBtRt          videoBitRate
#define IS11172VCy_vbvBffrSz            vbvBufferSize
#define IS11172VCy_smplsPrLn            samplesPerLine
#define IS11172VCy_lnsPrFrm             linesPerFrame
#define IS11172VdCpblty_pctrRt          pictureRate
#define IS11172VCy_lmnncSmplRt          luminanceSampleRate

// VideoCapability
#define VdCpblty_nonStandard_chosen     VideoCapability_nonStandard_chosen
#define VdCpblty_nonStandard            nonStandard

// AudioCapability
#define AdCpblty_nonStandard_chosen     AudioCapability_nonStandard_chosen
#define AdCpblty_g711Alaw64k_chosen     AudioCapability_g711Alaw64k_chosen
#define AdCpblty_g711Alaw56k_chosen     AudioCapability_g711Alaw56k_chosen
#define AdCpblty_g711Ulaw64k_chosen     AudioCapability_g711Ulaw64k_chosen
#define AdCpblty_g711Ulaw56k_chosen     AudioCapability_g711Ulaw56k_chosen
#define AudioCapability_g722_64k_chosen g722_64k_chosen
#define AudioCapability_g722_56k_chosen g722_56k_chosen
#define AudioCapability_g722_48k_chosen g722_48k_chosen
#define AdCpblty_g729AnnexA_chosen      AudioCapability_g729AnnexA_chosen
#define ACy_g729AASSn_chosen            AudioCapability_g729AnnexAwSilenceSuppression_chosen
#define AdCpblty_nonStandard            nonStandard
#define AdCpblty_g711Alaw64k            g711Alaw64k
#define AdCpblty_g711Alaw56k            g711Alaw56k
#define AdCpblty_g711Ulaw64k            g711Ulaw64k
#define AdCpblty_g711Ulaw56k            g711Ulaw56k
#define AudioCapability_g722_64k        g722_64k
#define AudioCapability_g722_56k        g722_56k
#define AudioCapability_g722_48k        g722_48k
#define AudioCapability_g7231           g7231
#define AudioCapability_g728            g728
#define AudioCapability_g729            g729
#define AdCpblty_g729AnnexA             g729AnnexA
#define ACy_g729AASSn                   g729AnnexAwSilenceSuppression

// Capability
#define rcvAndTrnsmtVdCpblty_chosen     receiveAndTransmitVideoCapability_chosen
#define rcvAndTrnsmtAdCpblty_chosen     receiveAndTransmitAudioCapability_chosen
#define rcvDtApplctnCpblty_chosen       receiveDataApplicationCapability_chosen
#define trnsmtDtApplctnCpblty_chosen    transmitDataApplicationCapability_chosen
#define rATDACy_chosen                  receiveAndTransmitDataApplicationCapability_chosen
#define h233EncryptnTrnsmtCpblty_chosen h233EncryptionTransmitCapability_chosen
#define h233EncryptnRcvCpblty_chosen    h233EncryptionReceiveCapability_chosen
#define Capability_nonStandard          nonStandard
#define rcvAndTrnsmtVdCpblty            receiveAndTransmitVideoCapability
#define rcvAndTrnsmtAdCpblty            receiveAndTransmitAudioCapability
#define rcvDtApplctnCpblty              receiveDataApplicationCapability
#define trnsmtDtApplctnCpblty           transmitDataApplicationCapability
#define rATDACy                         receiveAndTransmitDataApplicationCapability
#define h233EncryptnTrnsmtCpblty        h233EncryptionTransmitCapability
#define h233EncryptnRcvCpblty           h233EncryptionReceiveCapability

// CapabilityDescriptor
#define smltnsCpblts_present            simultaneousCapabilities_present
#define smltnsCpblts                    simultaneousCapabilities

// EncryptionMode
#define EncryptnMd_nonStandard_chosen   EncryptionMode_nonStandard_chosen
#define EncryptnMd_nonStandard          nonStandard

// DataType
#define DataType_nonStandard            nonStandard
#define DataType_videoData              videoData
#define DataType_audioData              audioData
#define DataType_data                   data

// _choice5 vs H223LogicalChannelParameters_adaptationLayerType
#define H223LCPs_aLTp_nnStndrd_chosen   H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen
#define H223LCPs_aLTp_al1Frmd_chosen    H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen
#define H223LCPs_aLTp_al1NtFrmd_chosen  H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen
#define H223LCPs_aLTp_a2WSNs_1_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223LCPs_aLTp_a2WSNs_2_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223LCPs_aLTp_al3_chosen        H223LogicalChannelParameters_adaptationLayerType_al3_chosen
#define H223LCPs_aLTp_nnStndrd          nonStandard
#define H223LCPs_aLTp_al3               al3

// UnicastAddress
#define UncstAddrss_iP6Address_chosen   UnicastAddress_iP6Address_chosen
#define UAs_nnStndrdAddrss_chosen       UnicastAddress_nonStandardAddress_chosen
#define UnicastAddress_iPAddress        iPAddress
#define UncstAddrss_iP6Address          iP6Address
#define UnicastAddress_nsap             nsap
#define UAs_nnStndrdAddrss              nonStandardAddress

// MulticastAddress
#define MltcstAddrss_iPAddress_chosen   MulticastAddress_iPAddress_chosen
#define MltcstAddrss_iP6Address_chosen  MulticastAddress_iP6Address_chosen
#define MAs_nnStndrdAddrss_chosen       MulticastAddress_nonStandardAddress_chosen
#define MltcstAddrss_iPAddress          iPAddress
#define MltcstAddrss_iP6Address         iP6Address
#define MulticastAddress_nsap           nsap
#define MAs_nnStndrdAddrss              nonStandardAddress

// H2250LogicalChannelParameters
#define H2250LCPs_nnStndrd_present      H2250LogicalChannelParameters_nonStandard_present
#define H2250LCPs_assctdSssnID_present  H2250LogicalChannelParameters_associatedSessionID_present
#define H2250LCPs_mdChnnl_present       H2250LogicalChannelParameters_mediaChannel_present
#define H2250LCPs_mdGrntdDlvry_present  H2250LogicalChannelParameters_mediaGuaranteedDelivery_present
#define H2250LCPs_mdCntrlChnnl_present  H2250LogicalChannelParameters_mediaControlChannel_present
#define H2250LCPs_mCGDy_present         H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present
#define H2250LCPs_dRTPPTp_present       H2250LogicalChannelParameters_dynamicRTPPayloadType_present
#define H2250LCPs_nnStndrd              nonStandard
#define H2250LCPs_assctdSssnID          associatedSessionID
#define H2250LCPs_mdChnnl               mediaChannel
#define H2250LCPs_mdGrntdDlvry          mediaGuaranteedDelivery
#define H2250LCPs_mdCntrlChnnl          mediaControlChannel
#define H2250LCPs_mCGDy                 mediaControlGuaranteedDelivery
#define H2250LCPs_dRTPPTp               dynamicRTPPayloadType

// _choice20 vs OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
#define fLCPs_mPs_h222LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define fLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define fLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define fLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define fLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define fLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define fLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define fLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define fLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define fLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// _choice21 vs OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define rLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define rLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define rLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define rLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define rLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define rLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// OpenLogicalChannel
#define OLCl_rLCPs_present              OpenLogicalChannel_reverseLogicalChannelParameters_present
#define OpnLgclChnnl_sprtStck_present   OpenLogicalChannel_separateStack_present
#define fLCPs_prtNmbr_present           OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present
#define fLCPs_prtNmbr                   portNumber
#define OLCl_rLCPs_mltplxPrmtrs_present OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present
#define OLCl_rLCPs_mltplxPrmtrs         multiplexParameters
#define OLCl_rLCPs                      reverseLogicalChannelParameters
#define OpnLgclChnnl_sprtStck           separateStack

// _choice23 vs MultiplexElement_type
#define typ_logicalChannelNumber_chosen MultiplexElement_type_logicalChannelNumber_chosen
#define typ_logicalChannelNumber        logicalChannelNumber

// _choice24 vs MultiplexElement_repeatCount
#define repeatCount_finite_chosen       MultiplexElement_repeatCount_finite_chosen
#define repeatCount_finite              finite

// _choice25 vs H261VideoMode_resolution
#define H261VdMd_resolution_qcif_chosen H261VideoMode_resolution_qcif_chosen
#define H261VdMd_resolution_cif_chosen  H261VideoMode_resolution_cif_chosen

// _choice26 vs H262VideoMode_profileAndLevel
#define prflAndLvl_SpatialatH_14_chosen profileAndLevel_SpatialatH_14_chosen

// H262VideoMode
#define H262VdMd_videoBitRate_present   H262VideoMode_videoBitRate_present
#define H262VdMd_vbvBufferSize_present  H262VideoMode_vbvBufferSize_present
#define H262VdMd_samplesPerLine_present H262VideoMode_samplesPerLine_present
#define H262VdMd_linesPerFrame_present  H262VideoMode_linesPerFrame_present
#define H262VdMd_frmsPrScnd_present     H262VideoMode_framesPerSecond_present
#define H262VdMd_lmnncSmplRt_present    H262VideoMode_luminanceSampleRate_present
#define H262VdMd_videoBitRate           videoBitRate
#define H262VdMd_vbvBufferSize          vbvBufferSize
#define H262VdMd_samplesPerLine         samplesPerLine
#define H262VdMd_linesPerFrame          linesPerFrame
#define H262VdMd_frmsPrScnd             framesPerSecond
#define H262VdMd_lmnncSmplRt            luminanceSampleRate

// _choice27 vs H263VideoMode_resolution
#define H263VdMd_resolution_qcif_chosen H263VideoMode_resolution_qcif_chosen
#define H263VdMd_resolution_cif_chosen  H263VideoMode_resolution_cif_chosen

// H263VideoMode
#define H263VdMd_errrCmpnstn_present    H263VideoMode_errorCompensation_present
#define H263VdMd_errrCmpnstn            errorCompensation

// IS11172VideoMode
#define IS11172VdMd_vdBtRt_present      IS11172VideoMode_videoBitRate_present
#define IS11172VdMd_vbvBffrSz_present   IS11172VideoMode_vbvBufferSize_present
#define IS11172VdMd_smplsPrLn_present   IS11172VideoMode_samplesPerLine_present
#define IS11172VdMd_lnsPrFrm_present    IS11172VideoMode_linesPerFrame_present
#define IS11172VdMd_pictureRate_present IS11172VideoMode_pictureRate_present
#define IS11172VdMd_lmnncSmplRt_present IS11172VideoMode_luminanceSampleRate_present
#define IS11172VdMd_vdBtRt              videoBitRate
#define IS11172VdMd_vbvBffrSz           vbvBufferSize
#define IS11172VdMd_smplsPrLn           samplesPerLine
#define IS11172VdMd_lnsPrFrm            linesPerFrame
#define IS11172VdMd_pictureRate         pictureRate
#define IS11172VdMd_lmnncSmplRt         luminanceSampleRate

// VideoMode
#define VideoMode_nonStandard           nonStandard

// _choice28 vs IS11172AudioMode_audioLayer
#define audioLayer1_chosen      IS11172AudioMode_audioLayer_audioLayer1_chosen
#define audioLayer2_chosen      IS11172AudioMode_audioLayer_audioLayer2_chosen
#define audioLayer3_chosen      IS11172AudioMode_audioLayer_audioLayer3_chosen

// _choice29 vs IS11172AudioMode_audioSampling
#define IS11172AMd_aSg_aS32k_chosen     IS11172AudioMode_audioSampling_audioSampling32k_chosen
#define IS11172AMd_aSg_aS441_chosen     IS11172AudioMode_audioSampling_audioSampling44k1_chosen
#define IS11172AMd_aSg_aS48k_chosen     IS11172AudioMode_audioSampling_audioSampling48k_chosen

// _choice30 vs IS11172AudioMode_multichannelType
#define IS11172AMd_mTp_snglChnnl_chosen IS11172AudioMode_multichannelType_singleChannel_chosen
#define IS11172AMd_mTp_tCSr_chosen      IS11172AudioMode_multichannelType_twoChannelStereo_chosen
#define IS11172AMd_mTp_twChnnlDl_chosen IS11172AudioMode_multichannelType_twoChannelDual_chosen

// _choice32 vs IS13818AudioMode_audioSampling
#define IS13818AMd_aSg_aS32k_chosen     IS13818AudioMode_audioSampling_audioSampling32k_chosen
#define IS13818AMd_aSg_aS441_chosen     IS13818AudioMode_audioSampling_audioSampling44k1_chosen
#define IS13818AMd_aSg_aS48k_chosen     IS13818AudioMode_audioSampling_audioSampling48k_chosen

// _choice33 vs IS13818AudioMode_multichannelType
#define IS13818AMd_mTp_snglChnnl_chosen IS13818AudioMode_multichannelType_singleChannel_chosen
#define IS13818AMd_mTp_tCSr_chosen      IS13818AudioMode_multichannelType_twoChannelStereo_chosen
#define IS13818AMd_mTp_twChnnlDl_chosen IS13818AudioMode_multichannelType_twoChannelDual_chosen

// _choice34 vs AudioMode_g7231
#define nSlncSpprssnLwRt_chosen         noSilenceSuppressionLowRate_chosen
#define nSlncSpprssnHghRt_chosen        noSilenceSuppressionHighRate_chosen
#define slncSpprssnLwRt_chosen          silenceSuppressionLowRate_chosen
#define slncSpprssnHghRt_chosen         silenceSuppressionHighRate_chosen

// AudioMode
#define AMd_g729AASSn_chosen            AudioMode_g729AnnexAwSilenceSuppression_chosen
#define AudioMode_nonStandard           nonStandard
#define AudioMode_g7231                 g7231

// _choice35 vs DataMode_application
#define DtMd_applctn_nonStandard_chosen DataMode_application_nonStandard_chosen
#define DtMd_application_t120_chosen    DataMode_application_t120_chosen
#define DtMd_application_dsm_cc_chosen  dsm_cc_chosen
#define DtMd_applctn_userData_chosen    DataMode_application_userData_chosen
#define DtMd_application_t434_chosen    DataMode_application_t434_chosen
#define DtMd_application_h224_chosen    DataMode_application_h224_chosen
#define DtMd_application_nlpid_chosen   DataMode_application_nlpid_chosen
#define DtMd_applctn_dsvdControl_chosen DataMode_application_dsvdControl_chosen
#define DMd_an_h222DtPrttnng_chosen     DataMode_application_h222DataPartitioning_chosen
#define DtMd_applctn_nonStandard        nonStandard
#define DtMd_application_t120           t120
#define DtMd_application_dsm_cc         dsm_cc
#define DtMd_applctn_userData           userData
#define DataMode_application_t84        t84
#define DtMd_application_t434           t434
#define DtMd_application_h224           h224
#define DtMd_application_nlpid          nlpid
#define DMd_an_h222DtPrttnng            h222DataPartitioning

// _choice36 vs H223ModeParameters_adaptationLayerType
#define H223MPs_aLTp_nnStndrd_chosen    H223ModeParameters_adaptationLayerType_nonStandard_chosen
#define H223MPs_aLTp_al1Frmd_chosen     H223ModeParameters_adaptationLayerType_al1Framed_chosen
#define H223MPs_aLTp_al1NtFrmd_chosen   H223ModeParameters_adaptationLayerType_al1NotFramed_chosen
#define H223MPs_aLTp_a2WSNs_1_chosen    H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223MPs_aLTp_a2WSNs_2_chosen    H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223MPs_adpttnLyrTyp_al3_chosen H223ModeParameters_adaptationLayerType_al3_chosen
#define H223MPs_aLTp_nnStndrd           nonStandard
#define H223MPs_adpttnLyrTyp_al3        al3

// ModeElement
#define h223AnnxAMdPrmtrs_present       h223AnnexAModeParameters_present
#define h223AnnxAMdPrmtrs               h223AnnexAModeParameters

// _choice38 vs MaintenanceLoopRequest_type
#define systemLoop_chosen               MaintenanceLoopRequest_type_systemLoop_chosen // MaintenanceLoopReject_type_systemLoop_chosen
#define mediaLoop_chosen                MaintenanceLoopRequest_type_mediaLoop_chosen // MaintenanceLoopReject_type_mediaLoop_chosen
#define logicalChannelLoop_chosen       MaintenanceLoopRequest_type_logicalChannelLoop_chosen // MaintenanceLoopReject_type_logicalChannelLoop_chosen

// RequestMessage
#define RqstMssg_nonStandard_chosen     RequestMessage_nonStandard_chosen
#define h223AnnxARcnfgrtn_chosen        h223AnnexAReconfiguration_chosen
#define RqstMssg_nonStandard            nonStandard
#define h223AnnxARcnfgrtn               h223AnnexAReconfiguration

// _choice45 vs TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
#define hghstEntryNmbrPrcssd_chosen     highestEntryNumberProcessed_chosen
#define hghstEntryNmbrPrcssd            highestEntryNumberProcessed

// _choice46 vs TerminalCapabilitySetReject_cause
#define TCSRt_cs_unspcfd_chosen         TerminalCapabilitySetReject_cause_unspecified_chosen
#define dscrptrCpctyExcdd_chosen        descriptorCapacityExceeded_chosen
#define tblEntryCpctyExcdd_chosen       tableEntryCapacityExceeded_chosen
#define tblEntryCpctyExcdd              tableEntryCapacityExceeded

// H2250LgclChnnlAckPrmtrs vs H2250LogicalChannelAckParameters
#define H2250LgclChnnlAckPrmtrs         H2250LogicalChannelAckParameters
#define H2250LCAPs_nnStndrd_present     H2250LogicalChannelAckParameters_nonStandard_present
#define H2250LCAPs_mdChnnl_present      H2250LogicalChannelAckParameters_mediaChannel_present
#define H2250LCAPs_mdCntrlChnnl_present H2250LogicalChannelAckParameters_mediaControlChannel_present
#define H2250LCAPs_dRTPPTp_present      H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present
#define H2250LCAPs_nnStndrd             nonStandard
#define H2250LCAPs_mdChnnl              mediaChannel
#define H2250LCAPs_mdCntrlChnnl         mediaControlChannel
#define H2250LCAPs_dRTPPTp              dynamicRTPPayloadType

// _choice47 vs OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h222LCPs_chosen       OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define mPs_h2250LgclChnnlPrmtrs_chosen OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define mPs_h2250LgclChnnlPrmtrs        h2250LogicalChannelParameters

// _choice48 vs OpenLogicalChannelAck_forwardMultiplexAckParameters
#define h2250LgclChnnlAckPrmtrs_chosen  h2250LogicalChannelAckParameters_chosen
#define h2250LgclChnnlAckPrmtrs         h2250LogicalChannelAckParameters

// OpenLogicalChannelAck
#define OLCAk_rLCPs_present             OpenLogicalChannelAck_reverseLogicalChannelParameters_present
#define OLCAk_sprtStck_present          OpenLogicalChannelAck_separateStack_present
#define frwrdMltplxAckPrmtrs_present    forwardMultiplexAckParameters_present
#define rLCPs_prtNmbr_present           OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present
#define OLCAk_rLCPs_mPs_present         OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present
#define rLCPs_prtNmbr                   portNumber
#define OLCAk_rLCPs_mPs                 multiplexParameters
#define OLCAk_rLCPs                     reverseLogicalChannelParameters
#define OLCAk_sprtStck                  separateStack
#define frwrdMltplxAckPrmtrs            forwardMultiplexAckParameters

// _choice49 vs OpenLogicalChannelReject_cause
#define OLCRt_cs_unspcfd_chosen         OpenLogicalChannelReject_cause_unspecified_chosen
#define unstblRvrsPrmtrs_chosen         unsuitableReverseParameters_chosen
#define dtTypALCmbntnNtSpprtd_chosen    dataTypeALCombinationNotSupported_chosen
#define mltcstChnnlNtAllwd_chosen       multicastChannelNotAllowed_chosen
#define sprtStckEstblshmntFld_chosen    separateStackEstablishmentFailed_chosen

// _choice51 vs MultiplexEntryRejectionDescriptions_cause
#define MERDs_cs_unspcfdCs_chosen       MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// MltplxEntryRjctnDscrptns vs MultiplexEntryRejectionDescriptions
#define MltplxEntryRjctnDscrptns        MultiplexEntryRejectionDescriptions

// _choice52 vs RequestMultiplexEntryRejectionDescriptions_cause
#define RMERDs_cs_unspcfdCs_chosen      RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// RqstMltplxEntryRjctnDscrptns vs RequestMultiplexEntryRejectionDescriptions
#define RqstMltplxEntryRjctnDscrptns    RequestMultiplexEntryRejectionDescriptions

// _choice53 vs RequestModeAck_response
#define wllTrnsmtMstPrfrrdMd_chosen     willTransmitMostPreferredMode_chosen
#define wllTrnsmtLssPrfrrdMd_chosen     willTransmitLessPreferredMode_chosen

// _choice57 vs CommunicationModeTableEntry_dataType
#define dataType_videoData_chosen       CommunicationModeTableEntry_dataType_videoData_chosen
#define dataType_audioData_chosen       CommunicationModeTableEntry_dataType_audioData_chosen
#define dataType_data_chosen            CommunicationModeTableEntry_dataType_data_chosen
#define dataType_videoData              videoData
#define dataType_audioData              audioData
#define dataType_data                   data

// CommunicationModeTableEntry
#define CMTEy_nnStndrd_present          CommunicationModeTableEntry_nonStandard_present
#define CMTEy_assctdSssnID_present      CommunicationModeTableEntry_associatedSessionID_present
#define CMTEy_mdChnnl_present           CommunicationModeTableEntry_mediaChannel_present
#define CMTEy_mdGrntdDlvry_present      CommunicationModeTableEntry_mediaGuaranteedDelivery_present
#define CMTEy_mdCntrlChnnl_present      CommunicationModeTableEntry_mediaControlChannel_present
#define CMTEy_mdCntrlGrntdDlvry_present CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present
#define CMTEy_nnStndrd                  nonStandard
#define CMTEy_assctdSssnID              associatedSessionID
#define CMTEy_mdChnnl                   mediaChannel
#define CMTEy_mdGrntdDlvry              mediaGuaranteedDelivery
#define CMTEy_mdCntrlChnnl              mediaControlChannel
#define CMTEy_mdCntrlGrntdDlvry         mediaControlGuaranteedDelivery

// ResponseMessage
#define RspnsMssg_nonStandard_chosen    ResponseMessage_nonStandard_chosen
#define mstrSlvDtrmntnAck_chosen        masterSlaveDeterminationAck_chosen
#define mstrSlvDtrmntnRjct_chosen       masterSlaveDeterminationReject_chosen
#define trmnlCpbltyStRjct_chosen        terminalCapabilitySetReject_chosen
#define rqstChnnlClsRjct_chosen         requestChannelCloseReject_chosen
#define rqstMltplxEntryRjct_chosen      requestMultiplexEntryReject_chosen
#define cmmnctnMdRspns_chosen           communicationModeResponse_chosen
#define h223AnnxARcnfgrtnAck_chosen     h223AnnexAReconfigurationAck_chosen
#define h223AnnxARcnfgrtnRjct_chosen    h223AnnexAReconfigurationReject_chosen
#define RspnsMssg_nonStandard           nonStandard
#define mstrSlvDtrmntnAck               masterSlaveDeterminationAck
#define mstrSlvDtrmntnRjct              masterSlaveDeterminationReject
#define trmnlCpbltyStRjct               terminalCapabilitySetReject
#define rqstChnnlClsRjct                requestChannelCloseReject
#define rqstMltplxEntryRjct             requestMultiplexEntryReject
#define cmmnctnMdRspns                  communicationModeResponse
#define h223AnnxARcnfgrtnAck            h223AnnexAReconfigurationAck
#define h223AnnxARcnfgrtnRjct           h223AnnexAReconfigurationReject

// SendTerminalCapabilitySet
#define cpbltyTblEntryNmbrs_present     capabilityTableEntryNumbers_present
#define cpbltyDscrptrNmbrs_present      capabilityDescriptorNumbers_present
#define cpbltyTblEntryNmbrs             capabilityTableEntryNumbers
#define cpbltyDscrptrNmbrs              capabilityDescriptorNumbers

// _choice59 vs FlowControlCommand_scope
#define FCCd_scp_lgclChnnlNmbr_chosen   FlowControlCommand_scope_logicalChannelNumber_chosen
#define FlwCntrlCmmnd_scp_rsrcID_chosen FlowControlCommand_scope_resourceID_chosen
#define FCCd_scp_whlMltplx_chosen       FlowControlCommand_scope_wholeMultiplex_chosen
#define FCCd_scp_lgclChnnlNmbr          logicalChannelNumber
#define FlwCntrlCmmnd_scp_rsrcID        resourceID

// EndSessionCommand
#define EndSssnCmmnd_nonStandard_chosen EndSessionCommand_nonStandard_chosen
#define EndSssnCmmnd_nonStandard        nonStandard

// _choice62 vs MiscellaneousCommand_type
#define cnclMltpntMdCmmnd_chosen        cancelMultipointModeCommand_chosen
#define MCd_tp_vdTmprlSptlTrdOff_chosen MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen
#define vdSndSyncEvryGOBCncl_chosen     videoSendSyncEveryGOBCancel_chosen
#define MCd_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// ConferenceCommand
#define brdcstMyLgclChnnl_chosen        broadcastMyLogicalChannel_chosen
#define cnclBrdcstMyLgclChnnl_chosen    cancelBroadcastMyLogicalChannel_chosen
#define cnclMkTrmnlBrdcstr_chosen       cancelMakeTerminalBroadcaster_chosen
#define brdcstMyLgclChnnl               broadcastMyLogicalChannel
#define cnclBrdcstMyLgclChnnl           cancelBroadcastMyLogicalChannel
             
// CommandMessage
#define CmmndMssg_nonStandard_chosen    CommandMessage_nonStandard_chosen
#define mntnncLpOffCmmnd_chosen         maintenanceLoopOffCommand_chosen
#define sndTrmnlCpbltySt_chosen         sendTerminalCapabilitySet_chosen
#define CmmndMssg_nonStandard           nonStandard
#define mntnncLpOffCmmnd                maintenanceLoopOffCommand
#define sndTrmnlCpbltySt                sendTerminalCapabilitySet

// FunctionNotUnderstood
#define FnctnNtUndrstd_request_chosen   FunctionNotUnderstood_request_chosen
#define FnctnNtUndrstd_response_chosen  FunctionNotUnderstood_response_chosen
#define FnctnNtUndrstd_command_chosen   FunctionNotUnderstood_command_chosen
#define FnctnNtUndrstd_request          request
#define FnctnNtUndrstd_response         response
#define FnctnNtUndrstd_command          command

// _choice63 vs MiscellaneousIndication_type
#define cnclMltpntCnfrnc_chosen         cancelMultipointConference_chosen
#define mltpntScndryStts_chosen         multipointSecondaryStatus_chosen
#define cnclMltpntScndryStts_chosen     cancelMultipointSecondaryStatus_chosen
#define vdIndctRdyTActvt_chosen         videoIndicateReadyToActivate_chosen
#define MIn_tp_vdTmprlSptlTrdOff_chosen MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen
#define MIn_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// _choice64 vs JitterIndication_scope
#define JIn_scp_lgclChnnlNmbr_chosen    JitterIndication_scope_logicalChannelNumber_chosen
#define JttrIndctn_scp_rsrcID_chosen    JitterIndication_scope_resourceID_chosen
#define JttrIndctn_scp_whlMltplx_chosen JitterIndication_scope_wholeMultiplex_chosen
#define JIn_scp_lgclChnnlNmbr           logicalChannelNumber
#define JttrIndctn_scp_rsrcID           resourceID

// UserInputIndication
#define UsrInptIndctn_nnStndrd_chosen   UserInputIndication_nonStandard_chosen
#define UsrInptIndctn_nnStndrd          nonStandard

// ConferenceIndication
#define cnclSnByAtLstOnOthr_chosen      cancelSeenByAtLeastOneOther_chosen

// IndicationMessage
#define IndctnMssg_nonStandard_chosen   IndicationMessage_nonStandard_chosen
#define mstrSlvDtrmntnRls_chosen        masterSlaveDeterminationRelease_chosen
#define trmnlCpbltyStRls_chosen         terminalCapabilitySetRelease_chosen
#define opnLgclChnnlCnfrm_chosen        openLogicalChannelConfirm_chosen
#define rqstChnnlClsRls_chosen          requestChannelCloseRelease_chosen
#define mltplxEntrySndRls_chosen        multiplexEntrySendRelease_chosen
#define rqstMltplxEntryRls_chosen       requestMultiplexEntryRelease_chosen
#define h2250MxmmSkwIndctn_chosen       h2250MaximumSkewIndication_chosen
#define IndctnMssg_nonStandard          nonStandard
#define mstrSlvDtrmntnRls               masterSlaveDeterminationRelease
#define trmnlCpbltyStRls                terminalCapabilitySetRelease
#define opnLgclChnnlCnfrm               openLogicalChannelConfirm
#define rqstChnnlClsRls                 requestChannelCloseRelease
#define mltplxEntrySndRls               multiplexEntrySendRelease
#define rqstMltplxEntryRls              requestMultiplexEntryRelease
#define h2250MxmmSkwIndctn              h2250MaximumSkewIndication

// MltmdSystmCntrlMssg vs MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg             MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg_PDU         MultimediaSystemControlMessage_PDU
#define MltmdSystmCntrlMssg_rqst_chosen MultimediaSystemControlMessage_request_chosen
#define MSCMg_rspns_chosen              MultimediaSystemControlMessage_response_chosen
#define MSCMg_cmmnd_chosen              MultimediaSystemControlMessage_command_chosen
#define MltmdSystmCntrlMssg_rqst        request
#define MSCMg_rspns                     response
#define MSCMg_cmmnd                     command


#ifdef __cplusplus
}
#endif

#endif // H245ASN1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\linkapi.h ===
/***************************************************************************
 *
 * File: linkapi.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   linkapi.h  $
 * $Revision:   1.17  $
 * $Modtime:   11 Dec 1996 13:57:14  $
 * $Log:   S:\sturgeon\src\include\vcs\linkapi.h_v  $
 * 
 *    Rev 1.17   11 Dec 1996 14:10:48   SBELL1
 * changed parameters to linkLayerInit/Listen
 * 
 *    Rev 1.16.1.0   11 Dec 1996 13:57:14   SBELL1
 * CHanged parameters to linkLayerInit and Listen.
 * 
 *    Rev 1.16   14 Oct 1996 14:00:20   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.15   15 Aug 1996 14:00:08   rodellx
 * 
 * Added additional address validation error case for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 * 
 *    Rev 1.14   11 Jul 1996 18:42:10   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.13   10 Jul 1996 21:36:26   rodellx
 * 
 * Changed error code base to required value defined by apierror.h.
 * 
 *    Rev 1.12   May 28 1996 18:09:08   plantz
 * Change all error and message codes to use HRESULT. Deleted unused codes.
 * 
 *    Rev 1.11   09 May 1996 18:28:36   EHOWARDX
 * Eliminated unnessary formal parameters.
 * 
 *    Rev 1.4   25 Apr 1996 21:43:50   helgebax
 * Copied Philip's changes from sturgeon\src\include.
 * 
 *    Rev 1.10   Apr 25 1996 21:07:16   plantz
 * Add messages for connect callback.
 * Add connect callback parameter to link layer accept.
 * 
 *    Rev 1.9   Apr 25 1996 15:36:50   plantz
 * Remove #include incommon.h and dependencies on types defined in incommon
 * (use pointers to incomplete structure types instead).
 * 
 *    Rev 1.8   Apr 24 1996 20:54:08   plantz
 * Change name of H245LISTENCALLBACK to H245CONNECTCALLBACK and add additional
 * parameters. Add it as an parameter to linkLayerConnect as well as
 * linkLayerListen.
 * 
 *    Rev 1.7   Apr 24 1996 17:00:04   plantz
 * Merge 1.3.1.0 with 1.6 (changes to support Q931).
 * 
 *    Rev 1.6   19 Apr 1996 10:35:36   EHOWARDX
 * Encorporate Dan's latest SRPAPI.H changes.
 * 
 *    Rev 1.3.1.0   Apr 23 1996 13:45:26   plantz
 * Changes to support Q.931.
 * 
 *****************************************************************************/

#ifndef LINKAPI_H
#define LINKAPI_H

#include "apierror.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// declare exported functions
#if defined(LINKDLL_EXPORT)
#define LINKDLL __declspec (dllexport)
#else   // (LINKDLL_EXPORT)
#define LINKDLL __declspec (dllimport)
#endif  // (LINKDLL_EXPORT)
#define SRPDLL LINKDLL

////////////////////////////////////////////////////////////////////////////
//
// Link Layer defaults
//
////////////////////////////////////////////////////////////////////////////

#define INVALID_PHYS_ID			(DWORD) 0xffffffff


////////////////////////////////////////////////////////////////////////////
//
// Link Layer Error defines
//
////////////////////////////////////////////////////////////////////////////

#define LINK_ERROR_BASE        ERROR_LOCAL_BASE_ID
#define LINK_SEND_ERROR_BASE   LINK_ERROR_BASE + 0x100
#define LINK_SEND_COMP_BASE    LINK_ERROR_BASE + 0x200
#define LINK_RCV_ERROR_BASE    LINK_ERROR_BASE + 0x300
#define LINK_RCV_COMP_BASE     LINK_ERROR_BASE + 0x400
#define LINK_UTIL_ERROR_BASE   LINK_ERROR_BASE + 0x500
#define LINK_UTIL_COMP_BASE    LINK_ERROR_BASE + 0x600
#define LINK_FATAL_ERROR       LINK_ERROR_BASE + 0x700
#define LINK_CONN_ERROR_BASE   LINK_ERROR_BASE + 0x800
#define LINK_CONN_COMP_BASE    LINK_ERROR_BASE + 0x900

////////////////////////////////////////////////////////////////////////////
//
// CallBack Prototype for Channel CallBack
//
////////////////////////////////////////////////////////////////////////////

typedef void (*H245SRCALLBACK)
(
    DWORD       dwH245Instance,
    HRESULT     dwMessage,
    PBYTE       pbyDataBuf,
    DWORD       dwLength
);

// Link Send Callback error codes
#define LINK_SEND_COMPLETE     MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 0)
#define LINK_SEND_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 5) // Tx aborted the SDU (not implemented)
#define LINK_SEND_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+20)
#define LINK_SEND_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+22)
#define LINK_SEND_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+23)

// Link Receive Callback error codes
#define LINK_RECV_DATA         MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 6) // DATA.INDICATION from H.223 (Should not be zero)
#define LINK_RECV_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 7) // Tx aborted the SDU (not implemented)
#define LINK_RECV_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+10) // from AL2 - _CRC error
#define LINK_RECV_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+20)
#define LINK_RECV_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+22)

typedef void (*H245CONNECTCALLBACK)
(
   DWORD       dwH245Instance,
   HRESULT     dwMessage,
   struct _ADDR *LocalAddr,
   struct _ADDR *PeerAddr
);

#define LINK_CONNECT_REQUEST   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+1)
#define LINK_CONNECT_COMPLETE  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+2)

////////////////////////////////////////////////////////////////////////////
//
// Link Layer Function Prototypes
//
////////////////////////////////////////////////////////////////////////////
LINKDLL VOID H245WSShutdown();

/**************************************************************************
**	Function 	: linkLayerInit
**	Description : This function will initialize the datalink subsystem. 
**				  This in turn will make appropriate calls to initialize 
**				  the software and hardware subsystems below this layer. 
**				  linkLayernit() has to be called before any other service or
**				  System control functions are used.
****************************************************************************/
LINKDLL HRESULT
linkLayerInit
(
    DWORD*           pdwPhysicalId,
    DWORD           dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

typedef
HRESULT 
(*PFxnlinkLayerInit)
(
    DWORD*           pdwPhysicalId,
    DWORD           dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

///////////////////////////////////////////////////////////////
///
///	SRP Initialization defines
///
///////////////////////////////////////////////////////////////

#define LINK_INVALID_INSTANCE    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+1)
#define LINK_DUPLICATE_INSTANCE  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+2)
#define LINK_MEM_FAILURE         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, ERROR_OUTOFMEMORY)
#define LINK_INVALID_STATE       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+6)



/**************************************************************************
**	Function 	: linkLayerShutdown
**	Description : This releases all the memory the link layer used for a particular 
**				  instance. For using any of the linklayer services in that 
**				  instance again, a linkLayerInit has to be called. 
**				  This function will shutdown the linklayer session pointed 
**				  by the dwPhysicalID.
***************************************************************************/
LINKDLL HRESULT
linkLayerShutdown
(DWORD dwPhysicalId);



typedef
 HRESULT 
(*PFxnlinkLayerShutdown)
(DWORD dwPhysicalId);



///////////////////////////////////////////////////////////////
///
///	SRP Termination defines
///
///////////////////////////////////////////////////////////////

/**************************************************************************
**	Function 	: linkLayerGetInstance
**	Description : Returns the link layer instance corresponding to a physical ID
***************************************************************************/
LINKDLL DWORD
linkLayerGetInstance
(DWORD dwPhysicalId);



typedef
DWORD  
(*PFxnlinkLayerGetInstance)
(DWORD dwPhysicalId);



/**************************************************************************
**	Function 	: datalinkReceiveRequest
**	Description : Posts one receive message buffer to the link layer subsystem. 
**				  This buffer will be filled in by the incoming message for
** 				  the specified channel. H223_DATA_INDICATION will be sendto 
**				  the client on receiving a complete PDU. Error messages may also be 
**				  reported.
***************************************************************************/
LINKDLL HRESULT
datalinkReceiveRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT  
(*PFxndatalinkReceiveRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Receive Request return codes

#define LINK_RECV_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_ERROR_BASE+ 2) // No room for buffering


/**************************************************************************
**	Function 	: datalinkSendRequest
**	Description : Hands over the message to be sent to the link layer subsystem.
***************************************************************************/
LINKDLL HRESULT
datalinkSendRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT  
(*PFxndatalinkSendRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Send Request return codes

#define LINK_SEND_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_ERROR_BASE+2)


/**************************************************************************
**	Function 	: linkLayerFlushChannel
**	Description : All the posted transmit and/or receive buffers are released.
**					The bitmasks DATALINK_RECEIVE and DATALINK_RECEIVE can
**					be OR'd together to perform both functions in the same call
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushChannel
(DWORD dwPhysicalId, DWORD dwDirectionMask);




typedef
HRESULT 
(*PFxnlinkLayerFlushChannel)
(DWORD dwPhysicalId, DWORD dwDirectionMask);




// Bits for dwDirectionMask
#define DATALINK_RECEIVE      0x01  // Flush buffer in receive direction
#define DATALINK_TRANSMIT     0x02  // Flush buffer in Transmit direction
#define DATALINK_TX_ACTIVES   0x04  // Flush buffers actively being transmitted
#define SHUTDOWN_PENDING      0x08  // Shutdown is in progress
#define FLUSH_SYNCH           0x10  // 0: Asynch call, 1: Synchronous call
#define DATALINK_TRANSMIT_ALL (DATALINK_TRANSMIT | DATALINK_TX_ACTIVES)
#define SHUTDOWN_MASK         (DATALINK_RECEIVE | DATALINK_TRANSMIT | SHUTDOWN_PENDING)


// linkLayerFlushChannel Callback

#define LINK_FLUSH_COMPLETE   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_UTIL_COMP_BASE+1)


/**************************************************************************
**	Function 	: linkLayerFlushAll
**	Description : All the posted transmit and/or receive buffers are released.
**					Same as LinkLayerFlushChannel except:
**					1) Synchronous Call
**					2) Transmit Buffers in progress are flushed
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushAll
(DWORD	dwPhysicalId);



typedef
HRESULT 
(*PFxnlinkLayerFlushAll)
(DWORD	dwPhysicalId);



// linkLayerFlushChannel RETURN CODES same as for linkLayerFlushChannel

#define LINK_UNKNOWN_ADDR      MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, LINK_UTIL_ERROR_BASE + 1)

LINKDLL HRESULT
linkLayerConnect(DWORD dwPhysicalId, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerListen(DWORD* dwPhysicalId, DWORD dwH245Instance, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback);


#define LL_PDU_SIZE             2048



/**************************************************************************
**
**  Dynamic DLL Function Calls
**
**************************************************************************/
#ifdef UNICODE
#define SRPDLLFILE          L"h245srp.dll"
#define H245WSDLLFILE       L"h245ws.dll"
#else
#define SRPDLLFILE          "h245srp.dll"
#define H245WSDLLFILE       "h245ws.dll"
#endif
#define LINKINITIALIZE      __TEXT("linkLayerInit")
#define LINKSHUTDOWN        __TEXT("linkLayerShutdown")
#define LINKGETINSTANCE     __TEXT("linkLayerGetInstance")
#define LINKRECEIVEREQUEST  __TEXT("datalinkReceiveRequest")
#define LINKSENDREQUEST     __TEXT("datalinkSendRequest")
#define LINKFLUSHCHANNEL    __TEXT("linkLayerFlushChannel")
#define LINKFLUSHALL        __TEXT("linkLayerFlushAll")

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // LINKAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\q931.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.49  $
 *	$Date:   08 Jan 1997 18:02:54  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef Q931_H
#define Q931_H


#include "incommon.h"
#include "q931pdu.h"
#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

//====================================================================================
// Q931-specific codes
//====================================================================================

// Status codes
#define CS_OK                               NOERROR
#define CS_BAD_PARAM                        MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x1)
#define CS_DUPLICATE_LISTEN                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x2)
#define CS_INTERNAL_ERROR                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x3)
#define CS_BAD_SIZE                         MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x4)
#define CS_NO_MEMORY                        MAKE_Q931_ERROR(ERROR_OUTOFMEMORY)
#define CS_NOT_IMPLEMENTED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x6)
#define CS_NOT_INITIALIZED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x7)
#define CS_DUPLICATE_INITIALIZE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x8)
#define CS_SUBSYSTEM_FAILURE                MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x9)
#define CS_OUT_OF_SEQUENCE                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xA)
#define CS_PEER_UNREACHABLE                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xB)
#define CS_SETUP_TIMER_EXPIRED              MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xC)
#define CS_RINGING_TIMER_EXPIRED            MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xD)
#define CS_INCOMPATIBLE_VERSION             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xE)

// parsing error cases
#define CS_OPTION_NOT_IMPLEMENTED           MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xF)
#define CS_ENDOFINPUT                       MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x10)
#define CS_INVALID_FIELD                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x11)
#define CS_NO_FIELD_DATA                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x12)
#define CS_INVALID_PROTOCOL                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x13)
#define CS_INVALID_MESSAGE_TYPE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x14)
#define CS_MANDATORY_IE_MISSING             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x15)
#define CS_BAD_IE_CONTENT                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x16)

// Event codes
#define Q931_CALL_INCOMING                  1
#define Q931_CALL_REMOTE_HANGUP             2
#define Q931_CALL_REJECTED                  3
#define Q931_CALL_ACCEPTED                  4
#define Q931_CALL_RINGING                   5
#define Q931_CALL_FAILED                    6
#define Q931_CALL_CONNECTION_CLOSED         7

// Goal codes
#define CSG_NONE                            0
#define CSG_JOIN                            1
#define CSG_CREATE                          2
#define CSG_INVITE                          3

#define CC_MAX_PARTY_NUMBER_LEN             254

//====================================================================================
// Q931-specific types
//====================================================================================

typedef HRESULT CS_STATUS;
typedef DWORD HQ931LISTEN, *PHQ931LISTEN;
typedef DWORD HQ931CALL, *PHQ931CALL;


//====================================================================================
// Callback definitions.
//====================================================================================

typedef DWORD (*Q931_CALLBACK) (BYTE bEvent, HQ931CALL hQ931Call,
    HQ931LISTEN hListenToken, DWORD dwUserToken, void *pEventData);

typedef BOOL (*Q931_RECEIVE_PDU_CALLBACK) (Q931MESSAGE *pMessage,
    HQ931CALL hQ931Call, DWORD dwListenToken, DWORD dwUserToken);

//====================================================================================
// definitions of structures passed to callbacks as parameters.
//====================================================================================

// CSS_CALL_INCOMING callback parameter type
typedef struct 
{
    WORD wCallReference;
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;
    LPWSTR pszCalledPartyNumber;
    PCC_ADDR pSourceAddr;
    PCC_ADDR pCallerAddr;
    PCC_ADDR pCalleeDestAddr;
    PCC_ADDR pLocalAddr;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pSourceEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_INCOMING, *PCSS_CALL_INCOMING;

// CSS_CALL_REMOTE_HANGUP callback parameter type
typedef struct
{
    BYTE bReason;
} CSS_CALL_REMOTE_HANGUP, *PCSS_CALL_REMOTE_HANGUP;


// CSS_CALL_REJECTED callback parameter type
typedef struct 
{
    BYTE bRejectReason;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pAlternateAddr;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_REJECTED, *PCSS_CALL_REJECTED;

// CSS_CALL_ACCEPTED callback parameter type
typedef struct 
{
    WORD wCallReference;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pCalleeAddr;
    PCC_ADDR pLocalAddr;
    PCC_ADDR pH245Addr;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pDestinationEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_ACCEPTED, *PCSS_CALL_ACCEPTED;

// Q931_CALL_RINGING callback event will have pEventData set to NULL

// CSS_CALL_FAILED callback paremeter type
typedef struct
{
    HRESULT error;
} CSS_CALL_FAILED, *PCSS_CALL_FAILED;

//====================================================================================
// function declarations.
//====================================================================================

CS_STATUS Q931Init();

CS_STATUS Q931DeInit();

CS_STATUS Q931Listen(
    PHQ931LISTEN phQ931Listen,
    PCC_ADDR pListenAddr,
    DWORD dwListenToken,
    Q931_CALLBACK ListenCallback);

CS_STATUS Q931CancelListen(
    HQ931LISTEN hQ931Listen);

CS_STATUS Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD dwUserToken,
    Q931_CALLBACK ConnectCallback,
    WORD wCRV);

CS_STATUS Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason);

CS_STATUS Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV);

CS_STATUS Q931AcceptCall(
    HQ931CALL hQ931Call,
    LPWSTR pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_ADDR pH245Addr,
    DWORD dwUserToken);

CS_STATUS Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931ReOpenConnection(
    HQ931CALL hQ931Call);

CS_STATUS Q931GetVersion(
    WORD wLength,          // character count, not byte count.
    LPWSTR pszVersion);

CS_STATUS Q931SetAlertingTimeout(
    DWORD dwDuration);

void Q931SetReceivePDUHook(
    Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback);

CS_STATUS Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931SendPDU(
    HQ931CALL hQ931Call,
    BYTE* CodedPtrPDU,
    DWORD CodedLengthPDU);

CS_STATUS Q931FlushSendQueue(
    HQ931CALL hQ931Call);

// utility routines
CS_STATUS Q931ValidateAddr(PCC_ADDR pAddr);
CS_STATUS Q931ValidatePartyNumber(LPWSTR pszPartyNumber);

CS_STATUS Q931ValidateAliasItem(PCC_ALIASITEM pSource);
CS_STATUS Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource);
CS_STATUS Q931FreeAliasItem(PCC_ALIASITEM pSource);

CS_STATUS Q931ValidateAliasNames(PCC_ALIASNAMES pSource);
CS_STATUS Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
CS_STATUS Q931FreeAliasNames(PCC_ALIASNAMES pSource);

CS_STATUS Q931ValidateDisplay(LPWSTR pszDisplay);
CS_STATUS Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource);
CS_STATUS Q931FreeDisplay(LPWSTR pszDisplay);

CS_STATUS Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo);
CS_STATUS Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource);
CS_STATUS Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo);

CS_STATUS Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);
CS_STATUS Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource);
CS_STATUS Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);

#ifdef __cplusplus
}
#endif

#endif Q931_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\q931pdu.h ===
/****************************************************************************
 *
 *  $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931pdu.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1996 Intel Corporation.
 *
 *  $Revision:   1.11  $
 *  $Date:   22 Jan 1997 17:21:04  $
 *  $Author:   MANDREWS  $
 *
 *  Abstract: Parser routines for Q931 PDUs
 *
 ***************************************************************************/
#ifndef Q931PAR_H
#define Q931PAR_H

#include <winerror.h>
#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

struct S_BUFFERDESCR
{
    DWORD Length;
    BYTE *BufferPtr;
};

typedef struct S_BUFFERDESCR BUFFERDESCR;
typedef struct S_BUFFERDESCR *PBUFFERDESCR;

// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E
   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN Present;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN Present;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN Present;
    BYTE Length;
    BYTE Contents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The sending complete element is a single type 2
typedef struct S_SINGLESTRUCT2 SENDCOMPLIE;
typedef struct S_SINGLESTRUCT2 *PSENDCOMPLIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The repeat indicator element is a single type 1
typedef struct S_SINGLESTRUCT1 REPEATIE;
typedef struct S_SINGLESTRUCT1 *PREPEATIE;

// The segmented element is a variable 
typedef struct S_VARSTRUCT SEGMENTEDIE;
typedef struct S_VARSTRUCT *PSEGMENTEDIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The end to end transit delay element is a variable 
typedef struct S_VARSTRUCT ENDTOENDDELAYIE;
typedef struct S_VARSTRUCT *PENDTOENDDELAYIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The reverse charge indication element is a variable 
typedef struct S_VARSTRUCT REVERSECHARGEIE;
typedef struct S_VARSTRUCT *PREVERSECHARGEIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The transit network selection element is a variable 
typedef struct S_VARSTRUCT TRANSITNETIE;
typedef struct S_VARSTRUCT *PTRANSITNETIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209 ((PDTYPE)0x05)

struct S_VARSTRUCT_UU
{
    BOOLEAN Present;
    BYTE ProtocolDiscriminator;
    WORD UserInformationLength;
    BYTE UserInformation[0x1000];   // 4k bytes should be good for now...
};

// The user to user element is a variable 
typedef struct S_VARSTRUCT_UU USERUSERIE;
typedef struct S_VARSTRUCT_UU *PUSERUSERIE;

struct S_PARTY_NUMBER
{
    BOOLEAN Present;
    BYTE NumberType;
    BYTE NumberingPlan;
    BYTE PartyNumberLength;
    BYTE PartyNumbers[MAXVARFIELDLEN];
};

// The called party number element is a variable 
typedef struct S_PARTY_NUMBER CALLEDNUMBERIE;
typedef struct S_PARTY_NUMBER *PCALLEDNUMBERIE;

// Q932 defined message types
#define FACILITYMESSAGETYPE   0x62
#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE CallReference;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    SENDCOMPLIE SendingComplete;
    CONGESTIONIE CongestionLevel;
    REPEATIE RepeatIndicator;
    SEGMENTEDIE SegmentedMessage;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    ENDTOENDDELAYIE EndToEndTransitDelay;
    TRANSITDELAYIE TransitDelay;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CLOSEDUGIE ClosedUserGroup;
    REVERSECHARGEIE ReverseChargeIndication;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    TRANSITNETIE TransitNetworkSelection;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;
};

typedef struct S_MESSAGE Q931MESSAGE;
typedef struct S_MESSAGE *PQ931MESSAGE;

//-------------------------------------------------------------------
// Single routine for parsing Q931 messages
//-------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message);

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//==========================================================
// CAUSE FIELD DEFINITIONS
//==========================================================
#define CAUSE_EXT_BIT                0x80
#define CAUSE_CODING_CCITT           0x00
#define CAUSE_LOCATION_USER          0x00
#define CAUSE_RECOMMENDATION_Q931    0x00

#define CAUSE_VALUE_NORMAL_CLEAR     0x10
#define CAUSE_VALUE_USER_BUSY        0x11
#define CAUSE_VALUE_NO_ANSWER        0x13   // Callee does not answer
#define CAUSE_VALUE_REJECTED         0x15
#define CAUSE_VALUE_ENQUIRY_RESPONSE 0x1E
#define CAUSE_VALUE_NOT_IMPLEMENTED  0x4F
#define CAUSE_VALUE_INVALID_CRV      0x51
#define CAUSE_VALUE_INVALID_MSG      0x5F
#define CAUSE_VALUE_IE_MISSING       0x60
#define CAUSE_VALUE_IE_CONTENTS      0x64
#define CAUSE_VALUE_TIMER_EXPIRED    0x66

typedef struct _ERROR_MAP
{
    int nErrorCode;
#ifdef UNICODE_TRACE
    LPWSTR pszErrorText;
#else
    LPSTR pszErrorText;
#endif
} ERROR_MAP;

typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *ptr;
} BINARY_STRING;

typedef struct _Q931_SETUP_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    BOOL SourceAddrPresent;
    BOOL CallerAddrPresent;
    BOOL CalleeAddrPresent;
    BOOL CalleeDestAddrPresent;
    CC_ADDR SourceAddr;                // originating addr
    CC_ADDR CallerAddr;                // gk addr
    CC_ADDR CalleeAddr;                // local addr
    CC_ADDR CalleeDestAddr;            // target destination addr
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_SETUP_ASN;

typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BYTE bReason;
} Q931_RELEASE_COMPLETE_ASN;

typedef struct _Q931_CONNECT_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BOOL h245AddrPresent;
    CC_ADDR h245Addr;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_CONNECT_ASN;

typedef struct _Q931_ALERTING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
} Q931_ALERTING_ASN;

typedef struct _Q931_CALL_PROCEEDING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
} Q931_CALL_PROCEEDING_ASN;

typedef struct _Q931_FACILITY_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR AlternativeAddr;
    PCC_ALIASNAMES pAlternativeAliasList;
    CC_CONFERENCEID ConferenceID;
    BOOL ConferenceIDPresent;
    BYTE bReason;
} Q931_FACILITY_ASN;

//-------------------------------------------------------------------
// Initialization Routines
//-------------------------------------------------------------------
HRESULT Q931InitPER();
HRESULT Q931DeInitPER();

//-------------------------------------------------------------------
// Parsing Routines
//-------------------------------------------------------------------

HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData);

HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData);

HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData);

HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData);

HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData);

HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData);

//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------

// routines for the Setup Message:
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Release Complete Message:
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Connect Message:
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Alerting Message:
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Proceeding Message:
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf);

#ifdef __cplusplus
}
#endif

#endif Q931PAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\interop\interop.h ===
#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif


#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\interop\interop.cpp ===
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#include "interop.h"
#include <stdio.h>
#include "cpls.h"

static int g_nRefCount = 0;

LPInteropLogger INTEROP_EXPORT InteropLoad(CPLProtocol Protocol)
{
	OutputDebugString("Loading CPLS\n");
	LPInteropLogger Logger = (LPInteropLogger) GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, sizeof(InteropLogger));
	if (!(Logger))
		return NULL;
    UINT oldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);

	(Logger)->hInst = LoadLibrary(DLLName);

    SetErrorMode(oldMode);

    if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
    {
	  g_nRefCount++;

	#ifdef _DEBUG
	  char buf[80];
	  wsprintf (buf, "Loading Generic Protocol Logger: %s\n",DLLName);
      OutputDebugString(buf);
	#endif

      (Logger)->CPLInitialize = (CPLInitialize_t)GetProcAddress((Logger)->hInst, "CPLInitialize");
      (Logger)->CPLUninitialize = (CPLUninitialize_t)GetProcAddress((Logger)->hInst, "CPLUninitialize");
      (Logger)->CPLOpen = (CPLOpen_t)GetProcAddress((Logger)->hInst, "CPLOpen");
      (Logger)->CPLClose = (CPLClose_t)GetProcAddress((Logger)->hInst, "CPLClose");
      (Logger)->CPLOutput = (CPLOutput_t)GetProcAddress((Logger)->hInst, "CPLOutput");
	  Logger->g_ProtocolLogID = Logger->CPLInitialize(Protocol);
	  Logger->g_ComplianceProtocolLogger = Logger->CPLOpen(Logger->g_ProtocolLogID,
													NULL,
													CPLS_CREATE | CPLS_APPEND);
	}
    else
    {
		GlobalFree((Logger));
		(Logger) = NULL;
	#ifdef _DEBUG
		char buf[80];
		wsprintf (buf, "Loading Generic Protocol Logger %s Failed\n",DLLName);
		OutputDebugString(buf);
	#endif
    }

    return Logger;
}

void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger)
{
	#ifdef _DEBUG
	char buf[80];
	wsprintf (buf, "Unloading Generic Protocol Logger: %s\n",DLLName);
	OutputDebugString(buf);
	#endif

	if ((Logger))
	{
		if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
		{
			Logger->CPLClose(Logger->g_ComplianceProtocolLogger);
			Logger->CPLUninitialize(Logger->g_ProtocolLogID);
			if (--g_nRefCount <= 0)
				FreeLibrary((Logger)->hInst);
		}
		GlobalFree((Logger));
		(Logger) = NULL;
	}

}

void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf,
							int length, unsigned long userData)
{
	if (!Logger)
		return;
	Logger->CPLOutput(Logger->g_ComplianceProtocolLogger, buf, length,userData);

}

#endif // #if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\acmcaps.cpp ===
/*
 *  	File: acmcaps.cpp
 *
 *		Base ACM implementation of Microsoft Network Audio capability object.
 *
 *		Revision History:
 *
 *		12/20/95	mikev	created
 *		06/11/96	mikev	separated protocol implementation specifics into
 *							msiacaps.cpp (the original proprietary version) and
 *							acmh323.cpp (H.323/H.245 implementation)
 */

#include "precomp.h"


LPACMFORMATTAGDETAILS paftd_g;
ACMDRIVERDETAILS *padd;
ACMDRIVERDETAILS add;
static UINT uMaxFormatSize =0;
	
LPWAVEFORMATEX lpScratchFormat;

//Variables imported from msiacaps.cpp.
//uDefTableEntries is the count of default entries
//and default_id_table is the table itself
extern UINT uDefTableEntries;
extern AUDCAP_DETAILS default_id_table[];

BOOL __stdcall DriverEnumCallback(HACMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall ACMFormatTagEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATTAGDETAILS paftd, DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall FormatEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);

CAcmCapability::CAcmCapability()
{
	hAcmDriver = NULL;
}

CAcmCapability::~CAcmCapability()
{
	CloseACMDriver();
}


BOOL CAcmCapability::OpenACMDriver(HACMDRIVERID hadid)
{
	MMRESULT mResult;
	// clear any previous open
	CloseACMDriver();
	// do it
	mResult = acmDriverOpen(&hAcmDriver, hadid, 0);
	if(mResult != MMSYSERR_NOERROR)
   	{
		return FALSE;
   	}
   	return TRUE;
}

VOID CAcmCapability:: CloseACMDriver()
{
	if(hAcmDriver)
	{
		acmDriverClose(hAcmDriver, 0);
		hAcmDriver = NULL;
	}
}


//
//	DriverEnum() is the root level enumeration of ACM formats. Each permutation of
//  format tag, bits per sample, and sample rate is considered a unique format
//  and will have a unique registry entry if it is "enabled" for internet audio
//

//
// acmDriverEnum() calls DriverEnumCallback() which calls acmFormatTagEnum()
// which calls FormatTagEnumCallback() which calls acmFormatEnum() which
// calls FormatEnumCallback().
//

BOOL CAcmCapability::DriverEnum(DWORD_PTR pAppParam)
{
	MMRESULT mResult;

	if(!GetFormatBuffer())
	{
		return FALSE;
	}

    mResult = acmDriverEnum(DriverEnumCallback, pAppParam, NULL);

	if(lpScratchFormat) {
	   MEMFREE(lpScratchFormat);
	   lpScratchFormat=NULL;
	}

	if(mResult != MMSYSERR_NOERROR)
   	{
		return FALSE;
   	}
	return TRUE;
}

// default implementation of FormatEnumHandler does nothing
BOOL  CAcmCapability::FormatEnumHandler(HACMDRIVERID hadid,
	    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	return FALSE;
}

BOOL __stdcall DriverEnumCallback(HACMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport)
{
	MMRESULT mResult;
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	CAcmCapability *pCapObject = pAppParam->pCapObject;

	ACMFORMATTAGDETAILS aftd;
	
	// not interested unless it's a codec driver
	if(!(fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CODEC))
		return TRUE;	// continue enumeration

	add.cbStruct = sizeof(add);
	aftd.cbStruct = sizeof(ACMFORMATTAGDETAILS);
    aftd.dwFormatTagIndex=0;
    aftd.cbFormatSize=0;
    // I do NOT know why, but fdwSupport MUST be initialized to zero before
    // calling acmFormatTagEnum().  (returns MMSYSERR_INVALPARAM otherwise)
   	aftd.fdwSupport = 0;
    aftd.dwFormatTag = WAVE_FORMAT_UNKNOWN;
    aftd.szFormatTag[0]=0;

	// now see what formats this driver supports
	mResult =  acmDriverDetails(hadid, &add, 0);
	if(mResult != MMSYSERR_NOERROR)
   	{
		return TRUE;  //error, but continue enumerating
   	}

   	// set global driver details pointer
   	padd = &add;
   	
	// # of formats are in add.cFormatTags;
	DEBUGMSG(ZONE_ACM,("DriverEnumCallback: driver %s has %d formats\r\n",
		add.szShortName, add.cFormatTags));
		
	aftd.cStandardFormats = add.cFormatTags;

	// open the driver so we can query it for stuff
	//mResult = acmDriverOpen(&had, hadid, 0);
	//if(mResult != MMSYSERR_NOERROR)
	if(!pCapObject->OpenACMDriver(hadid))
   	{
		ERRORMESSAGE(("DriverEnumCallback: driver open failed:0x%08lX\r\n",mResult));
		padd = NULL;
		return TRUE;  //error, but continue enumerating
   	}
   	
	mResult = acmFormatTagEnum(pCapObject->GetDriverHandle(), &aftd,	ACMFormatTagEnumCallback, dwInstance, 0);
	if(mResult != MMSYSERR_NOERROR)
   	{
		ERRORMESSAGE(("DriverEnumCallback: acmFormatTagEnum failed:0x%08lX\r\n",mResult));
	}
	// cleanup
	pCapObject->CloseACMDriver();
	padd = NULL;
	return TRUE;
	
}


BOOL GetFormatBuffer()
{
	// get size of largest WAVEFORMATEX structure in the system
	MMRESULT mResult = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT,
		(LPVOID) &uMaxFormatSize);
	if(mResult != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("GetFormatBuffer: acmMetrics failed:0x%08lX\r\n",mResult));
		return FALSE;
	}

	// workaround bug in some third party codecs: it has been observed that the
	// Voxware RT-24 codec distributed by Netscape CoolTalk corrupts the heap when
	// the codec is enumerated.  It writes more data to the WAVEFORMATEX that it
	// indicates when metrics are evaluated.  Workaround by allocating twice as much as
	// we think we need.

	lpScratchFormat = (LPWAVEFORMATEX) MEMALLOC(2* uMaxFormatSize);
	if(!lpScratchFormat)
	{
		ERRORMESSAGE(("GetFormatBuffer: allocation failed\r\n"));
		return FALSE;
	}
	ZeroMemory(lpScratchFormat, uMaxFormatSize);
	//Set the size of the extra buffer to maximum possible size...
	lpScratchFormat->cbSize=(WORD)(uMaxFormatSize - sizeof (WAVEFORMATEX));
	return TRUE;
}


//
//	Gets format details (all permutations of formats) for a given format tag that
//	the driver supports
//	

BOOL __stdcall ACMFormatTagEnumCallback(
	HACMDRIVERID hadid,
    LPACMFORMATTAGDETAILS paftd,
    DWORD_PTR dwInstance,
    DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	CAcmCapability *pCapObject = pAppParam->pCapObject;
	MMRESULT mResult;
	ACMFORMATDETAILS afd;
	UINT i;

    //Set this first, so that if we are using a default format, we can help the enumerator
    //narrow the field.
	afd.pwfx = lpScratchFormat;

	// if caller wanted to enum ALL formats go right to it (for adding a format)
	if (((pAppParam->dwFlags && ACMAPP_FORMATENUMHANDLER_MASK) != ACMAPP_FORMATENUMHANDLER_ADD) &&
		(pAppParam->pRegCache)) {
        //Do we care about this particular format?
        //rrf_nFormats is the number of formats we read in the
        //registry.
        if (pAppParam->pRegCache->nFormats) {
            for (i=0;i<pAppParam->pRegCache->nFormats;i++) {
                if (((AUDCAP_DETAILS *)pAppParam->pRegCache->pData[i])->wFormatTag == paftd->dwFormatTag){
                    //Add some guesses based on the default information
                    break;
                }
            }

            // i is the index of either the found tag (so we care.) or
            // equal to the # of formats in the cache, which means not
            // found, so check the default list.

            if (i==pAppParam->pRegCache->nFormats) {
                //Check the case that some (but not all) of the default formats are missing.
                for (i=0;i<uDefTableEntries;i++) {
                    if (paftd->dwFormatTag == default_id_table[i].wFormatTag) {
                        break;
                    }
                }
                if (i==uDefTableEntries) {
                    //We don't care about this format, it's not in the cache, or default list
                    return TRUE;
                }
            }
        }
    }
    //We support mono formats
    afd.pwfx->nChannels=1;
	afd.cbStruct = sizeof(afd);
	afd.dwFormatIndex = 0;
	afd.dwFormatTag = paftd->dwFormatTag;
	afd.fdwSupport = 0;
	afd.cbwfx = uMaxFormatSize;
	afd.szFormat[0]=0;
	
	//afd.dwFormatTag = WAVE_FORMAT_UNKNOWN;
	//lpScratchFormat->wFormatTag = WAVE_FORMAT_UNKNOWN;
	lpScratchFormat->wFormatTag = LOWORD(paftd->dwFormatTag);
	
	DEBUGMSG(ZONE_ACM,("ACMFormatTagEnumCallback:dwFormatTag 0x%08lX, cbFormatSize 0x%08lX,\r\n",
		paftd->dwFormatTag, paftd->cbFormatSize));
	DEBUGMSG(ZONE_ACM,("ACMFormatTagEnumCallback:cStandardFormats 0x%08lX, szTag %s,\r\n",
		paftd->cStandardFormats, paftd->szFormatTag));

    paftd_g = paftd;
	// just setting the global paftd_g should be fine, but I'd like to rid of it later
	pAppParam->paftd = paftd;   	

	DEBUGMSG(ZONE_ACM,(""));
	DEBUGMSG(ZONE_ACM,("All %s formats known to ACM", paftd->szFormatTag));
	DEBUGMSG(ZONE_ACM,("====================================="));
	DEBUGMSG(ZONE_ACM,("Tag    Channels SampPerSec AvgBytPerSec Block  BitsPerSample cbSize szFormat"));

	mResult = acmFormatEnum(pCapObject->GetDriverHandle(), &afd,
    	FormatEnumCallback, dwInstance, ACM_FORMATENUMF_WFORMATTAG|ACM_FORMATENUMF_NCHANNELS);
    	
	return TRUE;
}


BOOL __stdcall FormatEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	CAcmCapability *pCapObject = pAppParam->pCapObject;

	DEBUGMSG(ZONE_ACM,("0x%04x %8d 0x%08lx 0x%010lx 0x%04x 0x%011x 0x%04x %s",
						pafd->pwfx->wFormatTag, pafd->pwfx->nChannels,
						pafd->pwfx->nSamplesPerSec, pafd->pwfx->nAvgBytesPerSec,
						pafd->pwfx->nBlockAlign, pafd->pwfx->wBitsPerSample,
						pafd->pwfx->cbSize,	pafd->szFormat));
	
	return pCapObject->FormatEnumHandler(hadid, pafd, dwInstance, fdwSupport);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\include\tstable.h ===
/****************************************************************************
 *
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *
 *	Abstract:   
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef __TSTABLE_H
#define __TSTABLE_H

#include <windows.h>

typedef struct _LOCK_ENTRY
{
	HANDLE        hLock;
	int           iLockCount;
	BOOL          bCleanup,
								bDeleted;
	WORD          wNextFree,
								wUniqueID;

} LOCK_ENTRY, *PLOCK_ENTRY;


// definition of an invalid ID
#define TSTABLE_INVALID_ID				(DWORD) 0xFFFFFFFF

// return codes that the callback function used in conjunction with EnumerateEntries can return
const DWORD CALLBACK_CONTINUE                = 1;
const DWORD CALLBACK_ABORT                   = 2;
const DWORD CALLBACK_DELETE_ENTRY            = 3;
const DWORD CALLBACK_DELETE_ENTRY_AND_OBJECT = 4;



// used in call to Lock
#define TSTABLE_INVALID_UNIQUE_ID            (WORD) 0xFFFF
#define TSTABLE_INVALID_INDEX                (WORD) 0xFFFF

// This is a compare function that we aren't using right now.  It
// will be useful in the future if there is a reason to search
// the table 

typedef INT (*ENTRY_COMPARE) (LPVOID ptr1, LPVOID ptr2);


template <class EntryData> class TSTable
{
typedef DWORD (*TABLE_CALLBACK) (EntryData* ptr, LPVOID context);

public:
	           TSTable         (WORD            _size);
	          ~TSTable         ();
	BOOL       Resize          (WORD            wNewSize);
	BOOL       CreateAndLock   (EntryData*      pEntryData,
															LPDWORD         lpdwID);
	BOOL       Validate        (DWORD           dwID);
	EntryData *Lock            (DWORD           dwID,
															DWORD           timeout = INFINITE);
	BOOL       Unlock          (DWORD           dwID);
	BOOL       Delete          (DWORD           dwID,
															BOOL            bCleanup = FALSE);
	EntryData *EnumerateEntries(TABLE_CALLBACK  callBackFunc,
															void*           context,
															BOOL            bUnlockTable = FALSE);
	
	BOOL       IsInitialized   () {return bInitialized;}
	WORD       GetSize         () {return wNumUsed;}

private:
	// data

	EntryData**       pDataTable;
	PLOCK_ENTRY       pLockTable;
	CRITICAL_SECTION  csTableLock;
	WORD              wSize,
					  wNumUsed,
					  wFirstFree,
				      wLastFree,
					  wUniqueID;
	BOOL              bInitialized;

	// private methods

	BOOL LockEntry   (WORD wIndex,
									 DWORD timeout = INFINITE);
	BOOL UnLockEntry(WORD wIndex);
	void LockTable  () { EnterCriticalSection(&csTableLock); };
	void UnLockTable() { LeaveCriticalSection(&csTableLock); };
	WORD GenerateUniqueID();
	DWORD MakeID(WORD wIndex, WORD wUniqueID)
		{
			DWORD theID = wUniqueID;
			theID = (theID << 16) & 0xFFFF0000;
			theID |= wIndex;
			return(theID);
		};
	void BreakID(DWORD theID, WORD* pwIndex, WORD* pwUID)
		{
			*pwIndex = (WORD) (theID & 0x0000FFFF);
			*pwUID   = (WORD) ((theID >> 16) & 0x0000FFFF);
		};

};

/*
 ** TSTable::TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\tstable.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::TSTable(WORD _size) :
														wSize(_size),
														wNumUsed((WORD) 0),
														wFirstFree((WORD) 0),
														wLastFree((WORD) (_size - 1)),
														wUniqueID((WORD) 0),
														bInitialized(TRUE),
														pDataTable(NULL),
														pLockTable(NULL)
{
	WORD wIndex;

	// Create the table lock

	InitializeCriticalSection(&csTableLock);

	// Lock the table

	LockTable();

	// Create the data table

	pDataTable = new EntryData*[wSize];
	
	if(pDataTable == NULL) 
	{
		bInitialized = FALSE;
		return;
	}   

	// Init the pointers

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		pDataTable[wIndex] = NULL;
	}

	// Create the lock table

	pLockTable = new LOCK_ENTRY[wSize];

	if (pLockTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}   

	// Initialize the lock table entries...each entry begins with
	// a NULL mutex handle, a zero lock count and it's next free is
	// the next successive entry.

	for (wIndex = 0; wIndex < wSize; wIndex++ )
	{
		pLockTable[wIndex].hLock      = NULL;
		pLockTable[wIndex].iLockCount = 0;
		pLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}   

	// note: the wNextFree in the last table entry points to an invalid index, however,
	// this is OK since if the table ever fills, it is automatically resized making what 
	// was an invalid index, the index into the first entry of newly added part of the 
	// enlargened table.  Trust me...

	// Unlock the table

	UnLockTable();
}

/*
 ** TSTable::~TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::~TSTable()
{
	DWORD wIndex;

	// Lock the table

	LockTable();

	// Delete the data table

	if (pDataTable != NULL)
	{
		delete pDataTable;
	}

	// Delete the lock table

	if (pLockTable != NULL)
	{
		// Destroy the mutexes

		for (wIndex = 0; wIndex < wSize; wIndex++)
		{
			if (pLockTable[wIndex].hLock != NULL)
			{
				CloseHandle(pLockTable[wIndex].hLock);
			}
		}

		delete pLockTable;
	}

	// Unlock the table

	UnLockTable();

	// Destroy the table lock

	DeleteCriticalSection(&csTableLock);

	bInitialized = FALSE; 
}

/*
 ** TSTable::Resize
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Resize(WORD wNewSize) 
{
	BOOL        bRetCode = TRUE;
	EntryData** pNewDataTable;
	PLOCK_ENTRY pNewLockTable;
	WORD        wIndex;

	// Lock the table

	LockTable();

	// If the table is shrinking, pretend we did it

	if (wNewSize <= wSize)
	{
		goto EXIT;
	}
	
	// Allocate new data and lock tables and make sure that succeeds.

	pNewDataTable = new EntryData*[wNewSize];

	if(pNewDataTable == NULL) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	pNewLockTable = new LOCK_ENTRY[wNewSize];

	if(pNewLockTable == NULL) 
	{
		bRetCode = FALSE;
		goto CLEANUP1;
	}

	// Initialize the new section of the lock and data tables

	for (wIndex = wSize; wIndex < wNewSize; wIndex++)
	{
		pNewDataTable[wIndex]            = NULL;

		pNewLockTable[wIndex].hLock      = NULL;
		pNewLockTable[wIndex].iLockCount = 0;
		pNewLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}

	// Copy the old data table pointers to the new data table

	memcpy((PCHAR) pNewDataTable,
				 (PCHAR) pDataTable,
				 sizeof(EntryData*) * wSize);

	// Delete the old data table and fix the pointer 

	delete pDataTable;
	pDataTable = pNewDataTable;

	// Copy the old lock table to the new lock table

	memcpy((PCHAR) pNewLockTable,
				 (PCHAR) pLockTable,
				 sizeof(LOCK_ENTRY) * wSize);

	// Delete the old lock table and fix the pointer 

	delete pLockTable;
	pLockTable = pNewLockTable;

	// Fix the size variable

	wSize = wNewSize;

	goto EXIT;

CLEANUP1:

	// Delete the new data table

	delete pNewDataTable;

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::CreateAndLock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::CreateAndLock(EntryData* pEntryData,
																			 LPDWORD    lpdwID)
{
	BOOL  bRetCode = FALSE;
	WORD wIndex;

	// If the pointer passed in is bad, then don't even try to do anything for them

	if (pEntryData == NULL || lpdwID == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// If the table is full, then resize it.

	if (wNumUsed == wSize)
	{
		if (Resize((WORD) (wSize + 20)) == FALSE)
		{
			goto EXIT;
		}
	}

	// Get the first free entry

	wIndex = wFirstFree;

	// Create the mutex for the object

	if ((pLockTable[wIndex].hLock = CreateMutexA(NULL, FALSE, NULL)) == NULL)
	{
		goto EXIT;
	}

	// Lock the entry (no need checking the return code as the entire
	// table is locked) - since this is a new entry, that means that nobody
	// could have locked the entry already.

	LockEntry(wIndex, 0);

	// Copy pointer to the data table

	pDataTable[wIndex] = pEntryData;

	// Init the corresponding lock table entry

	pLockTable[wIndex].bDeleted   = FALSE;
	pLockTable[wIndex].iLockCount = 1;
	pLockTable[wIndex].wUniqueID = GenerateUniqueID();

	// Set the id for the caller

	*lpdwID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

	// Bump up the count of number used

	wNumUsed++;

	// Fix the next free index

	wFirstFree = pLockTable[wIndex].wNextFree;

	// Signal success

	bRetCode = TRUE;

EXIT:

	// Unlock the table

	UnLockTable();
	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::Lock(DWORD dwID,
																		DWORD timeout) 
{
	EntryData* pEntryData = NULL;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, and the unique ID matches).

	if (pLockTable[wIndex].hLock    == NULL ||
			pLockTable[wIndex].bDeleted == TRUE ||
			pLockTable[wIndex].wUniqueID != wUID)
	{
		goto EXIT;
	}

	// If the timeout is INFINITE, then try to lock the entry using a more
	// "thread friendly" method.	 If a timeout is specified, then don't do
	// the spin lock since it could be implemented at a higher level.

	if(timeout == INFINITE)
	{
		// simulate infinity with a pseudo "spin lock"
		// This is more "thread friendly" in that it unlocks the table allowing some
		// other thread that is trying to unlock the same entry to be able to lock the
		// table.

		while(LockEntry(wIndex, 0) == FALSE)
		{
			UnLockTable();

			// give up the rest of this thread quantum, allowing others to run and potentially
			// unlock the entry

			Sleep(0); 
			LockTable();

			// If the entry has been replaced, deleted or marked for deletion then
			// bag it (give up)

			if((pLockTable[wIndex].wUniqueID != wUID)  ||
				 (pLockTable[wIndex].hLock      == NULL)  || 
				 (pLockTable[wIndex].bDeleted   == TRUE))
			{
				goto EXIT;
			}
		}

		// we got the lock

		pEntryData = pDataTable[wIndex];
	}
	
	// Otherwise, do a normal lock

	else
	{	
		if (LockEntry(wIndex, timeout) == TRUE) 
		{
			pEntryData = pDataTable[wIndex];
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return pEntryData;
}

/*
 ** TSTable::Unlock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Unlock(DWORD dwID)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 
	
	// Lock the table

	LockTable();

	// Verify the id is within bounds

	if (wIndex >= wSize) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the lock is actually valid and that the entry has not been
	// deleted

	if (pLockTable[wIndex].hLock == NULL)
	{
		goto EXIT;
	}

	// Make sure that that thread has the lock on the entry

	if ((bRetCode = LockEntry(wIndex, 0)) == TRUE) 
	{
		// if this table entry is marked for delete and the lock count is less than 2
		// (since the thread could have called delete after unlocking the entry...although
		// this is a no-no) then clean up the table entry

		if (pLockTable[wIndex].bDeleted   == TRUE &&
				pLockTable[wIndex].iLockCount <= 2)
		{
			// If the caller specifed cleanup on delete, then get rid of memory

			if (pLockTable[wIndex].bCleanup == TRUE)
			{
				delete pDataTable[wIndex];
			}

			// Set the pointer to NULL

			pDataTable[wIndex] = NULL;

			// Decrement the count of used entries

			wNumUsed--;

			// Fix the entry so that it's next free index is what is currently
			// the next free pointed to by the current last free entry.  
			// Then update the last free entry's next pointer, and finally, 
			// update the last free index to this entry
			pLockTable[wIndex].wNextFree    = pLockTable[wLastFree].wNextFree;
			pLockTable[wLastFree].wNextFree = wIndex;
			wLastFree                       = wIndex;
		}

		// Do two unlocks on the entry ... one for the original lock and another for
		// the lock we obtained during the test

		UnLockEntry(wIndex);
		UnLockEntry(wIndex);

		// Since the entire table is locked, then we can get away with this.  If
		// the code is ever changed so that the entire table is not locked during
		// these operations, then this will cause a race condition.

		// If we got rid of the data, then close the handle to the mutex and
		// set the handle to NULL

		if (pDataTable[wIndex] == NULL)
		{
			CloseHandle(pLockTable[wIndex].hLock);
			pLockTable[wIndex].hLock = NULL;
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Delete
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Delete(DWORD dwID,
																BOOL  bCleanup) 
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify that the ID is within bounds

	if (wIndex >= wSize) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is valid

	if (pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Try to lock the entry (ie check to see if we had the entry locked)

	if (LockEntry(wIndex, 0) == TRUE)
	{
		// mark it for deletion, set the cleanp flag and then unlock it

		pLockTable[wIndex].bDeleted = TRUE;
		pLockTable[wIndex].bCleanup = bCleanup;

		UnLockEntry(wIndex);

		// Note: this function does not call ::Unlock() on behalf of the user.
		// Thus, the entry is only marked as deleted at this point and can no
		// longer be locked by any threads (including the one that marked it for delete).
		// The thread that marked the entry as deleted must call ::Unlock() to actually
		// free up the entry.
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:  Validates that an object still exists.  Can be called
 *								regardless if caller has entry locked or not.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Validate(DWORD dwID)
{
	BOOL bRetCode = TRUE;
	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, the unique ID matches, and the data ptr is not null).

	if (pLockTable[wIndex].hLock    == NULL  ||
			pLockTable[wIndex].bDeleted == TRUE  ||
			pLockTable[wIndex].wUniqueID != wUID ||
			pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::EnumerateEntries
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::EnumerateEntries(TABLE_CALLBACK callbackFunc,
																								LPVOID         context,
																								BOOL           bUnlockTable) 
{
	DWORD      dwAction;
	WORD       wIndex = wSize;
	EntryData* pEntryData = NULL;
	DWORD      dwEntryID;

	// Make sure they passed a good function

	if (callbackFunc == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// Run through the data table and pass the data to the callback function

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		// Verify that there is actually data in the entry and that the entry has not
		// been marked for deletion.

		if (pDataTable[wIndex]          == NULL ||
				pLockTable[wIndex].bDeleted == TRUE)
		{
			continue;
		}


		// Try to lock the entry...if we cannot, then we don't have the lock and
		// we will only report entries that we have locked (or are unlocked)

		if (LockEntry(wIndex, 0) == FALSE)
		{
			continue;
		}
		
		// build and remember the "full" entry ID so we can use it to unlock the entry
		dwEntryID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

		// Save the pointer to the object.

		pEntryData = pDataTable[wIndex];

		// note: only unlock the table during the callback if we are explicitly asked to (the 
		// default is not to unlock the table). 
		if(bUnlockTable == TRUE)
			UnLockTable();

		// Call their function
		dwAction = callbackFunc(pDataTable[wIndex], context);

		if(bUnlockTable == TRUE)
			LockTable();

		// If the action says to delete the entry, then do so...if we are also to delete
		// the object, pass in a TRUE.

		if (dwAction == CALLBACK_DELETE_ENTRY ||
				dwAction == CALLBACK_DELETE_ENTRY_AND_OBJECT)
		{
			Delete(dwEntryID, (dwAction == CALLBACK_DELETE_ENTRY ? FALSE : TRUE));
		}

		// If the action says abort, then break the loop...notice that means that
		// the entry is still locked

		else if (dwAction == CALLBACK_ABORT)
		{
			goto EXIT;
		}

		// Unlock the entry...notice we don't use UnLockEntry.  The reason is that
		// if the entry has been marked as deleted, then we need to have
		// it destroyed and UnLockEntry doesn't do that.

		Unlock(dwEntryID);
	}

EXIT:

	// Unlock the table

	UnLockTable();

	// Return NULL if we processed the entire table...if we were told to abort,
	// return a pointer to the entry we stopped on.

	return (wIndex == wSize ? NULL : pEntryData);
}

// helper functions - these assume table is locked and index is good

/*
 ** TSTable::LockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::LockEntry(WORD wIndex,
																	 DWORD timeout) 
{
	BOOL  bRetCode = TRUE;
	DWORD dwRetCode;


	// Try to lock the entry.  If it succeeds, we'll bump up the lock count.  If
	// the wait ended because another thread abandoned the mutex, then set the count
	// to one.

	dwRetCode = WaitForSingleObject(pLockTable[wIndex].hLock, timeout);
	
	if (dwRetCode == WAIT_OBJECT_0)
	{
		pLockTable[wIndex].iLockCount++;
	}
	else if (dwRetCode == WAIT_ABANDONED)
	{
		pLockTable[wIndex].iLockCount = 1;
	}
	else
	{
		bRetCode = FALSE;
	}

	return bRetCode;
}

/*
 ** TSTable::UnLockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::UnLockEntry(WORD wIndex)
{
	BOOL bRetCode;

	// Release the mutex...if that succeeds, reduce the count

	if((bRetCode = ReleaseMutex(pLockTable[wIndex].hLock)) == TRUE) 
	{
		pLockTable[wIndex].iLockCount--;
	}

	return bRetCode;
}


/*
 ** TSTable::GenerateUniqueID
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION: table should be locked before calling this function.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
WORD TSTable<EntryData>::GenerateUniqueID()
{
	// table must be locked
	if(++wUniqueID == TSTABLE_INVALID_UNIQUE_ID)
		wUniqueID++;
	return(wUniqueID);
}






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\isrdbg32\isrdbg32.c ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/network/isrdbg/rcs/isrdbg.c $
 $Revision:   1.3  $
      $Date:   30 Dec 1996 16:44:32  $
    $Author:   EHOWARDX  $
    $Locker:  $

	Description
	-----------
	VCITest - test harness for VCI and underlaying subsystems.

****************************************************************************/

// Turn off Windows stuff will never use.
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#ifndef STRICT
#define STRICT
#endif // not defined STRICT

#include <windows.h>

#include <string.h>

#define ISRDBG32_C
#include <isrg.h>					// exports to functions.

#include "isrdbg32.h"				// private header file for this app



HINSTANCE		ghAppInstance = 0;		// global instance handle

// Global lock to protect:
//		gStrTabOfs, guNumItems
HANDLE			gSemaphore = 0;			// global semaphore for accessing dbg info.



// Most data needs to be globally mapped because info is shared with viewer and apps
// placing debug info into the buffers.
typedef struct _tDS
{
	UINT			uBindCount;		// How many copies of this DLL have run.
	UINT			guNumModules;
	UINT			guNumItems;
	UINT			gStrTabOfs;
	WORD			ghDefaultModule;
} tDS,*ptDS;

HANDLE			ghDS = 0;
ptDS			gpDS = NULL;

HANDLE			ghModuleTable = 0;
ptISRModule		gpModuleTable = NULL;

HANDLE			ghDbgTable = 0;
ptISRItem		gpDbgTable = NULL;

HANDLE			ghzStrTab = 0;
LPSTR			gpzStrTab = NULL;


//------------------------------------------------------------------------------
ptISRItem WINAPI
ISR_GetItemInternal (UINT uItem);



//------------------------------------------------------------------------------
BOOL MapGlobalWin32Memory(void** pMem,HANDLE* hMem,UINT MemSize,char* MemName)
{
	BOOL		fInit;


	if (!pMem || !hMem)
		return FALSE;

	*hMem = CreateFileMapping(
		INVALID_HANDLE_VALUE,	// use paging file
		NULL,					// no security attr.
		PAGE_READWRITE,			// read/write access
		0,						// size: high 32-bits
		MemSize,				// size: low 32-bits
		MemName);		// name of map object
	if (!*hMem)
		return FALSE;

	// The first process to attach initializes memory.
	fInit = (GetLastError() != ERROR_ALREADY_EXISTS);

	// Get a pointer to the file-mapped shared memory.
	*pMem = MapViewOfFile(
		*hMem,			// object to map view of
		FILE_MAP_WRITE,	// read/write access
		0,				// high offset:   map from
		0,				// low offset:    beginning
		0);				// default: map entire file
	if (!*pMem)
	{
		CloseHandle(*hMem);
		*hMem = 0;
		return FALSE;
	}

	// Initialize memory if this is the first process.
	if (fInit)
	{
		memset(*pMem,0,MemSize);
	}

	return TRUE;
}


void FreeGlobalWin32Memory(void* pMem,HANDLE hMem)
{
	// Unmap shared memory from the process's address space.
	if (pMem)
		UnmapViewOfFile(pMem);

	// Close the process's handle to the file-mapping object.
	if (hMem)
		CloseHandle(hMem);
}


//------------------------------------------------------------------------------
//	InitModules
//		Init the Module filters on startup.
//		Do not init the filters when the module is registered.
//		The display app may have some global filters in effect by the time
//		the individual register module calls come in.
//------------------------------------------------------------------------------
static void
InitModules (void)
{
	UINT			hMod;
	ptISRModule		pMod;


	for (hMod = 0; hMod < kMaxModules; hMod++)
	{
		pMod = ISR_GetModule(hMod);
		if (!pMod)
			break;

		pMod->DisplayFilter = 0xFF;
		pMod->CaptureFilter = 0xFF;
	}
}


//------------------------------------------------------------------------------
//	ValidCaptureMsg
//		Validate the capture filters to determine if this message should be
//		dropped.
//
//	Returns:
//		TRUE	- if msg is valid and should be kept
//		FALSE	- if msg is filtered out and should be dropped.
//------------------------------------------------------------------------------
static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel)
{
	ptISRModule		pMod;


	pMod = ISR_GetModule(hISRInst);
	if (!pMod)
		return FALSE;

	if (DbgLevel & pMod->CaptureFilter)
		return TRUE;
	else
		return FALSE;
}


//------------------------------------------------------------------------------
//	OutputRec ()
//		Store a string resource Id to be displayed at task time.
//		In addition store a number to be displayed in printf format of the
//		string.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	)
{
	ptISRItem	pItem;
	UINT		uItem;


	// Capture Filter
	if ( !ValidCaptureMsg(hISRInst, DbgLevel) )
		return;

	// Protect against reentrancy.  Just drop the msg if reentered.
	if (WAIT_OBJECT_0 != WaitForSingleObject(gSemaphore,100))
		return;

	uItem = gpDS->guNumItems++;
	if (kMaxISRItems <= gpDS->guNumItems)
	{
		gpDS->guNumItems = 0;
	}
	ReleaseSemaphore(gSemaphore,1,NULL);

	pItem = ISR_GetItemInternal(uItem);
	if (!pItem)
	{
		// This is a serious bug.  Our debugger is even hosed.
		// Need to think of a way to indicate this to the user.
		return;
	}

	pItem->hISRInst = hISRInst;
	pItem->DbgLevel = DbgLevel;
	pItem->Flags = Flags;
	pItem->IP = IP;
	pItem->Param1 = Param1;
	pItem->Param2 = Param2;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ISR_DLL void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	)
{
	LPSTR		pzStrTab;
	UINT		uStrOfs;
	UINT		uStrLen;
	UINT		StrLen1;
	UINT		StrLen2;


	// Capture Filter
	if ( !ValidCaptureMsg(hISRInst, DbgLevel) )
		return;

	if (pzStr1)
		StrLen1 = lstrlen(pzStr1);
	else
		StrLen1 = 0;
	if (pzStr2)
		StrLen2 = lstrlen(pzStr2);
	else
		StrLen2 = 0;
	uStrLen = StrLen1 + StrLen2 + 1;	// 1 for null terminator.
	if (kMaxStrTab <= uStrLen)
	{
		return;	// It is so big.
	}
	
	// Protect against reentrancy.  Just drop the msg if reentered.
	if (WAIT_OBJECT_0 != WaitForSingleObject(gSemaphore,100))
		return;

	uStrOfs = gpDS->gStrTabOfs;
	gpDS->gStrTabOfs += uStrLen;
	if (kMaxStrTab <= gpDS->gStrTabOfs)
	{
		uStrOfs = 0;
		gpDS->gStrTabOfs = uStrLen;

		// Also reset items which would otherwise point in trashed strings.
		gpDS->guNumItems = 0;
	}
	pzStrTab = gpzStrTab + uStrOfs;
	ReleaseSemaphore(gSemaphore,1,NULL);

	if (pzStr1)
		lstrcpy(pzStrTab, pzStr1);
	if (pzStr2)
		lstrcpy(pzStrTab+StrLen1, pzStr2);

	OutputRec(hISRInst, DbgLevel, kParam1IsStr, IP, uStrOfs, Param1);
}


//------------------------------------------------------------------------------
//	ISR_HookDbgStrStr
//		Allow two strings to be concatenated together.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2)
{
	OutputRecStr(hISRInst, DbgLevel, kParam1IsStr, IP, pzStr1, pzStr2, 0);
}


//------------------------------------------------------------------------------
//	ISR_HookDbgRes
//		Use a resource to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1)
{
	OutputRec(hISRInst, DbgLevel, kParam1IsRes, IP, uResId, Param1);
}


//------------------------------------------------------------------------------
//	ISR_HookDbgStr
//		Use a str to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1)
{
	OutputRecStr(hISRInst, DbgLevel, kParam1IsStr, IP, pzStr1, 0, Param1);
}


//------------------------------------------------------------------------------
//	ISR_DbgStrStr
//		Allow two strings to be concatenated together.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2)
{
	UINT		IP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		IP,ax
//		pop		ax
//	}
	ISR_HookDbgStrStr(IP, hISRInst, DbgLevel, pzStr1, pzStr2);
}


//------------------------------------------------------------------------------
//	ISR_DbgRes
//		Use a resource to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1)
{
	UINT		IP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		IP,ax
//		pop		ax
//	}
	ISR_HookDbgRes(IP, hISRInst, DbgLevel, uResId, Param1);
}


//------------------------------------------------------------------------------
//	ISR_DbgStr
//		Use a str to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1)
{
	UINT		IP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		IP,ax
//		pop		ax
//	}
	ISR_HookDbgStr(IP, hISRInst, DbgLevel, pzStr1, Param1);
}


//------------------------------------------------------------------------------
//	TT_DbgMsg
//		This function builds a formatted string, based upon numeric or
//		string input parameters, and sends the string to isrdbg.dll to
//		be displayed in the isrdsp.exe window.	THIS FUNCTION CAN NOT
//		BE CALLED AT INTERRUPT-TIME.  This function uses the same
//		mechanism as isrdbg.dll to enable/disable debug output.
//
// In:
//		hISRInst,		- Module's ISRDBG handle.
//		DbgLevel,		- Appropriate ISRDBG level.
//		zMsgFmt,		- Output format string (like printf).
//		...				- Optional parameter list.
//
// Out:
//		none
//
// Return:
//		none
//------------------------------------------------------------------------------
ISR_DLL void FAR cdecl DLL_EXPORT
TTDbgMsg
(
	WORD		hISRInst,
	BYTE		DbgLevel,
	LPCSTR		zMsgFmt,
	...
)
{
	WORD		TempIP = 0;
	char		MsgBuf[256];

//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov 	TempIP,ax
//		pop		ax
//	}

#ifdef _M_ALPHA
	va_list valDummy;
	ZeroMemory(&valDummy, sizeof(valDummy));

	va_start (valDummy,zMsgFmt);
	wvsprintf (MsgBuf, zMsgFmt, valDummy);
	va_end  (valDummy);
#else  // _M_ALPHA
	wvsprintf (MsgBuf, zMsgFmt, (va_list) (&zMsgFmt + 1));
#endif // _M_ALPHA

	ISR_HookDbgStrStr(TempIP, hISRInst, DbgLevel, MsgBuf, 0);
}


//------------------------------------------------------------------------------
//	ISR_OutputDbgStr ()
//		Store a string to be displayed at task time.
//		The passed in string will be copied to a local storage.
//		Therefore the caller can reuse on return.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr)
{
	WORD		TempIP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}
	
	ISR_HookDbgStrStr(TempIP, gpDS->ghDefaultModule, kISRDefault, pzStr, 0);
}


//------------------------------------------------------------------------------
//	ISR_OutputStr ()
//		Store a string resource Id to be displayed at task time.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId)
{
	UINT		TempIP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}
	ISR_HookDbgRes(TempIP, gpDS->ghDefaultModule, kISRDefault, uResId, 0);
}


//------------------------------------------------------------------------------
//	ISR_OutputNum ()
//		Store a string resource Id to be displayed at task time.
//		In addition store a number to be displayed in printf format of the
//		string.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num)
{
	WORD		TempIP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}
	ISR_HookDbgRes(TempIP, gpDS->ghDefaultModule, kISRDefault, uResId, Num);
}


//------------------------------------------------------------------------------
//	DbgMsg ()
//		Canned Debug format that may be useful.  This function has nothen
//		to do with Interrupt time display.  However it keeps all the
//		display info in one place.  Basically it is convenient.
//
//		WARNING: Do not call this at interrupt time.  wsprintf is not reentrant.
//------------------------------------------------------------------------------
ISR_DLL void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	)
{
	WORD		TempIP = 0;
	char		MsgBuf[256];
	va_list valDummy;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}

	wsprintf (MsgBuf, ">--<%s> %s", module,
			(LPSTR) ((state == ISR_DBG) ? "debug : " : "ERROR : "));


#ifdef _M_ALPHA
	ZeroMemory(&valDummy, sizeof(valDummy));

	va_start (valDummy,format_str);
	wvsprintf ((LPSTR) (MsgBuf + lstrlen (MsgBuf)), format_str,valDummy);
	va_end  (valDummy);
#else  // _M_ALPHA
	wvsprintf ((LPSTR) (MsgBuf + lstrlen (MsgBuf)), format_str,
			(va_list) (&format_str + 1));

#endif // _M_ALPHA


	ISR_HookDbgStrStr(TempIP, gpDS->ghDefaultModule, kISRDefault, MsgBuf, 0);

//	lstrcat (MsgBuf, "\n");

//	OutputDebugString (MsgBuf);
}


//------------------------------------------------------------------------------
//	ISR_ClearItems ()
//		Clear the list of debug msgs.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_ClearItems (void)
{
	// Protect against reentrancy.  Just drop the msg if reentered.
	if (WAIT_OBJECT_0 != WaitForSingleObject(gSemaphore,100))
		return;

	// This is not a serious race condition.  Must likely failure
	// is what messages get dropped.
	gpDS->guNumItems = 0;
	gpDS->gStrTabOfs = 0;

	ReleaseSemaphore(gSemaphore,1,NULL);
}


//------------------------------------------------------------------------------
//	ISR_GetNumItems ()
//		Return the number of items that have be entered.
//------------------------------------------------------------------------------
ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void)
{
	return gpDS->guNumItems;
}
//------------------------------------------------------------------------------
//	ISR_GetNumModules ()
//		Return the number of modules that have be entered.
//------------------------------------------------------------------------------
ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void)
{
	return gpDS->guNumModules;
}


//------------------------------------------------------------------------------
//	ISR_GetItemInternal
//		Return a pointer to the record num uItem.  Only reason to
//		do it this way is to hide the buf struct.  This way I can use a
//		heap manager such as BigMem or SmartHeap or NT HeapAlloc.
//		The items are numbered 0..n-1.
//		Alternatively a Ptr to the array of records could be passed back.
//------------------------------------------------------------------------------
ptISRItem WINAPI
ISR_GetItemInternal (UINT uItem)
{
	if (kMaxISRItems <= uItem)
	{
		return NULL;
	}

	return &gpDbgTable[uItem];
}


//------------------------------------------------------------------------------
//	ISR_GetItem
//		Return a pointer to the record num uItem.  Only reason to
//		do it this way is to hide the buf struct.  This way I can use a
//		heap manager such as BigMem or SmartHeap or NT HeapAlloc.
//		The items are numbered 0..n-1.
//		Alternatively a Ptr to the array of records could be passed back.
//------------------------------------------------------------------------------
ISR_DLL ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem)
{
	ptISRItem		pISRItem;

	if (!pItem)
	{
		return NULL;
	}

	pISRItem = ISR_GetItemInternal(uItem);
	if (!pISRItem)
	{
		return NULL;
	}

	memcpy(pItem,pISRItem,sizeof(tISRItem));
	if (pISRItem->Flags & kParam1IsStr)
	{
		// This memory is shared so therefore need to make a copy for upper layers
		// Ptr within the struct are offsets so now need to be ptrs again.
		// Each instance of DLL in Win32 has its own memory map
		pItem->Param1 += (DWORD_PTR)gpzStrTab;
	}

	return pItem;
}


//------------------------------------------------------------------------------
//	ISR_RegisterModule
//		Register a name to be associated with related debug strings.
//		The debug display code can then present this information to the user
//		to determine how to filter the data.
//
//	Params:
//		zShortName	- name to display when space is critical.
//		zLongName	- name to display when a complete description is needed.
//
//	Returns:
//		on error zero for the compatible handle.
//		a handle to be used when making all other debug output calls.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR pzShortName, LPSTR pzLongName)
{
	ptISRModule		pMod;
	UINT			hMod;

	if (!phISRInst)
		return;

	*phISRInst = 0;

	if (kMaxModules <= gpDS->guNumModules)
	{
		// We are out of handles.
		// Return the default handle and drop the name info.
		return;
	}

	// Check if this module label was used before.  If it has then just reuse it.
	// This case will most likely happen when the module is loaded, unloaded,
	// and then reloaded.  Another case is when the same name is used in two
	// different instances.  This would be a confusing programmer oversight
	// and that his problem.
	for (hMod = 0; hMod < kMaxModules; hMod++)
	{
		// if no name then we cannot group very well.
		// In this case waste another handle.
		if (!pzShortName || (0 == *pzShortName))
			break;
		
		pMod = ISR_GetModule(hMod);
		if (!pMod)
			break;

		if ( !_strnicmp(pzShortName,pMod->zSName,sizeof(pMod->zSName)-1) )
		{
			// It matched so just reuse it.
			*phISRInst = (WORD)hMod;
			return;
		}
	}


	*phISRInst = gpDS->guNumModules++;

	pMod = ISR_GetModule(*phISRInst);
	if (!pMod)
		return;

	if (pzShortName)
		strncpy(pMod->zSName,pzShortName,sizeof(pMod->zSName));
	pMod->zSName[sizeof(pMod->zSName)-1] = 0;
	if (pzLongName)
		strncpy(pMod->zLName,pzLongName,sizeof(pMod->zLName));
	pMod->zLName[sizeof(pMod->zLName)-1] = 0;

	return;
}


//------------------------------------------------------------------------------
//	ISR_GetModule
//		Return a pointer to the module record.  Only reason to
//		do it this way is to hide the buf struct.  This way I can use a
//		heap manager such as BigMem or SmartHeap or NT HeapAlloc.
//		Alternatively a Ptr to the array of records could be passed back.
//------------------------------------------------------------------------------
ISR_DLL ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst)
{
	if (kMaxModules <= hISRInst)
	{
		return NULL;
	}

	return(&gpModuleTable[hISRInst]);
}


//------------------------------------------------------------------------------
//	ISR_SetCaptureFilter
//		Debug Messages for a given module can be dropped based on a low/high
//		filter.  If the entire module is not wanted then call with
//		LoFilter = 255, and HiFilter = 0.
//
//------------------------------------------------------------------------------
ISR_DLL int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter)
{
	ptISRModule		pMod;


	pMod = ISR_GetModule(hISRInst);
	if (!pMod)
		return -1;

	pMod->CaptureFilter = CaptureFilter;
	pMod->DisplayFilter = DisplayFilter;

	return 0;
}


/***************************************************************************
	LibMain()
		DLL entry point

	Parameters
		hDllInstance	= instance handle of the DLL (NOT our caller!)
		wDataSegment	= our DS
		wHeapSize		= size of our heap in DS (see .def)
		lpzCmdLine		= argv passed to application (our caller)

	Returns
		TRUE iff we were able to register our window class


	Side Effects
		- Unlocks our data segment (which is really a NOP for protect mode)
	
****************************************************************************/
extern BOOL WINAPI
DllMain
	(
    HINSTANCE	hDllInstance,
	DWORD		dwReason,
	PVOID		pReserved
	)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			// Called for each exe binding.  Each time a exe binds a different hDllInstance will
			// be passed in.  Also our global data will be unique for each Process binding.
			ghAppInstance = hDllInstance;

			// Create a named file mapping object for the base table.
			MapGlobalWin32Memory(&gpDS,&ghDS,sizeof(tDS),"ISRDBG_DS");
			MapGlobalWin32Memory(&gpModuleTable,&ghModuleTable,sizeof(tISRModule) * kMaxModules,"ISRDBG_ModuleTable");
			MapGlobalWin32Memory(&gpDbgTable,&ghDbgTable,sizeof(tISRItem) * kMaxISRItems,"ISRDBG_DbgTable");
			MapGlobalWin32Memory(&gpzStrTab,&ghzStrTab,kMaxStrTab,"ISRDBG_StrTab");
			if (!gpDS || !gpModuleTable || !gpDbgTable || !gpzStrTab)
			{
				return FALSE;
			}

			gSemaphore = CreateSemaphore(NULL,1,1,NULL);

			if (!gpDS->uBindCount++)
			{
				// Set the filters before any output.
				InitModules();

				// Reserve the default module.
				ISR_RegisterModule(&gpDS->ghDefaultModule, "Default", "<ISRDBG><Default Module>");
				ISR_DbgStrStr(gpDS->ghDefaultModule, kISRDefault, "<ISRDBG><DllMain>", "Win32 x1.00");
				ISR_DbgStrStr(gpDS->ghDefaultModule, kISRDefault, "<ISRDBG><DllMain>", "Line 2 test");
			}
			break;
		}
		case DLL_THREAD_ATTACH:
		{
			break;
		}

		case DLL_THREAD_DETACH:
		{
			break;
		}

		case DLL_PROCESS_DETACH:
		{
		    if (gSemaphore)
            {
                CloseHandle(gSemaphore);
                gSemaphore = 0;
            }

			// The DLL is detaching from a process due to
			// process termination or a call to FreeLibrary.
			FreeGlobalWin32Memory(gpDS,ghDS);
			FreeGlobalWin32Memory(gpModuleTable,ghModuleTable);
			FreeGlobalWin32Memory(gpDbgTable,ghDbgTable);
			FreeGlobalWin32Memory(gpzStrTab,ghzStrTab);

			break;
		}
 	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\intelcc\isrdbg32\isrdbg32.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/network/isrdbg/rcs/isrdbgp.h $
  $Revision:   1.0  $
      $Date:   Feb 05 1996 16:27:28  $
    $Author:   DMGORLIC  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.


****************************************************************************/


//--------------------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------------------
// Exported protos are in isrg.h

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\acmfilter.cpp ===
#include "precomp.h"
#include "AcmFilter.h"

AcmFilter::AcmFilter() :
m_bOpened(FALSE),
m_hStream(NULL),
m_dwConvertFlags(0),
m_pWfSrc(NULL),
m_pWfDst(NULL)
{
	return;
};

AcmFilter::~AcmFilter()
{
	Close();
}


MMRESULT AcmFilter::Open(WAVEFORMATEX *pWaveFormatSrc, WAVEFORMATEX *pWaveFormatDst)
{
	const int nMaxExtra = WF_EXTRASIZE;
	int nExtra;
	DWORD dwOpenFlags=0;
	MMRESULT mmr;
	int nAllocAmount = sizeof(WAVEFORMATEX)+nMaxExtra;

	// just in case we are already opened in some other context
	Close();


	m_pWfSrc = (WAVEFORMATEX *)MEMALLOC(nAllocAmount);
	m_pWfDst = (WAVEFORMATEX *)MEMALLOC(nAllocAmount);

	CopyMemory(m_pWfSrc, pWaveFormatSrc, sizeof(WAVEFORMATEX));
	CopyMemory(m_pWfDst, pWaveFormatDst, sizeof(WAVEFORMATEX));

	nExtra = m_pWfSrc->cbSize;
	if (nExtra > nMaxExtra)
		nExtra = nMaxExtra;
	CopyMemory((BYTE*)m_pWfSrc+sizeof(WAVEFORMATEX), (BYTE*)pWaveFormatSrc + sizeof(WAVEFORMATEX), nExtra);

	nExtra = m_pWfDst->cbSize;
	if (nExtra > nMaxExtra)
		nExtra = nMaxExtra;
	CopyMemory((BYTE*)m_pWfDst+sizeof(WAVEFORMATEX), (BYTE*)pWaveFormatDst + sizeof(WAVEFORMATEX), nExtra);

	// now handle all the special conditions for licensed codecs
	// and their individual properties
	FixHeader(m_pWfSrc);
	FixHeader(m_pWfDst);

	GetFlags(m_pWfSrc, m_pWfDst, &dwOpenFlags, &m_dwConvertFlags);

	mmr = acmStreamOpen(&m_hStream, NULL, m_pWfSrc, m_pWfDst, NULL,
	                    0, // no callback
	                    0, // no instance data
	                    dwOpenFlags);

	m_bOpened = (mmr == 0);

#ifdef _DEBUG
	if (m_pWfSrc->wFormatTag == WAVE_FORMAT_PCM)
	{
		DEBUGMSG (1, ("acmStreamOpen: Opened %.6s compression stream\r\n", (m_pWfDst->wFormatTag == 66) ? "G723.1" : (m_pWfDst->wFormatTag == 112) ? "LHCELP" : (m_pWfDst->wFormatTag == 113) ? "LHSB08" : (m_pWfDst->wFormatTag == 114) ? "LHSB12" : (m_pWfDst->wFormatTag == 115) ? "LHSB16" : (m_pWfDst->wFormatTag == 6) ? "MSALAW" : (m_pWfDst->wFormatTag == 7) ? "MSULAW" : (m_pWfDst->wFormatTag == 130) ? "MSRT24" : "??????"));
	}
	else
	{
		DEBUGMSG (1, ("acmStreamOpen: Opened %.6s decompression stream\r\n", (m_pWfSrc->wFormatTag == 66) ? "G723.1" : (m_pWfSrc->wFormatTag == 112) ? "LHCELP" : (m_pWfSrc->wFormatTag == 113) ? "LHSB08" : (m_pWfSrc->wFormatTag == 114) ? "LHSB12" : (m_pWfSrc->wFormatTag == 115) ? "LHSB16" : (m_pWfSrc->wFormatTag == 6) ? "MSALAW" : (m_pWfSrc->wFormatTag == 7) ? "MSULAW" : (m_pWfSrc->wFormatTag == 130) ? "MSRT24" : "??????"));
	}
#endif

	// post opening messages for L&H codecs
	NotifyCodec();

#ifdef DEBUG
	if (mmr != 0)
	{
		DEBUGMSG(ZONE_ACM, ("acmStreamOpen failure: mmr = %d\r\n", mmr));
	}
#endif


	return mmr;
}


MMRESULT AcmFilter::Close()
{
	if (m_bOpened)
	{
		acmStreamClose(m_hStream, 0);
		m_hStream = NULL;
	}

	m_bOpened = FALSE;
	if (m_pWfSrc)
	{
		MEMFREE(m_pWfSrc);
		m_pWfSrc = NULL;
	}

	if (m_pWfDst)
	{
		MEMFREE(m_pWfDst);
		m_pWfDst = NULL;
	}


	return 0;

}


MMRESULT AcmFilter::PrepareHeader(ACMSTREAMHEADER *pHdr)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = acmStreamPrepareHeader(m_hStream, pHdr, 0);

	return mmr;

}


MMRESULT AcmFilter::UnPrepareHeader(ACMSTREAMHEADER *pHdr)
{
	MMRESULT mmr;
	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = acmStreamUnprepareHeader(m_hStream, pHdr, 0);

	return mmr;
}



MMRESULT AcmFilter::PrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection)
{
	MMRESULT mmr;
	ACMSTREAMHEADER *pAcmHeader;
	UINT uIndex;
	UINT uSizeRaw, uSizeNet;
    DWORD_PTR dwPropVal;
	DWORD dwSizeNetMax;
	BYTE *pRaw, *pNet;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	for (uIndex = 0; uIndex < uPackets; uIndex++)
	{
		pAcmHeader = (ACMSTREAMHEADER*)(ppAudPacket[uIndex]->GetConversionHeader());

		ASSERT(pAcmHeader);
		
		ppAudPacket[uIndex]->GetDevData((PVOID*)&pRaw, &uSizeRaw);
		ppAudPacket[uIndex]->GetNetData((PVOID*)&pNet, &uSizeNet);
		ppAudPacket[uIndex]->GetProp(MP_PROP_MAX_NET_LENGTH, &dwPropVal);
        dwSizeNetMax = (DWORD)dwPropVal;

		ZeroMemory(pAcmHeader, sizeof(ACMSTREAMHEADER));
		pAcmHeader->cbStruct = sizeof(ACMSTREAMHEADER);

		if (uDirection == AP_ENCODE)
		{
			pAcmHeader->pbSrc = pRaw;
			pAcmHeader->cbSrcLength = uSizeRaw;

			pAcmHeader->pbDst = pNet;
			pAcmHeader->cbDstLength = uSizeNet;
		}
		else
		{
			pAcmHeader->pbSrc = pNet;
			pAcmHeader->cbSrcLength = dwSizeNetMax;

			pAcmHeader->pbDst = pRaw;
			pAcmHeader->cbDstLength = uSizeRaw;
		}
		
		mmr = PrepareHeader(pAcmHeader);
		if (mmr != MMSYSERR_NOERROR)
		{
			return mmr;
		}

	}

	return mmr;
}

MMRESULT AcmFilter::UnPrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection)
{
	MMRESULT mmr;
	ACMSTREAMHEADER *pAcmHeader;
	UINT uIndex;
    DWORD_PTR dwPropVal;
	DWORD dwSizeNetMax;
	BYTE *pRaw, *pNet;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	for (uIndex = 0; uIndex < uPackets; uIndex++)
	{
		pAcmHeader = (ACMSTREAMHEADER*)(ppAudPacket[uIndex]->GetConversionHeader());

		ASSERT(pAcmHeader);
		
		ppAudPacket[uIndex]->GetProp(MP_PROP_MAX_NET_LENGTH, &dwPropVal);
        dwSizeNetMax = (DWORD)dwPropVal;

		if (uDirection == AP_DECODE)
		{
			pAcmHeader->cbSrcLength = dwSizeNetMax;
		}
		
		mmr = UnPrepareHeader(pAcmHeader);  // ignore errors
		ZeroMemory(pAcmHeader, sizeof(ACMSTREAMHEADER));
	}

	return mmr;
}



MMRESULT AcmFilter::Convert(BYTE *srcBuffer, UINT *pcbSizeSrc, UINT cbSizeSrcMax, BYTE *destBuffer, UINT *pcbSizeDest)
{
	ACMSTREAMHEADER acmHeader;
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	ASSERT((*pcbSizeSrc) <= cbSizeSrcMax);

	ZeroMemory(&acmHeader, sizeof(ACMSTREAMHEADER));

	acmHeader.cbStruct = sizeof(ACMSTREAMHEADER);

	acmHeader.pbSrc = srcBuffer;
	acmHeader.cbSrcLength = cbSizeSrcMax;

	acmHeader.pbDst = destBuffer;
	acmHeader.cbDstLength = *pcbSizeDest;

	mmr = PrepareHeader(&acmHeader);
	if (mmr != 0)
	{
		return mmr;
	}

	acmHeader.cbSrcLength = *pcbSizeSrc;

	mmr = Convert(&acmHeader);

	*pcbSizeSrc = acmHeader.cbSrcLengthUsed;
	*pcbSizeDest = acmHeader.cbDstLengthUsed;

	acmHeader.cbSrcLength = cbSizeSrcMax;  // makes ACM happy
	UnPrepareHeader(&acmHeader);

	return mmr;

}


MMRESULT AcmFilter::Convert(ACMSTREAMHEADER *pAcmHdr)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = acmStreamConvert(m_hStream, pAcmHdr, m_dwConvertFlags);


#ifdef DEBUG
	if (mmr != 0)
	{
		DEBUGMSG(ZONE_ACM, ("acmStreamConvert failed (mmr = %d)\r\n", mmr));
	}
#endif


	return mmr;

}


MMRESULT AcmFilter::Convert(AudioPacket *pAP, UINT uDirection)
{
	MMRESULT mmr=MMSYSERR_INVALPARAM;

	BYTE *pRaw, *pNet;
	UINT uSizeRaw, uSizeNet;
	DWORD dwSizeNetMax;
	ACMSTREAMHEADER *pAcmHeader;


	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	pAcmHeader = (ACMSTREAMHEADER*)(pAP->GetConversionHeader());

	ASSERT(pAcmHeader);

	if (uDirection == AP_ENCODE)
	{
		mmr = Convert(pAcmHeader);
		pAP->SetNetLength(pAcmHeader->cbDstLengthUsed);
	}

	else if (uDirection == AP_DECODE)
	{
		pAP->GetNetData((PVOID*)&pNet, &uSizeNet);
		pAcmHeader->cbSrcLength = uSizeNet;
		mmr = Convert(pAcmHeader);
		pAP->SetRawActual(pAcmHeader->cbDstLengthUsed);
	}

	return mmr;
}



// primarily for putting code licensing codes into header
int AcmFilter::FixHeader(WAVEFORMATEX *pWF)
{
	switch (pWF->wFormatTag)
	{
		case WAVE_FORMAT_PCM:
			break;

		case WAVE_FORMAT_MSG723:
		{
			ASSERT(pWF->cbSize == 10);
			((MSG723WAVEFORMAT *) pWF)->dwCodeword1 = G723MAGICWORD1;
			((MSG723WAVEFORMAT *) pWF)->dwCodeword2 = G723MAGICWORD2;
			break;
		}

		case WAVE_FORMAT_MSRT24:
		{
			// assume call control will take care of the other
			// params ?
			ASSERT(pWF->cbSize == 80);
			lstrcpy(((VOXACM_WAVEFORMATEX *) pWF)->szKey, VOXWARE_KEY);
			break;
		}
	}

	return 0;

}


int AcmFilter::GetFlags(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst, DWORD *pDwOpen, DWORD *pDwConvert)
{
	*pDwOpen = 0;
	*pDwConvert = ACM_STREAMCONVERTF_START | ACM_STREAMCONVERTF_END;

	if (  (pWfSrc->wFormatTag == WAVE_FORMAT_GSM610) ||
	      (pWfDst->wFormatTag == WAVE_FORMAT_GSM610))
	{
		*pDwOpen |= ACM_STREAMOPENF_NONREALTIME;
	}

	return 0;
}

int AcmFilter::NotifyCodec()
{

	if (m_bOpened == FALSE)
		return -1;

	switch	(m_pWfSrc->wFormatTag)
	{
		case WAVE_FORMAT_LH_SB8:
		case WAVE_FORMAT_LH_SB12:
		case WAVE_FORMAT_LH_SB16:
			acmStreamMessage ((HACMSTREAM) m_hStream, ACMDM_LH_DATA_PACKAGING,
		                       LH_PACKET_DATA_FRAMED, 0);
		break;
	}

	return 0;

}


// pWfSrc is a compressed format
// pWfDst is an uncompressed PCM format
MMRESULT AcmFilter::SuggestDecodeFormat(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst)
{
	MMRESULT mmr;

	ZeroMemory(pWfDst, sizeof(WAVEFORMATEX));
	pWfDst->nSamplesPerSec = pWfSrc->nSamplesPerSec;
	pWfDst->wFormatTag = WAVE_FORMAT_PCM;
	pWfDst->nChannels = pWfSrc->nChannels;

	mmr = acmFormatSuggest(NULL, pWfSrc, pWfDst, sizeof(WAVEFORMATEX),
			ACM_FORMATSUGGESTF_NCHANNELS | ACM_FORMATSUGGESTF_NSAMPLESPERSEC
			| ACM_FORMATSUGGESTF_WFORMATTAG);


#ifdef DEBUG
	if (mmr != 0)
	{
		DEBUGMSG(ZONE_ACM, ("acmFormatSuggest failed (mmr == %d)\r\n", mmr));
	}
	else
	{
		DEBUGMSG(ZONE_ACM,
		         ("acmFormatSuggest: wFormat = %d  nChannels = %d  nSamplesPerSec = %d  wBitsPerSample = %d\r\n",
				   pWfDst->wFormatTag, pWfDst->nChannels, pWfDst->nSamplesPerSec, pWfDst->wBitsPerSample));
	}
#endif


	return mmr;
}

MMRESULT AcmFilter::SuggestSrcSize(DWORD dwDestSize, DWORD *p_dwSuggestedSourceSize)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	// 4th param specifies type of 2nd parameter
	mmr = acmStreamSize(m_hStream, dwDestSize, p_dwSuggestedSourceSize, ACM_STREAMSIZEF_DESTINATION);

	return mmr;
}



MMRESULT AcmFilter::SuggestDstSize(DWORD dwSourceSize, DWORD *p_dwSuggestedDstSize)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	// 4th param specifies type of 2nd parameter
	mmr = acmStreamSize(m_hStream, dwSourceSize, p_dwSuggestedDstSize, ACM_STREAMSIZEF_SOURCE);

	return mmr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\acmcaps.h ===
/*
 *  	File: acmcaps.h
 *
 *
 *		ACM implementation of Microsoft Network Audio capability object.
 *
 *		Additional methods supported by this implementation:
 *			BOOL OpenACMDriver(HACMDRIVERID hadid); // (internal)
 *			VOID CloseACMDriver();					// (internal)
 *			HACMDRIVER GetDriverHandle();			// (internal)
 *	
 *		AUDIO_FORMAT_ID AddEncodeFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *		AUDIO_FORMAT_ID AddDecodeFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *

 *		Revision History:
 *
 *		12/27/95	mikev	created
 */


#ifndef _ACMCAPS_H
#define _ACMCAPS_H


// ACM enumeration support functions
BOOL GetFormatBuffer(VOID);
BOOL __stdcall ACMFormatTagEnumCallback(HACMDRIVERID hadid, LPACMFORMATTAGDETAILS paftd,
    DWORD_PTR dwInstance,  DWORD fdwSupport);
BOOL __stdcall ACMFormatEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall ACMDriverEnumCallback(HACMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport);


#ifdef __cplusplus

class CAcmCapability
{
protected:

	HACMDRIVER hAcmDriver;	
public:
	CAcmCapability();
	~CAcmCapability();
	BOOL DriverEnum(DWORD_PTR pAppParam);
	HACMDRIVER GetDriverHandle() {return hAcmDriver;};
	virtual BOOL FormatEnumHandler(HACMDRIVERID hadid,
	    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
	virtual BOOL OpenACMDriver(HACMDRIVERID hadid);
	virtual VOID CloseACMDriver();
};

#define PREF_ORDER_UNASSIGNED 0xffff
typedef enum {
	SortByAppPref=0
}SortMode;

typedef struct AudioParameters
{
	BYTE    RTPPayload;		// RTP payload type
	DWORD 	dwFormatDescriptor;		// the unique ID of this format
	UINT	uSamplesPerSec;	
	UINT	uBitsPerSample;
}AUDIO_PARAMS;


typedef struct H245AudCaps
{
	H245_CAPDIR_T   Dir;
	H245_DATA_T     DataType;
	H245_CLIENT_T   ClientType;
	H245_CAPID_T    CapId;

	H245_CAP_NONSTANDARD_T        H245_NonStd;
	H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
	unsigned short                H245Aud_G711_ALAW64;
	unsigned short                H245Aud_G711_ULAW64;
	H245_CAP_G723_T               H245Aud_G723;

} H245_TERMCAP;


// default initializer for NSC_CHANNEL_PARAMETERS
#define STD_CHAN_PARAMS {0, 0,0,0,0,0,0,0,0}	
// initializers for CC_TERMCAP
#define NONSTD_TERMCAP {H245_CAPDIR_LCLRX, H245_DATA_AUDIO,H245_CLIENT_AUD_NONSTD, 0, {0}}
#define STD_TERMCAP(tc) {H245_CAPDIR_LCLRX, H245_DATA_AUDIO,(tc), 0, {0}}
// Capability cache structure.  This contains local capabilities, public versions of
// those capabilities, parameters for capabilities, plus other information
// that is used to affect how the local machine proritizes or selects a format
//
typedef struct AudCapDetails
{
	WORD	wFormatTag;
	H245_TERMCAP H245TermCap;
	
	NSC_CHANNEL_PARAMETERS nonstd_params;
	AUDIO_PARAMS audio_params;	
	DWORD dwPublicRefIndex;	// index of the local capability entry that will be
							// advertized.  Zero if this entry is the one to advertize
	BOOL bSendEnabled;
	BOOL bRecvEnabled;	
	DWORD dwDefaultSamples;		// default number of samples per packet
	UINT uMaxBitrate;			// max bandwidth used by this format (calculated: bits per sample * sample rate)
	UINT uAvgBitrate;			// average bandwidth used by this format (we get this from the codec)
	WORD wCPUUtilizationEncode;
	WORD wCPUUtilizationDecode;	
	WORD wApplicationPrefOrder;	// overriding preference - lower number means more preferred
	UINT uLocalDetailsSize;		// size in bytes of what lpLocalFormatDetails points to
	LPVOID lpLocalFormatDetails;
	UINT uRemoteDetailsSize;	// size in bytes of what lpRemoteFormatDetails points to
	LPVOID lpRemoteFormatDetails;
	char szFormat[ACMFORMATDETAILS_FORMAT_CHARS];
}AUDCAP_DETAILS, *PAUDCAP_DETAILS;

//Registry Format Cache Structure
//Use In the ACM routines. They build a list of format names, and a list of format data blocks.
//rrf_nFormats is the number of formats we read from the registry.
typedef struct rrfCache {

    char **pNames;
    BYTE **pData;
    UINT nFormats;

} RRF_INFO, *PRRF_INFO;

/*
 *	ACM interface
 *	Definitions for interfacing with ACM
 */

#define ACMAPP_FORMATENUMHANDLER_MASK	0x3
#define ACMAPP_FORMATENUMHANDLER_ENUM	0x0
#define ACMAPP_FORMATENUMHANDLER_ADD	0x1

typedef struct
{
	CAcmCapability *pCapObject;		// the "calling" capability object
	PAUDCAP_DETAILS pAudcapDetails;	// a pointer to an AUDCAP_DETAILS structure
	DWORD dwFlags;					// misc flags...
	LPWAVEFORMATEX lpwfx;			// pointer to wave format structure. used when adding formats
	LPACMFORMATTAGDETAILS paftd;	// pointer to an ACM format tag details.
									// is filled in during DriverEnum
	HRESULT hr;
    PRRF_INFO pRegCache;
} ACM_APP_PARAM, *PACM_APP_PARAM;

//
//  implementation class of the audio interface
//

class CImpAppAudioCap : public IAppAudioCap
{
	public:
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());
	
	STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
    STDMETHOD(ApplyAppFormatPrefs(PBASIC_AUDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));
	STDMETHOD( GetBasicAudcapInfo (AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddACMFormat (LPWAVEFORMATEX lpwfx, PBASIC_AUDCAP_INFO pAudCapInfo));
	STDMETHOD( RemoveACMFormat (LPWAVEFORMATEX lpwfx));

	STDMETHOD_ (LPVOID, GetFormatDetails) (AUDIO_FORMAT_ID Id) ;
 	void Init(class CMsiaCapability * pCapObject) {m_pCapObject = pCapObject;};

protected:
	class CMsiaCapability * m_pCapObject;
};


class CMsiaCapability : public IH323MediaCap, public CAcmCapability
{
protected:
	UINT uRef;
	BOOL bPublicizeTXCaps;
	BOOL bPublicizeTSTradeoff;
	PRRF_INFO pRegFmts;     //Registry cache info structure
	// LOOKLOOK this supports a hack to disable CPU intensive codecs if not running on a pentium
	WORD wMaxCPU;
	UINT m_uPacketDuration;	// packet duration in millisecs

	static MEDIA_FORMAT_ID IDsByRank[MAX_CAPS_PRESORT];
	
	static UINT uNumLocalFormats;			// # of active entries in pLocalFormats
	static UINT uCapIDBase;					// rebase capability ID to index into IDsByRank
	static AUDCAP_DETAILS *pLocalFormats;	// cached list of formats that we can receive
	static UINT uLocalFormatCapacity;		// size of pLocalFormats (in multiples of AUDCAP_DETAILS)
	static UINT uStaticRef;					// global ref count for all instances of CMsiaCapability

	AUDCAP_DETAILS *pRemoteDecodeFormats;	// cached list of formats that the
	UINT uNumRemoteDecodeFormats;	// # of entries for remote decode capabilities
	UINT uRemoteDecodeFormatCapacity;	// size of pRemoteDecodeFormats (in multiples of VIDCAP_DETAILS)
											// other end can receive/decode

	// embedded interface classes											
	CImpAppAudioCap m_IAppCap;											

public:
protected:
	// Internal functions
	UINT IDToIndex(MEDIA_FORMAT_ID id) {return id - uCapIDBase;};
	MEDIA_FORMAT_ID IndexToId(UINT uIndex){return uIndex + uCapIDBase;};
	LPTSTR AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBytesPerSec);
	VOID FreeRegistryKeyName(LPTSTR lpszKeyName);
	virtual VOID CalculateFormatProperties(AUDCAP_DETAILS *pFmtBuf,LPWAVEFORMATEX lpwfx);
	virtual BOOL IsFormatSpecified(LPWAVEFORMATEX lpFormat, LPACMFORMATDETAILS pafd,
		LPACMFORMATTAGDETAILS paftd, AUDCAP_DETAILS *pAudcapDetails);
	virtual VOID SortEncodeCaps(SortMode sortmode);
	BOOL UpdateFormatInRegistry(AUDCAP_DETAILS *pFmt);
	BOOL BuildFormatName(	AUDCAP_DETAILS *pAudcapDetails,
							char *pszFormatTagName,
							char *pszFormatName);
	virtual AUDIO_FORMAT_ID AddFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
	DWORD MaxFramesPerPacket(WAVEFORMATEX *pwf);
	DWORD MinFramesPerPacket(WAVEFORMATEX *pwf);
	UINT MinSampleSize(WAVEFORMATEX *pwf);


public:
	STDMETHOD_(BOOL, Init());
	STDMETHOD_(BOOL, ReInit());
	CMsiaCapability();
	~CMsiaCapability();

	// handler for codec enumeration callback	
	virtual BOOL FormatEnumHandler(HACMDRIVERID hadid,
		LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
	virtual BOOL AddFormatEnumHandler(HACMDRIVERID hadid,
		LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);

//
// Common interface methods
//
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());

//		
// IACapApi methods		
//
    STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
	STDMETHOD(ApplyAppFormatPrefs(PBASIC_AUDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));
	STDMETHOD( GetBasicAudcapInfo (AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddACMFormat (LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo));
	STDMETHOD( RemoveACMFormat (LPWAVEFORMATEX lpwfx));

// support of  IACapApi
	virtual HRESULT CopyAudcapInfo (PAUDCAP_DETAILS pDetails, PAUDCAP_INFO pInfo,
									BOOL bDirection);

//
//	H.323 method implementations
//
	STDMETHOD_(VOID, FlushRemoteCaps());
	STDMETHOD( AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList));
	STDMETHOD_(MEDIA_FORMAT_ID, AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap));

	STDMETHOD( CreateCapList(LPVOID *ppCapBuf));
	STDMETHOD( DeleteCapList(LPVOID pCapBuf));

	STDMETHOD( ResolveEncodeFormat(AUDIO_FORMAT_ID *pIDEncodeOut,
			AUDIO_FORMAT_ID *pIDRemoteDecode));
			
	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID));
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability));
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uSizeLocal,
		AUDIO_FORMAT_ID idRemote, AUDIO_FORMAT_ID idLocal));
	STDMETHOD( GetLocalDecodeParams(LPVOID lpvBuf, UINT uBufSize, AUDIO_FORMAT_ID id));
	STDMETHOD( GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, AUDIO_FORMAT_ID id));
	STDMETHOD( GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		AUDIO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize));
	STDMETHOD_(BOOL, IsCapabilityRecognized(PCC_TERMCAP pCCThisCap));
	STDMETHOD_(BOOL, IsFormatPublic(MEDIA_FORMAT_ID FormatID));	
	STDMETHOD_(MEDIA_FORMAT_ID, GetPublicID(MEDIA_FORMAT_ID FormatID));

	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting)) {bPublicizeTXCaps = bSetting;};
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting)) {bPublicizeTSTradeoff= bSetting;};
	STDMETHOD (SetAudioPacketDuration( UINT durationInMs));
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote));	
// Methods common to H.323 and MSICCP
	STDMETHOD_(UINT, GetNumCaps()){return uNumLocalFormats;};
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps));
	STDMETHOD_(BOOL, IsHostForCapID(MEDIA_FORMAT_ID CapID));
	STDMETHOD(SetCapIDBase(UINT uNewBase));
	STDMETHOD_(UINT, GetCapIDBase()) {return uCapIDBase;};
	STDMETHOD (IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend));

// methods provided to the Data pump, common to H.323 and MSICCP
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));


};

#endif	// __cplusplus

#endif	//#ifndef _ACMCAPS_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\agc.h ===
#ifndef _AGC_H
#define _AGC_H

#include "mixer.h"

#define PEAKARRAYSIZE	5
#define AGC_INCREMENT	10000  // approx 1/6 of the mixer range
#define AGC_MAXVOL	65535   // highest mixer volume setting

#define AGC_HIGHVOL	24576   // minimum for loud volume see Update() method
#define AGC_PEAKVOL 32767   // peak sample value (could also be 32768)

#define AGC_DEFAULT_THRESH	16384


#define AGC_NOUPDATE	0
#define AGC_UPDATE_LOWERVOL	1
#define AGC_UPDATE_RAISEVOL	2

class AGC
{
private:
	CMixerDevice *m_pMixer;

	WORD m_aPeaks[PEAKARRAYSIZE];
	int m_cPeaks;  // how many have been inserted into above array

	WORD m_wCurrentPeak;  // max value of last second
	DWORD m_dwCollectionTime; // amount of sampling collected so far

	WORD m_wThreshStrength;  // the minimum we are trying to target

	DWORD m_dwLastVolumeSetting; // last known volume setting
	int m_nLastUpdateResult;

	inline BOOL RaiseVolume();
	inline BOOL LowerVolume();
	inline BOOL HasVolumeChanged();

public:
	AGC(CMixerDevice *pMixer);
	void SetMixer(CMixerDevice *pMixer);
	inline void SetThresholdStrength(WORD wStrength) {m_wThreshStrength=wStrength;}
	int Update(WORD wPeakStrength, DWORD dwLengthMS);
	void Reset();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\audiofile.cpp ===
#include "precomp.h"



/*************************************************************************

  Function: AudioFile::OpenSourceFile(MMIOSRC *pSrcFile, WAVEFORMATEX *pwf)

  Purpose : Opens wav file to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments: * Registry keys:
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fPlayFromFile
              If set to zero, data will not be read from wav file.
              If set to a non null value <= INT_MAX, data will be read from wav file.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\szInputFileName
              Name of the wav file to read audio data from.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fLoop
              If set to zero, the file will only be read once.
              If set to a non null value <= INT_MAX, the file will be read circularly.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\cchIOBuffer
              If set to zero, size of the MM IO buffer is set to its default value (8Kbytes).
              If set to one, size of the MM IO buffer is set to match maximum size of the wav file.
              If set a non null value between 2 and INT_MAX, size of the MM IO buffer is set to cchIOBuffer bytes.

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::OpenSourceFile (MMIOSRC *pSrcFile, WAVEFORMATEX *pwf)
{
	HRESULT			hr = DPR_SUCCESS;
	MMIOINFO		mmioInfo;
	long			cchBuffer;
	WAVEFORMATEX	*pwfFile;
	DWORD			dw;

	FX_ENTRY ("SendAudioStream::OpenSrcFile")

	RegEntry reIPhoneInFile(szRegInternetPhone TEXT("\\") szRegInternetPhoneInputFile,
							HKEY_LOCAL_MACHINE,
							FALSE,
							KEY_READ);

	// For now, get the file name from the registry
	if (pSrcFile->fPlayFromFile = reIPhoneInFile.GetNumberIniStyle(TEXT("fPlayFromFile"), FALSE))
	{
		lstrcpyn(pSrcFile->szInputFileName,
					reIPhoneInFile.GetString(TEXT("szInputFileName")),
					CCHMAX(pSrcFile->szInputFileName));
		cchBuffer = reIPhoneInFile.GetNumberIniStyle(TEXT("cchIOBuffer"), 0L);
		pSrcFile->fLoop = reIPhoneInFile.GetNumberIniStyle(TEXT("fLoop"), TRUE);
		pSrcFile->fDisconnectAfterPlayback 
			= reIPhoneInFile.GetNumberIniStyle(TEXT("fDisconnectAfterPlayback"), FALSE);
		
		cchBuffer = MMIO_DEFAULTBUFFER;

		ZeroMemory(&mmioInfo, sizeof(MMIOINFO));
		do
		{
			mmioInfo.cchBuffer = cchBuffer;
			pSrcFile->hmmioSrc = mmioOpen((LPSTR)&(pSrcFile->szInputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_READ | MMIO_DENYWRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF);
			cchBuffer /= 2;
		} while ((mmioInfo.wErrorRet == MMIOERR_OUTOFMEMORY) && (mmioInfo.cchBuffer > MMIO_DEFAULTBUFFER));

		if (pSrcFile->hmmioSrc)
		{
			// Locate a 'WAVE' form type in a 'RIFF' thing...
			pSrcFile->ckSrcRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
			if (mmioDescend(pSrcFile->hmmioSrc, (LPMMCKINFO)&(pSrcFile->ckSrcRIFF), NULL, MMIO_FINDRIFF))
				goto MyMMIOErrorExit3;

			// We found a WAVE chunk--now go through and get all subchunks that we know how to deal with
			while (mmioDescend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), &(pSrcFile->ckSrcRIFF), 0) == 0)
			{
				// Quickly check for corrupt RIFF file--don't ascend past end!
				if ((pSrcFile->ckSrc.dwDataOffset + pSrcFile->ckSrc.cksize) > (pSrcFile->ckSrcRIFF.dwDataOffset + pSrcFile->ckSrcRIFF.cksize))
					goto MyMMIOErrorExit1;
				// Make sure the wave format structure of this file is compatible with the microphone
				if (pSrcFile->ckSrc.ckid == mmioFOURCC('f', 'm', 't', ' '))
				{
					if ((dw = pSrcFile->ckSrc.cksize) < sizeof(WAVEFORMATEX))
						dw = sizeof(WAVEFORMATEX);

					if (!(pwfFile = (WAVEFORMATEX *)GlobalAllocPtr(GHND, dw)))
						goto MyMMIOErrorExit1;

					dw = pSrcFile->ckSrc.cksize;
					if (mmioRead(pSrcFile->hmmioSrc, (HPSTR)pwfFile, dw) != (LONG)dw)
						goto MyMMIOErrorExit0;
					if (dw == sizeof(WAVEFORMATEX))
						pwfFile->cbSize = 0;
					if ((pwfFile->wFormatTag != pwf->wFormatTag) || (pwfFile->nChannels != pwf->nChannels)
						|| (pwfFile->nSamplesPerSec != pwf->nSamplesPerSec) || (pwfFile->nAvgBytesPerSec != pwf->nAvgBytesPerSec)
						|| (pwfFile->nBlockAlign != pwf->nBlockAlign)  || (pwfFile->wBitsPerSample != pwf->wBitsPerSample) || (pwfFile->cbSize != pwf->cbSize))
						goto MyMMIOErrorExit0;
					pwfFile = (WAVEFORMATEX *)(UINT_PTR)GlobalFreePtr(pwfFile);
				}
				// Step up to prepare for next chunk..
				mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), 0);
			}

			// Go back to beginning of data portion of WAVE chunk
			if (-1L == mmioSeek(pSrcFile->hmmioSrc, pSrcFile->ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
				goto MyMMIOErrorExit2;
			pSrcFile->ckSrc.ckid = mmioFOURCC('d', 'a', 't', 'a');
			if (mmioDescend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), &(pSrcFile->ckSrcRIFF), MMIO_FINDCHUNK))
				goto MyMMIOErrorExit2;
			pSrcFile->dwMaxDataLength = pSrcFile->ckSrc.cksize;
			pSrcFile->dwDataLength = 0;
			pSrcFile->wfx = *pwf;

			// At this point, the src file is sitting at the very
			// beginning of its data chunks--so we can read from the src file...

			goto MyLastExit;

MyMMIOErrorExit0:
			GlobalFreePtr(pwfFile);
MyMMIOErrorExit1:
			mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), 0);
MyMMIOErrorExit2:
			mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrcRIFF), 0);
MyMMIOErrorExit3:
			mmioClose(pSrcFile->hmmioSrc, 0);
			pSrcFile->hmmioSrc = NULL;
		}
	}

MyLastExit:

	return hr;

}


/*************************************************************************

  Function: AudioFile::CloseSourceFile(void)

  Purpose : Close wav file used to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments:

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::CloseSourceFile (MMIOSRC *pSrcFile)
{
	HRESULT	hr = DPR_SUCCESS;

	FX_ENTRY ("SendAudioStream::CloseSrcFile")

	if (pSrcFile->fPlayFromFile && pSrcFile->hmmioSrc)
	{
		mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), 0);
		mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrcRIFF), 0);
		mmioClose(pSrcFile->hmmioSrc, 0);
		pSrcFile->hmmioSrc = NULL;
	}

	return hr;
}

HRESULT AudioFile::ReadSourceFile(MMIOSRC *pmmioSrc, BYTE *pData, DWORD dwBytesToRead)
{

	long lNumBytesRead;
	bool bCloseFile = false;

	FX_ENTRY ("AdPckt::ReadFromFile")

	if (pmmioSrc->hmmioSrc == NULL)
		return S_FALSE;


	if (dwBytesToRead)
	{
MyRead:
		if ((pmmioSrc->dwDataLength + dwBytesToRead) <= pmmioSrc->dwMaxDataLength)
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, (char*)pData, dwBytesToRead);
			pmmioSrc->dwDataLength += lNumBytesRead;
		}
		else
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, (char*)pData, pmmioSrc->dwMaxDataLength - pmmioSrc->dwDataLength);
			pmmioSrc->dwDataLength += lNumBytesRead;

			// silence out the remainder of the block
			if (pmmioSrc->wfx.wBitsPerSample != 8)
			{
				ZeroMemory(pData, dwBytesToRead - lNumBytesRead);
			}
			else
			{
				FillMemory(pData, dwBytesToRead - lNumBytesRead, 0x80);
			}

			pmmioSrc->dwDataLength = 0;
			lNumBytesRead = 0;
		}
		
		if (!lNumBytesRead)
		{
			if (pmmioSrc->fLoop && !pmmioSrc->fDisconnectAfterPlayback)
			{
				// Reset file pointer to beginning of data
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), 0);
				if (-1L == mmioSeek(pmmioSrc->hmmioSrc, pmmioSrc->ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
				{
					DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't seek in file, mmr=%ld\r\n", (ULONG) 0L));
					bCloseFile = true;
				}
				else
				{
					pmmioSrc->ckSrc.ckid = mmioFOURCC('d', 'a', 't', 'a');
					if (mmioDescend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), &(pmmioSrc->ckSrcRIFF), MMIO_FINDCHUNK))
					{
						DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't locate 'data' chunk, mmr=%ld\r\n", (ULONG) 0L));
						bCloseFile = true;
					}
					else
					{
						// At this point, the src file is sitting at the very
						// beginning of its data chunks--so we can read from the src file...
						goto MyRead;
					}
				}
			}
			else
			{
				bCloseFile = true;
			}

			if (bCloseFile)
			{
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrcRIFF), 0);
				mmioClose(pmmioSrc->hmmioSrc, 0);
				pmmioSrc->hmmioSrc = NULL;
				return S_FALSE;
			}
		}

		return S_OK;

	}
	return S_FALSE;
}






/*************************************************************************

  Function: RecvAudioStream::OpenDestFile(void)

  Purpose : Opens wav file to record audio data into.

  Returns : HRESULT.

  Params  : None

  Comments: * Registry keys:
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\fRecordToFile
              If set to zero, data will not be recorded into wav file.
              If set to a non null value <= INT_MAX, data will be recorded into wav file.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\fRecordToFile
              If set to zero, data will overwrite existing data if wav file already exists.
              If set to a non null value <= INT_MAX, data will be recorded into wav file after existing data.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\szOutputFileName
              Name of the wav file to record audio data into.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\lMaxTimeLength
              If set to zero, there is no limit to the size of the wav file.
              If set to a non null value <= INT_MAX, size of the file will be clamped to lMaxTimeLength.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\cchIOBuffer
              If set to zero, size of the MM IO buffer is set to its default value (8Kbytes).
              If set to one, size of the MM IO buffer is set to match maximum size of the wav file.
              If set a non null value between 2 and INT_MAX, size of the MM IO buffer is set to cchIOBuffer bytes.

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::OpenDestFile (MMIODEST *pDestFile, WAVEFORMATEX *pwf)
{
	HRESULT			hr = DPR_SUCCESS;
	MMIOINFO		mmioInfo;
	DWORD			dw;
	long			cchBuffer;
	long			lMaxTimeLength;
	BOOL			fAppend;
	MMRESULT		mmr;

	FX_ENTRY ("RecvAudioStream::OpenDestFile")

	RegEntry reIPhoneOutFile(szRegInternetPhone TEXT("\\") szRegInternetPhoneOutputFile,
							HKEY_LOCAL_MACHINE,
							FALSE,
							KEY_READ);

	// For now, get the file name from the registry
	if (pDestFile->fRecordToFile = reIPhoneOutFile.GetNumberIniStyle(TEXT("fRecordToFile"), FALSE))
	{
		lstrcpyn(pDestFile->szOutputFileName,
					reIPhoneOutFile.GetString(TEXT("szOutputFileName")),
					CCHMAX(pDestFile->szOutputFileName));
		cchBuffer = reIPhoneOutFile.GetNumberIniStyle(TEXT("cchIOBuffer"), 0L);
		lMaxTimeLength = reIPhoneOutFile.GetNumberIniStyle(TEXT("lMaxTimeLength"), 0L);
#if 0
		fAppend = reIPhoneOutFile.GetNumberIniStyle(TEXT("fAppend"), FALSE);
#else
		fAppend = FALSE;
#endif
		// Try to open the file for writing using buffered I/O
		// If the size of the buffer is too large, try again
		// with a buffer half that size.
		// m_RecvFilter->GetProp(FM_PROP_DST_MEDIA_FORMAT, (PDWORD)&pwf);

		if (!pwf)
			goto MyLastExit;
		pDestFile->dwMaxDataLength = lMaxTimeLength == 0L ? (DWORD)INT_MAX : (DWORD)(lMaxTimeLength * pwf->nSamplesPerSec * pwf->nBlockAlign / 1000L);
		if ((cchBuffer == 0L) || (lMaxTimeLength == 0L))
			cchBuffer = MMIO_DEFAULTBUFFER;
		else
			if (cchBuffer == 1L)
				cchBuffer = (long)pDestFile->dwMaxDataLength;
		ZeroMemory(&mmioInfo, sizeof(MMIOINFO));
		if (!mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), NULL, MMIO_EXIST))
			fAppend = FALSE;
		do
		{
			mmioInfo.cchBuffer = cchBuffer;
			// pDestFile->hmmioDst = mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_EXCLUSIVE | MMIO_ALLOCBUF | (fAppend ? MMIO_READWRITE : MMIO_WRITE | MMIO_CREATE));
			pDestFile->hmmioDst = mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_EXCLUSIVE | MMIO_ALLOCBUF | (fAppend ? MMIO_WRITE : MMIO_WRITE | MMIO_CREATE));
			cchBuffer /= 2;
		} while ((mmioInfo.wErrorRet == MMIOERR_OUTOFMEMORY) && (mmioInfo.cchBuffer > MMIO_DEFAULTBUFFER));
		if (pDestFile->hmmioDst)
		{
			if (!fAppend)
			{
				// Create the RIFF chunk of form type 'WAVE'
				pDestFile->ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
				pDestFile->ckDstRIFF.cksize  = 0L;
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), MMIO_CREATERIFF))
					goto MyMMIOErrorExit3;

				// Now create the destination fmt, fact, and data chunks _in that order_
				pDestFile->ckDst.ckid   = mmioFOURCC('f', 'm', 't', ' ');
				pDestFile->ckDst.cksize = dw = SIZEOF_WAVEFORMATEX(pwf);
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit2;
				if (mmioWrite(pDestFile->hmmioDst, (HPSTR)pwf, dw) != (LONG)dw)
					goto MyMMIOErrorExit1;
				if (mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit1;

				// Create the 'fact' chunk.
				// Since we are not writing any data to this file (yet), we set the
				// samples contained in the file to 0.
				pDestFile->ckDst.ckid   = mmioFOURCC('f', 'a', 'c', 't');
				pDestFile->ckDst.cksize = 0L;
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit2;
				pDestFile->dwDataLength = 0; // This will be updated when closing the file.
				if (mmioWrite(pDestFile->hmmioDst, (HPSTR)&(pDestFile->dwDataLength), sizeof(long)) != sizeof(long))
					goto MyMMIOErrorExit1;
				if (mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit1;

				// Create the data chunk and stay descended
				pDestFile->ckDst.ckid   = mmioFOURCC('d', 'a', 't', 'a');
				pDestFile->ckDst.cksize = 0L;
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit2;

				// At this point, the dst file is sitting at the very
				// beginning of its data chunks--so we can write to the dst file...
				goto MyLastExit;

MyMMIOErrorExit1:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
MyMMIOErrorExit2:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), 0);
MyMMIOErrorExit3:
				mmioClose(pDestFile->hmmioDst, 0);
				mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_DELETE);
				pDestFile->hmmioDst = NULL;
			}
			else
			{
				// File already exists, only need to position pointer at the end of existing data.
				// Locate a 'WAVE' form type in a 'RIFF' thing...
				pDestFile->ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
				if (mmr = mmioDescend(pDestFile->hmmioDst, (LPMMCKINFO)&(pDestFile->ckDstRIFF), NULL, MMIO_FINDRIFF))
					goto MyOtherMMIOErrorExit3;

				// We found a WAVE chunk--now go through and get all subchunks that we know how to deal with
				while (mmr = mmioDescend(pDestFile->hmmioDst, &(pDestFile->ckDst), &(pDestFile->ckDstRIFF), 0) == 0)
				{
					// Quickly check for corrupt RIFF file--don't ascend past end!
					if ((pDestFile->ckDst.dwDataOffset + pDestFile->ckDst.cksize) > (pDestFile->ckDstRIFF.dwDataOffset + pDestFile->ckDstRIFF.cksize))
						goto MyOtherMMIOErrorExit1;
					// Step up to prepare for next chunk..
					mmr = mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
				}

				// Go back to beginning of data portion of WAVE chunk
				if (-1L == mmioSeek(pDestFile->hmmioDst, pDestFile->ckDstRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
					goto MyOtherMMIOErrorExit2;
				pDestFile->ckDst.ckid = mmioFOURCC('d', 'a', 't', 'a');
				if (mmr = mmioDescend(pDestFile->hmmioDst, &(pDestFile->ckDst), &(pDestFile->ckDstRIFF), MMIO_FINDCHUNK))
					goto MyOtherMMIOErrorExit2;
				pDestFile->dwDataLength = pDestFile->ckDst.cksize;
				if (-1L == (mmr = mmioSeek(pDestFile->hmmioDst, 0, SEEK_END)))
					goto MyOtherMMIOErrorExit2;

				// At this point, the dst file is sitting at the very
				// end of its data chunks--so we can write to the dst file...

				goto MyLastExit;

MyOtherMMIOErrorExit1:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
MyOtherMMIOErrorExit2:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), 0);
MyOtherMMIOErrorExit3:
				mmioClose(pDestFile->hmmioDst, 0);
				pDestFile->hmmioDst = NULL;
			}
		}
	}

MyLastExit:
	return hr;

}


/*************************************************************************

  Function: RecvAudioStream::CloseDestFile(void)

  Purpose : Close wav file used to record audio data into.

  Returns : HRESULT.

  Params  : None

  Comments:

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::CloseDestFile (MMIODEST *pDestFile)
{
	HRESULT	hr = DPR_SUCCESS;
	FX_ENTRY ("RecvAudioStream::CloseDestFile")

	if (pDestFile->fRecordToFile && pDestFile->hmmioDst)
	{
		mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
		mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), 0);
		mmioClose(pDestFile->hmmioDst, 0);
		pDestFile->hmmioDst = NULL;
	}

	return hr;
}




HRESULT AudioFile::WriteDestFile(MMIODEST *pmmioDest, BYTE *pData, DWORD dwBytesToWrite)
{
	MMRESULT mmr=MMSYSERR_NOERROR;

	FX_ENTRY ("AudioFile::WriteToFile")

	if ((pmmioDest->hmmioDst == NULL) || (dwBytesToWrite == 0))
	{
		return S_FALSE;
	}

	if (mmioWrite(pmmioDest->hmmioDst, (char *) pData, dwBytesToWrite) != (long)dwBytesToWrite)
	{
		mmr = MMSYSERR_ERROR;
	}
	else
	{
		pmmioDest->dwDataLength += dwBytesToWrite;
	}

	if ((pmmioDest->dwDataLength >= pmmioDest->dwMaxDataLength) ||
	    (mmr != MMSYSERR_NOERROR))
	{
		mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDst), 0);
		mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDstRIFF), 0);
		mmr = mmioClose(pmmioDest->hmmioDst, 0);
		pmmioDest->hmmioDst = NULL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\acmfilter.h ===
#ifndef ACM_FILTER_H
#define ACM_FILTER_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

// this is where are the WAVE_FORMAT_XXX defs live
#include <auformats.h>



// max number of bytes that may appear at the end of 
// a WAVEFORMATEX structure (e.g. VoxWare key)
#define WF_EXTRASIZE	80

#ifndef G723MAGICWORD1
#define G723MAGICWORD1 0xf7329ace
#endif

#ifndef G723MAGICWORD2
#define G723MAGICWORD2 0xacdeaea2
#endif



#ifndef VOXWARE_KEY
#define VOXWARE_KEY "35243410-F7340C0668-CD78867B74DAD857-AC71429AD8CAFCB5-E4E1A99E7FFD-371"
#endif


#define AP_ENCODE	1
#define AP_DECODE	2


class AcmFilter
{
public:
	AcmFilter();
	~AcmFilter();


	MMRESULT Open(WAVEFORMATEX *pWaveFormatSource, WAVEFORMATEX *pWaveFormatDest);


	// normally, you shouldn't have to worry about calling these
	// methods unless you pass an ACMSTREAMHEADER directly into Convert
	MMRESULT PrepareHeader(ACMSTREAMHEADER *pHdr);
	MMRESULT UnPrepareHeader(ACMSTREAMHEADER *pHdr);

	MMRESULT PrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection);
	MMRESULT UnPrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection);


	// pcbSizeSrc and pcbSizeDst are in/out params
	// specify size of buffers before compression and return
	// the amount of data used after compressioin
	// for most codecs: cbSizeSrcMax == cbSizeSrc unless the decode
	// operation support variable bit rates such as G723.1.  In this
	// case cbSizeSrcMax >= cbSizeSrc
	MMRESULT Convert(BYTE *srcBuffer, UINT *pcbSizeSrc, UINT cbSizeSrcMax,
	                 BYTE *destBuffer, UINT *pcbSizeDest);

	// make sure you sequence this particular call between PrepareHeader
	// and UnPrepareHeader
	MMRESULT Convert(ACMSTREAMHEADER *pHdr);

	MMRESULT Convert(AudioPacket *pAP, UINT uDirection);
	MMRESULT Close();

	MMRESULT SuggestSrcSize(DWORD dwDestSize, DWORD *p_dwSuggestedSourceSize);
	MMRESULT SuggestDstSize(DWORD dwSourceSize, DWORD *p_dwSuggestedDstSize);

	static MMRESULT SuggestDecodeFormat(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst);
	


private:
	BOOL m_bOpened;
	HACMSTREAM m_hStream;
	DWORD m_dwConvertFlags;

	WAVEFORMATEX *m_pWfSrc;
	WAVEFORMATEX *m_pWfDst;

	static int FixHeader(WAVEFORMATEX *pWF);
	static int GetFlags(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst, DWORD *pDwOpen, DWORD *pDwConvert);


	int NotifyCodec();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\audpackt.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    audpackt.h

Abstract:

    Contains  prototypes for the AudioPacket class, which encapsulates a sound buffer in
    its various states: recorded/encoded/network/decoded/playing etc.

--*/
#ifndef _AUDPACKT_H_
#define _AUDPACKT_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define AP_NUM_PREAMBLE_PACKETS		6

//
// Start of Interpolation defines
//

// Recovering techniques
typedef enum tagTECHNIQUE
{
	techPATT_MATCH_PREV_SIGN_CC,	// Replicate from the previous frame using pattern matching and signed cross-correlation
	techPATT_MATCH_NEXT_SIGN_CC,	// Replicate from the previous frame using pattern matching and signed cross-correlation
	techPATT_MATCH_BOTH_SIGN_CC,	// Interpolate between the previous and the next frame using pattern matching and signed cross-correlation
	techDUPLICATE_PREV,				// Replicate last frame
	techDUPLICATE_NEXT				// Replicate next frame
}TECHNIQUE;

// Wave Substitution structure
typedef struct tagPCMSUB
{
	short		*pwWaSuBf;	// Pointer to missing buffer
	short		*pwPrBf;	// Pointer to previous audio buffer
	short		*pwNeBf;	// Pointer to next audio buffer
	DWORD		dwBfSize;	// Number of samples in audio buffer
	DWORD		dwSaPeSe;	// Frequency sampling for ALL buffers (in samples per second)
	DWORD		dwBiPeSa;	// Number of bits per sample for ALL buffers (in bits per sample)
	TECHNIQUE	eTech;		// Technique to be used
	BOOL		fScal;      // Scale reconstructed frame
}PCMSUB;

#define PATTERN_SIZE 4		// Pattern size in milliseconds. Experiment with values between 2 and 8 ms.
#define SEARCH_SIZE 8		// Window search size in milliseconds. Experiment with values between 8 and 16 ms.

//
// End of Interpolation defines
//

class AudioPacket : public MediaPacket
{
 public:
	virtual HRESULT Initialize ( MEDIAPACKETINIT * p );
	virtual HRESULT Play ( MMIODEST *pmmioDest, UINT uDataType );
	virtual HRESULT Record ( void );
	virtual HRESULT Interpolate ( MediaPacket * pPrev, MediaPacket * pNext);
	virtual HRESULT GetSignalStrength ( PDWORD pdwMaxStrength );
	HRESULT ComputePower ( PDWORD pdwVoiceStrength, PWORD pwPeakStrength);
	virtual HRESULT MakeSilence ( void );
	virtual HRESULT Open ( UINT uType, DPHANDLE hdl );	// called by RxStream or TxStream
	virtual HRESULT Close ( UINT uType );				// called by RxStream or TxStream
	virtual BOOL IsBufferDone ( void );
	virtual BOOL IsSameMediaFormat(PVOID fmt1,PVOID fmt2);
	virtual DWORD GetDevDataSamples();

	void WriteToFile (MMIODEST *pmmioDest);
	void ReadFromFile (MMIOSRC *pmmioSrc);
	HRESULT PCMSubstitute( PCMSUB *pPCMSub);
};


#include <poppack.h> /* End byte packing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\audpackt.cpp ===
#include "precomp.h"

#define ZONE_AP			ZONE_DP


#define _GetState()		(m_dwState & DP_MASK_STATE)
#define _SetState(s)	(m_dwState = (m_dwState & ~DP_MASK_STATE) | (s & DP_MASK_STATE))

#define _GetPlatform()	(m_dwState & DP_MASK_PLATFORM)
#define _SetPlatform(s)	(m_dwState = (m_dwState & ~DP_MASK_PLATFORM) | (s & DP_MASK_PLATFORM))


int g_wavein_prepare = 0;
int g_waveout_prepare = 0;


///////////////////////////////////////////////////////
//
//  Public methods
//




HRESULT AudioPacket::Initialize ( MEDIAPACKETINIT * p )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::Init")

	if (p == NULL)
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid parameter (null ptr)\r\n", _fx_));
		return DPR_INVALID_PARAMETER;
	}

	hr = MediaPacket::Initialize( p);
	
	if (hr != DPR_SUCCESS)
		goto MyExit;
		
	// allocate conversion header only if m_pWaveData != m_pNetData
	if (m_pRawData != m_pNetData)
	{
		if (m_dwState & DP_FLAG_ACM)
		{
			m_pStrmConvHdr = MemAlloc (sizeof (ACMSTREAMHEADER));
			if (m_pStrmConvHdr == NULL)
			{
				DEBUGMSG (ZONE_AP, ("%s: MemAlloc4 (%ld) failed\r\n",
				_fx_, (ULONG) sizeof (ACMSTREAMHEADER)));
				hr = DPR_OUT_OF_MEMORY;
				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (acm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}

	}
	else
	{
		m_pStrmConvHdr = NULL;
	}

	// allocate device header
	if (m_dwState & DP_FLAG_MMSYSTEM)
	{
		m_pDevHdr = MemAlloc (sizeof (WAVEHDR));
		if (m_pDevHdr == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc5 (%ld) failed\r\n",
			_fx_, (ULONG) sizeof (WAVEHDR)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid platform (mm)\r\n", _fx_));
		hr = DPR_INVALID_PLATFORM;
		goto MyExit;
	}

	MakeSilence ();

MyExit:

	if (hr != DPR_SUCCESS)
	{
		m_fInitialized = FALSE;
		Release();
	}

	return hr;
}


HRESULT AudioPacket::Play ( MMIODEST *pmmioDest, UINT uDataType )
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwState = _GetState ();
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Play")

	if (dwState != MP_STATE_DECODED && dwState != MP_STATE_RESET)
	{
		DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		return DPR_OUT_OF_SEQUENCE;
	}

	if (uDataType == MP_DATATYPE_SILENCE)
	{
		LOG((LOGMSG_PLAY_SILENT,m_index,GetTickCount()));
		MakeSilence ();
	}
	else
	{
		if (uDataType == MP_DATATYPE_INTERPOLATED)
		{
			if (dwState == MP_STATE_DECODED)
			{
				LOG((LOGMSG_PLAY_INTERPOLATED,m_index,GetTickCount()));
			}
			else
			{
				LOG((LOGMSG_PLAY_SILENT,m_index,GetTickCount()));
				MakeSilence ();
			}
		}
		else
		{
			LOG((LOGMSG_PLAY,m_index, GetTickCount()));
		}
	}


	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_MMSYSTEM)
		{
			((WAVEHDR *) m_pDevHdr)->lpData = (char *) m_pDevData->data;
//			((WAVEHDR *) m_pDevHdr)->dwBufferLength = (dwState == MP_STATE_DECODED ?
//									((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed :
//									m_pDevData->length);

			((WAVEHDR *) m_pDevHdr)->dwBufferLength = (dwState == MP_STATE_DECODED ?
			                        m_cbValidRawData : m_pDevData->length);
			


			((WAVEHDR *) m_pDevHdr)->dwUser = (DWORD_PTR) this;
			((WAVEHDR *) m_pDevHdr)->dwFlags &= ~(WHDR_DONE|WHDR_INQUEUE);
			((WAVEHDR *) m_pDevHdr)->dwLoops = 0L;

			// feed this buffer to play
			mmr = waveOutWrite ((HWAVEOUT) m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
			if (mmr != MMSYSERR_NOERROR)
			{
				DEBUGMSG (ZONE_AP, ("%s: waveOutWrite failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
				hr = DPR_CANT_WRITE_WAVE_DEV;

				// this is an extremely rare error, but we've seen it
				// occur on some sound cards

				// in this case, just set the "done" bit, mark the
				// state to the "playing", but still return an error.

				((WAVEHDR *) m_pDevHdr)->dwFlags |= WHDR_DONE;


				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (mm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}
		if (pmmioDest && pmmioDest->fRecordToFile && pmmioDest->hmmioDst)
		{
			// write this buffer to disk
			WriteToFile(pmmioDest);
		}
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid handle\r\n", _fx_));
		hr = DPR_INVALID_HANDLE;
		goto MyExit;
	}

MyExit:

	if ((hr == DPR_SUCCESS) || (hr == DPR_CANT_WRITE_WAVE_DEV))
	{
		_SetState (((uDataType == MP_DATATYPE_SILENCE) || (uDataType == MP_DATATYPE_INTERPOLATED))? MP_STATE_PLAYING_SILENCE : MP_STATE_PLAYING_BACK);
	}
	return hr;
}



HRESULT AudioPacket::Record ( void )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Record")

	LOG((LOGMSG_RECORD,m_index));

	if (_GetState () != MP_STATE_RESET)
	{
		DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		return DPR_OUT_OF_SEQUENCE;
	}

	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_MMSYSTEM)
		{
			((WAVEHDR *) m_pDevHdr)->lpData = (char *) m_pDevData->data;
			((WAVEHDR *) m_pDevHdr)->dwBufferLength = m_pDevData->length;
			((WAVEHDR *) m_pDevHdr)->dwUser = (DWORD_PTR) this;
			((WAVEHDR *) m_pDevHdr)->dwFlags |= WHDR_PREPARED;
			((WAVEHDR *) m_pDevHdr)->dwLoops = 0L;

			// feed this buffer to record
			mmr = waveInAddBuffer ((HWAVEIN)m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
			if (mmr != MMSYSERR_NOERROR)
			{
				DEBUGMSG (ZONE_AP, ("%s: waveInAddBuffer failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
				hr = DPR_CANT_ADD_BUFFER;
				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (mm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid handle\r\n", _fx_));
		hr = DPR_INVALID_HANDLE;
		goto MyExit;
	}

MyExit:

	if (hr == DPR_SUCCESS) _SetState (MP_STATE_RECORDING);
	return hr;
}


BOOL AudioPacket::IsBufferDone ( void )
{
	FX_ENTRY ("AdPckt::IsBufferDone")

	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_MMSYSTEM)
		{
			return (((WAVEHDR *) m_pDevHdr)->dwFlags & WHDR_DONE);
		}
	}

	return FALSE;
}


HRESULT AudioPacket::MakeSilence ( void )
{
	// create white noise!!!

	FX_ENTRY ("AdPckt::MakeSilence")

	if (m_pDevFmt)
	{
		if (m_pDevData)
		{
			FillSilenceBuf ((WAVEFORMATEX *) m_pDevFmt, (PBYTE) m_pDevData->data,
											(ULONG) m_pDevData->length);
		}

	#if 0
		if (m_pRawData != m_pDevData)
		{
			if (m_pRawData)
				ZeroMemory (m_pRawData->data, m_pRawData->length);
		}

		if (m_pNetData != m_pRawData)
		{
			if (m_pNetData)
				ZeroMemory (m_pNetData->data, m_pNetData->length);
		}
	#endif
	}

	_SetState(MP_STATE_RESET);
	return DPR_SUCCESS;
}

/*
	Returns the max. peak-to-peak signal value scaled to
	the range [0,0xffff]
	Optional argument returns the peak value as well
*/
HRESULT AudioPacket::GetSignalStrength (  PDWORD pdwMaxStrength)
{
	return ComputePower(pdwMaxStrength, NULL);
}


HRESULT AudioPacket::ComputePower(PDWORD pdwMaxStrength, PWORD pwPeakStrength)
{
	BYTE bMax, bMin, *pb;
	short sMax, sMin, *ps;
	UINT cbSize;

	FX_ENTRY ("AdPckt::GetSignalStrength")

	if (((WAVEFORMATEX *) m_pDevFmt)->wFormatTag != WAVE_FORMAT_PCM) return FALSE;

	switch (((WAVEFORMATEX *) m_pDevFmt)->wBitsPerSample)
	{
	case 8: // unsigned char

		pb = (PBYTE) (m_pDevData->data);
		cbSize = m_pDevData->length;

		bMax = 0;
		bMin = 255;

		for ( ; cbSize; cbSize--, pb++)
		{
			if (*pb > bMax) bMax = *pb;
			if (*pb < bMin) bMin = *pb;
		}
	
		if (pdwMaxStrength)
		{
			// 2^9 <-- 2^16 / 2^7
			*pdwMaxStrength = ((DWORD) (bMax - bMin)) << 8;
		}
		if (pwPeakStrength)
		{
				*pwPeakStrength = (bMax > bMin) ? bMax : (WORD)(-bMin);
				*pwPeakStrength = (*pwPeakStrength) << 8;
		}
		break;

	case 16: // (signed) short

		ps = (short *) (m_pDevData->data);
		cbSize = m_pDevData->length;

		sMax = sMin = 0;

		for (cbSize >>= 1; cbSize; cbSize--, ps++)
		{
			if (*ps > sMax) sMax = *ps;
			if (*ps < sMin) sMin = *ps;
		}
	
		if (pdwMaxStrength)
		{
			*pdwMaxStrength = (DWORD) (sMax - sMin); // drop sign bit
		}
		if (pwPeakStrength)
		{
			*pwPeakStrength = ((WORD)(sMax) > (WORD)(-sMin)) ? sMax : (WORD)(-sMin);
		}
		break;

	default:
		if (pdwMaxStrength)
			*pdwMaxStrength = 0;
		if (pwPeakStrength)
			*pwPeakStrength = 0;	
		break;
	}
	//LOG((LOGMSG_SILENT,m_index,fResult));

	return DPR_SUCCESS;
}


HRESULT AudioPacket::Interpolate ( MediaPacket * pPrev, MediaPacket * pNext)
{
	HRESULT			hr = DPR_SUCCESS;
	DPHANDLE		hPrevDevAudio;
	NETBUF			*pPrevDevData;
	PVOID			pPrevDevHdr;
	WAVEFORMATEX	*pPrevpwfDevAudio;
	WAVEFORMATEX	*pNextpwfDevAudio;
	NETBUF			*pNextDevData;
	PVOID			pNextDevHdr;
	PCMSUB			PCMSub;

	FX_ENTRY ("AdPckt::Interpolate")

	// Make sure this really is an empty packet, that the previous packet is not an
	// empty packet and is being played back. It is not that important that we get
	// a handle to the next packet. If the next packet is decoded, then it's cool,
	// we can do a good job at interpolating between previous and next packet. If it's
	// not, well, too bad, we'll just work with the previous packet.
	if ((_GetState() != MP_STATE_RESET) || (pPrev->GetState() != MP_STATE_PLAYING_BACK))
	{
		// DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		hr = DPR_OUT_OF_SEQUENCE;
		goto MyExit;
	}

	// Get pointers to the member variables of interest in the previous and next
	// packet. Test the next packet to find out if we can use it in the interpolation
	// algorithm.
	pPrev->GetProp (MP_PROP_DEV_HANDLE, (PDWORD_PTR)&hPrevDevAudio);
	pPrev->GetProp (MP_PROP_DEV_DATA, (PDWORD_PTR)&pPrevDevData);
	pPrev->GetProp (MP_PROP_DEV_MEDIA_HDR, (PDWORD_PTR)&pPrevDevHdr);
	pPrev->GetProp (MP_PROP_DEV_MEDIA_FORMAT, (PDWORD_PTR)&pPrevpwfDevAudio);
	if (hPrevDevAudio && pPrevDevData && pPrevDevHdr && pPrevpwfDevAudio && (pPrevpwfDevAudio->wFormatTag == 1) && (pPrevpwfDevAudio->nSamplesPerSec == 8000) && (pPrevpwfDevAudio->wBitsPerSample == 16))
	{
		PCMSub.pwWaSuBf = (short *)m_pDevData->data;
		PCMSub.dwBfSize = ((WAVEHDR *) pPrevDevHdr)->dwBufferLength >> 1;
		PCMSub.dwSaPeSe = (DWORD)pPrevpwfDevAudio->nSamplesPerSec;
		PCMSub.dwBiPeSa = (DWORD)pPrevpwfDevAudio->wBitsPerSample;
		PCMSub.pwPrBf = (short *)pPrevDevData->data;

		pNext->GetProp (MP_PROP_DEV_DATA, (PDWORD_PTR)&pNextDevData);
		pNext->GetProp (MP_PROP_DEV_MEDIA_HDR, (PDWORD_PTR)&pNextDevHdr);
		pNext->GetProp (MP_PROP_DEV_MEDIA_FORMAT, (PDWORD_PTR)&pNextpwfDevAudio);

		// Do a bit of checking
		if ((pNext->GetState() == MP_STATE_DECODED) && pNextDevData && pNextDevHdr
			&& (PCMSub.dwBfSize == (((WAVEHDR *) pNextDevHdr)->dwBufferLength >> 1))
			&& pNextpwfDevAudio && (pNextpwfDevAudio->wFormatTag == 1) && (pNextpwfDevAudio->nSamplesPerSec == 8000)
			&& (pNextpwfDevAudio->wBitsPerSample == 16))
		{
			PCMSub.eTech = techPATT_MATCH_BOTH_SIGN_CC;
			//PCMSub.eTech = techDUPLICATE_PREV;
			PCMSub.pwNeBf = (short *)pNextDevData->data;
			PCMSub.fScal = TRUE;
		}
		else
		{
			PCMSub.eTech = techPATT_MATCH_PREV_SIGN_CC;
			//PCMSub.eTech = techDUPLICATE_PREV;
			PCMSub.pwNeBf = (short *)NULL;
			PCMSub.fScal = FALSE;
		}
		// Do the actual interpolation
		hr = PCMSubstitute(&PCMSub);
		((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed = ((WAVEHDR *) pPrevDevHdr)->dwBufferLength;
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: can't interpolate\r\n", _fx_));
		hr = DPR_INVALID_HANDLE;
		goto MyExit;
	}

	LOG((LOGMSG_INTERPOLATED,m_index));

MyExit:

	if (hr == DPR_SUCCESS)
		_SetState (MP_STATE_DECODED);
	else
		_SetState (MP_STATE_RESET);

	return hr;

}


HRESULT AudioPacket::Open ( UINT uType, DPHANDLE hdl )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Open")

	switch (uType)
	{
#ifdef PREP_HDR_PER_CONV
	case MP_TYPE_RECVSTRMCONV:
		m_hStrmConv = hdl;
		break;
#endif

	case MP_TYPE_STREAMCONV:
		if ((m_hStrmConv = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_ACM)
			{
				// initialize the header
				ZeroMemory (m_pStrmConvHdr, sizeof (ACMSTREAMHEADER));
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbStruct = sizeof (ACMSTREAMHEADER);
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->fdwStatus = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->dwUser = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->dwSrcUser = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLengthUsed = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->dwDstUser = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed = 0;
				if (m_dwState & DP_FLAG_SEND)
				{
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pRawData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pRawData->length;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pNetData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pNetData->length;
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pRawData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pRawData->length;
				}

				// prepare the header
				mmr = acmStreamPrepareHeader ((HACMSTREAM) m_hStrmConv,
											  (ACMSTREAMHEADER *) m_pStrmConvHdr, 0);
				if (mmr != MMSYSERR_NOERROR)
				{
					DEBUGMSG (ZONE_AP, ("%s: acmStreamPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
					hr = DPR_CANT_PREPARE_HEADER;
					goto MyExit;
				}

				m_fStrmPrepared = TRUE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		break;

	case MP_TYPE_DEV:
		if ((m_hDev = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_MMSYSTEM)
			{
				// initialize the header
				ZeroMemory (m_pDevHdr, sizeof (WAVEHDR));
				((WAVEHDR *) m_pDevHdr)->lpData = (char *) m_pDevData->data;
				((WAVEHDR *) m_pDevHdr)->dwBufferLength = m_pDevData->length;
				((WAVEHDR *) m_pDevHdr)->dwUser = (DWORD_PTR) this;
				((WAVEHDR *) m_pDevHdr)->dwFlags = 0L;
				((WAVEHDR *) m_pDevHdr)->dwLoops = 0L;

				if (m_dwState & DP_FLAG_SEND)
				{
					g_wavein_prepare++;

					// prepare the header
					mmr = waveInPrepareHeader ((HWAVEIN) m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: waveInPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_PREPARE_HEADER;
						goto MyExit;
					}
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_waveout_prepare++;

					// prepare header
					mmr = waveOutPrepareHeader ((HWAVEOUT) m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: waveOutPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_PREPARE_HEADER;
						goto MyExit;
					}
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = TRUE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}


HRESULT AudioPacket::Close ( UINT uType )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Close")

	switch (uType)
	{
#ifdef PREP_HDR_PER_CONV
	case MP_TYPE_RECVSTRMCONV:
#endif

	case MP_TYPE_STREAMCONV:
		if (m_hStrmConv)
		{
			if (m_dwState & DP_FLAG_ACM)
			{
				if (m_fStrmPrepared)
				{
					// unprepare the header
					if (m_dwState & DP_FLAG_RECV)
					{
						// Within acmStreamUnprepareHeader, there is a test that compares ((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbSrcLength
						// to ((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbPreparedSrcLength. If there isn't an exact match, MSACM32 will fail
						// this call. That test is Ok when the size of the input buffer is constant, but with the variable bit rate codecs,
						// we can receive packets with a size smaller than the max size we advertize when we prepare the buffers. In
						// order to make this call succeed, we fix up ((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbSrcLength before the call.
						((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbSrcLength = ((ACMSTREAMHEADER *)m_pStrmConvHdr)->dwReservedDriver[7];
					}
					mmr = acmStreamUnprepareHeader ((HACMSTREAM) m_hStrmConv,
													(ACMSTREAMHEADER *) m_pStrmConvHdr, 0);
					m_fStrmPrepared = FALSE; // don't care about any error

					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: acmStreamUnprepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_UNPREPARE_HEADER;
						goto MyExit;
					}
				}
			}

			if (uType == MP_TYPE_STREAMCONV) m_hStrmConv = NULL;
		}
		break;

	case MP_TYPE_DEV:
		if (m_hDev)
		{
			if (m_fDevPrepared)
			{
				if (m_dwState & DP_FLAG_SEND)
				{
					g_wavein_prepare--;
					mmr = waveInUnprepareHeader ((HWAVEIN) m_hDev,
												 (WAVEHDR *) m_pDevHdr,
												 sizeof (WAVEHDR));
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_waveout_prepare--;
					mmr = waveOutUnprepareHeader ((HWAVEOUT) m_hDev,
												  (WAVEHDR *) m_pDevHdr,
												  sizeof (WAVEHDR));
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = FALSE; // don't care about any error

				if (mmr != MMSYSERR_NOERROR)
				{
					DEBUGMSG (ZONE_AP, ("%s: Unprep hdr failed, mmr=0x%lX\r\n", _fx_, mmr));
					hr = DPR_CANT_UNPREPARE_HEADER;
					goto MyExit;
				}
			}

			m_hDev = NULL;
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}

void AudioPacket::WriteToFile (MMIODEST *pmmioDest)
{
	MMRESULT mmr;
	long dwDataLength;

	FX_ENTRY ("AdPckt::WriteToFile")

	AudioFile::WriteDestFile(pmmioDest,	m_pDevData->data, m_pDevData->length);
}

void AudioPacket::ReadFromFile (MMIOSRC *pmmioSrc)
{
	AudioFile::ReadSourceFile(pmmioSrc, (BYTE*)(((WAVEHDR*)m_pDevHdr)->lpData), ((WAVEHDR*)m_pDevHdr)->dwBytesRecorded);
}



BOOL AudioPacket::IsSameMediaFormat(PVOID fmt1,PVOID fmt2)
{
	return IsSameWaveFormat(fmt1,fmt2);
}

/*************************************************************************

  Function: PCMSubstitute(PCMSUB *)

  Purpose : Fills up missing buffer with wave data.

  Returns : HRESULT. DPR_SUCCESS if everything is cool, some error code
			otherwise.

  Params  : pPCMSub == Pointer to wave substitution structure

  Techniques:	* Straight replication of the previous packet
				* Straight replication of the next packet	
				* Replication of some part of the previous packet based on pattern matching
				* Replication of some part of the next packet based on pattern matching
				* Search window size need to be at least twice the size of the pattern!!!

  Comments: * The algorithm searches previous packets to find pPCMSub->dwBfSize
			samples that resemble the missing packet. To do so it uses as a
			template the M speech samples that came just before
			the missing packet. The algorithm scans a search window of
			duration N samples to find the M samples that best match the
			template. It then uses as a replacement packet the L samples
			that follow the best match.
			* Current code assumes all the packets (current, previous, and
			next) have the same size.
			* Current code only takes 8kHz data.
			* Current code only takes 16bit data.
			* Current code requires that the matching pattern be smaller than packet.

  History : Date      Reason
            04/16/95  Created - PhilF

*************************************************************************/
HRESULT AudioPacket::PCMSubstitute(PCMSUB *pPCMSub)
{
	DWORD	dwPaSize;						// Pattern size in samples
	DWORD	dwSeWiSize;						// Search window size in samples
	short	*pwPa = (short *)NULL;			// Pointer to the pattern
	short	*pwPaSav = (short *)NULL;		// Pointer to the pattern (copy)
	short	*pwPrSeWi = (short *)NULL;		// Pointer to the previous buffer (search window)
	short	*pwPrSeWiSav = (short *)NULL;	// Pointer to the previous buffer (search window) (copy)
	short	*pwNeSeWi = (short *)NULL;		// Pointer to the next buffer (search window)
	short	*pwNeSeWiSav = (short *)NULL;	// Pointer to the next buffer (search window) (copy)
	DWORD	i, j;							// Counters
	DWORD	dwPrCCPosMax;					// Sample position of the maximum cross-correlation between pattern and previous buffer
	DWORD	dwNeCCPosMax;					// Sample position of the maximum cross-correlation between pattern and previous buffer
	long	lPrCCMax;						// Max cross-correlation with previous buffer
	long	lNeCCMax;						// Max cross-correlation with next buffer
	long	lCCNum;							// Cross-correlation numerator
	DWORD	dwNuSaToCopy;					// Number of samples to copy in the missing buffer
	DWORD	dwNuSaCopied;					// Number of samples copied in the missing buffer
	long	alSign[2] = {1,-1};				// Sign array
	DWORD	dwPaAmp;						// Amplitude of the pattern
	DWORD	dwPaAmpExp;						// Expected amplitude of the pattern
	DWORD	dwNeSeWiAmp;					// Amplitude of a segment of the window following the current window
	DWORD	dwNumPaInSeWin;					// Number of patterns in search window
	DWORD	dwPrSeWiAmp;					// Amplitude of a segment of the current window
	BOOL	fPaInPr;						// Pattern is at the end of previous buffer of at the beginning of next buffer


	// Test input parameters
	if ((!pPCMSub) || (!pPCMSub->pwWaSuBf) || (pPCMSub->dwBiPeSa != 16) || (pPCMSub->dwSaPeSe != 8000))
		return DPR_INVALID_PARAMETER;

	// Check number of buffer available before and after missing packet
	// In case there are no packet before or after the missing packet,
	// just return; the packet will be filled with silence data later.
	if (!pPCMSub->pwPrBf && !pPCMSub->pwNeBf)
		return DPR_CANT_INTERPOLATE;

	// Just replicate previous packet
	if ((pPCMSub->eTech == techDUPLICATE_PREV) && pPCMSub->pwPrBf)
		CopyMemory(pPCMSub->pwWaSuBf, pPCMSub->pwPrBf, pPCMSub->dwBfSize << 1);
	else	// Just replicate next packet
		if ((pPCMSub->eTech == techDUPLICATE_NEXT) && pPCMSub->pwNeBf)
			CopyMemory(pPCMSub->pwWaSuBf, pPCMSub->pwNeBf, pPCMSub->dwBfSize << 1);
		else
			if ((pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC) || (pPCMSub->eTech == techPATT_MATCH_NEXT_SIGN_CC) || (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))
			{

				// We use a search window with a size double the size of the matching pattern
				// Experimentation will tell if this is a reasonable size or not
				// Experimentation will also tell if 4ms size of the matching pattern is Ok
				dwPaSize = pPCMSub->dwSaPeSe / 1000 * PATTERN_SIZE;
				if (dwPaSize > (pPCMSub->dwBfSize/2))
					dwPaSize = pPCMSub->dwBfSize/2;
				if (!dwPaSize)
					return DPR_CANT_INTERPOLATE;
#if 1
				// For now look up the whole previous frame
				dwSeWiSize = pPCMSub->dwBfSize;
#else
				dwSeWiSize = min(pPCMSub->dwBfSize, pPCMSub->dwSaPeSe / 1000 * SEARCH_SIZE);
#endif

				// In order to use pattern matching based techniques we need to have the
				// previous buffer when doing a backward search, the next buffer
				// when doing a forward search, the previous buffer and the next buffer
				// when doing a full search
				if (pPCMSub->pwPrBf && (pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC))
				{
					pwPa     = pwPaSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwPaSize;
					pwPrSeWi = pwPrSeWiSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwSeWiSize;
				}
				else
					if (pPCMSub->pwNeBf && (pPCMSub->eTech == techPATT_MATCH_NEXT_SIGN_CC))
					{
						pwPa   = pwPaSav = pPCMSub->pwNeBf;
						pwNeSeWi = pwNeSeWiSav = pPCMSub->pwNeBf;
					}
					else
						if (pPCMSub->pwPrBf && pPCMSub->pwNeBf && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))
						{
							// Use the pattern with the highest amplitude
							pwPa = pwPaSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwPaSize;
							pwNeSeWi = pPCMSub->pwNeBf;
							pwPrSeWi = pwPrSeWiSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwSeWiSize;
							fPaInPr = TRUE;
							for (i=0, dwPaAmp = 0, dwNeSeWiAmp = 0; i<dwPaSize; i++, pwPa++, pwNeSeWi++)
							{
								dwPaAmp		+= abs(*pwPa);
								dwNeSeWiAmp	+= abs(*pwNeSeWi);
							}
							if (dwNeSeWiAmp > dwPaAmp)
							{
								pwPaSav = pPCMSub->pwNeBf;
								fPaInPr = FALSE;
							}
							pwPa = pwPaSav;
							pwNeSeWi = pwNeSeWiSav = pPCMSub->pwNeBf + dwPaSize/2;
						}

				if (pwPa && (pwPrSeWi || pwNeSeWi))
				{
					// Look for best match in previous packet
					dwPrCCPosMax = 0; lPrCCMax = -((long)dwPaSize+1);
					if (pwPrSeWi && ((pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC) || ((fPaInPr) && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))))
					{
						// Look for the highest sign correlation between pattern and search window
						for (i=0; i<(dwSeWiSize-dwPaSize-dwPaSize/2+1); i++, pwPa = pwPaSav, pwPrSeWi = pwPrSeWiSav + i)
						{
							// Compute the sign correlation between pattern, and search window
							for (j=0, lCCNum = 0; j<dwPaSize; j++, pwPa++, pwPrSeWi++)
								lCCNum += alSign[(*pwPa ^ *pwPrSeWi)>> 15 & 1];

							// Save position and value of highest sign correlation
							if (lCCNum>lPrCCMax)
							{
								dwPrCCPosMax = i;
								lPrCCMax = lCCNum;
							}
						}
					}

					// Look for best match in next packet
					dwNeCCPosMax = dwPaSize/2; lNeCCMax = -((long)dwPaSize+1);
					if (pwNeSeWi && ((pPCMSub->eTech == techPATT_MATCH_NEXT_SIGN_CC) || ((!fPaInPr) && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))))
					{
						// Look for the highest sign correlation between pattern and search window
						for (i=dwPaSize/2; i<(dwSeWiSize-dwPaSize-dwPaSize/2+1); i++, pwPa = pwPaSav, pwNeSeWi = pwNeSeWiSav + i)
						{
							// Compute the sign correlation between pattern, and search window
							for (j=0, lCCNum = 0; j<dwPaSize; j++, pwPa++, pwNeSeWi++)
								lCCNum += alSign[(*pwPa ^ *pwNeSeWi)>> 15 & 1];

							// Save position and value of highest sign correlation
							if (lCCNum>lNeCCMax)
							{
								dwNeCCPosMax = i;
								lNeCCMax = lCCNum;
							}
						}
					}				

					if ((pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC) || (pwPrSeWiSav && fPaInPr && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC)))
					{
						// Copy matching samples from the previous frame in missing frame
						dwNuSaToCopy = pPCMSub->dwBfSize-dwPaSize-dwPrCCPosMax;
						CopyMemory(pPCMSub->pwWaSuBf, pwPrSeWiSav+dwPaSize+dwPrCCPosMax, dwNuSaToCopy << 1);

						// Do it until missing packet is full
						for (dwNuSaCopied = dwNuSaToCopy; dwNuSaCopied<pPCMSub->dwBfSize;dwNuSaCopied += dwNuSaToCopy)
						{
							dwNuSaToCopy = min(pPCMSub->dwBfSize-dwNuSaCopied, dwNuSaToCopy);
							CopyMemory(pPCMSub->pwWaSuBf + dwNuSaCopied, pwPrSeWiSav+dwPaSize+dwPrCCPosMax, dwNuSaToCopy << 1);
						}
					}
					else
					{
						// Copy matching samples from the next frame in missing frame
						dwNuSaToCopy = dwNeCCPosMax;
						CopyMemory(pPCMSub->pwWaSuBf + pPCMSub->dwBfSize - dwNuSaToCopy, pPCMSub->pwNeBf, dwNuSaToCopy << 1);

						// Do it until missing packet is full
						for (dwNuSaCopied = dwNuSaToCopy; dwNuSaCopied<pPCMSub->dwBfSize;dwNuSaCopied += dwNuSaToCopy)
						{
							dwNuSaToCopy = min(pPCMSub->dwBfSize-dwNuSaCopied, dwNuSaToCopy);
							CopyMemory(pPCMSub->pwWaSuBf + pPCMSub->dwBfSize - dwNuSaCopied - dwNuSaToCopy, pPCMSub->pwNeBf+dwNeCCPosMax-dwNuSaToCopy, dwNuSaToCopy << 1);
						}
					}

					if ((pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC) && pwNeSeWiSav && pwPrSeWiSav)
					{
						if (pPCMSub->fScal)
						{
							// Compute the amplitude of the pattern
							for (i=0, dwPrSeWiAmp = 0, dwNeSeWiAmp = 0, pwPrSeWi = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwPaSize, pwNeSeWi = pPCMSub->pwNeBf; i<dwPaSize; i++, pwPrSeWi++, pwNeSeWi++)
							{
								dwPrSeWiAmp	+= abs(*pwPrSeWi);
								dwNeSeWiAmp	+= abs(*pwNeSeWi);
							}
							// Scale data
							dwNumPaInSeWin = pPCMSub->dwBfSize/dwPaSize;
							for (i=0, pwPaSav = pPCMSub->pwWaSuBf; i<dwNumPaInSeWin; i++, pwPaSav += dwPaSize)
							{
								for (j=0, pwPa = pwPaSav, dwPaAmp = 0; j<dwPaSize; j++, pwPa++)
									dwPaAmp	+= abs(*pwPa);
								dwPaAmpExp = (dwPrSeWiAmp * (dwNumPaInSeWin - i) + dwNeSeWiAmp * (i + 1)) / (dwNumPaInSeWin + 1);
								for (;dwPaAmpExp > 65536; dwPaAmpExp >>= 1, dwPaAmp >>= 1)
									;
								if (dwPaAmp && (dwPaAmp != dwPaAmpExp))
									for (j=0, pwPa = pwPaSav; j<dwPaSize; j++, pwPa++)
										*pwPa = (short)((long)*pwPa * (long)dwPaAmpExp / (long)dwPaAmp);
							}
						}
					}
				}
			}
		else
			return DPR_CANT_INTERPOLATE;

	return DPR_SUCCESS;

}

// returns length of uncompressed PCM data in buffer
DWORD
AudioPacket::GetDevDataSamples()
{
	DWORD dwState = _GetState();
	DWORD cbData;
	
	if (dwState == MP_STATE_DECODED)
		// return actual length
		cbData = ((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed ;
	else if (m_pDevData)
		// return size of buffer
		cbData = m_pDevData->length;
	else
		cbData = 0;

	return cbData * 8/ ((WAVEFORMATEX *) m_pDevFmt)->wBitsPerSample;
	
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\bufpool.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    bufpool.h

Abstract:
	The class defined here manages a pool of fixed-size buffers that are typically used
	for network packets or sound buffers.

--*/
#ifndef _BUFPOOL_H_
#define _BUFPOOL_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

class BufferPool
{
private:

	BOOL	m_fInitialized;

	ULONG	m_cbSizeBuf;
	UINT	m_cBufAlloc;
	UINT	m_cBufFree;

	PVOID	m_pAlloc;

	PVOID	m_pBufFree;

	// intra-process/inter-thread synchronization
	CRITICAL_SECTION m_CritSect;

private:

	void _Construct ( void );
	void _Destruct ( void );

public:

	BufferPool ( void );
	~BufferPool ( void );

	HRESULT Initialize ( UINT uBuf, ULONG cbSizeBuf );
	PVOID GetBuffer ( void );
	void ReturnBuffer ( PVOID pBuf );
	ULONG GetMaxBufferSize ( void );
	void Release ( void );
};


#include <poppack.h> /* End byte packing */

#endif // _BUFPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\bufpool.cpp ===
#include "precomp.h"

///////////////////////////////////////////////////////
//
//  Public methods
//


BufferPool::BufferPool ( void )
{
	InitializeCriticalSection (&m_CritSect);

	_Construct ();
}


BufferPool::~BufferPool ( void )
{
	_Destruct ();

	DeleteCriticalSection (&m_CritSect);
}


HRESULT BufferPool::Initialize ( UINT uBuf, ULONG cbSizeBuf )
{
	HRESULT hr = DPR_SUCCESS;
	PBYTE *ppb;

	DEBUGMSG (ZONE_VERBOSE, ("BufPool::Initialize: enter.\r\n"));

	EnterCriticalSection (&m_CritSect);

	if (m_fInitialized)
	{
		hr = DPR_CANT_INITIALIZE_AGAIN;
		goto MyExit;
	}

	m_cBufFree = uBuf;
	m_cbSizeBuf = (cbSizeBuf + 3) & (~3);	// round up to 4

	m_pAlloc = m_pBufFree = LocalAlloc (LMEM_FIXED, m_cBufFree * m_cbSizeBuf);
	if (m_pAlloc == NULL)
	{
		hr = DPR_OUT_OF_MEMORY;
		goto MyExit;
	}

	ppb = (PBYTE *) m_pBufFree;
	while (-- uBuf)
	{
		ppb = (PBYTE *) (*ppb = (PBYTE) ppb + m_cbSizeBuf);
	}
	*ppb = NULL;

MyExit:

	if (hr == DPR_SUCCESS) m_fInitialized = TRUE;

	LeaveCriticalSection (&m_CritSect);

	DEBUGMSG (ZONE_VERBOSE, ("BufPool::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


PVOID BufferPool::GetBuffer ( void )
{
	PVOID p = NULL;

	EnterCriticalSection (&m_CritSect);

	if (m_fInitialized)
	{
		p = m_pBufFree;

		if (m_pBufFree)
		{
			m_pBufFree = (PVOID) *((PBYTE *) m_pBufFree);
		}
	}

	LeaveCriticalSection (&m_CritSect);

	return p;
}


void BufferPool::ReturnBuffer ( PVOID p )
{
	EnterCriticalSection (&m_CritSect);

	if (m_fInitialized)
	{
		*((PVOID *) p) = m_pBufFree;
		m_pBufFree = p;
	}

	LeaveCriticalSection (&m_CritSect);
}


ULONG BufferPool::GetMaxBufferSize ( void )
{
	return m_fInitialized ? m_cbSizeBuf : 0;
}


void BufferPool::Release ( void )
{
	_Destruct ();
}


///////////////////////////////////////////////////////
//
//  Private methods
//


void BufferPool::_Construct ( void )
{
	m_fInitialized = FALSE;

	m_cbSizeBuf = 0;
	m_cBufAlloc = 0;
	m_cBufFree = 0;

	m_pAlloc = NULL;

	m_pBufFree = NULL;
}


void BufferPool::_Destruct ( void )
{
	if (m_fInitialized)
	{
		if (m_pAlloc)
		{
			LocalFree (m_pAlloc);
			m_pAlloc = NULL;
		}

		m_fInitialized = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\agc.cpp ===
#include "precomp.h"
#include "mixer.h"
#include "agc.h"



// this should be moved to the mixer class - but right
// now we already have two instances of that class (one in NAC, the other in CONF)
static BOOL GetVolume(CMixerDevice *pMixer, DWORD *pdwVol)
{
	DWORD dwSub=0, dwMain=0;
	BOOL fSubAvail, fMainAvail;

	if (pMixer == NULL)
	{
		return FALSE;
	}

	fSubAvail = pMixer->GetSubVolume(&dwSub);
	fMainAvail = pMixer->GetMainVolume(&dwMain);

	if ((!fSubAvail) && (!fMainAvail))
	{
		*pdwVol = 0;
		return FALSE;
	}

	if ((fSubAvail) && (fMainAvail))
	{
		*pdwVol = ((dwSub + dwMain)/2);
	}

	else if (fSubAvail)
	{
		*pdwVol = dwSub;
	}

	else
	{
		*pdwVol = dwMain;
	}

	return TRUE;
}


// check to see if volume has changed since the last update of the mixer
// if so, we update m_dsLastVolumeSetting and return TRUE
BOOL AGC::HasVolumeChanged()
{
	DWORD dwVol;

	if (m_pMixer)
	{
		if (GetVolume(m_pMixer, &dwVol))
		{
			if (dwVol != m_dwLastVolumeSetting)
			{	
				m_dwLastVolumeSetting = dwVol;
				return TRUE;
			}
		}
	}
	return FALSE;
}


// raise the volume my the increment amount
inline BOOL AGC::RaiseVolume()
{
	DWORD dwVol;

	if (m_pMixer)
	{
		if (GetVolume(m_pMixer, &dwVol))
		{
			if (dwVol < (AGC_MAXVOL-AGC_INCREMENT))
			{
				dwVol += AGC_INCREMENT;
			}
			else
			{
				dwVol = AGC_MAXVOL;
			}
			m_pMixer->SetVolume(dwVol);
			GetVolume(m_pMixer, &m_dwLastVolumeSetting);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	return FALSE;
}

// lower the volume by the increment amount
inline BOOL AGC::LowerVolume()
{
	DWORD dwRet;

	if (m_pMixer)
	{
		if (GetVolume(m_pMixer, &dwRet))
		{
			if (dwRet > (AGC_INCREMENT+AGC_INCREMENT/2))
				m_dwLastVolumeSetting = dwRet - AGC_INCREMENT;
			else
				m_dwLastVolumeSetting = AGC_INCREMENT / 2;

			m_pMixer->SetVolume(m_dwLastVolumeSetting);
			GetVolume(m_pMixer, &m_dwLastVolumeSetting);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	return FALSE;
}



AGC::AGC(CMixerDevice *pMixer) :
m_cPeaks(0), m_wCurrentPeak(0),
m_dwCollectionTime(0),
m_pMixer(pMixer),
m_wThreshStrength(AGC_DEFAULT_THRESH),
m_dwLastVolumeSetting(0),
m_nLastUpdateResult(AGC_NOUPDATE)
{;}


// resets all stats inside the AGC control except the mixer object
void AGC::Reset()
{
	m_cPeaks = 0;
	m_wCurrentPeak = 0;
	m_dwCollectionTime = 0;
	m_wThreshStrength = AGC_DEFAULT_THRESH;
	m_dwLastVolumeSetting = 0;
	m_nLastUpdateResult = AGC_NOUPDATE;
}


// initialize the AGC control with an instance of a mixer object
// (you can also set the mixer in the constructor)
void AGC::SetMixer(CMixerDevice *pMixer)
{
	m_pMixer = pMixer;

	if (pMixer)
	{
		GetVolume(pMixer, &m_dwLastVolumeSetting);
		pMixer->SetVolume(m_dwLastVolumeSetting);
	}
}



// call this method for all recorded packets that
// are begin sent. mixer will get raised/lowered as
// appropriate. wPeakStrength can be any WORD that
// represents a volume amount, but is designed to be
// the highest sample value in a packet.
int AGC::Update(WORD wPeakStrength, DWORD dwLengthMS)
{
	int nIndex;
	DWORD dwTotal=0, dwMin=AGC_PEAKVOL, dwMax=0;
	DWORD dwAvg=0;
	BOOL nMaxPeaks=0;

	ASSERT (PEAKARRAYSIZE >= 2);


	if (wPeakStrength > m_wCurrentPeak)
	{
		m_wCurrentPeak = wPeakStrength;
	}

	m_dwCollectionTime += dwLengthMS;

	// have we exceeded one second worth of collections
	if (m_dwCollectionTime > 1000)
	{
		m_aPeaks[m_cPeaks++] = m_wCurrentPeak;
		m_dwCollectionTime = 0;
		m_wCurrentPeak = 0;
	}


	if (m_cPeaks >= 2)
	{
		// compute the average volume and number of clips that occurred
		for (nIndex = 0; nIndex < m_cPeaks; nIndex++)
		{
			dwTotal += m_aPeaks[nIndex];
			if (m_aPeaks[nIndex] < dwMin)
			{
				dwMin = m_aPeaks[nIndex];
			}
			else if (m_aPeaks[nIndex] > dwMax)
			{
				dwMax = m_aPeaks[nIndex];
			}
			if (m_aPeaks[nIndex] >= AGC_PEAKVOL)
			{
				nMaxPeaks++;
			}
		}

		dwAvg = (dwTotal-dwMin) / (PEAKARRAYSIZE-1);


		// check for clipping every 2 seconds
		if (((nMaxPeaks >= 1) && (dwAvg > AGC_HIGHVOL)) || (nMaxPeaks >=2))
		{
			// if the volume changed during (user manually adjusted sliders)
			// then allow those settings to stay in effect for this update
			if (HasVolumeChanged())
			{
				m_nLastUpdateResult = AGC_NOUPDATE;
			}
			else
			{
				m_cPeaks = 0;
				LowerVolume();
				m_nLastUpdateResult = AGC_UPDATE_LOWERVOL;
			}
			return m_nLastUpdateResult;
		}


		if (m_cPeaks >= PEAKARRAYSIZE)
		{
			m_cPeaks = 0;

			// if the volume changed during (user manually adjusted sliders)
			// then allow those settings to stay in effect for this update
			if (HasVolumeChanged())
			{
				m_nLastUpdateResult = AGC_NOUPDATE;
			}


			// should we actually raise the volume ?
			// if we just lowered the volume, don't raise it again
			// prevents the system from appearing "jerky"

			// if we just raised the volume, then don't raise immediately
			// again... let silence detection catch up.
			else if ((dwAvg < m_wThreshStrength) && (m_nLastUpdateResult == AGC_NOUPDATE))
			{
				RaiseVolume();
				m_nLastUpdateResult = AGC_UPDATE_RAISEVOL;
			}

			else
			{
				m_nLastUpdateResult = AGC_NOUPDATE;
			}

			return m_nLastUpdateResult;
		}

		return AGC_NOUPDATE;

	}

	// return NOUPDATE, but don't set m_nLastUpdateResult since
	// there was no decision made.
	return AGC_NOUPDATE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\devaudq.cpp ===
#include "precomp.h"

DevMediaQueue::DevMediaQueue ( void )
{
    m_uBegin = 0;
    m_uEnd = 0;
    m_uMaxNum = 0;
}


DevMediaQueue::~DevMediaQueue ( void )
{
    if (m_paPackets)
    {
        MemFree ((PVOID) m_paPackets);
        m_paPackets = NULL;
    }
}


void DevMediaQueue::SetSize ( UINT uMaxNum )
{
    m_uMaxNum = uMaxNum + 8;

	// Allocate zero-filled media packets
    m_paPackets = (MediaPacket **) MemAlloc (m_uMaxNum * sizeof (MediaPacket *));
}


void DevMediaQueue::Put ( MediaPacket * p )
{
    m_paPackets[m_uEnd++] = p;
    m_uEnd %= m_uMaxNum;
}


MediaPacket * DevMediaQueue::Get ( void )
{
    MediaPacket * p = NULL;

    if (m_uBegin != m_uEnd)
    {
        p = m_paPackets[m_uBegin];
		m_paPackets[m_uBegin++] = NULL;
        m_uBegin %= m_uMaxNum;
    }

    return p;
}


MediaPacket * DevMediaQueue::Peek ( void )
{
    return ((m_uBegin != m_uEnd) ? m_paPackets[m_uBegin] : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\counters.cpp ===
//  COUNTERS.CPP
//
//      Global performance counters for the nac
//
//  Created 13-Nov-96 [JonT]

#include "precomp.h"

// Global ICounterMgr. We just use as an CLSID_Counter class factory
ICounterMgr* g_pCtrMgr;

// Define all counters here
ICounter* g_pctrVideoSend;   
ICounter* g_pctrVideoReceive;
ICounter* g_pctrVideoSendBytes;
ICounter* g_pctrVideoReceiveBytes;
ICounter* g_pctrVideoSendLost;
ICounter* g_pctrVideoCPUuse;
ICounter* g_pctrVideoBWuse;

ICounter* g_pctrAudioSendBytes;
ICounter* g_pctrAudioReceiveBytes;
ICounter* g_pctrAudioSendLost;
ICounter* g_pctrAudioJBDelay;

// Define all reports here
IReport* g_prptCallParameters;   
IReport* g_prptSystemSettings;

// Put these in a .LIB file someday
const IID IID_ICounterMgr = {0x9CB7FE5B,0x3444,0x11D0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};
const CLSID CLSID_CounterMgr = {0x65DDC229,0x38FE,0x11d0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};

//  InitCountersAndReports
//      Initializes all counters and reports that we want to use

extern "C" BOOL WINAPI InitCountersAndReports(void)
{
    // Get a pointer to the statistics counter interface if it's around
    if (CoCreateInstance(CLSID_CounterMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICounterMgr, (void**)&g_pCtrMgr) != S_OK)
        return FALSE;

    // Create counters here
    DEFINE_COUNTER(&g_pctrVideoSend, "Video Send Frames Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrVideoReceive, "Video Receive Frames Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrVideoSendBytes, "Video Send Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrVideoReceiveBytes, "Video Receive Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrAudioSendBytes, "Audio Send Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrAudioReceiveBytes, "Audio Receive Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrAudioSendLost, "Audio Send Packets Lost", 0);
    DEFINE_COUNTER(&g_pctrVideoSendLost, "Video Send Packets Lost", 0);
    DEFINE_COUNTER(&g_pctrAudioJBDelay, "Audio Jitter Buffer Delay", 0);

    DEFINE_COUNTER(&g_pctrVideoCPUuse, "Video CPU use calculation", COUNTER_CLEAR);
    DEFINE_COUNTER(&g_pctrVideoBWuse, "Video Bit rate calculation", COUNTER_CLEAR);

    // Create reports here
    DEFINE_REPORT(&g_prptCallParameters, "Call Parameters", 0);
    DEFINE_REPORT(&g_prptSystemSettings, "System Settings", 0);

	// Create call parameters report entries here
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Format", REP_SEND_AUDIO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Sampling Rate (Hz)", REP_SEND_AUDIO_SAMPLING);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Bitrate (w/o network overhead - bps)", REP_SEND_AUDIO_BITRATE);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Packetization (ms / packet)", REP_SEND_AUDIO_PACKET);

	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Format", REP_RECV_AUDIO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Sampling Rate (Hz)", REP_RECV_AUDIO_SAMPLING);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Bitrate (w/o network overhead - bps)", REP_RECV_AUDIO_BITRATE);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Packetization (ms / packet)", REP_RECV_AUDIO_PACKET);

	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Send Format", REP_SEND_VIDEO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Send Max Frame Rate (negotiated - fps)", REP_SEND_VIDEO_MAXFPS);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Send Max Bitrate (negotiated - bps)", REP_SEND_VIDEO_BITRATE);

	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Recv Format", REP_RECV_VIDEO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Recv Max Frame Rate (negotiated - fps)", REP_RECV_VIDEO_MAXFPS);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Recv Max Bitrate (negotiated - bps)", REP_RECV_VIDEO_BITRATE);

	// Create system settings report entries here
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Bandwidth (user setting)", REP_SYS_BANDWIDTH);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Subsystem", REP_SYS_AUDIO_DSOUND);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Record", REP_SYS_AUDIO_RECORD);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Playback", REP_SYS_AUDIO_PLAYBACK);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Duplex Type", REP_SYS_AUDIO_DUPLEX);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Capture", REP_SYS_VIDEO_DEVICE);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Device Image Size", REP_DEVICE_IMAGE_SIZE);

	// Provide defaults for some entries
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 4, REP_SYS_BANDWIDTH);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_DSOUND);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_RECORD);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_PLAYBACK);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_VIDEO_DEVICE);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_DEVICE_IMAGE_SIZE);

	UPDATE_COUNTER(g_pctrAudioJBDelay, 0);
	UPDATE_COUNTER(g_pctrAudioSendLost,0);
	UPDATE_COUNTER(g_pctrVideoSendLost,0);
	INIT_COUNTER_MAX(g_pctrAudioJBDelay, 500); // jitter delay above 500ms is bad


    return TRUE;
}


//  DoneCountersAndReports
//      Cleans up after all counters and reports we wanted to use

extern "C" void WINAPI DoneCountersAndReports(void)
{
    ICounterMgr* pctrmgr;

    // Release the statistics stuff if it's around
    if (!g_pCtrMgr)
        return;

    // Zero out the interface pointer so we don't accidentally use it elsewhere
    pctrmgr = g_pCtrMgr;
    g_pCtrMgr = NULL;

    // Remove counters here
    DELETE_COUNTER(&g_pctrVideoSend);
    DELETE_COUNTER(&g_pctrVideoReceive);
    DELETE_COUNTER(&g_pctrVideoSendBytes);
    DELETE_COUNTER(&g_pctrVideoReceiveBytes);
    DELETE_COUNTER(&g_pctrVideoSendLost);

    DELETE_COUNTER(&g_pctrAudioSendBytes);
    DELETE_COUNTER(&g_pctrAudioReceiveBytes);
    DELETE_COUNTER(&g_pctrAudioSendLost);

    DELETE_COUNTER(&g_pctrVideoCPUuse);
    DELETE_COUNTER(&g_pctrVideoBWuse);

    DELETE_COUNTER(&g_pctrAudioJBDelay);
	
    // Remove reports here
    DELETE_REPORT(&g_prptCallParameters);
    DELETE_REPORT(&g_prptSystemSettings);

    // Done with ICounterMgr
    pctrmgr->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\devaudq.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    devaudq.h

Abstract:
	Simple circular queue of MediaPacket structures used to keep track of audio buffers
	while they're being recorded/played.

--*/
#ifndef _DEVAUDQ_H_
#define _DEVAUDQ_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

class DevMediaQueue
{
private:

	UINT			m_uBegin;
	UINT			m_uEnd;

	UINT			m_uMaxNum;
	MediaPacket		**m_paPackets;

public:

	DevMediaQueue ( void );
	~DevMediaQueue ( void );

	void SetSize ( UINT uMaxNum );
	void Put ( MediaPacket * p );
	MediaPacket * Get ( void );
	MediaPacket * Peek ( void );
};

#include <poppack.h> /* End byte packing */

#endif // _DEVAUDQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\datapump.cpp ===
/*
	DATAPUMP.C
*/

#include "precomp.h"
#include "confreg.h"
#include "mixer.h"
#include "dscStream.h"

extern UINT g_MinDSEmulAudioDelayMs; // minimum millisecs of introduced playback delay (DirectSound on emulated drivers)
extern UINT g_MinWaveAudioDelayMs;	 // minimum millisecs of introduced playback delay (Wave)
extern UINT g_MaxAudioDelayMs;	// maximum milliesecs of introduced playback delay
extern UINT g_AudioPacketDurationMs;	// preferred packet duration

extern int g_wavein_prepare, g_waveout_prepare;
extern int g_videoin_prepare, g_videoout_prepare;

#define RSVP_KEY	TEXT("RSVP")

HANDLE g_hEventHalfDuplex = NULL;

HWND DataPump::m_hAppWnd = NULL;
HINSTANCE DataPump::m_hAppInst = NULL;


HRESULT WINAPI CreateStreamProvider(IMediaChannelBuilder **lplpSP)
{
	DataPump * pDataPump;
	if(!lplpSP)
		return DPR_INVALID_PARAMETER;
		
    DBG_SAVE_FILE_LINE
	pDataPump = new DataPump;	
	if(NULL == pDataPump)
		return	DPR_OUT_OF_MEMORY;
		
	// the refcount of DataPump is 1.  Don't call pDataPump->QueryInterface(), 
	// just do what QueryInterface() would do except don't increment refcount
	*lplpSP = (IMediaChannelBuilder *)pDataPump; 
	return hrSuccess;
}


DataPump::DataPump(void)
:m_uRef(1)
{
	ClearStruct( &m_Audio );
	ClearStruct( &m_Video );
	InitializeCriticalSection(&m_crs);

    // Create performance counters
    InitCountersAndReports();
}

DataPump::~DataPump(void)
{
	ReleaseResources();

	WSACleanup();
	DeleteCriticalSection(&m_crs);

    // We're done with performance counters
    DoneCountersAndReports();
}

HRESULT __stdcall DataPump::Initialize(HWND hWnd, HINSTANCE hInst)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	FX_ENTRY ("DP::Init")
	WSADATA WSAData;
	int status;
	BOOL fDisableWS2;
	UINT uMinDelay;
	TCHAR *szKey = NACOBJECT_KEY TEXT("\\") RSVP_KEY;
	RegEntry reRSVP(szKey, HKEY_LOCAL_MACHINE, FALSE);
	
	if((NULL == hWnd) || (NULL == hInst))
		goto InitError;
		
	m_hAppInst = hInst; 
	m_hAppWnd = hWnd;

	status = WSAStartup(MAKEWORD(1,1), &WSAData);
	if(status !=0)
	{
		ERRORMESSAGE(("CNac::Init:WSAStartup failed\r\n"));
		goto InitError;
	}

		// Introduce scope to allow creation of object after goto statements
	{
	
		// get settings from registry  
		RegEntry reNac(szRegInternetPhone TEXT("\\") szRegInternetPhoneNac, 
						HKEY_LOCAL_MACHINE,
						FALSE,
						KEY_READ);

		g_MaxAudioDelayMs = reNac.GetNumberIniStyle(TEXT ("MaxAudioDelayMs"), g_MaxAudioDelayMs);

		uMinDelay = reNac.GetNumberIniStyle(TEXT ("MinAudioDelayMs"), 0);

		if (uMinDelay != 0)
		{
			g_MinWaveAudioDelayMs = uMinDelay;
			g_MinDSEmulAudioDelayMs = uMinDelay;
		}

		fDisableWS2 = reNac.GetNumberIniStyle(TEXT ("DisableWinsock2"), 0);

	}
#ifdef OLDSTUFF
	// to be safe, only try loading WS2_32 if WSOCK32 is passing
	// thru to it. Once we make sure that we link to the same DLL for all
	// Winsock calls to a socket, this check can possibly be removed.
	if (LOBYTE(WSAData.wHighVersion) >= 2 && !fDisableWS2)
		TryLoadWinsock2();
#endif	
	// Initialize data (should be in constructor)

	g_hEventHalfDuplex = CreateEvent (NULL, FALSE, TRUE, __TEXT ("AVC:HalfDuplex"));
	if (g_hEventHalfDuplex == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: CreateEvent failed, LastErr=%lu\r\n", _fx_, GetLastError ()));
		hr = DPR_CANT_CREATE_EVENT;
		return hr;
	}

	// Initialize QoS. If it fails, that's Ok, we'll do without it.
	// No need to set the resource ourselves, this now done by the UI
	hr = CreateQoS (NULL, IID_IQoS, (void **)&m_pIQoS);
	if (hr != DPR_SUCCESS)
		m_pIQoS = (LPIQOS)NULL;

	m_bDisableRSVP = reRSVP.GetNumber("DisableRSVP", FALSE);


	LogInit();	// Initialize log

    //No receive channels yet
    m_nReceivers=0;

	// IVideoDevice initialize
	m_uVideoCaptureId = -1;  // (VIDEO_MAPPER)

	// IAudioDevice initialize
	m_uWaveInID = WAVE_MAPPER;
	m_uWaveOutID = WAVE_MAPPER;
	m_bFullDuplex = FALSE;
	m_uSilenceLevel = 1000;  // automatic silence detection
	m_bAutoMix = FALSE;
	m_bDirectSound = FALSE;


	return DPR_SUCCESS;

InitError:
	ERRORMESSAGE( ("DataPump::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


STDMETHODIMP
DataPump::CreateMediaChannel( UINT flags, IMediaChannel **ppIMC)
{
	IUnknown *pUnkOuter = NULL;
	IMediaChannel *pStream = NULL;
	HRESULT hr = E_FAIL;

	// try to be consistant about which parent classes we cast to

	*ppIMC = NULL;

	
	if (flags & MCF_AUDIO)
	{
		if ((flags & MCF_SEND) && !m_Audio.pSendStream)
		{
			if (m_bDirectSound && (DSC_Manager::Initialize() == S_OK))
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(SendMediaStream*)new SendDSCStream;
            }
			else
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(SendMediaStream*)new SendAudioStream;
            }

		}
		else if ((flags & MCF_RECV) && !m_Audio.pRecvStream)
		{
			if (m_bDirectSound && (DirectSoundMgr::Initialize() == S_OK))
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(RecvMediaStream*)new RecvDSAudioStream;
            }
			else
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(RecvMediaStream*)new RecvAudioStream;
            }
		}
	}
	else if (flags  & MCF_VIDEO)
	{
		if ((flags & MCF_SEND) && !m_Video.pSendStream)
		{
            DBG_SAVE_FILE_LINE
			pStream =  (IMediaChannel*)(SendMediaStream*) new SendVideoStream;
		}
		else if ((flags & MCF_RECV) && !m_Video.pRecvStream)
		{
            DBG_SAVE_FILE_LINE
			pStream = (IMediaChannel*)(RecvMediaStream*) new RecvVideoStream;
		}
	}
	else
		hr = E_INVALIDARG;

	if (pStream != NULL) {
		// need to inc the refCount of the object
		pStream->AddRef();

		hr = (flags & MCF_SEND) ?
				((SendMediaStream *)pStream)->Initialize( this)
				: ((RecvMediaStream *)pStream)->Initialize(this);

		if (hr == S_OK)
		{
			hr = pStream->QueryInterface(IID_IMediaChannel, (void **)ppIMC);
		}
		if (hr == S_OK)
		{
			AddMediaChannel(flags, pStream);
		}


		// calling to the IVideoDevice and IAudioDevice methods
		// prior to creating the corresponding channel object
		// require when they get created

		// video only needs it's device ID set
		if ((flags & MCF_SEND) && (flags & MCF_VIDEO))
		{
			SetCurrCapDevID(m_uVideoCaptureId);
		}

		// audio streams need several properties set
		if (flags & MCF_AUDIO)
		{
			if (flags & MCF_SEND)
			{
				SetSilenceLevel(m_uSilenceLevel);
				SetAutoMix(m_bAutoMix);
				SetRecordID(m_uWaveInID);
			}
			else if (flags & MCF_RECV)
			{
				SetPlaybackID(m_uWaveOutID);
			}
			SetStreamDuplex(pStream, m_bFullDuplex);
		}

		// to avoid a circular ref-count,
		// dont keep a hard reference to MediaChannel objects 
		// MediaChannel will call RemoveMediaChannel before it goes away..
		pStream->Release();
		pStream = NULL;
	}
	return hr;
}


STDMETHODIMP DataPump::SetStreamEventObj(IStreamEventNotify *pNotify)
{

	EnterCriticalSection(&m_crs);

	if (m_pTEP)
	{
		delete m_pTEP;
		m_pTEP = NULL;
	}

	if (pNotify)
	{
        DBG_SAVE_FILE_LINE
		m_pTEP = new ThreadEventProxy(pNotify, m_hAppInst);
	}

	LeaveCriticalSection(&m_crs);

	return S_OK;

}


// this function gets called by the stream threads when an event occurs
STDMETHODIMP DataPump::StreamEvent(UINT uDirection, UINT uMediaType, 
								   UINT uEventType, UINT uSubCode)
{
	BOOL bRet = FALSE;

	EnterCriticalSection(&m_crs);
	
	if (m_pTEP)
	{
		bRet = m_pTEP->ThreadEvent(uDirection, uMediaType, uEventType, uSubCode);
	}

	LeaveCriticalSection(&m_crs);

	return bRet ? DPR_INVALID_PARAMETER : DPR_SUCCESS;
}


void
DataPump::AddMediaChannel(UINT flags, IMediaChannel *pMediaChannel)
{
	EnterCriticalSection(&m_crs);
	if (flags & MCF_SEND)
	{
		SendMediaStream *pS = static_cast<SendMediaStream *> (pMediaChannel);
		if (flags & MCF_AUDIO) 
			m_Audio.pSendStream = pS;
		else if (flags & MCF_VIDEO)
			m_Video.pSendStream = pS;
	}
	else if (flags & MCF_RECV)
	{
		RecvMediaStream *pR = static_cast<RecvMediaStream *> (pMediaChannel);
		if (flags & MCF_AUDIO) 
			m_Audio.pRecvStream = pR;
		else if (flags & MCF_VIDEO)
			m_Video.pRecvStream = pR;
	}
	LeaveCriticalSection(&m_crs);
}

void
DataPump::RemoveMediaChannel(UINT flags, IMediaChannel *pMediaChannel)
{
	EnterCriticalSection(&m_crs);
	if (flags & MCF_SEND)
	{
		if (flags & MCF_AUDIO)
		{
			ASSERT(pMediaChannel == m_Audio.pSendStream);
			if (pMediaChannel == m_Audio.pSendStream)
				m_Audio.pSendStream = NULL;
		}
		else if (flags & MCF_VIDEO)
		{
			ASSERT(pMediaChannel == m_Video.pSendStream);
			m_Video.pSendStream = NULL;
		}
	}
	else if (flags & MCF_RECV)
	{
		if (flags & MCF_AUDIO) 
		{
			ASSERT(pMediaChannel == m_Audio.pRecvStream);
			m_Audio.pRecvStream = NULL;
		}
		else if (flags & MCF_VIDEO)
		{
			ASSERT(pMediaChannel == m_Video.pRecvStream);
			m_Video.pRecvStream = NULL;
		}
	}
	LeaveCriticalSection(&m_crs);
	
}

// called by Record Thread and Receive Thread, usually to get the
// opposite channel
HRESULT DataPump::GetMediaChannelInterface( UINT flags, IMediaChannel **ppI)
{
//	extern IID IID_IMediaChannel;
	
	IMediaChannel *pStream = NULL;

	HRESULT hr;
	EnterCriticalSection(&m_crs);
	if (flags & MCF_AUDIO) {
		if (flags & MCF_SEND) {
			pStream =  m_Audio.pSendStream;
		} else if (flags & MCF_RECV) {
			pStream =  m_Audio.pRecvStream;
		}
	}
	else if (flags & MCF_VIDEO) {
		if (flags & MCF_SEND) {
			pStream =  m_Video.pSendStream;
		} else if (flags & MCF_RECV) {
			pStream =  m_Video.pRecvStream;
		}
	} else
		hr = DPR_INVALID_PARAMETER;
	if (pStream) {
			// need to inc the refCount of the object
			hr = (pStream)->QueryInterface(IID_IMediaChannel, (PVOID *)ppI);
	} else
		hr = E_NOINTERFACE;
	LeaveCriticalSection(&m_crs);
	return hr;
}


DWORD __stdcall StartDPRecvThread(PVOID pVoid)
{
	DataPump *pDP = (DataPump*)pVoid;
	return pDP->CommonWS2RecvThread();
}



STDMETHODIMP DataPump::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = NULL;
	if(iid == IID_IUnknown)// satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if(iid == IID_IMediaChannelBuilder)
	{
		*ppvObject = (IMediaChannelBuilder *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if (iid == IID_IVideoDevice)
	{
		*ppvObject = (IVideoDevice *)this;
		hr = hrSuccess;
		AddRef();
	}

	else if (iid == IID_IAudioDevice)
	{
		*ppvObject = (IAudioDevice*)this;
		hr = hrSuccess;
		AddRef();
	}
	
	return (hr);
}
ULONG DataPump::AddRef()
{
	m_uRef++;
	return m_uRef;
}

ULONG DataPump::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		m_hAppWnd = NULL;
		m_hAppInst = NULL;
		delete this;
		return 0;
	}
	return m_uRef;
}


void
DataPump::ReleaseResources()
{
	FX_ENTRY ("DP::ReleaseResources")

#ifdef DEBUG
	if (m_Audio.pSendStream)
		ERRORMESSAGE(("%s: Audio Send stream still around => Ref count LEAK!\n", _fx_));
	if (m_Audio.pRecvStream)
		ERRORMESSAGE(("%s: Audio Recv stream still around => Ref count LEAK!\n", _fx_));
	if (m_Video.pSendStream)
		ERRORMESSAGE(("%s: Video Send stream still around => Ref count LEAK!\n", _fx_));
	if (m_Video.pRecvStream)
		ERRORMESSAGE(("%s: Video Recv stream still around => Ref count LEAK!\n", _fx_));
#endif

	// close debug log
	LogClose();

	// Free QoS resources
	if (m_pIQoS)
	{
		m_pIQoS->Release();
		m_pIQoS = (LPIQOS)NULL;
	}

	// Close the receive and transmit streams
	if (g_hEventHalfDuplex)
	{
		CloseHandle (g_hEventHalfDuplex);
		g_hEventHalfDuplex = NULL;
	}

}


HRESULT DataPump::SetStreamDuplex(IMediaChannel *pStream, BOOL bFullDuplex)
{
	BOOL fOn = (pStream->GetState() == MSSTATE_STARTED);
	BOOL bStreamFullDuplex;
	UINT uSize = sizeof(BOOL);

	pStream->GetProperty(PROP_DUPLEX_TYPE, &bStreamFullDuplex, &uSize);

	if (bStreamFullDuplex != bFullDuplex)
	{
		if (fOn)
		{
			pStream->Stop();
		}

		pStream->SetProperty(DP_PROP_DUPLEX_TYPE, &bFullDuplex, sizeof(BOOL));

		if (fOn)
		{
			pStream->Start();
		}
	}
	return S_OK;
}


HRESULT __stdcall DataPump::SetDuplex(BOOL bFullDuplex)
{
	IMediaChannel *pS = m_Audio.pSendStream;
	IMediaChannel *pR = m_Audio.pRecvStream;
	IMediaChannel *pStream;
	BOOL fPlayOn = FALSE;
    BOOL fRecOn = FALSE;
	UINT uSize;
	BOOL bRecDuplex, bPlayDuplex;

	m_bFullDuplex = bFullDuplex ? TRUE : FALSE;

	UPDATE_REPORT_ENTRY(g_prptSystemSettings, (m_bFullDuplex) ? 1 : 0, REP_SYS_AUDIO_DUPLEX);
	RETAILMSG(("NAC: Audio Duplex Type: %s",(m_bFullDuplex) ? "Full Duplex" : "Half Duplex"));


	// no streams ?  No problem.
	if ((pS == NULL) && (pR == NULL))
	{
		return S_OK;
	}


	// only one stream
	if ((pS || pR) && !(pS && pR))
	{
		if (pS)
			pStream = pS;
		else
			pStream = pR;

		return SetStreamDuplex(pStream, m_bFullDuplex);
	}


	// assert - pS && pR

	// both streams exist

	// try to avoid the whole start/stop sequence if the duplex
	// is the same
	uSize=sizeof(BOOL);
	pR->GetProperty(PROP_DUPLEX_TYPE, &bRecDuplex, &uSize);
	uSize=sizeof(BOOL);
	pS->GetProperty(PROP_DUPLEX_TYPE, &bPlayDuplex, &uSize);

	if ( (bPlayDuplex == m_bFullDuplex) &&
	     (bRecDuplex == m_bFullDuplex))
	{
		return S_OK;
	}


	// save the old thread flags
	fPlayOn = (pR->GetState() == MSSTATE_STARTED);
	fRecOn = (pS->GetState() == MSSTATE_STARTED);

	// Ensure the record and playback threads are stopped
	pR->Stop();
	pS->Stop();

	SetStreamDuplex(pR, m_bFullDuplex);
	SetStreamDuplex(pS, m_bFullDuplex);

	// Resume the record/playback
	// Try to let play start before record - DirectS and SB16 prefer that!
	if (fPlayOn)
	{
		pR->Start();
	}

	if (fRecOn)
	{
		pS->Start();
	}

	return DPR_SUCCESS;
}

#define LONGTIME	60000	// 60 seconds

// utility function to synchronously communicate a
// a state change to the recv thread
HRESULT DataPump::RecvThreadMessage(UINT msg, RecvMediaStream *pMS)
{
	BOOL fSignaled;
	DWORD dwWaitStatus;
	HANDLE handle;
	// Unfortunately cant use PostThreadMessage to signal the thread
	// because it doesnt have a message loop
	m_pCurRecvStream = pMS;
	m_CurRecvMsg = msg;
	fSignaled = SetEvent(m_hRecvThreadSignalEvent);
    	
	
	if (fSignaled) {

		handle =  (msg == MSG_EXIT_RECV ? m_hRecvThread : m_hRecvThreadAckEvent);
    	dwWaitStatus = WaitForSingleObject(handle, LONGTIME);
    	ASSERT(dwWaitStatus == WAIT_OBJECT_0);
    	if (dwWaitStatus != WAIT_OBJECT_0)
    		return GetLastError();
    } else
    	return GetLastError();
    
    return S_OK;
}

// start receiving on this stream
// will create the receive thread if necessary.
HRESULT
DataPump::StartReceiving(RecvMediaStream *pMS)
{
	DWORD dwWaitStatus;
	FX_ENTRY("DP::StartReceiving")
	// one more stream
	m_nReceivers++;	
	if (!m_hRecvThread) {
		ASSERT(m_nReceivers==1);
		ASSERT(!m_hRecvThreadAckEvent);
    	//Use this for thread event notifications. I.e. Video started/stopped, audio stopped, et al.
    	//m_hRecvThreadChangeEvent=CreateEvent (NULL,FALSE,FALSE,NULL);
	   	//create the stopping sync event
	   	m_hRecvThreadAckEvent=CreateEvent (NULL,FALSE,FALSE,NULL);
		m_hRecvThreadSignalEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	   	
	    m_hRecvThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)StartDPRecvThread,(PVOID)this,0,&m_RecvThId);
		DEBUGMSG(ZONE_DP,("%s: RecvThread Id=%x\n",_fx_,m_RecvThId));
		// thread will signal event soon as its message loop is ready
    	dwWaitStatus = WaitForSingleObject(m_hRecvThreadAckEvent, LONGTIME);
    	ASSERT(dwWaitStatus == WAIT_OBJECT_0);
	}
    
	//Tell the recv Thread to start receiving on this MediaStream
	return RecvThreadMessage(MSG_START_RECV,pMS);	
    
    
}

// Stop receiving on the stream
// will stop the receive thread if necessary
HRESULT
DataPump::StopReceiving(RecvMediaStream *pMS)
{
	HANDLE rgh[2];
	ASSERT(m_nReceivers > 0);
	ASSERT(m_hRecvThread);
	if (m_nReceivers > 0)
		m_nReceivers--;

	RecvThreadMessage(MSG_STOP_RECV, pMS);
	
	if (!m_nReceivers && m_hRecvThread) {
		// kill the receive thread
		RecvThreadMessage(MSG_EXIT_RECV,NULL);
		
		CloseHandle(m_hRecvThread);
		CloseHandle(m_hRecvThreadAckEvent);
		m_hRecvThread = NULL;
		m_hRecvThreadAckEvent = NULL;
		if (m_hRecvThreadSignalEvent) {
			CloseHandle(m_hRecvThreadSignalEvent);
			m_hRecvThreadSignalEvent = NULL;
		}
	}
	return S_OK;
}


//
// IVideoDevice Methods
//

// Capture device methods

// Gets the number of enabled capture devices
// Returns -1L on error
HRESULT __stdcall DataPump::GetNumCapDev()
{
	FINDCAPTUREDEVICE fcd;

	// scan for broken or unplugged devices
	FindFirstCaptureDevice(&fcd, NULL);

	return (GetNumCaptureDevices());
}

// Gets the max size of the captuire device name
// Returns -1L on error
HRESULT __stdcall DataPump::GetMaxCapDevNameLen()
{
	return (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION);
}

// Enum list of enabled capture devices
// Fills up 1st buffer with device IDs, 2nd buffer with device names
// Third parameter is the max number of devices to enum
// Returns number of devices enum-ed
HRESULT __stdcall DataPump::EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev)
{
	FINDCAPTUREDEVICE fcd;
	DWORD dwNumCapDevFound = 0;

	fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
	if (FindFirstCaptureDevice(&fcd, NULL))
	{
		do
		{
			pdwCapDevIDs[dwNumCapDevFound] =  fcd.nDeviceIndex;

			// Build device name out of the capture device strings
			if (fcd.szDeviceDescription && fcd.szDeviceDescription[0] != '\0')
				lstrcpy(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), fcd.szDeviceDescription);
			else
				lstrcpy(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), fcd.szDeviceName);
			if (fcd.szDeviceVersion && fcd.szDeviceVersion[0] != '\0')
			{
				lstrcat(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), ", ");
				lstrcat(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), fcd.szDeviceVersion);
			}
			dwNumCapDevFound++;
		} while ((dwNumCapDevFound < dwNumCapDev) && FindNextCaptureDevice(&fcd));
	}

	return (dwNumCapDevFound);
}

HRESULT __stdcall DataPump::GetCurrCapDevID()
{
	UINT uCapID;
	UINT uSize = sizeof(UINT);

	// even though we know the value of the last call
	// to SetCurrCapDevID, the stream may have resulted in using
	// wave_mapper (-1).  We want to be able to return -1, if this
	// is the case.  However, the channel objects don't do this yet.
	// (they still return the same value as m_uVideoCaptureId)

	if (m_Video.pSendStream)
	{
		m_Video.pSendStream->GetProperty(PROP_CAPTURE_DEVICE, &uCapID, &uSize);
#ifdef DEBUG
		if (uCapID != m_uVideoCaptureId)
		{
			DEBUGMSG(ZONE_DP,("Video capture stream had to revert to MAPPER or some other device"));
		}
#endif
		return uCapID;
	}

	return m_uVideoCaptureId;

}


HRESULT __stdcall DataPump::SetCurrCapDevID(int nCapDevID)
{
	m_uVideoCaptureId = (UINT)nCapDevID;

	if (m_Video.pSendStream)
	{
		m_Video.pSendStream->SetProperty(PROP_CAPTURE_DEVICE, &m_uVideoCaptureId, sizeof(m_uVideoCaptureId));
	}
	return S_OK;
}




// IAudioDevice methods
HRESULT __stdcall DataPump::GetRecordID(UINT *puWaveDevID)
{
	*puWaveDevID = m_uWaveInID;
	return S_OK;
}

HRESULT __stdcall DataPump::SetRecordID(UINT uWaveDevID)
{
	m_uWaveInID = uWaveDevID;

	if (m_Audio.pSendStream)
	{
		m_Audio.pSendStream->SetProperty(PROP_RECORD_DEVICE, &m_uWaveInID, sizeof(m_uWaveInID));
	}
	return S_OK;

}


HRESULT __stdcall DataPump::GetPlaybackID(UINT *puWaveDevID)
{
	// like video, the audio device may have resorted to using
	// WAVE_MAPPER.  We'd like to be able to detect that

	*puWaveDevID = m_uWaveOutID;
	return S_OK;
}

HRESULT __stdcall DataPump::SetPlaybackID(UINT uWaveDevID)
{
	m_uWaveOutID = uWaveDevID;

	if (m_Audio.pRecvStream)
	{
		m_Audio.pRecvStream->SetProperty(PROP_PLAYBACK_DEVICE, &m_uWaveOutID, sizeof(m_uWaveOutID));
	}
	return S_OK;

}

HRESULT __stdcall DataPump::GetSilenceLevel(UINT *puLevel)
{
	*puLevel = m_uSilenceLevel;
	return S_OK;
}


HRESULT __stdcall DataPump::SetSilenceLevel(UINT uLevel)
{
	m_uSilenceLevel = uLevel;

	if (m_Audio.pSendStream)
	{
		m_Audio.pSendStream->SetProperty(PROP_SILENCE_LEVEL, &m_uSilenceLevel, sizeof(m_uSilenceLevel));
	}
	return S_OK;
}


HRESULT __stdcall DataPump::GetDuplex(BOOL *pbFullDuplex)
{
	*pbFullDuplex = m_bFullDuplex;
	return S_OK;
}



HRESULT __stdcall DataPump::GetMixer(HWND hwnd, BOOL bPlayback, IMixer **ppMixer)
{
	CMixerDevice *pMixerDevice = NULL;
	DWORD dwFlags;
	HRESULT hr = E_NOINTERFACE;

	// unfortunately, trying to create a mixer when WAVE_MAPPER
	// has been specified as the device ID results in a mixer
	// that doesn't work on Win95.

	*ppMixer = NULL;
	
	if ((bPlayback) && (m_uWaveOutID != WAVE_MAPPER))
	{
		pMixerDevice = CMixerDevice::GetMixerForWaveDevice(hwnd, m_uWaveOutID, MIXER_OBJECTF_WAVEOUT);
	}
	else if (m_uWaveInID != WAVE_MAPPER)
	{
		pMixerDevice = CMixerDevice::GetMixerForWaveDevice(hwnd, m_uWaveInID, MIXER_OBJECTF_WAVEIN);
	}

	if (pMixerDevice)
	{
		hr = pMixerDevice->QueryInterface(IID_IMixer, (void**)ppMixer);
	}

	return hr;
}


HRESULT __stdcall DataPump::GetAutoMix(BOOL *pbAutoMix)
{
	*pbAutoMix = m_bAutoMix;
	return S_OK;
}

HRESULT __stdcall DataPump::SetAutoMix(BOOL bAutoMix)
{
	m_bAutoMix = bAutoMix;
	if (m_Audio.pSendStream)
	{
		m_Audio.pSendStream->SetProperty(PROP_AUDIO_AUTOMIX, &m_bAutoMix, sizeof(m_bAutoMix));
	}
	return S_OK;
}

HRESULT __stdcall DataPump::GetDirectSound(BOOL *pbDS)
{
	*pbDS = m_bDirectSound;
	return S_OK;
}

HRESULT __stdcall DataPump::SetDirectSound(BOOL bDS)
{
	m_bDirectSound = bDS;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\datapump.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    datapump.h

Abstract:
	Contains constants and class declarations for the DataPump object. The DataPump controls
	the streaming of audio/video information between the network and the local record/playback
	source. It contains  or references several subclasses that deal with the multimedia devices,
	compression apis, buffer streaming and the network transport.
	
--*/
#ifndef _DATAPUMP_H_
#define _DATAPUMP_H_

#include "PacketSender.h"
#include "imstream.h"
#include "ThreadEvent.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

typedef HANDLE DPHANDLE;

//move this to nac..
#define 	MEDIA_ID_AUDIO		1
#define		MEDIA_ID_VIDEO		2

#define DEF_SILENCE_LIMIT		10
#define DEF_MISSING_LIMIT		10

#define DP_PROP_DUPLEX_TYPE		100		// internal version of PROP_DUPLEX_TYPE
										// needs to be above the PROP_xxx range in iprop.h

#define DP_MASK_PLATFORM		0xFF000000UL
#define DP_FLAG_ACM				0x01000000UL
#define DP_FLAG_QUARTZ			0x02000000UL
#define DP_FLAG_MMSYSTEM		0x04000000UL
#define DP_FLAG_AUDIO			DP_FLAG_MMSYSTEM
#define DP_FLAG_DIRECTSOUND		0x08000000UL
#define DP_FLAG_VCM				0x10000000UL
#define DP_FLAG_VIDEO			0x20000000UL

#define DP_MASK_TRANSPORT		0x00F00000UL
#define DP_FLAG_SEND			0x00100000UL
#define DP_FLAG_RECV			0x00200000UL

#define DP_MASK_DUPLEX			0x00030000UL
#define DP_FLAG_HALF_DUPLEX		0x00010000UL
#define DP_FLAG_FULL_DUPLEX		0x00020000UL

#define DP_MASK_WAVE_DEVICE		0x00000300UL
#define DP_FLAG_PLAY_CAP		0x00000100UL
#define DP_FLAG_RECORD_CAP		0x00000200UL

#define DP_MASK_VOICESWITCH		0x00007000UL    // used to r/w mode of voice switching
#define DP_FLAG_AUTO_SWITCH		0x00001000UL	// MODE:normal operation
#define DP_FLAG_MIC_ON			0x00002000UL	// MODE:manual "talk" control
#define DP_FLAG_MIC_OFF			0x00004000UL	// MODE:"mute"
#define DP_FLAG_AUTO_SILENCE_DETECT	0x00008000	// use auto thresholding (when auto-switching)

// m_DPFlags  is made up of the following plus some of the DP_XXX flags above
#define DPFLAG_INITIALIZED		0x00000001
#define DPFLAG_STARTED_SEND		0x00000002
#define DPFLAG_STARTED_RECV		0x00000004
#define DPFLAG_CONFIGURED_SEND	0x00000008
#define DPFLAG_CONFIGURED_RECV	0x00000010
#define DPFLAG_ENABLE_PREVIEW	0x00000020	// preview mode (video)
#define DPFLAG_AV_SYNC			0x00000040	// enable synchronization
#define DPFLAG_REAL_THING		0x00000080	// Allows distinction between preview and real call in Configure/Unconfigure

#define DPFLAG_ENABLE_SEND		0x00400000	// packets are recorded and sent
#define DPFLAG_ENABLE_RECV		0x00800000	// packets are recved and played


// ThreadFlags
#define DPTFLAG_STOP_MASK   0xFF
#define DPTFLAG_STOP_SEND	0x1
#define DPTFLAG_STOP_RECV	0x2
#define DPTFLAG_STOP_RECORD	0x4
#define DPTFLAG_STOP_PLAY	0x8
#define DPTFLAG_PAUSE_RECV	0x10
#define DPTFLAG_PAUSE_SEND	0x20
#define DPTFLAG_PAUSE_CAPTURE	0x40
#define DPTFLAG_SEND_PREAMBLE	0x100	// send I frames

	
#define MAX_MMIO_PATH 128


// the number of times the device must "fail" before a
// stream event notification gets sent
#define MAX_FAILCOUNT	3

typedef struct tagMMIOSRC
{
	BOOL		fPlayFromFile;
	HMMIO		hmmioSrc;
	MMCKINFO	ckSrc;
	MMCKINFO	ckSrcRIFF;
	DWORD		dwDataLength;
	DWORD		dwMaxDataLength;
	TCHAR		szInputFileName[MAX_MMIO_PATH];
	BOOL		fLoop;
	BOOL		fStart;
	BOOL		fStop;
	BOOL		fDisconnectAfterPlayback;
	WAVEFORMATEX wfx;
} MMIOSRC;

typedef struct tagMMIODEST
{
	BOOL		fRecordToFile;
	HMMIO		hmmioDst;
	MMCKINFO	ckDst;
	MMCKINFO	ckDstRIFF;
	DWORD		dwDataLength;
	DWORD		dwMaxDataLength;
	TCHAR		szOutputFileName[MAX_MMIO_PATH];
} MMIODEST;

namespace AudioFile
{
	HRESULT OpenSourceFile(MMIOSRC *pSrcFile, WAVEFORMATEX *pwf);
	HRESULT ReadSourceFile(MMIOSRC *pSrcFile, BYTE *pData, DWORD dwBytesToRead);
	HRESULT CloseSourceFile(MMIOSRC *pSrcFile);

	HRESULT OpenDestFile(MMIODEST *pDestFile, WAVEFORMATEX *pwf);
	HRESULT WriteDestFile(MMIODEST *pDestFile, BYTE *pData, DWORD dwBytesToWrite);
	HRESULT CloseDestFile(MMIODEST *pDestFile);
};



extern HANDLE g_hEventHalfDuplex;


#define MAX_TIMESTAMP 0xffffffffUL

/*
	TTimeout is used to schedule a thread timeout notification and is used along with
	the ThreadTimer class.
	Derive from the TTimeOut abstract class by defining the TimeoutIndication virtual function and
	pass an instance of the derived class to ThreadTimer::SetTimeout() after setting the time interval.
*/
class TTimeout
{
public:
	TTimeout() {pNext = pPrev = this;}
	void SetDueTime(DWORD msWhen) {m_DueTime = msWhen;}
	DWORD GetDueTime(void) {return m_DueTime;}
	
	friend class ThreadTimer;
private:
	class TTimeout *pNext;	// ptrs for doubly-linked-list
	class TTimeout *pPrev;	//
	DWORD m_DueTime;		// absolute time when this will fire 
	void InsertAfter(class TTimeout *pFirst) {
		pNext = pFirst->pNext;
		pPrev = pFirst;
		pFirst->pNext = this;
		pNext->pPrev = this;
	};
	void Remove(void) {
		pNext->pPrev = pPrev;
		pPrev->pNext = pNext;
		pNext = this;	// make next and prev self-referential so that Remove() is idempotent
		pPrev = this;
	}
	
protected:
	virtual void TimeoutIndication() {};

};

/*
	Implements a mechanism for a worker thread to schedule timeouts.
	The client calls SetTimeout(TTimeout *) to schedule an interval callback and CancelTimeout()
	to cancel a scheduled timeout. The main loop of the worker thread must call UpdateTime(curTime) periodically, at
	which point any elapsed timeouts will be triggered. UpdateTime() returns the time when it next needs to be called,
	which is usually the time of the earliest scheduled timeout.
	NOTE: All methods are expected to be called from the same thread so there is no need for critical sections..
*/
class ThreadTimer {
public:
	void SetTimeout(TTimeout *pTObj);
	void CancelTimeout(TTimeout  *pTObj);
	DWORD UpdateTime (DWORD curTime);

private:
	TTimeout m_TimeoutList;
	DWORD m_CurTime;

	BOOL IsEmpty() {return (&m_TimeoutList == m_TimeoutList.pNext);}
	
	
};


//flags for Start()/Stop()

#define DP_STREAM_SEND		1
#define DP_STREAM_RECV		2

// Number of video frames used to compute QoS stats
// We need at least 30 entries since the max frames
// per sec capture rate is 30. 32 allows us to figure
// out the integer stats per frame using a simple shift.
#define NUM_QOS_VID_ENTRIES 32
// The sizes of the IP and UDP header added to each packet
// need to be added to the size of the compressed packet
#define IP_HEADER_SIZE 20
#define UDP_HEADER_SIZE 8
class MediaStream;
class SendMediaStream;
class RecvMediaStream;

class DataPump : public IMediaChannelBuilder, public IVideoDevice, public IAudioDevice
{
	friend class SendAudioStream;
	friend class RecvAudioStream;
	friend class RecvDSAudioStream;

public:
	DataPump();
	~DataPump();

	// IMediaChannelBuilder
	STDMETHODIMP Initialize(HWND hWnd, HINSTANCE hInst);
	STDMETHODIMP CreateMediaChannel(UINT flags, IMediaChannel  **ppObj);
	STDMETHODIMP SetStreamEventObj(IStreamEventNotify *pNotify);

	// Internal

	void AddMediaChannel(UINT flags, IMediaChannel *pMediaChannel);
	void RemoveMediaChannel(UINT flags, IMediaChannel *pMediaChannel);
	HRESULT GetMediaChannelInterface(UINT flags, IMediaChannel **ppI);
	HRESULT StartReceiving(RecvMediaStream *pMS);
	HRESULT StopReceiving(RecvMediaStream *pMS);
	void ReleaseResources();

	STDMETHODIMP StreamEvent(UINT uDirection, UINT uMediaType, 
	                         UINT uEventType, UINT uSubCode);


    // IUnknown methods
   	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IQOS interface pointer and two resources requests: one for BW and one for CPU
	LPIQOS		m_pIQoS;

	// Recv thread timeout scheduler
	ThreadTimer m_RecvTimer;

	CRITICAL_SECTION m_crs;	// serializes access to multithread-safe methods
	
	// the app handles are global 
	static HWND		m_hAppWnd;
	static HINSTANCE	m_hAppInst;

	PacketSender m_PacketSender;
	ThreadEventProxy *m_pTEP;

	BOOL m_bDisableRSVP;

	// IVideoDevice Methods
	// Capture Device related methods
	HRESULT __stdcall GetNumCapDev();
	HRESULT __stdcall GetMaxCapDevNameLen();
	HRESULT __stdcall EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev);
	HRESULT __stdcall GetCurrCapDevID();
	HRESULT __stdcall SetCurrCapDevID(int nCapDevID);


	// IAudioDevice Methods
	HRESULT __stdcall GetRecordID(UINT *puWaveDevID);
	HRESULT __stdcall SetRecordID(UINT uWaveDevID);
	HRESULT __stdcall GetPlaybackID(UINT *puWaveDevID);
	HRESULT __stdcall SetPlaybackID(UINT uWaveDevID);
	HRESULT __stdcall GetDuplex(BOOL *pbFullDuplex);
	HRESULT __stdcall SetDuplex(BOOL bFullDuplex);
	HRESULT __stdcall GetSilenceLevel(UINT *puLevel);
	HRESULT __stdcall SetSilenceLevel(UINT uLevel);
	HRESULT __stdcall GetAutoMix(BOOL *pbAutoMix);
	HRESULT __stdcall SetAutoMix(BOOL bAutoMix);
	HRESULT __stdcall GetDirectSound(BOOL *pbDS);
	HRESULT __stdcall SetDirectSound(BOOL bDS);
	HRESULT __stdcall GetMixer(HWND hwnd, BOOL bPlayback, IMixer **ppMixer);


protected:
	struct MediaChannel {
	public:
		SendMediaStream *pSendStream;
		RecvMediaStream *pRecvStream;
	}
	m_Audio, m_Video;

	UINT m_uRef;

	// receive thread stuff
	HANDLE m_hRecvThread;
	DWORD m_RecvThId,m_nReceivers;
	HANDLE m_hRecvThreadAckEvent;		// ack from recv thread
	// temp variables for communicating with recv thread
	HANDLE m_hRecvThreadSignalEvent;	// signal to recv thread
	RecvMediaStream *m_pCurRecvStream;	
	UINT m_CurRecvMsg;

	
	friend  DWORD __stdcall StartDPRecvThread(PVOID pDP); // pDP == pointer to DataPump
	DWORD CommonRecvThread(void);
	DWORD CommonWS2RecvThread(void);

	HRESULT RecvThreadMessage(UINT msg, RecvMediaStream *pMS);
	HRESULT SetStreamDuplex(IMediaChannel *pStream, BOOL bFullDuplex);
	
	// datapump only needs to keep track of the device ID for
	// video.  Gets a bit more complicated for Audio.
	UINT m_uVideoCaptureId;

	// IAudioDevice stuff
	UINT m_uWaveInID;
	UINT m_uWaveOutID;
	BOOL m_bFullDuplex;
	UINT m_uSilenceLevel; // 0-999 (manual)   1000- (automatic)
	BOOL m_bAutoMix;
	BOOL m_bDirectSound;

};

// messages used to signal recv thread
// must not conflict with message ids used by AsyncSock
#define MSG_START_RECV	(WM_USER + 20)
#define MSG_STOP_RECV	(WM_USER + 21)
#define MSG_EXIT_RECV	(WM_USER + 22)
#define MSG_PLAY_SOUND	(WM_USER + 23)

#include <poppack.h> /* End byte packing */

#endif	//_DATAPUMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\com.h ===
/*
 -  COM.H
 -
 *	Microsoft NetMeeting
 *	Network Audio Controller (NAC) DLL
 *	Internal header file for general COM "things"
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		2.3.97		Yoram Yaacovi		Created
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/* 
 *	Class factory
 */
typedef HRESULT (STDAPICALLTYPE *PFNCREATE)(IUnknown *, REFIID, void **);
class CClassFactory : public IClassFactory
{
    public:
        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void **);
        STDMETHODIMP         LockServer(BOOL);

        CClassFactory(PFNCREATE);
        ~CClassFactory(void);

    protected:
        ULONG	m_cRef;
		PFNCREATE m_pfnCreate;
};

#include <poppack.h> /* End byte packing */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\counters.h ===
//  COUNTERS.H
//
//      Global performance counters for the nac
//
//  Created 13-Nov-96 [JonT]


#ifndef _COUNTERS_H
#define _COUNTER_H

#include <objbase.h>
#include "icounter.h"

// Interface pointer to counter manager object.
// If this pointer is NULL, stats are not around (or not initialized)
extern ICounterMgr* g_pCtrMgr;

// Counter pointers. All available counters should be listed here
extern ICounter* g_pctrVideoSend;
extern ICounter* g_pctrVideoReceive;
extern ICounter* g_pctrVideoSendBytes;
extern ICounter* g_pctrVideoReceiveBytes;
extern ICounter* g_pctrVideoSendLost;

extern ICounter* g_pctrAudioSendBytes;
extern ICounter* g_pctrAudioReceiveBytes;
extern ICounter* g_pctrAudioSendLost;

extern ICounter* g_pctrVideoCPUuse;
extern ICounter* g_pctrVideoBWuse;
extern ICounter* g_pctrAudioJBDelay;


extern IReport* g_prptCallParameters;
extern IReport* g_prptSystemSettings;

// Helper function prototypes (COUNTER.CPP)
extern "C" BOOL WINAPI InitCountersAndReports(void);
extern "C" void WINAPI DoneCountersAndReports(void);

// Function helpers (better than using macros)
void __inline DEFINE_COUNTER(ICounter** ppctr, char* szName, DWORD dwFlags)
{
    if (g_pCtrMgr->CreateCounter(ppctr) == S_OK)
        (*ppctr)->Initialize(szName, dwFlags);
}

void __inline DELETE_COUNTER(ICounter** ppctr)
{
    ICounter* pctrT;

    if (*ppctr)
    {
        pctrT = *ppctr;
        *ppctr = NULL;
        pctrT->Release();
    }
}

void __inline UPDATE_COUNTER(ICounter* pctr, int nValue)
{
    if (pctr)
        pctr->Update(nValue);
}

void __inline INIT_COUNTER_MAX(ICounter* pctr, int nMaxValue)
{
    if (pctr)
        pctr->InitMax(nMaxValue);
}

void __inline DEFINE_REPORT(IReport** pprpt, char* szName, DWORD dwFlags)
{
    if (g_pCtrMgr->CreateReport(pprpt) == S_OK)
        (*pprpt)->Initialize(szName, dwFlags);
}

void __inline DELETE_REPORT(IReport** pprpt)
{
    IReport* prptT;

    if (*pprpt)
    {
        prptT = *pprpt;
        *pprpt = NULL;
        prptT->Release();
    }
}

void __inline DEFINE_REPORT_ENTRY(IReport* prpt, char* szName, DWORD dwIndex)
{
    if (prpt)
        prpt->CreateEntry(szName, dwIndex);
}

void __inline UPDATE_REPORT_ENTRY(IReport* prpt, int nValue, DWORD dwIndex)
{
    if (prpt)
        prpt->Update(nValue, dwIndex);
}

#endif // #ifndef _COUNTERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\clsfact.cpp ===
/*
 -  CLSFACT.CPP
 -
 *	Microsoft NetMeeting
 *	Network Audio Control DLL
 *	Generic class factory
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		2.6.97		Yoram Yaacovi		Copied from qosfact.cpp
 *										Added handling of CInstallCodecs
 *		2.27.97		Yoram Yaacovi		Added DllRegisterServer and DllUnregisterServer
 *
 *	Functions:
 *		DllGetClassObject
 *		DllCanUnloadNow
 *		DllRegisterServer
 *		DllUnregisterServer
 *		CClassFactory::QueryInterface
 *		CClassFactory::AddRef
 *		CClassFactory::Release
 *		CClassFactory::CreateInstance
 *		CClassFactory::LockServer
 *		CreateClassFactory
 *		
 *
 *	Object types supported:
 *		CQoS
 *		CInstallCodecs
 *
 *	Notes:
 *		To add support for manufacturing objects of other types, change:
 *			DllGetClassObject
 *			DllCanUnloadNow
 *			Add the CLSID and description to aObjectInfo
 *
 */

#include <precomp.h>

int g_cObjects = 0;				// A general object count. Used for LockServer.
EXTERN_C int g_cQoSObjects;		// QoS object count. Public in qos\qos.cpp
EXTERN_C int g_cICObjects;		// CInstallCodecs object count. Public in inscodec.cpp

EXTERN_C HINSTANCE g_hInst;		// global module instance

// Untested code for registering COM objects in the NAC
// when enabled, DllRegisterServer and DllUnregisterServer should be exported
// in nac.def

#define GUID_STR_LEN    40

typedef struct
{
    const CLSID *pclsid;
	char szDescription[MAX_PATH];
} OBJECT_INFO;

static OBJECT_INFO aObjectInfo[]=
	{&CLSID_QoS, TEXT("Microsoft NetMeeting Quality of Service"),
	 &CLSID_InstallCodecs, TEXT("Microsoft NetMeeting Installable Codecs"),
	 NULL, TEXT("")};

// Internal helper functions
BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPTSTR pszSubKey);
BOOL UnregisterUnknownObject(const CLSID *prclsid);
BOOL RegisterUnknownObject(LPCTSTR  pszObjectName, const CLSID *prclsid);

/***************************************************************************

    Name      : DllGetClassObject

    Purpose   : Standard COM entry point to create a COM object

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr;
    CClassFactory *pObj;

	*ppv = 0;

	// find out object of what class we need to create and instantiate
	// the class factory with the correct create function
    if (CLSID_QoS == rclsid)
	{
    	DBG_SAVE_FILE_LINE
		pObj = new CClassFactory(CreateQoS);
	}
	else if (CLSID_InstallCodecs == rclsid)
	{
		DBG_SAVE_FILE_LINE
		pObj = new CClassFactory(CreateInstallCodecs);
	}
	else
	{
		hr = CLASS_E_CLASSNOTAVAILABLE;
		goto out;
	}

    if (!pObj)
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}

    hr = pObj->QueryInterface(riid, ppv);
    if (FAILED(hr))
        delete pObj;

out:
    return hr;
}

/***************************************************************************

    Name      : DllCanUnloadNow

    Purpose   : Standard COM entry point tell a DLL it can unload

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllCanUnloadNow ()
{
	HRESULT hr=S_OK;
	int vcObjects = g_cObjects + g_cQoSObjects + g_cICObjects;

	return (vcObjects == 0 ? S_OK : S_FALSE);
}

/***************************************************************************

    Name      : DllRegisterServer

    Purpose   : Standard COM entry point to register a COM server

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllRegisterServer(void)
{
	ULONG i=0;
	HRESULT hr=NOERROR;

	while ((aObjectInfo[i].pclsid != NULL) &&
			(lstrlen(aObjectInfo[i].szDescription) != 0))
    {
		if (!RegisterUnknownObject(aObjectInfo[i].szDescription,
								   aObjectInfo[i].pclsid))
		{
			hr = E_FAIL;
			goto out;
		}

		// next server to register
		i++;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : DllUnregisterServer

    Purpose   : Standard COM entry point to unregister a COM server

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllUnregisterServer(void)
{
 	ULONG i=0;
	HRESULT hr=NOERROR;

	while ((aObjectInfo[i].pclsid != NULL) &&
			(lstrlen(aObjectInfo[i].szDescription) != 0))
    {
		if (!UnregisterUnknownObject(aObjectInfo[i].pclsid))
		{
			hr = E_FAIL;
			goto out;
		}

		// next server to register
		i++;
	}

out:
	return hr;
}

/***************************************************************************

    ClassFactory: Generic implementation

***************************************************************************/
CClassFactory::CClassFactory(PFNCREATE pfnCreate)
{
	m_cRef=0;
	m_pfnCreate = pfnCreate;

	return;
}

CClassFactory::~CClassFactory(void)
{
	return;
}

/***************************************************************************

    IUnknown Methods for  CClassFactory

***************************************************************************/
HRESULT CClassFactory::QueryInterface (REFIID riid, void **ppv)
{
	HRESULT hr=NOERROR;

#ifdef DEBUG
	// parameter validation
    if (IsBadReadPtr(&riid, (UINT) sizeof(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(ppv, sizeof(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }
#endif // DEBUG
	
	*ppv = 0;

    if (IID_IUnknown == riid ||
		IID_IClassFactory == riid)
	{
		*ppv = this;
	}
	else    
	{
        hr = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

	((IUnknown *)*ppv)->AddRef();

out:
	return hr;
}

ULONG CClassFactory::AddRef (void)
{
    return ++m_cRef;
}

ULONG CClassFactory::Release (void)
{
	// if the cRef is already 0 (shouldn't happen), assert, but let it through
	ASSERT(m_cRef);
	if (--m_cRef == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

/***************************************************************************

    Name      : CreateInstance

    Purpose   : Standard COM class factory entry point which creates the
				object that this class factory knows to create

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
HRESULT CClassFactory::CreateInstance (	IUnknown *punkOuter,
										REFIID riid,
										void **ppv)
{
	DEBUGMSG(ZONE_VERBOSE,("CClassFactory::CreateInstance\n"));

	return (m_pfnCreate)(punkOuter, riid, ppv);
}

/***************************************************************************

    Name      : LockServer

    Purpose   : Standard COM class factory entry point which will prevent
				the server from shutting down. Necessary when the caller
				keeps the class factory (through CoGetClassObject) instead
				of calling CoCreateInstance.

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
HRESULT CClassFactory::LockServer (BOOL flock)
{
	if (flock)
		++g_cObjects;
	else
		--g_cObjects;

	return NOERROR;
}

/***************************************************************************

	Helper functions

***************************************************************************/
/***************************************************************************

    Name      : StringFromGuid

    Purpose   : Creates a string out of a GUID

    Parameters: riid - [in]  clsid to make string out of.
				pszBuf - [in]  buffer in which to place resultant GUID

    Returns   : int - number of chars written out

    Comment   : 

***************************************************************************/
int StringFromGuid(const CLSID *priid, LPTSTR pszBuf)
{
    return wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            priid->Data1, 
            priid->Data2, priid->Data3, priid->Data4[0], priid->Data4[1], priid->Data4[2], 
            priid->Data4[3], priid->Data4[4], priid->Data4[5], priid->Data4[6], priid->Data4[7]);
}

/***************************************************************************

    Name      : RegisterUnknownObject

    Purpose   : Registers a simple CoCreatable object
				We add the following information to the registry:

				HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
				HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
				HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment

    Parameters: pszObjectName - [in] Object Name
				prclsid - [in] pointer to the CLSID of the object

    Returns   : BOOL - FALSE means couldn't register it all

    Comment   : 

***************************************************************************/
BOOL RegisterUnknownObject(LPCTSTR  pszObjectName, const CLSID *prclsid)
{
    HKEY  hk = NULL, hkSub = NULL;
    TCHAR szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    TCHAR szScratch[MAX_PATH];
	BOOL bRet = FALSE;
    long  l;

    // clean out any garbage
    UnregisterUnknownObject(prclsid);

    if (!StringFromGuid(prclsid, szGuidStr))
		goto out;

	// CLSID/<class-id>
    wsprintf(szScratch, TEXT("CLSID\\%s"), szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>: class name 
    wsprintf(szScratch, TEXT("%s Object"), pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch,
                      (lstrlen(szScratch) + 1)*sizeof(TCHAR));
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>/InprocServer32
    l = RegCreateKeyEx(hk, TEXT("InprocServer32"), 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>/InprocServer32:<file name>
    dwPathLen = GetModuleFileName(g_hInst, szScratch, sizeof(szScratch)/sizeof(TCHAR));
    if (!dwPathLen)
		goto out;
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (dwPathLen + 1)*sizeof(TCHAR));
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>/InprocServer32: ThreadingModel = Apartment
    l = RegSetValueEx(hkSub, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)TEXT("Apartment"),
                      sizeof(TEXT("Apartment")));
	if (l != ERROR_SUCCESS)
		goto out;

    bRet = TRUE;

out:
	// clean the keys if we failed somewhere
	if (!bRet)
		UnregisterUnknownObject(prclsid);
    if (hk)
		RegCloseKey(hk);
    if (hkSub)
		RegCloseKey(hkSub);
    return bRet;
}

/***************************************************************************

    Name      : UnregisterUnknownObject

    Purpose   : cleans up all the stuff that RegisterUnknownObject puts in the
				registry.

    Parameters: prclsid - [in] pointer to the CLSID of the object

    Returns   : BOOL - FALSE means couldn't register it all

    Comment   : 

***************************************************************************/
BOOL UnregisterUnknownObject(const CLSID *prclsid)
{
	TCHAR szScratch[MAX_PATH];
	HKEY hk=NULL;
	BOOL f;
	long l;
	BOOL bRet = FALSE;

	// delete everybody of the form
	//   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
	//
	if (!StringFromGuid(prclsid, szScratch))
		goto out;

	l = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_ALL_ACCESS, &hk);
	if (l != ERROR_SUCCESS)
		goto out;

	// Delete the object key and subkeys
	bRet = DeleteKeyAndSubKeys(hk, szScratch);

out:
    if (hk)
		RegCloseKey(hk);
	return bRet;
}

/***************************************************************************

    Name      : DeleteKeyAndSubKeys

    Purpose   : delete's a key and all of it's subkeys.

    Parameters: hkIn - [in] delete the descendant specified
				pszSubKey - [in] i'm the descendant specified

    Returns   : BOOL - TRUE = OK

    Comment   : Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
				work with sub-keys under windows 95.
				This function is recursive.

***************************************************************************/
BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;
    int   x;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    x = 0;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
        x++;
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dllmain.cpp ===
// File: nac.cpp


#include "precomp.h"
#include "confreg.h"

EXTERN_C BOOL APIENTRY QoSEntryPoint (HINSTANCE hInstDLL, DWORD dwReason, 
LPVOID lpReserved);

EXTERN_C HINSTANCE g_hInst=NULL;	// global module instance


#ifdef DEBUG
HDBGZONE  ghDbgZoneNac = NULL;
static PTCHAR _rgZonesNac[] = {
	TEXT("nac"),
	TEXT("Init"),
	TEXT("Connection"),
	TEXT("Comm Chan"),
	TEXT("Caps"),
	TEXT("DataPump"),
	TEXT("ACM"),
	TEXT("VCM"),
	TEXT("Verbose"),
	TEXT("Installable Codecs"),
	TEXT("Profile spew"),
	TEXT("Local QoS"),
	TEXT("Keyframe Management")
};

HDBGZONE  ghDbgZoneNMCap = NULL;
static PTCHAR _rgZonesNMCap[] = {
	TEXT("NM Capture"),
	TEXT("Ctor/Dtor"),
	TEXT("Ref Counts"),
	TEXT("Streaming")
};

int WINAPI NacDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("NAC", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */


bool NacShutdown()
{
	vcmReleaseResources();
	DirectSoundMgr::UnInitialize();
	return true;
}



extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL,
                                     DWORD  fdwReason,
                                     LPVOID  lpvReserved);

BOOL WINAPI DllEntryPoint(
    HINSTANCE  hinstDLL,	// handle to DLL module
    DWORD  fdwReason,	// reason for calling function
    LPVOID  lpvReserved 	// reserved
   )
{
	switch(fdwReason)
	{

		case DLL_PROCESS_ATTACH:
			DBGINIT(&ghDbgZoneNac, _rgZonesNac);
			DBGINIT(&ghDbgZoneNMCap, _rgZonesNMCap);

            DBG_INIT_MEMORY_TRACKING(hinstDLL);

			DisableThreadLibraryCalls(hinstDLL);
			g_hInst = hinstDLL;
            break;

		case DLL_PROCESS_DETACH:

			NacShutdown();  // release all global memory

            DBG_CHECK_MEMORY_TRACKING(hinstDLL);

			DBGDEINIT(&ghDbgZoneNac);
			DBGDEINIT(&ghDbgZoneNMCap);
			break;

		default:
			break;

	}
	// call attach/detach-time functions of cantained libraries
  	QoSEntryPoint(hinstDLL, fdwReason, lpvReserved);


 	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dscstream.h ===
#ifndef SEND_DSC_STREAM_H
#define SEND_DSC_STREAM_H

#include "agc.h"


#include <pshpack8.h> /* Assume 8 byte packing throughout */


#define MAX_DSC_DESCRIPTION_STRING 200
#define MAX_NUMBER_DSCAPTURE_DEVICES 16
#define NUM_AUDIOPACKETS 2
#define MIN_NUM_DSC_SEGMENTS 5

#define DSOUND_DLL	"dsound.dll"

#define DISABLE_DSC_REGKEY	 "Software\\Microsoft\\Internet Audio\\NacObject"
#define DISABLE_DSC_REGVALUE "DisableDirectSoundCapture"



typedef HRESULT (WINAPI *DS_CAP_CREATE)(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
typedef HRESULT (WINAPI *DS_CAP_ENUM)(LPDSENUMCALLBACKA, LPVOID);


struct DSC_CAPTURE_INFO
{
	GUID guid;
	char szDescription[MAX_DSC_DESCRIPTION_STRING];
	UINT uWaveId;
	BOOL bAllocated;
};


// really a namespace
class DSC_Manager
{
public:
	static HRESULT Initialize();
	static HRESULT MapWaveIdToGuid(UINT uwaveId, GUID *pGuid);
	static HRESULT CreateInstance(GUID *pGuid, IDirectSoundCapture **pDSC);

private:
	static BOOL s_bInitialized;

	static DSC_CAPTURE_INFO s_aDSC[MAX_NUMBER_DSCAPTURE_DEVICES];
	static int s_nCaptureDevices; // number in array

	static BOOL CALLBACK DSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription,
	                           LPCSTR lpcstrModule, LPVOID lpContext);

	static HINSTANCE s_hDSCLib;

	static DS_CAP_CREATE s_pDSCapCreate;
	static DS_CAP_ENUM s_pDSCapEnum;

};



class SendDSCStream : public SendMediaStream, public IAudioChannel, public IDTMFSend
{
private:
	AcmFilter *m_pAudioFilter;  // encapsulates codec
	WAVEFORMATEX m_wfPCM;       // uncompressed recording format
	WAVEFORMATEX m_wfCompressed; // compressed format
	AudioSilenceDetector m_AudioMonitor;
	MMIOSRC		m_mmioSrc;  // handle to input file


	static DWORD CALLBACK StartRecordingThread (LPVOID pVoid);
	DWORD RecordingThread();

	STDMETHODIMP_(void) UnConfigure(void);
	LONG m_lRefCount;

	IDirectSoundCapture *m_pDSC; // DSC device object
	IDirectSoundCaptureBuffer *m_pDSCBuffer; // the capture buffer

	HANDLE m_hEvent;  // DSC Notify Event


	DWORD m_dwSamplesPerFrame; // number of PCM samples represented in a frame
	DWORD m_dwNumFrames; // number of individual frames in the DSC Buffer
	DWORD m_dwFrameSize; // the size of a PCM frame in bytes
	DWORD m_dwDSCBufferSize; // the size of the DSC Buffer (== m_dwFrameSize * m_dwNumFrames)
	DWORD m_dwSilenceTime;   // amount of silence accumulated so far in Milliseconds
	DWORD m_dwFrameTimeMS;   // the length of a frame in milliseconds

	HRESULT CreateAudioPackets(MEDIAPACKETINIT *mpi);
	HRESULT ReleaseAudioPackets();
	AudioPacket *m_aPackets[NUM_AUDIOPACKETS];


	// private methods that the thread uses
	HRESULT CreateDSCBuffer();
	HRESULT ReleaseDSCBuffer();
	DWORD ProcessFrame(DWORD dwBufferPos, BOOL fMark);
	DWORD WaitForControl();
	DWORD YieldControl();
	BOOL ThreadExitCheck();
	void UpdateTimestamp();
	HRESULT SendPacket(AudioPacket *pAP);
	BOOL UpdateQosStats(UINT uStatType, UINT uStatValue1, UINT uStatValue2);

	// members used primarily by the recording thread
	BOOL m_bFullDuplex;
	BOOL m_bJammed; // set by the recording thread to indicate an error on the device
	BOOL m_bCanSignalOpen;
	BOOL m_bCanSignalFail;
	int m_nFailCount;
	AGC m_agc; // thread uses AGC object for AutoMix
	BOOL m_bAutoMix;  // indicates if AutoMixing is turned off or on

	// DTMF stuff
	DTMFQueue *m_pDTMF;
	HRESULT __stdcall SendDTMF();

public:
	SendDSCStream();
	virtual ~SendDSCStream();

	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	// IMediaChannel
	virtual STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	virtual STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	virtual HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return SendMediaStream::SetNetworkInterface(pUnknown);
	}

	virtual STDMETHODIMP Start(void);
	virtual STDMETHODIMP Stop(void);


	STDMETHODIMP_(DWORD) GetState() 
	{
		return SendMediaStream::GetState();
	}

	virtual HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate);

	// IAudioChannel
	virtual STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);

	// IDTMFSend
	virtual HRESULT __stdcall AddDigit(int nDigit);
	virtual HRESULT __stdcall ResetDTMF();

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *pdp);
	virtual DWORD Send();
	virtual void EndSend();
};

#include <poppack.h> /* End byte packing */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dscstream.cpp ===
#include "precomp.h"
#include <nmdsprv.h>

#include "mixer.h"
#include "dscstream.h"
#include "agc.h"


// static member initialization
BOOL DSC_Manager::s_bInitialized = FALSE;
DSC_CAPTURE_INFO DSC_Manager::s_aDSC[MAX_NUMBER_DSCAPTURE_DEVICES];
int DSC_Manager::s_nCaptureDevices = 0;
HINSTANCE DSC_Manager::s_hDSCLib = NULL;
DS_CAP_CREATE DSC_Manager::s_pDSCapCreate = NULL;
DS_CAP_ENUM DSC_Manager::s_pDSCapEnum = NULL;




// static
HRESULT DSC_Manager::Initialize()
{

	if (s_bInitialized)
	{
		return S_OK;
	}


	// failsafe way to to turn DSC off, without turning
	// DirectSound support off.  Otherwise, the UI setting
	// to disable DS will also disable DSC.
	{
		BOOL bDisable;
		RegEntry re(DISABLE_DSC_REGKEY, HKEY_LOCAL_MACHINE, FALSE,0);

		bDisable = re.GetNumber(DISABLE_DSC_REGVALUE, FALSE);
		if (bDisable)
		{
			return E_FAIL;
		}
	}


	// initialize the array of structure descriptions

	s_hDSCLib = LoadLibrary(DSOUND_DLL);

	if (s_hDSCLib == NULL)
		return E_FAIL;


	s_pDSCapCreate = (DS_CAP_CREATE)GetProcAddress(s_hDSCLib, "DirectSoundCaptureCreate");
	s_pDSCapEnum = (DS_CAP_ENUM)GetProcAddress(s_hDSCLib, "DirectSoundCaptureEnumerateA");

	if ((s_pDSCapCreate) && (s_pDSCapEnum))
	{
		// enumerate!

		s_pDSCapEnum(DSC_Manager::DSEnumCallback, 0);

		if (s_nCaptureDevices != 0)
		{
			s_bInitialized = TRUE;
			return S_OK; // success
		}
	}

	FreeLibrary(s_hDSCLib);
	s_hDSCLib = NULL;
	return E_FAIL;

}



// static
BOOL CALLBACK DSC_Manager::DSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription,
	                           LPCSTR lpcstrModule, LPVOID lpContext)
{
	if (lpGuid == NULL)
	{
		s_aDSC[s_nCaptureDevices].guid = GUID_NULL;
	}
	else
	{
		s_aDSC[s_nCaptureDevices].guid = *lpGuid;
	}


	lstrcpyn(s_aDSC[s_nCaptureDevices].szDescription, lpcstrDescription, MAX_DSC_DESCRIPTION_STRING);

	s_aDSC[s_nCaptureDevices].uWaveId = WAVE_MAPPER;
	s_nCaptureDevices++;
	return TRUE;
}


// static
HRESULT DSC_Manager::CreateInstance(GUID *pGuid, IDirectSoundCapture **pDSC)
{
	HRESULT hr;

	if FAILED(Initialize())
	{
		return E_FAIL;
	}

	if (*pGuid == GUID_NULL)
		pGuid = NULL;

	hr = s_pDSCapCreate(pGuid, pDSC, NULL);

	return hr;
}


// static
HRESULT DSC_Manager::MapWaveIdToGuid(UINT uWaveID, GUID *pGuid)
{

	HRESULT hr;
	WAVEINCAPS waveInCaps;
	UINT uNumWaveDevs;
	GUID guid = GUID_NULL;
	int nIndex;
	MMRESULT mmr;
	HWAVEIN hWaveIn;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM, 1, 8000, 16000, 2, 16, 0};
	IDirectSoundCapture *pDSC=NULL;

	*pGuid = GUID_NULL;
	
	if (FAILED( Initialize() ))
	{
		return E_FAIL;
	}

	// only one wave device, take the easy way out
	uNumWaveDevs = waveInGetNumDevs();

	if ((uNumWaveDevs <= 1) || (uWaveID == WAVE_MAPPER))
	{
		return S_OK;
	}

	// more than one wavein device
	mmr = waveInGetDevCaps(uWaveID, &waveInCaps, sizeof(WAVEINCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveInCaps.szPname, TRUE, &guid);
		if (SUCCEEDED(hr))
		{
			*pGuid = guid;
			return S_OK;
		}
	}


	// scan through the DSC list to see if we've mapped this device
	// previously

	for (nIndex = 0; nIndex < s_nCaptureDevices; nIndex++)
	{
		if (s_aDSC[nIndex].uWaveId == uWaveID)
		{
			*pGuid = s_aDSC[nIndex].guid;
			return S_OK;
		}
	}

	//  hack approach to mapping the device to a guid
	mmr = waveInOpen(&hWaveIn, uWaveID, &waveFormat, 0,0,0);
	if (mmr != MMSYSERR_NOERROR)
	{
		return S_FALSE;
	}

	// find all the DSC devices that fail to open
	for (nIndex = 0; nIndex < s_nCaptureDevices; nIndex++)
	{
		s_aDSC[nIndex].bAllocated = FALSE;
		hr = CreateInstance(&(s_aDSC[nIndex].guid), &pDSC);
		if (FAILED(hr))
		{
			s_aDSC[nIndex].bAllocated = TRUE;
		}
		else
		{
			pDSC->Release();
			pDSC=NULL;
		}
	}

	waveInClose(hWaveIn);

	// scan through the list of allocated devices and
	// see which one opens
	for (nIndex = 0; nIndex < s_nCaptureDevices; nIndex++)
	{
		if (s_aDSC[nIndex].bAllocated)
		{
			hr = CreateInstance(&(s_aDSC[nIndex].guid), &pDSC);
			if (SUCCEEDED(hr))
			{
				// we have a winner
				pDSC->Release();
				pDSC = NULL;
				*pGuid = s_aDSC[nIndex].guid;
				s_aDSC[nIndex].uWaveId = uWaveID;
				return S_OK;
			}
		}
	}
	// if we got to this point, it means we failed to map a device
	// just use GUID_NULL and return an error
	return S_FALSE;
}






SendDSCStream::SendDSCStream() :
SendMediaStream(),
m_pAudioFilter(NULL),
m_lRefCount(0),
m_pDSC(NULL),
m_pDSCBuffer(NULL),
m_hEvent(NULL),
m_dwSamplesPerFrame(0),
m_dwNumFrames(0),
m_dwFrameSize(0),
m_dwDSCBufferSize(0),
m_dwSilenceTime(0),
m_dwFrameTimeMS(0),
m_bFullDuplex(TRUE),
m_bJammed(FALSE),
m_bCanSignalOpen(TRUE),
m_bCanSignalFail(TRUE),
m_nFailCount(0),
m_agc(NULL),
m_bAutoMix(FALSE),
m_pDTMF(NULL)
{
	return;
};


HRESULT SendDSCStream::Initialize(DataPump *pDP)
{
	HRESULT hr;


	m_pDP = pDP;

	hr = DSC_Manager::Initialize();
	if (FAILED(hr))
	{
		return hr;
	}

	m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hEvent == NULL)
	{
		return DPR_CANT_CREATE_EVENT;
	}

    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter();
	if (!m_pAudioFilter)
	{
		return DPR_OUT_OF_MEMORY;
	}

    DBG_SAVE_FILE_LINE
	m_pDTMF = new DTMFQueue;
	if (!m_pDTMF)
	{
		return DPR_OUT_OF_MEMORY;
	}


	m_DPFlags = DP_FLAG_ACM|DP_FLAG_MMSYSTEM|DP_FLAG_DIRECTSOUND|DP_FLAG_SEND;

	m_SendTimestamp = m_SavedTickCount = timeGetTime();

	m_dwDstSize = 0;
	m_fSending = FALSE;

	m_hCapturingThread = NULL;
	m_CaptureThId = 0;
	m_ThreadFlags = 0;

	m_pRTPSend = NULL;
	m_RTPPayload = 0;

	m_CaptureDevice = -1;
	m_pRTPSend = NULL;

	ZeroMemory(m_aPackets, sizeof(m_aPackets));
	ZeroMemory(&m_mmioSrc, sizeof(m_mmioSrc));

	m_DPFlags = DP_FLAG_ACM | DP_FLAG_MMSYSTEM | DP_FLAG_AUTO_SILENCE_DETECT;
	m_DPFlags = (m_DPFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND;
	m_DPFlags |= DPFLAG_INITIALIZED;

	return S_OK;

}



SendDSCStream::~SendDSCStream()
{
	if (m_DPFlags & DPFLAG_INITIALIZED)
	{
		if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
		{
			UnConfigure();
		}

		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
			m_pRTPSend = NULL;
		}

		if (m_pDTMF)
		{
			delete m_pDTMF;
			m_pDTMF = NULL;
		}

		if (m_pAudioFilter)
		{
			delete m_pAudioFilter;
		}

		if (m_hEvent)
		{
			CloseHandle(m_hEvent);
		}

		m_pDP->RemoveMediaChannel(MCF_SEND|MCF_AUDIO, (IMediaChannel*)(SendMediaStream*)this);

		m_DPFlags &= ~DPFLAG_INITIALIZED;
	}
	
}



HRESULT STDMETHODCALLTYPE SendDSCStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	WAVEFORMATEX *pwfSend;
	MMRESULT mmr;
	MEDIAPACKETINIT mpi;
	DWORD dwSourceSize;
	int nIndex;
	HRESULT hr;

	FX_ENTRY ("SendDSCStream::Configure");


	// basic parameter checking
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
	{
		return DPR_OUT_OF_MEMORY;
	}

	// Not a good idea to change anything while in mid-stream
	if (m_DPFlags & DPFLAG_STARTED_SEND)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();
	}

	if ((NULL == pFormat) || (NULL == pChannelParams) ||
		(cbParams < sizeof(AUDIO_CHANNEL_PARAMETERS)) ||
		(cbFormat < sizeof(WAVEFORMATEX)))
	{
		return DPR_INVALID_PARAMETER;
	}

	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfSend = (WAVEFORMATEX *)pFormat;
	m_wfCompressed = *pwfSend;
	m_wfCompressed.cbSize = 0;

	// initialize the ACM filter
	mmr = AcmFilter::SuggestDecodeFormat(pwfSend, &m_wfPCM);
	if (mmr != MMSYSERR_NOERROR)
	{
		return DPR_INVALID_PARAMETER;
	}

	mmr = m_pAudioFilter->Open(&m_wfPCM, pwfSend);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		return DPR_CANT_OPEN_CODEC;
	}

	m_dwSamplesPerFrame = audChannelParams.ns_params.wFrameSize * audChannelParams.ns_params.wFramesPerPkt;
	m_dwFrameTimeMS = (m_dwSamplesPerFrame * 1000) / m_wfPCM.nSamplesPerSec;

	ASSERT(m_dwFrameTimeMS > 0);
	if (m_dwFrameTimeMS <= 0)
	{
		m_pAudioFilter->Close();
		return DPR_INVALID_PARAMETER;
	}

	m_dwNumFrames = 1000 / m_dwFrameTimeMS;
	if (m_dwNumFrames < MIN_NUM_DSC_SEGMENTS)
	{
		m_dwNumFrames = MIN_NUM_DSC_SEGMENTS;
	}


	m_dwFrameSize = m_dwSamplesPerFrame * m_wfPCM.nBlockAlign;
	m_pAudioFilter->SuggestDstSize(m_dwFrameSize, &m_dwDstSize);


	m_dwDSCBufferSize = m_dwFrameSize * m_dwNumFrames;

	// create the packets

	ZeroMemory(&mpi, sizeof(mpi));


	mpi.dwFlags = DP_FLAG_SEND | DP_FLAG_ACM | DP_FLAG_MMSYSTEM;
	mpi.cbOffsetNetData = sizeof(RTP_HDR);
	mpi.cbSizeNetData = m_dwDstSize;
	mpi.cbSizeDevData = m_dwFrameSize;
	mpi.cbSizeRawData = m_dwFrameSize;
	mpi.pDevFmt = &m_wfPCM;
	mpi.pStrmConvSrcFmt = &m_wfPCM;
	mpi.payload = audChannelParams.RTP_Payload;
	mpi.pStrmConvDstFmt = &m_wfCompressed;

	hr = CreateAudioPackets(&mpi);
	if (FAILED(hr))
	{
		m_pAudioFilter->Close();
		return hr;
	}

	AudioFile::OpenSourceFile(&m_mmioSrc, &m_wfPCM);

	m_pDTMF->Initialize(&m_wfPCM);
	m_pDTMF->ClearQueue();


	// Initialize RSVP structures
	InitAudioFlowspec(&m_flowspec, pwfSend, m_dwDstSize);


	// Initialize QOS structures
	if (m_pDP->m_pIQoS)
	{
		// Initialize our requests. One for CPU usage, one for bandwidth usage.
		m_aRRq.cResourceRequests = 2;
		m_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
		if (m_dwFrameTimeMS)
		{
			m_aRRq.aResourceRequest[0].nUnitsMin = (DWORD)(m_dwDstSize + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) * 8000 / m_dwFrameTimeMS;
		}
		else
		{
			m_aRRq.aResourceRequest[0].nUnitsMin = 0;
		}
		m_aRRq.aResourceRequest[1].resourceID = RESOURCE_CPU_CYCLES;
		m_aRRq.aResourceRequest[1].nUnitsMin = 800;

//      BUGBUG. This is, in theory the correct calculation, but until we do more investigation, go with a known value
//		m_aRRq.aResourceRequest[1].nUnitsMin = (audDetails.wCPUUtilizationEncode+audDetails.wCPUUtilizationDecode)*10;

		// Initialize QoS structure
		ZeroMemory(&m_Stats, sizeof(m_Stats));

		// Initialize oldest QoS callback timestamp
		// Register with the QoS module. Even if this call fails, that's Ok, we'll do without the QoS support
		
		// The Callback is defined in SendAudioStream
		m_pDP->m_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq, SendAudioStream::QosNotifyAudioCB, (DWORD_PTR)this);
	}



	// Initialize Statview constats
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->wFormatTag, REP_SEND_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nSamplesPerSec, REP_SEND_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nAvgBytesPerSec * 8, REP_SEND_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Send Format: %s", (pwfSend->wFormatTag == 66) ? "G723.1" : (pwfSend->wFormatTag == 112) ? "LHCELP" : (pwfSend->wFormatTag == 113) ? "LHSB08" : (pwfSend->wFormatTag == 114) ? "LHSB12" : (pwfSend->wFormatTag == 115) ? "LHSB16" : (pwfSend->wFormatTag == 6) ? "MSALAW" : (pwfSend->wFormatTag == 7) ? "MSULAW" : (pwfSend->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Send Sampling Rate (Hz): %ld", pwfSend->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Send Bitrate (w/o network overhead - bps): %ld", pwfSend->nAvgBytesPerSec*8));

	UPDATE_REPORT_ENTRY(g_prptCallParameters, m_dwSamplesPerFrame, REP_SEND_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Send Packetization (ms/packet): %ld", pwfSend->nSamplesPerSec ? m_dwSamplesPerFrame * 1000UL / pwfSend->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioSendBytes, (pwfSend->nAvgBytesPerSec + pwfSend->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / m_dwSamplesPerFrame) << 3);

	m_DPFlags |= DPFLAG_CONFIGURED_SEND;
	return S_OK;
}

void SendDSCStream::UnConfigure()
{
	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		Stop();

		m_pAudioFilter->Close();
		ReleaseAudioPackets();

		AudioFile::CloseSourceFile(&m_mmioSrc);

		m_ThreadFlags = 0;

		if (m_pDP->m_pIQoS)
		{
			m_pDP->m_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq);
		}

		m_DPFlags &= ~DPFLAG_CONFIGURED_SEND;

	}
}


DWORD CALLBACK SendDSCStream::StartRecordingThread (LPVOID pVoid)
{
	SendDSCStream *pThisStream = (SendDSCStream*)pVoid;
	return pThisStream->RecordingThread();
}


HRESULT STDMETHODCALLTYPE
SendDSCStream::Start()
{
	FX_ENTRY ("SendDSCStream::Start")

	if (m_DPFlags & DPFLAG_STARTED_SEND)
		return DPR_SUCCESS;

	if (!(m_DPFlags & DPFLAG_ENABLE_SEND))
		return DPR_SUCCESS;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
		return DPR_NOT_CONFIGURED;

	ASSERT(!m_hCapturingThread);
	m_ThreadFlags &= ~(DPTFLAG_STOP_RECORD|DPTFLAG_STOP_SEND);

	SetFlowSpec();

	// Start recording thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		m_hCapturingThread = CreateThread(NULL,0, SendDSCStream::StartRecordingThread,(LPVOID)this,0,&m_CaptureThId);

	m_DPFlags |= DPFLAG_STARTED_SEND;

	DEBUGMSG (ZONE_DP, ("%s: Record threadid=%x,\r\n", _fx_, m_CaptureThId));
	return DPR_SUCCESS;
}

HRESULT
SendDSCStream::Stop()
{											
	DWORD dwWait;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return DPR_SUCCESS;
	}
	
	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_SEND |  DPTFLAG_STOP_RECORD ;

	
	DEBUGMSG (ZONE_DP, ("SendDSCStream::Stop - Waiting for record thread to exit\r\n"));

	if (m_hCapturingThread)
	{
		dwWait = WaitForSingleObject (m_hCapturingThread, INFINITE);

		DEBUGMSG (ZONE_DP, ("SendDSCStream::Stop: Recording thread exited\r\n"));
		ASSERT(dwWait != WAIT_FAILED);
	
		CloseHandle(m_hCapturingThread);
		m_hCapturingThread = NULL;
	}
	m_DPFlags &= ~DPFLAG_STARTED_SEND;
	
	return DPR_SUCCESS;
}


HRESULT STDMETHODCALLTYPE SendDSCStream::SetMaxBitrate(UINT uMaxBitrate)
{
	return S_OK;
}


HRESULT STDMETHODCALLTYPE SendDSCStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((SendMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((SendMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IDTMFSend)
	{
		*ppVoid = (IDTMFSend*)this;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE SendDSCStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE SendDSCStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}

HRESULT STDMETHODCALLTYPE SendDSCStream::GetSignalLevel(UINT *pSignalStrength)
{
	UINT uLevel;
	DWORD dwJammed;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		uLevel = 0;
	}
	else
	{
		uLevel = m_AudioMonitor.GetSignalStrength();

		if (m_bJammed)
		{
			uLevel = (2 << 16);  // 0x0200
		}
		else if (m_fSending)
		{
			uLevel |= (1 << 16); // 0x0100 + uLevel
		}
	}

	*pSignalStrength = uLevel;
	return S_OK;


	return 0;
}

HRESULT STDMETHODCALLTYPE SendDSCStream::GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf)
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD dwValue;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (dwProp)
    {

	case PROP_SILENCE_LEVEL:
		*(DWORD *)pBuf = m_AudioMonitor.GetSilenceLevel();
		break;

	case PROP_DUPLEX_TYPE:
		if(m_bFullDuplex == TRUE)
			*(DWORD*)pBuf = DUPLEX_TYPE_FULL;
		else
			*(DWORD*)pBuf =	DUPLEX_TYPE_HALF;
		break;

	case PROP_RECORD_ON:
		*(DWORD *)pBuf = (m_DPFlags & DPFLAG_ENABLE_SEND) !=0;
		break;

	case PROP_PAUSE_SEND:
		// To be determined
		break;

	case PROP_AUDIO_AUTOMIX:
		*(DWORD*)pBuf = m_bAutoMix;
		break;

	case PROP_RECORD_DEVICE:
		*(DWORD *)pBuf = m_CaptureDevice;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}


HRESULT STDMETHODCALLTYPE SendDSCStream::SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf)
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (dwProp)
    {
	case PROP_SILENCE_LEVEL:
		m_AudioMonitor.SetSilenceLevel(*(DWORD *)pBuf);
		break;


	case DP_PROP_DUPLEX_TYPE:
		m_bFullDuplex = (*(DWORD*)pBuf != 0);
		break;


	case PROP_AUDIO_AUTOMIX:
		m_bAutoMix = *(DWORD*)pBuf;
		break;


	case PROP_RECORD_DEVICE:
		m_CaptureDevice = *(DWORD*)pBuf;
		RETAILMSG(("NAC: Setting default record device to %d", m_CaptureDevice));
		break;

	case PROP_RECORD_ON:
	{
		DWORD flag = DPFLAG_ENABLE_SEND ;
		if (*(DWORD *)pBuf)
		{
			m_DPFlags |= flag; // set the flag
			Start();
		}
		else
		{
			m_DPFlags &= ~flag; // clear the flag
			Stop();
		}
		RETAILMSG(("DSCStream: %s", *(DWORD*)pBuf ? "Enabling Stream":"Pausing stream"));
		break;
	}	

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;



}



void SendDSCStream::EndSend()
{
	return;
}



HRESULT SendDSCStream::CreateAudioPackets(MEDIAPACKETINIT *pmpi)
{
	int nIndex;
	HRESULT hr;

	ReleaseAudioPackets();

	for (nIndex = 0; nIndex < NUM_AUDIOPACKETS; nIndex++)
	{
        DBG_SAVE_FILE_LINE
		m_aPackets[nIndex] = new AudioPacket;
		if (m_aPackets[nIndex] == NULL)
		{
			return DPR_OUT_OF_MEMORY;
		}

		pmpi->index = nIndex;
		hr = m_aPackets[nIndex]->Initialize(pmpi);
		if (FAILED(hr))
		{
			ReleaseAudioPackets();
			return hr;
		}

	}

	m_pAudioFilter->PrepareAudioPackets(m_aPackets, NUM_AUDIOPACKETS, AP_ENCODE);


	return S_OK;
}


HRESULT SendDSCStream::ReleaseAudioPackets()
{


	for (int nIndex = 0; nIndex < NUM_AUDIOPACKETS; nIndex++)
	{
		if (m_aPackets[nIndex])
		{
			m_pAudioFilter->UnPrepareAudioPackets(&m_aPackets[nIndex], 1, AP_ENCODE);
			delete m_aPackets[nIndex];
			m_aPackets[nIndex] = NULL;
		}
	}
	return S_OK;
}


HRESULT SendDSCStream::CreateDSCBuffer()
{
	GUID guid = GUID_NULL;
	HRESULT hr;
	DSCBUFFERDESC dsBufDesc;
	DWORD dwIndex;
	DSBPOSITIONNOTIFY *aNotifyPos;
	IDirectSoundNotify *pNotify = NULL;


	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
	{
		return E_FAIL;
	}


	if (!m_pDSC)
	{
		ASSERT(m_pDSCBuffer==NULL);

		DSC_Manager::MapWaveIdToGuid(m_CaptureDevice, &guid);
		hr = DSC_Manager::CreateInstance(&guid, &m_pDSC);
		if (FAILED(hr))
		{
			return hr;
		}
	}

	if (!m_pDSCBuffer)
	{
		ZeroMemory(&dsBufDesc, sizeof(dsBufDesc));

		dsBufDesc.dwBufferBytes = m_dwDSCBufferSize;
		dsBufDesc.lpwfxFormat = &m_wfPCM;
		dsBufDesc.dwSize = sizeof(dsBufDesc);

		hr = m_pDSC->CreateCaptureBuffer(&dsBufDesc, &m_pDSCBuffer, NULL);
		if (FAILED(hr))
		{
			dsBufDesc.dwFlags = DSCBCAPS_WAVEMAPPED;
			hr = m_pDSC->CreateCaptureBuffer(&dsBufDesc, &m_pDSCBuffer, NULL);
		}

		if (FAILED(hr))
		{
			m_pDSC->Release();
			m_pDSC = NULL;
			return hr;
		}
		else
		{
			// do the notification positions
            DBG_SAVE_FILE_LINE
			aNotifyPos = new DSBPOSITIONNOTIFY[m_dwNumFrames];
			for (dwIndex = 0; dwIndex < m_dwNumFrames; dwIndex++)
			{
				aNotifyPos[dwIndex].hEventNotify = m_hEvent;
				aNotifyPos[dwIndex].dwOffset = m_dwFrameSize * dwIndex;
			}

			hr = m_pDSCBuffer->QueryInterface(IID_IDirectSoundNotify, (void**)&pNotify);
			if (SUCCEEDED(hr))
			{
				hr = pNotify->SetNotificationPositions(m_dwNumFrames, aNotifyPos);
			}
			if (FAILED(hr))
			{
				DEBUGMSG (ZONE_DP, ("Failed to set notification positions on DSC Buffer"));
			}
		}
	}

	if (aNotifyPos)
	{
		delete [] aNotifyPos;
	}
	if (pNotify)
	{
		pNotify->Release();
	}

	return S_OK;
}

HRESULT SendDSCStream::ReleaseDSCBuffer()
{
	if (m_pDSCBuffer)
	{
		m_pDSCBuffer->Stop();
		m_pDSCBuffer->Release();
		m_pDSCBuffer = NULL;
	}
	if (m_pDSC)
	{
		m_pDSC->Release();
		m_pDSC = NULL;
	}

	return S_OK;
}





// DTMF functions don't do anything if we aren't streaming
HRESULT __stdcall SendDSCStream::AddDigit(int nDigit)
{
	IMediaChannel *pIMC = NULL;
	RecvMediaStream *pRecv = NULL;
	BOOL bIsStarted;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
	{
		return DPR_NOT_CONFIGURED;
	}

	bIsStarted = (m_DPFlags & DPFLAG_STARTED_SEND);

	if (bIsStarted)
	{
		Stop();
	}

	m_pDTMF->AddDigitToQueue(nDigit);
	SendDTMF();

	m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
	if (pIMC)
	{
		pRecv = static_cast<RecvMediaStream *> (pIMC);
		pRecv->DTMFBeep();
		pIMC->Release();
	}

	if (bIsStarted)
	{
		Start();
	}

	return S_OK;
}


// this function is ALMOST identical to SendAudioStream::SendDTMF
HRESULT __stdcall SendDSCStream::SendDTMF()
{
	HRESULT hr=S_OK;
	MediaPacket *pPacket=NULL;
	ULONG uCount;
	UINT uBufferSize, uBytesSent;
	void *pBuffer;
	bool bMark = true;
	MMRESULT mmr;
	HANDLE hEvent = m_pDTMF->GetEvent();
	UINT uTimerID;
	
	// since the stream is stopped, just grab any packet
	// from the packet ring

	pPacket = m_aPackets[0];
	pPacket->GetDevData(&pBuffer, &uBufferSize);

	timeBeginPeriod(5);
	ResetEvent(hEvent);
	uTimerID = timeSetEvent(m_dwFrameTimeMS-1, 5, (LPTIMECALLBACK )hEvent, 0, TIME_CALLBACK_EVENT_SET|TIME_PERIODIC);


	hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);


	while (SUCCEEDED(hr))
	{
		// there should be only 1 tone in the queue (it can handle more)
		// so assume we only need to set the mark bit on the first packet

		pPacket->m_fMark = bMark;
		bMark = false;

		pPacket->SetProp(MP_PROP_TIMESTAMP, m_SendTimestamp);
		m_SendTimestamp += m_dwSamplesPerFrame;

		pPacket->SetState (MP_STATE_RECORDED);

		// SendPacket will also compress
		SendPacket((AudioPacket*)pPacket);

		pPacket->m_fMark=false;
		pPacket->SetState(MP_STATE_RESET);

		hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);


		// so that we don't overload the receive jitter buffer on the remote
		// side, sleep a few milliseconds between sending packets
		if (SUCCEEDED(hr))
		{
			WaitForSingleObject(hEvent, m_dwFrameTimeMS);
			ResetEvent(hEvent);
		}
	}

	timeKillEvent(uTimerID);
	timeEndPeriod(5);
	return S_OK;
}

HRESULT __stdcall SendDSCStream::ResetDTMF()
{
	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return S_OK;
	}

	return m_pDTMF->ClearQueue();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dscthread.cpp ===
#include "precomp.h"
#include "datapump.h"
#include "DSCStream.h"
#include "agc.h"


static const int DSC_TIMEOUT = 1000;
static const int DSC_MAX_LAG = 500;

static const int DSC_SUCCESS =			0;
static const int DSC_NEED_TO_EXIT =		1;
static const int DSC_FRAME_SENT =		2;
static const int DSC_SILENCE_DETECT	=	3;
static const int DSC_ERROR =			4;

static const int SILENCE_TIMEOUT=	600; // milliseconds

static const int HEADER_SIZE = 	sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;


static const UINT DSC_QOS_INITIALIZE = 100;
static const UINT DSC_QOS_PACKET_SENT = 101;

static inline UINT QMOD(const int x, const int mod)
{
	if (x >= mod)
		return (x-mod);
	if (x < 0)
		return (x+mod);
	else
		return x;
}


BOOL SendDSCStream::UpdateQosStats(UINT uStatType, UINT uStatValue1, UINT uStatValue2)
{
	EnterCriticalSection(&m_crsQos);

	switch (uStatType)
	{
		case DSC_QOS_INITIALIZE:
		{
			m_Stats.dwMsCap = m_Stats.dwMsComp = m_Stats.dwBits = m_Stats.dwCount = 0;
			m_Stats.dwNewestTs = m_Stats.dwOldestTs = timeGetTime();
			break;
		}

		case DSC_QOS_PACKET_SENT:
		{
			// uStatvalue1 is the CPU time, uStatvalue2 is the size in bytes
			m_Stats.dwCount++;
			m_Stats.dwMsComp += uStatValue1;
			m_Stats.dwBits += (uStatValue2) * 8;

			// statview really wants bits per second
		   	UPDATE_COUNTER(g_pctrAudioSendBytes, uStatValue2*8);
			break;
		}

	};

	LeaveCriticalSection(&m_crsQos);
	return TRUE;
}

inline BOOL SendDSCStream::ThreadExitCheck()
{
	return (m_ThreadFlags & DPTFLAG_STOP_RECORD);
}


// resyncs the Timestamp with the last known timestamp

inline void SendDSCStream::UpdateTimestamp()
{
	UINT uTime;
	uTime = (timeGetTime() - m_SavedTickCount)*((m_wfPCM.nSamplesPerSec)/1000);
//	if (uTime < 0)
//		uTime = 0;

	m_SendTimestamp += uTime;
}


// WaitForControl - Thread Function
// opens the DirectSound device or waits for it to become available
// returns either DSC_SUCCESS or DSC_NEED_TO_EXIT
DWORD SendDSCStream::WaitForControl()
{
	DWORD dwRet;
	HRESULT hr=E_FAIL;

	while (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
	{
		if (m_bFullDuplex == FALSE)
		{
			dwRet = WaitForSingleObject(g_hEventHalfDuplex, 1000);
			if (dwRet == WAIT_TIMEOUT)
				continue;
		}

		hr = CreateDSCBuffer();
		if (FAILED(hr))
		{
			m_nFailCount++;
			Sleep(2000); // wait and try again
			hr = CreateDSCBuffer();
		}
		if (SUCCEEDED(hr))
		{
			break;
		}

		m_nFailCount++;
		if ((m_nFailCount >= MAX_FAILCOUNT) && m_bCanSignalFail)
		{
			m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
			m_bCanSignalOpen = TRUE;
			m_bCanSignalFail = FALSE; // don't signal failure more than once
			m_bJammed = TRUE;
		}

		// if we can't open the device, even after being signaled
		// then yield some time to playback in hopes that it becomes available again

		// check the thread flags again such so that we don't
		// hold up the client for too long when he calls Stop()
		if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		{
			SetEvent(g_hEventHalfDuplex);
			Sleep(2000);
		}
	}

	if (m_ThreadFlags & DPTFLAG_STOP_RECORD)
	{
		return DSC_NEED_TO_EXIT;
	}

	m_bJammed = FALSE;
	m_nFailCount = 0;
	m_bCanSignalFail = TRUE;
	if (m_bCanSignalOpen)
	{
		m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
		m_bCanSignalOpen = FALSE; // don't signal more than once per session
	}

	return DSC_SUCCESS;
}


// YieldControl is a thread function
// It releases the DirectSound device
// and signals the half duplex event
DWORD SendDSCStream::YieldControl()
{
	ReleaseDSCBuffer();
	SetEvent(g_hEventHalfDuplex);

	if (m_ThreadFlags & DPTFLAG_STOP_RECORD)
	{
		return DSC_NEED_TO_EXIT;
	}

	// half duplex yielding
	// playback has 100ms to grab device otherwise we take it back
	Sleep(100);
	return DSC_SUCCESS;
}



// ProcessFrame is a thread function
// Given a position in the DirectSoundCapture buffer,
// it will apply silence detection to the frame, and send it if
// appropriate
// returns DSC_FRAME_SENT or DSC_SILENCE_DETECT

DWORD SendDSCStream::ProcessFrame(DWORD dwBufferPos, BOOL fMark)
{
	HRESULT hr;
	DWORD dwSize1=0, dwSize2=0, dwMaxStrength;
	WORD wPeakStrength;
	VOID *pBuf1=NULL, *pBuf2=NULL;
	void *pPacketBuffer = NULL;
	UINT uSize, uLength;
	AudioPacket *pAP = m_aPackets[0];
	BOOL fSilent, bRet;


	pAP->GetDevData(&pPacketBuffer, &uSize);
	pAP->SetProp(MP_PROP_TIMESTAMP,m_SendTimestamp);
	pAP->m_fMark = fMark;

	ASSERT(uSize == m_dwFrameSize);

	// copy the frame out of the DSC buffer and into the packet object
	hr = m_pDSCBuffer->Lock(dwBufferPos, m_dwFrameSize, &pBuf1, &dwSize1, &pBuf2, &dwSize2, 0);
	if (SUCCEEDED(hr))
	{
		CopyMemory((BYTE*)pPacketBuffer, pBuf1, dwSize1);
		if (pBuf2 && dwSize2)
		{
			CopyMemory(((BYTE*)pPacketBuffer)+dwSize1, pBuf2, dwSize2);
		}
		m_pDSCBuffer->Unlock(pBuf1, dwSize2, pBuf2, dwSize2);

		pAP->SetState(MP_STATE_RECORDED);
	}
	else
	{
		DEBUGMSG (ZONE_DP, ("SendDSCStream::ProcessFrame - could not lock DSC buffer\r\n"));
		return DSC_ERROR;
	}

	if (m_mmioSrc.fPlayFromFile && m_mmioSrc.hmmioSrc)
	{
		AudioFile::ReadSourceFile(&m_mmioSrc, (BYTE*)pPacketBuffer, uSize);
	}


	// do silence detection
	pAP->ComputePower(&dwMaxStrength, &wPeakStrength);
	fSilent = m_AudioMonitor.SilenceDetect((WORD)dwMaxStrength);

	if (fSilent)
	{
		m_dwSilenceTime += m_dwFrameTimeMS;
		if (m_dwSilenceTime < SILENCE_TIMEOUT)
		{
			fSilent = FALSE;
		}
	}
	else
	{
		m_dwSilenceTime = 0;

		// only do automix on packets above the silence threshold
		if (m_bAutoMix)
		{
			m_agc.Update(wPeakStrength, m_dwFrameTimeMS);
		}
	}



	m_fSending = !(fSilent);  // m_fSending indicates that we are transmitting

	if (fSilent)
	{
		// we don't send this packet, but we do cache it because
		// if the next one get's sent, we send this one too.
		ASSERT(pAP == m_aPackets[0]);

		// swap the audio packets
		// m_aPackets[1] always holds a cached packet
		pAP = m_aPackets[0];
		m_aPackets[0] = m_aPackets[1];
		m_aPackets[1] = pAP;
		pAP = m_aPackets[0];
		return DSC_SILENCE_DETECT;
	}


	// the packet is valid. send it, and maybe the one before it
	Send();

	return DSC_FRAME_SENT;
}


// this function is called by process frame (thread function)
// sends the current packet, and maybe any packet prior to it.
// returns the number of packets sent
DWORD SendDSCStream::Send()
{
	DWORD dwTimestamp0, dwTimestamp1;
	DWORD dwState0, dwState1;
	DWORD dwCount=0;
	MMRESULT mmr;
	HRESULT hr;

	// we know we have to send m_aPackets[0], and maybe m_aPackets[1]
	// we send m_aPackets[1] if it is actually the beginning of this talk spurt

	dwTimestamp0 = m_aPackets[0]->GetTimestamp();
	dwTimestamp1 = m_aPackets[1]->GetTimestamp();
	dwState0 = m_aPackets[0]->GetState();
	dwState1 = m_aPackets[1]->GetState();


	ASSERT(dwState0 == MP_STATE_RECORDED);

	if (dwState0 != MP_STATE_RECORDED)
		return 0;

	// evaluate if we need to send the prior packet
	if (dwState1 == MP_STATE_RECORDED)
	{
		if ((dwTimestamp1 + m_dwFrameTimeMS) == dwTimestamp0)
		{
			m_aPackets[1]->m_fMark = TRUE;   // set the mark bit on the first packet
			m_aPackets[0]->m_fMark = FALSE;  // reset the mark bit on the next packet
			hr = SendPacket(m_aPackets[1]);
			if (SUCCEEDED(hr))
			{
				dwCount++;
			}
		}
		else
		{
			m_aPackets[1]->SetState(MP_STATE_RESET);
		}
	}

	hr = SendPacket(m_aPackets[0]);
	if (SUCCEEDED(hr))
		dwCount++;

	return dwCount;

}

// thread function called by Send.  Sends a packet to RTP.
HRESULT SendDSCStream::SendPacket(AudioPacket *pAP)
{
	MMRESULT mmr;
	PS_QUEUE_ELEMENT psq;
	UINT uLength;
	UINT uEncodeTime;

	uEncodeTime = timeGetTime();
	mmr = m_pAudioFilter->Convert(pAP, AP_ENCODE);
	uEncodeTime = timeGetTime() - uEncodeTime;

	if (mmr == MMSYSERR_NOERROR)
	{
		pAP->SetState(MP_STATE_ENCODED);  // do we need to do this ?

		psq.pMP = pAP;
		psq.dwPacketType = PS_AUDIO;
		psq.pRTPSend = m_pRTPSend;
		pAP->GetNetData((void**)(&(psq.data)), &uLength);
		ASSERT(psq.data);
		psq.dwSize = uLength;
		psq.fMark = pAP->m_fMark;
		psq.pHeaderInfo = NULL;
		psq.dwHdrSize = 0;
		m_pDP->m_PacketSender.m_SendQueue.PushFront(psq);
		while (m_pDP->m_PacketSender.SendPacket())
		{
			;
		}


		UpdateQosStats(DSC_QOS_PACKET_SENT, uEncodeTime, uLength+HEADER_SIZE);
	}

	pAP->SetState(MP_STATE_RESET);

	return S_OK;
}


DWORD SendDSCStream::RecordingThread()
{
	HRESULT hr;
	DWORD dwWaitTime = DSC_TIMEOUT; // one sec
	DWORD dwRet, dwReadPos, dwCapPos;
	DWORD dwFirstValidFramePos, dwLastValidFramePos, dwNumFrames;
	DWORD dwLag, dwMaxLag, dwLagDiff;
	DWORD dwNextExpected, dwCurrentFramePos, dwIndex;
	BOOL bNeedToYield;
	BOOL fMark;
	IMediaChannel *pIMC = NULL;
	RecvMediaStream *pRecv = NULL;
	CMixerDevice *pMixer = NULL;


	// initialize recording thread
	m_SendTimestamp = timeGetTime();
	m_SavedTickCount = 0;

	m_fSending = TRUE;
	m_bJammed = FALSE;
	m_nFailCount = 0;
	m_bCanSignalOpen = TRUE;
	m_bCanSignalFail = TRUE;

	UpdateQosStats(DSC_QOS_INITIALIZE, 0, 0);
	SetThreadPriority(m_hCapturingThread, THREAD_PRIORITY_HIGHEST);

	// automix object
	pMixer = CMixerDevice::GetMixerForWaveDevice(NULL, m_CaptureDevice, MIXER_OBJECTF_WAVEIN);
	m_agc.SetMixer(pMixer);  // if pMixer is NULL, then it's still ok
	m_agc.Reset();

	LOG((LOGMSG_DSC_STATS, m_dwDSCBufferSize, m_dwFrameSize));

	while (!(ThreadExitCheck()))
	{
		dwRet = WaitForControl();
		if (dwRet == DSC_NEED_TO_EXIT)
		{
			break;
		}

		hr = m_pDSCBuffer->Start(DSCBSTART_LOOPING);
		if (FAILED(hr))
		{
			// ERROR!  We expected this call to succeed
			YieldControl();
			Sleep(1000);
			continue;
		}

		ResetEvent(m_hEvent);
		m_pDSCBuffer->GetCurrentPosition(&dwCapPos, &dwReadPos);


		// set the next expected position to be on the next logical
		// frame boundary up from where it is now

		dwNextExpected = QMOD(m_dwFrameSize + (dwReadPos / m_dwFrameSize) * m_dwFrameSize, m_dwDSCBufferSize);

		dwMaxLag = (m_dwNumFrames/2) * m_dwFrameSize;

		m_dwSilenceTime = 0;
		bNeedToYield = FALSE;
		fMark = TRUE;

		UpdateTimestamp();


		while( (bNeedToYield == FALSE) && (!(ThreadExitCheck())) )
		{
			dwRet = WaitForSingleObject(m_hEvent, dwWaitTime);

			LOG((LOGMSG_DSC_TIMESTAMP, timeGetTime()));

			m_pDSCBuffer->GetCurrentPosition(&dwCapPos, &dwReadPos);

			LOG((LOGMSG_DSC_GETCURRENTPOS, dwCapPos, dwReadPos));

			if (dwRet == WAIT_TIMEOUT)
			{
				DEBUGMSG(ZONE_DP, ("DSCThread.cpp: Timeout on the DSC Buffer has occurred.\r\n"));
				LOG((LOGMSG_DSC_LOG_TIMEOUT));
				dwNextExpected = QMOD(m_dwFrameSize + (dwReadPos / m_dwFrameSize) * m_dwFrameSize, m_dwDSCBufferSize);
				continue;
			}

			dwLag = QMOD(dwReadPos - dwNextExpected, m_dwDSCBufferSize);

			if (dwLag > dwMaxLag)
			{

				// we got here because of one of two conditions

				// 1. WaitFSO above returned earlier than expected.
				// This can happen when the previous interation of
				// the loop has sent multiple packets.  The read cursor
				// is most likely only within one frame behind the expected
				// cursor.

				// In this cases, just keep Waiting for the current
				// read position to (dwReadPos) "catch up" to dwNextExpected


				// 2. A huge delay or something really bad. ("burp")
				// we could simply continue waiting for the read position
				// to catch up to dwNextExpected, but it's probably better
				// to reposition dwNextExpected so that we don't wait
				// too long before sending a frame again
			
				dwLagDiff = QMOD((dwLag + m_dwFrameSize), m_dwDSCBufferSize);
				if (dwLagDiff < m_dwFrameSize)
				{
					LOG((LOGMSG_DSC_EARLY));
					// only lagging behind by one frame
					// WaitFSO probably returned early
					;
				}
				else
				{
					LOG((LOGMSG_DSC_LAGGING, dwLag, dwNextExpected));

					// consider repositioning dwNextExpected, advancing
					// m_SendTimeStamp, and setting fMark if this condition
					// happens a lot
				}

				continue;
			}

	
			dwFirstValidFramePos = QMOD(dwNextExpected - m_dwFrameSize, m_dwDSCBufferSize);
			dwLastValidFramePos = (dwReadPos / m_dwFrameSize) * m_dwFrameSize;
			dwNumFrames = QMOD(dwLastValidFramePos - dwFirstValidFramePos, m_dwDSCBufferSize) / m_dwFrameSize;
			dwCurrentFramePos = dwFirstValidFramePos;

			LOG((LOGMSG_DSC_SENDING, dwNumFrames, dwFirstValidFramePos, dwLastValidFramePos));

			for (dwIndex = 0; dwIndex < dwNumFrames; dwIndex++)
			{
				m_SendTimestamp += m_dwSamplesPerFrame; // increment in terms of samples

				// Send The data
				dwRet = ProcessFrame(dwCurrentFramePos, fMark);

				dwCurrentFramePos = QMOD(dwCurrentFramePos + m_dwFrameSize, m_dwDSCBufferSize);

				if (dwRet == DSC_FRAME_SENT)
				{
					fMark = FALSE;
				}

				else if ((dwRet == DSC_SILENCE_DETECT) && (m_bFullDuplex == FALSE))
				{
					m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
					fMark = TRUE;

					if (pIMC)
					{
						pRecv = static_cast<RecvMediaStream *> (pIMC);
						if (pRecv->IsEmpty() == FALSE)
						{
							bNeedToYield = TRUE;
						}
						pIMC->Release();
						pIMC = NULL;
						if (bNeedToYield)
						{
							break;
						}
					}
				}

				else
				{
					fMark = TRUE;
				}
			}

			dwNextExpected = QMOD(dwLastValidFramePos + m_dwFrameSize, m_dwDSCBufferSize);

			if (bNeedToYield)
			{
				YieldControl();
				m_SavedTickCount = timeGetTime();
			}
		} // while (!bNeedToYield)
	} // while (!ThreadExitCheck())

	// time to exit
	YieldControl();



	delete pMixer;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dsstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medistrm.h

Abstract:
	Contains constants and class declarations for the abstract MediaStream object. A MediaStream
	represents a single unidirectional stream, such as a received Video channel.
	
--*/
#ifndef _DSSTREAM_H_
#define _DSSTREAM_H_

class DataPump;

#include <pshpack8.h> /* Assume 8 byte packing throughout */

struct DSINFO;
extern GUID myNullGuid;	// a zero guid

typedef HRESULT (WINAPI *LPFNDSCREATE)(const GUID * , LPDIRECTSOUND * , IUnknown FAR * );
typedef HRESULT (WINAPI *LPFNDSENUM)(LPDSENUMCALLBACK , LPVOID  );

class DirectSoundMgr {
	public:
	static HRESULT Initialize();
	static HRESULT MapWaveIdToGuid(UINT waveId, GUID *pGuid);	// kludge!!
	static HRESULT Instance(LPGUID pDeviceGuid,LPDIRECTSOUND *ppDS, HWND hwnd, WAVEFORMATEX *pwf);
	static HRESULT ReleaseInstance(LPDIRECTSOUND pDS);
	static HRESULT UnInitialize();
	
	private:
	static HINSTANCE m_hDS;						// handle to DSOUND.DLL
	static LPFNDSCREATE m_pDirectSoundCreate;	// used for dynamic linking to DSOUND.DLL
	static LPFNDSENUM m_pDirectSoundEnumerate;	// used for dynamic linking
	static BOOL __stdcall DSEnumCallback(LPGUID, LPCSTR, LPCSTR, LPVOID);
	static DSINFO *m_pDSInfoList;
	static BOOL m_fInitialized ;
};

class DSTimeout : public TTimeout {
public:
	void SetDSStream(class RecvDSAudioStream *pDSS) {m_pRDSStream = pDSS;}
protected:
	class RecvDSAudioStream *m_pRDSStream;
	
	virtual void TimeoutIndication();
};

class RecvDSAudioStream : public RecvMediaStream, public IAudioChannel {
	friend class DataPump;
	friend BOOL RTPRecvDSCallback(DWORD ,WSABUF * );
private:
	WAVEFORMATEX m_fDevRecv;
	CRITICAL_SECTION m_crsAudQoS; // Allows QoS thread to read the audio statistics while recording and compression are running

	BOOL m_fEmpty;
	DWORD m_NextTimeT;
	DWORD m_BufSizeT;
	DWORD m_NextPosT;
	DWORD m_PlayPosT;
	DWORD m_SilenceDurationT;	// tracks "silence" periods in the received stream
	// used for adaptive delay calculations
	DWORD m_DelayT;
	DWORD m_MinDelayT;			// constant lower limit on playback delay
	DWORD m_MaxDelayT;			// constant upper limit on playback delay
	DWORD m_ArrT;				// local (pseudo)timestamp
	DWORD m_SendT0;             // m_SendT0 is the send timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	DWORD m_ArrivalT0;          // m_ArrivalT0 is the arrival timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	LONG m_ScaledAvgVarDelay;   // Average Variable Delay according to m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16). This is the m_DelayPos jitter.
	int m_nFailCount;           // number of consecutive times the device failed to open


	GUID m_DSguid;
	LPDIRECTSOUND m_pDS;
	LPDIRECTSOUNDBUFFER m_pDSBuf;
	DSBUFFERDESC m_DSBufDesc;
	DWORD m_DSFlags;			// from DSCAPS.dwFlags

	AcmFilter *m_pAudioFilter;
	ACMSTREAMHEADER m_StrmConvHdr;
	HANDLE m_hStrmConv;
	DSTimeout m_TimeoutObj;
	AudioSilenceDetector m_AudioMonitor;

	BOOL m_bJammed;
	BOOL m_bCanSignalOpen;
	
	// Non virtual methods
	void UpdateVariableDelay(DWORD timestamp, DWORD curPlayT);
	DWORD GetSignalStrength();
	HRESULT CreateDSBuffer();
	HRESULT ReleaseDSBuffer();
	HRESULT Decode(UCHAR *pData, UINT cbData);
	HRESULT PlayBuf(DWORD timestamp, UINT seq, BOOL fMark);

	LONG m_lRefCount;
	
public:	
	RecvDSAudioStream() :RecvMediaStream() {m_Net=NULL; m_lRefCount=0; m_TimeoutObj.SetDSStream(this);};
	~RecvDSAudioStream();

	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);


	// IMediaChannel APIs
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);
	STDMETHODIMP_(void) UnConfigure(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return RecvMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState() 
	{
		return RecvMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate)
	{
		return E_NOTIMPL;
	}

	// IAudioChannel
	STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);


    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// Other virtual inherited methods
	virtual HRESULT Initialize(DataPump *);
	virtual BOOL IsEmpty();
	HRESULT GetCurrentPlayNTPTime(NTP_TS *);
    virtual HRESULT StartRecv(HWND);
    virtual HRESULT StopRecv();

	HRESULT DTMFBeep();
	HRESULT OnDTMFBeep();


	void 	RecvTimeout();

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark);
};


#include <poppack.h> /* End byte packing */


#endif // _MEDISTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dtmf.h ===
#ifndef NAC_DTMF_H
#define NAC_DTMF_H


class DTMFQueue
{
private:
	BYTE **m_aTones; // array of tone signals
	bool m_bInitialized;
	WAVEFORMATEX m_WaveFormat;
	CRITICAL_SECTION m_cs;
	HANDLE m_hEvent;


	void ReleaseToneBank();

	void AddSignal(BYTE *pTone, int nFrequency, double dAmp, int nLength);
	void CreateDTMFTone(BYTE *pTone, int nToneLength, int toneID);
	HRESULT GenerateTones(WAVEFORMATEX *pWaveFormat);


	struct DTMF_TX_ELEMENT
	{
		int nToneID;
		int nBytesToCopy;
		int nOffsetStart;
	};

#define DTMF_QUEUE_SIZE	100
	DTMF_TX_ELEMENT m_aTxQueue[DTMF_QUEUE_SIZE];
	int m_nQueueHead;
	int m_nQueueLength;

public:
	DTMFQueue();
	~DTMFQueue();

	HRESULT Initialize(WAVEFORMATEX *pWaveFormat);
	HRESULT ReadFromQueue(BYTE *pBuffer, UINT uSize);
	HRESULT ClearQueue();
	HRESULT AddDigitToQueue(int nDigit);
	HANDLE GetEvent() {return m_hEvent;}
};



// default length of the DTMF feedback beep (in ms)
#define DTMF_FEEDBACK_BEEP_MS	64


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\nac\dsstream.cpp ===
#include "precomp.h"
#include <nmdsprv.h>

//bytes <-> PCM16 samples
inline UINT BYTESTOSAMPLES(UINT bytes) { return bytes/2;}
inline UINT SAMPLESTOBYTES(UINT samples) {return samples*2;}
// 'quick' modulo operator. reason its quick is because it only works if  -mod < x < 2*mod
inline UINT QMOD(const int x, const int mod)
{ 	if (x >= mod)
		return (x-mod);
	if (x < 0)
		return (x+mod);
	else
		return x;
}

#define BUFFER_RECEIVED 1		// used to indicate that the buffer is ready to play
#define BUFFER_SILENT	2		// buffer appears to be silent

#define DSFLAG_ALLOCATED 1

const int MIN_DSBUF_SIZE = 4000;

struct DSINFO {
	struct DSINFO *pNext;
	DWORD flags;
	GUID guid;
	LPSTR pszDescription;
	LPSTR pszModule;
	LPDIRECTSOUND pDS;
	LPDIRECTSOUNDBUFFER pDSPrimaryBuf;
	UINT uRef;
};

// initial all the globals
DSINFO *DirectSoundMgr::m_pDSInfoList = NULL;
BOOL DirectSoundMgr::m_fInitialized = FALSE;
HINSTANCE DirectSoundMgr::m_hDS = NULL;
LPFNDSCREATE DirectSoundMgr::m_pDirectSoundCreate=NULL;
LPFNDSENUM DirectSoundMgr::m_pDirectSoundEnumerate=NULL;

GUID myNullGuid = {0};

HRESULT DirectSoundMgr::Initialize()
{
	HRESULT hr;

	// currently there seems no need to re-enumerate the list of devices
	// but that can be changed if the need arises
	if (m_fInitialized)
		return (m_pDSInfoList == NULL ? DPR_NO_PLAY_CAP : S_OK);

	ASSERT(!m_pDSInfoList);
	m_hDS = ::LoadLibrary("DSOUND");
	if (m_hDS != NULL)
	{
		if (GetProcAddress(m_hDS, "DirectSoundCaptureCreate")	// this identifies DS5 or later
			&& (m_pDirectSoundCreate = (LPFNDSCREATE)GetProcAddress(m_hDS,"DirectSoundCreate"))
			&& (m_pDirectSoundEnumerate = (LPFNDSENUM)GetProcAddress(m_hDS,"DirectSoundEnumerateA"))
			)
		{
			if ((hr=(*m_pDirectSoundEnumerate)(DSEnumCallback, 0)) != S_OK)
			{
				DEBUGMSG(ZONE_DP,("DSEnumerate failed with %x\n",hr));
			} else {
				if (!m_pDSInfoList) {
					DEBUGMSG(ZONE_DP,("DSEnumerate - no devices found\n"));
					hr = DPR_NO_PLAY_CAP;	// no devices were found
				}
			}
		
		} else {
			hr = DPR_INVALID_PLATFORM;	// better error code?
		}
		if (hr != S_OK) {
			FreeLibrary(m_hDS);
			m_hDS = NULL;
		}
	}
	else
	{
		DEBUGMSG(ZONE_INIT,("LoadLibrary(DSOUND) failed"));
		hr = DPR_NO_PLAY_CAP;
	}

	m_fInitialized = TRUE;
	return hr;
}


HRESULT DirectSoundMgr::UnInitialize()
{
	DSINFO *pDSINFO = m_pDSInfoList, *pDSNEXT;
	if (m_fInitialized)
	{

		while (pDSINFO)
		{
			pDSNEXT = pDSINFO->pNext;
			delete [] pDSINFO->pszDescription;
			delete [] pDSINFO->pszModule;
			delete pDSINFO;
			pDSINFO = pDSNEXT;
		}

		m_fInitialized = FALSE;
		m_pDSInfoList = NULL;
	}

	return S_OK;
}



BOOL __stdcall DirectSoundMgr::DSEnumCallback(
	LPGUID lpGuid,
	LPCSTR lpstrDescription,
	LPCSTR lpstrModule,
	LPVOID lpContext
	)
{
	DSINFO *pDSInfo;
	
    DBG_SAVE_FILE_LINE
	pDSInfo = new DSINFO;
	if (pDSInfo) {
		pDSInfo->uRef = 0;
		pDSInfo->guid = (lpGuid ? *lpGuid : GUID_NULL);

        DBG_SAVE_FILE_LINE
		pDSInfo->pszDescription = new CHAR [lstrlen(lpstrDescription)+1];
		if (pDSInfo->pszDescription)
			lstrcpy(pDSInfo->pszDescription, lpstrDescription);

        DBG_SAVE_FILE_LINE
		pDSInfo->pszModule = new CHAR [lstrlen(lpstrModule)+1];
		if (pDSInfo->pszModule)
			lstrcpy(pDSInfo->pszModule, lpstrModule);

		// append to list
		pDSInfo->pNext = m_pDSInfoList;
		m_pDSInfoList = pDSInfo;
	}
	DEBUGMSG(ZONE_DP,("DSound device found: (%s) ; driver (%s);\n",lpstrDescription, lpstrModule));
	return TRUE;
}

HRESULT
DirectSoundMgr::MapWaveIdToGuid(UINT waveId, GUID *pGuid)
{
	// try to figure out which Guid maps to a wave id
	// Do this by opening the wave device corresponding to the wave id and then
	// all the DS devices in sequence and see which one fails.
	// Yes, this is a monstrous hack and clearly unreliable
	HWAVEOUT hWaveOut = NULL;
	MMRESULT mmr;
	HRESULT hr;
	DSINFO *pDSInfo;
	LPDIRECTSOUND pDS;
	DSCAPS dscaps;
	BOOL fEmulFound;
	WAVEFORMATEX wfPCM8K16 = {WAVE_FORMAT_PCM,1,8000,16000,2,16,0};
	WAVEOUTCAPS	waveOutCaps;

	if (!m_fInitialized)
		Initialize();	// get the list of DS devices

	if (!m_pDSInfoList)
		return DPR_CANT_OPEN_DEV;
	else if (waveId == WAVE_MAPPER || waveOutGetNumDevs()==1) {
		// we want the default or there is only one DS device, take the easy way out
		*pGuid =  GUID_NULL;
		return S_OK;
	}


	// try using the IKsProperty interface on a DirectSoundPrivate object
	// to find out what GUID maps to the waveId in question
	// Only likely to work on Win98 and NT 5.
	ZeroMemory(&waveOutCaps, sizeof(WAVEOUTCAPS));
	mmr = waveOutGetDevCaps(waveId, &waveOutCaps, sizeof(WAVEOUTCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveOutCaps.szPname, FALSE, pGuid);
		if (SUCCEEDED(hr))
		{
			return hr;
		}
		// if we failed to make a mapping, fall through to the old code path
	}


	mmr = waveOutOpen(&hWaveOut, waveId,
						  &wfPCM8K16,
						  0, 0, CALLBACK_NULL);
	if (mmr != MMSYSERR_NOERROR) {
		DEBUGMSG(ZONE_DP,("MapWaveIdToGuid - cannot open wave(%d)\n", waveId));
		return DPR_CANT_OPEN_DEV;
	}
	// now open all the DS devices in turn
	for (pDSInfo = m_pDSInfoList; pDSInfo; pDSInfo = pDSInfo->pNext) {
		hr = (*m_pDirectSoundCreate)(&pDSInfo->guid, &pDS, NULL);
		if (hr != S_OK) {
			pDSInfo->flags |= DSFLAG_ALLOCATED;	// this is a candidate
		} else {
			pDSInfo->flags &= ~DSFLAG_ALLOCATED;
			pDS->Release();
		}
	}
	waveOutClose(hWaveOut);
	hr = DPR_CANT_OPEN_DEV;

	dscaps.dwSize = sizeof(dscaps);
	fEmulFound = FALSE;
	// try opening the DS devices that failed the first time
	for (pDSInfo = m_pDSInfoList; pDSInfo; pDSInfo = pDSInfo->pNext) {
		if (pDSInfo->flags & DSFLAG_ALLOCATED) {
			hr = (*m_pDirectSoundCreate)(&pDSInfo->guid, &pDS, NULL);
			if (hr == S_OK) {
				*pGuid = pDSInfo->guid;
				// get dsound capabilities.
				// NOTE: consider putting the caps in DSINFO if its used often
				pDS->GetCaps(&dscaps);
				pDS->Release();
				DEBUGMSG(ZONE_DP,("mapped waveid %d to DS device(%s)\n", waveId, pDSInfo->pszDescription));
				if (dscaps.dwFlags & DSCAPS_EMULDRIVER)
					fEmulFound = TRUE;	// keep looking in case there's also a native driver
				else
					break;	// native DS driver. Look no further
					
			}
		}
	}
	if (fEmulFound)
		hr = S_OK;
		
	if (hr != S_OK) {
		DEBUGMSG(ZONE_DP,("Cant map id %d to DSound guid!\n", waveId));
		hr = DPR_CANT_OPEN_DEV;
	}

	return hr;
}

HRESULT
DirectSoundMgr::Instance(LPGUID pDeviceGuid,LPDIRECTSOUND *ppDS, HWND hwnd,  WAVEFORMATEX *pwf)
{
	DSINFO *pDSInfo = m_pDSInfoList;
	HRESULT hr;
	DSBUFFERDESC dsBufDesc;
	FX_ENTRY("DirectSoundInstance");

	if (pDeviceGuid == NULL)
		pDeviceGuid = &myNullGuid;
	// search for the Guid in the list
	*ppDS = NULL;

	if (!m_fInitialized)
		Initialize();
		
	while (pDSInfo) {
		if (pDSInfo->guid == *pDeviceGuid)
			break;
		pDSInfo = pDSInfo->pNext;
	}
	ASSERT (pDSInfo);

	if (!pDSInfo || !pDSInfo->pDS) {
		// need to create DS object
		PlaySound(NULL,NULL,0);		// hack to stop system sounds
			
		hr = (*m_pDirectSoundCreate)((*pDeviceGuid==GUID_NULL ? NULL: pDeviceGuid), ppDS, NULL);
		//set priority cooperative level, so we can set the format of the primary buffer.
		if (hr == S_OK 	&& 	(hr = (*ppDS)->SetCooperativeLevel(hwnd,DSSCL_PRIORITY)) == S_OK)
 		{
			if (!pDSInfo) {
				DEBUGMSG(ZONE_DP,("%s: GUID not in List!\n",_fx_));
				// BUGBUG: remove this block. Enumerate should have created the entry (except for NULL guid?)

                DBG_SAVE_FILE_LINE
				pDSInfo = new DSINFO;
				if (pDSInfo) {
					pDSInfo->uRef = 0;
					pDSInfo->guid = *pDeviceGuid;
					pDSInfo->pNext = m_pDSInfoList;
					m_pDSInfoList = pDSInfo;
				} else {
					(*ppDS)->Release();
					return DPR_OUT_OF_MEMORY;
				}
					
			}
			pDSInfo->pDS = *ppDS;
			++pDSInfo->uRef;
			// Create a primary buffer only to set the format
			// (what if its already set?)
			ZeroMemory(&dsBufDesc,sizeof(dsBufDesc));
			dsBufDesc.dwSize = sizeof(dsBufDesc);
			dsBufDesc.dwFlags = DSBCAPS_PRIMARYBUFFER|DSBCAPS_STICKYFOCUS;
			// STICKYFOCUS flags is supposed to preserve the format
			// when the app is not in-focus.
			hr = pDSInfo->pDS->CreateSoundBuffer(&dsBufDesc,&pDSInfo->pDSPrimaryBuf,NULL);
			if (hr == S_OK && pwf) {
				pDSInfo->pDSPrimaryBuf->SetFormat(pwf);
			} else {
				DEBUGMSG (ZONE_DP, ("%s: Create PrimarySoundBuffer failed, hr=0x%lX\r\n", _fx_, hr));
				hr = S_OK;	// Non fatal error
			}
			//DEBUGMSG(ZONE_DP, ("%s: Created Direct Sound object (%s)\n", _fx_,pDSInfo->pszDescription));
		} else {
			DEBUGMSG(ZONE_DP, ("%s: Could not create DS object (%s)\n", _fx_,pDSInfo->pszDescription));

		}
		LOG((LOGMSG_DSCREATE, hr));
	} else {
		*ppDS = pDSInfo->pDS;
		++pDSInfo->uRef;
		hr = S_OK;
	}
				
	return hr;	
}

HRESULT
DirectSoundMgr::ReleaseInstance(LPDIRECTSOUND pDS)
{
	// deref the DS object and release it if necessary
	DSINFO *pDSInfo = m_pDSInfoList;

	while (pDSInfo) {
		if (pDSInfo->pDS == pDS) {
			ASSERT(pDSInfo->uRef > 0);
			if (--pDSInfo->uRef == 0) {
				ULONG uref;
				if (pDSInfo->pDSPrimaryBuf) {
					pDSInfo->pDSPrimaryBuf->Release();
					pDSInfo->pDSPrimaryBuf = NULL;
				}
				uref = pDS->Release();
				pDSInfo->pDS = 0;
				LOG((LOGMSG_DSRELEASE, uref));
				//DEBUGMSG(ZONE_DP, ("Release Direct Sound object (%s) uref=%d\n", pDSInfo->pszDescription, uref));
				// dont bother freeing DSINFO. Its okay
				// to keep it around till the process dies
			}
			break;
		}
		pDSInfo = pDSInfo->pNext;
	}
	return (pDSInfo ? S_OK : DPR_INVALID_PARAMETER);
}


void DSTimeout::TimeoutIndication()
{
	ASSERT(m_pRDSStream);
	m_pRDSStream->RecvTimeout();
}


HRESULT STDMETHODCALLTYPE RecvDSAudioStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE RecvDSAudioStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE RecvDSAudioStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}



HRESULT
RecvDSAudioStream::Initialize( DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_ACM| DP_FLAG_DIRECTSOUND  | DP_FLAG_HALF_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("RecvDSAudioStream::Initialize")

	InitializeCriticalSection(&m_crsAudQoS);

	// enable Recv by default
	m_DPFlags = dwFlags | DPFLAG_ENABLE_RECV;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_Net = NULL;
	m_dwSrcSize = 0;
	m_pIRTPRecv = NULL;
	m_nFailCount = 0;
	m_bJammed = FALSE;
	m_bCanSignalOpen = TRUE;

	

	// Initialize data (should be in constructor)
	m_DSguid = GUID_NULL;	// use default device

	// Create decode audio filters
	m_hStrmConv = NULL; // replaced by AcmFilter

    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter;
	if (!m_pAudioFilter)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmManager new failed\r\n", _fx_));
		goto FilterAllocError;
	}

	ZeroMemory (&m_StrmConvHdr, sizeof (ACMSTREAMHEADER));


	// determine if the wave devices are available
	if (waveOutGetNumDevs()) m_DPFlags |= DP_FLAG_PLAY_CAP;
	

	m_DPFlags |= DPFLAG_INITIALIZED;

	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 1, REP_SYS_AUDIO_DSOUND);
	RETAILMSG(("NAC: Audio Subsystem: DirectSound"));

	return DPR_SUCCESS;


FilterAllocError:
	if (m_pAudioFilter) delete m_pAudioFilter;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_, hr));

	return hr;
}

RecvDSAudioStream::~RecvDSAudioStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
			UnConfigure();

		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
			m_pIRTPRecv = NULL;
		}

		if (m_pAudioFilter)
			delete m_pAudioFilter;

		m_pDP->RemoveMediaChannel(MCF_RECV|MCF_AUDIO, (IMediaChannel*)(RecvMediaStream*)this);

	}
	DeleteCriticalSection(&m_crsAudQoS);
}

extern UINT ChoosePacketSize(WAVEFORMATEX *pwf);
extern UINT g_MaxAudioDelayMs;
extern UINT g_MinWaveAudioDelayMs;
extern UINT g_MinDSEmulAudioDelayMs; // emulated DS driver delay


HRESULT STDMETHODCALLTYPE RecvDSAudioStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr=E_FAIL;
	BOOL fRet;
	DWORD dwMaxDecompressedSize;
	UINT cbSamplesPerPkt;
	DWORD dwPropVal;
	DWORD dwFlags;
	UINT uAudioCodec;
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	UINT ringSize = MAX_RXRING_SIZE;
	WAVEFORMATEX *pwfRecv;
	UINT maxRingSamples;
	MMRESULT mmr;

	FX_ENTRY ("RecvDSAudioStream::Configure")

//	m_Net = pNet;


	if (m_DPFlags & DPFLAG_STARTED_RECV)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();  // a re-configure will release the RTP object, need to call SetNetworkInterface again
	}


	if ((NULL == pFormat) ||
		(NULL == pChannelParams) ||
		(cbParams != sizeof(audChannelParams)) ||
		(cbFormat < sizeof(WAVEFORMATEX)) )

	{
		return DPR_INVALID_PARAMETER;
	}

	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfRecv = (WAVEFORMATEX *)pFormat;

	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
//	if (m_Net)
//	{
//		hr = m_Net->QueryInterface(IID_IRTPRecv, (void **)&m_pIRTPRecv);
//		if (!SUCCEEDED(hr))
//			return hr;
//	}

	AcmFilter::SuggestDecodeFormat(pwfRecv, &m_fDevRecv);
	
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->wFormatTag, REP_RECV_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nSamplesPerSec, REP_RECV_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nAvgBytesPerSec*8, REP_RECV_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Recv Format: %s", (pwfRecv->wFormatTag == 66) ? "G723.1" : (pwfRecv->wFormatTag == 112) ? "LHCELP" : (pwfRecv->wFormatTag == 113) ? "LHSB08" : (pwfRecv->wFormatTag == 114) ? "LHSB12" : (pwfRecv->wFormatTag == 115) ? "LHSB16" : (pwfRecv->wFormatTag == 6) ? "MSALAW" : (pwfRecv->wFormatTag == 7) ? "MSULAW" : (pwfRecv->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Recv Sampling Rate (Hz): %ld", pwfRecv->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Recv Bitrate (w/o network overhead - bps): %ld", pwfRecv->nAvgBytesPerSec*8));
	// note that parameters such as samples/packet are channel specific

	cbSamplesPerPkt = audChannelParams.ns_params.wFrameSize
		*audChannelParams.ns_params.wFramesPerPkt;

	// turn on receive silence detection only if the sender is not using
	// silence suppression
	if (!audChannelParams.ns_params.UseSilenceDet)
		m_DPFlags |= DP_FLAG_AUTO_SILENCE_DETECT;	
	else
		m_DPFlags &= ~DP_FLAG_AUTO_SILENCE_DETECT;
	UPDATE_REPORT_ENTRY(g_prptCallParameters, cbSamplesPerPkt, REP_RECV_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Recv Packetization (ms/packet): %ld", pwfRecv->nSamplesPerSec ? cbSamplesPerPkt * 1000UL / pwfRecv->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioReceiveBytes, (pwfRecv->nAvgBytesPerSec * 8 + pwfRecv->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / cbSamplesPerPkt) << 3);


	// make the ring buffer size large enought to hold 4 seconds of audio
	// This seems to be suitable for congested networks, in which
	// packets can get delayed and them for many to suddelnly arrive at once
	maxRingSamples = (pwfRecv->nSamplesPerSec * MIN_DSBUF_SIZE)/1000;


	// describe the DirectSound buffer
	
	ZeroMemory(&m_DSBufDesc,sizeof(m_DSBufDesc));
	m_DSBufDesc.dwSize = sizeof (m_DSBufDesc);
	m_DSBufDesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;
	m_DSBufDesc.dwBufferBytes = maxRingSamples * (m_fDevRecv.wBitsPerSample/8);
	m_DSBufDesc.dwReserved = 0;
	m_DSBufDesc.lpwfxFormat = &m_fDevRecv;
	
	m_pDS = NULL;
	m_pDSBuf = NULL;

	
	// Initialize the recv-stream filter manager object
	dwMaxDecompressedSize = cbSamplesPerPkt * (m_fDevRecv.nBlockAlign);


	mmr = m_pAudioFilter->Open(pwfRecv, &m_fDevRecv);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}

	
	// set up the decode buffer
	m_pAudioFilter->SuggestSrcSize(dwMaxDecompressedSize, &m_dwSrcSize);

	ZeroMemory (&m_StrmConvHdr, sizeof (ACMSTREAMHEADER));
	m_StrmConvHdr.cbStruct = sizeof (ACMSTREAMHEADER);

    DBG_SAVE_FILE_LINE
	m_StrmConvHdr.pbSrc = new BYTE[m_dwSrcSize];
	m_StrmConvHdr.cbSrcLength = m_dwSrcSize;  // may change for variable bit rate codecs

    DBG_SAVE_FILE_LINE
	m_StrmConvHdr.pbDst = new BYTE[dwMaxDecompressedSize];
	m_StrmConvHdr.cbDstLength = dwMaxDecompressedSize;

	mmr = m_pAudioFilter->PrepareHeader(&m_StrmConvHdr);
	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}
	
	// Initialize the recv stream
	m_BufSizeT = BYTESTOSAMPLES(m_DSBufDesc.dwBufferBytes);
	m_fEmpty = TRUE;

	m_MinDelayT = 0;
	m_MaxDelayT = g_MaxAudioDelayMs * m_fDevRecv.nSamplesPerSec /1000;
	m_ArrT = m_ArrivalT0 = 0;
	m_ScaledAvgVarDelay = 0;

	m_DelayT = m_MinDelayT;

	m_SilenceDurationT = 0;


	InitAudioFlowspec(&m_flowspec, pwfRecv, m_dwSrcSize);

	m_DPFlags |= DPFLAG_CONFIGURED_RECV;

	return DPR_SUCCESS;

RecvFilterInitError:
	if (m_pIRTPRecv)
	{
		m_pIRTPRecv->Release();
		m_pIRTPRecv = NULL;
	}

	m_pAudioFilter->Close();

	delete [] m_StrmConvHdr.pbSrc;
	delete [] m_StrmConvHdr.pbDst;
	m_StrmConvHdr.pbSrc=NULL;
	m_StrmConvHdr.pbDst = NULL;


	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}


void RecvDSAudioStream::UnConfigure()
{

	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV))
	{
		Stop();
		// Close the RTP state if its open
		m_Net = NULL;

		// release DS buffer and DS object
		//ReleaseDSBuffer();
		ASSERT(!m_pDSBuf);	// released in StopRecv()

		// Close the filters
		m_StrmConvHdr.cbSrcLength = m_dwSrcSize;
		m_pAudioFilter->UnPrepareHeader(&m_StrmConvHdr);
		m_pAudioFilter->Close();

		delete [] m_StrmConvHdr.pbSrc;
		delete [] m_StrmConvHdr.pbDst;
		m_StrmConvHdr.pbSrc=NULL;
		m_StrmConvHdr.pbDst = NULL;

		m_nFailCount = 0;
		m_bJammed = FALSE;
		m_bCanSignalOpen = TRUE;

		// Close the receive streams
		//m_RecvStream->Destroy();
        m_DPFlags &= ~(DPFLAG_CONFIGURED_RECV);
	}
}


HRESULT
RecvDSAudioStream::Start()
{
	HRESULT hr;
	IMediaChannel *pISendAudio;
	BOOL fStoppedRecording;
	FX_ENTRY ("RecvDSAudioStream::Start");
	
	if (m_DPFlags & DPFLAG_STARTED_RECV)
		return DPR_SUCCESS;
	// TODO: remove this check once audio UI calls the IComChan PAUSE_RECV prop
	if (!(m_DPFlags & DPFLAG_ENABLE_RECV))
		return DPR_SUCCESS;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_RECV)) || (!m_pIRTPRecv))
		return DPR_NOT_CONFIGURED;

	ASSERT(!m_hRenderingThread );
	m_ThreadFlags &= ~(DPTFLAG_STOP_PLAY|DPTFLAG_STOP_RECV);

	SetFlowSpec();

	pISendAudio = NULL;
	fStoppedRecording = FALSE;
	if (!(m_DPFlags & DP_FLAG_HALF_DUPLEX))
	{
	// make sure the recording device is closed before creating the DS object
	// Why ? Because SoundBlaster either sounds lousy or doesnt work at all if
	// you open waveIn before  waveOut or DirectSound.
		m_pDP->GetMediaChannelInterface(MCF_AUDIO|MCF_SEND, &pISendAudio);
		if (pISendAudio && pISendAudio->GetState()== MSSTATE_STARTED
		&& pISendAudio->Stop() == S_OK)
		{
			fStoppedRecording = TRUE;
			DEBUGMSG(ZONE_DP,("%s:Stopped Recording\n",_fx_));
		}
	}
	
	// Start receive thread. This will create the DSound object
    m_pDP->StartReceiving(this);

    if (pISendAudio) {
    	if (fStoppedRecording)
    		pISendAudio->Start();
    	pISendAudio->Release();
    }

    m_DPFlags |= DPFLAG_STARTED_RECV;
	return DPR_SUCCESS;
}

// LOOK: Identical to RecvVideoStream version.
HRESULT
RecvDSAudioStream::Stop()
{
	
	
	FX_ENTRY ("RecvDSAudioStream::Stop");

	if(!(m_DPFlags &  DPFLAG_STARTED_RECV))
	{
		return DPR_SUCCESS;
	}

	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_RECV |  DPTFLAG_STOP_PLAY ;

	// delink from receive thread
	m_pDP->StopReceiving(this);

	if (m_pDSBuf)
		m_pDSBuf->Stop();
	
    //This is per channel, but the variable is "DPFlags"
	m_DPFlags &= ~DPFLAG_STARTED_RECV;
	
	return DPR_SUCCESS;
}

//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaChannel. Supports properties for both audio
//      and video channels.

STDMETHODIMP
RecvDSAudioStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD dwValue;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
	case PROP_RECV_AUDIO_STRENGTH:
		{
			return GetSignalLevel((UINT*)pBuf);
		}

#ifdef OLDSTUFF
	case PROP_NET_RECV_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetRecvStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif
	//case PROP_VOLUME:

	case PROP_DUPLEX_TYPE:
		
		if(m_DPFlags & DP_FLAG_HALF_DUPLEX)
			*(DWORD*)pBuf = DUPLEX_TYPE_HALF;
		else
			*(DWORD*)pBuf =	DUPLEX_TYPE_FULL;
		break;

	case PROP_WAVE_DEVICE_TYPE:
		*(DWORD*)pBuf = m_DPFlags & DP_MASK_WAVE_DEVICE;
		break;
	case PROP_PLAY_ON:
		*(DWORD *)pBuf = (m_ThreadFlags & DPFLAG_ENABLE_RECV)!=0;
		break;
	case PROP_PLAYBACK_DEVICE:
		*(DWORD *)pBuf = m_RenderingDevice;
		break;

	case PROP_VIDEO_AUDIO_SYNC:
		*(DWORD*)pBuf = ((m_DPFlags & DPFLAG_AV_SYNC) != 0);
		break;
	
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}


// low order word is the signal strength
// high order work contains bits to indicate status
// (0x01 - transmitting)
// (0x02 - audio device is jammed)
STDMETHODIMP RecvDSAudioStream::GetSignalLevel(UINT *pSignalStrength)
{
	DWORD dwLevel;
	DWORD dwJammed;

	if ((!(m_DPFlags & DPFLAG_STARTED_RECV)) || (m_fEmpty) ||
		  (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		dwLevel = 0;
	}
	else
	{
		dwLevel = GetSignalStrength();
		dwLevel = LogScale[(dwLevel >> 8) & 0x00ff];

		if (m_bJammed)
		{
			dwLevel |= (2 << 16);
		}

		dwLevel |= (1 << 16);
	}
	*pSignalStrength = dwLevel;
	return S_OK;
};






DWORD
RecvDSAudioStream::GetSignalStrength()
{
	BYTE bMax, bMin, *pb;
	short sMax, sMin, *ps;
	UINT cbSize;
	DWORD dwMaxStrength = 0;
	cbSize = m_StrmConvHdr.cbDstLengthUsed;
	if (cbSize==0)
		return 0;
	switch (m_fDevRecv.wBitsPerSample)
	{
	case 8: // unsigned char

		pb = (PBYTE) (m_StrmConvHdr.pbDst);

		bMax = 0;
		bMin = 255;

		for ( ; cbSize; cbSize--, pb++)
		{
			if (*pb > bMax) bMax = *pb;
			if (*pb < bMin) bMin = *pb;
		}
	
			// 2^9 <-- 2^16 / 2^7
		dwMaxStrength = ((DWORD) (bMax - bMin)) << 8;
		break;

	case