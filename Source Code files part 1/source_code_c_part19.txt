UMNCLICK, OnColumnClick)
    END_MSG_MAP();


    LRESULT OnInitDialog        (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK                (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnOutputToCOM2      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOutputDebugString (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOutputToFile      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDebugBreak        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDumpStack         (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRestoreDefaults   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectAll         (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSelChanged        (int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnColumnClick       (int idCtrl, LPNMHDR pnmh, BOOL& bHandled );


    void    RecalcCheckboxes();
    void    DoSort();

private:
    enum
    {
        COLUMN_CATEGORY = 0,
        COLUMN_NAME     = 1,
        COLUMN_ENABLED  = 2
    };

    void            SetMaskFromCheckbox(UINT idControl, DWORD dwMask);

    WTL::CListViewCtrl m_listCtrl;
    WTL::CEdit         m_editStackLevels;
    DWORD              m_dwSortData;

};

#endif // DBG

#endif  // TRACEDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\cpsyscolor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cpsyscolor.h
//
//--------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////
// CProxy_SysColorEvents
template <class T>
class CProxy_SysColorEvents : public IConnectionPointImpl<T, &DIID__SysColorEvents, CComDynamicUnkArray>
{
public:
//methods:
//_SysColorEvents : IDispatch
public:
	void Fire_SysColorChange()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\dispobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dispobj.h
//
//--------------------------------------------------------------------------

// MMCDisplayObject.h : Declaration of the CMMCDisplayObject

#ifndef __DISPOBJ_H_
#define __DISPOBJ_H_

#include "resource.h"       // main symbols
#include "mmc.h"

/////////////////////////////////////////////////////////////////////////////
// CMMCDisplayObject
class ATL_NO_VTABLE CMMCDisplayObject :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCDisplayObject, &CLSID_MMCDisplayObject>,
    public IDispatchImpl<IMMCDisplayObject, &IID_IMMCDisplayObject, &LIBID_CICLib>
{
public:
    CMMCDisplayObject();
   ~CMMCDisplayObject();

    HRESULT Init (MMC_TASK_DISPLAY_OBJECT * pdo);

    // Strange registration. Why does this class has MMCTask registration script here?
    // But this object is not in object-map, so ATL wont use this script.
    DECLARE_MMC_OBJECT_REGISTRATION(
		g_szCicDll,
        CLSID_MMCTask,
        _T("MMCTask class"),
        _T("MMCTask.MMCTask.1"),
        _T("MMCTask.MMCTask"))

DECLARE_NOT_AGGREGATABLE(CMMCDisplayObject)

BEGIN_COM_MAP(CMMCDisplayObject)
    COM_INTERFACE_ENTRY(IMMCDisplayObject)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMMCDisplayObject
public:
    STDMETHOD(get_DisplayObjectType)(long* pVal);
    STDMETHOD(get_FontFamilyName   )(BSTR* pVal);
    STDMETHOD(get_URLtoEOT         )(BSTR* pVal);
    STDMETHOD(get_SymbolString     )(BSTR* pVal);
    STDMETHOD(get_MouseOverBitmap  )(BSTR* pVal);
    STDMETHOD(get_MouseOffBitmap   )(BSTR* pVal);

private:
    long m_type;
    BSTR m_bstrFontFamilyName;
    BSTR m_bstrURLtoEOT;
    BSTR m_bstrSymbolString;
    BSTR m_bstrMouseOffBitmap;
    BSTR m_bstrMouseOverBitmap;

// Ensure that default copy constructor & assignment are not used.
    CMMCDisplayObject(const CMMCDisplayObject& rhs);
    CMMCDisplayObject& operator=(const CMMCDisplayObject& rhs);
};

#endif //__MMCTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\dispobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dispobj.cpp
//
//--------------------------------------------------------------------------

// DispObj.cpp : Implementation of CMMCDisplayObject
#include "stdafx.h"
#include "cic.h"
#include "DispObj.h"
#include "mmc.h"
#include <wtypes.h>                             

/////////////////////////////////////////////////////////////////////////////
// CMMCDisplayObject
CMMCDisplayObject::CMMCDisplayObject()
{
    m_type = MMC_TASK_DISPLAY_UNINITIALIZED;

    m_bstrFontFamilyName  =
    m_bstrURLtoEOT        =
    m_bstrSymbolString    =
    m_bstrMouseOffBitmap  =
    m_bstrMouseOverBitmap = NULL;
}
CMMCDisplayObject::~CMMCDisplayObject()
{
    if (m_bstrFontFamilyName)   SysFreeString(m_bstrFontFamilyName);
    if (m_bstrURLtoEOT)         SysFreeString(m_bstrURLtoEOT);
    if (m_bstrSymbolString)     SysFreeString(m_bstrSymbolString);
    if (m_bstrMouseOffBitmap)   SysFreeString(m_bstrMouseOffBitmap);
    if (m_bstrMouseOverBitmap)  SysFreeString(m_bstrMouseOverBitmap);
}

STDMETHODIMP CMMCDisplayObject::get_DisplayObjectType(long* pVal)
{
    *pVal = m_type;
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_FontFamilyName (BSTR* pVal)
{
    if (m_bstrFontFamilyName)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrFontFamilyName);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_URLtoEOT (BSTR* pVal)
{
    if (m_bstrURLtoEOT)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrURLtoEOT);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_SymbolString (BSTR* pVal)
{
    if (m_bstrSymbolString)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrSymbolString);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_MouseOffBitmap (BSTR* pVal)
{
    if (m_bstrMouseOffBitmap)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrMouseOffBitmap);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_MouseOverBitmap (BSTR* pVal)
{
    if (m_bstrMouseOverBitmap)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrMouseOverBitmap);
    return S_OK;
}

HRESULT CMMCDisplayObject::Init(MMC_TASK_DISPLAY_OBJECT* pdo)
{
   _ASSERT (m_type == MMC_TASK_DISPLAY_UNINITIALIZED);
    if (m_type != MMC_TASK_DISPLAY_UNINITIALIZED)
        return E_UNEXPECTED;    // only allowed in here once

    switch (m_type = pdo->eDisplayType) {
    default:
    case MMC_TASK_DISPLAY_UNINITIALIZED:
//     _ASSERT (0 && "uninitialized MMC_TASK_DISPLAY_OBJECT struct");
        return E_INVALIDARG;
    case MMC_TASK_DISPLAY_TYPE_SYMBOL:           // fontname, EOT, symbols
        // all three fields MUST be filled out
       _ASSERT (pdo->uSymbol.szFontFamilyName && pdo->uSymbol.szURLtoEOT && pdo->uSymbol.szSymbolString);
        if (!(pdo->uSymbol.szFontFamilyName && pdo->uSymbol.szURLtoEOT && pdo->uSymbol.szSymbolString))
            return E_INVALIDARG;

        m_bstrFontFamilyName = SysAllocString (pdo->uSymbol.szFontFamilyName);
        m_bstrURLtoEOT       = SysAllocString (pdo->uSymbol.szURLtoEOT);
        m_bstrSymbolString   = SysAllocString (pdo->uSymbol.szSymbolString);
        if (m_bstrFontFamilyName && m_bstrURLtoEOT && m_bstrSymbolString)
            return S_OK;
        return E_OUTOFMEMORY;
        break;
    case MMC_TASK_DISPLAY_TYPE_VANILLA_GIF:      // (GIF) index 0 is transparent
    case MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF:    // (GIF) index 1 is transparent
    case MMC_TASK_DISPLAY_TYPE_BITMAP:           // non-transparent raster
        if ( pdo->uBitmap.szMouseOffBitmap  &&
             pdo->uBitmap.szMouseOverBitmap ){
            // if they both exist, like they're supposed to
            m_bstrMouseOffBitmap  = SysAllocString (pdo->uBitmap.szMouseOffBitmap);
            m_bstrMouseOverBitmap = SysAllocString (pdo->uBitmap.szMouseOverBitmap);
        } else if (pdo->uBitmap.szMouseOverBitmap) {
            // if only MouseOver image exists:
            // not too bad since it's probably color
            m_bstrMouseOffBitmap  = SysAllocString (pdo->uBitmap.szMouseOverBitmap);
            m_bstrMouseOverBitmap = SysAllocString (pdo->uBitmap.szMouseOverBitmap);
        } else if (pdo->uBitmap.szMouseOffBitmap) {
            // if only MouseOff image exists:
            // they're being bad, but not too bad
            m_bstrMouseOffBitmap  = SysAllocString (pdo->uBitmap.szMouseOffBitmap);
            m_bstrMouseOverBitmap = SysAllocString (pdo->uBitmap.szMouseOffBitmap);
        } else {
            // else they're really bad
            _ASSERT (0 && "MMC_TASK_DISPLAY_BITMAP uninitialized");
            return E_INVALIDARG;
        }
        if (m_bstrMouseOffBitmap && m_bstrMouseOverBitmap)
            return S_OK;
        return E_OUTOFMEMORY;
        break;
    }
    return E_UNEXPECTED;    // can't get here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\cic.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cic.cpp
//
//--------------------------------------------------------------------------

// cic.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f cicps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cic.h"

#include "cic_i.c"
#include "MMCCtrl.h"
#include "MMCTask.h"
#include "MMClpi.h"
#include "ListPad.h"
#include "SysColorCtrl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MMCCtrl,        CMMCCtrl)
    OBJECT_ENTRY(CLSID_MMCTask,        CMMCTask)
    OBJECT_ENTRY(CLSID_MMCListPadInfo, CMMCListPadInfo)
    OBJECT_ENTRY(CLSID_ListPad,        CListPad)
    OBJECT_ENTRY(CLSID_SysColorCtrl,   CSysColorCtrl)
END_OBJECT_MAP()

// cut from ndmgr_i.c (yuck) !!!
const IID IID_ITaskPadHost = {0x4f7606d0,0x5568,0x11d1,{0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a}};

#ifdef DBG
CTraceTag tagCicGetClassObject(TEXT("Cic"), TEXT("DllGetClassObject"));
#endif



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//***************************************************************************
//
// ScGetSystemWow64Directory
//
// PURPOSE: Calls GetSystemWow64DirectoryW using a late bind, to avoid
//          requiring the XP version of kernel32.dll
//
// PARAMETERS: 
//    LPTSTR  lpBuffer :
//    UINT    uSize :
//
// RETURNS: 
//    SC
//
//****************************************************************************
SC ScGetSystemWow64Directory(LPTSTR lpBuffer, UINT uSize )
{
    DECLARE_SC(sc, TEXT("ScGetSystemWow64Directory"));

    sc = ScCheckPointers(lpBuffer);
    if(sc)
        return sc;

    HMODULE hmod = GetModuleHandle (_T("kernel32.dll"));
    if (hmod == NULL)
        return (sc = E_FAIL);

    UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);
    (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryW");

    sc = ScCheckPointers(pfnGetSystemWow64Directory, E_FAIL);
    if(sc)
        return sc;

    if ((pfnGetSystemWow64Directory)(lpBuffer, uSize) == 0)
        return (sc = E_FAIL);

    return sc;
}

//***************************************************************************
//
// DllGetClassObject
//
// PURPOSE: Returns a class factory to create an object of the requested type
//          For security reasons, these COM objects can only be instantiated
//          within the context of MMC.EXE. If they are instantiated by any
//          other host, such as IE, they will fail.
//
// PARAMETERS: 
//    REFCLSID  rclsid :
//    REFIID    riid :
//    LPVOID*   ppv :
//
// RETURNS: 
//    STDAPI  - S_OK if the call succeeds
//              
//
//****************************************************************************
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    DECLARE_SC(sc, TEXT("CIC.DLL:DllGetClassObject"));

    TCHAR szFileName[MAX_PATH] = {0};
    DWORD cchFilename = MAX_PATH;

    // 1. Get the filename for the .exe associated with the process
    DWORD dw = GetModuleFileName(GetModuleHandle(NULL), szFileName, cchFilename);

    Trace(tagCicGetClassObject, TEXT("Process Filename: %s"), szFileName);

    if(0==dw)
        return sc.FromLastError().ToHr();

    // 2. Build the path to where MMC.EXE should be
    const int cchMMCPathName = MAX_PATH;
    TCHAR szMMCPathName[cchMMCPathName] = {0};

    UINT nLength = GetSystemDirectory(szMMCPathName, cchMMCPathName);
    if(0==nLength)
        return (sc = E_FAIL).ToHr();

    LPCTSTR szMMC = TEXT("\\MMC.EXE");

    sc = StringCchCat(szMMCPathName, cchMMCPathName, szMMC);
    if(sc)
        return sc.ToHr();

    // 3. Canonicalize by converting both paths to long path names
    const DWORD cchLongPath1 = MAX_PATH;
    const DWORD cchLongPath2 = MAX_PATH;
    TCHAR szLongPath1[cchLongPath1], szLongPath2[cchLongPath2];

    DWORD dw1 = GetLongPathName(szMMCPathName, szLongPath1, cchLongPath1);
    if(0==dw1)
        return sc.FromLastError().ToHr();

    DWORD dw2 = GetLongPathName(szFileName, szLongPath2, cchLongPath2);
    if(0==dw2)
        return sc.FromLastError().ToHr();

    // 4. Compare (case-insensitive) both parts to ensure that they are the same.
    // If they are not, some other .exe is trying to instantiate an object. Do
    // not allow this.
    Trace(tagCicGetClassObject, TEXT("Comparing %s to %s"), szLongPath1, szLongPath2);
    if(0 != _tcsicmp(szLongPath1, szLongPath2))
    {
        // try one more test (in case this is a 64-bit machine) - check for the SysWow64 directory
        const int cchMMCSysWow64PathName = MAX_PATH;
        TCHAR szMMCSysWow64PathName[cchMMCSysWow64PathName] = {0};

        sc = ScGetSystemWow64Directory(szMMCSysWow64PathName, cchMMCSysWow64PathName);
        if(sc)
            return sc.ToHr();

        sc = StringCchCat(szMMCSysWow64PathName, cchMMCSysWow64PathName, szMMC);
        if(sc)
            return sc.ToHr();
        
        const DWORD cchLongPathSysWow64 = MAX_PATH;
        TCHAR szLongPathSysWow64[cchLongPathSysWow64] = {0};

        DWORD dw3 = GetLongPathName(szMMCSysWow64PathName, szLongPathSysWow64, cchLongPathSysWow64);
        if(0==dw3)
            return sc.FromLastError().ToHr();

        Trace(tagCicGetClassObject, TEXT("Comparing %s to %s"), szLongPathSysWow64, szLongPath2);
        if(0 != _tcsicmp(szLongPath2, szLongPathSysWow64))
        {
            Trace(tagCicGetClassObject, TEXT("Invalid exe - must be %s or %s. Did not instantiate object."), szMMCPathName, szMMCSysWow64PathName);
            return (sc = CLASS_E_CLASSNOTAVAILABLE).ToHr();
        }
    }
    
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\listpad.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       listpad.h
//
//--------------------------------------------------------------------------

// ListPad.h : Declaration of the CListPad

#ifndef __LISTPAD_H_
#define __LISTPAD_H_

#include "resource.h"       // main symbols
#include "amcmsgid.h"
#include "commctrl.h"


/////////////////////////////////////////////////////////////////////////////
// CListPad
class ATL_NO_VTABLE CListPad :
public CComObjectRootEx<CComSingleThreadModel>,
public CComCoClass<CListPad, &CLSID_ListPad>,
public CComControl<CListPad>,
public IDispatchImpl<IListPad, &IID_IListPad, &LIBID_CICLib>,
public IProvideClassInfo2Impl<&CLSID_ListPad, NULL, &LIBID_CICLib>,
public IPersistStreamInitImpl<CListPad>,
public IPersistStorageImpl<CListPad>,
public IQuickActivateImpl<CListPad>,
public IOleControlImpl<CListPad>,
public IOleObjectImpl<CListPad>,
public IOleInPlaceActiveObjectImpl<CListPad>,
public IObjectSafetyImpl<CListPad, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
public IViewObjectExImpl<CListPad>,
public IOleInPlaceObjectWindowlessImpl<CListPad>,
public IDataObjectImpl<CListPad>,
public ISpecifyPropertyPagesImpl<CListPad>
{
public:
    CListPad()
    {
        m_MMChWnd = m_ListViewHWND = NULL;
        m_bWindowOnly = TRUE;
    }
    ~CListPad()
    {
        if (m_MMChWnd)
            ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_MMChWnd, (LPARAM)NULL);
    }

    /*+-------------------------------------------------------------------------*
     *
     * GetWndClassInfo
     *
     * PURPOSE: Need to override this to remove the CS_HREDRAW and CS_VREDRAW
     *          styles, which were causing lots of flicker. See the SDK
     *          docs under GetWndClassInfo for more details.
     *
     * RETURNS: 
     *    static CWndClassInfo&
     *
     *+-------------------------------------------------------------------------*/
    static CWndClassInfo& GetWndClassInfo() 
    { 
    	static CWndClassInfo wc = 
    	{ 
    		{ sizeof(WNDCLASSEX), CS_DBLCLKS, StartWindowProc, 
    		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, NULL, NULL }, 
    		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
    	}; 
    	return wc; 
    }


    DECLARE_MMC_CONTROL_REGISTRATION(
                                    g_szCicDll,
                                    CLSID_ListPad,
                                    _T("ListPad class"),
                                    _T("ListPad.ListPad.1"),
                                    _T("ListPad.ListPad"),
                                    LIBID_CICLib,
                                    _T("1"),
                                    _T("1.0"))

    BEGIN_COM_MAP(CListPad)
    COM_INTERFACE_ENTRY(IListPad)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CListPad)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
//  PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()

    BEGIN_MSG_MAP(CListPad)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)

    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    MESSAGE_HANDLER(WM_NOTIFYFORMAT, OnNotifyFormat)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    END_MSG_MAP()

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    STDMETHOD(TranslateAccelerator)(MSG *pMsg)
    {
        // If the list view has the focus process the keys the list view can use
        // use because IE will take them before they become normal key events
        // to the focused window.
        if (::GetFocus() == m_ListViewHWND && pMsg->message == WM_KEYDOWN)
        {
            switch (pMsg->wParam)
            {
            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
            case VK_HOME:
            case VK_END:
            case VK_PRIOR:
            case VK_NEXT:
                ::TranslateMessage(pMsg);
                ::DispatchMessage(pMsg);
                return S_OK;
            }
        }

        CComQIPtr<IOleControlSite,&IID_IOleControlSite> spCtrlSite (m_spClientSite);
        if (spCtrlSite)
            return spCtrlSite->TranslateAccelerator (pMsg,0);
        return S_FALSE;
    }

public:

    LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LRESULT lr = CComControlBase::OnSetFocus (nMsg, wParam, lParam, bHandled);
        if (m_ListViewHWND)
        {
            ::SetFocus (m_ListViewHWND);
            return TRUE;
        }
        return lr;
    }

    LRESULT OnNotify (UINT nMsg, WPARAM w, LPARAM l, BOOL& bHandled)
    {
        NMHDR* pnmhdr = reinterpret_cast<NMHDR*>(l);

        // Must handle focus changes here for active control tracking.
        // Don't forward it to the MMC window.
        if (pnmhdr->code == NM_SETFOCUS)
        {
            // if we're not UI active, request it now
            if (m_bInPlaceActive && !m_bUIActive)
                UIActivateWithNoGrab();

            return  CComControlBase::OnSetFocus (WM_SETFOCUS, NULL, NULL, bHandled);
        }
        else if (pnmhdr->code == NM_KILLFOCUS)
        {
            return  CComControlBase::OnKillFocus (WM_KILLFOCUS, NULL, NULL, bHandled);
        }

        if (m_MMChWnd != NULL)
            return(BOOL)::SendMessage (m_MMChWnd, nMsg, w, l);

        return bHandled = 0;
    }

    LRESULT OnNotifyFormat (UINT nMsg, WPARAM w, LPARAM l, BOOL& lResult)
    {   return OnNotify (nMsg, w, l, lResult);}

    LRESULT OnDestroy (UINT nMsg, WPARAM w, LPARAM l, BOOL& lResult)
    {
        if (m_MMChWnd != NULL)
        { // detach
            ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_hWnd, (LPARAM)NULL);
            m_MMChWnd = NULL;
        }
        return lResult = 1;
    }

    LRESULT OnSize (UINT nMsg, WPARAM w, LPARAM l, BOOL& lResult)
    {
 		::SetWindowPos (m_ListViewHWND, NULL, 0, 0, LOWORD(l), HIWORD(l), SWP_NOZORDER | SWP_NOACTIVATE);
        return 1;
    }

	HRESULT OnPostVerbInPlaceActivate();
    
    // UIActivation code taken from CComControlBase::InPlaceActivate.
    // Can't call InPlaceActivate because it always forces the focus to the
    // outer window and we don't want to steal focus from the list view control.
    void UIActivateWithNoGrab()
    {
        OLEINPLACEFRAMEINFO frameInfo;
        RECT rcPos, rcClip;
        CComPtr<IOleInPlaceFrame> spInPlaceFrame;
        CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
        frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

        m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
                                          &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

        CComPtr<IOleInPlaceActiveObject> spActiveObject;
        ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

        m_bUIActive = TRUE;
        HRESULT hr = m_spInPlaceSite->OnUIActivate();
        if (FAILED(hr))
            return;

        // set ourselves up in the host.
        //
        if (spActiveObject)
        {
            if (spInPlaceFrame)
                spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
            if (spInPlaceUIWindow)
                spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
        }

        if (spInPlaceFrame)
            spInPlaceFrame->SetBorderSpace(NULL);
        if (spInPlaceUIWindow)
            spInPlaceUIWindow->SetBorderSpace(NULL);
    }

private:
    HWND m_MMChWnd;
    HWND m_ListViewHWND;
};

#endif //__LISTPAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\mmcctrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcctrl.cpp
//
//--------------------------------------------------------------------------

// MMCCtrl.cpp : Implementation of CMMCCtrl
#include "stdafx.h"
#include "cic.h"
#include "MMCCtrl.h"
#include "MMCTask.h"
#include "DispObj.h"
#include "MMClpi.h"
#include "amcmsgid.h"
#include "findview.h"
#include "strings.h"


void CMMCCtrl::DoConnect ()
{
    // if we're not connected...
    if (m_spTaskPadHost == NULL) {
        HWND hwnd = FindMMCView(*dynamic_cast<CComControlBase*>(this));
        if (hwnd)
            Connect (hwnd);
    }
}

void CMMCCtrl::Connect (HWND wndCurrent)
{
    HWND hwndView = FindMMCView(wndCurrent);

    if (hwndView)
    {
        // get the control's IUnknown 
        IUnknownPtr spunk;
        ControlQueryInterface (IID_IUnknown, (void **)&spunk);
        if (spunk != NULL)
        {
            IUnknownPtr spunkMMC;
            ::SendMessage (hwndView, MMC_MSG_CONNECT_TO_CIC, (WPARAM)&spunkMMC, (LPARAM)(spunk.GetInterfacePtr()));
            if (spunkMMC != NULL)
                m_spTaskPadHost = spunkMMC;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CMMCCtrl


HRESULT CMMCCtrl::OnDraw(ATL_DRAWINFO& di)
{
    if (m_spTaskPadHost == NULL) {
        // get window from di and find console window
        HWND wndCurrent = WindowFromDC (di.hdcDraw);
        if (wndCurrent)
            Connect (wndCurrent);
    }
    return S_OK;
}


HRESULT CMMCCtrl::OnDrawAdvanced(ATL_DRAWINFO & di)
{
    return OnDraw (di);
}

STDMETHODIMP CMMCCtrl::TaskNotify(BSTR szClsid, VARIANT * pvArg, VARIANT * pvParam)
{
    DoConnect();    // connect, if not already connected
    if(m_spTaskPadHost != NULL)
        return m_spTaskPadHost->TaskNotify (szClsid, pvArg, pvParam);
    return E_FAIL;
}

STDMETHODIMP CMMCCtrl::GetFirstTask(BSTR szTaskGroup, IDispatch** retval)
{  // called by script, when it wants buttons, etc.

    // validate parameters
    _ASSERT (retval);
    _ASSERT (!IsBadWritePtr(retval, sizeof(IDispatch*)));
    // TODO:  how do I validate a BSTR?

    if (retval == NULL || IsBadWritePtr(retval, sizeof(IDispatch*)))
        return E_INVALIDARG;
    
    // should be initialized to this already (see note below)
    *retval = NULL;

    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost == NULL)    // from note above:
        return S_OK;        // any error, pops up ugly script message box....

    // "reset":  if we have an old enumerator, blitz it.
    if (m_spEnumTASK != NULL)
        m_spEnumTASK = NULL;

    // get new enumerator
    m_spTaskPadHost->GetTaskEnumerator (szTaskGroup, &m_spEnumTASK);
    if(m_spEnumTASK != NULL)
        return GetNextTask (retval);
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetNextTask(IDispatch** retval)
{
    // validate parameters
    _ASSERT (retval);
    _ASSERT (!IsBadWritePtr(retval, sizeof(IDispatch*)));

    if (retval == NULL || IsBadWritePtr(retval, sizeof(IDispatch*)))
        return E_INVALIDARG;
    
    if (m_spEnumTASK == NULL)
        return S_OK;    // all outa enumerators

    MMC_ITASK task;
    ZeroMemory (&task, sizeof(MMC_ITASK));
    HRESULT hresult = m_spEnumTASK->Next (1, (MMC_TASK *)&task, NULL);

    if (hresult != S_OK) {
        // out of tasks (and enumerators):  no need to hang onto this any more.
        m_spEnumTASK = NULL;
        return S_OK;
    }  else {
        // convert MMC_ITASK to ITask object
        CComObject<class CMMCTask>* ctask = NULL;
        hresult = CComObject<CMMCTask>::CreateInstance(&ctask);
        if (ctask) {

            ctask->SetText (task.task.szText);
            ctask->SetHelp (task.task.szHelpString);
            ctask->SetClsid(task.szClsid);

            hresult = ctask->SetDisplayObject (&task.task.sDisplayObject);
            if (hresult == S_OK) {
                switch (task.task.eActionType) {
                case MMC_ACTION_ID:
                    hresult = ctask->SetCommandID (task.task.nCommandID);
                    break;
                case MMC_ACTION_LINK:
                    hresult = ctask->SetActionURL (task.task.szActionURL);
                    break;
                case MMC_ACTION_SCRIPT:
                    hresult = ctask->SetScript (task.task.szScript);
                    break;
                default:
                    _ASSERT (FALSE);  // bad task
                    hresult = E_UNEXPECTED;
                    break;
                }
            }

            if (SUCCEEDED(hresult)) 
                ctask->QueryInterface (IID_IDispatch, (void **)retval);
            else 
                delete ctask;
        }
    }

    FreeDisplayData (&task.task.sDisplayObject);
    if (task.task.szText)            CoTaskMemFree (task.task.szText);
    if (task.task.szHelpString)      CoTaskMemFree (task.task.szHelpString);
    if (task.szClsid)                CoTaskMemFree (task.szClsid);
    if (task.task.eActionType != MMC_ACTION_ID)
        if (task.task.szScript)
            CoTaskMemFree (task.task.szScript);

    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetTitle(BSTR szTaskGroup, BSTR * retval)
{
    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost)
        m_spTaskPadHost->GetTitle (szTaskGroup, retval);
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetDescriptiveText(BSTR szTaskGroup, BSTR * retval)
{
    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost)
        m_spTaskPadHost->GetDescriptiveText (szTaskGroup, retval);
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetBackground(BSTR szTaskGroup, IDispatch** retval)
{
    DoConnect();    // connect, if not already connected
    *retval = NULL;
    if (m_spTaskPadHost) {

        MMC_TASK_DISPLAY_OBJECT tdo;
        ZeroMemory (&tdo, sizeof(tdo));

        // pass struct to host (which will pass to snapin)
        m_spTaskPadHost->GetBackground (szTaskGroup, &tdo);

        // convert struct to IDispatch object
        CComObject<class CMMCDisplayObject>* cdo = NULL;
        CComObject<CMMCDisplayObject>::CreateInstance(&cdo);
        if (cdo) {
            cdo->Init (&tdo);
            IDispatchPtr spIDispatch = cdo;
            if (*retval = spIDispatch)
                spIDispatch.Detach();
        }
        FreeDisplayData (&tdo);
    }
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetListPadInfo (BSTR szGroup, IDispatch** retval)
{
    *retval = NULL;
    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost == NULL)
        return S_OK;

    MMC_ILISTPAD_INFO ilpi;
    ZeroMemory (&ilpi, sizeof(MMC_ILISTPAD_INFO));
    m_spTaskPadHost->GetListPadInfo (szGroup, &ilpi);

    // convert struct to IDispatch
    CComObject<class CMMCListPadInfo>* clpi = NULL;
    HRESULT hr = CComObject<CMMCListPadInfo>::CreateInstance(&clpi);
    if (clpi) {
        // always set clsid, title, button text, even if NULL or empty strings
        if (ilpi.szClsid)
            hr = clpi->SetClsid (ilpi.szClsid);
        if (hr == S_OK && ilpi.info.szTitle)
            hr = clpi->SetTitle (ilpi.info.szTitle);
        if (hr == S_OK)
            hr = clpi->SetNotifyID (ilpi.info.nCommandID);
        if (hr == S_OK && ilpi.info.szButtonText)
            hr = clpi->SetText (ilpi.info.szButtonText);

        // NULL  button text => no button
        // empty button text => button without any text
        if (hr == S_OK)
            hr = clpi->SetHasButton (ilpi.info.szButtonText != NULL);

        if (SUCCEEDED(hr)) 
            clpi->QueryInterface (IID_IDispatch, (void **)retval);
        else 
            delete clpi;
    }

    // free resources
    if (ilpi.szClsid)           CoTaskMemFree (ilpi.szClsid);
    if (ilpi.info.szTitle)      CoTaskMemFree (ilpi.info.szTitle);
    if (ilpi.info.szButtonText) CoTaskMemFree (ilpi.info.szButtonText);
    return S_OK;
}

void CMMCCtrl::FreeDisplayData (MMC_TASK_DISPLAY_OBJECT* pdo)
{
    switch (pdo->eDisplayType) {
    default:
        break;
    case MMC_TASK_DISPLAY_TYPE_SYMBOL:
        if (pdo->uSymbol.szFontFamilyName)  CoTaskMemFree (pdo->uSymbol.szFontFamilyName);
        if (pdo->uSymbol.szURLtoEOT)        CoTaskMemFree (pdo->uSymbol.szURLtoEOT);
        if (pdo->uSymbol.szSymbolString)    CoTaskMemFree (pdo->uSymbol.szSymbolString);
        break;
    case MMC_TASK_DISPLAY_TYPE_BITMAP:
    case MMC_TASK_DISPLAY_TYPE_VANILLA_GIF:
    case MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF:
        if (pdo->uBitmap.szMouseOverBitmap) CoTaskMemFree (pdo->uBitmap.szMouseOverBitmap);
        if (pdo->uBitmap.szMouseOffBitmap)  CoTaskMemFree (pdo->uBitmap.szMouseOffBitmap);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\listpad.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       listpad.cpp
//
//--------------------------------------------------------------------------

// ListPad.cpp : Implementation of CListPad
#include "stdafx.h"
#include "cic.h"
#include "ListPad.h"
#include "findview.h"
#include "strings.h"

/////////////////////////////////////////////////////////////////////////////
// CListPad

HRESULT CListPad::OnPostVerbInPlaceActivate()
{
    // set up the window hierarchy
    if (m_MMChWnd == NULL)
    {
        // walk the parent windows until we hit one we recognize
        HWND hwnd = FindMMCView(m_hWnd);

        // found it!
        if (hwnd)
        {
            // hang onto this to prevent reconnections
            m_MMChWnd = hwnd;
            m_ListViewHWND = NULL;

            // send a message to pull the old switcheroo
            ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_hWnd, (LPARAM)&m_ListViewHWND);
        }
    }

    // when navigating back to a listpad using history, need to reconnect the  listpad. The test for this
    // is that both windows already exist and the parent of the list view is the amcview, indicating that the
    // connection has not yet taken place
    if(m_MMChWnd && m_ListViewHWND && (::GetParent(m_ListViewHWND)==m_MMChWnd) ) 
    {
        // send a message to pull the old switcheroo
        ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_hWnd, (LPARAM)&m_ListViewHWND);
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\mmcctrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcctrl.h
//
//--------------------------------------------------------------------------

// MMCCtrl.h : Declaration of the CMMCCtrl

#ifndef __MMCCTRL_H_
#define __MMCCTRL_H_

#include "resource.h"       // main symbols
#include "commctrl.h"       // to prevent LVITEMW redefinition in ndmgr.h
#include <ndmgr.h>

/////////////////////////////////////////////////////////////////////////////
// CMMCCtrl
class ATL_NO_VTABLE CMMCCtrl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCCtrl, &CLSID_MMCCtrl>,
    public CComControl<CMMCCtrl>,
    public IDispatchImpl<IMMCCtrl, &IID_IMMCCtrl, &LIBID_CICLib>,
    public IProvideClassInfo2Impl<&CLSID_MMCCtrl, &IID_IMMCCtrlEvent, &LIBID_CICLib>,
    public IPersistStreamInitImpl<CMMCCtrl>,
    public IPersistStorageImpl<CMMCCtrl>,
    public IQuickActivateImpl<CMMCCtrl>,
    public IOleControlImpl<CMMCCtrl>,
    public IOleObjectImpl<CMMCCtrl>,
    public IOleInPlaceActiveObjectImpl<CMMCCtrl>,
    public IObjectSafetyImpl<CMMCCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IViewObjectExImpl<CMMCCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CMMCCtrl>,
    public IDataObjectImpl<CMMCCtrl>,
    public ISpecifyPropertyPagesImpl<CMMCCtrl>,
    public IConnectionPointContainerImpl<CMMCCtrl>,
    public IConnectionPointImpl<CMMCCtrl, &IID_IMMCCtrlEvent>
{
public:
    CMMCCtrl()
    {
    }

    ~CMMCCtrl()
    {
    }

    DECLARE_MMC_CONTROL_REGISTRATION(
		g_szCicDll,
        CLSID_MMCCtrl,
        _T("MMCCtrl class"),
        _T("MMCCtrl.MMCCtrl.1"),
        _T("MMCCtrl.MMCCtrl"),
        LIBID_CICLib,
        _T("1"),
        _T("1.0"))

DECLARE_NOT_AGGREGATABLE(CMMCCtrl)

BEGIN_COM_MAP(CMMCCtrl)
    COM_INTERFACE_ENTRY(IMMCCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMMCCtrl)
    CONNECTION_POINT_ENTRY(IID_IMMCCtrlEvent)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CMMCCtrl)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CMMCCtrl)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

    STDMETHOD(TranslateAccelerator)(MSG *pMsg)
    {
        CComQIPtr<IOleControlSite,&IID_IOleControlSite> spCtrlSite (m_spClientSite);
        if(spCtrlSite)
            return spCtrlSite->TranslateAccelerator (pMsg,0);
        return S_FALSE;
    }

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }
   STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
   {
#ifdef DIDNT_WORK_TOO_WELL
      static BOOL b = FALSE;
      if (b == TRUE) {
         b = FALSE;
         psizel->cx = psizel->cy = 121;
      } else {
         b = TRUE;
         psizel->cx = psizel->cy = 120;
      }
#else
      psizel->cx = psizel->cy = 250;
#endif
        return S_OK;
    }

// IMMCCtrl
public:
    STDMETHOD(GetBackground     )(BSTR szTaskGroup, IDispatch** retval);
    STDMETHOD(GetTitle          )(BSTR szTaskGroup, BSTR * retval);
    STDMETHOD(GetDescriptiveText)(BSTR szTaskGroup, BSTR * retval);
    STDMETHOD(GetFirstTask      )(BSTR szTaskGroup, IDispatch** retval);
    STDMETHOD(GetNextTask       )(IDispatch** retval);
    STDMETHOD(GetListPadInfo    )(BSTR szGroup, IDispatch** retval);
    STDMETHOD(TaskNotify        )(BSTR szClsid, VARIANT * pvArg, VARIANT * pvParam);

    HRESULT OnDraw(ATL_DRAWINFO& di);
    HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);

private: // helpers
   void Connect (HWND wndCurrent);
   void DoConnect ();
   void FreeDisplayData (MMC_TASK_DISPLAY_OBJECT* pdo);

private:
   ITaskPadHostPtr m_spTaskPadHost;
   IEnumTASKPtr    m_spEnumTASK;
};

#endif //__MMCCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\mmclpi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmclpi.cpp
//
//--------------------------------------------------------------------------

// MMCTask.cpp : Implementation of CMMCTask
#include "stdafx.h"
#include "cic.h"
#include "MMClpi.h"

/////////////////////////////////////////////////////////////////////////////
// CMMCListPad
CMMCListPadInfo::CMMCListPadInfo()
{
    m_bstrTitle  =
    m_bstrClsid  =
    m_bstrText   = NULL;
    m_lNotifyID  = 0;
    m_bHasButton = FALSE;
}
CMMCListPadInfo::~CMMCListPadInfo()
{
    if (m_bstrTitle)    SysFreeString (m_bstrTitle);
    if (m_bstrText)     SysFreeString (m_bstrText);
    if (m_bstrClsid)    SysFreeString (m_bstrClsid);
}

STDMETHODIMP CMMCListPadInfo::get_Title(BSTR * pVal)
{
    if (m_bstrTitle)
        *pVal = SysAllocString ((OLECHAR *)m_bstrTitle);
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_Text(BSTR * pVal)
{
    if (m_bstrText)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrText);
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_NotifyID(LONG_PTR * pVal)
{
    *pVal = m_lNotifyID;
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_Clsid(BSTR * pVal)
{
    if (m_bstrClsid)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrClsid);
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_HasButton(BOOL* pVal)
{
    *pVal = m_bHasButton;
    return S_OK;
}

HRESULT CMMCListPadInfo::SetNotifyID(LONG_PTR nID)
{
    m_lNotifyID = nID;
    return S_OK;
}
HRESULT CMMCListPadInfo::SetTitle (LPOLESTR szTitle)
{
    if (m_bstrTitle)  SysFreeString (m_bstrTitle);
    m_bstrTitle = SysAllocString (szTitle);
    if (!m_bstrTitle)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CMMCListPadInfo::SetText (LPOLESTR szText)
{
    if (m_bstrText)  SysFreeString (m_bstrText);
    m_bstrText = SysAllocString (szText);
    if (!m_bstrText)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CMMCListPadInfo::SetClsid(LPOLESTR szClsid)
{
    if (m_bstrClsid)  SysFreeString (m_bstrClsid);
    m_bstrClsid = SysAllocString (szClsid);
    if (!m_bstrClsid)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CMMCListPadInfo::SetHasButton (BOOL b)
{
    m_bHasButton = b;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cic.rc
//
#define IDS_PROJNAME                    100
#define IDS_CONNECT_MSG                 101
#define IDR_NAVCTRL                     107

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\mmclpi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmclpi.h
//
//--------------------------------------------------------------------------

// MMCListPad.h : Declaration of the CMMCListPad

#ifndef __MMCLPI_H_
#define __MMCLPI_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMMCListPad
class ATL_NO_VTABLE CMMCListPadInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCListPadInfo, &CLSID_MMCListPadInfo>,
    public IDispatchImpl<IMMCListPadInfo, &IID_IMMCListPadInfo, &LIBID_CICLib>
{
public:
    CMMCListPadInfo();
   ~CMMCListPadInfo();

   DECLARE_MMC_OBJECT_REGISTRATION(
	   g_szCicDll,
       CLSID_MMCListPadInfo,
       _T("MMCListPadInfo class"),
       _T("MMCListPadInfo.MMCListPadInfo.1"),
       _T("MMCListPadInfo.MMCListPadInfo"))

DECLARE_NOT_AGGREGATABLE(CMMCListPadInfo)

BEGIN_COM_MAP(CMMCListPadInfo)
    COM_INTERFACE_ENTRY(IMMCListPadInfo)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMMCListPadInfo
public:
    STDMETHOD(get_Title    )(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(get_Text     )(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(get_NotifyID )(/*[out, retval]*/ LONG_PTR* pVal);
    STDMETHOD(get_Clsid    )(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(get_HasButton)(/*[out, retval]*/ BOOL* pVal);

public:
    HRESULT SetTitle    (LPOLESTR szTitle);
    HRESULT SetText     (LPOLESTR szText);
    HRESULT SetClsid    (LPOLESTR szClsid);
    HRESULT SetNotifyID (LONG_PTR lID);
    HRESULT SetHasButton(BOOL b);

private:
    BSTR m_bstrTitle;
    BSTR m_bstrText;
    BSTR m_bstrClsid;
    LONG_PTR m_lNotifyID;
    BOOL m_bHasButton;

// Ensure that default copy constructor & assignment are not used.
    CMMCListPadInfo(const CMMCListPadInfo& rhs);
    CMMCListPadInfo& operator=(const CMMCListPadInfo& rhs);
};

#endif //__MMCLPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\mmctask.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmctask.h
//
//--------------------------------------------------------------------------

// MMCTask.h : Declaration of the CMMCTask

#ifndef __MMCTASK_H_
#define __MMCTASK_H_

#include "resource.h"       // main symbols
#include "mmc.h"
#include <ndmgr.h>

/////////////////////////////////////////////////////////////////////////////
// CMMCTask
class ATL_NO_VTABLE CMMCTask :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCTask, &CLSID_MMCTask>,
    public IDispatchImpl<IMMCTask, &IID_IMMCTask, &LIBID_CICLib>
{
public:
    CMMCTask();
    ~CMMCTask();

    HRESULT SetScript        (LPOLESTR szScript);
    HRESULT SetActionURL     (LPOLESTR szActionURL);
    HRESULT SetCommandID     (LONG_PTR nID);
    HRESULT SetActionType    (long nType);
    HRESULT SetHelp          (LPOLESTR szHelp);
    HRESULT SetText          (LPOLESTR szText);
    HRESULT SetClsid         (LPOLESTR szClsid);
    HRESULT SetDisplayObject (MMC_TASK_DISPLAY_OBJECT* pdo);

    DECLARE_MMC_OBJECT_REGISTRATION(
		g_szCicDll,
        CLSID_MMCTask,
        _T("MMCTask class"),
        _T("MMCTask.MMCTask.1"),
        _T("MMCTask.MMCTask"))

DECLARE_NOT_AGGREGATABLE(CMMCTask)

BEGIN_COM_MAP(CMMCTask)
    COM_INTERFACE_ENTRY(IMMCTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMMCTask
public:
    STDMETHOD(get_Clsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Script)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ActionURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CommandID)(/*[out, retval]*/ LONG_PTR *pVal);
    STDMETHOD(get_ActionType)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Help)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Text)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ScriptLanguage)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DisplayObject)(/*[out, retval]*/ IDispatch** pDispatch);

private:
    void FreeActions ();

private:
    BSTR m_bstrLanguage;
    BSTR m_bstrScript;
    BSTR m_bstrActionURL;
    BSTR m_bstrHelp;
    BSTR m_bstrText;
    BSTR m_bstrClsid;
    long m_type;
    LONG_PTR m_ID;
    IDispatchPtr m_spDisplayObject;

// Ensure that default copy constructor & assignment are not used.
    CMMCTask(const CMMCTask& rhs);
    CMMCTask& operator=(const CMMCTask& rhs);
};

#endif //__MMCTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\mmctask.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmctask.cpp
//
//--------------------------------------------------------------------------

// MMCTask.cpp : Implementation of CMMCTask
#include "stdafx.h"
#include "cic.h"
#include "MMCTask.h"
#include "DispObj.h"
#include "mmc.h"
#include <wtypes.h>                             

/////////////////////////////////////////////////////////////////////////////
// CMMCTask
CMMCTask::CMMCTask()
{
    m_ID              = 0;
    m_bstrClsid       = m_bstrScript    = m_bstrLanguage  =
    m_bstrActionURL   = m_bstrHelp      = m_bstrText      = NULL;
    m_type            = MMC_ACTION_UNINITIALIZED;
}
CMMCTask::~CMMCTask()
{
    if (m_bstrScript)         SysFreeString(m_bstrScript);
    if (m_bstrActionURL)      SysFreeString(m_bstrActionURL);
    if (m_bstrHelp)           SysFreeString(m_bstrHelp);
    if (m_bstrText)           SysFreeString(m_bstrText);
    if (m_bstrClsid)          SysFreeString(m_bstrClsid);
}

STDMETHODIMP CMMCTask::get_DisplayObject (IDispatch** pDispatch)
{
    IDispatchPtr spDispatch = m_spDisplayObject;
    *pDispatch = spDispatch.Detach();
    return S_OK;
}

HRESULT CMMCTask::SetDisplayObject (MMC_TASK_DISPLAY_OBJECT* pdo)
{
    HRESULT hr = S_OK;
    CComObject<class CMMCDisplayObject>* cdo = NULL;
    CComObject<CMMCDisplayObject>::CreateInstance(&cdo);
    if (!cdo)
        hr = E_OUTOFMEMORY;
    else {
        hr = cdo->Init (pdo);
        m_spDisplayObject = cdo;
    }
    return hr;
}

STDMETHODIMP CMMCTask::get_Text(BSTR * pVal)
{
    if (m_bstrText)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrText);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_Help(BSTR * pVal)
{
    if (m_bstrHelp)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrHelp);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_ActionType(long * pVal)
{
    *pVal = m_type;
    return S_OK;
}

STDMETHODIMP CMMCTask::get_CommandID(LONG_PTR * pVal)
{
    _ASSERT (m_type == MMC_ACTION_ID);
    if (m_type != MMC_ACTION_ID)
        return E_UNEXPECTED;
    *pVal = m_ID;
    return S_OK;
}

STDMETHODIMP CMMCTask::get_ActionURL(BSTR * pVal)
{
    _ASSERT (m_type == MMC_ACTION_LINK);
    if (m_type != MMC_ACTION_LINK)
        return E_UNEXPECTED;
    if (m_bstrActionURL)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrActionURL);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_Clsid(BSTR * pVal)
{
    if (m_bstrClsid)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrClsid);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_Script(BSTR * pVal)
{
    _ASSERT (m_type == MMC_ACTION_SCRIPT);
    if (m_type != MMC_ACTION_SCRIPT)
        return E_UNEXPECTED;
    if (m_bstrScript)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrScript);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_ScriptLanguage(BSTR *pVal)
{
    _ASSERT (m_type == MMC_ACTION_SCRIPT);
    if (m_type != MMC_ACTION_SCRIPT)
        return E_UNEXPECTED;
    if (m_bstrLanguage)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrLanguage);
    return S_OK;
}


HRESULT CMMCTask::SetScript (LPOLESTR szScript)
{
    FreeActions ();

    // look for "VBSCRIPT:", "JSCRIPT:" and "JAVASCRIPT:"
    WCHAR szVBScriptColon[] = L"VBSCRIPT:";
    WCHAR szJScriptColon[] = L"JSCRIPT:";
    WCHAR szJavaScriptColon[] = L"JAVASCRIPT:";

    if (0==_wcsnicmp(szVBScriptColon, szScript, wcslen(szVBScriptColon))) 
    {
        m_bstrLanguage = SysAllocString (L"VBSCRIPT");
        szScript += wcslen(szVBScriptColon);
    } 
    else if (0==_wcsnicmp(szJScriptColon, szScript, wcslen(szJScriptColon))) 
    {
        m_bstrLanguage = SysAllocString (L"JSCRIPT");
        szScript += wcslen(szJScriptColon);
    } 
    else if (0==_wcsnicmp (szJavaScriptColon, szScript, wcslen(szJavaScriptColon))) 
    {
        m_bstrLanguage = SysAllocString (L"JAVASCRIPT");
        szScript += wcslen(szJavaScriptColon);
    } else 
    {
        m_bstrLanguage = SysAllocString (L"JAVASCRIPT");
    }
    if (!m_bstrLanguage)
        return E_OUTOFMEMORY;

    m_bstrScript = SysAllocString (szScript);
    if (m_bstrScript == NULL)
        return E_OUTOFMEMORY;
    m_type = MMC_ACTION_SCRIPT;
    return S_OK;
}
HRESULT CMMCTask::SetActionURL (LPOLESTR szActionURL)
{
    FreeActions ();
    m_bstrActionURL = SysAllocString (szActionURL);
    if (m_bstrActionURL == NULL)
        return E_OUTOFMEMORY;
    m_type = MMC_ACTION_LINK;
    return S_OK;
}

HRESULT CMMCTask::SetCommandID (LONG_PTR nID)
{
    FreeActions ();
    m_ID   = nID;
    m_type = MMC_ACTION_ID;
    return S_OK;
}
HRESULT CMMCTask::SetActionType(long nType)
{
    m_type = nType;
    return S_OK;
}
HRESULT CMMCTask::SetHelp (LPOLESTR szHelp)
{
    if (m_bstrHelp)  SysFreeString (m_bstrHelp);
    m_bstrHelp = SysAllocString (szHelp);
    if (!m_bstrHelp)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CMMCTask::SetText (LPOLESTR szText)
{
    if (m_bstrText)  SysFreeString (m_bstrText);
    m_bstrText = SysAllocString (szText);
    if (!m_bstrText)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CMMCTask::SetClsid(LPOLESTR szClsid)
{
    if (m_bstrClsid)  SysFreeString (m_bstrClsid);
    m_bstrClsid = SysAllocString (szClsid);
    if (!m_bstrClsid)
        return E_OUTOFMEMORY;
    return S_OK;
}

void CMMCTask::FreeActions ()
{
    if (m_bstrLanguage) {
        SysFreeString (m_bstrLanguage);
        m_bstrLanguage = NULL;
    }
    if (m_bstrScript) {
        SysFreeString(m_bstrScript);
        m_bstrScript = NULL;
    }
    if (m_bstrActionURL) {
        SysFreeString(m_bstrActionURL);
        m_bstrActionURL = NULL;
    }
    m_ID = 0;
    m_type = MMC_ACTION_UNINITIALIZED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF


MAJORCOMP  = admin
MINORCOMP  = cic

TARGETNAME = cic
TARGETPATH = obj
TARGETTYPE = DYNLINK

DLLENTRY   = _DllMainCRTStartup

UMTYPE     = windows

WIN32_WINNT_VERSION = 0x0400
WIN32_IE_VERSION    = 0x0500
SUBSYSTEM_VERSION   = 4.00


USE_NATIVE_EH  = 1
USE_RTTI       = 1
USE_VCCOM      = 1
USE_STATIC_ATL = 1
ATL_VER        = 30
USE_MSVCRT     = 1
USE_STL        = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	$(SDK_LIB_PATH)\mmc.lib						\
	..\..\..\core\$(CharWidth)\$(O)\uicore.lib	\
	..\..\..\base\$(CharWidth)\$(O)\mmcbase.lib

TARGETLIBS = \
	$(SDK_LIB_PATH)\kernel32.lib     \
	$(SDK_LIB_PATH)\user32.lib       \
	$(SDK_LIB_PATH)\oleaut32.lib     \
	$(SDK_LIB_PATH)\ole32.lib        \
	$(SDK_LIB_PATH)\advapi32.lib     \
	$(SDK_LIB_PATH)\uuid.lib         \
	$(SDK_LIB_PATH)\comctl32.lib     \
	$(SDK_LIB_PATH)\gdi32.lib        \
	$(SDK_LIB_PATH)\comdlg32.lib


DLLDEF = ..\cic.def

INCLUDES = \
	..;                         \
	..\idl\$(O);                \
	..\..\..\types\idl\$(O);    \
	..\..\..\inc;				\

PRECOMPILED_INCLUDE    = ..\stdafx.h
PRECOMPILED_CXX        = 1
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp

# This target is required so $(O)\cic.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$(O)\cic.res: \
	..\idl\$(O)\cic.tlb	\

SOURCES = \
	..\cic.rc           \
	..\cic.cpp          \
	..\dispobj.cpp      \
	..\listpad.cpp      \
	..\mmcctrl.cpp      \
	..\mmclpi.cpp       \
	..\mmctask.cpp      \
	..\sysclrctrl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3D5905E4_523C_11D1_9FEA_00600832DB4A__INCLUDED_)
#define AFX_STDAFX_H__3D5905E4_523C_11D1_9FEA_00600832DB4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <shellapi.h>

#include <atlbase.h>
using namespace ::ATL;
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
//#include <atlwin21.h>
#include <atlcom.h>
#include <atlctl.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include <vector>
#include <string>
#include "tstring.h"


//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
#include <strsafe.h>

//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "mmcdebug.h"
#include "mmcerror.h"

#include "classreg.h"
#include "strings.h"

#endif // !defined(AFX_STDAFX_H__3D5905E4_523C_11D1_9FEA_00600832DB4A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\sysclrctrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       sysclrctrl.cpp
//
//--------------------------------------------------------------------------

// SysColorCtrl.cpp : Implementation of CSysColorCtrl
#include "stdafx.h"
#include "cic.h"
#include "SysColorCtrl.h"

#ifndef ASSERT
#define ASSERT _ASSERT
#endif
#include <mmctempl.h>

// CPlex::Create and CPlex::FreeDataChain are needed to use CList.
// These should be moved to core.lib.  I copied them from nodemgr\plex.cpp

/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    DECLARE_SC(sc, TEXT("CPlex::Create"));
    if ( (nMax <=0) || (cbElement <= 0))
    {
        sc = E_INVALIDARG;
        return NULL;
    }

    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
                        // may throw exception
    if (!p)
    {
        sc = E_OUTOFMEMORY;
        return NULL;
    }

    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
        CPlex* p = this;
        while (p != NULL)
        {
                BYTE* bytes = (BYTE*) p;
                CPlex* pNext = p->pNext;
                delete[] bytes;
                p = pNext;
        }
}

// need to subclass the top-level window hosting this control so that
// I can be assured of receiving the WM_SYSCOLORCHANGE message
static WNDPROC g_OriginalWndProc;
static HWND g_hwndTop;

// need a list of HWNDs (one for each SysColorCtrl) so that I can notify each
// one of WM_SYSCOLORCHANGE
static CList<HWND, HWND> g_listHWND;

static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_SYSCOLORCHANGE) {
        // post message to all SysColor controls
        POSITION pos = g_listHWND.GetHeadPosition();
        while (pos) {
            HWND hwndSysColor = g_listHWND.GetNext(pos);
            if (hwndSysColor != NULL)
                PostMessage(hwndSysColor, uMsg, wParam, lParam);
        }
    }
    return CallWindowProc(g_OriginalWndProc, hwnd, uMsg, wParam, lParam);
}

static long GetHTMLColor(int nIndex)
{
    long rgb = GetSysColor(nIndex);

    // now swap the red and the blue so HTML hosts display the color properly
    return ((rgb & 0xff) << 16) + (rgb & 0xff00) + ((rgb & 0xff0000) >> 16);
}





/////////////////////////////////////////////////////////////////////////////
// CSysColorCtrl
LRESULT CSysColorCtrl::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // if no sys color controls currently exist, subclass the top level window
    if (g_listHWND.IsEmpty()) {
        g_hwndTop = GetTopLevelParent();
        g_OriginalWndProc = (WNDPROC)::SetWindowLongPtr(g_hwndTop, GWLP_WNDPROC, (LONG_PTR)&SubclassWndProc);
    }
    else {
        _ASSERT(g_hwndTop && g_OriginalWndProc);
    }

    // add this window to the list of SysColor control windows
    g_listHWND.AddTail(m_hWnd);

    bHandled = FALSE;
    return 0;
}
LRESULT CSysColorCtrl::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // remove me from the list
    POSITION pos = g_listHWND.Find(m_hWnd);
    if (pos != NULL) {
        g_listHWND.RemoveAt(pos);
    }

    // if hwnd list is empty and we've subclassed a window, undo that.
    if (g_listHWND.IsEmpty() && g_hwndTop && g_OriginalWndProc) {
        ::SetWindowLongPtr(g_hwndTop, GWLP_WNDPROC, (LONG_PTR)g_OriginalWndProc);

        g_OriginalWndProc = NULL;
        g_hwndTop = NULL;
    }

    bHandled = FALSE;
    return 0;
}




// need to post a user defined message to handle WM_SYSCOLORCHANGE to work
// around a Win95 hang when using this control inside IE.
LRESULT CSysColorCtrl::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PostMessage(WM_MYSYSCOLORCHANGE);
    return 0;
}

LRESULT CSysColorCtrl::OnMySysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Fire_SysColorChange();
    return 0;
}


//
// Utility Methods
//
STDMETHODIMP CSysColorCtrl::ConvertRGBToHex(long rgb, BSTR * pszHex)
{
    DECLARE_SC(sc, TEXT("CSysColorCtrl::ConvertRGBToHex"));
    sc = ScCheckPointers(pszHex);
    if (sc)
        return sc.ToHr();

    SysFreeString(*pszHex);
    *pszHex = SysAllocString(L"xxxxxx");
    if (NULL == *pszHex)
        return (sc = E_OUTOFMEMORY).ToHr();

    WCHAR wszPossibles[] = L"0123456789abcdef";
    int i = 0;
    (*pszHex)[i++] = wszPossibles[(rgb & 0xf00000) >> 20];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x0f0000) >> 16];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x00f000) >> 12];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x000f00) >> 8];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x0000f0) >> 4];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x00000f)];
    (*pszHex)[i] = 0;

    return sc.ToHr();
}

STDMETHODIMP CSysColorCtrl::ConvertHexToRGB(BSTR szHex, long * pRGB)
{
    if (pRGB == NULL)
        return E_POINTER;

    // Hex string must be perfectly formatted 6 digits
    // probably should implement ISystemErrorInfo to give user more info
    // on usage errors
    if (6 != wcslen(szHex))
        return E_INVALIDARG;

    long nRed, nGreen, nBlue;
    nRed = nGreen = nBlue = 0;

    nRed += ValueOfHexDigit(szHex[0]) * 16;
    nRed += ValueOfHexDigit(szHex[1]);

    nGreen += ValueOfHexDigit(szHex[2]) * 16;
    nGreen += ValueOfHexDigit(szHex[3]);

    nBlue += ValueOfHexDigit(szHex[4]) * 16;
    nBlue += ValueOfHexDigit(szHex[5]);

    *pRGB = (nRed << 16) + (nGreen << 8) + nBlue;
    return S_OK;
}

STDMETHODIMP CSysColorCtrl::GetRedFromRGB(long rgb, short * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // for html, rgb is 00RR GGBB, not 00BB GGRR
    *pVal = LOWORD ((rgb & 0xff0000) >> 16);

    return S_OK;
}

STDMETHODIMP CSysColorCtrl::GetGreenFromRGB(long rgb, short * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // for html, rgb is 00RR GGBB, not 00BB GGRR
    *pVal = LOWORD ((rgb & 0x00ff00) >> 8);

    return S_OK;
}

STDMETHODIMP CSysColorCtrl::GetBlueFromRGB(long rgb, short * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // for html, rgb is 00RR GGBB, not 00BB GGRR
    *pVal = LOWORD ((rgb & 0x0000ff));

    return S_OK;
}



// strings supported for format
#define CSS_FORMAT L"CSS"
#define HEX_FORMAT L"HEX"
#define RGB_FORMAT L"RGB"

//
// private utility method for getting rgb from string based on format
//
HRESULT CSysColorCtrl::RGBFromString(BSTR pszColor, BSTR pszFormat, long * pRGB)
{
    DECLARE_SC(sc, TEXT("CSysColorCtrl::RGBFromString"));
    sc = ScCheckPointers(pRGB);
    if (sc)
        return sc.ToHr();

    LPWSTR pszDupFormat = _wcsdup(pszFormat);
    if (!pszDupFormat)
        return (sc = E_OUTOFMEMORY).ToHr();

    LPWSTR pszUpper = NULL;
    LPWSTR pszLower = NULL;

    pszUpper = _wcsupr(pszDupFormat);

    *pRGB = -1;
    if (0 == wcscmp(pszUpper, RGB_FORMAT)) {
        *pRGB = _wtol(pszColor);
    }
    else if (0 == wcscmp(pszUpper, HEX_FORMAT)) {
        sc = ConvertHexToRGB(pszColor, pRGB);
        if (sc.ToHr() != S_OK)
            goto Cleanup;
    }
    else if (0 == wcscmp(pszUpper, CSS_FORMAT)) {
        LPWSTR pszDupColor = _wcsdup(pszColor);
        if (!pszDupColor)
        {
            sc = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pszLower = _wcslwr(pszDupColor);
        if (0 == wcscmp(L"activeborder", pszLower)) {
            get_RGBactiveborder(pRGB);
        }
        else if (0 == wcscmp(L"activecaption", pszLower)) {
            get_RGBactivecaption(pRGB);
        }
        else if (0 == wcscmp(L"appworkspace", pszLower)) {
            get_RGBappworkspace(pRGB);
        }
        else if (0 == wcscmp(L"background", pszLower)) {
            get_RGBbackground(pRGB);
        }
        else if (0 == wcscmp(L"buttonface", pszLower)) {
            get_RGBbuttonface(pRGB);
        }
        else if (0 == wcscmp(L"buttonhighlight", pszLower)) {
            get_RGBbuttonhighlight(pRGB);
        }
        else if (0 == wcscmp(L"buttonshadow", pszLower)) {
            get_RGBbuttonshadow(pRGB);
        }
        else if (0 == wcscmp(L"buttontext", pszLower)) {
            get_RGBbuttontext(pRGB);
        }
        else if (0 == wcscmp(L"captiontext", pszLower)) {
            get_RGBcaptiontext(pRGB);
        }
        else if (0 == wcscmp(L"graytext", pszLower)) {
            get_RGBgraytext(pRGB);
        }
        else if (0 == wcscmp(L"highlight", pszLower)) {
            get_RGBhighlight(pRGB);
        }
        else if (0 == wcscmp(L"highlighttext", pszLower)) {
            get_RGBhighlighttext(pRGB);
        }
        else if (0 == wcscmp(L"inactiveborder", pszLower)) {
            get_RGBinactiveborder(pRGB);
        }
        else if (0 == wcscmp(L"inactivecaption", pszLower)) {
            get_RGBinactivecaption(pRGB);
        }
        else if (0 == wcscmp(L"inactivecaptiontext", pszLower)) {
            get_RGBinactivecaptiontext(pRGB);
        }
        else if (0 == wcscmp(L"infobackground", pszLower)) {
            get_RGBinfobackground(pRGB);
        }
        else if (0 == wcscmp(L"infotext", pszLower)) {
            get_RGBinfotext(pRGB);
        }
        else if (0 == wcscmp(L"menu", pszLower)) {
            get_RGBmenu(pRGB);
        }
        else if (0 == wcscmp(L"menutext", pszLower)) {
            get_RGBmenutext(pRGB);
        }
        else if (0 == wcscmp(L"scrollbar", pszLower)) {
            get_RGBscrollbar(pRGB);
        }
        else if (0 == wcscmp(L"threeddarkshadow", pszLower)) {
            get_RGBthreeddarkshadow(pRGB);
        }
        else if (0 == wcscmp(L"threedface", pszLower)) {
            get_RGBthreedface(pRGB);
        }
        else if (0 == wcscmp(L"threedhighlight", pszLower)) {
            get_RGBthreedhighlight(pRGB);
        }
        else if (0 == wcscmp(L"threedlightshadow", pszLower)) {
            get_RGBthreedlightshadow(pRGB);
        }
        else if (0 == wcscmp(L"threedshadow", pszLower)) {
            get_RGBthreedshadow(pRGB);
        }
        else if (0 == wcscmp(L"window", pszLower)) {
            get_RGBwindow(pRGB);
        }
        else if (0 == wcscmp(L"windowframe", pszLower)) {
            get_RGBwindowframe(pRGB);
        }
        else if (0 == wcscmp(L"windowtext", pszLower)) {
            get_RGBwindowtext(pRGB);
        }
        else {
            sc = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else {
        // should set some error here such as through ISystemErrorInfo
        sc = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    if (pszUpper)
        free(pszUpper);

    if (pszLower)
        free(pszLower);

    return sc.ToHr();
}

//
// Private utility method using only RGB format for deriving colors based
// on a starting color, a color to move towards, and a percentage to move
// towards that color.
//
HRESULT CSysColorCtrl::GetDerivedRGBFromRGB(long rgbFrom,
                                            long rgbTo,
                                            short nPercent,
                                            long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // nPercent must be between 0 and 100
    // probably should implement ISystemErrorInfo to give user more info
    // on usage errors
    if (nPercent < 0 || nPercent > 100)
        return E_INVALIDARG;

    // get the derived color based on starting color, ending color, and percentage
    // color = color + (colorTo - colorFrom) * (nPercent/100);
    long nRedFrom = (rgbFrom & 0xff0000) >> 16;
    long nRedTo = (rgbTo & 0xff0000) >> 16;
    long nRed = nRedFrom + ((nRedTo - nRedFrom)*nPercent/100);

    long nGreenFrom = (rgbFrom & 0x00ff00) >> 8;
    long nGreenTo = (rgbTo & 0x00ff00) >> 8;
    long nGreen = nGreenFrom + ((nGreenTo - nGreenFrom)*nPercent/100);

    long nBlueFrom = (rgbFrom & 0x0000ff);
    long nBlueTo = (rgbTo & 0x0000ff);
    long nBlue = nBlueFrom + ((nBlueTo - nBlueFrom)*nPercent/100);

    *pVal = (nRed << 16) + (nGreen << 8) + nBlue;
    return S_OK;
}

//
// Method for Deriving colors based on a starting color,
// a color to move towards, and a percentage to move towards that color.
//
STDMETHODIMP CSysColorCtrl::GetDerivedRGB(/*[in]*/ BSTR pszFrom,
                                          /*[in]*/ BSTR pszTo,
                                          /*[in]*/ BSTR pszFormat,
                                          /*[in]*/ short nPercent,
                                          /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    //
    // get everything into RGB format, then calculate derived color
    //

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1, rgbTo = -1;
    HRESULT hr;

    hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    hr = RGBFromString(pszTo, pszFormat, &rgbTo);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, rgbTo, nPercent, pVal);
}

STDMETHODIMP CSysColorCtrl::GetDerivedHex(/*[in]*/ BSTR pszFrom,
                                          /*[in]*/ BSTR pszTo,
                                          /*[in]*/ BSTR pszFormat,
                                          /*[in]*/ short nPercent,
                                          /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    long rgb;
    HRESULT hr = GetDerivedRGB(pszFrom, pszTo, pszFormat, nPercent, &rgb);
    if (hr != S_OK)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}


STDMETHODIMP CSysColorCtrl::Get3QuarterLightRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 75, pVal);
}

STDMETHODIMP CSysColorCtrl::Get3QuarterLightHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 75, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfLightRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 50, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfLightHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 50, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterLightRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 25, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterLightHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 25, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}
STDMETHODIMP CSysColorCtrl::Get3QuarterDarkRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 75, pVal);
}

STDMETHODIMP CSysColorCtrl::Get3QuarterDarkHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 75, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfDarkRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 50, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfDarkHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 50, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterDarkRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 25, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterDarkHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 25, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}




//
// Properties
//

// use macro so this is easily extensible to include more properties
// Should probably move this whole thing to header to be in-line
// for even easier extensibility
#define GETPROPSIMPL(methodname, color_value) \
STDMETHODIMP CSysColorCtrl::get_HEX##methodname(BSTR * pVal) { \
    return ConvertRGBToHex(GetHTMLColor(color_value), pVal); \
} \
STDMETHODIMP CSysColorCtrl::get_RGB##methodname(long * pVal) { \
    if (pVal == NULL) return E_POINTER; \
    *pVal = GetHTMLColor(color_value); \
    return S_OK; \
}

GETPROPSIMPL(activeborder, COLOR_ACTIVEBORDER)
GETPROPSIMPL(activecaption, COLOR_ACTIVECAPTION)
GETPROPSIMPL(appworkspace, COLOR_APPWORKSPACE)
GETPROPSIMPL(background, COLOR_BACKGROUND)
GETPROPSIMPL(buttonface, COLOR_BTNFACE)
GETPROPSIMPL(buttonhighlight, COLOR_BTNHIGHLIGHT)
GETPROPSIMPL(buttonshadow, COLOR_BTNSHADOW)
GETPROPSIMPL(buttontext, COLOR_BTNTEXT)
GETPROPSIMPL(captiontext, COLOR_CAPTIONTEXT)
GETPROPSIMPL(graytext, COLOR_GRAYTEXT)
GETPROPSIMPL(highlight, COLOR_HIGHLIGHT)
GETPROPSIMPL(highlighttext, COLOR_HIGHLIGHTTEXT)
GETPROPSIMPL(inactiveborder, COLOR_INACTIVEBORDER)
GETPROPSIMPL(inactivecaption, COLOR_INACTIVECAPTION)
GETPROPSIMPL(inactivecaptiontext, COLOR_INACTIVECAPTIONTEXT)
GETPROPSIMPL(infobackground, COLOR_INFOBK)
GETPROPSIMPL(infotext, COLOR_INFOTEXT)
GETPROPSIMPL(menu, COLOR_MENU)
GETPROPSIMPL(menutext, COLOR_MENUTEXT)
GETPROPSIMPL(scrollbar, COLOR_SCROLLBAR)
GETPROPSIMPL(threeddarkshadow, COLOR_3DDKSHADOW)
GETPROPSIMPL(threedface, COLOR_3DFACE)
GETPROPSIMPL(threedhighlight, COLOR_3DHIGHLIGHT)
GETPROPSIMPL(threedlightshadow, COLOR_3DLIGHT) // Is this correct?
GETPROPSIMPL(threedshadow, COLOR_3DSHADOW)
GETPROPSIMPL(window, COLOR_WINDOW)
GETPROPSIMPL(windowframe, COLOR_WINDOWFRAME)
GETPROPSIMPL(windowtext, COLOR_WINDOWTEXT)



//
// Protected methods
//
int CSysColorCtrl::ValueOfHexDigit(WCHAR wch)
{
    switch (wch) {
    case L'0':
        return 0;
    case L'1':
        return 1;
    case L'2':
        return 2;
    case L'3':
        return 3;
    case L'4':
        return 4;
    case L'5':
        return 5;
    case L'6':
        return 6;
    case L'7':
        return 7;
    case L'8':
        return 8;
    case L'9':
        return 9;
    case L'a':
    case L'A':
        return 10;
    case L'b':
    case L'B':
        return 11;
    case L'c':
    case L'C':
        return 12;
    case L'd':
    case L'D':
        return 13;
    case L'e':
    case L'E':
        return 14;
    case L'f':
    case L'F':
        return 15;
    }

    ATLTRACE(_T("Unrecognized Hex Digit: '%c'"), wch);
    return 0;
} // ValueOfHexDigit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\controls\cic\syscolorctrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       syscolorctrl.h
//
//--------------------------------------------------------------------------

// SysColorCtrl.h : Declaration of the CSysColorCtrl

#ifndef __SYSCOLORCTRL_H_
#define __SYSCOLORCTRL_H_

#include "resource.h"       // main symbols
#include "CPsyscolor.h"

// window message to be used to send myself a message to fire the event
#define WM_MYSYSCOLORCHANGE WM_USER+1

// need to subclass the top-level window hosting this control so that
// I can be assured of receiving the WM_SYSCOLORCHANGE message
//BOOL SetupSubclass(HWND hwndTopLevel);

/////////////////////////////////////////////////////////////////////////////
// CSysColorCtrl
class ATL_NO_VTABLE CSysColorCtrl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSysColorCtrl, &CLSID_SysColorCtrl>,
    public CComControl<CSysColorCtrl>,
    public IDispatchImpl<ISysColorCtrl, &IID_ISysColorCtrl, &LIBID_CICLib>,
    public IProvideClassInfo2Impl<&CLSID_SysColorCtrl, &DIID__SysColorEvents, &LIBID_CICLib>,
    public IPersistStreamInitImpl<CSysColorCtrl>,
    public IPersistStorageImpl<CSysColorCtrl>,
    public IQuickActivateImpl<CSysColorCtrl>,
    public IOleControlImpl<CSysColorCtrl>,
    public IOleObjectImpl<CSysColorCtrl>,
    public IOleInPlaceActiveObjectImpl<CSysColorCtrl>,
    public IObjectSafetyImpl<CSysColorCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IViewObjectExImpl<CSysColorCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CSysColorCtrl>,
    public IDataObjectImpl<CSysColorCtrl>,
    public ISpecifyPropertyPagesImpl<CSysColorCtrl>,
    public CProxy_SysColorEvents<CSysColorCtrl>,
    public IConnectionPointContainerImpl<CSysColorCtrl>
{
public:
    CSysColorCtrl()
    {
        m_bWindowOnly = TRUE;
    }

    DECLARE_MMC_CONTROL_REGISTRATION(
		g_szCicDll,
        CLSID_SysColorCtrl,
        _T("SysColorCtrl class"),
        _T("SysColorCtrl.SysColorCtrl.1"),
        _T("SysColorCtrl.SysColorCtrl"),
        LIBID_CICLib,
        _T("1"),
        _T("1.0"))

BEGIN_COM_MAP(CSysColorCtrl)
    COM_INTERFACE_ENTRY(ISysColorCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CSysColorCtrl)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CSysColorCtrl)
    CONNECTION_POINT_ENTRY(DIID__SysColorEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CSysColorCtrl)
//  MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
//  MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
//  MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
    MESSAGE_HANDLER(WM_MYSYSCOLORCHANGE, OnMySysColorChange)
END_MSG_MAP()

#if 0
// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }
#endif

    // need to override TranslateAccelerator in order to work around a
    // "feature" in IE4.  Description of the problem can be found in
    // KB article Q169434.  From the KB article:
    //
    // CAUSE: In-place active objects must always be given the first
    // chance at translating accelerator keystrokes. To satisfy this
    // requirement, the Internet Explorer calls an ActiveX control's
    // IOleInPlaceActiveObject::TranslateAccelerator method. The default
    // ATL implementation of TranslateAccelerator does not pass the
    // keystroke to the container.
    STDMETHOD(TranslateAccelerator)(MSG *pMsg) {
        CComQIPtr<IOleControlSite,&IID_IOleControlSite>
        spCtrlSite(m_spClientSite);
        if(spCtrlSite) {
            return spCtrlSite->TranslateAccelerator(pMsg,0);
        }
        return S_FALSE;
    }

// ISysColorCtrl
public:
    STDMETHOD(ConvertRGBToHex)(/*[in]*/ long rgb, /*[out, retval]*/ BSTR *pszHex);
    STDMETHOD(ConvertHexToRGB)(/*[in]*/ BSTR szHex, /*[out, retval]*/ long * pRGB);
    STDMETHOD(GetRedFromRGB)(/*[in]*/ long rgb, /*[out, retval]*/ short* pVal);
    STDMETHOD(GetGreenFromRGB)(/*[in]*/ long rgb, /*[out, retval]*/ short* pVal);
    STDMETHOD(GetBlueFromRGB)(/*[in]*/ long rgb, /*[out, retval]*/ short* pVal);

    STDMETHOD(GetDerivedRGB)(/*[in]*/ BSTR pszFrom,
                             /*[in]*/ BSTR pszTo,
                             /*[in]*/ BSTR pszFormat,
                             /*[in]*/ short nPercent,
                             /*[out, retval]*/ long * pVal);

    STDMETHOD(GetDerivedHex)(/*[in]*/ BSTR pszFrom,
                             /*[in]*/ BSTR pszTo,
                             /*[in]*/ BSTR pszFormat,
                             /*[in]*/ short nPercent,
                             /*[out, retval]*/ BSTR * pVal);

    // Wrapper methods
    // derived "light" methods calculate a color based the requested percentage from
    // a given color to white.
    STDMETHOD(Get3QuarterLightRGB)(/*[in]*/ BSTR pszFrom,
                                   /*[in]*/ BSTR pszFormat,
                                   /*[out, retval]*/ long * pVal);

    STDMETHOD(Get3QuarterLightHex)(/*[in]*/ BSTR pszFrom,
                                   /*[in]*/ BSTR pszFormat,
                                   /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetHalfLightRGB)(/*[in]*/ BSTR pszFrom,
                               /*[in]*/ BSTR pszFormat,
                               /*[out, retval]*/ long * pVal);

    STDMETHOD(GetHalfLightHex)(/*[in]*/ BSTR pszFrom,
                               /*[in]*/ BSTR pszFormat,
                               /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetQuarterLightRGB)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ long * pVal);

    STDMETHOD(GetQuarterLightHex)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ BSTR * pVal);

    // derived "dark" methods calculate a color based the requested percentage from
    // a given color to black.
    STDMETHOD(Get3QuarterDarkRGB)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ long * pVal);

    STDMETHOD(Get3QuarterDarkHex)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetHalfDarkRGB)(/*[in]*/ BSTR pszFrom,
                              /*[in]*/ BSTR pszFormat,
                              /*[out, retval]*/ long * pVal);

    STDMETHOD(GetHalfDarkHex)(/*[in]*/ BSTR pszFrom,
                              /*[in]*/ BSTR pszFormat,
                              /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetQuarterDarkRGB)(/*[in]*/ BSTR pszFrom,
                                 /*[in]*/ BSTR pszFormat,
                                 /*[out, retval]*/ long * pVal);

    STDMETHOD(GetQuarterDarkHex)(/*[in]*/ BSTR pszFrom,
                                 /*[in]*/ BSTR pszFormat,
                                 /*[out, retval]*/ BSTR * pVal);

    // properties - use macro for easy extensibility
#define GETPROPS(prop_name) \
    STDMETHOD(get_RGB##prop_name)(/*[out, retval]*/ long *pVal); \
    STDMETHOD(get_HEX##prop_name)(/*[out, retval]*/ BSTR *pVal);

    GETPROPS(activeborder)
    GETPROPS(activecaption)
    GETPROPS(appworkspace)
    GETPROPS(background)
    GETPROPS(buttonface)
    GETPROPS(buttonhighlight)
    GETPROPS(buttonshadow)
    GETPROPS(buttontext)
    GETPROPS(captiontext)
    GETPROPS(graytext)
    GETPROPS(highlight)
    GETPROPS(highlighttext)
    GETPROPS(inactiveborder)
    GETPROPS(inactivecaption)
    GETPROPS(inactivecaptiontext)
    GETPROPS(infobackground)
    GETPROPS(infotext)
    GETPROPS(menu)
    GETPROPS(menutext)
    GETPROPS(scrollbar)
    GETPROPS(threeddarkshadow)
    GETPROPS(threedface)
    GETPROPS(threedhighlight)
    GETPROPS(threedlightshadow)
    GETPROPS(threedshadow)
    GETPROPS(window)
    GETPROPS(windowframe)
    GETPROPS(windowtext)

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMySysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    int ValueOfHexDigit(WCHAR wch);
    HRESULT RGBFromString(BSTR pszColor, BSTR pszFormat, long * pRGB);
    HRESULT GetDerivedRGBFromRGB(long rgbFrom, long rgbTo, short nPercent, long * pVal);
};


#endif //__SYSCOLORCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcdoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcdoc.cpp
//
//--------------------------------------------------------------------------

// AMCDoc.cpp : implementation of the CAMCDoc class
//


#include "stdafx.h"
#include "AMC.h"

#include "AMCDoc.h"
#include "AMCView.h"
#include "treectrl.h"
#include "mainfrm.h"
#include "cclvctl.h"
#include "props.h"
#include <algorithm>
#include <vector>
#include <list>

#include "amcmsgid.h"
#include "amcpriv.h"
#include "mmcutil.h"
#include "ndmgrp.h"
#include "strtable.h"
#include "stgio.h"
#include "comdbg.h"
#include "favorite.h"
#include "mscparser.h"
#include "scriptevents.h"
// helper
tstring GetCurrentFileVersionAsString();

//############################################################################
//############################################################################
//
//  Implementation of class CMMCDocument
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CMMCDocument
 *
 *
 * PURPOSE: The COM 0bject that exposes the Document interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCDocument :
    public CMMCIDispatchImpl<Document>,
    public CTiedComObject<CAMCDoc>
{
public:
    typedef CAMCDoc CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CMMCDocument)
    END_MMC_COM_MAP()

    //Document interface
public:
    MMC_METHOD0(Save);
    MMC_METHOD1(SaveAs,         BSTR /*bstrFilename*/);
    MMC_METHOD1(Close,          BOOL /*bSaveChanges*/);
    MMC_METHOD1(CreateProperties, PPPROPERTIES  /*ppProperties*/);

    // properties
    MMC_METHOD1(get_Views,      PPVIEWS   /*ppViews*/);
    MMC_METHOD1(get_SnapIns,    PPSNAPINS /*ppSnapIns*/);
    MMC_METHOD1(get_ActiveView, PPVIEW    /*ppView*/);
    MMC_METHOD1(get_Name,       PBSTR     /*pbstrName*/);
    MMC_METHOD1(put_Name,       BSTR      /*bstrName*/);
    MMC_METHOD1(get_Location,   PBSTR    /*pbstrLocation*/);
    MMC_METHOD1(get_IsSaved,    PBOOL    /*pBIsSaved*/);
    MMC_METHOD1(get_Mode,       PDOCUMENTMODE /*pMode*/);
    MMC_METHOD1(put_Mode,       DocumentMode /*mode*/);
    MMC_METHOD1(get_RootNode,   PPNODE     /*ppNode*/);
    MMC_METHOD1(get_ScopeNamespace, PPSCOPENAMESPACE  /*ppScopeNamespace*/);
    MMC_METHOD1(get_Application, PPAPPLICATION  /*ppApplication*/);
};

/*+-------------------------------------------------------------------------*
 * class CMMCViews
 *
 *
 * PURPOSE: The COM 0bject that exposes the Views interface.
 *
 *+-------------------------------------------------------------------------*/

// the real CMMCViews is typedef'd below.
class _CMMCViews :
    public CMMCIDispatchImpl<Views>, // the Views interface
    public CTiedComObject<CAMCDoc>
{
public:
    typedef CAMCDoc CMyTiedObject;

    BEGIN_MMC_COM_MAP(_CMMCViews)
    END_MMC_COM_MAP()

    // Views interface
public:
    MMC_METHOD1(get_Count,  PLONG /*pCount*/);
    MMC_METHOD2(Add,        PNODE /*pNode*/, ViewOptions /*fViewOptions*/);
    MMC_METHOD2(Item,       long  /*Index*/, PPVIEW /*ppView*/);
};

// this typedefs the real CMMCViews class. Implements get__NewEnum using CMMCEnumerator and a CAMCViewPosition object
typedef CMMCNewEnumImpl<_CMMCViews, CAMCViewPosition> CMMCViews;


//############################################################################
//############################################################################
//
//  Implementation of class CStringTableString
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * CStringTableString::GetStringTable
 *
 *
 *--------------------------------------------------------------------------*/
IStringTablePrivate* CStringTableString::GetStringTable () const
{
    return (CAMCDoc::GetDocument()->GetStringTable());
}

void ShowAdminToolsOnMenu(LPCTSTR lpszFilename);


enum ENodeType
{
    entRoot,
    entSelected,
};

//############################################################################
//############################################################################
//
//  Implementation of class CAMCDoc
//
//############################################################################
//############################################################################

IMPLEMENT_DYNCREATE(CAMCDoc, CDocument)

BEGIN_MESSAGE_MAP(CAMCDoc, CDocument)
    //{{AFX_MSG_MAP(CAMCDoc)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
    ON_COMMAND(ID_CONSOLE_ADDREMOVESNAPIN, OnConsoleAddremovesnapin)
    ON_UPDATE_COMMAND_UI(ID_CONSOLE_ADDREMOVESNAPIN, OnUpdateConsoleAddremovesnapin)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCDoc construction/destruction

CAMCDoc* CAMCDoc::m_pDoc = NULL;

CAMCDoc::CAMCDoc()
    :   m_MTNodeIDForNewView(ROOTNODEID),
        m_ViewIDForNewView(0),
        m_lNewWindowOptions(MMC_NW_OPTION_NONE),
        m_bReadOnlyDoc(false),
        m_fFrameModified (false),
        m_eSaveStatus (eStat_Succeeded),
        m_pFavorites(NULL),
        m_bCanCloseViews(true)
{
    TRACE_CONSTRUCTOR(CAMCDoc);
    DECLARE_SC (sc, TEXT("CAMCDoc::CAMCDoc"));

    CComObject<CMasterStringTable> * pStringTable;

    sc = CComObject<CMasterStringTable>::CreateInstance (&pStringTable);
    if(sc.IsError() || !pStringTable)
    {
        sc = E_OUTOFMEMORY;
        sc.FatalError();
    }

    m_spStringTable = pStringTable; // does the addref.
    if(m_spStringTable == NULL)
    {
        delete pStringTable;
        sc = E_UNEXPECTED;
        sc.FatalError();
    }

    m_pstrCustomTitle = new CStringTableString(m_spStringTable);
    if(!m_pstrCustomTitle)
    {
        sc = E_OUTOFMEMORY;
        sc.FatalError();
    }

    if (m_pDoc)
        m_pDoc->OnCloseDocument();

    // Set default version update dialog to one appropriate for explicit saves
    SetExplicitSave(true);
    m_pDoc = this;

    m_ConsoleData.m_pConsoleDocument = this;
}

CAMCDoc::~CAMCDoc()
{
    TRACE_DESTRUCTOR(CAMCDoc);

    if (m_pDoc == this)
        m_pDoc = NULL;

    if(m_pFavorites != NULL)
    {
        delete m_pFavorites;
        m_pFavorites = NULL;
    }

    delete m_pstrCustomTitle;

    // Tell the node manager to release it's reference on the scope tree
    IFramePrivatePtr spFrame;

    HRESULT hr = spFrame.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);

    if (hr == S_OK)
    {
        spFrame->SetScopeTree(NULL);
        ReleaseNodeManager();
    }

    /*
     * if we used a custom icon, revert to the default icon on the frame
     */
    if (m_CustomIcon)
    {
        CMainFrame* pMainFrame = AMCGetMainWnd();

        if (pMainFrame != NULL)
        {
            pMainFrame->SetIconEx (NULL, true);
            pMainFrame->SetIconEx (NULL, false);
        }
    }
}

void CAMCDoc::ReleaseNodeManager()
{
    m_spScopeTreePersist = NULL;
    m_spScopeTree = NULL;
    m_spStorage = NULL;
}


//############################################################################
//############################################################################
//
//  CAMCDoc Object model methods.
//
//############################################################################
//############################################################################

// Document interface

/*+-------------------------------------------------------------------------*
 * CAMCDoc::ScCreateProperties
 *
 * Creates an empty Properties collection.
 *
 * Returns:
 *      E_UNEXPECTED    scope tree wasn't available
 *      other           value returned by IScopeTree::CreateProperties
 *--------------------------------------------------------------------------*/

SC CAMCDoc::ScCreateProperties (Properties** ppProperties)
{
    DECLARE_SC (sc, _T("CAMCDoc::ScCreateProperties"));

    /*
     * insure we have a scope tree; ppProperties will be validated downstream
     */
    if (m_spScopeTree == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * get the scope tree to create a Properties collection for us
     */
    sc = m_spScopeTree->CreateProperties (ppProperties);
    if (sc)
        return (sc);

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScEnumNext
 *
 * PURPOSE: Returns the next item in the enumeration sequence
 *
 * PARAMETERS:
 *    _Position & pos :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScEnumNext(CAMCViewPosition &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScEnumNext"));

    CAMCView *pView = GetNextAMCView(pos);

    if(NULL ==pView) // ran out of elements
    {
        sc = S_FALSE;
        return sc;
    }

    // at this point, we have a valid CAMCView.
    ViewPtr spMMCView = NULL;

    sc = pView->ScGetMMCView(&spMMCView);
    if(sc)
        return sc;

    if(spMMCView == NULL)
    {
        sc = E_UNEXPECTED;  // should never happen.
        return sc;
    }

    /*
     * return the IDispatch for the object and leave a ref on it for the client
     */
    pDispatch = spMMCView.Detach();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScEnumSkip
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    unsigned   long :
 *    CAMCViewPosition & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,
                    CAMCViewPosition &pos)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScEnumSkip"));

    // skip celt positions, don't check the last skip.
    for(celtSkipped=0; celtSkipped<celt; celtSkipped++)
    {
        if (pos == NULL)
        {
            sc = S_FALSE;
            return sc;
        }

        // go to the next view
        GetNextAMCView(pos);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScEnumReset
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CAMCViewPosition & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScEnumReset(CAMCViewPosition &pos)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScEnumReset"));

    // reset the position to the first view.
    pos = GetFirstAMCViewPosition();

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::ScSave
//
//  Synopsis:    Saves the document.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::ScSave ()
{
    DECLARE_SC(sc, _T("CAMCDoc::ScSave"));

    // Return if there is no file name given.
    if (m_strPathName.IsEmpty())
        return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);

    // save the document (this function may produce UI, but we tried ^ to avoid it)
    if (!DoFileSave())
        return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScSaveAs
 *
 * PURPOSE: Saves the console file, using the specified filename.
 *
 * PARAMETERS:
 *    BSTR  bstrFilename : The path to save the file to.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScSaveAs(BSTR bstrFilename)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScSaveAs"));

    USES_CONVERSION;

    LPCTSTR lpctstrName = OLE2T(bstrFilename);
    if(!OnSaveDocument(lpctstrName))
    {
        sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);
        return sc;
    }
    else
    {
        DeleteHelpFile ();
        SetPathName(lpctstrName);
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCDoc::ScClose
 *
 * PURPOSE: implements Document.Close for object model
 *
 * PARAMETERS:
 *    BOOL bSaveChanges - save changes before closing
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CAMCDoc::ScClose(BOOL bSaveChanges)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScClose"));

    if (bSaveChanges)
    {
        // cannot save ned document this way!
        if (m_strPathName.IsEmpty())
            return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);

        // check for property sheets open
        if (FArePropertySheetsOpen(NULL))
            return sc = ScFromMMC(IDS_ClosePropertyPagesBeforeClosingTheDoc);

        // save the document (this function may produce UI, but we tried ^ to avoid it)
        if (!DoFileSave())
            return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);
    }

    OnCloseDocument();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScItem
 *
 * PURPOSE: Returns the view specified by the index.
 *
 * PARAMETERS:
 *    long    Index :
 *    View ** ppView :
 *
 * RETURNS:
 *    STDMETHOD
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScItem(long Index, PPVIEW ppView)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScItem"));

    // check parameters
    if( (Index <= 0) ||  (Index > GetNumberOfViews()) || (!ppView) )
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // step to the appropriate view
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    CAMCView *pView = NULL;

    for (int nCount = 0; (nCount< Index) && (pos != NULL); )
    {
        pView = GetNextAMCView(pos);
        VERIFY (++nCount);
    }

    // make sure we have a valid view.

    if( (nCount != Index) || (!pView) )
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = pView->ScGetMMCView(ppView);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScMapViewOptions
 *
 * PURPOSE: helper function maps ViewOptions to view creation flags
 *
 * PARAMETERS:
 *    pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/

static SC ScMapViewOptions( ViewOptions fViewOptions, DWORD &value)
{
    DECLARE_SC(sc, TEXT("ScMapViewOptions"));

    value = MMC_NW_OPTION_NONE;

    // test to see if parameter is correct
    const DWORD mask = (ViewOption_ScopeTreeHidden |
                        ViewOption_NoToolBars |
                        ViewOption_NotPersistable
                       );

    if (fViewOptions & (~mask))
        sc = E_INVALIDARG;

    if (fViewOptions & ViewOption_ScopeTreeHidden)
        value |= MMC_NW_OPTION_NOSCOPEPANE;
    if (fViewOptions & ViewOption_NotPersistable)
        value |= MMC_NW_OPTION_NOPERSIST;
    if (fViewOptions & ViewOption_NoToolBars)
        value |= MMC_NW_OPTION_NOTOOLBARS;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScAdd
 *
 * PURPOSE: Impelements Views.Add method
 *
 * PARAMETERS:
 *    pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScAdd( PNODE pNode, ViewOptions fViewOptions )
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScAdd"));

    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    sc = ScCheckPointers(m_spScopeTree, E_POINTER);
    if (sc)
        return sc;

    DWORD dwOptions = 0;
    sc = ScMapViewOptions( fViewOptions, dwOptions );
    if (sc)
        return sc;

    MTNODEID id;
    sc = m_spScopeTree->GetNodeID(pNode, &id);
    if (sc)
        return sc;

    // Set the given node-id as the root.
    SetMTNodeIDForNewView(id);
    SetNewWindowOptions(dwOptions);
    CreateNewView( true );
    SetMTNodeIDForNewView(ROOTNODEID);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_Views
 *
 * PURPOSE: Returns a pointer to the Views interface
 *          (which is implemented by the same object, but need not be)
 *
 * PARAMETERS:
 *    Views ** ppViews :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_Views(PPVIEWS ppViews)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_Views"));

    if(!ppViews)
    {
        sc = E_POINTER;
        return sc;
    }

    // init out parameter
    *ppViews = NULL;

    // create a Views if needed.
    sc = CTiedComObjectCreator<CMMCViews>::ScCreateAndConnect(*this, m_spViews);
    if(sc)
        return sc;

    sc = ScCheckPointers(m_spViews, E_UNEXPECTED);
    if (sc)
        return sc;

    // addref the pointer for the client.
    m_spViews->AddRef();
    *ppViews = m_spViews;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_SnapIns
 *
 * PURPOSE: returns a pointer to the SnapIns object.
 *
 * PARAMETERS:
 *    SnapIns ** ppSnapIns :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_SnapIns(PPSNAPINS ppSnapIns)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_SnapIns"));

    if((NULL==ppSnapIns) || (NULL == m_spScopeTree) )
    {
        sc = E_POINTER;
        return sc;
    }

    sc = m_spScopeTree->QuerySnapIns(ppSnapIns);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_ScopeNamespace
 *
 * PURPOSE: returns a pointer to the ScopeNamespace object.
 *
 * PARAMETERS:
 *    ScopeNamespace ** ppScopeNamespace :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_ScopeNamespace(PPSCOPENAMESPACE ppScopeNamespace)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_ScopeNamespace"));

    if((NULL==ppScopeNamespace) || (NULL == m_spScopeTree) )
    {
        sc = E_POINTER;
        return sc;
    }

    sc = m_spScopeTree->QueryScopeNamespace(ppScopeNamespace);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_Count
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    long * pCount :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_Count(PLONG pCount)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_Count"));

    // check parameters
    if(!pCount)
    {
        sc = E_POINTER;
        return sc;
    }

    // this should *not* be GetNumberOfPersistedViews
    *pCount = GetNumberOfViews();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_Name
//
//  Synopsis:    Retrive the name of the current doc.
//
//  Arguments:   [pbstrName] - Ptr to the name to be returned.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_Name (PBSTR pbstrName)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_Name"));
    sc = ScCheckPointers(pbstrName);
    if (sc)
        return sc;

    CString strPath = GetPathName();

    *pbstrName = strPath.AllocSysString();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scput_Name
//
//  Synopsis:    Sets the name of the current document.
//
//  Arguments:   [bstrName] - The new name.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scput_Name(BSTR bstrName)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scput_Name"));

    USES_CONVERSION;
    LPCTSTR lpszPath = OLE2CT(bstrName);

    SetPathName(lpszPath, FALSE /*Dont add to MRU*/);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_Mode
//
//  Synopsis:    Retrieve the document mode.
//
//  Arguments:   [pMode] - Ptr to doc mode.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_Mode (PDOCUMENTMODE pMode)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_Mode"));
    sc = ScCheckPointers(pMode);
    if (sc)
        return sc;

    if (! GetDocumentMode(pMode))
        return (sc = E_FAIL);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scput_Mode
//
//  Synopsis:    Modify the document mode.
//
//  Arguments:   [mode] - new mode for the document.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scput_Mode (DocumentMode mode)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scput_Mode"));

    // SetDocumentMode fails if document mode is invalid.
    if (! SetDocumentMode(mode))
        return (sc = E_INVALIDARG);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_ActiveView
//
//  Synopsis:    Retrieve the Active View object.
//
//  Arguments:   [ppView] - Ptr to a ptr of View object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_ActiveView (PPVIEW ppView)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_ActiveView"));
    sc = ScCheckPointers(ppView);
    if (sc)
        return sc;

    *ppView = NULL;

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    CAMCView *pView = pMainFrame->GetActiveAMCView();
    if (! pView)
    {
        return (sc = ScFromMMC(IDS_NoActiveView)); // There are no active views.
    }

    // at this point, we have a valid CAMCView.
    ViewPtr spMMCView = NULL;

    sc = pView->ScGetMMCView(&spMMCView);
    if(sc)
        return sc;

    sc = ScCheckPointers(spMMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    /*
     * return the object and leave a ref on it for the client
     */
    *ppView = spMMCView.Detach();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_IsSaved
//
//  Synopsis:    Returns whether the file was saved. If not,
//               it is dirty and needs to be saved.
//
//  Arguments:   [pBIsSaved] - Ptr to BOOL (IsSaved info).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_IsSaved (PBOOL pBIsSaved)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_IsSaved"));
    sc = ScCheckPointers(pBIsSaved);
    if (sc)
        return sc;

    *pBIsSaved = (IsModified() == FALSE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_Location
//
//  Synopsis:    Gets the location of the current document.
//
//  Arguments:   [pbstrLocation] - Ptr to BSTR string in which result is returned.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_Location (PBSTR    pbstrLocation)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_Location"));
    sc = ScCheckPointers(pbstrLocation);
    if (sc)
        return sc;

    CString strFullPath = GetPathName();

    // Even if path is empty below code will return empty string.
    int nSlashLoc = strFullPath.ReverseFind(_T('\\'));
    CString strLocation = strFullPath.Left(nSlashLoc);

    *pbstrLocation = strLocation.AllocSysString();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_RootNode
//
//  Synopsis:    Returns the console root node.
//
//  Arguments:   [ppNode] - Ptr to ptr to root node obj.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_RootNode (PPNODE     ppNode)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_RootNode"));
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_spScopeTree->QueryRootNode(ppNode);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScGetMMCDocument
 *
 * PURPOSE: Creates, AddRef's, and returns a pointer to the tied COM object.
 *
 * PARAMETERS:
 *    Document ** ppDocument :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScGetMMCDocument(Document **ppDocument)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScGetMMCDocument"));

    // parameter check
    sc = ScCheckPointers(ppDocument);
    if (sc)
        return sc;

    // init out parameter
    *ppDocument = NULL;

    // create a CAMCDoc if needed.
    sc = CTiedComObjectCreator<CMMCDocument>::ScCreateAndConnect(*this, m_sp_Document);
    if(sc)
        return sc;

    sc = ScCheckPointers(m_sp_Document, E_UNEXPECTED);
    if (sc)
        return sc;

    // addref the pointer for the client.
    m_sp_Document->AddRef();
    *ppDocument = m_sp_Document;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * GetFirstAMCViewPosition
 *
 * PURPOSE: Returns the CAMCViewPosition of the first AMCView, or NULL if there is
 *          no AMCView.
 *
 * RETURNS:
 *    CAMCViewPosition
 *
 *+-------------------------------------------------------------------------*/
CAMCViewPosition
CAMCDoc::GetFirstAMCViewPosition()     const
{
    CAMCViewPosition vpos;
    POSITION pos = GetFirstViewPosition();

    while(pos != NULL)
    {
        POSITION posTemp = pos;         // hold this value.

        CAMCView *pView = dynamic_cast<CAMCView *>(GetNextView(pos));
        if(pView != NULL)                // found the AMCView
        {
            vpos.SetPosition(posTemp); // NOT pos!
            break;
        }
    }

    return (vpos);
}



/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::GetNextAMCView
 *
 * PURPOSE: Returns the next AMCView, starting at pos (inclusive)
 *
 * PARAMETERS:
 *    CAMCViewPosition & pos :  incremented to the next AMCView, NOT the next View.
 *
 * RETURNS:
 *    CAMCView *
 *
 *+-------------------------------------------------------------------------*/

CAMCView *
CAMCDoc::GetNextAMCView(CAMCViewPosition &pos) const
{
    CAMCView *pView = NULL;

    // check parameters
    if (pos == NULL)
        return NULL;

    // pos is non-NULL at this point. Loop until we have a CAMCView.
    // Note that unless there's a bug in GetFirstAMCViewPosition or
    // GetNextAMCView, we'll only go through this loop once, since a
    // non-NULL CAMCViewPosition should always refer to a CAMCView.
    while( (NULL == pView) && (pos != NULL) )
    {
        CView *pV = GetNextView(pos.GetPosition());
        pView = dynamic_cast<CAMCView *>(pV);
    }

    // at this point, pView is the correct return value, and it had better
    // not be NULL, or we never should have had a non-NULL pos
    ASSERT (pView != NULL);

    // bump pos to the next CAMCView
    // NOTE: This is NOT redundant. Must point to a CAMCView so that
    // NULL position tests can be done.
    while(pos != NULL)
    {
        /*
         * use temporary POSITION so we won't increment the POSITION
         * inside pos until we know pos doesn't refer to a CAMCView
         */
        POSITION posT = pos.GetPosition();

        if(dynamic_cast<CAMCView *>(GetNextView(posT)) != NULL) // found a CAMCView at pos
            break;

        /*
         * update the CAMCViewPosition with the position incremented
         * by GetNextView only if we didn't find a CAMCView at its
         * previous location
         */
        pos.SetPosition (posT);
    }

#ifdef DBG
    /*
     * if we're returning a non-NULL, it'd better point to a CAMCView
     */
    if (pos != NULL)
    {
        POSITION posT = pos.GetPosition();
        ASSERT (dynamic_cast<CAMCView *>(GetNextView(posT)) != NULL);
    }
#endif

    return pView;
}



/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::InitNodeManager
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CAMCDoc::InitNodeManager()
{
    DECLARE_SC(sc, TEXT("CAMCDoc::InitNodeManager"));

    TRACE_METHOD(CAMCDoc, InitNodeManager);

    // Should not be currently initialized
    ASSERT(m_spScopeTree == NULL && m_spScopeTreePersist == NULL);
    ASSERT(m_spStorage == NULL);

    // The string table should have been created by now
    sc = ScCheckPointers(m_spStringTable, E_FAIL);
    if(sc)
        return sc.ToHr();

    // create the favorites at this stage
    ASSERT(m_pFavorites == NULL);
    m_pFavorites = new CFavorites;
    sc = ScCheckPointers(m_pFavorites, E_OUTOFMEMORY);
    if(sc)
        return sc.ToHr();


    // Create the initial private frame
    IFramePrivatePtr spFrame;
    sc = spFrame.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
    if (sc)
        return sc.ToHr();

    // recheck teh pointer
    sc = ScCheckPointers( spFrame, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();


    // Create the scope tree
    sc = m_spScopeTree.CreateInstance(CLSID_ScopeTree, NULL, MMC_CLSCTX_INPROC);
    if (sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // recheck the pointer
    sc = ScCheckPointers( m_spScopeTree, E_UNEXPECTED );
    if (sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // link frame and scope tree
    sc = spFrame->SetScopeTree(m_spScopeTree);
    if(sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // Initialize the tree
    sc = m_spScopeTree->Initialize(AfxGetMainWnd()->m_hWnd, m_spStringTable);
    if (sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // Get the IPersistStorage interface from the scope tree
    m_spScopeTreePersist = m_spScopeTree; // query for IPersistStorage
    ASSERT(m_spScopeTreePersist != NULL);

    m_ConsoleData.SetScopeTree (m_spScopeTree);

    CMainFrame* pFrame = AMCGetMainWnd();
    m_ConsoleData.m_hwndMainFrame = pFrame->GetSafeHwnd();
    m_ConsoleData.m_pConsoleFrame = pFrame;

    return sc.ToHr();
}

BOOL CAMCDoc::OnNewDocument()
{
    TRACE_METHOD(CAMCDoc, OnNewDocument);

    USES_CONVERSION;

    // Initialize the document and scope view ...
    if (!CDocument::OnNewDocument())
        return FALSE;

    // A new file can't be read-only
    SetPhysicalReadOnlyFlag (false);

    // use latest file version
    m_ConsoleData.m_eFileVer = FileVer_Current;
    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));

    // Init help doc info times to current time by default
    // Will update when file is first saved
    ::GetSystemTimeAsFileTime(&GetHelpDocInfo()->m_ftimeCreate);
    GetHelpDocInfo()->m_ftimeModify = GetHelpDocInfo()->m_ftimeCreate;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAMCDoc diagnostics

#ifdef _DEBUG
void CAMCDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CAMCDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAMCDoc commands
inline bool UnableToSaveDocument()
{
    if (AMCGetApp()->GetMode() == eMode_Author)
        MMCMessageBox(IDS_UnableToSaveDocumentMessage);

    return false;
}

static const wchar_t* AMCViewDataStreamName     = L"ViewData";
static const wchar_t* AMCFrameDataStreamName    = L"FrameData";
static const wchar_t* AMCStringTableStorageName = L"String Table";
static const wchar_t* AMCFavoritesStreamName    = L"FavoritesStream";
static const wchar_t* AMCCustomTitleStreamName  = L"Title";
static const wchar_t* AMCColumnDataStreamName   = L"ColumnData";
static const wchar_t* AMCViewSettingDataStreamName = L"ViewSettingData"; // View settings data stream

#pragma warning( disable : 4800 )

struct FrameState
{
    WINDOWPLACEMENT windowPlacement;
    BOOL fShowStatusBarInUserMode;
    BOOL fShowToolbarInAuthorMode;
}; // struct FrameState


struct FrameState2
{
    UINT            cbSize;
    WINDOWPLACEMENT wndplFrame;
    ProgramMode     eMode;
    DWORD           dwFlags;
    // NOT USED - SIZE PRESERVED FOR COMPATIBILITY
    // DWORD           dwHelpDocIndex;
    // DWORD           dwHelpDocTime[2];
    DWORD           dwUnused;
    DWORD           dwUnused2[2];

    FrameState2 (ProgramMode eMode_   = eMode_Author,
                 DWORD       dwFlags_ = eFlag_Default) :
        cbSize         (sizeof (FrameState2)),
        eMode          (eMode_),
        dwFlags        (dwFlags_),
        // NOT USED - SIZE PRESERVED FOR COMPATIBILITY
        dwUnused(0)
        // dwHelpDocIndex (0)
    {
        // NOT USED - SIZE PRESERVED FOR COMPATIBILITY
        // ZeroMemory (dwHelpDocTime, sizeof (dwHelpDocTime));
        ZeroMemory (&dwUnused2, sizeof (dwUnused2));

        ZeroMemory (&wndplFrame, sizeof (wndplFrame));
        wndplFrame.length = sizeof (wndplFrame);
    }

};  // struct FrameState2

/*+-------------------------------------------------------------------------*
 * CFrameState
 *
 * class is designated to be used instead of FrameState2 in Persist methods.
 * It implements functionality of CXMLObject while containing the same data as FrameState2
 * The original struct cannot be extended because many methods do relay on its size.
 *
 *--------------------------------------------------------------------------*/
class CFrameState : public CXMLObject, public FrameState2
{
public:
    CFrameState(ProgramMode eMode_, DWORD dwFlags_) : FrameState2 (eMode_,dwFlags_) {}
protected:
    DEFINE_XML_TYPE (XML_TAG_FRAME_STATE);
    virtual void Persist(CPersistor &persistor)
    {
        persistor.Persist(CXMLWindowPlacement(wndplFrame));

        // define the table to map enumeration values to strings
        static const EnumLiteral frameStateFlags[] =
        {
            { eFlag_ShowStatusBar,                  XML_ENUM_FSTATE_SHOWSTATUSBAR },
            { eFlag_HelpDocInvalid,                 XML_ENUM_FSTATE_HELPDOCINVALID },
            { eFlag_LogicalReadOnly,                XML_ENUM_FSTATE_LOGICALREADONLY },
            { eFlag_PreventViewCustomization,       XML_ENUM_FSTATE_PREVENTVIEWCUSTOMIZATION },
        };

        // create wrapper to persist enumeration values as strings
        CXMLBitFlags flagPersistor(dwFlags, frameStateFlags, countof(frameStateFlags));
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_FRAME_STATE_FLAGS, flagPersistor);
    }
};

// what is the size of the Version 1.1 definition of FrameState2?
const int cbFrameState2_v11 = SIZEOF_STRUCT (FrameState2, dwUnused2 /*dwHelpDocTime*/ );


/*+-------------------------------------------------------------------------*
 * AdjustRect
 *
 * Adjusts pInnerRect so that it is completely contained within pOuterRect
 *
 * If AR_MOVE is specified, the origin of pInnerRect is moved enough (if
 * necessary) so that the right and/or bottom edges of pInnerRect coincide
 * with those of pOuterRect.  pInnerRect's origin is never moved above or to
 * the left of pOuterRect's origin.
 *
 * If AR_SIZE is specified, the right and/or bottom edges of pInnerRect are
 * moved to that they coincide with those of pOuterRect.
 *--------------------------------------------------------------------------*/

#define AR_MOVE     0x0000001
#define AR_SIZE     0x0000002

void AdjustRect (LPCRECT pOuterRect, LPRECT pInnerRect, DWORD dwFlags)
{
    /*
     * if the inner rectangle is completely within
     * the outer, there's nothing to do
     */
    if ((pInnerRect->left   >= pOuterRect->left  ) &&
        (pInnerRect->right  <= pOuterRect->right ) &&
        (pInnerRect->top    >= pOuterRect->top   ) &&
        (pInnerRect->bottom <= pOuterRect->bottom))
        return;


    /*
     * handle movement
     */
    if (dwFlags & AR_MOVE)
    {
        int dx = 0;

        /*
         * shift inner rect right?
         */
        if (pInnerRect->left < pOuterRect->left)
            dx = pOuterRect->left - pInnerRect->left;

        /*
         * shift inner rect left? (make sure we don't shift it past the
         * left of the outer rect)
         */
        else if (pInnerRect->right > pOuterRect->right)
            dx = std::_MAX (pOuterRect->right - pInnerRect->right,
                            pOuterRect->left  - pInnerRect->left);


        /*
         * make sure things are right in the vertical
         */
        int dy = 0;

        /*
         * shift inner rect down?
         */
        if (pInnerRect->top < pOuterRect->top)
            dy = pOuterRect->top - pInnerRect->top;

        /*
         * shift inner rect up? (make sure we don't shift it past the
         * top of the outer rect)
         */
        else if (pInnerRect->bottom > pOuterRect->bottom)
            dy = std::_MAX (pOuterRect->bottom - pInnerRect->bottom,
                            pOuterRect->top    - pInnerRect->top);


        /*
         * if we need to shift the inner rect, do it now
         */
        if ((dx != 0) || (dy != 0))
        {
            ASSERT (dwFlags & AR_MOVE);
            OffsetRect (pInnerRect, dx, dy);
        }
    }


    /*
     * handle sizing
     */
    if (dwFlags & AR_SIZE)
    {
        if (pInnerRect->right  > pOuterRect->right)
            pInnerRect->right  = pOuterRect->right;

        if (pInnerRect->bottom > pOuterRect->bottom)
            pInnerRect->bottom = pOuterRect->bottom;
    }
}


/*+-------------------------------------------------------------------------*
 * InsurePlacementIsOnScreen
 *
 * This function insures that the window will appear on the virtual screen,
 * and if the whole window can't be located there, that at least the most
 * interesting part is visible.
 *--------------------------------------------------------------------------*/

void InsurePlacementIsOnScreen (WINDOWPLACEMENT& wndpl)
{
    /*
     * find the monitor containing the window origin
     */
    HMONITOR hmon = MonitorFromPoint (CPoint (wndpl.rcNormalPosition.left,
                                              wndpl.rcNormalPosition.top),
                                      MONITOR_DEFAULTTONEAREST);

    MONITORINFO mi = { sizeof (mi) };
    CRect rectBounds;

    /*
     * if we could get the info for the monitor containing the window origin,
     * use it's workarea as the bounding rectangle; otherwise get the workarea
     * for the default monitor; if that failed as well, default to 640x480
     */
    if (GetMonitorInfo (hmon, &mi))
        rectBounds = mi.rcWork;
    else if (!SystemParametersInfo (SPI_GETWORKAREA, 0, &rectBounds, false))
        rectBounds.SetRect (0, 0, 639, 479);

    /*
     * position the window rectangle within the bounding rectangle
     */
    AdjustRect (rectBounds, &wndpl.rcNormalPosition, AR_MOVE | AR_SIZE);
}


//+-------------------------------------------------------------------
//
//  Member:     LoadFrame
//
//  Synopsis:   Load the Frame Data.
//
//  Note:       The app mode was already read by LoadAppMode.
//              The child frames are created so call UpdateFrameWindow.
//
//  Arguments:  None
//
//  Returns:    bool. TRUE if success.
//
//--------------------------------------------------------------------
bool CAMCDoc::LoadFrame()
// The caller is resposible for calling DeleteContents() and display a message
// to the user when this function return false.
{
    TRACE_METHOD(CAMCDoc, LoadFrame);

    // This assertion shouldn't fail until the definition of FrameState2 changes
    // in a version after 1.1.  At that time, add another cbFrameState2_vXX
    // with the new version's FrameState2 size.
    ASSERT (cbFrameState2_v11 == sizeof (FrameState2));

    if (!AssertNodeManagerIsLoaded())
        return false;

    // Open the stream containing data for the app and frame
    IStreamPtr spStream;
    HRESULT     hr;

    hr = OpenDebugStream (m_spStorage, AMCFrameDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);

    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return false;


    FrameState2 fs2;
    ULONG cbRead;
    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));

    // V1.0 file? Migrate it forward
    if (m_ConsoleData.m_eFileVer == FileVer_0100)
    {
        FrameState fs;
        hr = spStream->Read (&fs, sizeof(fs), &cbRead);

        // if we can't read the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs)))
            return (false);

        // migrate FrameState into FrameState2
        fs2.wndplFrame = fs.windowPlacement;

        if (fs.fShowStatusBarInUserMode)
            fs2.dwFlags |=  eFlag_ShowStatusBar;
        else
            fs2.dwFlags &= ~eFlag_ShowStatusBar;
    }

    // otherwise, current file
    else
    {
        hr = spStream->Read (&fs2, sizeof(fs2), &cbRead);

        // if we can't read the rest of the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs2)))
            return (false);
    }


    // Set the windows size and location and state
    CMainFrame* pMainFrame = AMCGetMainWnd ();
    ASSERT(pMainFrame != NULL);
    if (pMainFrame == NULL)
        return false;


    CAMCApp*    pApp = AMCGetApp();
    pApp->UpdateFrameWindow(true);
    pMainFrame->UpdateChildSystemMenus();

    // the status bar is on the child frame now
//  pMainFrame->ShowStatusBar ((fs2.dwFlags & eFlag_ShowStatusBar) != 0);


    // save the data from the file into the console data
    m_ConsoleData.m_eAppMode     = pApp->GetMode();
    m_ConsoleData.m_eConsoleMode = fs2.eMode;
    m_ConsoleData.m_dwFlags      = fs2.dwFlags;

    InsurePlacementIsOnScreen (fs2.wndplFrame);


    // if we're initializing, defer the actual show until initialization is complete
    // same if script is under control and MMC is hidden
    if (pApp->IsInitializing()
     || ( !pApp->IsUnderUserControl() && !pMainFrame->IsWindowVisible() ) )
    {
        pApp->m_nCmdShow = fs2.wndplFrame.showCmd;
        fs2.wndplFrame.showCmd = SW_HIDE;
    }

    return (pMainFrame->SetWindowPlacement (&fs2.wndplFrame));
}

//+-------------------------------------------------------------------
//
//  Member:     LoadAppMode
//
//  Synopsis:   Read the app mode from the frame and store it in CAMCApp.
//              This is needed during CAMCView::Load.
//
//  Arguments:  None
//
//  Returns:    bool. TRUE if success.
//
//--------------------------------------------------------------------
bool CAMCDoc::LoadAppMode()
{
    TRACE_METHOD(CAMCDoc, LoadAppMode);

    // Just load the application mode from frame data.
    // This assertion shouldn't fail until the definition of FrameState2 changes
    // in a version after 1.1.  At that time, add another cbFrameState2_vXX
    // with the new version's FrameState2 size.
    ASSERT (cbFrameState2_v11 == sizeof (FrameState2));

    if (!AssertNodeManagerIsLoaded())
        return false;

    // Open the stream containing data for the app and frame
    IStreamPtr spStream;
    HRESULT     hr;

    hr = OpenDebugStream (m_spStorage, AMCFrameDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);

    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return false;


    FrameState2 fs2;
    ULONG cbRead;
    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));

    // V1.0 file? Migrate it forward
    if (m_ConsoleData.m_eFileVer == FileVer_0100)
    {
        FrameState fs;
        hr = spStream->Read (&fs, sizeof(fs), &cbRead);

        // if we can't read the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs)))
            return (false);

        // migrate FrameState into FrameState2
        fs2.wndplFrame = fs.windowPlacement;

        if (fs.fShowStatusBarInUserMode)
            fs2.dwFlags |=  eFlag_ShowStatusBar;
        else
            fs2.dwFlags &= ~eFlag_ShowStatusBar;
    }

    // otherwise, current file
    else
    {
        hr = spStream->Read (&fs2, sizeof(fs2), &cbRead);

        // if we can't read the rest of the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs2)))
            return (false);
    }

    CAMCApp*    pApp = AMCGetApp();
    pApp->SetMode (fs2.eMode);

    return true;
}

bool CAMCDoc::LoadViews()
// Caller is resposible for calling DeleteContents() and displaying failure
// message if false is returned.
{
    TRACE_METHOD(CAMCDoc, LoadViews);

    if (!AssertNodeManagerIsLoaded())
        return false;

    // Open the tree data stream
    IStreamPtr spStream;
    HRESULT hr = OpenDebugStream(m_spStorage, AMCViewDataStreamName,
        STGM_SHARE_EXCLUSIVE | STGM_READ, &spStream);

    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return false;

    // Read the number of views persisted
    unsigned short numberOfViews;
    unsigned long bytesRead;
    hr = spStream->Read(&numberOfViews, sizeof(numberOfViews), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(numberOfViews));
    if (FAILED(hr) || bytesRead != sizeof(numberOfViews))
        return false;

    // Loop thru and create each view
    int failedCount = 0;
    while (numberOfViews--)
    {
        // Read the node id for the root node of the view being created.
        m_MTNodeIDForNewView = 0;
        bool bRet = m_spScopeTree->GetNodeIDFromStream(spStream, &m_MTNodeIDForNewView);

        // Read the node id for the selected node of the view being created.
        ULONG idSel = 0;
        bRet = m_spScopeTree->GetNodeIDFromStream(spStream, &idSel);

        // Read the view id of the view being created.
        hr = spStream->Read(&m_ViewIDForNewView,
                                   sizeof(m_ViewIDForNewView), &bytesRead);
        ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(m_ViewIDForNewView));
        if (FAILED(hr) || bytesRead != sizeof(m_ViewIDForNewView))
            return false;

        if (bRet || m_MTNodeIDForNewView != 0)
        {
            // Create the new view and load its data
            CAMCView* const v = CreateNewView(true);
            m_ViewIDForNewView = 0;
            ASSERT(v != NULL);
            if (v == NULL)
            {
                ++failedCount;
                continue;
            }
            if (!v->Load(*spStream))
                return false;

            v->ScSelectNode(idSel);
            v->SaveStartingSelectedNode();
            v->SetDirty (false);
            //v->GetHistoryList()->Clear();
        }
    }

    // Reset the node ID for future view creation
    m_MTNodeIDForNewView = ROOTNODEID;

    SetModifiedFlag(FALSE);
    return (failedCount == 0);
}

SC CAMCDoc::ScCreateAndLoadView(CPersistor& persistor, int nViewID, const CBookmark& rootNode)
// Caller is resposible for calling DeleteContents() and displaying failure
// message if false is returned.
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScCreateAndLoadView"));

    // Read the node id for the root node of the view being created.
    m_MTNodeIDForNewView = 0;

    MTNODEID idTemp = 0;
    bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark, unused
    sc = m_spScopeTree->GetNodeIDFromBookmark(rootNode, &idTemp, bExactMatchFound);
    if(sc)
        return sc;

    m_MTNodeIDForNewView = idTemp;

    if (m_MTNodeIDForNewView != 0)
    {
        // Read the view id of the view being created.
        m_ViewIDForNewView = nViewID;
        // Create the new view and load its data
        CAMCView* const v = CreateNewView(true);
        m_ViewIDForNewView = 0;

        sc = ScCheckPointers(v, E_FAIL);
        if (sc)
            return sc;

        v->Persist(persistor);

        v->SaveStartingSelectedNode();
        v->SetDirty (false);
        //v->GetHistoryList()->Clear();
    }
    else
    {
        return sc = SC(E_UNEXPECTED);
    }

    // Reset the node ID for future view creation
    m_MTNodeIDForNewView = ROOTNODEID;
    SetModifiedFlag(FALSE);
    return sc;
}


/*+-------------------------------------------------------------------------*
 * ShowIncompatibleFileMessage
 *
 *
 *--------------------------------------------------------------------------*/

static void ShowIncompatibleFileMessage (
    LPCTSTR             pszFilename,
    ConsoleFileVersion  eFileVer)
{
    DECLARE_SC(sc, TEXT("ShowIncompatibleFileMessage"));
    TCHAR szFileVersion[16];

    sc = StringCchPrintf(szFileVersion, countof(szFileVersion), 
                         _T("%d.%d%x"), GetConsoleFileMajorVersion    (eFileVer),
                         GetConsoleFileMinorVersion    (eFileVer), 
                         GetConsoleFileMinorSubversion (eFileVer));
    // Display error and show incompatible error.
    if (sc)
        sc.TraceAndClear();

    CString strMessage;
    FormatString2 (strMessage, IDS_NewerVersionRequired, pszFilename, szFileVersion);

    MMCMessageBox (strMessage);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::OnOpenDocument
 *
 * WM_OPENDOCUMENT handler for CAMCDoc.
 *--------------------------------------------------------------------------*/

BOOL CAMCDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::OnOpenDocument"));

    sc = ScOnOpenDocument(lpszPathName);
    if(sc) // found an error
    {
        DisplayFileOpenError (sc, lpszPathName);
        return false;
    }

    sc = ScFireEvent(CAMCDocumentObserver::ScDocumentLoadCompleted, this);
    if (sc)
		return false;

	/*
	 * Success!  We shouldn't think that a freshly opened console file is
	 * dirty.  If we do, someone's dirty bit processing is bogus.
	 */
	ASSERT (!IsFrameModified());

	/*
	 * Too many snap-ins leave themselves dirty after a load to leave this
	 * assert in, so we'll trace instead.  Note that this trace doesn't
	 * always indicate a snap-in problem, but it frequently does.
	 */
#ifdef DBG
//	ASSERT (!IsModified());
	if (IsModified())
		TraceErrorMsg (_T("CAMCDoc::IsModified returns true after opening"));
#endif


    return true;
}


/*+-------------------------------------------------------------------------*
 * DisplayFileOpenError
 *
 * Displays an error message if we couldn't open a console file.
 *--------------------------------------------------------------------------*/

int DisplayFileOpenError (SC sc, LPCTSTR pszFilename)
{
    // if it is any of the known errors, use a friendly string.

    if (sc == SC(STG_E_FILENOTFOUND) || sc == ScFromWin32(ERROR_FILE_NOT_FOUND))
        (sc = ScFromMMC(IDS_FileNotFound));
    else if (sc == ScFromMMC(MMC_E_INVALID_FILE))
        (sc = ScFromMMC(IDS_InvalidVersion));
    else if (sc == SC(STG_E_MEDIUMFULL))
        (sc = ScFromMMC(IDS_DiskFull));
    else
    {
        CString strError;
        AfxFormatString1(strError, IDS_UnableToOpenDocumentMessage, pszFilename);
        return (MMCErrorBox(strError));
    }

    return (MMCErrorBox(sc));
}


/*+-------------------------------------------------------------------------*
 * ScGetFileProperties
 *
 * Returns the read-only state of the given file, as well as the creation,
 * last access, and last write times (all optional).
 *
 * We determine if the file is read-only by trying to open the file for
 * writing rather than checking for FILE_ATTRIBUTE_READONLY.  We do this
 * because it will catch more read-only conditions, like the file living
 * on a read-only share or NTFS permissions preventing a write.
 *--------------------------------------------------------------------------*/

static SC ScGetFileProperties (
    LPCTSTR     lpszPathName,           /* I:name of file to check          */
    bool*       pfReadOnly,             /* O:is file read-only?             */
    FILETIME*   pftCreate,              /* O:creation time    (optional)    */
    FILETIME*   pftLastAccess,          /* O:last access time (optional)    */
    FILETIME*   pftLastWrite)           /* O:last write time  (optional)    */
{
    DECLARE_SC (sc, _T("ScGetFileProperties"));

    /*
     * validate inputs (pftCreate, pftLastAccess, and pftLastWrite are optional)
     */
    sc = ScCheckPointers (lpszPathName, pfReadOnly);
    if (sc)
        return (sc);

    /*
     * try to open the file for write; if we can't, the file is read-only
     */
    HANDLE hFile = CreateFile (lpszPathName, GENERIC_WRITE, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    *pfReadOnly = (hFile == INVALID_HANDLE_VALUE);

    /*
     * if read-only then open in read mode so we'll have a handle to pass
     * to GetFileTime
     */
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hFile = CreateFile (lpszPathName, 0, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            sc.FromLastError();
            return (sc);
        }
    }

    /*
     * get the timestamps on the file
     */
    if (!GetFileTime (hFile, pftCreate, pftLastAccess, pftLastWrite))
        sc.FromLastError();

    CloseHandle (hFile);
    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScOnOpenDocument
 *
 * PURPOSE: Opens the specified document.
 *
 * PARAMETERS:
 *    LPCTSTR  lpszPathName :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScOnOpenDocument(LPCTSTR lpszPathName)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScOnOpenDocument"));

    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    #define VIVEKJ
    #ifdef VIVEKJ

    // upgrade the console file to the XML version.
    CConsoleFile  consoleFile;
    consoleFile.ScUpgrade(lpszPathName);
    #endif


    USES_CONVERSION;

    // check inputs
    if (lpszPathName == NULL || *lpszPathName == 0)
        return (sc = E_UNEXPECTED);

    if (IsModified())
    {
        TRACE0("Warning: OnOpenDocument replaces an unsaved document.\n");
    }

    if (!AssertNodeManagerIsInitialized())
        return (sc = E_UNEXPECTED);

    /*
     * get the times for the file, as well as its read-only state
     */
    HELPDOCINFO* phdi = GetHelpDocInfo();
    sc = ScCheckPointers (phdi, E_UNEXPECTED);
    if (sc)
        return (sc);

    bool fReadOnly;
    sc = ScGetFileProperties (lpszPathName, &fReadOnly,
                              &phdi->m_ftimeCreate, NULL, &phdi->m_ftimeModify);
    if (sc)
        return (sc);

    // load the document using method from the base class (CConsoleFilePersistor)
    bool bXmlBased = false;
    CXMLDocument xmlDocument;
    IStoragePtr spStorage;
    sc = ScLoadConsole(lpszPathName, bXmlBased, xmlDocument, &spStorage);
    if (sc)
        return (sc);

    if ( bXmlBased )
    {
      // load as XML document
      sc = ScLoadFromDocument(xmlDocument);
      if(sc)
          return sc;
    }
    else
    {
        sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
        if (sc)
            return sc;

        // get the console file's version
        ASSERT (sizeof(m_ConsoleData.m_eFileVer) == sizeof(int));
        sc = m_spScopeTree->GetFileVersion(spStorage, (int*)&m_ConsoleData.m_eFileVer);
        if (sc)
            return sc;

        /*
         * check to see if this file is from a newer MMC
         */
        if (m_ConsoleData.m_eFileVer > FileVer_Current)
        {
            ShowIncompatibleFileMessage (lpszPathName, m_ConsoleData.m_eFileVer);
            return (sc = E_UNEXPECTED);
        }

        // Previous storage should have been closed and released
        ASSERT(m_spStorage == NULL);

        /*
         * Load the string table.
         */
        if (!LoadStringTable (spStorage))
            return (sc = E_UNEXPECTED);

        // Load column settings.
        do
        {
            IStreamPtr spStream;
            sc = OpenDebugStream (spStorage, AMCColumnDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);
            if(sc)
                break;

            if (NULL != m_ConsoleData.m_spPersistStreamColumnData)
                sc = m_ConsoleData.m_spPersistStreamColumnData->Load(spStream);

            ASSERT(NULL != m_ConsoleData.m_spPersistStreamColumnData);

            if (sc.IsError() || (NULL == m_ConsoleData.m_spPersistStreamColumnData) )
                return (sc = E_UNEXPECTED);

        } while ( FALSE );

        // Load view settings.
        do
        {
            IStreamPtr spStream;
            sc = OpenDebugStream (spStorage, AMCViewSettingDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);

            if (sc)
                break;

            IPersistStreamPtr spIPeristStreamViewSettings;
            SC sc = ScGetViewSettingsPersistorStream(&spIPeristStreamViewSettings);
            if (sc)
                break;

            sc = ScCheckPointers(spIPeristStreamViewSettings, E_UNEXPECTED);
            if (sc)
                break;

            sc = spIPeristStreamViewSettings->Load(spStream);
            if (sc)
                break;

        } while ( FALSE );


        // Load the tree
        sc = m_spScopeTreePersist->Load(spStorage);
        if (sc)
        {
            ReleaseNodeManager();
            return sc;
        }

        // Save the new storage
        m_spStorage = spStorage;

        /*
         * make sure the tree expansion happens synchronously
         */
        bool fSyncExpandWasRequired = m_spScopeTree->IsSynchronousExpansionRequired() == S_OK;
        m_spScopeTree->RequireSynchronousExpansion (true);

        // Load the favorites data before loading views and frames,
        // so that when frame/view is created the favorite data is ready.
        if (!LoadFavorites())
        {
            // bhanlon        ReleaseNodeManager();
            m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
            return (sc = E_UNEXPECTED);
        }


        /*
         * Load string table, custom data, views and frame.  Load the
         * custom data (including the icon) before loading the views so
         * the proper icon will be used for the views as they're created.
         */
        /*
         * The LoadAppMode, LoadViews and LoadFrame should be called in that
         * order due to following reason.
         * LoadAppMode reads mode from frame-data and saves it in CAMCApp.
         * The mode is used during LoadViews (in CAMCView::Load) to set the view.
         * LoadFrame again reads the frame-data and calls CAMCApp::UpdateFrameWindow
         * to set toolbar/menus according to the mode.
         */
        if (!LoadCustomData  (m_spStorage) || !LoadAppMode() || !LoadViews() || !LoadFrame())
        {
            // bhanlon        ReleaseNodeManager();
            m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
            return (sc = E_UNEXPECTED);
        }

        m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
    }

    SetModifiedFlag      (false);
    SetFrameModifiedFlag (false);

    SetPhysicalReadOnlyFlag (fReadOnly);

    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));
    return sc;
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::OnSaveDocument
 *
 * WM_SAVEDOCUMENT handler for CAMCDoc.
 *--------------------------------------------------------------------------*/

BOOL CAMCDoc::OnSaveDocument(LPCTSTR lpszFilename)
{
    DECLARE_SC(sc, _T("CAMCDoc::OnSaveDocument"));

    USES_CONVERSION;

    m_eSaveStatus = eStat_Succeeded;

    // Check for a valid filename
    ASSERT(lpszFilename != NULL && *lpszFilename != 0);
    if (lpszFilename == NULL || *lpszFilename == 0)
    {
        return UnableToSaveDocument();
    }

    // Ask the each view to save any data into its data
    // structures (memory) before calling IPersist*::Save.
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        CAMCView* const pAMCView = GetNextAMCView(pos);
        sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
        if (sc)
            return UnableToSaveDocument();
    }

    if (!IsCurrentFileVersion (m_ConsoleData.m_eFileVer))
    {
        // If we've arrived at this point then the user is attempting to save the file
        // from an old format into a new one and we will check to see if the user really
        // wants to do this.

        CString strMessage;

        LPCTSTR pszPathName = m_strPathName;

        // A YES/NO/(CANCEL) dialog asking if the user wants to save the file in the new format
        int nResult;

        /*
         * Bug 277586:  we don't ever want non-authors to see this dialog
         */
        if (AMCGetApp()->GetMode() != eMode_Author)
        {
            // non-authors are only saving console settings,
            // which are always in the current version
            // no need to ask for conversion - original console is not converted anyway.
            nResult = IDYES;
        }
        else if (IsExplicitSave())
        {
            // 2 button YES/NO dialog appears if this is an explicit save
            tstring strVersion = GetCurrentFileVersionAsString();
            FormatString2 (strMessage, IDS_CONVERT_FILE_FORMAT,
                           pszPathName, strVersion.c_str());

            nResult = MMCMessageBox (strMessage, MB_YESNO | MB_DEFBUTTON2);
        }
        else
        {
            // 3 button YES/NO/CANCEL appears if this dialog appears when the program
            // prompts to save changes when the user closes the document
            tstring strVersion = GetCurrentFileVersionAsString();
            FormatString2 (strMessage, IDS_CONVERT_FILE_FORMAT_CLOSE,
                           pszPathName, strVersion.c_str());

            nResult = MMCMessageBox (strMessage, MB_YESNOCANCEL | MB_DEFBUTTON3);
        }

        // If we cancel out
        if ((nResult == IDCANCEL) || ((nResult == IDNO) && IsExplicitSave()))
        {
            // Must set this variable otherwise MMC will delete the file
            m_eSaveStatus = eStat_Cancelled;
            return (false);
        }

        // If this will result in us exiting without saving
        if ((nResult == IDNO) && !IsExplicitSave())
            return (true);
    }

    // if we have more than one view, and we'll force SDI in user mode, prompt
    if ((GetNumberOfPersistedViews() > 1) &&
        (m_ConsoleData.m_eConsoleMode == eMode_User_SDI) &&
        (AMCGetApp()->GetMode()       == eMode_Author))
    {
        switch (MMCMessageBox (IDS_FORCE_SDI_PROMPT, MB_YESNOCANCEL))
        {
            case IDYES:
                /* do nothing */
                break;

            case IDNO:
                m_ConsoleData.m_eConsoleMode = eMode_User_MDI;
                break;

            case IDCANCEL:
                m_eSaveStatus = eStat_Cancelled;
                return (false);
        }
    }

    // save contents to xml document
    CXMLDocument xmlDocument;
    sc = ScSaveToDocument( xmlDocument );
    if (sc)
        return UnableToSaveDocument();

    // save xml document to file
    bool bAuthor = (AMCGetApp()->GetMode() == eMode_Author);
    sc = ScSaveConsole( lpszFilename, bAuthor, xmlDocument);
    if (sc)
        return UnableToSaveDocument();

    SetModifiedFlag      (false);
    SetFrameModifiedFlag (false);

	/*
	 * We shouldn't think that a freshly saved console file is
	 * dirty.  If we do, someone's dirty bit processing is bogus.
	 */
	ASSERT (!IsFrameModified());

	/*
	 * Too many snap-ins leave themselves dirty after a load to leave this
	 * assert in, so we'll trace instead.  Note that this trace doesn't
	 * always indicate a snap-in problem, but it frequently does.
	 */
#ifdef DBG
//	ASSERT (!IsModified());
	if (IsModified())
		TraceErrorMsg (_T("CAMCDoc::IsModified returns true after saving"));
#endif

    // if a save was just done, this can't be read-only

    // NOTE: if MMC adds support for "Save Copy As" we have
    // to determine whether a "Save As" or "Save Copy As"
    // was done before clearing the read-only status
    SetPhysicalReadOnlyFlag (false);
    m_ConsoleData.m_eFileVer = FileVer_Current;

    // Show admin tools on start menu if necessary
    ShowAdminToolsOnMenu(lpszFilename);

    return TRUE;
}



int CAMCDoc::GetNumberOfViews()
{
    TRACE_METHOD(CAMCDoc, GetNumberOfViews);

    CAMCViewPosition pos = GetFirstAMCViewPosition();
    int count = 0;

    while (pos != NULL)
    {
        GetNextAMCView(pos);
        VERIFY (++count);
    }

    return (count);
}


int CAMCDoc::GetNumberOfPersistedViews()
{
    unsigned short cPersistedViews = 0;

    CAMCViewPosition pos = GetFirstAMCViewPosition();

    while (pos != NULL)
    {
        CAMCView* v = GetNextAMCView(pos);

        if (v && v->IsPersisted())
            ++cPersistedViews;
    }

    return (cPersistedViews);
}


CAMCView* CAMCDoc::CreateNewView(bool fVisible, bool bEmitScriptEvents /*= true*/)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::CreateNewView"));
    TRACE_FUNCTION(CAMCDoc::CreateNewView);

    CDocTemplate* pTemplate = GetDocTemplate();
    ASSERT(pTemplate != NULL);

    CChildFrame* pFrame = (CChildFrame*) pTemplate->CreateNewFrame(this, NULL);
    ASSERT_KINDOF (CChildFrame, pFrame);

    if (pFrame == NULL)
    {
        TRACE(_T("Warning: failed to create new frame.\n"));
        return NULL;     // command failed
    }

    bool fOldCreateVisibleState;

    /*
     * If we're going to create the frame invisibly, set a flag in the frame.
     * When this flag is set, the frame will show itself with the
     * SW_SHOWMINNOACTIVE flag instead of the default flag.  Doing this will
     * avoid the side effect of restoring the currently active child frame
     * if it is maximized at the time the new frame is created invisibly.
     */
    // The SW_SHOWMINNOACTIVE was changed to SW_SHOWNOACTIVATE.
    // It does preserve the active window from mentioned side effect,
    // plus it also allows scripts (using Object Moded) to create invisible views,
    // position and then show them as normal (not minimized) windows,
    // thus providing same result as creating visible and then hiding the view.
    // While minimized window must be restored first in order to change their position.
    if (!fVisible)
    {
        fOldCreateVisibleState = pFrame->SetCreateVisible (false);
    }

    /*
     * update the frame as if it is to be visible; we'll hide the frame
     * later if necessary
     */
    // setting visibility to 'true' is required option for MFC to pass control
    // to OnInitialUpdate of child windows.
    pTemplate->InitialUpdateFrame (pFrame, this, true /*fVisible*/);

    if (fVisible)
    {
        // Force drawing of frame and view windows now in case a slow OCX in the result
        // pane delays the initial window update
        pFrame->RedrawWindow();
    }
    else
    {
        pFrame->SetCreateVisible (fOldCreateVisibleState);
        pFrame->ShowWindow (SW_HIDE);

        /*
         * InitialUpdateFrame will update the frame counts.  When it executes
         * the new, to-be-invisible frame will be visible, so it'll be included
         * in the count.  If the new window is the second frame, then the first
         * frame will have "1:" prepended to its title.  This is ugly, so we'll
         * update the frame counts again after the new frame has been hidden
         * to fix all of the existing frames' titles.
         */
        UpdateFrameCounts();
    }

    CAMCView* const v = pFrame->GetAMCView();

    if (!(MMC_NW_OPTION_NOPERSIST & GetNewWindowOptions()))
        SetModifiedFlag();

    ASSERT(v);

	if (!v)
		return v;

	AddObserver(static_cast<CAMCDocumentObserver&>(*v));

    // fire the event to the script
    if (bEmitScriptEvents)
    {
        CAMCApp*  pApp = AMCGetApp();

        // check
        sc = ScCheckPointers(pApp, E_UNEXPECTED);
        if (sc)
            return v;

        // forward
        sc = pApp->ScOnNewView(v);
        if (sc)
            return v;
    }

    return v;
}


void DeletePropertyPages(void)
{
    HWND hWnd = NULL;
    DWORD dwPid = 0;        // Process Id
    DWORD dwTid = 0;        // Thread Id

    while (TRUE)
    {
        USES_CONVERSION;

        // Note: No need to localize this string
        hWnd = ::FindWindowEx(NULL, hWnd, W2T( DATAWINDOW_CLASS_NAME ), NULL);
        if (hWnd == NULL)
            return; // No more windows
        ASSERT(IsWindow(hWnd));

        // Check if the window belongs to the current process
        dwTid = ::GetWindowThreadProcessId(hWnd, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        DataWindowData* pData = GetDataWindowData (hWnd);
        ASSERT (pData != NULL);
        ASSERT (IsWindow (pData->hDlg));

        if (SendMessage(pData->hDlg, WM_COMMAND, IDCANCEL, 0L) != 0)
        {
            DBG_OUT_LASTERROR;
        }

        // Note: For some reason, the send message stays stuck in the threads
        // msg queue causing the sheet not to dismiss itself.  By posting a another
        // message( it could be anything), it kick starts the queue and the send message
        // goes through.
        ::PostMessage(pData->hDlg, WM_COMMAND, IDCANCEL, 0L);
    }
}


void CAMCDoc::DeleteContents()
{
    TRACE_METHOD(CAMCDoc, DeleteContents);

    CDocument::DeleteContents();
}


void CAMCDoc::DeleteHelpFile ()
{
    /*
     *  Delete the help file on closing a console file
     */

    // Get a node callback interface
    ASSERT(m_spScopeTree != NULL);
    // If this asserts - the document is in invalid state.
    // Most probably it's because our "Load" procedures did not perform proper
    // cleanup when we failed to load the document
    INodeCallbackPtr spNodeCallback;

    if (m_spScopeTree != NULL)
    {
        m_spScopeTree->QueryNodeCallback(&spNodeCallback);
        ASSERT(spNodeCallback != NULL);
    }

    // fill in file name and send the delete request

    if (spNodeCallback != NULL)
    {
        USES_CONVERSION;
        GetHelpDocInfo()->m_pszFileName = T2COLE(GetPathName());
        spNodeCallback->Notify(NULL, NCLBK_DELETEHELPDOC, (LPARAM)GetHelpDocInfo(), NULL);
    }
}


void CAMCDoc::OnCloseDocument()
{
    DECLARE_SC(sc, TEXT("CAMCDoc::OnCloseDocument"));

    TRACE_METHOD(CAMCDoc, OnCloseDocument);

    // Inform nodemgr about doc-closing (should change this to observer object)
    do
    {
        sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
        if (sc)
            break;

        INodeCallbackPtr spNodeCallback;
        sc = m_spScopeTree->QueryNodeCallback(&spNodeCallback);
        if (sc)
            break;

        sc = ScCheckPointers(spNodeCallback, E_UNEXPECTED);
        if (sc)
            break;

        sc = spNodeCallback->DocumentClosing();
        if (sc)
            break;

    } while ( FALSE );

    if (sc)
        sc.TraceAndClear();

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        sc.TraceAndClear();
    else
    {
        // forward
        sc = pApp->ScOnCloseDocument(this);
        if (sc)
            sc.TraceAndClear();
    }

    // If we are not instantiated as OLESERVER check for open property sheets.
    if (! pApp->IsMMCRunningAsOLEServer() && FArePropertySheetsOpen(NULL))
    {
        CString strMsg, strTitle;

        if (strMsg.LoadString(IDS_MMCWillCancelPropertySheets) &&
            strTitle.LoadString(IDS_WARNING))
            ::MessageBox(NULL, strMsg, strTitle, MB_OK | MB_ICONWARNING);
    }

    DeletePropertyPages();
    DeleteHelpFile ();

    CDocument::OnCloseDocument();
}


BOOL CAMCDoc::SaveModified()
{
    BOOL    fDocModified   = IsModified();
    BOOL    fFrameModified = IsFrameModified();

    // if the file is not read-only and it is modified
    if (!IsReadOnly() && (fDocModified || fFrameModified))
    {
        int idResponse;
        bool fUserMode = (AMCGetApp()->GetMode() != eMode_Author);
        bool fSaveByUserDecision = false;

        // silent saves for the various flavors of user mode
        if (fUserMode)
            idResponse = IDYES;

        // silent saves if the frame was modified but the document wasn't...
        else if (fFrameModified && !fDocModified)
        {
            /*
             * ...unless the console wasn't modified.  This will happen
             * if the user ran MMC without opening an existing console file
             * and then moved the frame window.
             */
            // ...unless the console wasn't modified.
            if (m_strPathName.IsEmpty())
                idResponse = IDNO;
            else
                idResponse = IDYES;
        }

        // otherwise, prompt
        else
        {
            CString prompt;
            FormatString1(prompt, IDS_ASK_TO_SAVE, m_strTitle);
            idResponse = AfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE); // dont change to MMCMessageBox - different signature.
            fSaveByUserDecision = true;
        }

        switch (idResponse)
        {
            case IDCANCEL:
                return FALSE;       // don't continue

            case IDYES:
                // If so, either Save or Update, as appropriate
                // (ignore failures in User mode)

                // This save is not explicit and shows up when the user closes a modified
                // document. Set it as such. This will result in a different dialog
                // a few functions in.
                SetExplicitSave(false);
                if (!DoFileSave() && fSaveByUserDecision)
                {
                    // Restore to the default explicit save
                    SetExplicitSave(true);
                    return FALSE;       // don't continue
                }

                // Restore to the default explicit save
                SetExplicitSave(true);
                break;

            case IDNO:
                // If not saving changes, revert the document
                break;

            default:
                ASSERT(FALSE);
                break;
        }

    }

    // At this point we are committed to closing, so give each AMCView
    // a chance to do its clean-up work
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        CAMCView* const pView = GetNextAMCView(pos);

        if (pView != NULL)
            pView->CloseView();
    }

    return TRUE;    // keep going
}



#if (_MFC_VER > 0x0600)
#error CAMCDoc::DoSave was copied from CDocument::DoSave from MFC 6.0.
#error The MFC version has changed.  See if CAMCDoc::DoSave needs to be updated.
#endif

BOOL CAMCDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
    // Save the document data to a file
    // lpszPathName = path name where to save document file
    // if lpszPathName is NULL then the user will be prompted (SaveAs)
    // note: lpszPathName can be different than 'm_strPathName'
    // if 'bReplace' is TRUE will change file name if successful (SaveAs)
    // if 'bReplace' is FALSE will not change path name (SaveCopyAs)
{
    CString newName = lpszPathName;
    if (newName.IsEmpty())
    {
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);

        newName = m_strPathName;
        if (bReplace && newName.IsEmpty())
        {
            newName = m_strTitle;
#ifndef _MAC
            // check for dubious filename
            int iBad = newName.FindOneOf(_T(" #%;/\\"));
#else
            int iBad = newName.FindOneOf(_T(":"));
#endif
            if (iBad != -1)
                newName.ReleaseBuffer(iBad);

#ifndef _MAC
            // append the default suffix if there is one
            CString strExt;
            if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) &&
              !strExt.IsEmpty())
            {
                ASSERT(strExt[0] == '.');
                newName += strExt;
            }
#endif
        }

        if (!AfxGetApp()->DoPromptFileName(newName,
          bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
          OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, pTemplate))
            return FALSE;       // don't even attempt to save
    }

    CWaitCursor wait;

    if (!OnSaveDocument(newName))
    {
        // This is the modified MMC implementation
#ifdef MMC_DELETE_EXISTING_FILE     // See bug 395006
        if ((lpszPathName == NULL) && (m_eSaveStatus != eStat_Cancelled))
        {
            // be sure to delete the file
            try
            {
                CFile::Remove(newName);
            }
            catch (CException* pe)
            {
                TRACE0("Warning: failed to delete file after failed SaveAs.\n");
                pe->Delete();
            }
        }
#endif
        return FALSE;
    }

    // if changing the name of the open document
    if (bReplace)
    {
        /*
         *  Delete the help file for this console file before
         *  changing its name, because the help file can't be
         *  located once the old name is lost.
         */
        DeleteHelpFile ();

        // reset the title and change the document name
        SetPathName(newName);
    }

    return TRUE;        // success
}


BOOL CAMCDoc::IsModified()
{
    TRACE_METHOD(CAMCDoc, IsModified);

    BOOL const bModified = /*CDocument::IsModified() || */
                  (m_spScopeTreePersist != NULL && m_spScopeTreePersist->IsDirty() != S_FALSE);
    if (bModified)
        return TRUE;

    // Loop thru and save each view
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        // Get the view and skip if its the active view
        CAMCView* const v = GetNextAMCView(pos);

        if (v && v->IsDirty())
            return TRUE;
    }

    // The views should be asked about dirty before
    // asking the columns.
    if ( (NULL != m_ConsoleData.m_spPersistStreamColumnData) &&
         (S_OK == m_ConsoleData.m_spPersistStreamColumnData->IsDirty()) )
        return TRUE;

    // View data.
    IPersistStreamPtr spIPeristStreamViewSettings;
    SC sc = ScGetViewSettingsPersistorStream(&spIPeristStreamViewSettings);
    if ( (! sc.IsError()) &&
         (spIPeristStreamViewSettings != NULL) )
    {
        sc = spIPeristStreamViewSettings->IsDirty();
        if (sc == S_OK)
            return TRUE;

        sc.TraceAndClear();
    }

    return CDocument::IsModified();
}

void CAMCDoc::OnUpdateFileSave(CCmdUI* pCmdUI)
{
    pCmdUI->Enable (!IsReadOnly());
}


void CAMCDoc::OnConsoleAddremovesnapin()
{
    ASSERT(m_spScopeTree != NULL);

    // Can't run snap-in manager with active property sheets
    CString strMsg;
    LoadString(strMsg, IDS_SNAPINMGR_CLOSEPROPSHEET);
    if (FArePropertySheetsOpen(&strMsg))
        return;

    m_spScopeTree->RunSnapIn(AfxGetMainWnd()->m_hWnd);

    ::CoFreeUnusedLibraries();
}

void CAMCDoc::OnUpdateConsoleAddremovesnapin(CCmdUI* pCmdUI)
{
    pCmdUI->Enable (m_spScopeTree != NULL);
}



/*--------------------------------------------------------------------------*
 * CAMCDoc::SetMode
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetMode (ProgramMode eMode)
{
    /*
     * only set the modified flag if something actually changed
     */
    if (m_ConsoleData.m_eConsoleMode != eMode)
    {
        // should only be able to get here in author mode
        ASSERT (AMCGetApp()->GetMode() == eMode_Author);
        ASSERT (IsValidProgramMode (eMode));

        m_ConsoleData.m_eConsoleMode = eMode;
        SetModifiedFlag ();
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::SetConsoleFlag
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetConsoleFlag (ConsoleFlags eFlag, bool fSet)
{
    DWORD dwFlags = m_ConsoleData.m_dwFlags;

    if (fSet)
        dwFlags |=  eFlag;
    else
        dwFlags &= ~eFlag;

    /*
     * only set the modified flag if something actually changed
     */
    if (m_ConsoleData.m_dwFlags != dwFlags)
    {
        m_ConsoleData.m_dwFlags = dwFlags;
        SetModifiedFlag ();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * mappedModes
 *
 * PURPOSE: provides map to be used when persisting ProgramMode enumeration
 *
 * NOTE:    do not remove/ change items unless you're sure no console
 *          files will be broken
 *
 *+-------------------------------------------------------------------------*/
static const EnumLiteral mappedModes[] =
{
    { eMode_Author,     XML_ENUM_PROGRAM_MODE_AUTHOR   } ,
    { eMode_User,       XML_ENUM_PROGRAM_MODE_USER     } ,
    { eMode_User_MDI,   XML_ENUM_PROGRAM_MODE_USER_MDI } ,
    { eMode_User_SDI,   XML_ENUM_PROGRAM_MODE_USER_SDI } ,
};

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Persist
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCDoc::Persist(CPersistor& persistor)
{
    DECLARE_SC (sc, _T("CAMCDoc::Persist"));

    CAMCApp*    pApp = AMCGetApp();

    // check required pointers before going any further
    sc = ScCheckPointers(m_spStringTable ? pApp : NULL, // + workaround to check more pointers
                         m_ConsoleData.m_pXMLPersistColumnData,
                         m_spScopeTree ?   GetFavorites() : NULL, // + same workaround ^
                         E_POINTER);
    if (sc)
        sc.Throw();

    // persist version of the document
    CStr strFileVer = 0.;
    if (persistor.IsStoring())
    {
        strFileVer = GetCurrentFileVersionAsString().c_str();

        GUID  guidConsoleId;
        sc = CoCreateGuid(&guidConsoleId);
        if (sc)
            sc.Throw();

        // this parameter is also updated in IDocConfig implementation
        // update that code when changing following lines
        CPersistor persistorGuid(persistor, XML_TAG_CONSOLE_FILE_UID);
        persistorGuid.PersistContents(guidConsoleId);
    }
    persistor.PersistAttribute(XML_ATTR_CONSOLE_VERSION, strFileVer);
    if (persistor.IsLoading())
    {
        // 'decode' the version
        LPCTSTR pstrStart = strFileVer;
        LPTSTR  pstrStop =  const_cast<LPTSTR>(pstrStart);

        UINT uiMajorVer = _tcstol(pstrStart, &pstrStop, 10) ;

        UINT uiMinorVer = 0;
        if (pstrStop != pstrStart && *pstrStop == '.')
        {
            pstrStart = pstrStop + 1;
            uiMinorVer = _tcstol(pstrStart, &pstrStop, 10) ;
        }

        UINT uiMinorSubVer = 0;
        if (pstrStop != pstrStart && *pstrStop == '.')
        {
            pstrStart = pstrStop + 1;
            uiMinorVer = _tcstol(pstrStart, &pstrStop, 10) ;
        }

        ConsoleFileVersion eVersion = (ConsoleFileVersion)MakeConsoleFileVer_(uiMajorVer,
                                                                              uiMinorVer,
                                                                              uiMinorSubVer);

        m_ConsoleData.m_eFileVer = eVersion;

        // BUGBUG: this needs to be changed when we implement 'dynamic' SC messages
        if (eVersion != FileVer_Current)
            sc.Throw(E_UNEXPECTED);
    }


    // Create a storage for binaries
    // This will create "detached" XML element which may be used by persistor's
    // childs to store binary informatio.
    // (The element is attached to XML document by calling "CommitBinaryStorage()" )
    if (persistor.IsStoring())
        persistor.GetDocument().CreateBinaryStorage();
    else
        persistor.GetDocument().LocateBinaryStorage();

    /*
     * make sure the tree expansion happens synchronously
     */
    bool fSyncExpandWasRequired = m_spScopeTree->IsSynchronousExpansionRequired() == S_OK;
    m_spScopeTree->RequireSynchronousExpansion (true);

    // historically both loading and saving is to be done in certain order
    // steps are ordered by storing order
    const int STEP_FRAME        = 1;
    const int STEP_VIEWS        = 2;
    const int STEP_APP_MODE     = 3;
    const int STEP_CUST_DATA    = 4;
    const int STEP_FAVORITES    = 5;
    const int STEP_SCOPE_TREE   = 6;
    const int STEP_VIEW_DATA    = 7;
    const int STEP_COLUMN_DATA  = 8;
    const int STEP_STRING_TABLE = 9;
    const int MIN_STEP = 1;
    const int MAX_STEP = 9;
    for (int iStep = persistor.IsStoring() ? MIN_STEP : MAX_STEP;
         persistor.IsStoring() ? (iStep <= MAX_STEP) : (iStep >= MIN_STEP);
         persistor.IsStoring() ? ++iStep : --iStep
        )
    {
        switch(iStep)
        {
        case STEP_FRAME:
            PersistFrame(persistor);
            break;
        case STEP_VIEWS:
            PersistViews(persistor);
            break;
        case STEP_APP_MODE:
            if (persistor.IsLoading())
            {
                // restore proper application mode
                ProgramMode eMode;

                // create wrapper to persist enumeration values as strings
                CXMLEnumeration modeValuePersistor(eMode, mappedModes, countof(mappedModes));

                // persist the wrapper
                persistor.PersistAttribute(XML_ATTR_APPLICATION_MODE, modeValuePersistor);

                pApp->SetMode(eMode);
            }
            break;
        case STEP_CUST_DATA:
            PersistCustomData (persistor);
            break;
        case STEP_FAVORITES:
            persistor.Persist(*GetFavorites());
            break;
        case STEP_SCOPE_TREE:
            // IDocConfig relies on tree to be under the document.
            // revisit that code if you do the change here
            sc = m_spScopeTree->Persist(reinterpret_cast<HPERSISTOR>(&persistor));
            if (sc)
                sc.Throw();
            break;
        case STEP_VIEW_DATA:
            {
               INodeCallbackPtr spNodeCallback;
               sc = m_spScopeTree->QueryNodeCallback(&spNodeCallback);
               if (sc)
                   sc.Throw();

               sc = ScCheckPointers(spNodeCallback, E_UNEXPECTED);
               if (sc)
                   sc.Throw();

               CXMLObject *pXMLViewSettings = NULL;
               sc = spNodeCallback->QueryViewSettingsPersistor(&pXMLViewSettings);
               if (sc)
                   sc.Throw();

               sc = ScCheckPointers(pXMLViewSettings, E_UNEXPECTED);
               if (sc)
                   sc.Throw();

                persistor.Persist(*pXMLViewSettings);
            }
            break;
        case STEP_COLUMN_DATA:
            persistor.Persist(*m_ConsoleData.m_pXMLPersistColumnData);
            break;
        case STEP_STRING_TABLE:
            CMasterStringTable *pMasterStringTable = dynamic_cast<CMasterStringTable *>((IStringTablePrivate *)m_spStringTable);
            if(!pMasterStringTable)
            {
                sc = E_UNEXPECTED;
                sc.Throw();
            }
            persistor.Persist(*pMasterStringTable);
            break;
        }
    }

    m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
    SetModifiedFlag      (false);
    SetFrameModifiedFlag (false);

	/*
	 * We shouldn't think that a freshly saved console file is
	 * dirty.  If we do, someone's dirty bit processing is bogus.
	 */
	ASSERT (!IsFrameModified());

	/*
	 * Too many snap-ins leave themselves dirty after a load to leave this
	 * assert in, so we'll trace instead.  Note that this trace doesn't
	 * always indicate a snap-in problem, but it frequently does.
	 */
#ifdef DBG
//	ASSERT (!IsModified());
	if (IsModified())
		TraceErrorMsg (_T("CAMCDoc::IsModified returns true after %s"),
					   persistor.IsLoading() ? _T("opening") : _T("saving"));
#endif

    // The element used to gather binary information is attached to XML document here
    // Physically it will reside after all elements already added to persistor
    if (persistor.IsStoring())
        persistor.GetDocument().CommitBinaryStorage();
}

//***************************************************************************
// CScopedBool
// 
//
// PURPOSE: Owns a bool. The bool is set to false in the constructor and true
//          in the destructor.
//
//****************************************************************************
class CScopedBool
{
    bool & m_bool;

public:
    CScopedBool (bool &b) : m_bool(b)
    {
        b= false;
    }
    ~CScopedBool()
    {
        m_bool = true;
    }
};

void CAMCDoc::PersistViews(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::PersistViews"));

    CScopedBool scopedBool(m_bCanCloseViews); // lock the views from being deleted during the persist operation.

    if (persistor.IsLoading())
    {
        // Read templates for new views
        CViewTemplateList view_list(XML_TAG_VIEW_LIST);
        persistor.Persist(view_list);

        // Get the means for enumerating loaded collection
        CViewTemplateList::List_Type &rList = view_list.GetList();
        CViewTemplateList::List_Type::iterator it;

        // Enumerate all the views to be created
        // Create them one-by-one
        for (it = rList.begin(); it != rList.end(); ++it)
        {
            // extract information for the new view
            int iViewID = it->first;
            const CBookmark& pbm = it->second.first;
            CPersistor& v_persistor = it->second.second;

            // create it!
            sc = ScCreateAndLoadView(v_persistor, iViewID, pbm);
            if (sc)
                sc.Throw();
        }
    }
    else // if (persistor.IsStoring())
    {
        CPersistor persistorViews(persistor, XML_TAG_VIEW_LIST);

		/*
		 * Bug 3504: enumerate views in z-order (bottom-to-top) so the
		 * z-order will be restored correctly on reload
		 */
		CMainFrame* pMainFrame = AMCGetMainWnd();
		sc = ScCheckPointers (pMainFrame, E_UNEXPECTED);
		if (sc)
			sc.Throw();

		/*
		 * get the top-most MDI child
		 */
		CWnd* pwndMDIChild = pMainFrame->MDIGetActive();
		sc = ScCheckPointers (pwndMDIChild, E_UNEXPECTED);
		if (sc)
			sc.Throw();

		/*
		 * iterate through each of the MDI children
		 */
		for (pwndMDIChild  = pwndMDIChild->GetWindow (GW_HWNDLAST);
			 pwndMDIChild != NULL;
			 pwndMDIChild  = pwndMDIChild->GetNextWindow (GW_HWNDPREV))
		{
			/*
			 * turn the generic CMDIChildWnd into a CChildFrame
			 */
			CChildFrame* pChildFrame = dynamic_cast<CChildFrame*>(pwndMDIChild);
			sc = ScCheckPointers (pChildFrame, E_UNEXPECTED);
			if (sc)
				sc.Throw();

			/*
			 * get the view for this child frame
			 */
			CAMCView* pwndView = pChildFrame->GetAMCView();
			sc = ScCheckPointers (pwndView, E_UNEXPECTED);
			if (sc)
				sc.Throw();

            // skip those not persistible
            if ( !pwndView->IsPersisted() )
                continue;

			/*
			 * persist the view
			 */
			persistorViews.Persist (*pwndView);
		}
    }
}


void CAMCDoc::PersistFrame(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::PersistFrame"));

    CFrameState fs2 (m_ConsoleData.m_eConsoleMode, m_ConsoleData.m_dwFlags);
    ASSERT (fs2.wndplFrame.length == sizeof (WINDOWPLACEMENT));

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pMainFrame, E_UNEXPECTED);
    if (sc)
        sc.Throw();

    if (persistor.IsStoring())
    {
        // Get the attributes of the window.
        if (!pMainFrame->GetWindowPlacement (&fs2.wndplFrame))
            sc.Throw(E_FAIL);

        if (fs2.wndplFrame.showCmd == SW_SHOWMINIMIZED)
            fs2.wndplFrame.showCmd =  SW_SHOWNORMAL;
    }

    persistor.Persist(fs2);

    // this application setting (AppMode) is resored in AMCDoc::Persist, but saved/loaded here
    // create wrapper to persist enumeration values as strings
    CXMLEnumeration modeValuePersistor(m_ConsoleData.m_eConsoleMode, mappedModes, countof(mappedModes));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_APPLICATION_MODE, modeValuePersistor);

    if (persistor.IsLoading())
    {
        // Set the windows size and location and state
        CAMCApp*    pApp = AMCGetApp();
        pApp->UpdateFrameWindow(true);
        pMainFrame->UpdateChildSystemMenus();

        // the status bar is on the child frame now
        //  pMainFrame->ShowStatusBar ((fs2.dwFlags & eFlag_ShowStatusBar) != 0);

        // save the data from the file into the console data
        m_ConsoleData.m_eAppMode     = pApp->GetMode();
        m_ConsoleData.m_dwFlags      = fs2.dwFlags;

        InsurePlacementIsOnScreen (fs2.wndplFrame);

        // if we're initializing, defer the actual show until initialization is complete
        // same if script is under control and MMC is hidden
        if (pApp->IsInitializing()
         || ( !pApp->IsUnderUserControl() && !pMainFrame->IsWindowVisible() ) )
        {
            pApp->m_nCmdShow = fs2.wndplFrame.showCmd;
            fs2.wndplFrame.showCmd = SW_HIDE;
        }

        if (!pMainFrame->SetWindowPlacement (&fs2.wndplFrame))
            sc.Throw(E_FAIL);
    }
}

/*--------------------------------------------------------------------------*
 * CDocument::DoFileSave
 *
 * This is almost identical to CDocument::DoFileSave.  We just override it
 * here because we want to display a message for a read-only file before
 * throwing up the Save As dialog.
 *--------------------------------------------------------------------------*/

BOOL CAMCDoc::DoFileSave()
{
    DWORD dwAttrib = GetFileAttributes(m_strPathName);

    // attributes does not matter for user modes - it does not
    // save to the original console file anyway
    if ((AMCGetApp()->GetMode() == eMode_Author) &&
        (dwAttrib != 0xFFFFFFFF) &&
        (dwAttrib & FILE_ATTRIBUTE_READONLY))
    {
        CString strMessage;
        FormatString1 (strMessage, IDS_CONSOLE_READONLY, m_strPathName);
        MMCMessageBox (strMessage);

        // we do not have read-write access or the file does not (now) exist
        if (!DoSave(NULL))
        {
            TRACE0("Warning: File save with new name failed.\n");
            return FALSE;
        }
    }
    else
    {
        if (!DoSave(m_strPathName))
        {
            TRACE0("Warning: File save failed.\n");
            return FALSE;
        }
    }
    return TRUE;
}



/*--------------------------------------------------------------------------*
 * CAMCDoc::GetDefaultMenu
 *
 *
 *--------------------------------------------------------------------------*/

HMENU CAMCDoc::GetDefaultMenu()
{
    return (AMCGetApp()->GetMenu ());
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::GetCustomIcon
 *
 * Returns the small or large custom icon for the console.  Ownership of and
 * deletion responsibility for the icon is retained by CAMCDoc.
 *--------------------------------------------------------------------------*/

HICON CAMCDoc::GetCustomIcon (bool fLarge, CString* pstrIconFile, int* pnIconIndex) const
{
	DECLARE_SC (sc, _T("CAMCDoc::ScGetCustomIcon"));

    /*
     * if caller wants either the icon filename or index returned, get them
     */
    if ((pstrIconFile != NULL) || (pnIconIndex != NULL))
    {
        CPersistableIconData IconData;
        m_CustomIcon.GetData (IconData);

        if (pstrIconFile != NULL)
            *pstrIconFile = IconData.m_strIconFile.data();

        if (pnIconIndex != NULL)
            *pnIconIndex = IconData.m_nIndex;
    }

    /*
     * return the icon (m_CustomIcon will hold the reference for the
	 * caller)
     */
	CSmartIcon icon;
	sc = m_CustomIcon.GetIcon ((fLarge) ? 32 : 16, icon);
	if (sc)
		return (NULL);

	return (icon);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::SetCustomIcon
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetCustomIcon (LPCTSTR pszIconFile, int nIconIndex)
{
    DECLARE_SC (sc, _T("CAMCDoc::SetCustomIcon"));

    CPersistableIconData IconData (pszIconFile, nIconIndex) ;

    /*
     * if there's no change, bail
     */
    if (m_CustomIcon == IconData)
        return;

    m_CustomIcon = IconData;

    HICON 		hLargeIcon = GetCustomIcon (true  /*fLarge*/);
    HICON		hSmallIcon = GetCustomIcon (false /*fLarge*/);
    CMainFrame* pMainFrame = AMCGetMainWnd();

    sc = ScCheckPointers (hLargeIcon, hSmallIcon, pMainFrame, E_UNEXPECTED);
    if (sc)
        return;

    /*
     * change the icon on the frame
     */
    pMainFrame->SetIconEx (hLargeIcon, true);
    pMainFrame->SetIconEx (hSmallIcon, false);

    /*
     * change the icon on each MDI window
     */
    CWnd* pMDIChild = pMainFrame->MDIGetActive();

    while (pMDIChild != NULL)
    {
        ASSERT_KINDOF (CMDIChildWnd, pMDIChild);
        pMDIChild->SetIcon (hLargeIcon, true);
        pMDIChild->SetIcon (hSmallIcon, false);
        pMDIChild = pMDIChild->GetWindow (GW_HWNDNEXT);
    }

    SetModifiedFlag();
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadCustomData
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadCustomData (IStorage* pStorage)
{
    HRESULT hr;
    IStoragePtr spCustomDataStorage;
    hr = OpenDebugStorage (pStorage, g_pszCustomDataStorage,
                                STGM_SHARE_EXCLUSIVE | STGM_READ,
                                &spCustomDataStorage);


    if (FAILED (hr))
        return (true);

    LoadCustomIconData  (spCustomDataStorage);
    LoadCustomTitleData (spCustomDataStorage);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadCustomIconData
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadCustomIconData (IStorage* pStorage)
{
    HRESULT hr = m_CustomIcon.Load (pStorage);

    if (FAILED (hr))
        return (false);

    /*
     * If we get here, we have a custom icon.  The view windows
     * (MDI children) haven't been created yet -- they'll get the
     * right icons automatically.  The main frame, however, already
     * exists, so we have to explicitly set its icon here.
     */
    CWnd* pMainWnd = AfxGetMainWnd();
    pMainWnd->SetIcon (GetCustomIcon (true),  true);
    pMainWnd->SetIcon (GetCustomIcon (false), false);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadCustomTitleData
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadCustomTitleData (IStorage* pStorage)
{
    do  // not a loop
    {
        /*
         * Open the custom title data stream.  It may not exist, and
         * that's OK if it doesn't.  It just means we don't have a
         * custom title.
         */
        USES_CONVERSION;
        HRESULT hr;
        IStreamPtr spStream;
        hr = OpenDebugStream (pStorage, AMCCustomTitleStreamName,
                                   STGM_SHARE_EXCLUSIVE | STGM_READ,
                                   &spStream);

        BREAK_ON_FAIL (hr);

        try
        {
            /*
             * Read the stream version
             */
            DWORD dwVersion;
            *spStream >> dwVersion;

            /*
             * if this is the beta custom title format, migrate it forward
             */
            switch (dwVersion)
            {
                case 0:
                {
                    /*
                     * Read the length (in bytes) of the title
                     */
                    WORD cbTitle;
                    *spStream >> cbTitle;
                    const WORD cchTitle = cbTitle / sizeof (WCHAR);

                    /*
                     * Read the title
                     */
                    std::auto_ptr<WCHAR> spwzWideTitle (new WCHAR[cchTitle + 1]);
                    LPWSTR pwzWideTitle = spwzWideTitle.get();

                    DWORD cbRead;
                    hr = spStream->Read (pwzWideTitle, cbTitle, &cbRead);
                    BREAK_ON_FAIL (hr);

                    if (cbRead != cbTitle)
                        break;

                    /*
                     * terminate and convert the title string
                     */
                    pwzWideTitle[cchTitle] = 0;
                    if (m_pstrCustomTitle != NULL)
                        *m_pstrCustomTitle = W2T (pwzWideTitle);
                    break;
                }

                case 1:
                    if (m_pstrCustomTitle != NULL)
                        *spStream >> (*m_pstrCustomTitle);
                    break;

                default:
                    ASSERT (false);
                    break;
            }
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
            break;
        }
        catch (CMemoryException* pe)
        {
            pe->Delete();
            _com_issue_error (E_OUTOFMEMORY);
        }
    } while (false);

    return (true);
}



bool CAMCDoc::HasCustomTitle () const
{
    if(!m_pstrCustomTitle)
        return false;

    return (!m_pstrCustomTitle->str().empty());

}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadStringTable
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadStringTable (IStorage* pStorage)
{
    DECLARE_SC (sc, _T("CAMCDoc::LoadStringTable"));

    /*
     * open the string table storage
     */
    IStoragePtr spStringTableStg;
    HRESULT hr = OpenDebugStorage (pStorage, AMCStringTableStorageName,
                                        STGM_SHARE_EXCLUSIVE | STGM_READ,
                                        &spStringTableStg);


    /*
     * If there's no string table, things are OK.  We allow this so
     * we can continue to open older console files.
     */
    if (hr == STG_E_FILENOTFOUND)
        return (true);

    if (SUCCEEDED (hr))
    {
        /*
         * read the string table from the storage
         */
        try
        {
            CMasterStringTable *pMasterStringTable = dynamic_cast<CMasterStringTable *>((IStringTablePrivate *)m_spStringTable);
            if(!pMasterStringTable)
            {
                sc = E_UNEXPECTED;
                sc.Throw();
            }

            *spStringTableStg >> *pMasterStringTable;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (SUCCEEDED (hr));
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::SetCustomTitle
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetCustomTitle (CString strNewTitle)
{
    DECLARE_SC (sc, _T("CAMCDoc::SetCustomTitle"));

    if(!m_pstrCustomTitle)
        return;

    /*
     * if there's no change, just short out
     */
    if ((*m_pstrCustomTitle) == strNewTitle)
        return;

    /*
     * copy the new custom title
     */
    (*m_pstrCustomTitle) = strNewTitle;

    /*
     * force the frame to update
     */
    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pMainFrame, E_UNEXPECTED);
    if (sc)
        return;

    pMainFrame->OnUpdateFrameTitle (false);

    SetModifiedFlag();
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::GetCustomTitle
 *
 *
 *--------------------------------------------------------------------------*/

CString CAMCDoc::GetCustomTitle() const
{
    if (HasCustomTitle())
        return (m_pstrCustomTitle->data());

    CString strTitle = GetTitle();

    /*
     * strip the extension (extensions, including a separator,
     * are 4 characters or less)
     */
    int nExtSeparator = strTitle.ReverseFind (_T('.'));

    if ((nExtSeparator != -1) && ((strTitle.GetLength()-nExtSeparator) <= 4))
        strTitle = strTitle.Left (nExtSeparator);

    return (strTitle);
}

/*+-------------------------------------------------------------------------*
 * CAMCDoc::GetStringTable
 *
 *
 *--------------------------------------------------------------------------*/

IStringTablePrivate* CAMCDoc::GetStringTable() const
{
    return m_spStringTable;
}

/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadFavorites
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadFavorites ()
{
    ASSERT(m_spStorage != NULL);

    // Open the stream for the cache
    IStreamPtr spStream;
    HRESULT hr = OpenDebugStream(m_spStorage, AMCFavoritesStreamName,
                     STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"FavoritesStream", &spStream);
    if (FAILED(hr)) // did not find the stream - could be an older version.
        return hr;

    hr = GetFavorites()->Read(spStream);

    return (SUCCEEDED (hr));
}


void ShowAdminToolsOnMenu(LPCTSTR lpszFilename)
{
    static const TCHAR szAdminKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced");
    static const TCHAR szAdminValue[] = _T("StartMenuAdminTools");
    static const TCHAR szBroadcastParam[] = _T("ShellMenu");
    static const TCHAR szYes[] = _T("YES");

    CString strPath(lpszFilename);
    int nLastSepIndex = strPath.ReverseFind (_T('\\'));

    if (nLastSepIndex != -1)
    {
        // if we got "d:\filename", make sure to include the trailing separator
        if (nLastSepIndex < 3)
            nLastSepIndex++;

        // Form full path name (accounting for current directory info)
        TCHAR   szFullPathName[MAX_PATH];
        GetFullPathName (strPath.Left(nLastSepIndex), countof(szFullPathName),
                         szFullPathName, NULL);

        // if saving to admin tools
        if (AMCGetApp()->GetDefaultDirectory() == szFullPathName)
        {
            // set reg key to add admin tools to start menu
            HKEY hkey;
            long r = RegOpenKeyEx (HKEY_CURRENT_USER, szAdminKey, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkey);
            ASSERT(r == ERROR_SUCCESS);

            if (r == ERROR_SUCCESS)
            {
                // get current value
                TCHAR szBuffer[4];
                DWORD dwType = REG_SZ;
                DWORD dwCount = sizeof(szBuffer);
                r = RegQueryValueEx (hkey, szAdminValue, NULL, &dwType,(LPBYTE)szBuffer, &dwCount);

                // if value isn't "YES" then change it, and broadcast change message
                if (r != ERROR_SUCCESS || dwType != REG_SZ || lstrcmpi(szBuffer, szYes) != 0)
                {
                    r = RegSetValueEx (hkey, szAdminValue, NULL, REG_SZ, (CONST BYTE *)szYes, sizeof(szYes));
                    ASSERT(r == ERROR_SUCCESS);

                    ULONG_PTR dwRes;
                    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, (WPARAM)0,
                                        (LPARAM)szBroadcastParam, SMTO_ABORTIFHUNG|SMTO_NORMAL, 100, &dwRes);
                }

                RegCloseKey(hkey);
            }
        }
    }
}


void CAMCDoc::PersistCustomData (CPersistor &persistor)
{
    CPersistor persistorCustom(persistor, XML_TAG_CUSTOM_DATA);
    // persist custom title
    // It may not exist, and that's OK if it doesn't.
    // It just means we don't have a custom title.
    if ((persistorCustom.IsLoading()
         && persistorCustom.HasElement(XML_TAG_STRING_TABLE_STRING, XML_ATTR_CUSTOM_TITLE))
     || (persistorCustom.IsStoring() && HasCustomTitle()))
    {
        if(m_pstrCustomTitle)
            persistorCustom.PersistString(XML_ATTR_CUSTOM_TITLE, *m_pstrCustomTitle);
    }

    // persist custom icon
    CXMLPersistableIcon persIcon(m_CustomIcon);

    bool bHasIcon = persistorCustom.IsLoading() && persistorCustom.HasElement(persIcon.GetXMLType(), NULL);
    bHasIcon = bHasIcon || persistorCustom.IsStoring() && HasCustomIcon();

    if (!bHasIcon)
        return;

    persistorCustom.Persist(persIcon);

    if (persistorCustom.IsLoading())
    {
        CWnd* pMainWnd = AfxGetMainWnd();
        pMainWnd->SetIcon (GetCustomIcon (true),  true);
        pMainWnd->SetIcon (GetCustomIcon (false), false);
    }
}



/***************************************************************************\
 *
 * METHOD:  GetCurrentFileVersionAsString
 *
 * PURPOSE: formats current file version and returns a string
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CString    - resulting string
 *
\***************************************************************************/
tstring GetCurrentFileVersionAsString()
{
    DECLARE_SC(sc, TEXT("GetCurrentFileVersionAsString"));
    TCHAR szFileVersion[16];
    int cChFileVersion = countof(szFileVersion);

    // get file version data
    UINT uiMajorVer =    GetConsoleFileMajorVersion(FileVer_Current);
    UINT uiMinorVer =    GetConsoleFileMinorVersion(FileVer_Current);
    UINT uiMinorSubVer = GetConsoleFileMinorSubversion(FileVer_Current);

    if (uiMinorSubVer)
        sc = StringCchPrintf(szFileVersion, cChFileVersion, _T("%d.%d.%d"),  uiMajorVer,  uiMinorVer, uiMinorSubVer);
    else
        sc = StringCchPrintf(szFileVersion, cChFileVersion, _T("%d.%d"),  uiMajorVer,  uiMinorVer);

    if (sc)
        return _T("");

    return szFileVersion;
}

/***************************************************************************\
 *
 * METHOD:  CAMCDoc::ScOnSnapinAdded
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin added to the console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCDoc::ScOnSnapinAdded(PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScOnSnapinAdded"));

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward
    sc = pApp->ScOnSnapinAdded(this, pSnapIn);
    if (sc)
        return sc;


    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCDoc::ScOnSnapinRemoved
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin removed from console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCDoc::ScOnSnapinRemoved(PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScOnSnapinRemoved"));

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward
    sc = pApp->ScOnSnapinRemoved(this, pSnapIn);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::ScSetHelpCollectionInvalid
//
//  Synopsis:    A snapin is added/removed or extension is
//               enabled/disabled therefore help collection
//               no longer reflects current console file.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::ScSetHelpCollectionInvalid ()
{
    DECLARE_SC(sc, _T("CAMCDoc::ScSetHelpCollectionInvalid"));

    HELPDOCINFO *pHelpDocInfo = GetHelpDocInfo();
    sc = ScCheckPointers(pHelpDocInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    // console file modify time has to be updated for help collection.
    GetSystemTimeAsFileTime(&pHelpDocInfo->m_ftimeModify);

    return (sc);
}



SC CAMCDoc::Scget_Application(PPAPPLICATION  ppApplication)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_Application"));

    // parameter check
    sc = ScCheckPointers(ppApplication, E_UNEXPECTED);
    if (sc)
        return sc;

    // initialization
    *ppApplication = NULL;

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pApp->ScGet_Application(ppApplication);
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amc.h
//
//--------------------------------------------------------------------------

// AMC.h : main header file for the AMC application
//

#ifndef __AMC_H__
#define __AMC_H__

#ifndef __AFXWIN_H__
   #error include 'stdafx.h' before including this file for PCH
#endif

class CAMCDoc;

/////////////////////////////////////////////////////////////////////////////
// CAMCApp:
// See AMC.cpp for the implementation of this class
//

class CMainFrame;

class CAMCApp : public CWinApp, public CAMCViewObserver,
                public CAMCViewToolbarsObserver, public CConsoleEventDispatcher
{
    friend class CMMCApplication;
    DECLARE_DYNAMIC (CAMCApp)

    typedef std::list<HWND>             WindowList;
    typedef std::list<HWND>::iterator   WindowListIterator;

    // object model
public:
    SC      ScGet_Application(_Application **pp_Application);
    SC      ScRegister_Application(_Application *p_Application);

private:
    _ApplicationPtr m_sp_Application;

public:
    SC           ScCheckMMCPrerequisites();
    virtual BOOL PumpMessage();     // low level message pump
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void RegisterShellFileTypes(BOOL bCompat);
    CAMCApp();

// Attributes
public:
    CMainFrame *    GetMainFrame();

// Operations
public:
    void SetDefaultDirectory();
    void SaveUserDirectory(LPCTSTR pszUserDir);
    CString GetUserDirectory();
    CString GetDefaultDirectory();

    HMENU GetMenu () const
    {
        return (m_Menu);
    }

    ProgramMode GetMode() const
    {
        ASSERT (IsValidProgramMode (m_eMode));
        return (m_eMode);
    }

    bool IsInitializing() const
    {
        return (m_fInitializing);
    }

    bool DidCloseComeFromMainPump() const
    {
        return (m_fCloseCameFromMainPump);
    }

    void ResetCloseCameFromMainPump()
    {
        m_fCloseCameFromMainPump = false;
    }

    void DelayCloseUntilIdle (bool fDelay = true)
    {
        m_fDelayCloseUntilIdle = fDelay;
    }

    bool IsWin9xPlatform() const
    {
        return m_fIsWin9xPlatform;
    }

    bool IsMMCRunningAsOLEServer() const { return m_fRunningAsOLEServer;}

    void UpdateFrameWindow(bool bUpdate);

    void InitializeMode (ProgramMode eMode);
    void SetMode (ProgramMode eMode);

    void HookPreTranslateMessage (CWnd* pwndHook);
    void UnhookPreTranslateMessage (CWnd* pwndUnhook);

    CIdleTaskQueue * GetIdleTaskQueue ();

    SC ScShowHtmlHelp(LPCTSTR pszFile, DWORD_PTR dwData);

    // helpers for script event firing
    SC ScOnNewDocument(CAMCDoc *pDocument, BOOL bLoadedFromConsole);
    SC ScOnCloseDocument(CAMCDoc *pDocument);
    SC ScOnQuitApp();
    SC ScOnSnapinAdded  (CAMCDoc *pDocument, PSNAPIN pSnapIn);
    SC ScOnSnapinRemoved(CAMCDoc *pDocument, PSNAPIN pSnapIn);
    SC ScOnNewView(CAMCView *pView);

    bool IsUnderUserControl() { return m_fUnderUserControl;}

protected:
    void SetUnderUserControl(bool bUserControl = true);

// Interfaces
private:
    BOOL InitializeOLE();
    void DeinitializeOLE();
    SC   ScUninitializeHelpControl();

    HRESULT DumpConsoleFile (CString strConsoleFile, CString strDumpFile);


private:
    SC   ScProcessAuthorModeRestrictions();

private:
    BOOL m_bOleInitialized;
    BOOL m_bDefaultDirSet;
    bool m_fAuthorModeForced;
    bool m_fInitializing;
    bool m_fDelayCloseUntilIdle;
    bool m_fCloseCameFromMainPump;
    int  m_nMessagePumpNestingLevel;
    bool m_fUnderUserControl;
    bool m_fRunningAsOLEServer;

    CIdleTaskQueue      m_IdleTaskQueue;
    ProgramMode         m_eMode;
    CMenu               m_Menu;
    CAccel              m_Accel;
    WindowList          m_TranslateMessageHookWindows;
    bool                m_fIsWin9xPlatform;

    static const TCHAR  m_szSettingsSection[];
    static const TCHAR  m_szUserDirectoryEntry[];

    bool                m_bHelpInitialized;
    DWORD_PTR           m_dwHelpCookie;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    virtual BOOL OnIdle(LONG lCount);
    //}}AFX_VIRTUAL

// Implementation
#ifdef _DEBUG
    virtual void AssertValid() const;
#endif

    //{{AFX_MSG(CAMCApp)
    afx_msg void OnAppAbout();
    afx_msg void OnFileNewInUserMode(); // do nothing in user mode when CTRL+N is pressed. This handler prevents the hotkey from going to any WebBrowser controls
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // Observed view events - each fires a com event
protected:
    virtual SC ScOnCloseView( CAMCView *pView );
    virtual SC ScOnViewChange( CAMCView *pView, HNODE hNode );
    virtual SC ScOnResultSelectionChange( CAMCView *pView );
    virtual SC ScOnContextMenuExecuted( PMENUITEM pMenuItem );
    virtual SC ScOnListViewItemUpdated(CAMCView *pView , int nIndex);

    // toolbar events
    virtual SC ScOnToolbarButtonClicked( );

    // Object model related code - these are in a private block
    // because CMMCApplication is a friend class
private:
    SC    ScHelp();
    SC    ScRunTestScript();

};

inline CAMCApp* AMCGetApp()
{
    extern CAMCApp theApp;
    return (&theApp);
}

inline CIdleTaskQueue * AMCGetIdleTaskQueue()
{
    return (AMCGetApp()->GetIdleTaskQueue());
}

extern const CRect g_rectEmpty;

#ifdef DBG
extern CTraceTag tagForceMirror;
#endif


/////////////////////////////////////////////////////////////////////////////

#endif //__AMC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amc.cpp
//
//  Contents:  The one and only app
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Add code to switch views
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"


#include "MainFrm.h"
#include "ChildFrm.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "amcdocmg.h"
#include "sysmenu.h"
#include <shlobj.h>
#include "strings.h"
#include "macros.h"
#include "scripthost.h"
#include "HtmlHelp.h"
#include "scriptevents.h"
#include "mmcutil.h"
#include "guidhelp.h"       // for CLSID relational operators
#include "archpicker.h"
#include "classreg.h"

#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#include "websnk.h"
#include "websnk_i.c"

// We aren't picking this up from winuser.h for some reason.
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(3)

/*
 * define our own Win64 symbol to make it easy to include 64-bit only
 * code in the 32-bit build, so we can exercise some code on 32-bit Windows
 * where the debuggers are better
 */
#ifdef _WIN64
#define MMC_WIN64
#endif

#ifndef MMC_WIN64
#include <wow64t.h>         // for Wow64DisableFilesystemRedirector
#endif

/*
 * multimon.h is included by stdafx.h, without defining COMPILE_MULTIMON_STUBS
 * first.  We need to include it again here after defining COMPILE_MULTIMON_STUBS
 * so we'll get the stub functions.
 */
#if (_WIN32_WINNT < 0x0500)
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#endif

#ifdef DBG
    CTraceTag  tagEnableScriptEngines(_T("MMCScriptEngines"), _T("Enable"));
    CTraceTag  tag32BitTransfer(_T("64/32-bit interop"), _T("64/32-bit interop"));
#endif

// Note: These strings do not need to be localizable.
const TCHAR CAMCApp::m_szSettingsSection[]    = _T("Settings");
const TCHAR CAMCApp::m_szUserDirectoryEntry[] = _T("Save Location");

bool CanCloseDoc(void);
SC ScExpandEnvironmentStrings (CString& str);

//############################################################################
//############################################################################
//
//  ATL Support
//
//############################################################################
//############################################################################
#include <atlimpl.cpp>
#include <atlwin.cpp>

// The one and only instance of CAtlGlobalModule
CAtlGlobalModule _Module;

//############################################################################
//############################################################################
//
//  Trace Tags
//
//############################################################################
//############################################################################
#ifdef DBG
// enable this tag if you suspect memory corruption
// and you don't mind things slowing way down

BEGIN_TRACETAG(CDebugCRTCheck)
    void OnEnable()
    {
        _CrtSetDbgFlag (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)
                        | _CRTDBG_CHECK_ALWAYS_DF
                        | _CRTDBG_DELAY_FREE_MEM_DF);
    }
    void OnDisable()
    {
        _CrtSetDbgFlag (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)
                        & ~(_CRTDBG_CHECK_ALWAYS_DF
                            | _CRTDBG_DELAY_FREE_MEM_DF) );
    }
END_TRACETAG(CDebugCRTCheck, TEXT("Debug CRTs"), TEXT("Memory Check - SLOW!"))

CTraceTag tagAMCAppInit(TEXT("CAMCView"), TEXT("InitInstance"));
CTraceTag tagATLLock(TEXT("ATL"), TEXT("Lock/Unlock"));  // used by atlconui.h
CTraceTag tagGDIBatching(TEXT("CAMCView"), TEXT("Disable Graphics/GDI Batching"));
CTraceTag tagForceMirror(TEXT("Mirroring"), TEXT("Force MMC windows to be mirrored on non-mirrored systems"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CMMCApplication - the root level
//  automation class
//
//############################################################################
//############################################################################
class CMMCApplication :
    public CMMCIDispatchImpl<_Application, &CLSID_Application>,
    public CComCoClass<CMMCApplication, &CLSID_Application>,
    // support for connection points (script events)
    public IConnectionPointContainerImpl<CMMCApplication>,
    public IConnectionPointImpl<CMMCApplication, &DIID_AppEvents, CComDynamicUnkArray>,
    public IProvideClassInfo2Impl<&CLSID_Application, &DIID_AppEvents, &LIBID_MMC20>
    {
public:
    BEGIN_MMC_COM_MAP(CMMCApplication)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
    END_MMC_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CMMCApplication)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		CObjectRegParams op (
			CLSID_Application,
			_T("mmc.exe"),
			_T("MMC Application Class"),
			_T("MMC20.Application.1"),
			_T("MMC20.Application"),
			_T("LocalServer32") );

		return (MMCUpdateRegistry (bRegister, &op, NULL));
	}

    //hooks into ATL's construction
    HRESULT InternalFinalConstructRelease(); // not FinalConstruct() - this is to work around a bogus ATL assert.

    BEGIN_CONNECTION_POINT_MAP(CMMCApplication)
        CONNECTION_POINT_ENTRY(DIID_AppEvents)
    END_CONNECTION_POINT_MAP()

    // overriden to do more job than the base class does
    virtual ::SC ScOnDisconnectObjects();

private:

    //IMMCApplication
public:
    void  STDMETHODCALLTYPE  Help();
    void  STDMETHODCALLTYPE  Quit();
    STDMETHOD(get_Document)     (Document **ppDocument);
    STDMETHOD(Load)             (BSTR bstrFilename);
    STDMETHOD(get_Frame)        (Frame **ppFrame);
    STDMETHOD(get_Visible)      (BOOL *pVisible);
    STDMETHOD(Show)             ();
    STDMETHOD(Hide)             ();
    STDMETHOD(get_UserControl)  (PBOOL pUserControl);
    STDMETHOD(put_UserControl)  (BOOL  bUserControl);
    STDMETHOD(get_VersionMajor) (PLONG pVersionMajor);
    STDMETHOD(get_VersionMinor) (PLONG pVersionMinor);

private:
    // Return the CAMCApp only if it is initialized. We do not want
    // object model methods to operate on app while initializing.
    CAMCApp *GetApp()
    {
        CAMCApp *pApp = AMCGetApp();
        if ( (! pApp) || (pApp->IsInitializing()) )
            return NULL;

        return pApp;
    }
};

//############################################################################
//############################################################################
//
//  Event map for application events
//
//############################################################################
//############################################################################

DISPATCH_CALL_MAP_BEGIN(AppEvents)

    DISPATCH_CALL1( AppEvents, OnQuit,                   PAPPLICATION )
    DISPATCH_CALL2( AppEvents, OnDocumentOpen,           PDOCUMENT,        BOOL)
    DISPATCH_CALL1( AppEvents, OnDocumentClose,          PDOCUMENT )
    DISPATCH_CALL2( AppEvents, OnSnapInAdded,            PDOCUMENT,  PSNAPIN )
    DISPATCH_CALL2( AppEvents, OnSnapInRemoved,          PDOCUMENT,  PSNAPIN )
    DISPATCH_CALL1( AppEvents, OnNewView,                PVIEW )
    DISPATCH_CALL1( AppEvents, OnViewClose,              PVIEW )
    DISPATCH_CALL2( AppEvents, OnViewChange,             PVIEW,      PNODE );
    DISPATCH_CALL2( AppEvents, OnSelectionChange,        PVIEW,      PNODES )
    DISPATCH_CALL1( AppEvents, OnContextMenuExecuted,    PMENUITEM );
    DISPATCH_CALL0( AppEvents, OnToolbarButtonClicked )
    DISPATCH_CALL1( AppEvents, OnListUpdated,            PVIEW )

DISPATCH_CALL_MAP_END()



/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::InternalFinalConstructRelease
 *
 * PURPOSE: Hands the CAMCApp a pointer to the 'this' object.
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplication::InternalFinalConstructRelease()
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::InternalFinalConstructRelease"));

    // Dont use GetApp, we need to get CAMCApp even if it is not fully initialized.
    CAMCApp *pApp = AMCGetApp();
    sc = ScCheckPointers(pApp);
    if(sc)
        return sc.ToHr(); // some wierd error.

    sc = pApp->ScRegister_Application(this);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::GetFrame
 *
 * PURPOSE: A static function that hooks into the COM interface entry list
 *          and allows a tear-off object to be created that implements the
 *          Frame interface.
 *
 * PARAMETERS:
 *    void*   pv :   Defined by ATL to hold a pointer to the CMMCApplication object
 *                   because this is a static method.
 *    REFIID  riid :  As per QI
 *    LPVOID* ppv :   As per QI
 *    DWORD   dw :   ignored
 *
 * RETURNS:
 *    HRESULT WINAPI
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCApplication::get_Frame(Frame **ppFrame)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::get_Frame"));

    if(!ppFrame)
    {
        sc = E_POINTER;
        return sc.ToHr();
    }

    // get the app
    CAMCApp *pApp = GetApp();
    if(NULL == pApp)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }


    CMainFrame *pMainFrame = pApp->GetMainFrame();
    if(!pMainFrame)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMainFrame->ScGetFrame(ppFrame);

    return sc.ToHr();
}


STDMETHODIMP
CMMCApplication::get_Document(Document **ppDocument)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::get_Document"));

    CAMCDoc* const pDoc = CAMCDoc::GetDocument();

    ASSERT(ppDocument != NULL);
    if(ppDocument == NULL || (pDoc == NULL))
    {
        sc = E_POINTER;
        return sc.ToHr();
    }

    sc = pDoc->ScGetMMCDocument(ppDocument);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCApplication::Load
 *
 * PURPOSE: implements Application.Load for object model
 *
 * PARAMETERS:
 *    BSTR bstrFilename - console file to load
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCApplication::Load(BSTR bstrFilename)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::Load"));

    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    USES_CONVERSION;
    pApp->OpenDocumentFile(OLE2CT(bstrFilename));
    return sc.ToHr();
}


void
STDMETHODCALLTYPE CMMCApplication::Help()
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::Help"));

    CAMCApp *pApp = GetApp();

    if(NULL == pApp)
    {
        sc = E_UNEXPECTED;
        return;
    }

    sc = pApp->ScHelp();
    if(sc)
        return;

    return;
}

void
STDMETHODCALLTYPE CMMCApplication::Quit()
{
	MMC_COM_MANAGE_STATE();

    SC sc;
    CAMCApp *pApp = GetApp();

    if(NULL == pApp)
        goto Error;

    // confiscate the control from user
    pApp->SetUnderUserControl(false);

    // get mainframe
    {
        CMainFrame * pMainFrame = pApp->GetMainFrame();
        if(NULL == pMainFrame)
            goto Error;

        // close it gracefully.
        pMainFrame->PostMessage(WM_CLOSE);
    }

Cleanup:
    return;
Error:
    sc = E_UNEXPECTED;
    TraceError(TEXT("CMMCApplication::Quit"), sc);
    goto Cleanup;
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::get_VersionMajor
 *
 * PURPOSE: Returns the major version number for the installed version of MMC.
 *
 * PARAMETERS:
 *    PLONG  pVersionMajor :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplication::get_VersionMajor(PLONG pVersionMajor)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::get_VersionMajor"));

    sc = ScCheckPointers(pVersionMajor);
    if(sc)
        return sc.ToHr();

    *pVersionMajor = MMC_VERSION_MAJOR;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::get_VersionMinor
 *
 * PURPOSE: Returns the minor version number for the installed version of MMC.
 *
 * PARAMETERS:
 *    PLONG  pVersionMinor :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplication::get_VersionMinor(PLONG pVersionMinor)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::get_VersionMinor"));

    sc = ScCheckPointers(pVersionMinor);
    if(sc)
        return sc.ToHr();

    *pVersionMinor = MMC_VERSION_MINOR;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::get_Visible
//
//  Synopsis:    Returns the visible property
//
//  Arguments:   [PBOOL] - out bool
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::get_Visible (PBOOL pbVisible)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, _T("CMMCApplication::get_Visible"));

    sc = ScCheckPointers(pbVisible);
    if (sc)
        return sc.ToHr();

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    CMainFrame *pMainFrame = pApp->GetMainFrame();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    *pbVisible = pMainFrame->IsWindowVisible();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::Show
//
//  Synopsis:    Shows the application
//
//  Arguments:   None
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::Show ()
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, _T("CMMCApplication::Show"));

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    CMainFrame *pMainFrame = pApp->GetMainFrame();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    sc = pMainFrame->ShowWindow(SW_SHOW);

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::Hide
//
//  Synopsis:    Hides the application.
//
//  Arguments:   None
//
//  Returns:     HRESULT
//
//  Note:        If the user is under control (UserControl property is set)
//               then Hide fails.
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::Hide ()
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, _T("CMMCApplication::Hide"));

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    // Cant hide if app is under user control.
    if (pApp->IsUnderUserControl())
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CMainFrame *pMainFrame = pApp->GetMainFrame();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    sc = pMainFrame->ShowWindow(SW_HIDE);

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::get_UserControl
//
//  Synopsis:    Returns the UserControl property
//
//  Arguments:   PBOOL - out param.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::get_UserControl (PBOOL pbUserControl)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, _T("CMMCApplication::get_UserControl"));

    sc = ScCheckPointers(pbUserControl);
    if (sc)
        return (sc.ToHr());

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    *pbUserControl = pApp->IsUnderUserControl();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::put_UserControl
//
//  Synopsis:    Sets the UserControl property
//
//  Arguments:   BOOL
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::put_UserControl (BOOL bUserControl)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, _T("CMMCApplication::put_UserControl"));

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    pApp->SetUnderUserControl(bUserControl);

    return (sc.ToHr());
}


/***************************************************************************\
 *
 * METHOD:  CMMCApplication::ScOnDisconnectObjects
 *
 * PURPOSE: special disconnect implementation. For this object implementation
 *          provided by the base class is not enough, since connection point
 *          is an internal object which may also have strong references on it
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCApplication::ScOnDisconnectObjects()
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCApplication::ScOnDisconnectObjects"));

    // get the connection point container
    IConnectionPointContainerPtr spContainer(GetUnknown());
    sc = ScCheckPointers( spContainer, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the connection point
    IConnectionPointPtr spConnectionPoint;
    sc = spContainer->FindConnectionPoint( DIID_AppEvents, &spConnectionPoint );
    if (sc)
        return sc;

    // cut connection point references
    sc = CoDisconnectObject( spConnectionPoint, 0/*dwReserved*/ );
    if (sc)
        return sc;

    // let the base class do the rest
    sc = CMMCIDispatchImplClass::ScOnDisconnectObjects();
    if (sc)
        return sc;

    return sc;
}

//############################################################################
//############################################################################
//
// ATL GLobal Object Map
//
//############################################################################
//############################################################################

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Application, CMMCApplication)
END_OBJECT_MAP()


/*+-------------------------------------------------------------------------*
 * CLockChildWindowUpdate
 *
 * Helper class whose constructor turns off redraw for all of the children
 * of the given window, and whose destructor turns redraw back on for all
 * of the windows for which it was turned off.
 *
 * This is used to prevent ugly transient drawing while opening console
 * files that take a long time to completely open (bug 150356).
 *--------------------------------------------------------------------------*/

class CLockChildWindowUpdate
{
public:
    CLockChildWindowUpdate (CWnd* pwndLock) : m_pwndLock(pwndLock)
    {
        if (m_pwndLock != NULL)
        {
            CWnd* pwndChild;

            /*
             * turn off redraw for each child, saving the HWND for later
             * so we can turn it back on (we save the HWND instead of the
             * CWnd* because MFC might have returned a temporary object).
             */
            for (pwndChild  = m_pwndLock->GetWindow (GW_CHILD);
                 pwndChild != NULL;
                 pwndChild  = pwndChild->GetNextWindow())
            {
                pwndChild->SetRedraw (false);
                m_vChildren.push_back (pwndChild->GetSafeHwnd());
            }
        }
    }

    ~CLockChildWindowUpdate()
    {
        std::vector<HWND>::iterator it;

        /*
         * for every window for which we turned off redraw, turn it back on
         */
        for (it = m_vChildren.begin(); it != m_vChildren.end(); ++it)
        {
            HWND hWndChild = *it;

            if ( (hWndChild != NULL) && ::IsWindow(hWndChild) )
            {
                CWnd *pwndChild = CWnd::FromHandle(hWndChild);
                pwndChild->SetRedraw (true);
                pwndChild->RedrawWindow (NULL, NULL,
                                         RDW_INVALIDATE | RDW_UPDATENOW |
                                         RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
            }
        }
    }

private:
    CWnd* const         m_pwndLock;
    std::vector<HWND>   m_vChildren;
};

/*+-------------------------------------------------------------------------*
* class CCausalityCounter
* 
*
* PURPOSE: used to determine whether a function has resulted in a call back to itself on the same stack
*
* USAGE: Initialize with a variable that is set to zero.
*
* NOTE: Copied from MMCaxwin.cpp
*+-------------------------------------------------------------------------*/
class CCausalityCounter  
{
    UINT & m_bCounter;

public:
    CCausalityCounter(UINT &bCounter) : m_bCounter(bCounter){++m_bCounter;}
    ~CCausalityCounter() {--m_bCounter;}

    bool HasReentered() 
    {
        return (m_bCounter>1);
    }
};

//############################################################################
//############################################################################
//
//  Implementation of class CAMCMultiDocTemplate
//
//############################################################################
//############################################################################
class CAMCMultiDocTemplate : public CMultiDocTemplate
{
public:
    CAMCMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
                         CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass)
            : CMultiDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass)
        {
        }

    CDocument* OpenDocumentFile(LPCTSTR lpszPathName,
                                BOOL bMakeVisible)
        {
            DECLARE_SC(sc, TEXT("CAMCMultiDocTemplate::OpenDocumentFile"));

            CAMCDoc* const pDoc = CAMCDoc::GetDocument();
            if (pDoc && (!pDoc->SaveModified() || !CanCloseDoc() ))
                return NULL;        // leave the original one

            CLockChildWindowUpdate lock (AfxGetMainWnd());
            CAMCDoc* pDocument = (CAMCDoc*)CreateNewDocument();

            if (pDocument == NULL)
            {
                TRACE0("CDocTemplate::CreateNewDocument returned NULL.\n");
                AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC); // do not change to MMCMessageBox
                return NULL;
            }

            HRESULT hr;
            if ((hr = pDocument->InitNodeManager()) != S_OK)
            {
                TRACE1("CAMCDoc::InitNodeManager failed, 0x%08x\n", hr);
                CAMCApp* pApp = AMCGetApp();
                MMCErrorBox((pApp && pApp->IsWin9xPlatform())
                                    ? IDS_NODEMGR_FAILED_9x
                                    : IDS_NODEMGR_FAILED);
                delete pDocument;       // explicit delete on error
                return NULL;
            }

            ASSERT_VALID(pDocument);

            BOOL bAutoDelete = pDocument->m_bAutoDelete;
            pDocument->m_bAutoDelete = FALSE;   // don't destroy if something goes wrong
            CFrameWnd* pFrame = CreateNewFrame(pDocument, NULL);
            pDocument->m_bAutoDelete = bAutoDelete;
            if (pFrame == NULL)
            {
                AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);  // do not change to MMCMessageBox
                delete pDocument;       // explicit delete on error
                return NULL;
            }
            ASSERT_VALID(pFrame);

            if (lpszPathName == NULL)
            {
                // create a new document - with default document name
                SetDefaultTitle(pDocument);

                // avoid creating temporary compound file when starting up invisible
                if (!bMakeVisible)
                    pDocument->m_bEmbedded = TRUE;

                if (!pDocument->OnNewDocument())
                {
                    // user has be alerted to what failed in OnNewDocument
                    TRACE0("CDocument::OnNewDocument returned FALSE.\n");
                    AfxMessageBox (AFX_IDP_FAILED_TO_CREATE_DOC);  // do not change to MMCMessageBox
                    pFrame->DestroyWindow();
                    return NULL;
                }

                // it worked, now bump untitled count
                m_nUntitledCount++;

                InitialUpdateFrame(pFrame, pDocument, bMakeVisible);
            }
            else
            {
                // open an existing document
                CWaitCursor wait;
                if (!pDocument->OnOpenDocument(lpszPathName))
                {
                    // user has be alerted to what failed in OnOpenDocument
                    TRACE0("CDocument::OnOpenDocument returned FALSE.\n");
                    pFrame->DestroyWindow();
                    return NULL;
                }
#ifdef _MAC
                // if the document is dirty, we must have opened a stationery pad
                //  - don't change the pathname because we want to treat the document
                //  as untitled
                if (!pDocument->IsModified())
#endif
                    pDocument->SetPathName(lpszPathName);
                //REVIEW: dburg: InitialUpdateFrame(pFrame, pDocument, bMakeVisible);
                pFrame->DestroyWindow();
                pDocument->SetModifiedFlag      (false);
                pDocument->SetFrameModifiedFlag (false);
            }
            // fire script event
            CAMCApp* pApp = AMCGetApp();

            sc = ScCheckPointers(pApp, E_UNEXPECTED);
            if (sc)
                return pDocument;

            sc = pApp->ScOnNewDocument(pDocument, (lpszPathName != NULL));
            if (sc)
                sc.TraceAndClear();

            return pDocument;
        }
        // this method is overrided to catch application quit event
        virtual void CloseAllDocuments( BOOL bEndSession )
        {
            DECLARE_SC(sc, TEXT("CAMCMultiDocTemplate::CloseAllDocuments"));
            
            /* Bug 620422: CloseAllDocuments can end up being called again 
             * before a previous invocation has returned, e.g., when the actions
             * of closing this application and of logging out overlap.
             * MFC's handlers for these events: CFrameWnd::OnClose and 
             * CFrameWnd::OnEndSession both call CloseAllDocuments. 
             *
             * We keep track of whether a call to CloseAllDocuments is in 
             * progress by a causality counter tied to the static variable 
             * cInvocations (initialized to 0). 
             * Following invocations, if any, simply return.
             */

            static UINT cInvocations = 0;
            CCausalityCounter counter(cInvocations); 

            if (counter.HasReentered())
                return;

            // invoke base class to perform required tasks
            CMultiDocTemplate::CloseAllDocuments( bEndSession );

            // no other way we can get here but exit app
            // so that's a good time for script to know it
            CAMCApp* pApp = AMCGetApp();
            sc = ScCheckPointers(pApp, E_UNEXPECTED);
            if (sc)
                return;

            // forward to application to emit the script event
            sc = pApp->ScOnQuitApp();
            if (sc)
                sc.TraceAndClear();

            // cut off all strong references now.
            // Quit was executed - nothing else matters
            sc = GetComObjectEventSource().ScFireEvent( CComObjectObserver::ScOnDisconnectObjects );
            if (sc)
                sc.TraceAndClear();

	}
};


// Declare debug infolevel for this component
DECLARE_INFOLEVEL(AMCConUI);

//############################################################################
//############################################################################
//
//  Implementation of class CAMCApp
//
//############################################################################
//############################################################################
IMPLEMENT_DYNAMIC(CAMCApp, CWinApp)

BEGIN_MESSAGE_MAP(CAMCApp, CWinApp)
    //{{AFX_MSG_MAP(CAMCApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP

    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)

    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)

    ON_COMMAND(ID_FILE_NEW_USER_MODE, OnFileNewInUserMode) // CTRL+N in user mode - do nothing

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCApp construction

CAMCApp::CAMCApp() :
    m_bOleInitialized(FALSE),
    m_bDefaultDirSet(FALSE),
    m_eMode(eMode_Error),
    m_fAuthorModeForced(false),
    m_fInitializing(true),
    m_fDelayCloseUntilIdle(false),
    m_fCloseCameFromMainPump(false),
    m_nMessagePumpNestingLevel(0),
    m_fIsWin9xPlatform(false),
    m_dwHelpCookie(0),
    m_bHelpInitialized(false),
    m_fUnderUserControl(true),
    m_fRunningAsOLEServer(false)
{
}


/////////////////////////////////////////////////////////////////////////////
// The one and only CAMCApp object

CAMCApp theApp;
const CRect g_rectEmpty (0, 0, 0, 0);

void DeleteDDEKeys()
{
    HKEY key;

    if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_CLASSES_ROOT,
                                       _T("MSCFile\\shell\\open"),
                                       0, KEY_SET_VALUE, &key))
    {
        theApp.DelRegTree (key, _T("ddeexec"));
        RegCloseKey (key);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::GetMainFrame
 *
 * PURPOSE: Returns a pointer to the main frame.
 *
 * RETURNS:
 *    CMainFrame *
 *
 *+-------------------------------------------------------------------------*/
CMainFrame *
CAMCApp::GetMainFrame()
{
    return dynamic_cast<CMainFrame *>(m_pMainWnd);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScGet_Application
 *
 * PURPOSE: Returns a pointer to an _Application object.
 *
 * PARAMETERS:
 *    _Application ** pp_Application :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScGet_Application(_Application **pp_Application)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScGet_Application"));

    // parameter check
    sc = ScCheckPointers(pp_Application);
    if (sc)
        return sc;

    // init out param
    *pp_Application = NULL;

    // see if we have a chached one
    if (m_sp_Application != NULL)
    {
        *pp_Application = m_sp_Application;
        (*pp_Application)->AddRef(); // addref for the client.

        return sc;
    }

    // create an _Application object. This is needed if MMC was instantiated
    // by a user, not COM.

    sc = CMMCApplication::CreateInstance(pp_Application);
    if(sc)
        return sc;

    // The constructor of the CMMCApplication calls ScRegister_Application
    // which sets the m_sp_Application pointer. Do not set this pointer here.

    sc = ScCheckPointers(*pp_Application, E_UNEXPECTED);
    if (sc)
        return sc;

    // done
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScRegister_Application
 *
 * PURPOSE: called by a CMMCApplication object to enable the CAMCApp to store
 *          a pointer to it.
 *
 * PARAMETERS:
 *    _Application * p_Application :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScRegister_Application(_Application *p_Application)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScRegister_Application"));

    ASSERT(m_sp_Application == NULL); // only one _Application object should ever register.

    sc = ScCheckPointers(p_Application);
    if(sc)
        return sc;

    m_sp_Application = p_Application;
    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     RegisterShellFileTypes
//
//  Synopsis:   Register the file associations.
//
//  Note:       Also set all other relevant registry keys like
//              Open, Author, RunAs. Eventhough the setup has
//              done this it may have been deleted mistakenly.
//
//  History:
//              [AnandhaG] - Added the registry repair.
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::RegisterShellFileTypes(BOOL bCompat)
{
    CWinApp::RegisterShellFileTypes (bCompat);
    DECLARE_SC(sc, _T("CAMCApp::RegisterShellFileTypes"));

    do
    {
        // Create the top level MSCFile key.
        CRegKey regKey;
        LONG lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile"), REG_NONE,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        /*
         * for platforms that support it (i.e. not Win9x), set the MUI-friendly
         * value for the MSCFile document type
         */
        if (!IsWin9xPlatform())
        {
            CString strMUIValue;
            strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDR_MUIFRIENDLYNAME);
            lRet = RegSetValueEx (regKey, _T("FriendlyTypeName"), NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)(LPCTSTR) strMUIValue,
                                  sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;
        }

        // Set the EditFlags value.
        lRet = regKey.SetValue(0x100000, _T("EditFlags"));
        if (ERROR_SUCCESS != lRet)
            break;

        // Create the Author verb.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Author"), REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        // And set default value for author (this reflects in shell menu).
        CString strRegVal;
        LoadString(strRegVal, IDS_MENUAUTHOR);
        lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                              (CONST BYTE *)(LPCTSTR)strRegVal, sizeof(TCHAR) * (strRegVal.GetLength()+1) );
        if (ERROR_SUCCESS != lRet)
            break;

        /*
         * for platforms that support it (i.e. not Win9x), set the MUI-friendly
         * value for the menu item
         */
        if (!IsWin9xPlatform())
        {
            CString strMUIValue;
            strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDS_MENUAUTHOR);
            lRet = RegSetValueEx (regKey, _T("MUIVerb"), NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)(LPCTSTR) strMUIValue,
                                  sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;
        }

        // Create the Author command.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Author\\command"), REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        //////////////////////////////////////////////////////////////
        // Win95 does not support REG_EXPAND_SZ for default values. //
        // So we set expand strings and set registry strings as     //
        // REG_SZ for Win9x.                                        //
        // The following declarations are for Win9x platform.       //
        //////////////////////////////////////////////////////////////
        TCHAR szRegValue[2 * MAX_PATH];
        int cchRegValue = 2 * MAX_PATH;

        TCHAR szWinDir[MAX_PATH];
        if (0 == ExpandEnvironmentStrings(_T("%WinDir%"), szWinDir, countof(szWinDir)) )
            break;

        DWORD dwCount = 0;
        LPTSTR lpszRegValue = NULL;

        // Set the default value for Author command.
        if (IsWin9xPlatform() == false)
        {
            lpszRegValue = _T("%SystemRoot%\\system32\\mmc.exe /a \"%1\" %*");
            dwCount = sizeof(TCHAR) * (1 + _tcslen(lpszRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)lpszRegValue, dwCount);
        }
        else // Win9x platform
        {
            lpszRegValue = _T("\\mmc.exe /a \"%1\" %2 %3 %4 %5 %6 %7 %8 %9");
            sc = StringCchCopy(szRegValue, cchRegValue, szWinDir);
            if (sc)
                return;

            sc = StringCchCat(szRegValue, cchRegValue, lpszRegValue);
            if (sc)
                return;

            dwCount = sizeof(TCHAR) * (1 + _tcslen(szRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                                  (CONST BYTE *)szRegValue, dwCount);
        }

        if (ERROR_SUCCESS != lRet)
            break;

        // Create the Open verb.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Open"),  REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        // Set default value for Open.
        LoadString(strRegVal, IDS_MENUOPEN);
        lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                              (CONST BYTE *)(LPCTSTR)strRegVal,sizeof(TCHAR) * (strRegVal.GetLength()+1) );
        if (ERROR_SUCCESS != lRet)
            break;

        /*
         * for platforms that support it (i.e. not Win9x), set the MUI-friendly
         * value for the menu item
         */
        if (!IsWin9xPlatform())
        {
            CString strMUIValue;
            strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDS_MENUOPEN);
            lRet = RegSetValueEx (regKey, _T("MUIVerb"), NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)(LPCTSTR) strMUIValue,
                                  sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;
        }

        // Create the Open command.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Open\\command"),  REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        // Set the default value for Open command.
        if (IsWin9xPlatform() == false)
        {
            lpszRegValue = _T("%SystemRoot%\\system32\\mmc.exe \"%1\" %*");
            dwCount = sizeof(TCHAR) * (1 + _tcslen(lpszRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)lpszRegValue, dwCount);
        }
        else // Win9x platform
        {
            lpszRegValue = _T("\\mmc.exe \"%1\" %2 %3 %4 %5 %6 %7 %8 %9");

            sc = StringCchCopy(szRegValue, cchRegValue, szWinDir);
            if (sc)
                return;

            sc = StringCchCat(szRegValue, cchRegValue, lpszRegValue);
            if (sc)
                return;

            dwCount = sizeof(TCHAR) * (1 + _tcslen(szRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                                  (CONST BYTE *)szRegValue, dwCount);
        }

        if (ERROR_SUCCESS != lRet)
            break;

        // Create the RunAs verb (only on NT).
        if (IsWin9xPlatform() == false)
        {
            lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\RunAs"),  REG_NONE,
                                 REG_OPTION_NON_VOLATILE, KEY_WRITE);
            if (ERROR_SUCCESS != lRet)
                break;

            // Set default value for RunAs verb.
            LoadString(strRegVal, IDS_MENURUNAS);
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                                  (CONST BYTE *)(LPCTSTR)strRegVal,sizeof(TCHAR) * (strRegVal.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;

            /*
             * for platforms that support it (i.e. not Win9x), set the MUI-friendly
             * value for the menu item
             */
            if (!IsWin9xPlatform())
            {
                CString strMUIValue;
                strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDS_MENURUNAS);
                lRet = RegSetValueEx (regKey, _T("MUIVerb"), NULL, REG_EXPAND_SZ,
                                      (CONST BYTE *)(LPCTSTR) strMUIValue,
                                      sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
                if (ERROR_SUCCESS != lRet)
                    break;
            }

            // Create the RunAs command.
            lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\RunAs\\command"),  REG_NONE,
                                 REG_OPTION_NON_VOLATILE, KEY_WRITE);
            if (ERROR_SUCCESS != lRet)
                break;

            // Set the default value for RunAs command. (Only on NT Unicode)
            lpszRegValue = _T("%SystemRoot%\\system32\\mmc.exe \"%1\" %*");
            dwCount = sizeof(TCHAR) * (1 + _tcslen(lpszRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)lpszRegValue, dwCount);
        }

        if (ERROR_SUCCESS != lRet)
            break;

    } while ( FALSE );

    return;
}


/////////////////////////////////////////////////////////////////////////////
// CAMCApp initialization

#ifdef UNICODE
SC ScLaunchMMC (eArchitecture eArch, int nCmdShow);
#endif

#ifdef MMC_WIN64
    class CMMCCommandLineInfo;

    SC ScDetermineArchitecture (const CMMCCommandLineInfo& rCmdInfo, eArchitecture& eArch);
#else
    bool IsWin64();
#endif  // MMC_WIN64


class CMMCCommandLineInfo : public CCommandLineInfo
{
public:
	eArchitecture	m_eArch;
    bool    		m_fForceAuthorMode;
    bool    		m_fRegisterServer;
    CString 		m_strDumpFilename;

public:
    CMMCCommandLineInfo() :
		m_eArch (eArch_Any),
		m_fForceAuthorMode(false),
        m_fRegisterServer(false)
    {}

    virtual void ParseParam (LPCTSTR pszParam, BOOL bFlag, BOOL bLast)
    {
        DECLARE_SC(sc, _T("ParseParam"));

        bool fHandledHere = false;

        if (bFlag)
        {
            sc = ScCheckPointers(pszParam);
            if (sc)
                return;

            /*
             * ignore the following parameters:
             * -dde (await DDE command), -s (splash screen, obsolete).
             */
            if ((lstrcmpi (pszParam, _T("s"))   == 0) ||
                (lstrcmpi (pszParam, _T("dde")) == 0))
            {
                fHandledHere = true;
            }

            // force author mode
            else if (lstrcmpi (pszParam, _T("a")) == 0)
            {
                m_fForceAuthorMode = true;
                fHandledHere = true;
            }

            // register the server only
            else if (lstrcmpi (pszParam, _T("RegServer")) == 0)
            {
                m_fRegisterServer = true;
                fHandledHere = true;
            }

            // force 64-bit MMC to run
            else if (lstrcmp (pszParam, _T("64")) == 0)
            {
                m_eArch = eArch_64bit;
                fHandledHere = true;
            }

            // force 32-bit MMC to run
            else if (lstrcmp (pszParam, _T("32")) == 0)
            {
                m_eArch = eArch_32bit;
                fHandledHere = true;
            }

            else
            {
                static const TCHAR  szDumpParam[] = _T("dump:");
                const int           cchDumpParam  = 1000;
                TCHAR               szParam[cchDumpParam];

                sc = StringCchCopy(szParam, cchDumpParam, pszParam);
                if(sc)
                    sc.TraceAndClear();// suppress errors here. Truncation is OK. StringCchCopy will always add a NULL terminator
                

                // dump console file contents
                if (lstrcmpi (szParam, szDumpParam) == 0)
                {
                    m_strDumpFilename = pszParam + cchDumpParam - 1;
                    fHandledHere = true;
                }
            }
        }

        // if not handled, pass it on to base class
        // if just handled last parameter, call base class ParseLast
        // so it can do the final processing
        if (!fHandledHere)
            CCommandLineInfo::ParseParam (pszParam, bFlag, bLast);
        else if (bLast)
            CCommandLineInfo::ParseLast(bLast);

    }

}; // class CMMCCommandLineInfo



/*+-------------------------------------------------------------------------*
 * CWow64FilesystemRedirectionDisabler
 *
 * Disables Wow64 file system redirection for the file represented in the
 * given CMMCCommandLineInfo.  We do this so MMC32 can open consoles in
 * %windir%\system32 without having the path redirected to %windir%\syswow64.
 *--------------------------------------------------------------------------*/

class CWow64FilesystemRedirectionDisabler
{
public:
    CWow64FilesystemRedirectionDisabler (LPCTSTR pszFilename)
    {
#ifndef MMC_WIN64
		m_fDisabled = ((pszFilename != NULL) && IsWin64());

        if (m_fDisabled)
        {
            Trace (tag32BitTransfer, _T("Disabling Wow64 file system redirection for %s"), pszFilename);
            Wow64DisableFilesystemRedirector (pszFilename);
        }
#endif  // !MMC_WIN64
    }

    ~CWow64FilesystemRedirectionDisabler ()
    {
#ifndef MMC_WIN64
        if (m_fDisabled)
        {
            Trace (tag32BitTransfer, _T("Enabling Wow64 file system redirection"));
            Wow64EnableFilesystemRedirector();
        }
#endif  // !MMC_WIN64
    }

private:
#ifndef MMC_WIN64
    bool    m_fDisabled;
#endif  // !MMC_WIN64
};



/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScProcessAuthorModeRestrictions
 *
 * PURPOSE: Determines whether author mode restrictions are being enforced
 *          by system policy, and if author mode is not allowed,
 *          displays an error box and exits.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScProcessAuthorModeRestrictions()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScProcessAuthorModeRestrictions"));
    CRegKey regKey;

    // The mode is initialized to "author", if it is not in
    // initialized state just return.
    if (eMode_Author != m_eMode)
        return sc;

    // The console file mode is already read.
    // Check if user policy permits author mode.
    long lResult = regKey.Open(HKEY_CURRENT_USER, POLICY_KEY, KEY_READ);
    if (lResult != ERROR_SUCCESS)
        return sc;

    // get the value of RestrictAuthorMode.
    DWORD dwRestrictAuthorMode = 0;
    lResult = regKey.QueryValue(dwRestrictAuthorMode, g_szRestrictAuthorMode);
    if (lResult != ERROR_SUCCESS)
        return sc;

    if (dwRestrictAuthorMode == 0)    // Author mode is not restricted so return.
        return sc;

    /*
     * If called from script (running as embedded server) see if policy
     * restricts scripts from entering into author mode.
     *
     * If restricted then script will fail, thus restricting rogue scripts.
     *
     * Even if not restricted here cannot add snapins that are restricted.
     */
    if (IsMMCRunningAsOLEServer())
    {
        DWORD dwRestrictScriptsFromEnteringAuthorMode = 0;
        lResult = regKey.QueryValue(dwRestrictScriptsFromEnteringAuthorMode, g_szRestrictScriptsFromEnteringAuthorMode);
        if (lResult != ERROR_SUCCESS)
            return sc;

        if (dwRestrictScriptsFromEnteringAuthorMode == 0)  // Scripts can enter author mode so return
            return sc;

        sc = ScFromMMC(IDS_AUTHORMODE_NOTALLOWED_FORSCRIPTS);
    }
    else
        // If author mode is not allowed and
        // the user tried to force author mode
        // then display error message and exit.
        sc = ScFromMMC(IDS_AUTHORMODE_NOTALLOWED);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScCheckMMCPrerequisites
 *
 * PURPOSE: Checks all prerequisites. These are: (add to the list as appropriate)
 *          1) Internet Explorer 5.5 or greater must be installed
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScCheckMMCPrerequisites()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScCheckMMCPrerequisites"));

    // 1. Determine the installed version of Internet Explorer.
    const int cchDATA = 100;
    TCHAR szVersion[cchDATA];
    BOOL bIE55Found    = false;
    HKEY hkey          = NULL;
    DWORD dwType       =0;
    DWORD dwMajor      =0;
    DWORD dwMinor      =0;
    DWORD dwRevision   =0;
    DWORD dwBuild      =0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"), 0, KEY_READ, &hkey))
    {
        DWORD cbData = sizeof(TCHAR) * cchDATA;

        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("Version"), 0, &dwType, (LPBYTE)szVersion, &cbData))
        {
            if (lstrlen(szVersion) > 0)
            {
                if (_stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild) >= 2)
                {
                    //Make sure IE 5.5 or greater is installed. To do this:
                    // 1) Check if the major version is >= 6. If so we're done.
                    // 2) If the major version is 5, the minor version should be >= 50
                    if (dwMajor >= 6)
                    {
                        bIE55Found = true;
                    }
                    if (dwMajor == 5)
                    {
                        if(dwMinor >= 50)
                            bIE55Found = true;
                    }
                }
            }
        }

        RegCloseKey(hkey);

    }
    if (!bIE55Found)
    {
        sc = ScFromMMC(MMC_E_INCORRECT_IE_VERSION); // NOTE: update the string when the version requirement changes
        return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::InitInstance
 *
 * PURPOSE: Initializes the document.
 *
 * NOTE: as an aside, if you need to break on, say,  the 269th allocation,
 *       add the following code:
 *
 *      #define ALLOCATION_NUM  269
 *      _CrtSetBreakAlloc(ALLOCATION_NUM);
 *      _crtBreakAlloc = ALLOCATION_NUM;
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL CAMCApp::InitInstance()
{
    DECLARE_SC(sc, TEXT("CAMCApp::InitInstance"));

	/*
	 * Initialize Fusion.
	 */
    //RAID 656865: Prefix: return value from SHFusionInitializeFromModuleID ignored
	if (!SHFusionInitializeFromModuleID (NULL, static_cast<int>(reinterpret_cast<ULONG_PTR>(SXS_MANIFEST_RESOURCE_ID))))
    {
        sc = E_UNEXPECTED;
        return FALSE;
    }
   
#ifdef DBG
    if (tagForceMirror.FAny())
    {
        HINSTANCE hmodUser = GetModuleHandle (_T("user32.dll"));

        if (hmodUser != NULL)
        {
            BOOL (WINAPI* pfnSetProcessDefaultLayout)(DWORD);
            (FARPROC&)pfnSetProcessDefaultLayout = GetProcAddress (hmodUser, "SetProcessDefaultLayout");

            if (pfnSetProcessDefaultLayout != NULL)
                (*pfnSetProcessDefaultLayout)(LAYOUT_RTL);
        }
    }
#endif

    BOOL bRet = TRUE;

    // Initialize OLE libraries
    if (InitializeOLE() == FALSE)
        return FALSE;


    // Initialize the ATL Module
    _Module.Init(ObjectMap,m_hInstance);

#ifdef DBG
    if(tagGDIBatching.FAny())
    {
        // disable GDI batching so we'll see drawing as it happens
        GdiSetBatchLimit (1);
    }
#endif

    Unregister();

    Trace(tagAMCAppInit, TEXT("CAMCApp::InitInstance"));

    CMMCCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    /*
     * if we got a file on the command line, expand environment
     * variables in the filename so we can open files like
     * "%SystemRoot%\system32\compmgmt.msc"
     */
    if (!cmdInfo.m_strFileName.IsEmpty())
    {
        CWow64FilesystemRedirectionDisabler disabler (cmdInfo.m_strFileName);

        sc = ScExpandEnvironmentStrings (cmdInfo.m_strFileName);
        if (sc)
        {
            MMCErrorBox (sc);
            return (false);
        }
    }

    // Don't use an .ini file for the MRU or Settings
    // Note: This string does not need to be localizable.
    // HKEY_CURRENT_USER\\Software\\Microsoft\\Microsoft Management Console
    SetRegistryKey(_T("Microsoft"));

    // Find out OS version.
    OSVERSIONINFO versInfo;
    versInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bStat = GetVersionEx(&versInfo);
    ASSERT(bStat);
    m_fIsWin9xPlatform = (versInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    // default to Author mode (loading a console may change this later)
    InitializeMode (eMode_Author);

    m_fAuthorModeForced = cmdInfo.m_fForceAuthorMode      ||
                          cmdInfo.m_strFileName.IsEmpty();


    /*
     * dump the snap-ins (and do nothing else) if we got "-dump:<filename>"
     */
    if (!cmdInfo.m_strDumpFilename.IsEmpty())
    {
        DumpConsoleFile (cmdInfo.m_strFileName, cmdInfo.m_strDumpFilename);
        return (false);
    }

#ifdef MMC_WIN64
    /*
     * We're currently running the MMC64.  See if we need to defer to MMC32.
     * If we do, try to launch MMC32.  If we were able to launch MMC32
     * successfully, abort MMC64.
     */
    eArchitecture eArch = eArch_64bit;
    sc = ScDetermineArchitecture (cmdInfo, eArch);
    if (sc)
    {
        DisplayFileOpenError (sc, cmdInfo.m_strFileName);
        return (false);
    }

    switch (eArch)
    {
        /*
         * MMC64 is fine, do nothing
         */
        case eArch_64bit:
            break;

        /*
         * User cancelled action, abort
         */
        case eArch_None:
            return (false);
            break;

        /*
         * We need MMC32, so try to launch it.  If we were able to launch MMC32
         * successfully, abort MMC64; if not, continue running MMC64.
         */
        case eArch_32bit:
            if (!ScLaunchMMC(eArch_32bit, m_nCmdShow).IsError())
            {
                Trace (tag32BitTransfer, _T("32-bit MMC launched successfully"));
                return (false);
            }

            Trace (tag32BitTransfer, _T("32-bit MMC failed to launch"));
            MMCErrorBox (MMC_E_UnableToLaunchMMC32);
            break;

        default:
            ASSERT (false && "Unexpected architecture returned from ScDetermineArchitecture");
            break;
    }
#elif defined(UNICODE)
    /*
     * We're currently running the MMC32.  If it's running on IA64 and 32-bit
     * wasn't specifically requested with a "-32" switch (this is what MMC64
     * will do when it defers to MMC32), defer to MMC64 so it can do snap-in
     * analysis and determine the appropriate "bitness" to run.
     */
    if ((cmdInfo.m_eArch != eArch_32bit) && IsWin64())
    {
        /*
         * We need MMC64, so try to launch it.  If we were able to launch MMC64
         * successfully, abort MMC32; if not, continue running MMC32.
         */
        if (!ScLaunchMMC(eArch_64bit, m_nCmdShow).IsError())
        {
            Trace (tag32BitTransfer, _T("64-bit MMC launched successfully"));
            return (false);
        }

        Trace (tag32BitTransfer, _T("64-bit MMC failed to launch"));
        MMCErrorBox (MMC_E_UnableToLaunchMMC64);
    }
#endif // MMC_WIN64

    AfxEnableControlContainer();

    // Standard initialization

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // create our own CDocManager derivative before adding any templates
    // (CWinApp::~CWinApp will delete it)
    m_pDocManager = new CAMCDocManager;

    // Register document templates
    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CAMCMultiDocTemplate(
        IDR_AMCTYPE,
        RUNTIME_CLASS(CAMCDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CAMCView));
    AddDocTemplate(pDocTemplate);

    // Note: MDI applications register all server objects without regard
    //  to the /Embedding or /Automation on the command line.

    if (cmdInfo.m_fRegisterServer)
    {
        sc = _Module.RegisterServer(TRUE);// ATL Classes

        if (sc == TYPE_E_REGISTRYACCESS)
            sc.TraceAndClear();
    }

    if (sc)
    {
        MMCErrorBox (sc);
        return (false);
    }


    // create main MDI Frame window
    CMainFrame *pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // set the HWND to use as the parent for modal error dialogs.
    SC::SetHWnd(pMainFrame->GetSafeHwnd());

    // save this main thread's ID to check if snapins call MMC
    // interfaces from main thread.
    SC::SetMainThreadID(::GetCurrentThreadId());

    m_fRunningAsOLEServer = false;

    // Check to see if launched as OLE server
    if (RunEmbedded() || RunAutomated())
    {
        m_fRunningAsOLEServer = true;
        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        //return TRUE;

        // Also set that script is controlling the application not the user
        // The script can modify the UserControl property on the application.
        SetUnderUserControl(false);

        // When a server application is launched stand-alone, it is a good idea to register all objects
        // ATL ones specifically register with REGCLS_MULTIPLEUSE
        // we register class objects only when run as an OLE server. This way, cannot connect to
        // an existing instance of MMC.
        sc = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE);
        if(sc)
            goto Error;
    }

    if (cmdInfo.m_fRegisterServer)
    {
        CString strTypeLib;
        strTypeLib.Format(TEXT("\\%d"), IDR_WEBSINK_TYPELIB); // this should evaluate to something like "\\4"

        sc = _Module.RegisterTypeLib((LPCTSTR)strTypeLib);

        if (sc == TYPE_E_REGISTRYACCESS)
            sc.TraceAndClear();

        if(sc)
            goto Error;
    }

    // Don't Enable drag/drop open
    // m_pMainWnd->DragAcceptFiles();

    // Enable DDE Execute open
    if (cmdInfo.m_fRegisterServer)
        RegisterShellFileTypes(FALSE);
    EnableShellOpen();
    if (cmdInfo.m_fRegisterServer)
        DeleteDDEKeys();

    /*
     * At this point, all of our registration is complete.  If we were invoked
     * with -RegServer, we can bail now.
     */
    if (cmdInfo.m_fRegisterServer)
        return (false);


    {   // limit scope of disabler
        CWow64FilesystemRedirectionDisabler disabler (cmdInfo.m_strFileName);

        // Dispatch commands specified on the command line.
        // This loads a console file if necessary.
        if (!ProcessShellCommand(cmdInfo))
            return (false); // user is already informed about errors
    }

    // Now the console file is loaded. Check if Author mode
    // is permitted.
    sc = ScProcessAuthorModeRestrictions(); // check if there are any restrictions set by policy
    if(sc)
        goto Error;

    // if proccessing the command line put MMC into author mode,
    // it has to stick with it forever.
    // see bug 102465 openning an author mode console file and then
    //                a user mode console switched MMC into user mode
    if (eMode_Author == m_eMode)
        m_fAuthorModeForced = true;

    // create a document automatically only if we're not instantiated as an
    // OLE server.
    if(! IsMMCRunningAsOLEServer ())
    {
        // if we don't have a document now (maybe because
        // the Node Manager wasn't registered), punt
        CAMCDoc* pDoc = CAMCDoc::GetDocument ();
        if (pDoc == NULL)
            return (FALSE);

        pDoc->SetFrameModifiedFlag (false);
        pDoc->UpdateFrameCounts ();

        CMainFrame *pMainFrame = GetMainFrame();
        if (pMainFrame)
        {
            pMainFrame->ShowWindow(m_nCmdShow);
            pMainFrame->UpdateWindow();
        }

        // showing will set the frame and "Modified" - reset it
        pDoc->SetFrameModifiedFlag (false);
    }

    // register itself as dispatcher able to dispatch com events
    sc = CConsoleEventDispatcherProvider::ScSetConsoleEventDispatcher( this );
    if (sc)
        goto Error;

    m_fInitializing = false;

    // check for all MMC prerequisites
    sc = ScCheckMMCPrerequisites();
    if (sc)
        goto Error;


// Comment out below line when script engines hosted in mmc are enabled.
//    sc = ScRunTestScript();

Cleanup:
    return bRet;

Error:
    MMCErrorBox(sc);
    bRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:      ScRunTestScript
//
//  Synopsis:    Test program to run a script. Once script input mechanisms
//               are defined this can be removed.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCApp::ScRunTestScript ()
{
    DECLARE_SC(sc, _T("CAMCApp::ScRunTestScript"));

    // The Running of scripts is enabled only in debug mode.
    bool bEnableScriptEngines = false;

#ifdef DBG
    if (tagEnableScriptEngines.FAny())
        bEnableScriptEngines = true;
#endif

    if (!bEnableScriptEngines)
        return sc;

    // Get the IDispatch from MMC object, the script engine needs
    // the IUnknown to top level object & the ITypeInfo ptr.
    CComPtr<_Application> spApplication;
    sc = ScGet_Application(&spApplication);
    if (sc)
        return sc;

    IDispatchPtr spDispatch = NULL;
    sc = spApplication->QueryInterface(IID_IDispatch, (LPVOID*)&spDispatch);
    if (sc)
        return sc;

    // The CScriptHostMgr should be instead created on the stack (as we have only
    // one per app) and destroyed with app. This change can be made once we decide
    // how & when the script host will be used to execute the scripts.
    CScriptHostMgr* pMgr = new CScriptHostMgr(spDispatch);
    if (NULL == pMgr)
        return (sc = E_OUTOFMEMORY);

    LPOLESTR pszScript = L"set WShShell=CreateObject(\"WScript.Shell\")\n\
                            WshShell.Popup(\"Anand\")\n\
                            Select Case WshShell.Popup(\"Anand\",5,\"Ganesan\", vbyesnocancel)\n\
                            End Select";

    tstring strExtn = _T(".vbs");
    sc = pMgr->ScExecuteScript(pszScript, strExtn);

    tstring strFile = _T("E:\\newnt\\admin\\mmcdev\\test\\script\\MMCStartupScript.vbs");

    sc = pMgr->ScExecuteScript(strFile);

    delete pMgr;

    return (sc);
}

// App command to run the dialog
void CAMCApp::OnAppAbout()
{
    /*
     * load the title of the about dialog
     */
    CString strTitle (MAKEINTRESOURCE (IDS_APP_NAME));

    CString strVersion (MAKEINTRESOURCE (IDS_APP_VERSION));
    strTitle += _T(" ");
    strTitle += strVersion;

    ShellAbout(*AfxGetMainWnd(), strTitle, NULL, LoadIcon(IDR_MAINFRAME));
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::OnFileNewInUserMode
 *
 * PURPOSE: Do nothing in user mode when CTRL+N is pressed.
 *          This handler prevents the hotkey from going to any WebBrowser controls
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCApp::OnFileNewInUserMode()
{
    MessageBeep(-1);
}


//+-------------------------------------------------------------------
//
//  Member:     ScShowHtmlHelp
//
//  Synopsis:   Initialize and then call Help control to display help topic.
//
//  Arguments:  [pszFile]    - File to display.
//              [dwData]     - Depends on uCommand for HH_DISPLAY_TOPIC it
//                             is help topic string.
//
//  Note:       The command is always HH_DISPLAY_TOPIC. HWND is NULL so that
//              Help can get behind MMC window.
//              See ScUnintializeHelpControl's Note for more info.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCApp::ScShowHtmlHelp(LPCTSTR pszFile, DWORD_PTR dwData)
{
    DECLARE_SC(sc, _T("CAMCApp::ScInitializeHelpControl"));

    /*
     * displaying HtmlHelp might take awhile, so show a wait cursor
     */
    CWaitCursor wait;

    if (! m_bHelpInitialized)
        HtmlHelp (NULL, NULL, HH_INITIALIZE, (DWORD_PTR)&m_dwHelpCookie);

    // No documented return value for HH_INITIALIZE so always assume
    // Initialize is successful.
    m_bHelpInitialized = true;

    HtmlHelp (NULL, pszFile, HH_DISPLAY_TOPIC, dwData);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScUninitializeHelpControl
//
//  Synopsis:   UnInitialize the help if it was initialized by MMC.
//
//  Note:       The help-control calls OleInitialize & OleUninitialize
//              in its DllMain. If a snapin creates any free threaded object
//              on main thread (STA), the OLE creates an MTA.
//              The last OleUninitialize does OLEProcessUninitialize in which
//              then OLE waits for the above MTA to cleanup and return.
//              By the time help-control does last OleUninitialize in its
//              DllMain the MTA is already terminated so OLE waits for this
//              MTA to signal which it never would.
//              We call HtmlHelp(.. HH_UNINITIALIZE..) to force help control
//              to uninit so that MMC does last OleUninit.
//              (This will not solve the problem of snapins calling help directly).
//
//  Arguments:
//
//  Returns:     SC, S_FALSE if already uninitialized else S_OK.
//
//--------------------------------------------------------------------
SC CAMCApp::ScUninitializeHelpControl()
{
    DECLARE_SC(sc, _T("CAMCApp::ScUninitializeHelpControl"));

    if (false == m_bHelpInitialized)
        return (sc = S_FALSE);

    HtmlHelp (NULL, NULL, HH_UNINITIALIZE, m_dwHelpCookie);
    m_bHelpInitialized = false;
    m_dwHelpCookie     = 0;

    return sc;
}


BOOL CAMCApp::InitializeOLE()
{
    if (FAILED(::OleInitialize(NULL)))
        return FALSE;

    return (m_bOleInitialized = TRUE);
}

void CAMCApp::DeinitializeOLE()
{
    // Uninit help, see ScUninitializeHelpControl note.
    SC sc = ScUninitializeHelpControl();
    if (sc)
    {
        TraceError(_T("Uninit Help control failed"), sc);
    }

    // Forced DllCanUnloadNow before mmc exits.
    ::CoFreeUnusedLibraries();

    if (m_bOleInitialized == TRUE)
    {
        ::OleUninitialize();
        m_bOleInitialized = FALSE;
    }
}


/////////////////////////////////////////////////////////////////////////////
// CAMCApp diagnostics

#ifdef _DEBUG
void CAMCApp::AssertValid() const
{
    CWinApp::AssertValid();
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAMCApp commands

int CAMCApp::ExitInstance()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ExitInstance"));

    // if the main window is not destroyed yet - do that now.
    // since we need to get rid of all the objects before denitializing OLE.
    // It is not requred in most cases, since usually quit starts from closing the mainframe,
    // but in cases like system shut down it will come here with a valid window
    // See WindowsBug(ntbug9) #178858
    if ( ::IsWindow( AfxGetMainWnd()->GetSafeHwnd() ) )
    {
        AfxGetMainWnd()->DestroyWindow();
    }

    // disconnect the pointers to event dispatcher
    sc = CConsoleEventDispatcherProvider::ScSetConsoleEventDispatcher( NULL );
    if (sc)
        sc.TraceAndClear();

    // release cached application object
    m_sp_Application = NULL;

    // MFC's class factories registration is automatically revoked by MFC itself
    if (RunEmbedded() || RunAutomated())
	    _Module.RevokeClassObjects(); // Revoke class factories for ATL

    _Module.Term();               // clanup ATL GLobal Module

    // Ask node manager to cleanup what's got cached
    CComPtr<IComCacheCleanup> spComCacheCleanup;
    HRESULT hr = spComCacheCleanup.CoCreateInstance(CLSID_ComCacheCleanup, NULL, MMC_CLSCTX_INPROC);
    if (hr == S_OK)
    {
        spComCacheCleanup->ReleaseCachedOleObjects();
        spComCacheCleanup.Release();
    }

    // by now EVERY reference should be released
    ASSERT(_Module.GetLockCount() == 0 && "Outstanding references still exist on exit");

    DeinitializeOLE();

	/*
	 * uninitialize Fusion
	 */
	SHFusionUninitialize();

    int iRet = CWinApp::ExitInstance();

    DEBUG_VERIFY_INSTANCE_COUNT(CAMCTreeView);
    DEBUG_VERIFY_INSTANCE_COUNT(CAMCListView);
    DEBUG_VERIFY_INSTANCE_COUNT(CCCListViewCtrl);

    return iRet;
}


BOOL CAMCApp::PreTranslateMessage(MSG* pMsg)
{
	// Give HTML help a chance to crack the message. (Bug# 119355 & 206909).
	if ( m_bHelpInitialized && HtmlHelp(NULL, NULL, HH_PRETRANSLATEMESSAGE, (DWORD_PTR)pMsg) )
		return TRUE;

    // let all of the hook windows have a crack at this message
    WindowListIterator it = m_TranslateMessageHookWindows.begin();

    while (it != m_TranslateMessageHookWindows.end())
    {
        HWND  hwndHook = *it;
        CWnd* pwndHook = CWnd::FromHandlePermanent (hwndHook);

        // if this window is no longer valid, or it's not a permanent
        // window, remove it from the list
        if (!IsWindow (hwndHook) || (pwndHook == NULL))
            it = m_TranslateMessageHookWindows.erase (it);

        else
        {
            // otherwise if the hook window handled the message, bail
            if (pwndHook->PreTranslateMessage (pMsg))
                return (TRUE);

            ++it;
        }
    }

    // give the MMC defined main window accelerators a crack at the message
    if (m_Accel.TranslateAccelerator (AfxGetMainWnd()->GetSafeHwnd(), pMsg))
        return TRUE;

    return CWinApp::PreTranslateMessage(pMsg);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::SaveUserDirectory
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCApp::SaveUserDirectory(LPCTSTR pszUserDir)
{
    // if we got an empty string, change the pointer to NULL so
    // the entry will be removed from the registry
    if ((pszUserDir != NULL) && (lstrlen(pszUserDir) == 0))
        pszUserDir = NULL;

    WriteProfileString (m_szSettingsSection, m_szUserDirectoryEntry,
                        pszUserDir);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::GetUserDirectory
 *
 *
 *--------------------------------------------------------------------------*/

CString CAMCApp::GetUserDirectory(void)
{
    return (GetProfileString (m_szSettingsSection, m_szUserDirectoryEntry));
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::GetDefaultDirectory
 *
 *
 *--------------------------------------------------------------------------*/

CString CAMCApp::GetDefaultDirectory(void)
{
    static CString strDefaultDir;

    if (strDefaultDir.IsEmpty())
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHGetSpecialFolderLocation(
                                AfxGetMainWnd()->GetSafeHwnd(),
                                CSIDL_ADMINTOOLS | CSIDL_FLAG_CREATE, &pidl)))
        {
            // Convert to path name
            SHGetPathFromIDList (pidl, strDefaultDir.GetBuffer (MAX_PATH));
            strDefaultDir.ReleaseBuffer ();

            // Free IDList
            LPMALLOC pMalloc;

            if (SUCCEEDED(SHGetMalloc (&pMalloc)))
            {
                pMalloc->Free(pidl);
                pMalloc->Release();
            }
        }
    }

    return (strDefaultDir);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::SetDefaultDirectory
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCApp::SetDefaultDirectory(void)
{
    // Only set default first time, so we don't override user selection
    if (m_bDefaultDirSet)
        return;

    // Set the current directory to the default directory
    CString strDirectory;
    BOOL    rc = FALSE;

    strDirectory = GetDefaultDirectory ();

    if (!strDirectory.IsEmpty())
        rc = SetCurrentDirectory (strDirectory);

    m_bDefaultDirSet = rc;
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::PumpMessage
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CAMCApp::PumpMessage()
{
    m_nMessagePumpNestingLevel++;

    MSG msg;
    ::PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE);

    if (msg.message == WM_CLOSE)
        m_fCloseCameFromMainPump = true;

    BOOL rc = CWinApp::PumpMessage();

    if (m_fDelayCloseUntilIdle && (m_nMessagePumpNestingLevel == 1))
    {
        m_fCloseCameFromMainPump = true;
        CMainFrame *pMainFrame = GetMainFrame();
        if (pMainFrame)
            pMainFrame->SendMessage (WM_CLOSE);
        m_fDelayCloseUntilIdle = false;
    }

    m_fCloseCameFromMainPump = false;

    m_nMessagePumpNestingLevel--;
    ASSERT (m_nMessagePumpNestingLevel >= 0);
    return (rc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScHelp
 *
 * PURPOSE: Displays help for the application.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScHelp()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScHelp"));

    CMainFrame * pMainFrame = GetMainFrame();
    if(!pMainFrame)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    pMainFrame->OnHelpTopics();

    return sc;
}

/*+-------------------------------------------------------------------------*
 * CAMCApp::OnIdle
 *
 * WM_IDLE handler for CAMCApp.
 *--------------------------------------------------------------------------*/

BOOL CAMCApp::OnIdle(LONG lCount)
{
    SC               sc;
    CIdleTaskQueue * pQueue = GetIdleTaskQueue();
    BOOL             fMoreIdleWork   = TRUE;

    if(NULL == pQueue)
    {
        ASSERT(0 && "Should not come here.");
        goto Error;
    }

    fMoreIdleWork = CWinApp::OnIdle(lCount);

    if (!fMoreIdleWork)
    {
        CMainFrame *pMainFrame = GetMainFrame();
        if (pMainFrame)
            pMainFrame->OnIdle ();
    }

    /*
     * if MFC doesn't have any more idle work to do,
     * check our idle task queue (if we have one)
     */
    if (!fMoreIdleWork && (pQueue != NULL))
    {
        LONG_PTR cIdleTasks;
        pQueue->ScGetTaskCount (&cIdleTasks);
        if(sc)
            goto Error;

        /*
         * do we have any idle tasks?
         */
        if (cIdleTasks > 0)
        {
            SC sc = pQueue->ScPerformNextTask();
            if(sc)
                goto Error;

            /*
             * this idle task may have added others; refresh the count
             */
            sc = pQueue->ScGetTaskCount(&cIdleTasks);
            if(sc)
                goto Error;
        }

        /*
         * do we have any more idle work to do?
         */
        fMoreIdleWork = (cIdleTasks > 0);
    }

    if (!fMoreIdleWork)
    {
        // this code is to trigger MMC exit sequence when it
        // is under the script control and the last reference is released.
        // (we do not use MFC [which would simply delete the mainframe] to do that)
        if ( !IsUnderUserControl() && CMMCStrongReferences::LastRefReleased() )
        {
            // we are in script control mode and all references are released
            // a good time to say goodbye

            CMainFrame *pMainFrame = GetMainFrame();
            sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
            if (sc)
                goto Error;

            // disabled main window will probably mean we are under modal dialog
            // wait until it is dismissed ( and try again )
            if (pMainFrame->IsWindowEnabled())
            {
                // here is the deal: if MMC is shown - we will initiate the exit sequence,
                // but put into the user mode first, so if user chooses to cancel it - it will have
                // the control over the application. He will also have to handle save request if
                // something has changed in the console
                if ( pMainFrame->IsWindowVisible() )
                {
                    if ( !m_fUnderUserControl )
                        SetUnderUserControl();

                    pMainFrame->PostMessage(WM_CLOSE);
                }
                else
                {
                    // if the application is hidden it should wait until user closes all open property sheets.
                    // since it will come back here, waiting means just doing nothing at this point.
                    if ( !FArePropertySheetsOpen(NULL, false /*bBringToFrontAndAskToClose*/ ) )
                    {
                        // if there are not sheets open - we must die silently
                        CAMCDoc* const pDoc = CAMCDoc::GetDocument();
                        if(pDoc == NULL)
                        {
                            sc = E_POINTER;
                            //fall thru; (need to close anyway)
                        }
                        else
                        {
                            // discard document without asking to save
                            pDoc->OnCloseDocument();
                        }

                        // say goodbye
                        pMainFrame->PostMessage(WM_CLOSE);
                    }
                }
            }
        }
    }

Cleanup:
    return (fMoreIdleWork);
Error:
    TraceError(TEXT("CAMCApp::OnIdle"), sc);
    goto Cleanup;

}

//+-------------------------------------------------------------------
//
//  Member:     InitializeMode
//
//  Synopsis:   Set the mode and load the menus, accelerator tables.
//
//  Arguments:  [eMode] - New application mode.
//
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::InitializeMode (ProgramMode eMode)
{
    SetMode(eMode);
    UpdateFrameWindow(false);
}

//+-------------------------------------------------------------------
//
//  Member:     SetMode
//
//  Synopsis:   Set the mode.
//
//  Note:       Call UpdateFrameWindow some time soon to update
//              menus/toolbars for this mode.
//              Cannot do this in this method. This is called
//              from CAMCDoc::LoadAppMode. The CAMCDoc::LoadFrame
//              calls the UpdateFrameWindow.
//
//  Arguments:  [eMode] - New application mode.
//
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::SetMode (ProgramMode eMode)
{
    ASSERT (IsValidProgramMode (eMode));

    if (m_fAuthorModeForced)
    {
        ASSERT (m_eMode == eMode_Author);
        ASSERT (GetMainFrame()->IsMenuVisible ());
    }
    else
        m_eMode = eMode;
}

//+-------------------------------------------------------------------
//
//  Member:     UpdateFrameWindow
//
//  Synopsis:   Load the menu/accelerator tables and update
//              them if loaded from console file.
//
//  Note:       Call UpdateFrameWindow some time soon after
//              calling SetMode to update menus/toolbars for this mode.
//              This is called from CAMCDoc::LoadFrame.
//
//  Arguments:  [bUpdate] - BOOL
//                          We need to update the toolbar/menus only
//                          if loaded from console file
//
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::UpdateFrameWindow(bool bUpdate)
{
    static const struct ModeDisplayParams
    {
        int     nResourceID;
        bool    fShowToolbar;
    } aDisplayParams[eMode_Count] =
    {
        {   IDR_AMCTYPE,            true    },      // eMode_Author
        {   IDR_AMCTYPE_USER,       false   },      // eMode_User
        {   IDR_AMCTYPE_MDI_USER,   false   },      // eMode_User_MDI
        {   IDR_AMCTYPE_SDI_USER,   false   },      // eMode_User_SDI
    };

    if (m_fAuthorModeForced)
    {
        ASSERT (m_eMode == eMode_Author);
        ASSERT (GetMainFrame()->IsMenuVisible ());
        return;
    }

    m_Menu.DestroyMenu ();
    m_Accel.DestroyAcceleratorTable ();

    VERIFY (m_Menu.LoadMenu          (aDisplayParams[m_eMode].nResourceID));
    m_Accel.LoadAccelerators (aDisplayParams[m_eMode].nResourceID);

    if (bUpdate)
    {
        CMainFrame *pMainFrame = GetMainFrame();
        ASSERT (pMainFrame != NULL);
        ASSERT_VALID (pMainFrame);

        CMDIChildWnd* pwndActive = pMainFrame ? pMainFrame->MDIGetActive () : NULL;

        // bypass CMainFrame::OnUpdateFrameMenu so CMainFrame::NotifyMenuChanged
        // doesn't get called twice and remove the new menu entirely
        if (pwndActive != NULL)
            pwndActive->OnUpdateFrameMenu (TRUE, pwndActive, m_Menu);
        else if (pMainFrame)
            pMainFrame->OnUpdateFrameMenu (m_Menu);

        if (m_eMode == eMode_User_SDI)
        {
            if (pwndActive != NULL)
                pwndActive->MDIMaximize ();

            if (pMainFrame)
                AppendToSystemMenu (pMainFrame, eMode_User_SDI);
        }

        if (pMainFrame)
            pMainFrame->ShowMenu    (true /*Always show menu*/);
    }
}



/*+-------------------------------------------------------------------------*
 * IsInContainer
 *
 *
 *--------------------------------------------------------------------------*/

template<class InputIterator, class T>
bool Find (InputIterator itFirst, InputIterator itLast, const T& t)
{
    return (std::find (itFirst, itLast, t) != itLast);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::HookPreTranslateMessage
 *
 * Adds a window the the list of windows that get prioritized cracks at
 * PreTranslateMessage.  Hooks set later get priority over earlier hooks.
 *--------------------------------------------------------------------------*/

void CAMCApp::HookPreTranslateMessage (CWnd* pwndHook)
{
    HWND hwndHook = pwndHook->GetSafeHwnd();
    ASSERT (IsWindow (hwndHook));

    // this only makes sense for permanent windows
    ASSERT (CWnd::FromHandlePermanent(hwndHook) == pwndHook);

    /*
     * Put the hook window at the front of the hook list.  We're preserving
     * the HWND instead of the CWnd* so we don't have unnecessary list<>
     * code generated.  We already use a list<HWND> for m_DelayedUpdateWindows,
     * so using list<HWND> here doesn't cause any more code to be generated.
     */
    if (!Find (m_TranslateMessageHookWindows.begin(),
               m_TranslateMessageHookWindows.end(),
               hwndHook))
    {
        m_TranslateMessageHookWindows.push_front (hwndHook);
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::UnhookPreTranslateMessage
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCApp::UnhookPreTranslateMessage (CWnd* pwndUnhook)
{
    HWND hwndUnhook = pwndUnhook->GetSafeHwnd();
    ASSERT (IsWindow (hwndUnhook));

    WindowListIterator itEnd   = m_TranslateMessageHookWindows.end();
    WindowListIterator itFound = std::find (m_TranslateMessageHookWindows.begin(),
                                            itEnd, hwndUnhook);

    if (itFound != itEnd)
        m_TranslateMessageHookWindows.erase (itFound);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::GetIdleTaskQueue
 *
 * Returns the IIdleTaskQueue interface for the application, creating it
 * if necessary.
 *--------------------------------------------------------------------------*/

CIdleTaskQueue * CAMCApp::GetIdleTaskQueue ()
{
    return &m_IdleTaskQueue;
}



/*+-------------------------------------------------------------------------*
 * ScExpandEnvironmentStrings
 *
 * Expands the any environment string (e.g. %SystemRoot%) in the input
 * string, in place.
 *--------------------------------------------------------------------------*/

SC ScExpandEnvironmentStrings (CString& str)
{
    DECLARE_SC (sc, _T("ScExpandEnvironmentStrings"));

    if (str.Find(_T('%')) != -1)
    {
        TCHAR szBuffer[MAX_PATH];

        if (!ExpandEnvironmentStrings (str, szBuffer, countof(szBuffer)))
            return (sc.FromLastError());

        str = szBuffer;
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScCreateDumpSnapins
 *
 * Creates a CLSID_MMCDocConfig object, opens it on the supplied filename,
 * and returns a pointer to the IDumpSnapins interface on the object.
 *--------------------------------------------------------------------------*/

SC ScCreateDumpSnapins (
    CString&        strConsoleFile,     /* I/O:console file                 */
    IDumpSnapins**  ppDumpSnapins)      /* O:IDumpSnapins interface         */
{
    DECLARE_SC (sc, _T("ScCreateDumpSnapins"));

    /*
     * validate input
     */
    sc = ScCheckPointers (ppDumpSnapins);
    if (sc)
        return (sc);

    *ppDumpSnapins = NULL;

    /*
     * create a doc config object
     */
    IDocConfigPtr spDocConfig;
    sc = spDocConfig.CreateInstance (CLSID_MMCDocConfig);
    if (sc)
        return (sc);

    /*
     * expand any embedded environment strings in the console filename
     */
    sc = ScExpandEnvironmentStrings (strConsoleFile);
    if (sc)
        return (sc);

    /*
     * open the console file
     */
    sc = spDocConfig->OpenFile (::ATL::CComBSTR (strConsoleFile));
    if (sc)
        return (sc);

    /*
     * get the IDumpSnapins interface
     */
    sc = spDocConfig.QueryInterface (IID_IDumpSnapins, *ppDumpSnapins);
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::DumpConsoleFile
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CAMCApp::DumpConsoleFile (CString strConsoleFile, CString strDumpFile)
{
    DECLARE_SC (sc, _T("CAMCApp::DumpConsoleFile"));
    const CString* pstrFileWithError = &strConsoleFile;

    /*
     * get an IDumpSnapins interface on this console file
     */
    IDumpSnapinsPtr spDumpSnapins;
    sc = ScCreateDumpSnapins (strConsoleFile, &spDumpSnapins);
    if (sc)
        goto Error;

    sc = ScCheckPointers (spDumpSnapins, E_UNEXPECTED);
    if (sc)
        goto Error;

    /*
     * expand the dump filename if necessary
     */
    sc = ScExpandEnvironmentStrings (strDumpFile);
    if (sc)
        goto Error;

    /*
     * If there's no directory specifier on the dump file, put a "current
     * directory" marker on it.  We do this to prevent WritePrivateProfile*
     * from putting the file in the Windows directory.
     */
    if (strDumpFile.FindOneOf(_T(":\\")) == -1)
        strDumpFile = _T(".\\") + strDumpFile;

    /*
     * future file-related errors will pertain to the dump file
     * (see Error handler)
     */
    pstrFileWithError = &strDumpFile;

    /*
     * wipe out the existing file, if any
     */
    if ((GetFileAttributes (strDumpFile) != 0xFFFFFFFF) && !DeleteFile (strDumpFile))
    {
        sc.FromLastError();
        goto Error;
    }

    /*
     * dump the contents of the console file
     */
    sc = spDumpSnapins->Dump (strDumpFile);
    if (sc)
        goto Error;

    return (sc.ToHr());

Error:
    MMCErrorBox (*pstrFileWithError, sc);
    return (sc.ToHr());
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnNewDocument
 *
 * PURPOSE: Emits script event for application object
 *
 * PARAMETERS:
 *    CAMCDoc *pDocument      [in] document being created/opened
 *    BOOL bLoadedFromConsole [in] if document is loaded from file
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnNewDocument(CAMCDoc *pDocument, BOOL bLoadedFromConsole)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnNewDocument"));

    // check if there are "listeners"
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks;
        return sc;

    // construct document com object
    DocumentPtr spComDoc;
    sc = pDocument->ScGetMMCDocument(&spComDoc);
    if (sc)
        return sc;

    // check pointer
    sc = ScCheckPointers(spComDoc, E_POINTER);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnDocumentOpen (spComDoc , bLoadedFromConsole == FALSE));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnQuitApp
 *
 * PURPOSE: Emits script event for application object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnQuitApp()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnQuitApp"));

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnQuit (m_sp_Application));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnCloseView
 *
 * PURPOSE: Script event firing helper. Invoked when the view is closed
 *
 * PARAMETERS:
 *    CAMCView *pView [in] - view being closed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnCloseView( CAMCView *pView )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnCloseView"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnViewClose (spView));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnViewChange
 *
 * PURPOSE: Script event firing helper. Invoked when scope selection change
 *
 * PARAMETERS:
 *    CAMCView *pView [in] affected view
 *    HNODE hNode     [in] new selected scope node
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnViewChange( CAMCView *pView, HNODE hNode )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnViewChange"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // construct Node com object
    NodePtr spNode;
    sc = pView->ScGetScopeNode( hNode, &spNode );
    if (sc)
        return sc;

    // fire script event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnViewChange(spView, spNode));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnResultSelectionChange
 *
 * PURPOSE: Script event firing helper. Invoked when result selection change
 *
 * PARAMETERS:
 *    CAMCView *pView [in] - affected view
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnResultSelectionChange( CAMCView *pView )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnResultSelectionChange"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // construct Node com object
    NodesPtr spNodes;
    sc = pView->Scget_Selection( &spNodes );
    if (sc)
        return sc;

    // fire script event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnSelectionChange(spView, spNodes));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMMCApplication::ScOnContextMenuExecuted
 *
 * PURPOSE: called when the context menu is executed to fire the event to script
 *
 * PARAMETERS:
 *    PMENUITEM pMenuItem - menu item (note: it may be NULL if menu item is gone)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnContextMenuExecuted( PMENUITEM pMenuItem )
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnContextMenuExecuted"));

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents, OnContextMenuExecuted( pMenuItem ) );
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScOnListViewItemUpdated
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CAMCView * pView :
 *    int        nIndex :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScOnListViewItemUpdated(CAMCView *pView , int nIndex)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnListViewItemUpdated"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // fire script event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnListUpdated(spView));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnSnapinAdded
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin added to the console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnSnapinAdded(CAMCDoc *pAMCDoc, PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnSnapinAdded"));

    // parameter check
    sc = ScCheckPointers(pAMCDoc, pSnapIn);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    DocumentPtr spDocument;
    sc = pAMCDoc->ScGetMMCDocument(&spDocument);
    if (sc)
        return sc;

    // check
    sc = ScCheckPointers(spDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnSnapInAdded (spDocument, pSnapIn));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnSnapinRemoved
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin removed from console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnSnapinRemoved(CAMCDoc *pAMCDoc, PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnSnapinRemoved"));

    // parameter check
    sc = ScCheckPointers(pAMCDoc, pSnapIn);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    DocumentPtr spDocument;
    sc = pAMCDoc->ScGetMMCDocument(&spDocument);
    if (sc)
        return sc;

    // check
    sc = ScCheckPointers(spDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnSnapInRemoved (spDocument, pSnapIn));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnNewView
 *
 * PURPOSE: Script event firing helper
 *
 * PARAMETERS:
 *    CAMCView *pView [in] - created view
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnNewView(CAMCView *pView)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnNewView"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct View com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnNewView(spView));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::OnCloseDocument
 *
 * PURPOSE: Helper for invoking com event
 *
 * PARAMETERS:
 *    CAMCDoc *pAMCDoc [in] - document being closed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnCloseDocument(CAMCDoc *pAMCDoc)
{
    DECLARE_SC(sc, TEXT("CAMCApp::OnCloseDocument"));

    // parameter check
    sc = ScCheckPointers(pAMCDoc);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    DocumentPtr spDocument;
    sc = pAMCDoc->ScGetMMCDocument(&spDocument);
    if (sc)
        return sc;

    // check
    sc = ScCheckPointers(spDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnDocumentClose (spDocument));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnToolbarButtonClicked
 *
 * PURPOSE: Observed toolbar event - used to fire com event
 *
 * PARAMETERS:
 *    CAMCView *pAMCView - [in] view which toobar is executed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnToolbarButtonClicked( )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnToolbarButtonClicked"));

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnToolbarButtonClicked ( ));
    if (sc)
        sc.TraceAndClear(); // ignore the error - should not affect main behavior

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::SetUnderUserControl
 *
 * PURPOSE: puts application into user control/script control mode
 *          implements Application.UserControl property
 *
 * PARAMETERS:
 *    bool bUserControl [in] true == set user control
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCApp::SetUnderUserControl(bool bUserControl /* = true */ )
{
    m_fUnderUserControl = bUserControl;

    AfxOleSetUserCtrl(bUserControl); // allow MFC to know that
    if (bUserControl)
    {
        // make sure application is visible if it's under user control

        CMainFrame *pMainFrame = GetMainFrame();
        if(pMainFrame && !pMainFrame->IsWindowVisible())
        {
            pMainFrame->ShowWindow(SW_SHOW);
        }
    }
}


#ifdef MMC_WIN64

/*+-------------------------------------------------------------------------*
 * CompareBasicSnapinInfo
 *
 * Implements a less-than comparison for CBasicSnapinInfo, based solely on
 * the CLSID.  Returns true if the CLSID for bsi1 is less than the CLSID
 * for bsi2, false otherwise.
 *--------------------------------------------------------------------------*/

bool CompareBasicSnapinInfo (const CBasicSnapinInfo& bsi1, const CBasicSnapinInfo& bsi2)
{
    return (bsi1.m_clsid < bsi2.m_clsid);
}


/*+-------------------------------------------------------------------------*
 * ScDetermineArchitecture
 *
 * Determines whether MMC64 (which is currently executing) should chain
 * to MMC32.  This will occur in one of three situations:
 *
 * 1.  The "-32" command line parameter was specified.
 *
 * 2.  A console file was specified on the command line, and it contains
 *     one or more snap-ins that were not registered in the 64-bit HKCR
 *     hive, but all snap-ins are registered in the 32-bit HKCR hive.
 *
 * 3.  A console file was specified on the command line, and it contained
 *     one or more snap-ins that were not registered in the 64-bit HKCR
 *     hive, and one or more snap-ins that are not registered in the 32-bit
 *     HKCR hive.  In this case we'll do one of three things:
 *
 *     a.   If the set of unavailable 64-bit snap-ins is a subset of the
 *          set of unavailable 32-bit snap-ins, the 64-bit console will be
 *          more functional than the 32-bit console, so we'll run MMC64.
 *
 *     b.   If the set of unavailable 32-bit snap-ins is a subset of the
 *          set of unavailable 64-bit snap-ins, the 32-bit console will be
 *          more functional than the 64-bit console, so we'll run MMC32.
 *
 *     c.   If neither a. or b. is true, we'll display UI asking which
 *          version of MMC to run.
 *
 * Returns:
 * eArch == eArch_64bit - 64-bit MMC is needed (or an error occurred)
 * eArch == eArch_32bit - 32-bit MMC is needed
 * eArch == eArch_None  - user cancelled the operation
 *--------------------------------------------------------------------------*/

SC ScDetermineArchitecture (const CMMCCommandLineInfo& rCmdInfo, eArchitecture& eArch)
{
    DECLARE_SC (sc, _T("ScDetermineArchitecture"));

    /*
     * default to 64-bit
     */
    eArch = eArch_64bit;

    /*
     * Case 0:  Was "-64" specified on the command line?  64-bit needed
     */
    if (rCmdInfo.m_eArch == eArch_64bit)
    {
        Trace (tag32BitTransfer, _T("\"-64\" parameter specified, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * Case 1:  Was "-32" specified on the command line?  32-bit needed
     */
    if (rCmdInfo.m_eArch == eArch_32bit)
    {
        Trace (tag32BitTransfer, _T("\"-32\" parameter specified, 32-bit MMC needed"));
        eArch = eArch_32bit;
        return (sc);
    }

    /*
     * No file on the command line?  64-bit needed
     */
    if (rCmdInfo.m_nShellCommand != CCommandLineInfo::FileOpen)
    {
        Trace (tag32BitTransfer, _T("No console file specified, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * Cases 2 and 3:  Analyze the specified console file
     */
    Trace (tag32BitTransfer, _T("Analyzing snap-ins in \"%s\""), (LPCTSTR) rCmdInfo.m_strFileName);

    /*
     * get an IDumpSnapins interface so we can analyze the console file
     */
    IDumpSnapinsPtr spDumpSnapins;
    CString strConsoleFile = rCmdInfo.m_strFileName;
    sc = ScCreateDumpSnapins (strConsoleFile, &spDumpSnapins);
    if (sc)
        return (sc);

    sc = ScCheckPointers (spDumpSnapins, E_UNEXPECTED);
    if (sc)
        return (sc);

    /*
     * analyze the 64-bit snap-ins in this console
     */
    CAvailableSnapinInfo asi64(false);
    sc = spDumpSnapins->CheckSnapinAvailability (asi64);
    if (sc)
        return (sc);

    /*
     * if no snap-ins are unavailable in 64-bit form, no need for MMC32
     */
    if (asi64.m_vAvailableSnapins.size() == asi64.m_cTotalSnapins)
    {
        Trace (tag32BitTransfer, _T("All snapins are available in 64-bit form, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * analyze the 32-bit snap-ins in this console
     */
    CAvailableSnapinInfo asi32(true);
    sc = spDumpSnapins->CheckSnapinAvailability (asi32);
    if (sc)
        return (sc);

    /*
     * Case 2:  If no snap-ins are unavailable in 32-bit form, 32-bit needed
     */
    if (asi32.m_vAvailableSnapins.size() == asi32.m_cTotalSnapins)
    {
        Trace (tag32BitTransfer, _T("All snapins are available in 32-bit form, 32-bit MMC needed"));
        eArch = eArch_32bit;
        return (sc);
    }

    /*
     * std::includes depends on its ranges being sorted, so make sure
     * that's the case
     */
    std::sort (asi32.m_vAvailableSnapins.begin(), asi32.m_vAvailableSnapins.end(), CompareBasicSnapinInfo);
    std::sort (asi64.m_vAvailableSnapins.begin(), asi64.m_vAvailableSnapins.end(), CompareBasicSnapinInfo);

    /*
     * Case 3a:  If the set of available 64-bit snap-ins is a
     * superset of the set of available 32-bit snap-ins, run MMC64
     */
    if (std::includes (asi64.m_vAvailableSnapins.begin(), asi64.m_vAvailableSnapins.end(),
                       asi32.m_vAvailableSnapins.begin(), asi32.m_vAvailableSnapins.end(),
                       CompareBasicSnapinInfo))
    {
        Trace (tag32BitTransfer, _T("The set of available 64-bit snapins is a superset of..."));
        Trace (tag32BitTransfer, _T("...the set of available 32-bit snapins, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * Case 3b:  If the set of available 32-bit snap-ins is a
     * superset of the set of available 64-bit snap-ins, run MMC32
     */
    if (std::includes (asi32.m_vAvailableSnapins.begin(), asi32.m_vAvailableSnapins.end(),
                       asi64.m_vAvailableSnapins.begin(), asi64.m_vAvailableSnapins.end(),
                       CompareBasicSnapinInfo))
    {
        Trace (tag32BitTransfer, _T("The set of available 32-bit snapins is a superset of..."));
        Trace (tag32BitTransfer, _T("...the set of available 64-bit snapins, 32-bit MMC needed"));
        eArch = eArch_32bit;
        return (sc);
    }

    /*
     * Case 3c:  Ask the user which to run
     */
    CArchitecturePicker dlg (rCmdInfo.m_strFileName, asi64, asi32);

    if (dlg.DoModal() == IDOK)
    {
        eArch = dlg.GetArchitecture();
        Trace (tag32BitTransfer, _T("User chose %d-bit, %d-bit MMC needed"), (eArch == eArch_32bit) ? 32 : 64, (eArch == eArch_32bit) ? 32 : 64);
    }
    else
    {
        Trace (tag32BitTransfer, _T("User chose to exit, terminating"));
        eArch = eArch_None;
    }

    return (sc);
}

#endif // MMC_WIN64


#ifdef UNICODE

/*+-------------------------------------------------------------------------*
 * ScLaunchMMC
 *
 * Launches a specific architecture of MMC (i.e. MMC32 from MMC64 or vice
 * versa) with the same command line used to launch this process.
 *
 * Returns S_OK if the given architecture of MMC was launched successfully,
 * or an error code if an error occurred.
 *--------------------------------------------------------------------------*/

SC ScLaunchMMC (
	eArchitecture	eArch,				/* I:desired architecture           */
	int				nCmdShow)			/* I:show state                     */
{
    DECLARE_SC (sc, _T("ScLaunchMMC"));

	CString strArgs;
	int nFolder;

	switch (eArch)
	{
		case eArch_64bit:
			nFolder = CSIDL_SYSTEM;
			break;

		case eArch_32bit:
			/*
			 * make sure we give MMC32 a "-32" argument so it won't defer
			 * to MMC64 again (see CAMCApp::InitInstance)
			 */
			strArgs = _T("-32 ");
			nFolder = CSIDL_SYSTEMX86;
            break;

		default:
			return (sc = E_INVALIDARG);
			break;
	}

    /*
     * Get the directory where MMC32 lives (%SystemRoot%\syswow64) and
     * append the executable name
     */
    CString strProgram, strPath;
    sc = SHGetFolderPath (NULL, nFolder, NULL, 0, strProgram.GetBuffer(MAX_PATH));
    if (sc)
        return (sc);

    strProgram.ReleaseBuffer();
    strPath = strProgram;
    strProgram += _T("\\mmc.exe");

	/*
	 * disable file system redirection so MMC32 will be able to launch MMC64
	 */
	CWow64FilesystemRedirectionDisabler disabler (strProgram);

    /*
     * get the arguments for the original invocation of MMC, skipping
     * argv[0] (the executable name) and any "-32" or "-64" parameters
     */
    int argc;
    CAutoGlobalPtr<LPWSTR> argv (CommandLineToArgvW (GetCommandLine(), &argc));
    if (argv == NULL)
        return (sc.FromLastError());

    for (int i = 1; i < argc; i++)
    {
        CString strArg = argv[i];

        if ((strArg != _T("-32")) && (strArg != _T("/32")) &&
            (strArg != _T("-64")) && (strArg != _T("/64")))
        {
            strArgs += _T("\"") + strArg + _T("\" ");
        }
    }

	/*
	 * start the requested architecture of MMC
	 */
	Trace (tag32BitTransfer, _T("Attempting to run: %s %s"), (LPCTSTR) strProgram, (LPCTSTR) strArgs);

    SHELLEXECUTEINFO sei = {0};
    sei.cbSize       = sizeof (sei);
    sei.fMask        = SEE_MASK_FLAG_NO_UI;
    sei.lpFile       = strProgram;
    sei.lpDirectory  = strPath;
    sei.lpParameters = strArgs;
    sei.nShow        = nCmdShow;

    if (!ShellExecuteEx (&sei))
        return (sc.FromLastError());

    return (sc);
}

#endif  // UNICODE


#ifndef MMC_WIN64

/*+-------------------------------------------------------------------------*
 * IsWin64
 *
 * Returns true if we're running on Win64, false otherwise.
 *--------------------------------------------------------------------------*/

bool IsWin64()
{
#ifdef UNICODE
    /*
     * get a pointer to kernel32!GetSystemWow64Directory
     */
    HMODULE hmod = GetModuleHandle (_T("kernel32.dll"));
    if (hmod == NULL)
        return (false);

    UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);
    (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryW");

    if (pfnGetSystemWow64Directory == NULL)
        return (false);

    /*
     * if GetSystemWow64Directory fails and sets the last error to
     * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
     */
    TCHAR szWow64Dir[MAX_PATH];
    if (((pfnGetSystemWow64Directory)(szWow64Dir, countof(szWow64Dir)) == 0) &&
        (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
    {
        return (false);
    }

    /*
     * if we get here, we're on Win64
     */
    return (true);
#else
    /*
     * non-Unicode platforms cannot be Win64
     */
    return (false);
#endif  // UNICODE
}

#endif // !MMC_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcdoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcdoc.h
//
//--------------------------------------------------------------------------

// AMCDoc.h : interface of the CAMCDoc class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef AMCDOC_H__
#define AMCDOC_H__

#include "mmcdata.h"
#include "amc.h"            // for AMCGetApp
#include "picon.h"          // for CPersistableIcon
#include "tstring.h"        // for CStringTableStringBase
#include "condoc.h"

#define EXPLICIT_SAVE    0x1

class CAMCView;
class ViewSettings;
class CMasterStringTable;
class CFavorites;
class CMMCDocument;
struct Document;

/*+-------------------------------------------------------------------------*
 * CStringTableString
 *
 *
 *--------------------------------------------------------------------------*/

class CStringTableString : public CStringTableStringBase
{
    typedef CStringTableStringBase BaseClass;

public:
    CStringTableString (IStringTablePrivate* pstp)
        : BaseClass (pstp) {}

    CStringTableString (const CStringTableString& other)
        : BaseClass (other) {}

    CStringTableString (const tstring& str)
        : BaseClass (GetStringTable(), str) {}

    CStringTableString& operator= (const CStringTableString& other)
        { BaseClass::operator=(other); return (*this); }

    CStringTableString& operator= (const tstring& str)
        { BaseClass::operator=(str); return (*this); }

    CStringTableString& operator= (LPCTSTR psz)
        { BaseClass::operator=(psz); return (*this); }

private:
    IStringTablePrivate* GetStringTable() const;

};


/*+-------------------------------------------------------------------------*
 * CAMCViewPosition
 *
 * This class abstracts a POSITION.  It can be used to iterate through a
 * CAMCDoc's CAMCView objects using GetFirstAMCViewPosition and
 * GetNextAMCView.
 *
 * It exists to guard against using GetFirstViewPosition with GetNextAMCView
 * or GetFirstAMCViewPosition with GetNextView.
 *--------------------------------------------------------------------------*/

class CAMCViewPosition
{
public:
    CAMCViewPosition() : m_pos(NULL)
        {}

    POSITION& GetPosition ()        // returns non-const reference
        { return (m_pos); }

    void SetPosition (POSITION pos)
        { m_pos = pos; }

    /*
     * for comparison to NULL
     */
    bool operator==(int null) const
    {
        ASSERT (null == 0);     // *only* support comparison to NULL
        return (m_pos == NULL);
    }

    bool operator!=(int null) const
    {
        ASSERT (null == 0);     // *only* support comparison to NULL
        return (m_pos != NULL);
    }

private:
    POSITION    m_pos;
};


/*+-------------------------------------------------------------------------*
 * class CAMCDoc
 *
 *
 *--------------------------------------------------------------------------*/

class CAMCDoc :
    public CDocument,
    public CTiedObject,
    public CXMLObject,
    public CConsoleDocument,
    public CConsoleFilePersistor,
    public CEventSource<CAMCDocumentObserver>
{
    enum SaveStatus
    {
        eStat_Failed,
        eStat_Succeeded,
        eStat_Cancelled
    };

protected: // create from serialization only
    CAMCDoc();
    DECLARE_DYNCREATE(CAMCDoc)

// Attributes
public:
    virtual BOOL IsModified();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    SC           ScOnOpenDocument(LPCTSTR lpszPathName); // SC version of the above method.
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
    virtual void DeleteContents();
    virtual void OnCloseDocument();
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL

    private: bool m_bCanCloseViews;
    public:  bool CanCloseViews() {return m_bCanCloseViews;}

    // object model related methods.
    // hand over an automation object - CHANGE to use smart pointers.
    SC      ScGetMMCDocument(Document **ppDocument);

    // Document interface
    SC      ScSave();
    SC      ScSaveAs(         BSTR bstrFilename);
    SC      ScClose(          BOOL bSaveChanges);
    SC      ScCreateProperties( PPPROPERTIES ppProperties);

    // properties
    SC      Scget_Views(      PPVIEWS   ppViews);
    SC      Scget_SnapIns(    PPSNAPINS ppSnapIns);
    SC      Scget_ActiveView( PPVIEW    ppView);
    SC      Scget_Name(       PBSTR     pbstrName);
    SC      Scput_Name(       BSTR      bstrName);
    SC      Scget_Location(   PBSTR     pbstrLocation);
    SC      Scget_IsSaved(    PBOOL     pBIsSaved);
    SC      Scget_Mode(       PDOCUMENTMODE pMode);
    SC      Scput_Mode(       DocumentMode mode);
    SC      Scget_RootNode(   PPNODE     ppNode);
    SC      Scget_ScopeNamespace( PPSCOPENAMESPACE  ppScopeNamespace);
    SC      Scget_Application(PPAPPLICATION  ppApplication);

    // Views interface
    SC      Scget_Count(  PLONG pCount);
    SC      ScAdd(        PNODE pNode, ViewOptions fViewOptions /* = ViewOption_Default*/ );
    SC      ScItem(       long  Index, PPVIEW ppView);

    // views enumerator
    SC      ScEnumNext(CAMCViewPosition &pos, PDISPATCH & pDispatch);
    SC      ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, CAMCViewPosition &pos);
    SC      ScEnumReset(CAMCViewPosition &pos);


public:
    // to iterate through the AMCViews only (not all child views)
    // similar to GetNextView and GetFirstViewPosition.
    CAMCView *       GetNextAMCView(CAMCViewPosition &pos) const;
    CAMCViewPosition GetFirstAMCViewPosition()     const;


public:
    // CXMLObject overrides
    DEFINE_XML_TYPE(XML_TAG_MMC_CONSOLE_FILE);
    virtual void    Persist(CPersistor& persistor);
    void            PersistFrame(CPersistor& persistor);
    void            PersistViews(CPersistor& persistor);
    SC              ScCreateAndLoadView(CPersistor& persistor, int nViewID, const CBookmark& rootNode);
    void            PersistCustomData (CPersistor &persistor);

    IScopeTree* GetScopeTree()
    {
        return m_spScopeTree;
    }

    CAMCView* CreateNewView(bool visible, bool bEmitScriptEvents = true);

    static CAMCDoc* GetDocument()
    {
        return m_pDoc;
    }

    MTNODEID GetMTNodeIDForNewView()
    {
        return m_MTNodeIDForNewView;
    }

    void SetMTNodeIDForNewView(MTNODEID id)
    {
        m_MTNodeIDForNewView = id;
    }

    int GetViewIDForNewView()
    {
        return m_ViewIDForNewView;
    }

    long GetNewWindowOptions()
    {
        return m_lNewWindowOptions;
    }

    HELPDOCINFO* GetHelpDocInfo()
    {
        return &m_HelpDocInfo;
    }

    void SetNewWindowOptions(long lOptions)
    {
        m_lNewWindowOptions = lOptions;
    }

    void SetMode (ProgramMode eMode);
    ProgramMode GetMode () const
    {
        return (m_ConsoleData.GetConsoleMode());
    }

    bool IsFrameModified () const
    {
        return (m_fFrameModified);
    }

    void SetFrameModifiedFlag (bool fFrameModified = TRUE)
    {
        m_fFrameModified = fFrameModified;
    }

    // implements CConsoleDocument for document access from node manager
    virtual SC ScOnSnapinAdded       (PSNAPIN pSnapIn);
    virtual SC ScOnSnapinRemoved     (PSNAPIN pSnapIn);
    virtual SC ScSetHelpCollectionInvalid();


public:

// Implementation
    virtual ~CAMCDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    virtual BOOL DoFileSave();
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
    virtual HMENU GetDefaultMenu(); // get menu depending on state

    SConsoleData* GetConsoleData() { return &m_ConsoleData; }

public:
    HRESULT InitNodeManager();
    void ShowStatusBar (bool fVisible);

/*
 * Custom data stuff
 */
private:
    bool LoadCustomData      (IStorage* pStorage);
    bool LoadCustomIconData  (IStorage* pStorage);
    bool LoadCustomTitleData (IStorage* pStorage);
    bool LoadStringTable     (IStorage* pStorage);
/*
 * Custom icon stuff
 */
public:
    HICON GetCustomIcon (bool fLarge, CString* pstrIconFile = NULL, int* pnIconIndex = NULL) const;
    void  SetCustomIcon (LPCTSTR pszIconFile, int nIconIndex);

    bool  HasCustomIcon () const
        { return (m_CustomIcon); }

private:
    CPersistableIcon m_CustomIcon;


/*
 * Custom title stuff
 */
public:
    bool HasCustomTitle () const;
    CString GetCustomTitle () const;
    void SetCustomTitle (CString strNewTitle);
    IStringTablePrivate* GetStringTable() const;

private:
    CComPtr<IStringTablePrivate>    m_spStringTable;
    CStringTableString *            m_pstrCustomTitle;

/*
 * Favorites stuff
 */
 public:
    CFavorites* GetFavorites() { return m_pFavorites; }

private:
    bool LoadFavorites();
    CFavorites* m_pFavorites;

private:
    static CAMCDoc* m_pDoc;
    // the one and only document for the application

    IScopeTreePtr m_spScopeTree;
    // master namespace for document

    IPersistStoragePtr m_spScopeTreePersist;
    // master namespace IPersistStorage interface

    IStoragePtr m_spStorage;
    // the currently opened storage

    MTNODEID m_MTNodeIDForNewView;
    // the node id to be used when creating the next view

    int m_ViewIDForNewView;
    // the node id to be used when creating the next view

    SConsoleData   m_ConsoleData;

    long m_lNewWindowOptions;
    bool m_bReadOnlyDoc;
    bool m_fFrameModified;
    SaveStatus m_eSaveStatus;

    DWORD m_dwFlags;

    HELPDOCINFO m_HelpDocInfo;

    void ReleaseNodeManager();
    bool LoadViews();
    bool LoadFrame();
    bool LoadAppMode();

    bool NodeManagerIsInitialized();
    bool NodeManagerIsLoaded();
    bool AssertNodeManagerIsInitialized();
    bool AssertNodeManagerIsLoaded();
    BOOL OnNewDocumentFailed();
    void SetConsoleFlag (ConsoleFlags eFlag, bool fSet);
    void DeleteHelpFile ();

    SC   ScGetViewSettingsPersistorStream(IPersistStream **pIPersistStreamViewSettings);

private:
    bool GetDocumentMode(DocumentMode* pMode);
    bool SetDocumentMode(DocumentMode docMode);

public:
    // Is this save called implicitly or is it a result of exiting a modified file?
    bool IsExplicitSave() const
        { return (0 != (m_dwFlags & EXPLICIT_SAVE)); }

    void SetExplicitSave(bool bNewVal)
    {
        if (bNewVal)
            m_dwFlags |= EXPLICIT_SAVE;
        else
            m_dwFlags &= ~EXPLICIT_SAVE;
    }

    bool AllowViewCustomization() const
        { return ((m_ConsoleData.m_dwFlags & eFlag_PreventViewCustomization) == 0); }

    bool IsLogicalReadOnly() const
        { return ((m_ConsoleData.m_dwFlags & eFlag_LogicalReadOnly) != 0); }

    bool IsPhysicalReadOnly() const
        { return (m_bReadOnlyDoc); }

    // physical ReadOnly does not apply to user mode - it is not saving to original console
    // anyway.
    bool IsReadOnly() const
        { return ((IsPhysicalReadOnly() && (AMCGetApp()->GetMode() == eMode_Author)) ||
                  (IsLogicalReadOnly() && (AMCGetApp()->GetMode() != eMode_Author))) ; }

    void SetPhysicalReadOnlyFlag (bool fPhysicalReadOnly)
        { m_bReadOnlyDoc = fPhysicalReadOnly; }

    void SetLogicalReadOnlyFlag (BOOL fLogicalReadOnly)
        { SetConsoleFlag (eFlag_LogicalReadOnly, fLogicalReadOnly); }

    void AllowViewCustomization (BOOL fAllowCustomization)
        { SetConsoleFlag (eFlag_PreventViewCustomization, !fAllowCustomization); }

    int GetNumberOfViews();
    int GetNumberOfPersistedViews();

private:
    //{{AFX_MSG(CAMCDoc)
    afx_msg void OnUpdateFileSave(CCmdUI* pCmdUI);
    afx_msg void OnConsoleAddremovesnapin();
    afx_msg void OnUpdateConsoleAddremovesnapin(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    DocumentPtr  m_sp_Document;
    ViewsPtr     m_spViews;
};

inline bool CAMCDoc::NodeManagerIsInitialized()
{
    return m_spScopeTree != NULL && m_spScopeTreePersist != NULL;
}

inline bool CAMCDoc::NodeManagerIsLoaded()
{
    return NodeManagerIsInitialized() && m_spStorage != NULL;
}

inline bool CAMCDoc::AssertNodeManagerIsInitialized()
{
    bool const bInited = NodeManagerIsInitialized();
    ASSERT(bInited);
    return bInited;
}

inline bool CAMCDoc::AssertNodeManagerIsLoaded()
{
    bool const bLoaded = NodeManagerIsLoaded();
    ASSERT(bLoaded);
    return bLoaded;
}

inline BOOL CAMCDoc::OnNewDocumentFailed()
{
    ReleaseNodeManager();
    return FALSE;
}

inline bool CAMCDoc::GetDocumentMode(DocumentMode* pMode)
{
    if (! pMode)
        return false;

    switch(GetMode())
    {
    case eMode_Author:
        *pMode = DocumentMode_Author;
        break;

    case eMode_User:
        *pMode = DocumentMode_User;
        break;

    case eMode_User_MDI:
        *pMode = DocumentMode_User_MDI;
        break;

    case eMode_User_SDI:
        *pMode = DocumentMode_User_SDI;
        break;

    default:
        ASSERT(FALSE && _T("Unknown program mode"));
        return false;
        break;
    }

    return true;
}


inline bool CAMCDoc::SetDocumentMode(DocumentMode docMode)
{
    switch(docMode)
    {
    case DocumentMode_Author:
        SetMode(eMode_Author);
        break;

    case DocumentMode_User:
        SetMode(eMode_User);
        break;

    case DocumentMode_User_SDI:
        SetMode(eMode_User_SDI);
        break;

    case DocumentMode_User_MDI:
        SetMode(eMode_User_MDI);
        break;

    default:
        return false; // Unknown mode.
        break;
    }

    return true;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::ScGetViewSettingsPersistorStream
//
//  Synopsis:    helper to get the IPersistStream interface for
//               CViewSettingsPersistor object.
//
//  Arguments:   [pIPersistStreamViewSettings] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCDoc::ScGetViewSettingsPersistorStream (/*[out]*/IPersistStream **pIPersistStreamViewSettings)
{
    DECLARE_SC(sc, _T("CAMCDoc::ScGetViewSettingsPersistorStream"));
    sc = ScCheckPointers(pIPersistStreamViewSettings);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    INodeCallbackPtr spNodeCallback;
    sc = m_spScopeTree->QueryNodeCallback(&spNodeCallback);
    if (sc)
        return sc;

    sc = ScCheckPointers(spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spNodeCallback->QueryViewSettingsPersistor(pIPersistStreamViewSettings);
    if (sc)
        return sc;

    sc = ScCheckPointers(pIPersistStreamViewSettings, E_UNEXPECTED);
    if (sc)
        return sc;

    return (sc);
}


int DisplayFileOpenError (SC sc, LPCTSTR pszFilename);


/////////////////////////////////////////////////////////////////////////////

#endif // AMCDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcdocmg.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      amcdocmg.cpp
 *
 *  Contents:  Implementation file for CAMCDocManager
 *
 *  History:   01-Jan-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/


#include "stdafx.h"
#include "amcdocmg.h"
#include "amc.h"        // for AMCGetApp
#include "filedlgex.h"


void AppendFilterSuffix(CString& filter, OPENFILENAME_NT4& ofn,
    CDocTemplate* pTemplate, CString* pstrDefaultExt);

/*--------------------------------------------------------------------------*
 * CAMCDocManager::DoPromptFileName
 *
 * We need to override this so we can set the default directory. The MFC
 * implementation lets the system choose the default, which due to a NT5.0
 * change, is not always the current directory. This implementation specifically
 * requests the current directory.
 *--------------------------------------------------------------------------*/

// This and the following method were copied from MFC sources because we needed
// to modify the internal handling of the file dialog options. The added code
// sections are commented (MMC change).

BOOL CAMCDocManager::DoPromptFileName(CString& fileName, UINT nIDSTitle, DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate)
{
    //
    // MMC change: Set the default directory (sets to admin tools the first time called)
    //
    CAMCApp* pApp = AMCGetApp();
    pApp->SetDefaultDirectory ();

    CFileDialogEx dlgFile(bOpenFileDialog);

    CString title;
    VERIFY(title.LoadString(nIDSTitle)); // this uses MFC's LoadString because that is where the string resides.

    dlgFile.m_ofn.Flags |= (lFlags | OFN_ENABLESIZING);

    CString strFilter;
    CString strDefault;
    if (pTemplate != NULL)
    {
        ASSERT_VALID(pTemplate);
        AppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate, &strDefault);
    }
    else
    {
        // do for all doc template
        POSITION pos = m_templateList.GetHeadPosition();
        BOOL bFirst = TRUE;
        while (pos != NULL)
        {
            CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
            AppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate,
                bFirst ? &strDefault : NULL);
            bFirst = FALSE;
        }
    }

    // append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER)); // this uses MFC's LoadString because that is where the string resides.
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.*");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    //
    // MMC change: Set the initial dir to the current dir
    //
    TCHAR szDir[_MAX_PATH];
    GetCurrentDirectory(countof(szDir), szDir);
    dlgFile.m_ofn.lpstrInitialDir = szDir;

    BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
    fileName.ReleaseBuffer();

    return bResult;
}



void AppendFilterSuffix(CString& filter, OPENFILENAME_NT4& ofn,
    CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
    ASSERT_VALID(pTemplate);
    ASSERT_KINDOF(CDocTemplate, pTemplate);

    CString strFilterExt, strFilterName;
    if (pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt) &&
     !strFilterExt.IsEmpty() &&
     pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
     !strFilterName.IsEmpty())
    {
        // a file based document template - add to filter list
        ASSERT(strFilterExt[0] == '.');
        if (pstrDefaultExt != NULL)
        {
            // set the default extension
            *pstrDefaultExt = ((LPCTSTR)strFilterExt) + 1;  // skip the '.'
            ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
            ofn.nFilterIndex = ofn.nMaxCustFilter + 1;  // 1 based number
        }

        // add to filter
        filter += strFilterName;
        ASSERT(!filter.IsEmpty());  // must have a file type name
        filter += (TCHAR)'\0';  // next string please
        filter += (TCHAR)'*';
        filter += strFilterExt;
        filter += (TCHAR)'\0';  // next string please
        ofn.nMaxCustFilter++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcdocmg.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      amcdocmg.h
 *
 *  Contents:  Interface file for CAMCDocManager
 *
 *  History:   01-Jan-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef AMCDOCMG_H
#define AMCDOCMG_H


class CAMCDocManager : public CDocManager
{
public:
    virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
            DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
};


#endif /* AMCDOCMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcnav.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcnav.h
//
//--------------------------------------------------------------------------

// amcnav.h : header file for class CAMCNavigator
//

#ifndef _AMCNAV_H_
#define _AMCNAV_H_
 
//
// Class for adding custom keyboard navigation to a view
// View should inherit from CView (or derived class)
// and CAMCNavigator.
// 
//

enum AMCNavDir
{
    AMCNAV_NEXT,
    AMCNAV_PREV
};

class CAMCNavigator 
{
public:
	virtual BOOL ChangePane(AMCNavDir eDir) = 0;
    virtual BOOL TakeFocus(AMCNavDir eDir) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcview.h
//
//--------------------------------------------------------------------------

// AMCView.h : interface of the CAMCView class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __AMCVIEW_H__
#define __AMCVIEW_H__


#ifndef __CONTROLS_H__
#include "controls.h"
#endif

// this is needed for inline CAMCView::GetScopeTreePtr below
#ifndef AMCDOC_H__
#include "amcdoc.h"
#endif

// this is needed for CAMCView::GetParentFrame below
#ifndef CHILDFRM_H
#include "childfrm.h"
#endif

#include "amcpriv.h"
#include "cclvctl.h"
#include "amcnav.h"
#include "conview.h"            // for CConsoleView

#include "treeobsv.h"
#include "stdbar.h"
#include "toolbar.h"

#define UNINIT_VALUE    -1      // Unitialised value
#define BORDERPADDING   4       // Some multiple that stops the splitter from
                                // being pushed into the right border

#define AMC_LISTCTRL_CLSID  _T("{1B3C1394-D68B-11CF-8C2B-00AA003CA9F6}")


// REVIEW embed this in the class so it's hidden
// NOTE struct added to protected section

// Forward declarations
class CAMCDoc;
class CAMCTreeView;
class CAMCGenericOcxCtrl;
class CAMCWebViewCtrl;
class CAMCView;
class CListViewSub;
class CCCListViewCtrl;
class COCXHostView;
class CHistoryList;
class CChildFrame;
class CViewTracker;
class CBookmark;
class CTaskPadHost;
class CMemento;
class CViewSettings;
class CFolderTabView;
class CMMCToolBar;
class CAMCViewToolbars;
class CStandardToolbar;

struct NMFOLDERTAB;

struct TRACKER_INFO;
struct SViewUpdateInfo;
typedef CList<HMTNODE, HMTNODE> CHMTNODEList;

#ifdef DBG
extern CTraceTag tagSplitterTracking;
#endif


//____________________________________________________________________________
//
//  class:      ViewSettings
//____________________________________________________________________________
//

class ViewSettings
{
public:
    struct ScopeSettings
    {
        int cxWidth;
        int cxMin;
    };
    explicit ViewSettings(CAMCView* v);
    ~ViewSettings()
    {
    }
    int GetViewID() const
    {
        return m_nViewID;
    }
    BOOL IsDescriptionbarVisible() const
    {
        return m_bDescriptionbarVisible;
    }
    int GetViewMode() const
    {
        return m_nViewMode;
    }
    long GetListViewStyle() const
    {
        return m_nListViewStyle;
    }
    const ScopeSettings& GetScopeSettings() const
    {
        return m_Scope;
    }
    BOOL IsScopePaneVisible() const
    {
        return m_bScopePaneVisible;
    }
    void GetDefaultColumnWidths(int w[2])
    {
        w[0] = m_DefaultColumnWidths[0];
        w[1] = m_DefaultColumnWidths[1];
    }
    long GetDefaultLVStyle()
    {
        return m_DefaultLVStyle;
    }
private:
    int m_nViewID;
    BOOL m_bDescriptionbarVisible;
    int m_nViewMode;
    long m_nListViewStyle;
    ScopeSettings m_Scope;
    BOOL m_bScopePaneVisible;
    long m_DefaultLVStyle;
    int m_DefaultColumnWidths[2];
};

/*+-------------------------------------------------------------------------*
 * class CAMCView
 *
 *
 * PURPOSE: The console view UI class
 *
 *+-------------------------------------------------------------------------*/
class CAMCView: public CView, public CConsoleView, public CTiedObject,
                public CXMLObject, public CEventSource<CAMCViewObserver>,
                public CTreeViewObserver, public CListViewActivationObserver,
                public COCXHostActivationObserver, public CAMCDocumentObserver,
                public CListViewObserver
{
    friend class CMainFrame;
    friend void CALLBACK TrackerCallback(TRACKER_INFO* pinfo, bool bAcceptChange, bool fSyncLayout);

    // Object model related
private:
    ViewPtr m_spView;
public:
    // View interface
    //#######################################################################
    //#######################################################################
    //
    //  Item and item collection related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_ActiveScopeNode( PPNODE   ppNode);
    SC      Scput_ActiveScopeNode( PNODE    pNode);
    SC      Scget_Selection(       PPNODES  ppNodes);
    SC      Scget_ListItems(       PPNODES  ppNodes);
    SC      ScSnapinScopeObject( VARIANT& varScopeNode, PPDISPATCH ScopeNodeObject);
    SC      ScSnapinSelectionObject( PPDISPATCH SelectedObject);

    //#######################################################################
    //#######################################################################

    SC      ScIs          (PVIEW pView, VARIANT_BOOL *pbTheSame);
    SC      Scget_Document( PPDOCUMENT ppDocument );

    //#######################################################################
    //#######################################################################
    //
    //  Selection changing methods
    //
    //#######################################################################
    //#######################################################################
    SC      ScSelectAll();
    SC      ScSelect(               PNODE   pNode);
    SC      ScDeselect(             PNODE   pNode);
    SC      ScIsSelected(           PNODE   pNode,  PBOOL pIsSelected);

    //#######################################################################
    //#######################################################################
    //
    //  Verb and selection related methods
    //
    //#######################################################################
    //#######################################################################
    SC      ScDisplayScopeNodePropertySheet(VARIANT& varScopeNode);
    SC      ScDisplaySelectionPropertySheet();
    SC      ScCopyScopeNode(        VARIANT& varScopeNode);
    SC      ScCopySelection();
    SC      ScDeleteScopeNode(      VARIANT& varScopeNode);
    SC      ScDeleteSelection();
    SC      ScRenameScopeNode(      BSTR    bstrNewName, VARIANT& varScopeNode);
    SC      ScRenameSelectedItem(   BSTR    bstrNewName);
    SC      Scget_ScopeNodeContextMenu( VARIANT& varScopeNode, PPCONTEXTMENU ppContextMenu, bool bMatchGivenNode = false);
    SC      Scget_SelectionContextMenu( PPCONTEXTMENU ppContextMenu);
    SC      ScRefreshScopeNode(      VARIANT& varScopeNode);
    SC      ScRefreshSelection();
    SC      ScExecuteSelectionMenuItem(BSTR MenuItemPath);
    SC      ScExecuteScopeNodeMenuItem(BSTR MenuItemPath, VARIANT& varScopeNode  /* = ActiveScopeNode */);
    SC      ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState);

    //#######################################################################
    //#######################################################################
    //
    //  Frame and view related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_Frame( PPFRAME ppFrame);
    SC      ScClose();
    SC      Scget_ScopeTreeVisible( PBOOL pbVisible );
    SC      Scput_ScopeTreeVisible( BOOL bVisible );
    SC      ScBack();
    SC      ScForward();
    SC      Scput_StatusBarText(BSTR StatusBarText);
    SC      Scget_Memento(PBSTR Memento);
    SC      ScViewMemento(BSTR Memento);

    //#######################################################################
    //#######################################################################
    //
    //  List related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_Columns( PPCOLUMNS Columns);
    SC      Scget_CellContents( PNODE Node,  long Column, PBSTR CellContents);
    SC      ScExportList( BSTR bstrFile, ExportListOptions exportoptions /* = ExportListOptions_Default*/);
    SC      Scget_ListViewMode( PLISTVIEWMODE pMode);
    SC      Scput_ListViewMode( ListViewMode mode);

    //#######################################################################
    //#######################################################################
    //
    //  ActiveX control related methods
    //
    //#######################################################################
    //#######################################################################
    SC      Scget_ControlObject( PPDISPATCH Control);

    // helper functions
    SC      ScGetOptionalScopeNodeParameter(VARIANT &varScopeNode, PPNODE ppNode, bool& bMatchedGivenNode);
    SC      ScExecuteMenuItem(PCONTEXTMENU pContextMenu, BSTR MenuItemPath);

    SC      ScGetMMCView(View **ppView);

    // Frame interface
    SC      ScMaximize ();
    SC      ScMinimize ();
    SC      ScRestore ();

    SC      Scget_Left ( LPINT pCoord );
    SC      Scput_Left ( INT coord );

    SC      Scget_Right ( LPINT pCoord);
    SC      Scput_Right ( INT coord );

    SC      Scget_Top  ( LPINT pCoord);
    SC      Scput_Top  ( INT coord );

    SC      Scget_Bottom ( LPINT pCoord);
    SC      Scput_Bottom ( INT coord );

    // Frame interface for the view extension hosted frame
    SC      ScSetViewExtensionFrame(bool bShowListView, INT top, INT left, INT bottom, INT right);

    // Frame int helpers

    enum    coord_t { LEFT, TOP, RIGHT, BOTTOM };
    SC      ScGetFrameCoord        (LPINT pCoord, coord_t eCoord );
    SC      ScSetFrameCoord        (INT coord,    coord_t eCoord );
    SC      ScGetRectCoord         (const RECT& rect, LPINT pCoord, coord_t eCoord );
    SC      ScSetRectCoord         (RECT& rect,       INT coord,    coord_t eCoord );

    // Node locating helpers (used from view control)
    SC      ScFindResultItemForScopeNode( PNODE pNode, HRESULTITEM &itm );
    SC      ScGetScopeNode( HNODE hNode,  PPNODE ppNode );

    SC      ScNotifySelect (INodeCallback* pCallback, HNODE hNode, bool fMultiSelect,
                            bool fSelect, SELECTIONINFO* pSelInfo);

protected: // create from serialization only
    CAMCView();
    DECLARE_DYNCREATE(CAMCView);

// Helper methods.
private:
    enum EListSaveErrorType  {LSaveReadOnly, LSaveCantCreate, LSaveCantWrite};
    bool Write2File(HANDLE hfile, TCHAR const * strwrite, int type);
    void ListSaveErrorMes(EListSaveErrorType etype, HANDLE hfile = NULL, LPCTSTR lpFileName = NULL);
    SC   ScExportListWorker();
    SC   ScGetExportListFile (CString& strFileName, bool& bUnicode,
                              bool& bTabDelimited, bool& bSelectedRowsOnly);
    SC   ScCreateExportListFile(const CString& strFileName, bool bUnicode,
                                bool bShowErrorDialogs, HANDLE& hFile);
    SC   ScWriteExportListData (const CString& strFileName, bool bUnicode,
                                bool bTabDelimited, bool bSelectedRowsOnly,
                                bool bShowErrorDialogs = true);

    SC ScUpdateStandardbarMMCButtons();
    void SetScopePaneVisible(bool bVisible);


   // tree observer methods
    virtual SC ScOnItemDeselected(HNODE hNode);
    virtual SC ScOnTreeViewActivated ();

    // ListViewActivationObserver methods.
    virtual SC ScOnListViewActivated ();
    virtual SC ScOnListViewItemUpdated (int nIndex); // called when an item is updated

    // OCX or Web HostActivationObserver mthods.
    virtual SC ScOnOCXHostActivated ();

    // AMCDoc observer
    virtual SC  ScDocumentLoadCompleted (CAMCDoc *pDoc);

// Persistence related methods.
public:
    DEFINE_XML_TYPE(XML_TAG_VIEW);
    virtual void Persist(CPersistor& persistor);

    // Loads all of the local data previously saved by Save().  Restores
    // the window to the original state.
    // Returns true if the data and window state is successfully restored.
    bool Load(IStream& stream);

    bool IsDirty();
    void SetDirty (bool bDirty = true)
    {
        m_bDirty = bDirty;
//      m_pDocument->SetModifiedFlag (bDirty);
    }

// Information set and get methods
public:
    // Enum types for args
    // NOTE: Enum values are relevant!
    enum EUIStyleType   {uiClientEdge,uiNoClientEdge};

    CAMCDoc* GetDocument();
    CHistoryList* GetHistoryList() { return m_pHistoryList; }

    void GetPaneInfo(ViewPane ePane, int* pcxCur,int* pcxMin);
    void SetPaneInfo(ViewPane ePane, int cxCur, int cxMin);

    CView* GetPaneView(ViewPane ePane);

    // what's in the view?
    bool HasList            () const        { return m_ViewData.HasList();            }
    bool HasOCX             () const        { return m_ViewData.HasOCX();             }
    bool HasWebBrowser      () const        { return m_ViewData.HasWebBrowser();      }
    bool HasListPad         () const;
    bool HasListOrListPad   () const;

    DWORD GetListOptions() const            { return m_ViewData.GetListOptions();}
    DWORD GetHTMLOptions() const            { return m_ViewData.GetHTMLOptions();}
    DWORD GetOCXOptions()  const            { return m_ViewData.GetOCXOptions();}
    DWORD GetMiscOptions() const            { return m_ViewData.GetMiscOptions();}

    CDescriptionCtrl& GetRightDescCtrl(void) { return m_RightDescCtrl; }

    BOOL IsVerbEnabled(MMC_CONSOLE_VERB verb);

    void GetDefaultColumnWidths(int columnWidth[2]);
    void SetDefaultColumnWidths(int columnWidth[2], BOOL fUpdate = TRUE);

    CStandardToolbar* GetStdToolbar() const;

    INodeCallback*  GetNodeCallback();    // returns a reference to view's callback interface
    IScopeTreeIter* GetScopeIterator();   // returns a reference to view's scope tree interator
    IScopeTree*     GetScopeTree();       // returns a reference to scope tree

    friend ViewSettings;
    void            GetTaskpadID(GUID &guidID);
    ViewSettings* GetViewSettings()
    {
        ViewSettings* pVS = new ViewSettings(this);
        ASSERT(pVS != NULL);
        return pVS;
    }

    CAMCTreeView* GetTreeCtrl() { return m_pTreeCtrl; }
    void SetUsingDefColumns(bool bDefColumns) { m_bDefColumns = bDefColumns; }
    bool UsingDefColumns() { return m_bDefColumns; }

    bool IsScopePaneVisible(void) const;

    UINT GetViewID(void);
    void SetViewID(UINT id) { m_nViewID = m_ViewData.m_nViewID = id; }

    SViewData* GetViewData() { return &m_ViewData; }
    bool IsVirtualList()  { return (m_ViewData.IsVirtualList()); }

    bool AreStdToolbarsAllowed() const
    {
        return !(m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOTOOLBARS);
    }
    bool IsScopePaneAllowed() const
    {
        return !(m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOSCOPEPANE);
    }

    bool HasCustomTitle() const
    {
        return (m_ViewData.m_lWindowOptions & MMC_NW_OPTION_CUSTOMTITLE);
    }
    bool IsPersisted() const
    {
        return (!(m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOPERSIST) &&
                !m_fRootedAtNonPersistedDynamicNode);
    }

    bool IsAuthorModeView() const
    {
        return m_bAuthorModeView;
    }

    void SetAuthorModeView(bool fAuthorMode)
    {
        m_bAuthorModeView = fAuthorMode;
    }

    static CAMCView* CAMCView::GetActiveView();
        // Returns the most recently activated CAMCView.

    bool IsTracking() const;

    long GetDefaultListViewStyle() const;
    void SetDefaultListViewStyle(long style);

    int GetViewMode() const;

private:
    BOOL IsSelectingNode() { return (m_nSelectNestLevel > 0); }

    SC   ScSpecialResultpaneSelectionActivate(bool bActivate);
    SC   ScTreeViewSelectionActivate(bool bActivate);
    SC   ScListViewSelectionActivate(bool bActivate);

    bool CanInsertScopeItemInResultPane();

// Operations
public:
    SC  ScUpdateWindowTitle();
    SC  ScActivate();
    SC  ScOnMinimize(bool fMinimized);
    SC  ScOnSize(UINT nType, int cx, int cy);

    SC  ScApplyViewExtension (LPCTSTR pszURL);


    // Scope Pane : Tree View.
    UINT GetTreeItem(CHMTNODEList* pNodeList, HTREEITEM* phItem);
    HTREEITEM FindChildNode(HTREEITEM hti, DWORD dwItemDataKey);
    HTREEITEM FindHTreeItem(HMTNODE hMTNode, HTREEITEM htiFirst);
    BOOL QueryForReName(TV_DISPINFO* ptvdi, LRESULT* pResult);
    void SetRootNode(HMTNODE hMTNode);
    HNODE GetRootNode(void);
    HRESULT GetNodePath(HTREEITEM hti, HTREEITEM htiRoot, CBookmark* pbm);
    HRESULT GetRootNodePath(CBookmark* pbm);
    HRESULT GetSelectedNodePath(CBookmark* pbm);
    void SelectNode(MTNODEID ID, GUID &guidTaskpad);

    // Result Pane.
    SC   ScInitDefListView(LPUNKNOWN pUnkResultsPane);
    SC   ScAddDefaultColumns();
    SC   ScOnSelectNode(HNODE hNode, BOOL &bAddSubFolders);
    SC   ScSetResultPane(HNODE hNode, CResultViewType rvt, int viewMode, bool bUsingHistory);


    SC   ScGetProperty(int iIndex, BSTR bstrPropertyName, PBSTR pbstrPropertyValue);
    SC   ScGetNodetype(int iIndex, PBSTR Nodetype);

    LPUNKNOWN GetPaneUnknown(ViewPane ePane);
    void OpenResultItem(HNODE hNode);
    BOOL OnListCtrlItemDblClk(void);
    BOOL DispatchListCtrlNotificationMsg(LPARAM lParam, LRESULT* pResult);
    BOOL CreateListCtrl(int nID, CCreateContext* pContext);
    void SetListViewOptions(DWORD dwListOptions);
    SC   ScAttachListViewAsResultPane();
    SC   ScAttachWebViewAsResultPane();
    SC   ScAttachOCXAsResultPane(HNODE hNode);
    void ShowResultPane(CView * pWnd, EUIStyleType nStyle);
    long GetListViewStyle();
    CView* GetResultView () const;
    void SetListViewMultiSelect(BOOL bMultiSelect);
    bool CanDoDragDrop();
    void DeSelectResultPane(HNODE hNodeSel);
    HRESULT NotifyListPad (BOOL b);

    // General (both) view related.
    LPCTSTR GetWindowTitle(void);
    BOOL RenameItem(HNODE hNode, BOOL bScopeItem, MMC_COOKIE lResultItemCookie, LPWSTR pszText, LRESULT* pResult);
    void CloseView();
    void DeleteView();

    // REVIEW int's are not enum!
    void SetPane(ViewPane ePane, CView* pView, EUIStyleType nStyle=uiClientEdge);

    bool DeflectActivation (BOOL fActivate, CView* pDeactivatingView);
    void SetChildFrameWnd(HWND m_hChildFrameWnd);
    void SetPaneFocus();
    void SetPaneWithFocus(UINT pane);

    SC   ScDeferSettingFocusToResultPane();
    SC   ScSetFocusToResultPane();

    // Other helpers.
    void OnActionMenu(CPoint pt, LPCRECT prcExclude);
    void OnViewMenu(CPoint pt, LPCRECT prcExclude);
    void OnFavoritesMenu(CPoint point, LPCRECT prcExclude);
    void UpdateSnapInHelpMenus(CMenu* pMenu);
    void OnRefresh();
    void OnUpdatePasteBtn();

    SC ScShowScopePane (bool fShow, bool fForce = false);
    SC ScConsoleVerb (int nVerb);
    SC ScProcessConsoleVerb (HNODE hNode, bool bScope, LPARAM lResultCookie, int nVerb);

    SC ScUpOneLevel                 ();
    SC ScWebCommand                 (WebCommand eCommand);

    void OnEmptyAddToCArray(CObject*);

    SC   ScUpdateMMCMenus();

    // Columns helpers
    SC   ScColumnInfoListChanged(const CColumnInfoList& colInfoList);
    SC   ScGetPersistedColumnInfoList(CColumnInfoList *pColInfoList);
    SC   ScDeletePersistedColumnData();

    /*
     * Message Handlers.
     */

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCView)
public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnInitialUpdate();
protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL
    virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );


// Generated message map functions
protected:
    //{{AFX_MSG(CAMCView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint pt);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnDestroy();
    afx_msg void OnUpdateFileSnapinmanager(CCmdUI* pCmdUI);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnNextPane();
    afx_msg void OnPrevPane();
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg void OnContextHelp();
    afx_msg void OnSnapInHelp();
    afx_msg void OnSnapinAbout();
    afx_msg void OnHelpTopics();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnPaletteChanged(CWnd* pwndFocus);
    afx_msg BOOL OnQueryNewPalette( );
    afx_msg void OnSysColorChange();
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG

    // keep these outside the AFX_MSG markers so ClassWizard won't munge them
    afx_msg void OnUpdateNextPane(CCmdUI* pCmdUI);
    afx_msg void OnUpdatePrevPane(CCmdUI* pCmdUI);
    afx_msg void OnUpdateShiftF10(CCmdUI* pCmdUI);
    afx_msg void OnVerbAccelKey(UINT nID);
    afx_msg void OnShiftF10();

    afx_msg void OnAmcNodeNew(UINT nID);
    afx_msg void OnAmcNodeNewUpdate(CCmdUI* pCmdUI);
    afx_msg void OnDrawClipboard();
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LRESULT OnProcessMultiSelectionChanges(WPARAM, LPARAM);
    afx_msg LRESULT OnJiggleListViewFocus (WPARAM, LPARAM);
    afx_msg LRESULT OnDeferRecalcLayout (WPARAM, LPARAM);
    afx_msg LRESULT OnConnectToCIC (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnConnectToTPLV(WPARAM wParam, LPARAM lParam)   {return ScOnConnectToTPLV(wParam, lParam).ToHr();}
    SC              ScOnConnectToTPLV(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnShowWebContextMenu (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetDescriptionBarText (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetIconInfoForSelectedNode(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAppCommand(WPARAM wParam, LPARAM lParam);

    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);

    // result based tabs.
    afx_msg void    OnChangedResultTab(NMHDR *nmhdr, LRESULT *pRes);

public:
    DECLARE_MESSAGE_MAP()

// Implementation
public:
    virtual ~CAMCView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    int                     m_nSelectNestLevel;
    UINT                    m_nViewID;
    HMTNODE                 m_hMTNode;              // root node for this view
    IScopeTreeIterPtr       m_spScopeTreeIter;      // view's iterator to scope tree
    INodeCallbackPtr        m_spNodeCallback;       // view's callback interface
    bool                    m_bAuthorModeView;      // Saved in author mode (user can't close)

    bool                    m_bDefColumns;
    long                    m_DefaultLVStyle;
    int                     m_columnWidth[2];


    // Last selection
    bool                    m_bLastSelWasMultiSel;

    enum eCurrentActivePane
    {
        eActivePaneNone,   // No pane is active.
        eActivePaneScope,
        eActivePaneResult,
    };

    eCurrentActivePane      m_eCurrentActivePane; // Tells if scope or result was the active pane.

    // Check for sel-change data
    bool                    m_bProcessMultiSelectionChanges;

    CDescriptionCtrl     m_RightDescCtrl; // control bar embedded members

    IScopeTree* GetScopeTreePtr();
        // The document may release the scope tree without notifying the view.
        // The view should always go through this function to obtain a pointer
        // to the the scope tree.

private:
    HNODE m_ListPadNode;
    int  m_iFocusedLV;
    bool m_bLVItemSelected;
    int  m_nReleaseViews;


// Attributes
protected:

    //---------------------------------------------------------------------
    // NOTE: ePane_Tasks is defined to have a pane identifier for the
    // task view pane. Currently no task view information is stored
    // in the pane info array, so the use of ePane_Tasks as an index is
    // of limited value.
    //----------------------------------------------------------------------

    // Pane information implementation structure
    struct PaneInfo
    {
        CView*  pView;          // Pointer to the view
        int     cx;             // 0 means hidden
        int     cxIdeal;        // user set size or size before hidden
        int     cxMin;          // below that try not to show
    };


    // child window IDs
    enum
    {
        /*
         * Bug 344422: these IDs should be maintained for compatibility
         * with automated tests
         */
        IDC_TreeView       = 12785,
        IDC_ListView       = 12786,
        IDC_GenericOCXCtrl = 12787,
        IDC_WebViewCtrl    = 12788,

        IDC_OCXHostView,
        IDC_TaskView,
        IDC_RightDescBar,
        IDC_TaskpadTitle,
        IDC_ListCaption,
        IDC_ResultTabCtrl,
        IDC_ViewExtensionView,
    };


    // Pointers to actual controls
    CAMCTreeView *          m_pTreeCtrl;            // Tree control
    CCCListViewCtrl *       m_pListCtrl;            // Default list control
    CAMCWebViewCtrl *       m_pWebViewCtrl;         // Private web view control
    CAMCWebViewCtrl *       m_pViewExtensionCtrl;   // Private web view control for view extensions
    COCXHostView *          m_pOCXHostView;         // host for OCX's
    CFolderTabView *        m_pResultFolderTabView;

    // current state information
    PaneInfo        m_PaneInfo[ePane_Count];       // Array of panes
    int             m_nViewMode;                   // current listview mode for all node that use listviews in this view
    bool            m_bRenameListPadItem;

protected:
    CChildFrame* GetParentFrame() const;

    void SetDescBarVisible(bool b)
        { m_ViewData.SetDescBarVisible (b); }

    bool IsDescBarVisible(void) const
        { return m_ViewData.IsDescBarVisible(); }

    void SetStatusBarVisible(bool bVisible)
    {
        if (bVisible)
            m_ViewData.m_dwToolbarsDisplayed |=  STATUS_BAR;
        else
            m_ViewData.m_dwToolbarsDisplayed &= ~STATUS_BAR;
    }

    bool IsStatusBarVisible(void) const
        { return ((m_ViewData.m_dwToolbarsDisplayed & STATUS_BAR) != 0); }

    void SetTaskpadTabsAllowed(bool b)
        { m_ViewData.SetTaskpadTabsAllowed(b); }

    bool AreTaskpadTabsAllowed(void) const
        { return m_ViewData.AreTaskpadTabsAllowed(); }

    // implementation attributes which control layout of the splitter
    static const CSize  m_sizEdge;             // 3-D edge
    static const int    m_cxSplitter;          // amount of space between panes

    // splitter bar and hit test enums
    enum ESplitType     {splitBox, splitBar, splitIntersection, splitBorder};
    enum HitTestValue {hitNo, hitSplitterBox, hitSplitterBar};

    bool m_bDirty;
    HTREEITEM m_htiStartingSelectedNode;

    bool m_fRootedAtNonPersistedDynamicNode;
    bool m_fSnapinDisplayedHelp;
    bool m_fActivatingSpecialResultPane;
    bool m_fViewExtended;

    HTREEITEM m_htiCut;

// implementation routines
public:
    void AdjustTracker (int cx, int cy);

    void SaveStartingSelectedNode();
    bool HasNodeSelChanged();

    // layout methods
    void DeferRecalcLayout(bool fUseIdleTaskQueue = true, bool bArrangeIcons = false);
    void RecalcLayout(void);
    void LayoutResultFolderTabView  (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutScopePane            (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutResultPane           (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutResultDescriptionBar (CDeferWindowPos& dwp,       CRect& rectRemaining);
    void LayoutResultView           (CDeferWindowPos& dwp, const CRect& rectRemaining);

public:
    // CConsoleView methods
    virtual SC ScCut                        (HTREEITEM htiCut);
    virtual SC ScPaste                      ();
    virtual SC ScToggleStatusBar            ();
    virtual SC ScToggleDescriptionBar       ();
    virtual SC ScToggleScopePane            ();
    virtual SC ScToggleTaskpadTabs          ();
    virtual SC ScContextHelp                ();
    virtual SC ScHelpTopics                 ();
    virtual SC ScShowSnapinHelpTopic        (LPCTSTR pszTopic);
    virtual SC ScSaveList                   ();
    virtual SC ScGetFocusedItem             (HNODE& hNode, LPARAM& lCookie, bool& fScope);
    virtual SC ScSetFocusToPane             (ViewPane ePane);
    virtual SC ScSelectNode                 (MTNODEID id, bool bSelectExactNode = false); // Select the given node.
    virtual SC ScExpandNode                 (MTNODEID id, bool fExpand, bool fExpandVisually);
    virtual SC ScShowWebContextMenu         ();
    virtual SC ScSetDescriptionBarText      (LPCTSTR pszDescriptionText);
    virtual SC ScViewMemento                (CMemento* pMemento);
    virtual SC ScChangeViewMode             (int nNewMode);
    virtual SC ScJiggleListViewFocus        ();
    virtual SC ScRenameListPadItem          ();
    virtual SC ScOrganizeFavorites          (); // bring up the "Organize Favorites" dialog.
    virtual SC ScLineUpIcons                (); // line up the icons in the list
    virtual SC ScAutoArrangeIcons           (); // auto arrange the icons in the list
    virtual SC ScOnRefresh                  (HNODE hNode, bool bScope, LPARAM lResultItemParam); // refreshes the view
    virtual SC ScOnRename                   (CContextMenuInfo *pContextInfo); // allows the user to rename the specified item
    virtual SC ScRenameScopeNode            (HMTNODE hMTNode); // put the specified scope node into rename mode.
    virtual SC ScGetStatusBar               (CConsoleStatusBar **ppStatusBar);
    virtual SC ScAddViewExtension           (const CViewExtensionData& ved);


    virtual ViewPane GetFocusedPane         ();
    virtual int      GetListSize            ();
    virtual HNODE    GetSelectedNode        ();
    virtual HWND     CreateFavoriteObserver (HWND hwndParent, int nID);

private:
    /*
     * CDeferredLayout - deferred layout object
     */
    class CDeferredLayout : public CIdleTask
    {
    public:
        CDeferredLayout(CAMCView* pAMCView);
       ~CDeferredLayout();

        // IIdleTask methods
        SC ScDoWork();
        SC ScGetTaskID(ATOM* pID);
        SC ScMerge(CIdleTask* pitMergeFrom);

        bool Attach (CAMCView* pwndAMCView);

    private:
        typedef std::set<HWND>  WindowCollection;

        WindowCollection    m_WindowsToLayout;
        const ATOM          m_atomTask;
    };

protected:
    // Tracking and and hit testing methods
    int HitTestPane(CPoint& pointTreeCtrlCoord);

    void OnTreeContextMenu(CPoint& point, CPoint& pointTreeCtrlCoord, HTREEITEM htiRClicked);
    void OnListContextMenu(CPoint& point);
    void OnContextMenuForTreeItem(int iIndex, HNODE hNode, CPoint& point,
                          DATA_OBJECT_TYPES type_of_pane = CCT_SCOPE,
                          HTREEITEM htiRClicked = NULL,
                          MMC_CONTEXT_MENU_TYPES eMenuType = MMC_CONTEXT_MENU_DEFAULT,
                          LPCRECT prcExclude = NULL,
                          bool bAllowDefaultItem = true);
    void OnContextMenuForListItem(int iIndex, HRESULTITEM hHitTestItem,
                                  CPoint& point,
                                  MMC_CONTEXT_MENU_TYPES eMenuType = MMC_CONTEXT_MENU_DEFAULT,
                                  LPCRECT prcExclude = NULL,
                                  bool bAllowDefaultItem = true);

// Internal functions and data
private:
    UINT ClipPath(CHMTNODEList* pNodeList, POSITION& rpos, HNODE hNode);
    SC   ScInitializeMemento(CMemento &memento);
    void OnAddToFavorites();
    void OnAdd(SViewUpdateInfo *pvui);
    void OnUpdateSelectionForDelete(SViewUpdateInfo* pvui);
    void OnDelete(SViewUpdateInfo *pvui);
    void OnModify(SViewUpdateInfo *pvui);
    void OnUpdateTaskpadNavigation(SViewUpdateInfo *pvui);
    void ChangePane(AMCNavDir eDir);
    int _GetLVItemData(LPARAM *lParam, UINT flags);
    int _GetLVSelectedItemData(LPARAM *lParam);
    int _GetLVFocusedItemData(LPARAM *lParam);
    HRESULT SendGenericNotify(NCLBK_NOTIFY_TYPE nclbk);
    void IdentifyRootNode();

    void CalcMaxHostedFrameRect (CRect& rect);
    void MapViewPtToHostedFramePt (CPoint& pt);
    void MapHostedFramePtToViewPt (CPoint& pt);
    void PointMapperWorker (CPoint& pt, bool fViewToHostedFrame);

    SC   ScOnLeftOrRightMouseClickInListView();
    bool OnListItemChanged  (NM_LISTVIEW* pnmlv);
    int  OnVirtualListItemsStateChanged(LPNMLVODSTATECHANGE lpStateChange );
    SC   ScPostMultiSelectionChangesMessage();

    SC ScCompleteInitialization();


    HMTNODE GetHMTNode(HTREEITEM hti);
    BOOL OwnsResultList(HTREEITEM hti);

    void OnContextMenuForTreeBackground(CPoint& point, LPCRECT prcExclude = NULL, bool bAllowDefaultItem = true);
    void ArrangeIcon(long style);

    void PrivateChangeListViewMode(int nMode);
    BOOL CommonListViewUpdate()
    {
        if (!HasList())
            return FALSE;

        if (m_pListCtrl == NULL)
        {
            TRACE(_T("View is supposed to be a listview but the member is NULL!"));
            ASSERT(FALSE);
            return FALSE;
        }
        return TRUE;
    }

    //LRESULT OnLVDeleteKeyPressed(WPARAM wParam, LPARAM lParam);
    LRESULT HandleLVMessage(UINT message, WPARAM wParam, LPARAM lParam);
    BOOL OnSharedKeyDown(WORD mVKey);


    CView* CreateView (CCreateContext* pContext, int nID, DWORD dwStyle);
    bool CreateView (int nID);
    bool CreateFolderCtrls();
    SC   ScCreateToolbarObjects ();

    typedef std::vector<TREEITEMID> TIDVector;
    void AddFavItemsToCMenu(CMenu& menu, CFavorites* pFavs, TREEITEMID tid, TIDVector& vItemIDs);
    SC   ScHelpWorker (LPCTSTR pszHelpTopic);

    SC   ScGetSelectedLVItem(LPARAM& lvData);
    SC   ScGetHNodeFromPNode(const PNODE& pNode, HNODE& hNode);

    SC   ScExecuteScopeItemVerb (MMC_CONSOLE_VERB verb, VARIANT& varScopeNode, BSTR bstrNewName);
    SC   ScExecuteResultItemVerb(MMC_CONSOLE_VERB verb, BSTR bstrNewName);

    SC   ScAddFolderTabs( HNODE hNode , const CLSID& tabToSelect );

    SC   ScCreateTaskpadHost(); // for snapin taskpads

private:
    CString         m_strWindowTitle;
    SViewData       m_ViewData;
    CRect           m_rectResultFrame;
    CRect           m_rectVSplitter;

    CHistoryList*   m_pHistoryList;
    CViewTracker*   m_pTracker;

    ITaskPadHostPtr m_spTaskPadHost;
    FramePtr        m_spFrame;
    FramePtr        m_spViewExtFrame; // a frame pointer for the internal view extension hosted frame containing the primary snapin's view.

    // Toolbars related to this view.
    CRefCountedObject<CAMCViewToolbars>::SmartPtr  m_spAMCViewToolbars;
    std::auto_ptr<CStandardToolbar>   m_spStandardToolbar;

    // map with view extension URL addresses
    typedef std::map<GUID, tstring> CViewExtensionURLs;
    CViewExtensionURLs m_ViewExtensionURLs;

private:
    /*
     * private, registered window messages
     */
    static const UINT m_nShowWebContextMenuMsg;
    static const UINT m_nProcessMultiSelectionChangesMsg;
    static const UINT m_nJiggleListViewFocusMsg;
    static const UINT m_nDeferRecalcLayoutMsg;
};

#ifndef _DEBUG  // debug version in AMCView.cpp
inline CAMCDoc* CAMCView::GetDocument()
{
    return (CAMCDoc*)m_pDocument;
}
#endif


CAMCView* GetAMCView (CWnd* pwnd);

/*+-------------------------------------------------------------------------*
 * class CViewTemplateList
 *
 *
 * PURPOSE: Used as the helper to persist CAMCView objects, when loading
 *          Since CAMCView need small ammount of data to be known prior to
 *          creating it (and thus prior to persisting CAMCView),
 *          we persist a CViewTemplateList to collect all data.
 *          Afterwards we create views using that list and persist them
 *
 *+-------------------------------------------------------------------------*/
class CViewTemplateList : public XMLListCollectionBase
{
public:
    // defines data to be stored as std::pair objects
    typedef std::pair< CBookmark, CPersistor > ViewTemplB_Type;
    typedef std::pair< int /*nViewID*/, ViewTemplB_Type > ViewTempl_Type;
    // defines collection to be used for storing data about views
    typedef std::vector< ViewTempl_Type > List_Type;

    // creator must provide a XML type
    CViewTemplateList(LPCTSTR strXmlType) : m_strXmlType(strXmlType) {}

    // accessory to get the list of gathered data
    inline List_Type& GetList()  { return m_ViewsList; }

    // Pesistence staff used from CPersistor
    virtual void Persist(CPersistor& persistor);
    virtual void OnNewElement(CPersistor& persistor);
    virtual LPCTSTR GetXMLType() { return m_strXmlType; }
private:
    List_Type   m_ViewsList;
    LPCTSTR     m_strXmlType;
};

/*+-------------------------------------------------------------------------*
 * class CXMLWindowPlacement
 *
 *
 * PURPOSE: class persists WINDOWPLACEMENT to xml
 *
 *+-------------------------------------------------------------------------*/
class CXMLWindowPlacement : public CXMLObject
{
    WINDOWPLACEMENT& m_rData;
public:
    CXMLWindowPlacement(WINDOWPLACEMENT& rData) : m_rData(rData) {}
protected:
    DEFINE_XML_TYPE(XML_TAG_WINDOW_PLACEMENT);
    virtual void    Persist(CPersistor &persistor);
};

#include "amcview.inl"

#endif // __AMCVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\atlconui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      atlconui.h
//
//  Contents:  Support for ATL in an MFC project
//
//  History:   15-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------
#include <atlbase.h>
// We can implement the MFC/ATL lock count interaction in two different ways
// (you may comment/uncomment the one you want to try)

// ATL can blindly delegate all the ATL Lock()/Unlock() calls to MFC
/*
class CAtlGlobalModule : public CComModule
{
public:
    LONG Lock()
    {
        AfxOleLockApp();
        return 0;
    }
    LONG Unlock()
    {
        AfxOleUnlockApp();
        return 0;
    }
};
*/


#ifdef DBG
extern CTraceTag tagATLLock;
#endif

class CAtlGlobalModule : public CComModule
{
public:
    LONG Lock()
    {
        LONG l = CComModule::Lock();
        Trace(tagATLLock, TEXT("Lock:   count = %d"), l);
        return l;
    }
    LONG Unlock()
    {
        LONG l = CComModule::Unlock();
        Trace(tagATLLock, TEXT("Unlock: count = %d"), l);
        return l;
    }
};

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CAtlGlobalModule _Module;
#include <atlcom.h>


// Needed because MFC creates a macro for this which ATL doesn't like.                     
#undef SubclassWindow

#undef WM_OCC_LOADFROMSTREAM          
#undef WM_OCC_LOADFROMSTORAGE         
#undef WM_OCC_INITNEW                 
#undef WM_OCC_LOADFROMSTREAM_EX       
#undef WM_OCC_LOADFROMSTORAGE_EX      

// This prevents the ATL activeX host from locking the app.
#define _ATL_HOST_NOLOCK

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>
#include <sitebase.h>
#include <axhostwindow2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\archpicker.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      archpicker.cpp
 *
 *  Contents:  Implementation file for CArchitecturePicker
 *
 *  History:   1-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

// ArchPicker.cpp : implementation file
//

#include "stdafx.h"

#ifdef _WIN64		// this class is only required on 64-bit platforms

#include "amc.h"
#include "ArchPicker.h"

//#ifdef _DEBUG
//#define new DEBUG_NEW
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#endif

/////////////////////////////////////////////////////////////////////////////
// CArchitecturePicker dialog


/*+-------------------------------------------------------------------------*
 * CArchitecturePicker::CArchitecturePicker
 *
 * Constructs a CArchitecturePicker object.
 *--------------------------------------------------------------------------*/

CArchitecturePicker::CArchitecturePicker (
	CString					strFilename,		// I:name of console file
	CAvailableSnapinInfo&	asi64,				// I:available 64-bit snap-ins
	CAvailableSnapinInfo&	asi32,				// I:available 32-bit snap-ins
	CWnd*					pParent /*=NULL*/)	// I:dialog's parent window
	:	CDialog       (CArchitecturePicker::IDD, pParent),
		m_asi64       (asi64),
		m_asi32       (asi32),
		m_strFilename (strFilename),
		m_eArch       (eArch_64bit)
{
	//{{AFX_DATA_INIT(CArchitecturePicker)
	//}}AFX_DATA_INIT

	ASSERT (!asi64.m_f32Bit);
	ASSERT ( asi32.m_f32Bit);
}


void CArchitecturePicker::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArchitecturePicker)
	DDX_Control(pDX, IDC_SnapinList64, m_wndSnapinList64);
	DDX_Control(pDX, IDC_SnapinList32, m_wndSnapinList32);
	//}}AFX_DATA_MAP

	DDX_Radio(pDX, IDC_64Bit, reinterpret_cast<int&>(m_eArch));
}


BEGIN_MESSAGE_MAP(CArchitecturePicker, CDialog)
	//{{AFX_MSG_MAP(CArchitecturePicker)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArchitecturePicker message handlers

BOOL CArchitecturePicker::OnInitDialog()
{
	/*
	 * these must be consecutive and match the order of radio buttons on
	 * the dialog
	 */
	ASSERT (eArch_64bit == 0);
	ASSERT (eArch_32bit == 1);
	ASSERT (GetNextDlgGroupItem(GetDlgItem(IDC_64Bit))                 != NULL);
	ASSERT (GetNextDlgGroupItem(GetDlgItem(IDC_64Bit))->GetDlgCtrlID() == IDC_32Bit);

	/*
	 * if there are more 32-bit snap-ins than 64-bit snap-ins, default
	 * to running 32-bit; otherwise, default to running 64-bit
	 * (do this before calling CDialog::OnInitDialog so the state of
	 * the radio button will be set correctly when CDialog::OnInitDialog
	 * calls UpdateData)
	 */
	if (m_asi32.m_vAvailableSnapins.size() > m_asi64.m_vAvailableSnapins.size())
		m_eArch = eArch_32bit;
	
	CDialog::OnInitDialog();

	/*
	 * put the filename on the dialog
	 */
	SetDlgItemText (IDC_ConsoleFileName, m_strFilename);

	/*
	 * put formatted messages in the info windows
	 */
	FormatMessage (IDC_SnapinCount64, m_asi64);
	FormatMessage (IDC_SnapinCount32, m_asi32);

	/*
	 * populate the lists
	 */
	PopulateList (m_wndSnapinList64, m_asi64);
	PopulateList (m_wndSnapinList32, m_asi32);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/*+-------------------------------------------------------------------------*
 * CArchitecturePicker::FormatMessage
 *
 * Retrieves the format text from the given control, formats the message
 * with the information contained in the given CArchitecturePicker, and
 * replaces the text in the control with the result.
 *--------------------------------------------------------------------------*/

void CArchitecturePicker::FormatMessage (
	UINT					idControl,		/* I:control to update			*/
	CAvailableSnapinInfo&	asi)			/* I:data to use in formatting	*/
{
	DECLARE_SC (sc, _T("CArchitecturePicker::FormatMessage"));

	/*
	 * get the control
	 */
	CWnd* pwnd = GetDlgItem (idControl);
	if (pwnd == NULL)
	{
		sc.FromLastError();
		return;
	}

	/*
	 * get the format string from the control
	 */
	CString strFormat;
	pwnd->GetWindowText (strFormat);

	/*
	 * format the text
	 */
	CString strText;
	strText.FormatMessage (strFormat, asi.m_vAvailableSnapins.size(), asi.m_cTotalSnapins);

	/*
	 * put the text in the window
	 */
	pwnd->SetWindowText (strText);
}


/*+-------------------------------------------------------------------------*
 * CArchitecturePicker::PopulateList
 *
 * Puts the names of each snap-in in asi into the given list control.
 *--------------------------------------------------------------------------*/

void CArchitecturePicker::PopulateList (
	CListCtrl&				wndList,		/* I:control to update			*/
	CAvailableSnapinInfo&	asi)			/* I:data to use in formatting	*/
{
	/*
	 * put a single, full-width column in the list
	 */
	CRect rect;
	wndList.GetClientRect (rect);
	int cxColumn = rect.Width() - GetSystemMetrics (SM_CXVSCROLL);
	wndList.InsertColumn (0, NULL, LVCFMT_LEFT, cxColumn);

	/*
	 * Give the list the imagelist.  The imagelist is owned by the
	 * CAvailableSnapinInfo, so make sure the list has LVS_SHAREIMAGELISTS
	 * so it won't delete the image list when it's destroyed.
	 */
	ASSERT (wndList.GetStyle() & LVS_SHAREIMAGELISTS);
	wndList.SetImageList (CImageList::FromHandle (asi.m_himl), LVSIL_SMALL);

	/*
	 * put each item in the list
	 */
	std::vector<CBasicSnapinInfo>::iterator it;

	for (it  = asi.m_vAvailableSnapins.begin();
		 it != asi.m_vAvailableSnapins.end();
		 ++it)
	{
		wndList.InsertItem (-1, it->m_strName.data(), it->m_nImageIndex);
	}
}


#endif	// _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\archpicker.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      archpicker.h
 *
 *  Contents:  Interface file for CArchitecturePicker
 *
 *  History:   1-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_ARCHPICKER_H__4502E3CD_5EB7_4708_A765_8DAF3D03773F__INCLUDED_)
#define AFX_ARCHPICKER_H__4502E3CD_5EB7_4708_A765_8DAF3D03773F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ArchPicker.h : header file
//

enum eArchitecture
{
	eArch_64bit,	// force 64-bit version to run
	eArch_32bit,	// force 32-bit version to run
	eArch_Any,		// any architecture is acceptable
	eArch_None,		// no architecture is acceptable (i.e. abort)
};

#ifdef _WIN64		// this class is only required on 64-bit platforms

class CAvailableSnapinInfo;


/////////////////////////////////////////////////////////////////////////////
// CArchitecturePicker dialog

class CArchitecturePicker : public CDialog
{
// Construction
public:
	CArchitecturePicker(
		CString					strFilename,		// I:name of console file
		CAvailableSnapinInfo&	asi64,				// I:available 64-bit snap-ins
		CAvailableSnapinInfo&	asi32,				// I:available 32-bit snap-ins
		CWnd*					pParent = NULL);	// I:dialog's parent window

	eArchitecture GetArchitecture() const	{ return (m_eArch); }

// Dialog Data
	//{{AFX_DATA(CArchitecturePicker)
	enum { IDD = IDD_ArchitecturePicker };
	CListCtrl	m_wndSnapinList64;
	CListCtrl	m_wndSnapinList32;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArchitecturePicker)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CArchitecturePicker)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void FormatMessage (UINT idControl,     CAvailableSnapinInfo& asi);
	void PopulateList  (CListCtrl& wndList, CAvailableSnapinInfo& asi);

private:
	CAvailableSnapinInfo&	m_asi64;
	CAvailableSnapinInfo&	m_asi32;
	CString					m_strFilename;
	eArchitecture			m_eArch;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif	// _WIN64

#endif // !defined(AFX_ARCHPICKER_H__4502E3CD_5EB7_4708_A765_8DAF3D03773F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcview.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      amcview.inl
 *
 *  Contents:  Inline functions for CAMCView class.
 *
 *  History:   29-Oct-99 AnandhaG     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef AMCVIEW_INL
#define AMCVIEW_INL
#pragma once

//+-------------------------------------------------------------------
//
//  Member:      SetScopePaneVisible
//
//  Synopsis:    Sets the flag in the view data that indicates whether
//               the scope pane is visible or not.  The window is
//               physically shown by ScShowScopePane.
//
//  Arguments:   [bVisible]        -
//
//  Returns:     None
//
//--------------------------------------------------------------------
inline void CAMCView::SetScopePaneVisible(bool bVisible)
{
    /*
     * we should only be marking the scope pane visible if it is
     * allowed on this view
     */
    ASSERT (!bVisible || IsScopePaneAllowed());
    m_ViewData.SetScopePaneVisible (bVisible);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::IsScopePaneVisible
 *
 * Returns true if the scope pane is visible in this view, false otherwise
 *--------------------------------------------------------------------------*/

inline bool CAMCView::IsScopePaneVisible(void) const
{
    bool fVisible = m_ViewData.IsScopePaneVisible();

    /*
     * the scope pane should only be visible if it is
     * permitted on this view
     */
    ASSERT (IsScopePaneAllowed() || !fVisible);

    return (fVisible);
}


//+-------------------------------------------------------------------
//
//  Member:      SetRootNode
//
//  Synopsis:    Set the root node.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::SetRootNode(HMTNODE hMTNode)
{
    ASSERT(hMTNode != 0);
    ASSERT(m_hMTNode == 0);
    m_hMTNode = hMTNode;

}

//+-------------------------------------------------------------------
//
//  Member:      GetNodeCallback
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline INodeCallback*  CAMCView::GetNodeCallback()
{
    return m_spNodeCallback;
}

//+-------------------------------------------------------------------
//
//  Member:      GetScopeIterator
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline IScopeTreeIter* CAMCView::GetScopeIterator()
{
    return m_spScopeTreeIter;
}

//+-------------------------------------------------------------------
//
//  Member:      DeleteView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::DeleteView()
{
    GetParentFrame()->PostMessage(WM_SYSCOMMAND, SC_CLOSE, 0);
}

//+-------------------------------------------------------------------
//
//  Member:      GetScopeTreePtr
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Note:       The document may release the scope tree without
//              notifying the view. The view should always go
//              through this function to obtain a pointer to the
//              the scope tree.
//
//--------------------------------------------------------------------
inline IScopeTree* CAMCView::GetScopeTreePtr()
{
    CAMCDoc* const pDoc = GetDocument();
    ASSERT(pDoc);
    if (!pDoc)
        return NULL;
    IScopeTree* const pScopeTree = pDoc->GetScopeTree();
    return pScopeTree;
}

//+-------------------------------------------------------------------
//
//  Member:      GetScopeTree
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline IScopeTree* CAMCView::GetScopeTree()
{
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    return pScopeTree;
}

//+-------------------------------------------------------------------
//
//  Member:      SetChildFrameWnd
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::SetChildFrameWnd(HWND hwndChildFrame)
{
    if (hwndChildFrame == NULL || !::IsWindow(hwndChildFrame))
    {
        ASSERT(FALSE); // Invalid Arguments
        return;
    }

    m_ViewData.m_hwndChildFrame = hwndChildFrame;
}

//+-------------------------------------------------------------------
//
//  Member:      GetParentFrame
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline CChildFrame* CAMCView::GetParentFrame () const
{
    CChildFrame* pFrame = dynamic_cast<CChildFrame*>(CView::GetParentFrame());
    ASSERT (pFrame != NULL);
    ASSERT_VALID (pFrame);
    ASSERT_KINDOF (CChildFrame, pFrame);

    return (pFrame);
}

//+-------------------------------------------------------------------
//
//  Member:      IsTracking
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline bool CAMCView::IsTracking () const
{
    return (m_pTracker != NULL);
}


//+-------------------------------------------------------------------
//
//  Member:      IsVerbEnabled
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline BOOL CAMCView::IsVerbEnabled(MMC_CONSOLE_VERB verb)
{
    BOOL bFlag = FALSE;
    if (m_ViewData.m_spVerbSet != NULL)
    {
        HRESULT hr = m_ViewData.m_spVerbSet->GetVerbState(verb, ENABLED, &bFlag);
        if (FAILED(hr))
            bFlag = FALSE;
    }
    return bFlag;
}

//+-------------------------------------------------------------------
//
//  Member:      GetDefaultColumnWidths
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::GetDefaultColumnWidths(int columnWidth[2])
{
    columnWidth[0] = m_columnWidth[0];
    columnWidth[1] = m_columnWidth[1];
}


//+-------------------------------------------------------------------
//
//  Member:      SetDefaultColumnWidths
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
inline void CAMCView::SetDefaultColumnWidths(int columnWidth[2], BOOL fUpdate)
{
    // Bug 157408:  remove the "Type" column for static nodes
    columnWidth[1] = 0;

    m_columnWidth[0] = columnWidth[0];
    m_columnWidth[1] = columnWidth[1];

    if (fUpdate == TRUE && m_pListCtrl != NULL)
    {
        CListCtrl& lc = m_pListCtrl->GetListCtrl();

        lc.SetColumnWidth(0, m_columnWidth[0]);
        lc.SetColumnWidth(1, m_columnWidth[1]);
    }

    SetDirty();
}

//+-------------------------------------------------------------------
//
//  Member:      GetDefaultListViewStyle
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline long CAMCView::GetDefaultListViewStyle() const
{
    return m_DefaultLVStyle;
}

//+-------------------------------------------------------------------
//
//  Member:      SetDefaultListViewStyle
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline void CAMCView::SetDefaultListViewStyle(long style)
{
    m_DefaultLVStyle = style;
}

//+-------------------------------------------------------------------
//
//  Member:      GetViewMode
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline int CAMCView::GetViewMode() const
{
    return m_nViewMode;
}

//+-------------------------------------------------------------------
//
//  Member:      CanDoDragDrop
//
//  Synopsis:    if there are posted messages for multiselection changes
//               to be processed then do not do drag&drop.
//
//--------------------------------------------------------------------
inline bool CAMCView::CanDoDragDrop()
{
    if (m_pListCtrl && m_pListCtrl->IsListPad())
        return false;
    return !m_bProcessMultiSelectionChanges;
}


//+-------------------------------------------------------------------
//
//  Member:      HasListOrListPad
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline bool CAMCView::HasListOrListPad() const
{
    return (HasList() || HasListPad());
}


//+-------------------------------------------------------------------
//
//  Member:      HasListPad
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline bool CAMCView::HasListPad() const
{
    if (m_pListCtrl)
        return m_pListCtrl->IsListPad();

    return false;
}

//+-------------------------------------------------------------------
//
//  Member:      GetStdToolbar
//
//  Synopsis:
//
//--------------------------------------------------------------------
inline CStandardToolbar* CAMCView::GetStdToolbar() const
{
    return dynamic_cast<CStandardToolbar*>(m_ViewData.GetStdVerbButtons());
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScColumnInfoListChanged
//
//  Synopsis:    The column-info-list (width/order/hiddeness) for currently
//               selected node has changed ask nodemgr to persist the new data.
//
//  Arguments:   [colInfoList] - new data
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCView::ScColumnInfoListChanged (const CColumnInfoList& colInfoList)
{
    DECLARE_SC(sc, _T("CAMCView::ScColumnInfoListChanged"));

    INodeCallback* spNodeCallback = GetNodeCallback();
    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers(spNodeCallback, hNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = spNodeCallback->SaveColumnInfoList(hNode, colInfoList);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetPersistedColumnInfoList
//
//  Synopsis:    The list-view requests the column-data (no sort data) to setup the headers
//               before any items are inserted into the list-view. Forward this
//               request to nodemgr.
//
//  Arguments:   [pColInfoList] - [out param]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCView::ScGetPersistedColumnInfoList (CColumnInfoList *pColInfoList)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetPersistedColumnInfoList"));

    INodeCallback* spNodeCallback = GetNodeCallback();
    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers(spNodeCallback, hNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = spNodeCallback->GetPersistedColumnInfoList(hNode, pColInfoList);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDeletePersistedColumnData
//
//  Synopsis:    The column data for currently selected node is invalid,
//               ask nodemgr to remove it.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CAMCView::ScDeletePersistedColumnData ()
{
    DECLARE_SC(sc, _T("CAMCView::ScDeletePersistedColumnData"));

    INodeCallback* spNodeCallback = GetNodeCallback();
    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers(spNodeCallback, hNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = spNodeCallback->DeletePersistedColumnData(hNode);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CanInsertScopeItemInResultPane
//
//  Synopsis:    Can we insert child scope items of currently selected scope
//               item in the listview.
//
//--------------------------------------------------------------------
inline bool CAMCView::CanInsertScopeItemInResultPane()
{
    // Can insert only if
    // a) it is a non-virtual result list,
    // b) Don't add the item if a node select is in progress
    //    because the tree control will automatically add all
    //    scope items as part of the select procedure.
    // c) view-option to exclude scope items in result pane is not specified.

    return (!IsVirtualList() && !IsSelectingNode() && !(GetListOptions() & RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST) );
}


#endif  // AMCVIEW_INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\amcview.cpp ===
// AMCView.cpp : implementation of the CAMCView class
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amcview.cpp
//
//  Contents:  Base view implementation for all console views
//             Also include splitter window implementation (Horizontal Splitter)
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Added code to switch views and split them
//
//--------------------------------------------------------------------------
// NOTE:
// MMC starting from version 1.1 had a code which allowed to copy the view
// settings from one view to another and thus the created view would look
// the same. AMCDoc was used as temporary storage for those settings.
// But the code was NEVER used; hence was not tested and not up-to-date.
// Switching to XML persistence would require essential changes to that code,
// and at this time we cannot afford using it.
// If in the future we decide to support the feature, someone needs to look at
// MMC 1.2 sources and bring the code back. Today the code is removed from
// active sources.
// audriusz. 3/29/2000
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"
#include "Mainfrm.h"
#include "HtmlHelp.h"

#include "websnk.h"
#include "WebCtrl.h"        // AMC Private implementation of the web view control
#include "CClvCtl.h"        // List view control
#include "ocxview.h"
#include "histlist.h"       // history list

#include "AMCDoc.h"         // AMC Console Document
#include "AMCView.h"
#include "childfrm.h"

#include "TreeCtrl.h"       // AMC Implementation of the Tree Control
#include "TaskHost.h"

#include "util.h"           // GUIDFromString, GUIDToString
#include "AMCPriv.h"
#include "guidhelp.h" // ExtractObjectTypeGUID
#include "amcmsgid.h"
#include "cclvctl.h"
#include "vwtrack.h"
#include "cmenuinfo.h"

#ifdef IMPLEMENT_LIST_SAVE  // See nodemgr.idl (t-dmarm)
#include "svfildlg.h"       // Save File Dialog
#endif

#include "macros.h"
#include <mapi.h>
#include <mbstring.h>       // for _mbslen

#include "favorite.h"
#include "favui.h"

#include "ftab.h"

#include "toolbar.h"
#include "menubtns.h"       // UpdateFavorites menu.
#include "stdbar.h"         // Standard toolbar.
#include "variant.h"
#include "rsltitem.h"
#include "scriptevents.h" // for IMenuItemEvents

extern "C" UINT dbg_count = 0;

enum
{
    ITEM_IS_PARENT_OF_ROOT,
    ITEM_NOT_IN_VIEW,
    ITEM_IS_IN_VIEW,
};

enum EIndex
{
    INDEX_INVALID        = -1,
    INDEX_BACKGROUND     = -2,
    INDEX_MULTISELECTION = -3,
    INDEX_OCXPANE        = -4,
    INDEX_WEBPANE        = -5,
};

enum ScopeFolderItems
{
    SFI_TREE_TAB         = 1,
    SFI_FAVORITES_TAB    = 2
};


const UINT CAMCView::m_nShowWebContextMenuMsg           = ::RegisterWindowMessage (_T("CAMCView::ShowWebContextMenu"));
const UINT CAMCView::m_nProcessMultiSelectionChangesMsg = ::RegisterWindowMessage (_T("CAMCView::OnProcessMultiSelectionChanges"));
const UINT CAMCView::m_nJiggleListViewFocusMsg          = ::RegisterWindowMessage (_T("CAMCView::JiggleListViewFocus"));
const UINT CAMCView::m_nDeferRecalcLayoutMsg            = ::RegisterWindowMessage (_T("CAMCView::DeferRecalcLayout"));


void CALLBACK TrackerCallback(TRACKER_INFO& info, bool bAcceptChange, bool bSyncLayout);
void GetFullPath(CAMCTreeView &ctc, HTREEITEM hti, CString &strPath);
BOOL PtInWindow(CWnd* pWnd, CPoint pt);


#ifdef DBG
CTraceTag  tagLayout            (_T("CAMCView"),    _T("Layout"));
CTraceTag  tagSplitterTracking  (_T("CAMCView"),    _T("Splitter tracking"));
CTraceTag  tagListSelection     (_T("Result list"), _T("Selection"));
CTraceTag  tagViewActivation    (_T("View Activation"), _T("View Activation"));
#endif


/*+-------------------------------------------------------------------------*
 * CAMCView::ScNotifySelect
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScNotifySelect (
    INodeCallback*      pCallback,
    HNODE               hNode,
    bool                fMultiSelect,
    bool                fSelect,
    SELECTIONINFO*      pSelInfo)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScNotifySelect"));

    // parameter check
    sc = ScCheckPointers(pCallback);
    if (sc)
        return sc;

    // pSelInfo can be NULL only for multi-select.
    if (!pSelInfo && !fMultiSelect)
        return (sc = E_INVALIDARG);

#ifdef DBG
    Trace (tagListSelection, _T("%s (fSelect=%s, pwnd=0x%08x)"),
           (fMultiSelect) ? _T("NCLBK_MULTI_SELECT") : _T("NCLBK_SELECT"),
           (fSelect) ? _T("true") : _T("false"),
           static_cast<CWnd *>(this));
#endif

    // we want this error (not a failure to broadcast the event) to be returned,
    // so cache it and assign before return
    SC sc_notify = (pCallback->Notify (hNode, fMultiSelect ? NCLBK_MULTI_SELECT :NCLBK_SELECT,
                                     fSelect, reinterpret_cast<LPARAM>(pSelInfo)));

    // fire event whenever the selection changes, but not if
    //  its a background hit or loss of focus
    if(fMultiSelect ||
       (pSelInfo->m_bBackground == FALSE && (fSelect == TRUE || pSelInfo->m_bDueToFocusChange == FALSE)))
    {
        sc = ScFireEvent(CAMCViewObserver::ScOnResultSelectionChange, this);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }

    sc = sc_notify;
    return sc;
}


/*+-------------------------------------------------------------------------*
 * GetAMCView
 *
 * Returns the CAMCView window for any child of CChildFrame.
 *--------------------------------------------------------------------------*/

CAMCView* GetAMCView (CWnd* pwnd)
{
    /*
     * get the input window's parent frame window
     */
    CWnd* pFrame = pwnd->GetParentFrame();

    /*
     * if we couldn't find a parent frame, or that parent frame isn't
     * of type CChildFrame, fail
     */
    if ((pFrame == NULL) || !pFrame->IsKindOf (RUNTIME_CLASS (CChildFrame)))
        return (NULL);

    /*
     * get the first view of the frame window
     */
    CWnd* pView = pFrame->GetDlgItem (AFX_IDW_PANE_FIRST);

    /*
     * if we can't find a window with the right ID, or the one we find
     * isn't of type CAMCView, fail
     */
    if ((pView == NULL) || !pView->IsKindOf (RUNTIME_CLASS (CAMCView)))
        return (NULL);

    return (dynamic_cast<CAMCView*>(pView));
}


//############################################################################
//############################################################################
//
//  Implementation of class CMMCView
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CMMCView
 *
 *
 * PURPOSE: The COM 0bject that exposes the View interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCView :
    public CTiedComObject<CAMCView>,
    public CMMCIDispatchImpl<View>
{
    typedef CAMCView CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CMMCView)
    END_MMC_COM_MAP()

public:
    //#######################################################################
    //#######################################################################
    //
    //  Item and item collection related methods
    //
    //#######################################################################
    //#######################################################################

    MMC_METHOD1(get_ActiveScopeNode,    PPNODE);
    MMC_METHOD1(put_ActiveScopeNode,    PNODE);
    MMC_METHOD1(get_Selection,          PPNODES);
    MMC_METHOD1(get_ListItems,          PPNODES);
    MMC_METHOD2(SnapinScopeObject,    VARIANT,    PPDISPATCH);
    MMC_METHOD1(SnapinSelectionObject,    PPDISPATCH);

    //#######################################################################
    //#######################################################################

    MMC_METHOD2(Is,                     PVIEW,  VARIANT_BOOL *);
    MMC_METHOD1(get_Document,           PPDOCUMENT);

    //#######################################################################
    //#######################################################################
    //
    //  Selection changing methods
    //
    //#######################################################################
    //#######################################################################
    MMC_METHOD0(SelectAll);
    MMC_METHOD1(Select,                 PNODE);
    MMC_METHOD1(Deselect,               PNODE);
    MMC_METHOD2(IsSelected,             PNODE,      PBOOL);

    //#######################################################################
    //#######################################################################
    //
    //  Verb and selection related methods
    //
    //#######################################################################
    //#######################################################################
    MMC_METHOD1(DisplayScopeNodePropertySheet,      VARIANT);
    MMC_METHOD0(DisplaySelectionPropertySheet);
    MMC_METHOD1(CopyScopeNode,          VARIANT);
    MMC_METHOD0(CopySelection);
    MMC_METHOD1(DeleteScopeNode,        VARIANT);
    MMC_METHOD0(DeleteSelection);
    MMC_METHOD2(RenameScopeNode,        BSTR,       VARIANT);
    MMC_METHOD1(RenameSelectedItem,     BSTR);
    MMC_METHOD2(get_ScopeNodeContextMenu,VARIANT,   PPCONTEXTMENU);
    MMC_METHOD1(get_SelectionContextMenu,PPCONTEXTMENU);
    MMC_METHOD1(RefreshScopeNode,        VARIANT);
    MMC_METHOD0(RefreshSelection);
    MMC_METHOD1(ExecuteSelectionMenuItem, BSTR /*MenuItemPath*/);
    MMC_METHOD2(ExecuteScopeNodeMenuItem, BSTR /*MenuItemPath*/, VARIANT /*varScopeNode  = ActiveScopeNode */);
    MMC_METHOD4(ExecuteShellCommand,      BSTR /*Command*/,      BSTR /*Directory*/, BSTR /*Parameters*/, BSTR /*WindowState*/);

    //#######################################################################
    //#######################################################################
    //
    //  Frame and view related methods
    //
    //#######################################################################
    //#######################################################################

    MMC_METHOD1(get_Frame,              PPFRAME);
    MMC_METHOD0(Close);
    MMC_METHOD1(get_ScopeTreeVisible,   PBOOL);
    MMC_METHOD1(put_ScopeTreeVisible,   BOOL);
    MMC_METHOD0(Back);
    MMC_METHOD0(Forward);
    MMC_METHOD1(put_StatusBarText,      BSTR);
    MMC_METHOD1(get_Memento,            PBSTR);
    MMC_METHOD1(ViewMemento,            BSTR);


    //#######################################################################
    //#######################################################################
    //
    //  List related methods
    //
    //#######################################################################
    //#######################################################################

    MMC_METHOD1(get_Columns,            PPCOLUMNS);
    MMC_METHOD3(get_CellContents,       PNODE,       long,           PBSTR);
    MMC_METHOD2(ExportList,             BSTR, ExportListOptions);
    MMC_METHOD1(get_ListViewMode,       PLISTVIEWMODE);
    MMC_METHOD1(put_ListViewMode,       ListViewMode);

    //#######################################################################
    //#######################################################################
    //
    //  ActiveX control related methods
    //
    //#######################################################################
    //#######################################################################
    MMC_METHOD1(get_ControlObject,      PPDISPATCH);

};


/*
 * WM_APPCOMMAND is only defined in winuser.h if _WIN32_WINNT >= 0x0500.
 * We need these definitions, but can't use _WIN32_WINNT==0x0500 (yet).
 */

#ifndef WM_APPCOMMAND
    #define WM_APPCOMMAND                   0x0319
    #define APPCOMMAND_BROWSER_BACKWARD       1
    #define APPCOMMAND_BROWSER_FORWARD        2
    #define APPCOMMAND_BROWSER_REFRESH        3

    #define FAPPCOMMAND_MOUSE 0x8000
    #define FAPPCOMMAND_KEY   0
    #define FAPPCOMMAND_OEM   0x1000
    #define FAPPCOMMAND_MASK  0xF000

    #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#endif  // WM_APPCOMMAND



//############################################################################
//############################################################################
//
//  Implementation of class CAMCView
//
//############################################################################
//############################################################################
IMPLEMENT_DYNCREATE(CAMCView, CView);

BEGIN_MESSAGE_MAP(CAMCView, CView)
    //{{AFX_MSG_MAP(CAMCView)
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_CREATE()
    ON_WM_SETFOCUS()
    ON_WM_CONTEXTMENU()
    ON_WM_DESTROY()
    ON_UPDATE_COMMAND_UI(ID_FILE_SNAPINMANAGER, OnUpdateFileSnapinmanager)
    ON_WM_SHOWWINDOW()
    ON_COMMAND(ID_MMC_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_MMC_PREV_PANE, OnPrevPane)
    ON_WM_SETCURSOR()
    ON_COMMAND(ID_MMC_CONTEXTHELP, OnContextHelp)
    ON_COMMAND(ID_HELP_SNAPINHELP, OnSnapInHelp)
    ON_COMMAND(ID_SNAPIN_ABOUT, OnSnapinAbout)
    ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpTopics)
    ON_WM_SIZE()
    ON_WM_SYSKEYDOWN()
    ON_WM_PALETTECHANGED()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_DRAWCLIPBOARD()
    ON_WM_SETTINGCHANGE()
    ON_WM_MENUSELECT()
    //}}AFX_MSG_MAP

    // keep this outside the AFX_MSG_MAP markers so ClassWizard doesn't munge it
    ON_COMMAND_RANGE(ID_MMC_CUT, ID_MMC_PRINT, OnVerbAccelKey)

    // WARNING: If your message handler has void return use ON_MESSAGE_VOID !!
    ON_MESSAGE(MMC_MSG_CONNECT_TO_CIC, OnConnectToCIC)
    ON_MESSAGE(MMC_MSG_CONNECT_TO_TPLV, OnConnectToTPLV)
    ON_MESSAGE(MMC_MSG_GET_ICON_INFO, OnGetIconInfoForSelectedNode)
    ON_MESSAGE(WM_APPCOMMAND, OnAppCommand)

    ON_REGISTERED_MESSAGE (m_nShowWebContextMenuMsg,  OnShowWebContextMenu)
    ON_REGISTERED_MESSAGE (m_nProcessMultiSelectionChangesMsg,   OnProcessMultiSelectionChanges)
    ON_REGISTERED_MESSAGE (m_nJiggleListViewFocusMsg, OnJiggleListViewFocus)
    ON_REGISTERED_MESSAGE (m_nDeferRecalcLayoutMsg,   OnDeferRecalcLayout)

    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)

    ON_NOTIFY(FTN_TABCHANGED, IDC_ResultTabCtrl, OnChangedResultTab)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCView construction/destruction

const CSize CAMCView::m_sizEdge          (GetSystemMetrics (SM_CXEDGE),
                                          GetSystemMetrics (SM_CYEDGE));

const int   CAMCView::m_cxSplitter = 3;


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnMenuSelect
//
//  Synopsis:    Handles WM_MENUSELECT for Favorites menu.
//
//  Arguments:   [nItemID] - the resource id of menu item.
//               [nFlags]  - MF_* flags
//
//  Returns:     none
//
//--------------------------------------------------------------------
void CAMCView::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnMenuSelect"));

    CMainFrame* pFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pFrame, E_UNEXPECTED);
    if (sc)
        return;

    // Pass onto the mainframe.
    return pFrame->OnMenuSelect(nItemID, nFlags, hSysMenu);
}


CAMCView::CAMCView() :
        m_pResultFolderTabView(new CFolderTabView(this))       // dynamically allocated for decoupling
{
    TRACE_CONSTRUCTOR(CAMCView);

    // Init pointer members to NULL
    m_nViewID                          = 0;
    m_pTreeCtrl                        = NULL;
    m_pListCtrl                        = NULL;
    m_pWebViewCtrl                     = NULL;
    m_pViewExtensionCtrl               = NULL;
    m_pOCXHostView                     = NULL;
    m_nSelectNestLevel                 = 0;

    // if the view is a listview, then this member define what the view
    // mode is for all snapins with that view.

    m_nViewMode                        = LVS_REPORT; // REVIEW: Must we persist this - ravi

    // REVIEW consider moving the above initialzation to the InitSplitter
    // CommonConstruct
    // NOTE moved code from InitSplitter into the contructor and deleted InitSplitter

    // Default values for view.  User can set these values with SetPaneInfo;
    m_PaneInfo[ePane_ScopeTree].pView   = NULL;
    m_PaneInfo[ePane_ScopeTree].cx      = -1;
    m_PaneInfo[ePane_ScopeTree].cxMin   = 50;

    m_PaneInfo[ePane_Results].pView     = NULL;
    m_PaneInfo[ePane_Results].cx        = -1;
    m_PaneInfo[ePane_Results].cxMin     = 50;

    m_pTracker                         = NULL;

    m_rectResultFrame                  = g_rectEmpty;
    m_rectVSplitter                    = g_rectEmpty;

//  m_fDontPersistOCX                  = FALSE;

    // root node for the view
    m_hMTNode                          = 0;

    // Bug 157408:  remove the "Type" column for static nodes
//  m_columnWidth[0]                   = 90;
//  m_columnWidth[1]                   = 50;
    m_columnWidth[0]                   = 200;
    m_columnWidth[1]                   = 0;

    m_iFocusedLV                       = -1;
    m_bLVItemSelected                  = FALSE;
    m_DefaultLVStyle                   = 0;

    m_bProcessMultiSelectionChanges    = false;

    m_htiCut                           = NULL;
    m_nReleaseViews                    = 0;
    m_htiStartingSelectedNode          = NULL;
    m_bLastSelWasMultiSel              = false;
    m_eCurrentActivePane               = eActivePaneNone;

    m_fRootedAtNonPersistedDynamicNode = false;
    m_fSnapinDisplayedHelp             = false;
    m_fActivatingSpecialResultPane     = false;
    m_bDirty                           = false;
    m_fViewExtended                    = false;

    m_pHistoryList                     = new CHistoryList (this);
    m_ListPadNode                      = NULL;

    /*
     * Bug 103604: Mark this as an author mode view if it was created in
     * author mode.  If we're loading a user mode console file, it will
     * have author mode views and possibly some views that were created
     * in user mode, but this code will mark all of the views as non-author
     * mode views.  CAMCView::Persist will fix that.
     */
    CAMCApp* pApp = AMCGetApp();
    if (pApp != NULL)
        m_bAuthorModeView = (pApp->GetMode() == eMode_Author);
    else
        m_bAuthorModeView = true;
}

CAMCView::~CAMCView()
{
    TRACE_DESTRUCTOR(CAMCView);

    // Delete all pointer members. (C++ checks to see if they are NULL before deleting)
    // The standard ~CWnd destructor will call DestroyWindow()

    // REVIEW set the pointers to NULL after deleting them
    // Note Done

    // CViews "delete this" in PostNcDestroy, no need to delete here
    //delete m_pTreeCtrl;
    m_pTreeCtrl = NULL;

    m_pListCtrl->Release();
    m_pListCtrl = NULL;

    /*
     * DONT_DELETE_VIEWS
     *
     * CViews "delete this" in PostNcDestroy, no need to delete
     * here if the web view control is derived from CView.  See
     * AttachWebViewAsResultPane (search for "DONT_DELETE_VIEWS")
     * for the ASSERTs that make sure this code is right.
     */
    //delete m_pWebViewCtrl;
    //m_pWebViewCtrl = NULL;

    /*
     * CViews "delete this" in PostNcDestroy, no need to delete here
     */
    m_pOCXHostView = NULL;
    m_pResultFolderTabView = NULL;

    if (m_ViewData.m_spNodeManager != NULL)
        m_ViewData.m_spNodeManager->CleanupViewData(
                                reinterpret_cast<LONG_PTR>(&m_ViewData));

    ASSERT (m_ViewData.m_pMultiSelection == NULL);

    delete m_pHistoryList;

    // First destroy the IControlbarsCache as snapins call CAMCViewToolbars
    // to cleanup toolbars before the CAMCViewToolbars itself gets destroyed.
    m_ViewData.m_spControlbarsCache = NULL;

    // (UI cleanup) release toolbars related to this view.
    m_spAMCViewToolbars = NULL;
    m_spStandardToolbar = std::auto_ptr<CStandardToolbar>(NULL);

    //m_spStandardToolbar = NULL;
    //m_spAMCViewToolbars = NULL;
}



//############################################################################
//############################################################################
//
//  CAMCView: Object model methods - View Interface
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetOptionalScopeNodeParameter
 *
 * PURPOSE: Helper function - returns the scope node pointer, if supplied
 *          in the variant, or the Active Scope node pointer, if not
 *          supplied.
 *
 * PARAMETERS:
 *    VARIANT  varScopeNode : The parameter, which can be empty. NOTE: This is a
 *                  reference, so we don't need to call VariantClear on it.
 *    PPNODE   ppNode :
 *    bool& bMatchedGivenNode: If true the returned ppNode corresponds to the given node
 *                            applies only if given node is in bookmark format.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetOptionalScopeNodeParameter(VARIANT &varScopeNode, PPNODE ppNode, bool& bMatchedGivenNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetOptionalScopeNodeParameter"));

    sc = ScCheckPointers(ppNode);
    if(sc)
        return sc;

    // init the out parameter
    *ppNode = NULL;
    bMatchedGivenNode = true;

    // supply the optional parameter if it is missing
    if(IsOptionalParamMissing(varScopeNode))
    {
        sc = Scget_ActiveScopeNode(ppNode);
        return sc;
    }

    VARIANT* pvarTemp = ConvertByRefVariantToByValue(&varScopeNode);
    sc = ScCheckPointers(pvarTemp,E_UNEXPECTED);
    if(sc)
        return sc;

    bool bByReference = ( VT_BYREF == (V_VT(pvarTemp) & VT_BYREF) ); // value passed by reference
    UINT uiVarType = (V_VT(pvarTemp) & VT_TYPEMASK); // get variable type (strip flags)


    if(uiVarType == VT_DISPATCH) // do we have a dispatch interface.
    {
        IDispatchPtr spDispatch = NULL;

        if(bByReference)      // a reference, use ppDispVal
            spDispatch = *(pvarTemp->ppdispVal);
        else
            spDispatch = pvarTemp->pdispVal;  // passed by value, use pDispVal

        sc = ScCheckPointers(spDispatch.GetInterfacePtr());
        if(sc)
            return sc;

        // at this point spDispatch is correctly set. QI for Node from it.

        NodePtr spNode = spDispatch;
        if(spNode == NULL)
            return (sc = E_INVALIDARG);

        *ppNode = spNode.Detach(); // keep the reference.
    }
    else if(uiVarType == VT_BSTR)
    {
        // Name: get string properly ( see if it's a reference )
        LPOLESTR lpstrBookmark = bByReference ? *(pvarTemp->pbstrVal) : pvarTemp->bstrVal;

        // get the bookmark
        CBookmark bm;
        sc = bm.ScLoadFromString(lpstrBookmark);
        if(sc)
            return sc;

        if(!bm.IsValid())
            return (sc = E_UNEXPECTED);

        IScopeTree* const pScopeTree = GetScopeTreePtr();
        sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
        if(sc)
            return sc;

        NodePtr spNode;

        // Need a bool variable to find if exact match is found or not, cannot return
        // MMC specific error codes from nodemgr to conui.
        bMatchedGivenNode = false;
        sc = pScopeTree->GetNodeFromBookmark( bm, this, ppNode, bMatchedGivenNode);
        if(sc)
            return sc;
    }
    else
        return (sc = E_INVALIDARG);


    // we should have a valid node at this point.
    if(!ppNode)
        return (sc = E_UNEXPECTED);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ActiveScopeNode
 *
 * PURPOSE: Implements get method for Wiew.ActiveScopeNode property
 *
 * PARAMETERS:
 *    PPNODE ppNode - resulting node
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ActiveScopeNode( PPNODE ppNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ActiveScopeNode"));

    // checking parameters
    sc= ScCheckPointers(ppNode);
    if (sc)
        return sc;

    // get selected node
    HNODE hNode = GetSelectedNode();
    sc= ScCheckPointers((LPVOID)hNode, E_FAIL);
    if (sc)
        return sc;

    // get node callback
    INodeCallback* pNodeCallBack = GetNodeCallback();
    sc= ScCheckPointers(pNodeCallBack, E_FAIL);
    if (sc)
        return sc;

    // now get an HMTNODE
    HMTNODE hmtNode = NULL;
    sc = pNodeCallBack->GetMTNode(hNode, &hmtNode);
    if (sc)
        return sc;

    // geting pointer to scope tree
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc= ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // map to PNODE
    sc = pScopeTree->GetMMCNode(hmtNode, ppNode);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CExpandSyncModeLock
 *
 * PURPOSE: constructing the object of this class locks MMC in syncronous
 *          expansion mode (node expansion will send MMCN_EXPANDSYNC to snapin)
 *          destructor of the class restores the previous mode
 *
\***************************************************************************/
class CExpandSyncModeLock
{
    IScopeTreePtr m_spScopeTree;
    bool          m_fSyncExpandWasRequired;
public:
    CExpandSyncModeLock( IScopeTree *pScopeTree ) : m_spScopeTree(pScopeTree),
                                                    m_fSyncExpandWasRequired(false)
    {
        ASSERT( m_spScopeTree != NULL );
        if ( m_spScopeTree )
        {
            m_fSyncExpandWasRequired = (m_spScopeTree->IsSynchronousExpansionRequired() == S_OK);
            m_spScopeTree->RequireSynchronousExpansion (true);
        }
    }

    ~CExpandSyncModeLock()
    {
        if ( m_spScopeTree )
        {
            m_spScopeTree->RequireSynchronousExpansion ( m_fSyncExpandWasRequired );
        }
    }
};

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scset_ActiveScopeNode
 *
 * PURPOSE: Implements set method for Wiew.ActiveScopeNode property
 *
 * PARAMETERS:
 *    PNODE pNode - node to activate
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_ActiveScopeNode( PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_ActiveScopeNode"));

    // checking parameters
    sc= ScCheckPointers(pNode);
    if (sc)
        return sc;

    // geting pointer to scope tree
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc= ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // Converting PNODE to TNODEID
    MTNODEID ID = 0;
    sc = pScopeTree->GetNodeID(pNode, &ID);
    if (sc)
        return sc;

    // always require syncronous expansion for Object Model
    // see bug #154694
    CExpandSyncModeLock lock( pScopeTree );

    // selecting the node
    sc = ScSelectNode(ID);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_Selection
 *
 * PURPOSE: creates enumerator for Selected Nodes
 *
 * PARAMETERS:
 *    PPNODES ppNodes - resulting enumerator
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_Selection( PPNODES ppNodes )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_SelectedItems"));

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // get enumerator from list control
    sc = m_pListCtrl->Scget_SelectedItems(ppNodes);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_ListItems
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PPNODES ppNodes - resulting enumerator
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_ListItems( PPNODES ppNodes )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ListItems"));

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // get enumerator from list control
    sc = m_pListCtrl->Scget_ListItems(ppNodes);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSnapinScopeObject
//
//  Synopsis:    Get the IDispatch* from snapin for given ScopeNode object.
//
//  Arguments:   varScopeNode          - Given ScopeNode object.
//               ScopeNodeObject [out] - IDispatch for ScopeNode object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSnapinScopeObject (VARIANT& varScopeNode, /*[out]*/PPDISPATCH ScopeNodeObject)
{
    DECLARE_SC(sc, _T("CAMCView::ScSnapinScopeObject"));
    sc = ScCheckPointers(ScopeNodeObject);
    if (sc)
        return sc;

    *ScopeNodeObject = NULL;

    bool bMatchedGivenNode = false; // unused
    NodePtr spNode = NULL;
    sc = ScGetOptionalScopeNodeParameter(varScopeNode, &spNode, bMatchedGivenNode);
    if(sc)
        return sc;

    INodeCallback* pNC        = GetNodeCallback();

    sc = ScCheckPointers(spNode.GetInterfacePtr(), pNC, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = pNC->QueryCompDataDispatch(spNode, ScopeNodeObject);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSnapinSelectionObject
//
//  Synopsis:    Get the IDispatch* from snapin for selected items in result pane.
//
//  Arguments:   SelectedObject [out] - IDispatch for Selected items object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSnapinSelectionObject (PPDISPATCH SelectedObject)
{
    DECLARE_SC(sc, _T("CAMCView::ScSnapinSelectionObject"));
    sc = ScCheckPointers(SelectedObject);
    if (sc)
        return sc;

    *SelectedObject = NULL;

    if (!HasList()) // not a list. Return error
        return (sc = ScFromMMC(MMC_E_NOLIST));

    LPARAM lvData = LVDATA_ERROR;
    sc = ScGetSelectedLVItem(lvData);
    if (sc)
        return sc;

    HNODE  hNode   = GetSelectedNode();
    sc = ScCheckPointers(hNode, E_UNEXPECTED);
    if (sc)
        return sc;

    INodeCallback* pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pNodeCallback->QueryComponentDispatch(hNode, lvData, SelectedObject);
    if (sc)
        return sc;

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScIs
 *
 * PURPOSE: compares two views if they are the same
 *
 * PARAMETERS:
 *    PVIEW pView               - [in] another view
 *    VARIANT_BOOL * pbTheSame  - [out] comparison result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScIs (PVIEW pView, VARIANT_BOOL *pbTheSame)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScIs"));

    // parameter check
    sc = ScCheckPointers(pView, pbTheSame);
    if (sc)
        return sc;

    *pbTheSame = CComPtr<View>(pView).IsEqualObject(m_spView)
                 ? VARIANT_TRUE : VARIANT_FALSE;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSelectAll
//
//  Synopsis:    Selects all items in the result pane
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSelectAll ()
{
    DECLARE_SC(sc, _T("CAMCView::ScSelectAll"));

    if (! (GetListOptions() & RVTI_LIST_OPTIONS_MULTISELECT) )
        return (sc = ScFromMMC(MMC_E_NO_MULTISELECT));

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScSelectAll();
    if (sc)
        return sc;

    return (sc);
}


/***************************************************************************\
 *
 * METHOD:  CAMCView::ScSelect
 *
 * PURPOSE: selects item identified by node [implements View.Select()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to select
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScSelect( PNODE pNode )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSelect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScSelect( pNode );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScDeselect
 *
 * PURPOSE: deselects item identified by node [implements View.Deselect()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to deselect
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScDeselect( PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScDeselect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScDeselect( pNode );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScIsSelected
 *
 * PURPOSE: checks the status of item identified by node [implements View.IsSelected]
 *
 * PARAMETERS:
 *    PNODE pNode       - node to examine
 *    PBOOL pIsSelected - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScIsSelected( PNODE pNode,  PBOOL pIsSelected )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScIsSelected"));

    // parameter check
    sc = ScCheckPointers(pNode, pIsSelected);
    if (sc)
        return sc;

    *pIsSelected = FALSE;

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScIsSelected( pNode, pIsSelected );
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExecuteScopeItemVerb
//
//  Synopsis:    Get the context and pass it on to nodemgr to execute
//               given verb.
//
//  Arguments:   [verb]         - Verb to execute
//               [varScopeNode] - Optional scope node (if not given,
//                                 currently selected item will be used.)
//               [bstrNewName]  - valid for Rename else NULL.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExecuteScopeItemVerb (MMC_CONSOLE_VERB verb, VARIANT& varScopeNode, BSTR bstrNewName)
{
    DECLARE_SC(sc, _T("CAMCView::ScExecuteScopeItemVerb"));

    NodePtr spNode = NULL;
    bool bMatchedGivenNode = false;
    // We should navigate to exact node to execute the verb.
    sc = ScGetOptionalScopeNodeParameter(varScopeNode, &spNode, bMatchedGivenNode);
    if(sc)
        return sc;

    if (! bMatchedGivenNode)
        return (sc = ScFromMMC(IDS_ACTION_COULD_NOTBE_COMPLETED));

    HNODE hNode = NULL;
    sc = ScGetHNodeFromPNode(spNode, hNode);
    if (sc)
        return sc;

    INodeCallback* pNC        = GetNodeCallback();
    sc = ScCheckPointers(spNode.GetInterfacePtr(), pNC);
    if(sc)
        return sc;

    sc = pNC->ExecuteScopeItemVerb(verb, hNode, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExecuteResultItemVerb
//
//  Synopsis:    Get the currently selected context and pass it on to
//               nodemgr to execute given verb.
//
//  Arguments:   [verb]         - Verb to execute
//               [bstrNewName]  - valid for Rename else NULL.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExecuteResultItemVerb (MMC_CONSOLE_VERB verb, BSTR bstrNewName)
{
    DECLARE_SC(sc, _T("CAMCView::ScExecuteResultItemVerb"));

    if (!HasList()) // not a list. Return error
        return (sc = ScFromMMC(MMC_E_NOLIST));

    LPARAM lvData = LVDATA_ERROR;
    sc = ScGetSelectedLVItem(lvData);
    if (sc)
        return sc;

    if (lvData == LVDATA_ERROR)
        return (sc = E_UNEXPECTED);

    HNODE  hNode   = GetSelectedNode();
    sc = ScCheckPointers(hNode, E_UNEXPECTED);
    if (sc)
        return sc;

    INodeCallback* pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pNodeCallback->ExecuteResultItemVerb( verb, hNode, lvData, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScDisplayScopeNodePropertySheet
 *
 * PURPOSE: Displays the property sheet for a scope node.
 *
 * PARAMETERS:
 *    VARIANT  varScopeNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScDisplayScopeNodePropertySheet(VARIANT& varScopeNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScDisplayPropertySheet"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_PROPERTIES, varScopeNode, NULL);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDisplaySelectionPropertySheet
//
//  Synopsis:    Show the property sheet for selected result item(s).
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDisplaySelectionPropertySheet ()
{
    DECLARE_SC(sc, _T("CAMCView::ScDisplaySelectionPropertySheet"));

    sc = ScExecuteResultItemVerb(MMC_VERB_PROPERTIES, NULL);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCopyScopeNode
//
//  Synopsis:    Copy the specified scope node (if given) or currently
//               selected node to clipboard.
//
//  Arguments:   [varScopeNode] - given node.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCopyScopeNode (VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScCopyScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_COPY, varScopeNode, NULL);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCopySelection
//
//  Synopsis:    Copy the selected result item(s) to clipboard.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCopySelection ()
{
    DECLARE_SC(sc, _T("CAMCView::ScCopySelection"));

    sc = ScExecuteResultItemVerb(MMC_VERB_COPY, NULL);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDeleteScopeNode
//
//  Synopsis:    Deletes the specified scope node (if given) or currently
//               selected node.
//
//  Arguments:   [varScopeNode] - node to delete
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDeleteScopeNode (VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScDeleteScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_DELETE, varScopeNode, NULL);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDeleteSelection
//
//  Synopsis:    Deletes the selected item(s) in result pane.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDeleteSelection ()
{
    DECLARE_SC(sc, _T("CAMCView::ScDeleteSelection"));

    sc = ScExecuteResultItemVerb(MMC_VERB_DELETE, NULL);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRenameScopeNode
//
//  Synopsis:    Rename the specified scope node (if given) or currently
//               selected node with given new name.
//
//  Arguments:   [bstrNewName]  - the new name
//               [varScopeNode] - given node.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRenameScopeNode (BSTR    bstrNewName, VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScRenameScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_RENAME, varScopeNode, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRenameSelectedItem
//
//  Synopsis:    Rename the selected result item with given new name.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRenameSelectedItem (BSTR    bstrNewName)
{
    DECLARE_SC(sc, _T("CAMCView::ScRenameSelectedItem"));

    sc = ScExecuteResultItemVerb(MMC_VERB_RENAME, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRefreshScopeNode
//
//  Synopsis:    Refresh the specified scope node (if given) or currently
//               selected node.
//
//  Arguments:   [varScopeNode] - given node.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRefreshScopeNode (VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScRefreshScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_REFRESH, varScopeNode, NULL);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRefreshSelection
//
//  Synopsis:    Refresh the selected result item(s).
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRefreshSelection ()
{
    DECLARE_SC(sc, _T("CAMCView::ScRefreshSelection"));

    sc = ScExecuteResultItemVerb(MMC_VERB_REFRESH, NULL);
    if (sc)
        return sc;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ScopeNodeContextMenu
 *
 * PURPOSE: Creates a context menu for a scope node and returns it.
 *
 * PARAMETERS:
 *    VARIANT        varScopeNode :
 *    PPCONTEXTMENU  ppContextMenu :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ScopeNodeContextMenu(VARIANT& varScopeNode,  PPCONTEXTMENU ppContextMenu, bool bMatchGivenNode /* = false*/)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ContextMenu"));

    NodePtr spNode;
    // See if context menu for exactly the given node is asked for.
    bool bMatchedGivenNode = false;
    sc = ScGetOptionalScopeNodeParameter(varScopeNode, &spNode, bMatchedGivenNode);
    if (sc)
        return sc;

    if ( (bMatchGivenNode) && (!bMatchedGivenNode) )
        return ScFromMMC(IDS_NODE_NOT_FOUND);

    if(sc)
        return sc;

    INodeCallback* spNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(spNode, ppContextMenu, spNodeCallback, GetTreeCtrl());
    if(sc)
        return sc.ToHr();

    *ppContextMenu = NULL; // initialize output.

    HNODE hNode = NULL;
    sc = ScGetHNodeFromPNode(spNode, hNode);
    if (sc)
        return sc;

    // tell the node callback to add menu items for the scope node.
    sc = spNodeCallback->CreateContextMenu(spNode, hNode, ppContextMenu);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_SelectionContextMenu
 *
 * PURPOSE: Creates a context menu for the current selection and returns it.
 *
 * PARAMETERS:
 *    PPCONTEXTMENU  ppContextMenu : [OUT]: The context menu object
 *
 * RETURNS:
 *    SC : error if no list exists, or there is nothing selected.
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_SelectionContextMenu( PPCONTEXTMENU ppContextMenu)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_SelectionContextMenu"));

    sc = ScCheckPointers(ppContextMenu);
    if(sc)
        return sc;

    if (!HasListOrListPad()) // not a list. Return error
        return (sc = ScFromMMC(MMC_E_NOLIST));

    INodeCallback* pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback);
    if(sc)
        return sc.ToHr();

    CContextMenuInfo contextInfo; // the structure to pass to nodemgr

    // common entries
    contextInfo.m_pConsoleView       = this;

    // always use the temp verbs - cannot depend on what the active pane is
    contextInfo.m_dwFlags = CMINFO_USE_TEMP_VERB;

    int iIndex = -1;

    HNODE hNode = GetSelectedNode();
    ASSERT(hNode != NULL);

    int cSel = m_pListCtrl->GetSelectedCount();
    if(0 == cSel)
    {
        // no items selected, bail
        return (sc = ScFromMMC(MMC_E_NO_SELECTED_ITEMS));
    }
    else if(1 == cSel)
    {
        // single selection
        LPARAM lvData = LVDATA_ERROR;
        iIndex = _GetLVSelectedItemData(&lvData);
        ASSERT(iIndex != -1);
        ASSERT(lvData != LVDATA_ERROR);

        if (IsVirtualList())
        {
            // virtual list item in the result pane
            contextInfo.m_eDataObjectType  = CCT_RESULT;
            contextInfo.m_eContextMenuType = MMC_CONTEXT_MENU_DEFAULT;
            contextInfo.m_bBackground      = false;
            contextInfo.m_bMultiSelect     = false;
            contextInfo.m_resultItemParam  = iIndex;
            contextInfo.m_iListItemIndex   = iIndex;
        }
        else
        {
            CResultItem* pri = CResultItem::FromHandle (lvData);
            if(!pri)
                return (sc = E_UNEXPECTED);

            if (pri->IsScopeItem())
            {
                // scope item in the result pane
                contextInfo.m_eDataObjectType       = CCT_SCOPE;
                contextInfo.m_eContextMenuType      = MMC_CONTEXT_MENU_DEFAULT;
                contextInfo.m_bBackground           = FALSE;
                contextInfo.m_hSelectedScopeNode    = GetSelectedNode();
                contextInfo.m_resultItemParam       = NULL;
                contextInfo.m_bMultiSelect          = FALSE;
                contextInfo.m_bScopeAllowed         = TRUE;
				contextInfo.m_iListItemIndex        = iIndex;

                // change the scope node on which the menu is to be displayed
                hNode = pri->GetScopeNode();
            }
            else
            {
                // single result item in the result pane
                contextInfo.m_eDataObjectType  = CCT_RESULT;
                contextInfo.m_eContextMenuType = MMC_CONTEXT_MENU_DEFAULT;
                contextInfo.m_bBackground      = false;
                contextInfo.m_bMultiSelect     = false;
                contextInfo.m_resultItemParam  = lvData;
                contextInfo.m_iListItemIndex   = iIndex;

            }
        }
    }
    else
    {
        // multiselection
        iIndex = INDEX_MULTISELECTION; // => MultiSelect

        contextInfo.m_eDataObjectType  = CCT_RESULT;
        contextInfo.m_eContextMenuType = MMC_CONTEXT_MENU_DEFAULT;
        contextInfo.m_bBackground      = false;
        contextInfo.m_bMultiSelect     = true;
        contextInfo.m_resultItemParam  = LVDATA_MULTISELECT;
        contextInfo.m_iListItemIndex   = iIndex;
    }

    sc = pNodeCallback->CreateSelectionContextMenu(hNode, &contextInfo, ppContextMenu);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteMenuItem
 *
 * PURPOSE: Executes the specified context menu item on the specified context menu
 *
 * PARAMETERS:
 *    PCONTEXTMENU  pContextMenu :
 *    BSTR          MenuItemPath : Either the language-independent path or the
 *                                 language-dependent path.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteMenuItem(PCONTEXTMENU pContextMenu, BSTR MenuItemPath)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteMenuItem"));

    sc = ScCheckPointers(MenuItemPath);
    if(sc)
        return sc;

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc;

    // execute the menu item, if found.
    MenuItemPtr spMenuItem;
    sc = pContextMenu->get_Item(CComVariant(MenuItemPath), &spMenuItem);
    if(sc.IsError() || sc == SC(S_FALSE)) // error or no item
        return (sc = E_INVALIDARG); // did not find the menu item.

    // recheck the pointer
    sc = ScCheckPointers(spMenuItem, E_UNEXPECTED);
    if (sc)
        return sc;

    // found - execute it
    sc = spMenuItem->Execute();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteSelectionMenuItem
 *
 * PURPOSE: Executes a context menu item on the selection.
 *
 * PARAMETERS:
 *    BSTR  MenuItemPath : Either the language-independent path or the
 *                                 language-dependent path of the menu item.

 *
 * NOTE: This is an aggregate or utility function - it only uses other
 *       object model functions
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteSelectionMenuItem(BSTR MenuItemPath)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteSelectionMenuItem"));

    // get the context menu object
    ContextMenuPtr spContextMenu;
    sc = Scget_SelectionContextMenu(&spContextMenu);
    if(sc)
        return sc;

    sc = ScExecuteMenuItem(spContextMenu, MenuItemPath);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteScopeNodeMenuItem
 *
 * PURPOSE: Executes a context menu item on the specified scope node. The parameter
 *          is the language independent path of the menu item
 *
 * PARAMETERS:
 *    BSTR  MenuItemLanguageIndependentPath :
 *
 * NOTE: This is an aggregate or utility function - it only uses other
 *       object model functions
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteScopeNodeMenuItem(BSTR MenuItemPath, VARIANT &varScopeNode  /* = ActiveScopeNode */)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteScopeNodeMenuItem"));

    // get the context menu object for exactly the given node.
    ContextMenuPtr spContextMenu;
    sc = Scget_ScopeNodeContextMenu(varScopeNode, &spContextMenu, /*bMatchGivenNode = */ true);

    if (sc == ScFromMMC(IDS_NODE_NOT_FOUND))
    {
        sc = ScFromMMC(IDS_ACTION_COULD_NOTBE_COMPLETED);
        return sc;
    }

    if(sc)
        return sc;

    sc = ScExecuteMenuItem(spContextMenu, MenuItemPath);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteShellCommand
 *
 * PURPOSE: Executes a shell command with the specified parameters in the
 *          specified directory with the correct window size
 *
 * PARAMETERS:
 *    BSTR  Command :
 *    BSTR  Directory :
 *    BSTR  Parameters :
 *    BSTR  WindowState :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteShellCommand"));

    sc = ScCheckPointers(Command, Directory, Parameters, WindowState);
    if(sc)
        return sc;

    INodeCallback *pNodeCallback = GetNodeCallback();
    HNODE          hNodeSel      = GetSelectedNode();

    sc = ScCheckPointers(pNodeCallback, hNodeSel, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = pNodeCallback->ExecuteShellCommand(hNodeSel, Command, Directory, Parameters, WindowState);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ListViewMode
 *
 * PURPOSE: Returns the list view mode, if available.
 *
 * PARAMETERS:
 *    ListViewMode * pMode :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ListViewMode(PLISTVIEWMODE pMode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ListViewMode"));

    // check parameter
    if(!pMode)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    int mode = 0;

    // translate it into an automation friendly enum
    switch(GetViewMode())
    {
    default:
        ASSERT( 0 && "Should not come here");
        // fall thru.

    case LVS_LIST:
        *pMode = ListMode_List;
        break;

    case LVS_ICON:
        *pMode = ListMode_Large_Icons;
        break;

    case LVS_SMALLICON:
        *pMode = ListMode_Small_Icons;
        break;

    case LVS_REPORT:
        *pMode = ListMode_Detail;
        break;

    case MMCLV_VIEWSTYLE_FILTERED:
        *pMode = ListMode_Filtered;
        break;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_ListViewMode
 *
 * PURPOSE: Sets the list mode to the specified mode.
 *
 * PARAMETERS:
 *    ListViewMode  mode :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_ListViewMode(ListViewMode mode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_ListViewMode"));

    int nMode;

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    switch (mode)
    {
    default:
        sc = E_INVALIDARG;
        return sc;

    case ListMode_List:
        nMode = LVS_LIST;
        break;
    case ListMode_Detail:
        nMode = LVS_REPORT;
        break;
    case ListMode_Large_Icons:
        nMode = LVS_ICON;
        break;
    case ListMode_Small_Icons:
        nMode = LVS_SMALLICON;
        break;

    case ListMode_Filtered:
        nMode = MMCLV_VIEWSTYLE_FILTERED;
        break;
    }

    sc = ScChangeViewMode(nMode);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScBack
 *
 * PURPOSE: Invokes the Back command on the view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScBack()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScBack"));

    sc = ScWebCommand(CConsoleView::eWeb_Back);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScForward
 *
 * PURPOSE: Invokes the Forward command on the view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScForward()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScForward"));

    sc = ScWebCommand(CConsoleView::eWeb_Forward);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_StatusBarText
 *
 * PURPOSE: Sets the status bar text for the view
 *
 * PARAMETERS:
 *    BSTR  StatusBarText :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_StatusBarText(BSTR StatusBarText)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_StatusBarText"));

    // check the in parameter
    sc = ScCheckPointers(StatusBarText);
    if(sc)
        return sc;

    CConsoleStatusBar *pStatusBar = m_ViewData.GetStatusBar();
    sc = ScCheckPointers(pStatusBar, E_UNEXPECTED);
    if(sc)
        return sc;

    USES_CONVERSION;
    // set the status text
    sc = pStatusBar->ScSetStatusText(OLE2T(StatusBarText));

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Memento
 *
 * PURPOSE: Returns the XML version of the memento for the current view.
 *
 * PARAMETERS:
 *    PBSTR  Memento : [out]: The memento
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_Memento(PBSTR Memento)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Memento"));

    sc = ScCheckPointers(Memento);
    if(sc)
       return sc;

    // initialize the out parameter
    *Memento = NULL;

    CMemento memento;
    sc = ScInitializeMemento(memento);
    if(sc)
        return sc;

    std::wstring xml_contents;
    sc = memento.ScSaveToString(&xml_contents);
    if(sc)
        return sc.ToHr();

    // store the result
    CComBSTR bstrBuff(xml_contents.c_str());
    *Memento = bstrBuff.Detach();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScViewMemento
 *
 * PURPOSE: Sets the view from the specified XML memento.
 *
 * PARAMETERS:
 *    BSTR  Memento :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScViewMemento(BSTR Memento)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScViewMemento"));

    sc = ScCheckPointers(Memento);
    if(sc)
        return sc;

    CMemento memento;
    sc = memento.ScLoadFromString(Memento);
    if(sc)
        return sc;

    sc = ScViewMemento(&memento);
    if (sc == ScFromMMC(IDS_NODE_NOT_FOUND))
        return (sc = ScFromMMC(IDS_ACTION_COULD_NOTBE_COMPLETED));

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::Scget_CellContents
//
//  Synopsis:    Given row & column, get the text.
//
//  Arguments:   Node:               - the row
//               [Column]            - 1 based column index
//               [pbstrCellContents] - return value, contents of cell.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::Scget_CellContents (PNODE Node,  long Column, PBSTR pbstrCellContents)
{
    DECLARE_SC(sc, _T("CAMCView::Scget_CellContents"));
    sc = ScCheckPointers(Node, pbstrCellContents);
    if (sc)
        return sc;

    *pbstrCellContents = NULL;

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // No need to check if we are in REPORT mode as columns exist
    // even in other modes (small icon....).

    int iItem = -1;
    sc = m_pListCtrl->ScFindResultItem( Node, iItem );
    if (sc)
        return sc;

    // Script uses 1- based index for columns & rows.
    // ColCount are total # of cols.
    if (m_pListCtrl->GetColCount() < Column)
        return (sc = E_INVALIDARG);

    CListCtrl& ctlList = m_pListCtrl->GetListCtrl();

    CString strData = ctlList.GetItemText(iItem, Column-1 /*convert to zero-based*/);
    *pbstrCellContents = strData.AllocSysString();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExportList
//
//  Synopsis:    Export the list view data to given file with given options.
//
//  Arguments:   [bstrFile]       - File to save to.
//               [exportoptions]  - (Unicode, tab/comma delimited & selected rows only).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExportList (BSTR bstrFile, ExportListOptions exportoptions)
{
    DECLARE_SC(sc, _T("CAMCView::ScExportList"));

    if (SysStringLen(bstrFile) < 1)
        return (sc = E_INVALIDARG);

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    bool bUnicode          = (exportoptions & ExportListOptions_Unicode);
    bool bTabDelimited     = (exportoptions & ExportListOptions_TabDelimited);
    bool bSelectedRowsOnly = (exportoptions & ExportListOptions_SelectedItemsOnly);

    USES_CONVERSION;
    LPCTSTR lpszFileName = OLE2T(bstrFile);

    sc = ScWriteExportListData(lpszFileName, bUnicode,
                               bTabDelimited, bSelectedRowsOnly,
                               false /*bShowErrorDialogs*/);
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScClose
 *
 * PURPOSE: Implements Wiew.Close method
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScClose()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScClose"));

    // get the frame and the document
    CChildFrame* pFrame = GetParentFrame();
    CAMCDoc* pDoc = CAMCDoc::GetDocument();
    sc= ScCheckPointers(pDoc, pFrame, E_FAIL);
    if (sc)
        return sc;

    // count the views
    int cViews = 0;
    CAMCViewPosition pos = pDoc->GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        CAMCView* pView = pDoc->GetNextAMCView(pos);

        if ((pView != NULL) && ++cViews >= 2)
            break;
    }

    // prevent closing the document this way !!!
    if (cViews == 1)
    {
        sc.FromMMC(IDS_CloseDocNotLastView);
        return sc;
    }

    // if not closing last view, then give it
    // a chance to clean up first.
    // (if whole doc is closing CAMCDoc will handle
    //  closing all the views.)

    /*
     * Don't allow the user to close the last persisted view.
     */
    if (IsPersisted() && (pDoc->GetNumberOfPersistedViews() == 1))
    {
        sc.FromMMC(IDS_CantCloseLastPersistableView);
        return sc;
    }

    // checkings done, do close
    // do it indirectly so that it won't hurt the view extension it it
    // tries to close itself
    pFrame->PostMessage(WM_CLOSE);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ScopeTreeVisible
 *
 * PURPOSE: Implements get method for Wiew.ScopeTreeVisible property
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ScopeTreeVisible( PBOOL pbVisible )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ScopeTreeVisible"));

    // parameter check...
    sc = ScCheckPointers(pbVisible);
    if (sc)
        return sc;

    *pbVisible = IsScopePaneVisible();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_ScopeTreeVisible
 *
 * PURPOSE: Implements set method for Wiew.ScopeTreeVisible property
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_ScopeTreeVisible( BOOL bVisible )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_ScopeTreeVisible"));

    // show/hide the scope pane
    sc = ScShowScopePane (bVisible);
    if (sc)
        return (sc);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScFindResultItemForScopeNode
 *
 * PURPOSE: - Calculates result item representing the scope node in the list
 *
 * PARAMETERS:
 *    PNODE pNode       - node to search
 *    HRESULTITEM &itm  - resulting item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScFindResultItemForScopeNode( PNODE pNode, HRESULTITEM &itm )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScFindResultItemForScopeNode"));

    // initialization
    itm = NULL;

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // get/check for list view and tree controls and callback
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers( pScopeTree, m_pTreeCtrl, m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    // retrieve MTNode
    HMTNODE hMTNode = NULL;
    sc = pScopeTree->GetHMTNode(pNode, &hMTNode);
    if (sc)
        return sc;

    // get the pointer to the map
    CTreeViewMap *pTreeMap = m_pTreeCtrl->GetTreeViewMap();
    sc = ScCheckPointers(pTreeMap, E_UNEXPECTED);
    if (sc)
        return sc;

    // find the tree item for the node
    HTREEITEM htiNode = NULL;
    sc = pTreeMap->ScGetHTreeItemFromHMTNode(hMTNode, &htiNode);
    if (sc)
        return sc = ScFromMMC(MMC_E_RESULT_ITEM_NOT_FOUND);

    // try to match the node to the child of selected one
    HTREEITEM htiParent = m_pTreeCtrl->GetParentItem(htiNode);
    if (htiParent == NULL || htiParent != m_pTreeCtrl->GetSelectedItem())
        return sc = ScFromMMC(MMC_E_RESULT_ITEM_NOT_FOUND);

    // the node shold be in the ListView, lets find if!
    HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(htiNode);

    // get result item id
    sc = m_spNodeCallback->GetResultItem (hNode, &itm);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScGetScopeNodeForItem
 *
 * PURPOSE: Returns Node (Scope Node) for specified item index
 *
 * PARAMETERS:
 *    int  nItem        - node index to retrieve
 *    PPNODE ppNode     - result storage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScGetScopeNode( HNODE hNode,  PPNODE ppNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetScopeNodeForItem"));

    // check the parameters
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;
    // initialize the result
    *ppNode = NULL;


    // get/check required pointers
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers(pScopeTree, m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    // find MTNode
    HMTNODE hmtNode;
    sc = m_spNodeCallback->GetMTNode(hNode, &hmtNode);
    if (sc)
        return sc;

    // request the object!
    sc = pScopeTree->GetMMCNode(hmtNode, ppNode);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_Columns
 *
 * PURPOSE: create new or return pointer to existing Columns object
 *
 * PARAMETERS:
 *    PPCOLUMNS ppColumns - resulting (AddRef'ed) pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_Columns(PPCOLUMNS ppColumns)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Columns"));

    // Check received parameters
    sc = ScCheckPointers(ppColumns);
    if (sc)
        return sc;

    // initialize
    *ppColumns = NULL;

    // Check the pointer to LV
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward the request to LV
    sc = m_pListCtrl->Scget_Columns(ppColumns);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetSelectedLVItem
//
//  Synopsis:    Return the LVItem cookie.
//
//  Arguments:   LPARAM     - the LVDATA retval.
//
//  Returns:     SC - Fails if no selected item in LV.
//
//--------------------------------------------------------------------
SC CAMCView::ScGetSelectedLVItem(LPARAM& lvData)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetSelectedLVItem"));

    lvData = LVDATA_ERROR;
    int cSel = m_pListCtrl->GetSelectedCount();
    if(0 == cSel)
    {
        // no items selected, bail
        return (sc = ScFromMMC(MMC_E_NO_SELECTED_ITEMS));
    }
    else if(1 == cSel)
    {
        // single selection
        int iIndex = _GetLVSelectedItemData(&lvData);

        if (iIndex == -1 || lvData == LVDATA_ERROR)
            return (sc = E_UNEXPECTED);

        if (IsVirtualList())
        {
            // virtual list item in the result pane
            lvData = iIndex;
        }
    }
    else if (cSel > 1)
    {
        // multiselection
        lvData = LVDATA_MULTISELECT;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetHNodeFromPNode
//
//  Synopsis:    Takes in PNODE and returns corresponding hNode
//
//  Arguments:   [PNODE] - Given pnode.
//               [HNODE] - ret val.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScGetHNodeFromPNode (const PNODE& pNode, HNODE& hNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetHNodeFromPNode"));
    hNode = NULL;

    CAMCTreeView* pAMCTreeView = GetTreeCtrl();
    sc = ScCheckPointers(pAMCTreeView, E_UNEXPECTED);
    if (sc)
        return sc;

    CTreeViewMap *pTreeMap   = pAMCTreeView->GetTreeViewMap();
    IScopeTree   *pScopeTree = GetScopeTree();
    sc = ScCheckPointers(pTreeMap, pScopeTree, E_UNEXPECTED);
    if(sc)
        return sc;

    HMTNODE hMTNode = NULL;
    sc = pScopeTree->GetHMTNode(pNode, &hMTNode);
    if(sc)
        return sc;

    sc = pTreeMap->ScGetHNodeFromHMTNode(hMTNode, &hNode);
    if(sc)
        return sc;

    return (sc);
}



/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetMMCView
 *
 * PURPOSE: Creates, AddRef's, and returns a pointer to the tied COM object.
 *
 * PARAMETERS:
 *    View ** ppView :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetMMCView(View **ppView)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetMMCView"));

    sc = ScCheckPointers(ppView);
    if (sc)
        return sc;

    // init out parameter
    *ppView = NULL;

    // create a CMMCView if needed.
    sc = CTiedComObjectCreator<CMMCView>::ScCreateAndConnect(*this, m_spView);
    if(sc)
        return sc;

    if(m_spView == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spView->AddRef();
    *ppView = m_spView;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::IsDirty
 *
 * PURPOSE: Determines whether or not CAMCView is in a dirty state
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool CAMCView::IsDirty()
{
    bool bRet = m_bDirty;

    if (!m_bDirty && !m_fRootedAtNonPersistedDynamicNode)
       bRet = HasNodeSelChanged();

    TraceDirtyFlag(TEXT("CAMCView"), bRet);

    return (bRet);
}


/////////////////////////////////////////////////////////////////////////////
// CAMCView drawing

void CAMCView::OnDraw(CDC* pDC)
{
    if (IsScopePaneVisible())
    {
        pDC->FillRect (m_rectVSplitter, AMCGetSysColorBrush (COLOR_3DFACE));
    }
}

/////////////////////////////////////////////////////////////////////////////
// CAMCView printing

BOOL CAMCView::OnPreparePrinting(CPrintInfo* pInfo)
{
    TRACE_METHOD(CAMCView, OnPreparePrinting);

    // default preparation
    return DoPreparePrinting(pInfo);
}

void CAMCView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    TRACE_METHOD(CAMCView, OnBeginPrinting);

}

void CAMCView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    TRACE_METHOD(CAMCView, OnEndPrinting);

}


/////////////////////////////////////////////////////////////////////////////
// CAMCView diagnostics

#ifdef _DEBUG
void CAMCView::AssertValid() const
{
    CView::AssertValid();
}

void CAMCView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CAMCDoc* CAMCView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CAMCDoc)));
    return (CAMCDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAMCView message handlers

//+-------------------------------------------------------------------------
//
//  Function:   PreCreateWindow
//
//  Synopsis:   Create new window class (CAMCView) - WS_EX_CLIENTEDGE
//
//--------------------------------------------------------------------------

BOOL CAMCView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |=  WS_CLIPCHILDREN;
    cs.style &= ~WS_BORDER;

    // give base class a chance to do own job
    BOOL bOK = (CView::PreCreateWindow(cs));

    // register view class
    LPCTSTR pszViewClassName = g_szAMCViewWndClassName;

    // try to register window class which does not cause the repaint
    // on resizing (do it only once)
    static bool bClassRegistered = false;
    if ( !bClassRegistered )
    {
        WNDCLASS wc;
        if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
        {
            // Clear the H and V REDRAW flags
            wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
            wc.lpszClassName = pszViewClassName;
            // Register this new class;
            bClassRegistered = AfxRegisterClass(&wc);
        }
    }

    // change window class to one which does not cause the repaint
    // on resizing if we successfully registered such
    if ( bClassRegistered )
        cs.lpszClass = pszViewClassName;

    return bOK;
}


//+-------------------------------------------------------------------------
//
//  Function:   OnCreate
//
//  Synopsis:   Create Window, and Tree control / Default List control
//
//--------------------------------------------------------------------------

int CAMCView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, _T("CAMCView::OnCreate"));

    if (CView::OnCreate(lpCreateStruct) == -1)
    {
        sc = E_FAIL;
        return -1;
    }

    CChildFrame* pFrame = GetParentFrame();
    ASSERT(NULL != pFrame);
    if (pFrame)
        pFrame->SetAMCView(this);

    m_ViewData.SetStatusBar (dynamic_cast<CConsoleStatusBar*>(pFrame));
    m_ViewData.SetConsoleView (this);

    m_RightDescCtrl.Create (NULL, WS_CHILD, g_rectEmpty, this, IDC_RightDescBar);

    ASSERT (m_pDocument != NULL);
    ASSERT (m_pDocument == CAMCDoc::GetDocument());
    ASSERT_KINDOF (CAMCDoc, m_pDocument);
    CAMCDoc* pAMCDoc = reinterpret_cast<CAMCDoc *>(m_pDocument);

    CCreateContext* pContext = (CCreateContext*) lpCreateStruct->lpCreateParams;
    ASSERT (pContext != NULL);

    // Set window options
    m_ViewData.m_lWindowOptions = pAMCDoc->GetNewWindowOptions();

    /*
     * If the scope pane is suppressed, clear the scope-visible flag.
     * It's not necessary to call ScShowScopePane here because none of
     * the windows have been created yet.  We just need to keep our
     * interal accounting correct.
     */
    if (m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOSCOPEPANE)
        SetScopePaneVisible (false);

    // Create tree ctrl.
    if (!CreateView (IDC_TreeView) || (!m_pTreeCtrl) )
    {
        sc = E_FAIL;
        return -1;
    }

    SetPane(ePane_ScopeTree, m_pTreeCtrl, uiClientEdge);

    if (!AreStdToolbarsAllowed())
        m_ViewData.m_dwToolbarsDisplayed &= ~(STD_MENUS | STD_BUTTONS);

    // Create default list control
    if (!CreateListCtrl (IDC_ListView, pContext))
    {
        sc = E_FAIL;
        return -1;
    }

    // Create the folder tab control
    if (!CreateFolderCtrls ())
    {
        sc = E_FAIL;
        return -1;
    }

    // initialize the result pane to the list view
    {
        CResultViewType rvt;

        sc = ScSetResultPane(NULL /*HNODE*/, rvt, MMCLV_VIEWSTYLE_REPORT /*viewMode*/, false /*bUsingHistory*/);
        if(sc)
            return -1;
    }

    sc = ScCreateToolbarObjects();
    if (sc)
        return -1;

    //
    //  Set m_ViewData.
    //

    m_ViewData.m_nViewID = 0;// Set in OnInitialUpdate

    VERIFY ((m_ViewData.m_spNodeManager   = m_pTreeCtrl->m_spNodeManager)   != NULL);
    VERIFY ((m_ViewData.m_spResultData    = m_pTreeCtrl->m_spResultData)    != NULL);
    VERIFY ((m_ViewData.m_spRsltImageList = m_pTreeCtrl->m_spRsltImageList) != NULL);
    VERIFY ( m_ViewData.m_hwndView        = m_hWnd);
    VERIFY ( m_ViewData.m_hwndListCtrl    = m_pListCtrl->GetListViewHWND());
    VERIFY ( m_ViewData.m_pConsoleData    = GetDocument()->GetConsoleData());

    m_ViewData.m_pMultiSelection = NULL;

    if(pFrame)
    {
        // add the MDIClient window's taskbar as an observer
        CMDIFrameWnd * pFrameWnd = pFrame->GetMDIFrame();
        CWnd *pWnd = NULL;
        if(pFrameWnd)
            pWnd = pFrameWnd->GetWindow(GW_CHILD); // get the first child of the frame.
    }

    // add AMCDoc as an observer for this source (object)
    CAMCApp *pCAMCApp = AMCGetApp();
    if ( pCAMCApp )
         AddObserver(*static_cast<CAMCViewObserver *>(pCAMCApp));

    // fire the view creation event to all observers.
    sc = ScFireEvent(CAMCViewObserver::ScOnViewCreated, this);
    if(sc)
        sc.TraceAndClear();

    return 0;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::CreateFolderCtrls
 *
 * PURPOSE: Creates the tabbed folder controls for the scope and result panes.
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool
CAMCView::CreateFolderCtrls()
{
    if (!m_pResultFolderTabView->Create (WS_CHILD|WS_VISIBLE, g_rectEmpty, this, IDC_ResultTabCtrl))
        return false;

    // add the views to the framework
    GetDocument()->AddView(m_pResultFolderTabView);

    return true;
}

/*+-------------------------------------------------------------------------*
 * CAMCView::CreateView
 *
 * This was copied largely from CFrameWnd::CreateView.  We need to duplicate
 * it here so common control-based views are initially created with the
 * correct parent.  A common control caches its original parent, so
 * using CFrameWnd::CreateView (which will create the view with the frame
 * as its parent) then reparenting to CAMCView will result in the common
 * control caching the wrong parent.
 *--------------------------------------------------------------------------*/

CView* CAMCView::CreateView (CCreateContext* pContext, int nID, DWORD dwStyle)
{
    ASSERT(m_hWnd != NULL);
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(pContext != NULL);
    ASSERT(pContext->m_pNewViewClass != NULL);

    CView* pView = (CView*)pContext->m_pNewViewClass->CreateObject();
    if (pView == NULL)
    {
        TRACE1("Warning: Dynamic create of view type %hs failed.\n",
            pContext->m_pNewViewClass->m_lpszClassName);
        return NULL;
    }
    ASSERT_KINDOF(CView, pView);

    // views are always created with a border!
    if (!pView->Create (NULL, NULL, AFX_WS_DEFAULT_VIEW | dwStyle,
                        g_rectEmpty, this, nID, pContext))
    {
        TRACE0("Warning: could not create view for frame.\n");
        return NULL;        // can't continue without a view
    }

    return pView;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CreateView
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCView::CreateView (int nID)
{
    struct CreateViewData
    {
        int             nID;
        CRuntimeClass*  pClass;
        CView**         ppView;
        DWORD           dwStyle;
    };

    CreateViewData rgCreateViewData[] =
    {
        { IDC_TreeView,
            RUNTIME_CLASS(CAMCTreeView),
            (CView**)&m_pTreeCtrl,
            0   },

        { IDC_OCXHostView,
            RUNTIME_CLASS(COCXHostView),
            (CView**)&m_pOCXHostView,
            0   },

        { IDC_WebViewCtrl,
            RUNTIME_CLASS(CAMCWebViewCtrl),
            (CView**)&m_pWebViewCtrl,
            CAMCWebViewCtrl::WS_HISTORY | CAMCWebViewCtrl::WS_SINKEVENTS},

        { IDC_ViewExtensionView,
            RUNTIME_CLASS(CAMCWebViewCtrl),
            (CView**)&m_pViewExtensionCtrl,
            WS_CLIPSIBLINGS },
    };

    for (int i = 0; i < countof (rgCreateViewData); i++)
    {
        if (rgCreateViewData[i].nID == nID)
        {
            CCreateContext ctxt;
            ZeroMemory (&ctxt, sizeof (ctxt));
            ctxt.m_pCurrentDoc   = GetDocument();
            ctxt.m_pNewViewClass = rgCreateViewData[i].pClass;

            CView*& pView = *rgCreateViewData[i].ppView;
            ASSERT (pView == NULL);
            pView = CreateView (&ctxt, nID, rgCreateViewData[i].dwStyle);
            ASSERT ((pView != NULL) && "Check the debug output window");

            // Add observers only to tree, ocx and web hosts. Do not add to view extension host
            // as we do not care about its activation/deactivations.
            switch (nID)
            {
            case IDC_TreeView:
                    // set the view and the description bar as observers of the tree view control
                    m_pTreeCtrl->AddObserver(static_cast<CTreeViewObserver &>(*this));
                    m_pTreeCtrl->AddObserver(static_cast<CTreeViewObserver &>(m_RightDescCtrl));
                break;

            case IDC_OCXHostView:
                m_pOCXHostView->AddObserver(static_cast<COCXHostActivationObserver &>(*this));
                break;

            case IDC_WebViewCtrl:
                m_pWebViewCtrl->AddObserver(static_cast<COCXHostActivationObserver &>(*this));
                break;
            }

            return (pView != NULL);
        }
    }

    ASSERT (false && "Missing an entry in rgCreateViewData");
    return (false);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::GetActiveView
 *
 *
 *--------------------------------------------------------------------------*/

CAMCView* CAMCView::GetActiveView()
{
    return NULL;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScChangeViewMode
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScChangeViewMode (int nNewMode)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::OnViewModeChange"));

    // if switching from a custom view, force a reselect
    if (!HasListOrListPad())
    {
        NavState state = m_pHistoryList->GetNavigateState();
        m_pHistoryList->SetNavigateState (MMC_HISTORY_BUSY);
        PrivateChangeListViewMode(nNewMode);
        m_pHistoryList->SetNavigateState (state);
        sc = m_pTreeCtrl->ScReselect();
        if (sc)
            return sc;
    }
    else
    {
        int nCurMode = m_pListCtrl->GetViewMode();

        if ( (nNewMode == MMCLV_VIEWSTYLE_FILTERED) &&
             (!(GetListOptions() & RVTI_LIST_OPTIONS_FILTERED)) )
            return (sc = E_INVALIDARG);

        PrivateChangeListViewMode(nNewMode);

        // if filter state change, notify the snap-in
        if ( ((nCurMode == MMCLV_VIEWSTYLE_FILTERED) != (nNewMode == MMCLV_VIEWSTYLE_FILTERED))
             && (GetListOptions() & RVTI_LIST_OPTIONS_FILTERED))
        {
            HNODE hNodeSel = GetSelectedNode();
            ASSERT(hNodeSel != NULL);
            m_spNodeCallback->Notify(hNodeSel, NCLBK_FILTER_CHANGE,
                         (nNewMode == MMCLV_VIEWSTYLE_FILTERED) ? MFCC_ENABLE : MFCC_DISABLE, 0);
        }
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ViewMmento
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScViewMemento(CMemento* pMemento)
{
    DECLARE_SC (sc, TEXT("CAMCView::ScViewMemento"));
    sc = ScCheckPointers(pMemento);
    if (sc)
        return sc;

    AFX_MANAGE_STATE (AfxGetAppModuleState());

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    MTNODEID NodeId = 0;

    CBookmark& bm = pMemento->GetBookmark();
    ASSERT(bm.IsValid());

    // We want to display message if exact favorite item cannot be selected.
    bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark.
    sc = pScopeTree->GetNodeIDFromBookmark( bm, &NodeId, bExactMatchFound);
    if(sc)
        return sc;

    if (! bExactMatchFound)
        return ScFromMMC(IDS_NODE_NOT_FOUND); // do not trace

    INodeCallback *pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    // set the persisted information to the saved settings.
    sc = pNodeCallback->SetViewSettings(GetViewID(),
                                        reinterpret_cast<HBOOKMARK>(&bm),
                                        reinterpret_cast<HVIEWSETTINGS>(&pMemento->GetViewSettings()));
    if (sc)
        return sc;

    sc = ScSelectNode(NodeId, /*bSelectExactNode*/ true);
    if (sc == ScFromMMC(IDS_NODE_NOT_FOUND))
    {
        SC scNoTrace = sc;
        sc.Clear();
        return scNoTrace;
    }

    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnSetFocus
 *
 * WM_SETFOCUS handler for CAMCView.
 *--------------------------------------------------------------------------*/

void CAMCView::OnSetFocus(CWnd* pOldWnd)
{
    /*
     * try to deflect the activation to a child view; if we couldn't just punt
     */
    if (!DeflectActivation (true, NULL))
        CView::OnSetFocus(pOldWnd);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnActivateView
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    /*
     * try to deflect the activation to a child view; if we couldn't just punt
     */
    if (!DeflectActivation (bActivate, pDeactiveView))
        CView::OnActivateView (bActivate, pActivateView, pDeactiveView);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::DeflectActivation
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCView::DeflectActivation (BOOL fActivate, CView* pDeactivatingView)
{
    if (fActivate)
    {
        CFrameWnd* pFrame = GetParentFrame();
        if (pFrame == NULL)
            return (false);

        /*
         * first try to put the focus back on the deactivating view
         */
        if (pDeactivatingView == NULL)
            pDeactivatingView = pFrame->GetActiveView();

        if ((pDeactivatingView != NULL) && (pDeactivatingView != this))
        {
            pFrame->SetActiveView (pDeactivatingView);
            return true;
        }

        /*
         * otherwise, deflect the activation to the scope view, if it's there
         */
        CView* pScopeView = NULL;

        if (IsScopePaneVisible() && ((pScopeView = GetPaneView(ePane_ScopeTree)) != NULL))
        {
            if (IsWindow (pScopeView->GetSafeHwnd()))
            {
                pFrame->SetActiveView (pScopeView);
                return (true);
            }
        }

        /*
         * finally, no scope view, try the result view
         */
        CView* pResultView = GetResultView();

        if (pResultView  != NULL)
        {
            pFrame->SetActiveView(pResultView);
            return (true);
        }
    }

    return (false);
}

//+-------------------------------------------------------------------------
//
//  Function:   OnLButtonDown
//
//  Synopsis:   If mouse down in splitter area initiate view tracker to move
//              the splitter. (TrackerCallback function handles completion)
//--------------------------------------------------------------------------

void CAMCView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    TRACE_METHOD(CAMCView, OnLButtonDown);

    // click in splitter bar?
    if (!m_rectVSplitter.PtInRect(pt))
        return;

    // setup tracker information
    TRACKER_INFO trkinfo;

    // range is client area
    GetClientRect(trkinfo.rectArea);

    // bound by min size of panes
    trkinfo.rectBounds = trkinfo.rectArea;
    trkinfo.rectBounds.left  += m_PaneInfo[ePane_ScopeTree].cxMin;
    trkinfo.rectBounds.right -= m_PaneInfo[ePane_Results].cxMin;

    // Current tracker is splitter rect
    trkinfo.rectTracker = trkinfo.rectArea;
    trkinfo.rectTracker.left = m_PaneInfo[ePane_ScopeTree].cx;
    trkinfo.rectTracker.right = trkinfo.rectTracker.left + m_cxSplitter;

    // Don't allow either pane to be hidden by dragging the splitter
    trkinfo.bAllowLeftHide  = FALSE;
    trkinfo.bAllowRightHide = FALSE;

    // back ptr and completion callback
    trkinfo.pView = this;
    trkinfo.pCallback = TrackerCallback;

    // initiate tracking
    CViewTracker::StartTracking (&trkinfo);
}


void CAMCView::AdjustTracker (int cx, int cy)
{   // if user resizes window so that splitter becomes hidden,
    // move it like Explorer does.

    if (!IsScopePaneVisible())
        return;

    // extra adjustment
    cx -= BORDERPADDING + 1;

    if (cx <= m_PaneInfo[ePane_ScopeTree].cx + m_cxSplitter)
    {
        int offset = m_PaneInfo[ePane_ScopeTree].cx + m_cxSplitter - cx;

        m_PaneInfo[ePane_ScopeTree].cx -= offset;
        m_PaneInfo[ePane_Results].cx -= offset;

        RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAddDefaultColumns
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAddDefaultColumns()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAddDefaultColumns"));

    IHeaderCtrlPtr spHeaderCtrl = m_ViewData.m_spNodeManager;

    sc = ScCheckPointers(spHeaderCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    SetUsingDefColumns(TRUE);

    const int INDEX_MAX = 2;

    CString str[INDEX_MAX];

    LoadString(str[0], IDS_NAME);
    LoadString(str[1], IDS_TYPE);

    int iMax = 0;
    int nMax = str[0].GetLength();
    int nTemp = 0;

    for (int i=1; i < INDEX_MAX; i++)
    {
        nTemp = str[i].GetLength();

        if (nTemp > nMax)
        {
            nMax = nTemp;
            iMax = i;
        }
    }

    int cchName = nMax + 1;
    LPOLESTR pszName = new OLECHAR[cchName];
    sc = ScCheckPointers(pszName, E_OUTOFMEMORY);
    if (sc)
        return sc;

    CAutoArrayPtr<OLECHAR> Name;
    Name.Attach(pszName); // Attach to CAuto... so that it is automatically freed.

    int alWidths[INDEX_MAX] = {0, 0};
    GetDefaultColumnWidths(alWidths);

    for (i=0; i < INDEX_MAX; i++)
    {
        // Bug 157408:  remove the "Type" column for static nodes
        if (i == 1)
            continue;

        USES_CONVERSION;

        sc = StringCchCopyW(pszName, cchName, T2COLE( (LPCTSTR) str[i] ));
        if (sc)
            sc.TraceAndClear(); // Ignore and set truncated column name.

        sc = spHeaderCtrl->InsertColumn(i, pszName, LVCFMT_LEFT, alWidths[i]);
        if(sc)
            return sc;
    }

    return sc;
}

SC
CAMCView::ScInitDefListView(LPUNKNOWN pUnkResultsPane)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScInitDefListView"));

    if (!HasList())
        return (sc = E_UNEXPECTED);

    sc = ScCheckPointers(pUnkResultsPane, m_ViewData.m_spResultData, E_UNEXPECTED);
    if(sc)
        return sc;

    m_ViewData.m_spResultData->ResetResultData();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnSelectNode
 *
 * Most of this code was moved out of CAMCTreeView::OnSelectNode, as it is
 * more appropriate that this is executed by CAMCView.
 *
 * PURPOSE: Called when an item in the tree is selected. Does the following:
 *          1) Sets up the result pane to either a list, and OCX, or a web page.
 *          2) Sets the view options
 *          3) Sends a selection notification to the node.
 *          3) Adds a history entry if needed.
 *
 * PARAMETERS:
 *    HNODE  hNode :          [IN]:  The node that got selected.
 *    BOOL & bAddSubFolders : [OUT]: Whether subfolders should be added to the list
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnSelectNode(HNODE hNode, BOOL &bAddSubFolders)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnSelectNode"));

    USES_CONVERSION;

    //
    //  Set the result pane
    //
    LPOLESTR pszResultPane  = NULL;
    GUID     guidTaskpad    = GUID_NULL;
    int      lViewMode      = MMCLV_VIEWSTYLE_REPORT; // the default view mode

    //long lViewOptions = MMC_VIEW_OPTIONS_NONE;

    bool bUsingHistory  = false;
    bool bRestoredView  = false;

    INodeCallback* spNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(spNodeCallBack, E_UNEXPECTED);
    if (sc)
        return sc;

    CHistoryList* pHistoryList = GetHistoryList();
    sc = ScCheckPointers(pHistoryList, E_UNEXPECTED);
    if (sc)
        return sc;

    CResultViewType rvt;

    if (pHistoryList->GetNavigateState() == MMC_HISTORY_NAVIGATING)
    {
        // we're going "back" or "forward":
        // get Result pane stuff from history

        bUsingHistory   = true;
        sc = pHistoryList->ScGetCurrentResultViewType(rvt, lViewMode, guidTaskpad);
        if (sc)
            return sc;

        sc = spNodeCallBack->RestoreResultView(hNode, rvt);
        if (sc)
        {
            TraceError(_T("Snapin failed on NCLBK_RESTORE_VIEW\n"), sc);
            sc.Clear();     // Compatible with 1.2 dont need this error.
        }

        if (sc.ToHr() == S_OK)
            bRestoredView = true;
        else
            rvt = CResultViewType(); // this restores rvt back to a nascent state. see Bug 176058.

    }

    // The view is not restored by history so ask snapin for view settings.
    if (! bRestoredView)
    {

        // get Result pane stuff from snapin
        GUID guid = GUID_NULL;
        sc = spNodeCallBack->GetResultPane(hNode, rvt, &guid);
        if (sc)
            return sc;

        // we cannot pass the guidTaskpad to GetResultPane directly, since
        // when it is navigation what causes the change, view settings are
        // not yet updated and thus the guid returned will not reflect the
        // current situation
        if (!bUsingHistory)
            guidTaskpad = guid;
    }

    // make sure we have a taskpad set (this will change the value of guidTaskpad if required)
    // This is required when pages referred from history are no longer available when returning
    // to the view (taskpad being deleted/default page being replaced/etc.)
    if (bUsingHistory)
        spNodeCallBack->SetTaskpad(hNode, &guidTaskpad);

    //SetViewOptions(lViewOptions);


    // at this stage, rvt contains all the result view information (excluding, as always the list view mode.)
    if (rvt.HasList())
    {
        SetListViewMultiSelect(
            (rvt.GetListOptions() & RVTI_LIST_OPTIONS_MULTISELECT) == RVTI_LIST_OPTIONS_MULTISELECT);
    }

    sc = ScSetResultPane(hNode, rvt, lViewMode, bUsingHistory);
    if(sc)
        return sc;

    ::CoTaskMemFree(pszResultPane);

    //
    //  Initialize default list view.
    //
    LPUNKNOWN pUnkResultsPane = GetPaneUnknown(CConsoleView::ePane_Results);
    if (rvt.HasList())
    {
        sc = ScInitDefListView(pUnkResultsPane);
        if(sc)
            return sc;

        sc = ScCheckPointers(m_ViewData.m_spResultData, E_UNEXPECTED);
        if (sc)
            return sc;

        // this turns off list view redrawing. Should have some sort of smart object that automatically
        // turns redrawing on in its destructor.
        m_ViewData.m_spResultData->SetLoadMode(TRUE); // SetLoadMode(FALSE) is called by the caller, CAMCTreeView::OnSelectNode
    }


    //
    //  Notify the new node that it is selected.
    //
    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));

    selInfo.m_bScope = TRUE;
    selInfo.m_pView  = pUnkResultsPane;

    if (rvt.HasWebBrowser())
    {
        selInfo.m_bResultPaneIsWeb = TRUE;
        selInfo.m_lCookie          = LVDATA_CUSTOMWEB;
    }
    else if (rvt.HasOCX())
    {
        selInfo.m_bResultPaneIsOCX = TRUE;
        selInfo.m_lCookie          = LVDATA_CUSTOMOCX;
    }

    // Increment and save local copy of nesting level counter. This counter serves
    // two purposes. First, it allows AMCView to inhibit inserting scope items in
    // the result pane during a select by checking the IsSelectingNode method.
    // Without this test the scope items would appear twice because all the scope
    // items are added to the result pane at the end of this method.
    // Second, during the following ScNotifySelect call the snap-in could do another
    // select which would re-enter this method. In that case, only the innermost
    // call to this method should do the post-notify processing. The outer calls
    // should just exit, returning S_FALSE instead of S_OK.

    int nMyNestLevel = ++m_nSelectNestLevel;

    // collect / manage view tabs
    sc = ScAddFolderTabs( hNode, guidTaskpad );
    if (sc)
        return sc;

    try
    {
        sc = ScNotifySelect ( spNodeCallBack, hNode, false /*fMultiSelect*/, true, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }
    catch(...)
    {
        // if first call to Select, reset level to zero before leaving
        if (nMyNestLevel == 1) m_nSelectNestLevel = 0;
        throw;
    }


    // if the local call level does not match the shared call level then this
    // method was reentered during the ScNotifySelect. In that case don't finish
    // the processing because the node and/or view may have changed.
    // Be sure to reset the call level to zero if this is the outermost call.

    ASSERT(nMyNestLevel <= m_nSelectNestLevel);
    BOOL bDoProcessing = (nMyNestLevel == m_nSelectNestLevel);
    if (nMyNestLevel == 1)
        m_nSelectNestLevel = 0;

    if (!bDoProcessing)
        return S_FALSE;


    //
    // If the result pane is the def-LV, ensure that there are headers.
    // If not add the default ones
    //

    if (rvt.HasList())
    {
        SetUsingDefColumns(FALSE);

        // Get ptr to ResultPane.
        IMMCListViewPtr pMMCLV = pUnkResultsPane;
        sc = ScCheckPointers(pMMCLV, E_UNEXPECTED);
        if (sc)
            return sc;

        int nCols = 0;
        sc = pMMCLV->GetColumnCount(&nCols);
        if (sc)
            return sc;

        if(0 == nCols)
        {
            sc = ScAddDefaultColumns();
            if(sc)
                return sc;

            IResultDataPrivatePtr& pResultDataPrivate = m_ViewData.m_spResultData;
            sc = ScCheckPointers(pResultDataPrivate, E_UNEXPECTED);
            if (sc)
                return sc;

            long lViewMode = GetViewMode();

            // If default mode is filtered and new node doesn't
            // support that, use report mode instead
            if (lViewMode == MMCLV_VIEWSTYLE_FILTERED &&
                !(rvt.GetListOptions() & RVTI_LIST_OPTIONS_FILTERED))
                lViewMode = LVS_REPORT;

            // you've got to change the mode before you change the
            // style:  style doesn't contain the "quickfilter" bit.
            pResultDataPrivate->SetViewMode (lViewMode);

            long style = GetDefaultListViewStyle();
            if (style != 0)
            {
                sc = pResultDataPrivate->SetListStyle(style);
                if (sc)
                    return sc;
            }
        }
    }


    //
    // Show the static scope items in the result pane,
    // but not for a virtual list view, or views specifically
    // marked that they don't want scope items in the result view
    //

    if (rvt.HasList() &&
        !(rvt.GetListOptions() & RVTI_LIST_OPTIONS_OWNERDATALIST) &&
        !(rvt.GetListOptions() & RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST))
    {
        bAddSubFolders = TRUE;
    }


    //  Update window title.
    sc = ScUpdateWindowTitle();
    if(sc)
        return sc;

    // fire event to script
    sc = ScFireEvent(CAMCViewObserver::ScOnViewChange, this, hNode);
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetResultPane
 *
 * PURPOSE:   Sets the result pane to the specified configuration.
 *
 * PARAMETERS:
 *    HNODE            hNode :
 *    CResultViewType  rvt :
 *    long             lViewOptions :
 *    bool             bUsingHistory :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScSetResultPane(HNODE hNode, CResultViewType rvt, int viewMode, bool bUsingHistory)
{
    DECLARE_SC(sc, TEXT("CAMCView::SetResultPane"));

    m_ViewData.SetResultViewType(rvt);

    if(rvt.HasList())
    {
        sc = ScAttachListViewAsResultPane();
        if(sc)
            return sc;
    }

    else if(rvt.HasWebBrowser())
    {
        sc = ScAttachWebViewAsResultPane();
        if(sc)
            return sc;
    }

    else if(rvt.HasOCX())
    {
        sc = ScAttachOCXAsResultPane(hNode);
        if(sc)
            return sc;
    }
    else
    {
        ASSERT(0 && "Should not come here!!");
        return (sc = E_UNEXPECTED);
    }

    // show the toolbars
    if(GetStdToolbar() != NULL) // may be NULL at startup.
    {
        sc = GetStdToolbar()->ScShowStdBar(true);
        if(sc)
            return sc;
    }

    // if we haven't gotten here using history, add a history entry.
    if(!bUsingHistory)
    {
        GUID guidTaskpad = GUID_NULL;
        GetTaskpadID(guidTaskpad);
        sc = m_pHistoryList->ScAddEntry(rvt, m_nViewMode, guidTaskpad);
        if(sc)
            return sc;
    }


    // if we have a node manager, tell it what the result pane is.
    if(m_ViewData.m_spNodeManager)
    {
        LPUNKNOWN pUnkResultsPane = GetPaneUnknown(CConsoleView::ePane_Results);
        m_ViewData.m_spNodeManager->SetResultView(pUnkResultsPane);
    }

    return sc;
}



BOOL CAMCView::CreateListCtrl(int nID, CCreateContext* pContext)
{
    TRACE_METHOD(CAMCView, CreateListCtrl);

    ASSERT(m_pListCtrl == NULL);

    CComObject<CCCListViewCtrl> *pLV = NULL;
    CComObject<CCCListViewCtrl>::CreateInstance( &pLV );

    if (pLV == NULL)
    {
        ASSERT(0 && "Unable to create list control");
        return FALSE;
    }

    // we assign directly - implicit cast works, since we have a type derived from the one we need
    m_pListCtrl = pLV;
    // we intend to hold a reference, so do addref here (CreateInstance creates w/ 0 reffs)
    m_pListCtrl->AddRef();

    if (!m_pListCtrl->Create (WS_VISIBLE | WS_CHILD, g_rectEmpty, this, nID, pContext))
    {
        ASSERT(0 && "Unable to create list control");
        return FALSE;
    }

    m_pListCtrl->SetViewMode (m_nViewMode);

    SC SC = m_pListCtrl->ScInitialize(); // intialize the list control

    return TRUE;
}


void CAMCView::SetListViewOptions(DWORD dwListOptions)
{
    TRACE_METHOD(CAMCView, SetListViewOptions);

    bool bVirtual = (dwListOptions & RVTI_LIST_OPTIONS_OWNERDATALIST) ? true : false;

    ASSERT(m_pListCtrl != NULL);

    CDocument* pDoc = GetDocument();
    ASSERT(pDoc != NULL);

    // If change to/from virtual list, change list mode
    if (IsVirtualList() != bVirtual)
    {
        m_ViewData.SetVirtualList (bVirtual);
        pDoc->RemoveView(m_pListCtrl->GetListViewPtr());
        m_pListCtrl->SetVirtualMode(bVirtual);
        pDoc->AddView(m_pListCtrl->GetListViewPtr());
        m_ViewData.m_hwndListCtrl = m_pListCtrl->GetListViewHWND();
    }

    // if snapin doesn't support filtering make sure it's off
    if (!(GetListOptions() & RVTI_LIST_OPTIONS_FILTERED) &&
         m_pListCtrl->GetViewMode() == MMCLV_VIEWSTYLE_FILTERED)
    {
        m_pListCtrl->SetViewMode(LVS_REPORT);
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAttachListViewAsResultPane
 *
 * PURPOSE: Sets up the list view as the result pane.
 *
 * PARAMETERS: NONE
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAttachListViewAsResultPane()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAttachListViewAsResultPane"));

    bool bVirtual = (GetListOptions() & RVTI_LIST_OPTIONS_OWNERDATALIST) ? true : false;
    GUID guidTaskpad;
    GetTaskpadID(guidTaskpad);

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    CDocument* pDoc = GetDocument();
    ASSERT(pDoc != NULL);

    // If change to/from virtual list, change list mode
    if (IsVirtualList() != bVirtual)
    {
        m_ViewData.SetVirtualList (bVirtual);
        pDoc->RemoveView(m_pListCtrl->GetListViewPtr());
        m_pListCtrl->SetVirtualMode(bVirtual);
        pDoc->AddView(m_pListCtrl->GetListViewPtr());
        m_ViewData.m_hwndListCtrl = m_pListCtrl->GetListViewHWND();
    }

    // if snapin doesn't support filtering make sure it's off
    if (!(GetListOptions() & RVTI_LIST_OPTIONS_FILTERED) &&
         m_pListCtrl->GetViewMode() == MMCLV_VIEWSTYLE_FILTERED)
    {
        m_pListCtrl->SetViewMode(LVS_REPORT);
    }

    ShowResultPane(m_pListCtrl->GetListViewPtr(), uiClientEdge);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAttachWebViewAsResultPane
 *
 * PURPOSE:
 *
 * PARAMETERS: NONE
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAttachWebViewAsResultPane()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAttachWebViewAsResultPane"));

    // if we were in ListPad-mode, undo that.
    if (m_pListCtrl->IsListPad())
    {
        sc = m_pListCtrl->ScAttachToListPad (NULL, NULL);
        if(sc)
            return sc;
    }

    // The control is created on demand. This prevents IE from loading when unnecessary
    // and reduces startup time.
    if (m_pWebViewCtrl == NULL)
        CreateView (IDC_WebViewCtrl);

    sc = ScCheckPointers(m_pWebViewCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // Force web control to update its palette
    SendMessage(WM_QUERYNEWPALETTE);

    ShowResultPane(m_pWebViewCtrl, uiNoClientEdge);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAttachOCXAsResultPane
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPCTSTR  pszResultPane :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAttachOCXAsResultPane(HNODE hNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAttachOCXAsResultPane"));
    USES_CONVERSION;

    ASSERT(m_pListCtrl != NULL);

    if (m_pOCXHostView == NULL)
        CreateView (IDC_OCXHostView);

    sc = ScCheckPointers(m_pOCXHostView);
    if(sc)
        return sc;

    sc = m_pOCXHostView->ScSetControl(hNode, m_ViewData.m_rvt, GetNodeCallback());
    if(sc)
        return sc;

    ShowResultPane(m_pOCXHostView, uiClientEdge);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScApplyViewExtension
 *
 * Applies a view extension to the current view.  pszURL specifies the
 * URL of the HTML to load as the view extension.  If pszURL is NULL or
 * empty, the view extension is removed.
 *
 * This method will force a layout of the view if it is required.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScApplyViewExtension (
    LPCTSTR pszURL)                     /* I:URL to use, NULL to remove     */
{
    DECLARE_SC (sc, _T("CAMCView::ScApplyViewExtension"));

    /*
     * assume no view extension
     */
    bool fViewWasExtended = m_fViewExtended;
    m_fViewExtended       = false;

    /*
     * if we're given a URL with which to extend the view, turn on the extension
     */
    if ((pszURL != NULL) && (*pszURL != 0))
    {
        /*
         * if we don't have a web control for the view extension yet, create one
         */
        if (m_pViewExtensionCtrl == NULL)
            CreateView (IDC_ViewExtensionView);

        sc = ScCheckPointers (m_pViewExtensionCtrl, E_FAIL);
        if (sc)
            return (sc);

        m_fViewExtended = true;

        // hide the hosted window initially
        CWnd *pwndHosted = GetPaneView(ePane_Results);
        sc = ScCheckPointers(pwndHosted);
        if(sc)
            return sc;

        pwndHosted->ShowWindow(SW_HIDE);

        RecalcLayout(); // do this BEFORE calling Navigate, which may resize the above rectangle via the mmcview behavior

        // navigate to the requested URL
        m_pViewExtensionCtrl->Navigate (pszURL, NULL);
    }
    else if (fViewWasExtended && (m_pViewExtensionCtrl != NULL))
    {
        /*
         * Bug 96948: If we've got an extension and we're currently extending
         * the view, navigate the view extension's web browser to an empty page
         * so the behavior that resizes the hosted result frame is disabled
         */
        CStr strEmptyPage;
        sc = CHistoryList::ScGeneratePageBreakURL (strEmptyPage);
        if (sc)
            return (sc);

        m_pViewExtensionCtrl->Navigate (strEmptyPage, NULL);

        if(fViewWasExtended)
            DeferRecalcLayout();
    }


    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ShowResultPane
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CView*        pNewView :
 *    EUIStyleType  nStyle :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::ShowResultPane(CView* pNewView, EUIStyleType nStyle)
{
    TRACE_METHOD(CAMCView, ShowResultPane);
    ASSERT(pNewView != NULL);

    CView* pCurrentView = GetPaneView(ePane_Results);

    bool bActive = (GetParentFrame()->GetActiveView() == pCurrentView);

    // Check to see if we need to swap the CWnd control in the result pane
    if (pNewView != pCurrentView)
    {
        HWND hwndCurrentView = pCurrentView->GetSafeHwnd();

        if (IsWindow (hwndCurrentView))
        {
            pCurrentView->ShowWindow(SW_HIDE);

            // Note: We are directly hiding the window for cases that controls
            // don't hide during a DoVerb(OLEIVERB_HIDE).  Actually, this does a
            // hide on all windows.  It's too hard at this point to optimize the code
            // for doing this with an OLE control only.
            ::ShowWindow(hwndCurrentView, SW_HIDE);
        }

        SetPane(ePane_Results, pNewView, nStyle);
        RecalcLayout();

        // if other pane was active, make the new one active
        if ((pCurrentView != NULL) && bActive)
        {
            // make sure the new window is visible
            pNewView->ShowWindow(SW_SHOW);
            GetParentFrame()->SetActiveView(pNewView);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetPaneInfo
//
//  Synopsis:   Get information about a particular pane
//
//--------------------------------------------------------------------------

void CAMCView::GetPaneInfo(ViewPane ePane, int* pcxCur, int* pcxMin)
{
    TRACE_METHOD(CAMCView, GetPaneInfo);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::GetPaneInfo: Invalid pane specifier");
        return;
    }

    if ((pcxCur==NULL) || (pcxMin==NULL))
    {
        ASSERT(FALSE); // One or more of the args is wrong
        return;
    }

    // REVIEW fix enum
    *pcxCur   = m_PaneInfo[ePane].cx;
    *pcxMin   = m_PaneInfo[ePane].cxMin;


}

//+-------------------------------------------------------------------------
//
//  Function:   SetPaneInfo
//
//  Synopsis:   Set information about a particular pane
//
//--------------------------------------------------------------------------

void CAMCView::SetPaneInfo(ViewPane ePane, int cxCur, int cxMin)
{
    TRACE_METHOD(CAMCView, SetPaneInfo);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::SetPaneInfo: Invalid pane specifier");
        return;
    }

    if (cxCur < 0 || cxMin < 0)
    {
        ASSERT(FALSE); // One or more of the args is wrong
        return;
    }

    m_PaneInfo[ePane].cx      = cxCur;
    m_PaneInfo[ePane].cxMin   = cxMin;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetPaneView
//
//  Synopsis:   Returns a pointer to CView for a particular pane
//
//--------------------------------------------------------------------------

CView* CAMCView::GetPaneView(ViewPane ePane)
{
    TRACE_METHOD(CAMCView, GetPaneView);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::GetPaneView: Invalid pane specifier");
        return (NULL);
    }

    return (m_PaneInfo[ePane].pView);
}



/*+-------------------------------------------------------------------------*
 * CAMCView::GetResultView
 *
 *
 *--------------------------------------------------------------------------*/

CView* CAMCView::GetResultView() const
{
    CView* pView = NULL;

    // may need changes here - assumes the different types are independent.

    if(HasWebBrowser())
        pView = m_pWebViewCtrl;

    else if(HasList())
        pView = m_pListCtrl->GetListViewPtr();

    else if(HasOCX())
        pView = m_pOCXHostView;

    ASSERT (pView != NULL);
    return (pView);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetPaneUnknown
//
//  Synopsis:   Returns a pointer to the Unknown
//
//--------------------------------------------------------------------------

LPUNKNOWN CAMCView::GetPaneUnknown(ViewPane ePane)
{
    TRACE_METHOD(CAMCView, GetPaneUnknown);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::GetPaneUnknown: Invalid pane specifier");
        return (NULL);
    }

    if (!IsWindow (GetPaneView(ePane)->GetSafeHwnd()))
    {
        ASSERT(FALSE); // Invalid pane element
        return NULL;
    }

    if (HasWebBrowser() && m_pWebViewCtrl != NULL)
    {
        return m_pWebViewCtrl->GetIUnknown();
    }
    else if( HasList() && m_pListCtrl != NULL )
    {
        IUnknownPtr spUnk = m_pListCtrl;
        LPUNKNOWN pUnk = spUnk;
        return pUnk;
    }
    else if (HasOCX() && m_pOCXHostView != NULL)
    {
        ASSERT(GetPaneView (ePane));
        return m_pOCXHostView->GetIUnknown();
    }
    else
    {
        // result pane not initialized yet. This is usually because we are in between a deselect and a
        // subsequent reselect.
        return NULL;
   }
}


//+-------------------------------------------------------------------------
//
//  Function:   SetPane
//
//  Synopsis:   Set a CWnd pointer for a particular pane and other information
//
//--------------------------------------------------------------------------

void CAMCView::SetPane(ViewPane ePane, CView* pView, EUIStyleType nStyle)
{
    TRACE_METHOD(CAMCView, SetPane);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::SetPane: Invalid pane specifier");
        return;
    }

    if (pView==NULL || !IsWindow(*pView))
    {
        ASSERT(FALSE); // Invalid arg
        return;
    }

    m_PaneInfo[ePane].pView = pView;

    // Ensure that the window is visible & at the top of the Z-order.
    pView->SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE);

    // Note: We are directly showing the window for cases that controls
    // don't show during a DoVerb(OLEIVERB_SHOW).  Actually, this does a
    // show on all windows.  It's too hard at this point to optimize the code
    // for doing this with an OLE control only.
    ::ShowWindow(pView->m_hWnd, SW_SHOW);
}

//
// Other Methods
//


/*+-------------------------------------------------------------------------*
 * CAMCView::ScShowScopePane
 *
 * Shows or hides the scope pane in the current view.  If fForce is true,
 * we'll go through the motions of showing the scope pane even if we think
 * its visibility state wouldn't change.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScShowScopePane (bool fShow, bool fForce /* =false */)
{
    DECLARE_SC (sc, _T("CAMCView::ScShowScopePane"));

    /*
     * if the current visibility state doesn't match the requested state,
     * change the current state to match the requested state
     */
    if (fForce || (IsScopePaneVisible() != fShow))
    {
        /*
         * If MMC_NW_OPTION_NOSCOPEPANE was specified when this view was
         * created, we can't display a scope pane.  If we're asked to, fail.
         */
        if (fShow && !IsScopePaneAllowed())
            return (sc = E_FAIL);

        /*
         * if the scope pane is being hidden and it contained the active
         * view, activate the result pane
         */
        if (!fShow && (GetFocusedPane() == ePane_ScopeTree))
            ScSetFocusToResultPane ();   // ignore errors here

        /*
         * remember the new state
         */
        SetScopePaneVisible (fShow);

        /*
         * Don't defer this layout.  This may be called by the Customize View
         * dialog which wants to see its updates in real time.  It will be
         * sitting in a modal message loop so we won't get a chance to precess
         * our idle task.
         */
        RecalcLayout();

        /*
         * the console has changed
         */
        SetDirty();
    }

    /*
     * put the scope pane toolbar button in the right state
     */
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    sc = ScCheckPointers(pStdToolbar, E_UNEXPECTED);
    if (sc)
        return (sc);

    CAMCDoc *pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return sc;

	bool bEnableScopePaneButton = (IsScopePaneAllowed() && pDoc->AllowViewCustomization());

    // IF view customization is not allowed then "Show/Hide Consolte tree" button should be hidden.
    if (bEnableScopePaneButton)
    {
        /*
         * the scope pane is permitted; show and check the toolbar
         * button if the scope pane is visible, show and uncheck the
         * toolbar button if the scope pane is hidden
         */
        sc = pStdToolbar->ScCheckScopePaneBtn (fShow);
        if (sc)
            return (sc);
    }
    else
    {
        /*
         * no scope pane permitted, hide the scope pane button
         */
        sc = pStdToolbar->ScEnableScopePaneBtn (bEnableScopePaneButton);
        if (sc)
            return (sc);
    }

    /*
     * if we get to this point, the current state should match the requested state
     */
    ASSERT (IsScopePaneVisible() == fShow);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::CDeferredLayout
 *
 * Constructs a CAMCView::CDeferredLayout::CDeferredLayout.  Note that if
 * an error occurs during construction, an SC exception will be thrown.
 *--------------------------------------------------------------------------*/

CAMCView::CDeferredLayout::CDeferredLayout (CAMCView* pAMCView)
    : m_atomTask (AddAtom (_T("CAMCView::CDeferredLayout")))
{
        DECLARE_SC (sc, _T("CAMCView::CDeferredLayout::CDeferredLayout"));

        if (!Attach (pAMCView))
                (sc = E_INVALIDARG).Throw();
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::~CDeferredLayout
 *
 *
 *--------------------------------------------------------------------------*/

CAMCView::CDeferredLayout::~CDeferredLayout()
{
    DeleteAtom (m_atomTask);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::ScDoWork
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::CDeferredLayout::ScDoWork()
{
    WindowCollection::iterator  it;
    WindowCollection::iterator  itEnd = m_WindowsToLayout.end();

    for (it = m_WindowsToLayout.begin(); it != itEnd; ++it)
    {
        CWnd* pwnd = CWnd::FromHandlePermanent (*it);
        CAMCView* pAMCView = dynamic_cast<CAMCView*>(pwnd);

        if (pAMCView != NULL)
        {
            pAMCView->RecalcLayout();
            pAMCView->Invalidate();
            pAMCView->UpdateWindow();
        }
    }

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::ScGetTaskID
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::CDeferredLayout::ScGetTaskID(ATOM* pID)
{
    *pID = m_atomTask;
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::ScMerge
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::CDeferredLayout::ScMerge(CIdleTask* pitMergeFrom)
{
    CDeferredLayout* pdlMergeFrom = dynamic_cast<CDeferredLayout*>(pitMergeFrom);
    ASSERT (pdlMergeFrom != NULL);

    /*
     * copy the windows from the merge-from task into the merge-to task
     */
    WindowCollection::iterator  it;
    WindowCollection::iterator  itEnd = pdlMergeFrom->m_WindowsToLayout.end();

    for (it = pdlMergeFrom->m_WindowsToLayout.begin(); it != itEnd; ++it)
    {
        m_WindowsToLayout.insert (*it);
    }

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::Attach
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCView::CDeferredLayout::Attach (CAMCView* pAMCView)
{
    ASSERT (pAMCView != NULL);

    HWND hwndAMCView = pAMCView->GetSafeHwnd();

    if (hwndAMCView != NULL)
        m_WindowsToLayout.insert (hwndAMCView);

    return (hwndAMCView != NULL);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::DeferRecalcLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::DeferRecalcLayout (bool fUseIdleTaskQueue /* =true */, bool bArrangeIcons /* = false*/)
{
    DECLARE_SC (sc, _T("CAMCView::DeferRecalcLayout"));

    if (fUseIdleTaskQueue)
    {
        Trace (tagLayout, _T("CAMCView::DeferRecalcLayout (idle task)"));
        try
        {
            /*
             * get the idle task manager
             */
            CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
            if (pIdleTaskQueue == NULL)
                (sc = E_UNEXPECTED).Throw();

            /*
             * create the deferred layout task
             */
            CAutoPtr<CDeferredLayout> spDeferredLayout (new CDeferredLayout (this));
            if (spDeferredLayout == NULL)
                (sc = E_OUTOFMEMORY).Throw();

            /*
             * put the task in the queue, which will take ownership of it
             */
            sc = pIdleTaskQueue->ScPushTask (spDeferredLayout, ePriority_Normal);
            if (sc)
                sc.Throw();

            /*
             * if we get here, the idle task queue owns the idle task, so
             * we can detach it from our smart pointer
             */
            spDeferredLayout.Detach();

            /*
             * jiggle the message pump so that it wakes up and checks idle tasks
             */
            PostMessage (WM_NULL);
        }
        catch (SC& scCaught)
        {
            /*
             * if we failed to enqueue our deferred layout task, do the layout now
             */
            RecalcLayout();
        }
    }

    /*
     * post a message instead of using the idle task queue
     */
    else
    {
        /*
         * we only need to post a message if there's not one in the queue
         * already
         */
        MSG msg;

        if (!PeekMessage (&msg, GetSafeHwnd(),
                          m_nDeferRecalcLayoutMsg,
                          m_nDeferRecalcLayoutMsg,
                          PM_NOREMOVE))
        {
            PostMessage (m_nDeferRecalcLayoutMsg, bArrangeIcons);
            Trace (tagLayout, _T("CAMCView::DeferRecalcLayout (posted message)"));
        }
        else
        {
            Trace (tagLayout, _T("CAMCView::DeferRecalcLayout (skipping redundant posted message)"));
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   RecalcLayout
//
//  Synopsis:   Calls methods to layout control and paint borders and splitters.
//
//--------------------------------------------------------------------------

void CAMCView::RecalcLayout(void)
{
    TRACE_METHOD(CAMCView, RecalcLayout);
    ASSERT_VALID(this);
        Trace (tagLayout, _T("CAMCView::RecalcLayout"));

    /*
     * short out if the client rect is empty
     */
    CRect rectClient;
    GetClientRect (rectClient);

    if (rectClient.IsRectEmpty())
        return;

    CDeferWindowPos dwp (10);

    LayoutScopePane  (dwp, rectClient);
    LayoutResultPane (dwp, rectClient);

    /*
     * CDeferWindowPos dtor will position the windows
     */
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutScopePane
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutScopePane (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    int cxScope = 0;

    // If a scope pane is visible
    if (IsScopePaneVisible())
    {
        int cxTotal = rectRemaining.Width();

        // get the current width
        cxScope = m_PaneInfo[ePane_ScopeTree].cx;

        // if not determined yet, set scope pane width to 1/4 of window
        if (cxScope == -1)
            cxScope = cxTotal / 3;

        /*
         * Bug 86718:  Make sure we leave at least the minimum width
         * for the result pane, which is always visible
         */
        cxScope = std::_MIN (cxScope, cxTotal - m_PaneInfo[ePane_Results].cxMin - m_cxSplitter);

        /*
         * remember the scope pane width
         */
        m_PaneInfo[ePane_ScopeTree].cx = cxScope;
    }

    CRect rectScope = rectRemaining;
    rectScope.right = rectScope.left + cxScope;


    /*
     * remove space used by the scope pane
     * (and splitter) from the remaining area
     */
    if (IsScopePaneVisible())
    {
        m_rectVSplitter.left   = rectScope.right;
        m_rectVSplitter.top    = rectScope.top;
        m_rectVSplitter.right  = rectScope.right + m_cxSplitter;
        m_rectVSplitter.bottom = rectScope.bottom;

        rectRemaining.left     = m_rectVSplitter.right;

        /*
         * Inflate the splitter rect to give a little bigger hot area.
         * We need to do this logically instead of physically (i.e. instead
         * of increasing m_cxSplitter) to keep the visuals right.
         */
        m_rectVSplitter.InflateRect (GetSystemMetrics (SM_CXEDGE), 0);

    }
    else
        m_rectVSplitter = g_rectEmpty;


    /*
     * scope pane
     */
    dwp.AddWindow (GetPaneView(ePane_ScopeTree), rectScope,
                   SWP_NOZORDER | SWP_NOACTIVATE |
                        (IsScopePaneVisible() ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultPane
 *
 * Lays out the children of the result pane.
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultPane (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    /*
     * Note:  the order of these calls to LayoutXxx is *critical*.
     */
    LayoutResultDescriptionBar (dwp, rectRemaining);
    LayoutResultFolderTabView  (dwp, rectRemaining);

    m_rectResultFrame = rectRemaining;

    LayoutResultView           (dwp, rectRemaining);

    /*
     * remember the final width of the result pane in m_PaneInfo[ePane_Results].cx
     */
    m_PaneInfo[ePane_Results].cx = m_rectResultFrame.Width();
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultFolderTabView
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultFolderTabView (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    DECLARE_SC(sc, TEXT("CAMCView::LayoutResultFolderTabView"));

    sc = ScCheckPointers(m_pResultFolderTabView, E_UNEXPECTED);
    if (sc)
        return;

    // layout the folder tab control - always on top.
    bool bVisible = AreTaskpadTabsAllowed() && m_pResultFolderTabView->IsVisible();

    CRect rectFolder;

    if (bVisible)
        m_pResultFolderTabView->Layout(rectRemaining, rectFolder);
    else
        rectFolder = g_rectEmpty;

    DWORD dwPosFlags = SWP_NOZORDER | SWP_NOACTIVATE |
                            (bVisible ? SWP_SHOWWINDOW : SWP_HIDEWINDOW);
    dwp.AddWindow (m_pResultFolderTabView, rectFolder, dwPosFlags);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultDescriptionBar
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultDescriptionBar (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    DWORD dwPosFlags = SWP_NOZORDER | SWP_NOACTIVATE;
    CRect rectT      = rectRemaining;

    if (IsDescBarVisible() && !rectT.IsRectEmpty())
    {
        rectT.bottom      = rectT.top + m_RightDescCtrl.GetHeight();
        rectRemaining.top = rectT.bottom;
        dwPosFlags |= SWP_SHOWWINDOW;
    }
    else
    {
        dwPosFlags |= SWP_HIDEWINDOW;
    }

    dwp.AddWindow (&m_RightDescCtrl, rectT, dwPosFlags);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultView
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultView (CDeferWindowPos& dwp, const CRect& rectRemaining)
{
    DECLARE_SC (sc, _T("CAMCView::LayoutResultView"));
    Trace (tagLayout, _T("CAMCView::LayoutResultView"));
    CWnd* pwndResult = GetPaneView(ePane_Results);

    /*
     * we should never think the view is extended if we don't also have
     * a view extension web host control
     */
    ASSERT (!(m_fViewExtended && (m_pViewExtensionCtrl == NULL)));

    /*
     * if it exists, the view extension control is always at the bottom of
     * the Z-order, and visible if the view is being extended
     */
    if(m_pViewExtensionCtrl != NULL)
    {
        /*
         * note no SWP_NOZORDER
         */
        DWORD dwPosFlags = SWP_NOACTIVATE | ((m_fViewExtended)
                                    ? SWP_SHOWWINDOW
                                    : SWP_HIDEWINDOW);

        dwp.AddWindow (m_pViewExtensionCtrl, rectRemaining,
                       dwPosFlags, &CWnd::wndBottom);
    }

    /*
     * If the view's not extended, show or hide the result window based on
     * whether there's any room left in the positioning rectangle.  (If the
     * view is extended, the result window will have been hidden when the
     * view extension was applied (in ScApplyViewExtension), and possibly
     * redisplayed by the extension in ScSetViewExtensionFrame.)
     */
    if (!m_fViewExtended)
    {
        DWORD dwFlags = SWP_NOZORDER | SWP_NOACTIVATE |
                        (rectRemaining.IsRectEmpty() ? SWP_HIDEWINDOW : SWP_SHOWWINDOW);

        dwp.AddWindow (pwndResult, rectRemaining, dwFlags);
    }

    /*
     * lists in extended views and listpads don't get a border, all others do
     */
    if (HasListOrListPad())
    {
        if (HasListPad())
        {
            sc = ScCheckPointers (m_pListCtrl, E_UNEXPECTED);
            if (sc)
                return;

            CWnd* pwndListCtrl = m_pListCtrl->GetListViewPtr();
            sc = ScCheckPointers (pwndListCtrl, E_UNEXPECTED);
            if (sc)
                return;

            pwndListCtrl->ModifyStyleEx (WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);  // remove border
        }

        else if (m_fViewExtended)
            pwndResult->ModifyStyleEx (WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);  // remove border
        else
            pwndResult->ModifyStyleEx (0, WS_EX_CLIENTEDGE, SWP_FRAMECHANGED);  // add border
    }
}

//
// Tracking and and hit testing methods
//


//+-------------------------------------------------------------------------
//
//  Function:   HitTestPane
//
//  Synopsis:   Test which pane contains the point arg, or ePane_None for
//              the splitter bar
//
//--------------------------------------------------------------------------

int CAMCView::HitTestPane(CPoint& point)
{
    TRACE_METHOD(CAMCView, HitTestPane);

    if (PtInWindow(m_pTreeCtrl, point))
        return ePane_ScopeTree;

    if (m_PaneInfo[ePane_Results].pView &&
        PtInWindow(m_PaneInfo[ePane_Results].pView, point))
        return ePane_Results;

    return ePane_None;
}


HNODE CAMCView::GetSelectedNode(void)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    TRACE_METHOD(CAMCView, GetSelectedNode);

    // When the tree is empty we don't want to AV
    HTREEITEM hti = m_pTreeCtrl->GetSelectedItem();
    if (hti == NULL)
        return NULL;

    HNODE hNode = m_pTreeCtrl->GetItemNode(hti);
    return hNode;
}


HNODE CAMCView::GetRootNode(void)
{
    TRACE_METHOD(CAMCView, GetSelectedNode);

    // When the tree is empty we don't want to AV
    HTREEITEM hti = m_pTreeCtrl->GetRootItem();
    if (hti == NULL)
        return NULL;

    HNODE hNode = m_pTreeCtrl->GetItemNode(hti);
    return hNode;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScUpdateWindowTitle
 *
 * PURPOSE: Updates the window title and informs observers about the change.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScUpdateWindowTitle()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScUpdateWindowTitle"));

    CChildFrame* pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame);
    if(sc)
        return sc;

    if (pFrame)
        pFrame->OnUpdateFrameTitle(TRUE);

    sc = ScFireEvent(CAMCViewObserver::ScOnViewTitleChanged, this);

    return sc;
}

BOOL CAMCView::RenameItem(HNODE hNode, BOOL bScopeItem, MMC_COOKIE lResultItemCookie,
                          LPWSTR pszText, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCView::RenameItem"));

    sc = S_FALSE;

    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));

    selInfo.m_bScope = bScopeItem;
    selInfo.m_lCookie = lResultItemCookie;

    if (pszText != NULL)
    {
        USES_CONVERSION;

        /*
         * Bug 322184:  The snap-in may throw up some UI on this notification.
         * The list or tree may have captured the mouse to look for a drag,
         * which will interfere with the snap-in's UI.  Release the capture
         * during the callback and put it back when we're done.
         */
        HWND hwndCapture = ::SetCapture (NULL);

        sc = m_spNodeCallback->Notify(hNode, NCLBK_RENAME,
                reinterpret_cast<LPARAM>(&selInfo), reinterpret_cast<LPARAM>(pszText));

        /*
         * put the capture back
         */
        ::SetCapture (hwndCapture);
    }

    *pResult = (sc == SC(S_OK));
    if (*pResult)
    {
        sc = ScUpdateWindowTitle();
        if(sc)
            sc.TraceAndClear();
    }

    return TRUE;
}

BOOL CAMCView::DispatchListCtrlNotificationMsg(LPARAM lParam, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCView::DispatchListCtrlNotificationMsg"));

    TRACE_METHOD(CAMCView, DispatchListCtrlNotificationMsg);

    NM_LISTVIEW *pNm = reinterpret_cast<NM_LISTVIEW*>(lParam);
    BOOL bReturn = TRUE;

    switch (pNm->hdr.code)
    {
    case NM_RCLICK:
        bReturn = FALSE;  // In case of right click send the select notification to the snapin
                          // but return FALSE so that message is further processed to display
                          // context menu.

        // Fall thro into NM_CLICK
    case NM_CLICK:
        {
            sc = ScOnLeftOrRightMouseClickInListView();
            if (sc)
                return bReturn;
        }
        break;

    case NM_DBLCLK:
        OnListCtrlItemDblClk();
        break;

    case NM_CUSTOMDRAW:
        *pResult = m_pListCtrl->OnCustomDraw (
                            reinterpret_cast<NMLVCUSTOMDRAW *>(lParam));
        break;

    case LVN_BEGINLABELEDITA:
    case LVN_BEGINLABELEDITW:
    {
        CMainFrame* pFrame = AMCGetMainWnd();

        if ((pFrame != NULL) && (IsVerbEnabled(MMC_VERB_RENAME) ||
                                 m_bRenameListPadItem == true))
        {
            pFrame->SetInRenameMode(true);
            return FALSE;
        }
        else
        {
            return TRUE;
        }

        break;
    }

    case LVN_ENDLABELEDITW:
    case LVN_ENDLABELEDITA:
    {
        CMainFrame* pFrame = AMCGetMainWnd();
        if (pFrame != NULL)
            pFrame->SetInRenameMode(false);

        LPARAM lResultParam = 0;
        long index = -1;
        LPWSTR pszText = NULL;

        if (pNm->hdr.code == LVN_ENDLABELEDITW)
        {
            LV_DISPINFOW* pdi = (LV_DISPINFOW*) lParam;
            index = pdi->item.iItem;
            pszText = pdi->item.pszText;
            lResultParam = pdi->item.lParam;
        }
        else // if (pNm->hdr.code == LVN_ENDLABELEDIT)
        {
            LV_DISPINFO* pdi = (LV_DISPINFO*) lParam;
            index = pdi->item.iItem;
            USES_CONVERSION;
            pszText = T2W(pdi->item.pszText);
            lResultParam = pdi->item.lParam;
        }

        if (IsVirtualList())
        {
            // for virtual list pass the item index rather than the lparam
            HNODE hNodeSel = GetSelectedNode();
            RenameItem(hNodeSel, FALSE, index, pszText, pResult);
        }
        else
        {
            CResultItem* pri = CResultItem::FromHandle (lResultParam);

            if (pri != NULL)
            {
                if (pri->IsScopeItem())
                    RenameItem(pri->GetScopeNode(), TRUE, 0, pszText, pResult);
                else
                    RenameItem(GetSelectedNode(), FALSE, pri->GetSnapinData(), pszText, pResult);
            }
        }

        break;
    }

    case LVN_GETDISPINFOW:
    {
        LV_DISPINFOW *pDispInfo = reinterpret_cast<LV_DISPINFOW*>(lParam);

        // If column is hidden do not forward the call to snapin.
        if (m_pListCtrl && m_pListCtrl->IsColumnHidden(pDispInfo->item.iSubItem))
            break;

		HNODE hNode = GetSelectedNode();
		if (hNode)
			m_spNodeCallback->GetDispInfo (GetSelectedNode(), &pDispInfo->item);
		else
			bReturn = FALSE;

        break;
    }

    case LVN_GETDISPINFOA:
    {
        LV_DISPINFOA *pDispInfo = reinterpret_cast<LV_DISPINFOA*>(lParam);
        ASSERT (pDispInfo != NULL);

        // If column is hidden do not forward the call to snapin.
        if (m_pListCtrl && m_pListCtrl->IsColumnHidden(pDispInfo->item.iSubItem))
            break;

		HNODE hNode = GetSelectedNode();
		if (! hNode)
		{
			bReturn = FALSE;
			break;
		}

        /*
         * put the data in the UNICODE structure for the query
         */
        LV_ITEMW lviW;
        lviW.mask       = pDispInfo->item.mask;
        lviW.iItem      = pDispInfo->item.iItem;
        lviW.iSubItem   = pDispInfo->item.iSubItem;
        lviW.state      = pDispInfo->item.state;
        lviW.stateMask  = pDispInfo->item.stateMask;
        lviW.cchTextMax = pDispInfo->item.cchTextMax;
        lviW.iImage     = pDispInfo->item.iImage;
        lviW.lParam     = pDispInfo->item.lParam;
        lviW.iIndent    = pDispInfo->item.iIndent;

        if (pDispInfo->item.mask & LVIF_TEXT)
            lviW.pszText = new WCHAR[pDispInfo->item.cchTextMax];

        /*
         * convert to ANSI
         */
        if  (SUCCEEDED (m_spNodeCallback->GetDispInfo (GetSelectedNode(), &lviW)) &&
            (pDispInfo->item.mask & LVIF_TEXT))
        {
            WideCharToMultiByte (CP_ACP, 0, lviW.pszText, -1,
                                 pDispInfo->item.pszText,
                                 pDispInfo->item.cchTextMax,
                                 NULL, NULL);
        }

        if (pDispInfo->item.mask & LVIF_TEXT)
            delete [] lviW.pszText;

        /*
         * copy the results back to the ANSI structure
         */
        pDispInfo->item.mask       = lviW.mask;
        pDispInfo->item.iItem      = lviW.iItem;
        pDispInfo->item.iSubItem   = lviW.iSubItem;
        pDispInfo->item.state      = lviW.state;
        pDispInfo->item.stateMask  = lviW.stateMask;
        pDispInfo->item.cchTextMax = lviW.cchTextMax;
        pDispInfo->item.iImage     = lviW.iImage;
        pDispInfo->item.lParam     = lviW.lParam;
        pDispInfo->item.iIndent    = lviW.iIndent;
        break;
    }

    case LVN_DELETEALLITEMS:
        // return TRUE to prevent notification for each item
        return TRUE;

    case LVN_ITEMCHANGED:
        bReturn = OnListItemChanged (pNm);
        break;

    case LVN_ODSTATECHANGED:
        // The state of an item or range of items has changed in virtual list.
        return OnVirtualListItemsStateChanged(reinterpret_cast<LPNMLVODSTATECHANGE>(lParam));
        break;

    case LVN_ODFINDITEMA:
    case LVN_ODFINDITEMW:
        {
            USES_CONVERSION;

            NM_FINDITEM *pNmFind = reinterpret_cast<NM_FINDITEM*>(lParam);
            ASSERT(IsVirtualList() && (pNmFind->lvfi.flags & LVFI_STRING));

            LPOLESTR polestr = NULL;
            if (pNm->hdr.code == LVN_ODFINDITEMW)
            {
                LVFINDINFOW* pfiw = reinterpret_cast<LVFINDINFOW*>(&pNmFind->lvfi);
                polestr = const_cast<LPOLESTR>(pfiw->psz);
            }
            else
            {
                LVFINDINFOA* pfi = reinterpret_cast<LVFINDINFOA*>(&pNmFind->lvfi);
                polestr = A2W(const_cast<LPSTR>(pfi->psz));
            }
            Dbg(DEB_USER1, _T("\n********************** polestr = %ws\n"), polestr);
            RESULTFINDINFO findInfo;
            findInfo.psz = polestr;
            findInfo.nStart = pNmFind->iStart;
            findInfo.dwOptions = 0;

            // Listview bug: LVFI_SUBSTRING is not defined in the SDK headers and the
            // listview sets it instead of LVFI_PARTIAL when it wants a
            // partial match. So for now, define it here and test for both.
            #define LVFI_SUBSTRING 0x0004

            if (pNmFind->lvfi.flags & (LVFI_PARTIAL | LVFI_SUBSTRING))
                findInfo.dwOptions |= RFI_PARTIAL;

            if (pNmFind->lvfi.flags & LVFI_WRAP)
                findInfo.dwOptions |= RFI_WRAP;

            HNODE hNodeSel = GetSelectedNode();
            INodeCallback* pNC = GetNodeCallback();
            ASSERT(pNC != NULL);

            pNC->Notify(hNodeSel, NCLBK_FINDITEM,
                        reinterpret_cast<LPARAM>(&findInfo),
                        reinterpret_cast<LPARAM>(pResult));
        }
        break;

    case LVN_ODCACHEHINT:
        {
            NM_CACHEHINT *pNmHint = reinterpret_cast<NM_CACHEHINT*>(lParam);

            ASSERT(IsVirtualList());

            HNODE hNodeSel = GetSelectedNode();
            INodeCallback* pNC = GetNodeCallback();
            ASSERT(pNC != NULL);

            pNC->Notify(hNodeSel, NCLBK_CACHEHINT, pNmHint->iFrom, pNmHint->iTo);
        }

        break;

    case LVN_KEYDOWN:
        {
            NMLVKEYDOWN *pNmKeyDown = reinterpret_cast<NMLVKEYDOWN*>(lParam);

            switch (pNmKeyDown->wVKey)
            {
                case VK_DELETE:
                {
                    if (!IsVerbEnabled(MMC_VERB_DELETE))
                        break;

                    INodeCallback* pCallback = GetNodeCallback();
                    ASSERT(pCallback != NULL);
                    if (pCallback == NULL)
                        break;

                    HNODE hNode = GetSelectedNode();
                    if (hNode == 0)
                        break;

                    int cSel = m_pListCtrl->GetSelectedCount();
                    ASSERT(cSel >= 0);

                    LPARAM lvData;
                    if (cSel == 0)
                    {
                        break;
                    }
                    else if (cSel == 1)
                    {
                        if (_GetLVSelectedItemData(&lvData) == -1)
                            break;
                    }
                    else if (cSel > 1)
                    {
                        lvData = LVDATA_MULTISELECT;
                    }
                    else
                    {
                        break;
                    }

                    pCallback->Notify(hNode, NCLBK_DELETE, FALSE, lvData);
                    break;
                }
                break;

                case VK_TAB:
                    GetParentFrame()->SetActiveView (m_pTreeCtrl);
                    break;

                case VK_BACK:
                    ScUpOneLevel();
                    break;

                case VK_RETURN:
                    if(GetKeyState(VK_MENU)<0) // has the ALT key been pressed?
                    {
                        // Process <ALT><ENTER>
                        if (! IsVerbEnabled(MMC_VERB_PROPERTIES))
                            break;

                        LPARAM lvData = 0;

                        if (HasList())
                        {
                            ASSERT (m_pListCtrl != NULL);
                            ASSERT (GetParentFrame()->GetActiveView() == m_pListCtrl->GetListViewPtr());

                            int cSel = m_pListCtrl->GetSelectedCount();
                            ASSERT(cSel >= 0);

                            lvData = LVDATA_ERROR;
                            if (cSel == 0)
                                lvData = LVDATA_BACKGROUND;
                            else if (cSel == 1)
                                _GetLVSelectedItemData(&lvData);
                            else if (cSel > 1)
                                lvData = LVDATA_MULTISELECT;

                            ASSERT(lvData != LVDATA_ERROR);
                            if (lvData == LVDATA_ERROR)
                                break;

                            if (lvData == LVDATA_BACKGROUND)
                                break;
                        }
                        else if (HasOCX())
                        {
                            lvData = LVDATA_CUSTOMOCX;
                        }
                        else
                        {
                            ASSERT(HasWebBrowser());
                            lvData = LVDATA_CUSTOMWEB;
                        }

                        INodeCallback* pNC = GetNodeCallback();
                        ASSERT(pNC != NULL);
                        if (pNC == NULL)
                            break;

                        HNODE hNodeSel = GetSelectedNode();
                        ASSERT(hNodeSel != NULL);
                        if (hNodeSel == NULL)
                            break;

                        pNC->Notify(hNodeSel, NCLBK_PROPERTIES, FALSE, lvData);
                        break;
                    }
                    else     // nope, the ALT key has not been pressed.
                    {
                        // do the default verb.
                        OnListCtrlItemDblClk();
                    }
                    break;

                default:
                    bReturn = OnSharedKeyDown(pNmKeyDown->wVKey);
                    break;
            }
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnLeftOrRightMouseClickInListView
//
//  Synopsis:    Left or right mouse button is clicked on the list view, see
//               if it is clicked on list-view background. If so send a select.
//
//               Click on list view background is treated as scope owner item selected.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnLeftOrRightMouseClickInListView()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnLeftOrRightMouseClickInListView"));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    CAMCListView *pAMCListView = m_pListCtrl->GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc;

    CPoint pt;
    GetCursorPos(&pt);
    pAMCListView->ScreenToClient(&pt);

    UINT uFlags = 0;
    int iItem = pAMCListView->GetListCtrl().HitTest(pt, &uFlags);
    Dbg(DEB_USER1, _T("----- HitTest > %d \n"), iItem);

    // Make sure mouse click is in the ListView and there are
    // no items selected in the list view.
    if ( (iItem == -1) &&
         !(uFlags & (LVHT_ABOVE | LVHT_BELOW | LVHT_TOLEFT | LVHT_TORIGHT) ) &&
         (m_pListCtrl->GetSelectedCount() == 0) )
    {
        INodeCallback* pNC = GetNodeCallback();
        sc = ScCheckPointers(pNC, E_UNEXPECTED);
        if (sc)
            return sc;

        HNODE hNodeSel = GetSelectedNode();

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = TRUE;
        selInfo.m_bDueToFocusChange = TRUE;
        selInfo.m_bBackground = TRUE;
        selInfo.m_lCookie = LVDATA_BACKGROUND;

        sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, true, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 * CAMCView::OnListItemChanged
 *
 * WM_NOTIFY (LVN_ITEMCHANGED) handler for CAMCView.
 *
 * return true as message is handled here.
 *--------------------------------------------------------------------------*/

bool CAMCView::OnListItemChanged (NM_LISTVIEW* pnmlv)
{
    DECLARE_SC (sc, _T("CAMCView::OnListItemChanged"));

    bool bOldState = (pnmlv->uOldState & LVIS_SELECTED);
    bool bNewState = (pnmlv->uNewState & LVIS_SELECTED);

    // is this a selection change?
    if ( (pnmlv->uChanged & LVIF_STATE) &&
         (bOldState != bNewState) )
    {
        const int cSelectedItems = m_pListCtrl->GetSelectedCount();

#ifdef DBG
        Trace (tagListSelection,
               _T("Item %d %sselected, %d total items selected"),
               pnmlv->iItem,
               (pnmlv->uOldState & LVIS_SELECTED) ? _T("de") : _T("  "),
               cSelectedItems);
#endif

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));

        selInfo.m_bScope = FALSE;
        selInfo.m_pView = NULL;
        selInfo.m_lCookie = IsVirtualList() ? pnmlv->iItem : pnmlv->lParam;

        /*
         * If user is (de)selecting multiple items using control and/or shift keys
         * then defer the multi-select notification until we're quiescent
         * with the exception of only one item being (de)selected.
         */
        if ((IsKeyPressed(VK_SHIFT) || IsKeyPressed(VK_CONTROL)) &&
            (GetParentFrame()->GetActiveView() == m_pListCtrl->GetListViewPtr()) &&
            (cSelectedItems > 1) )
        {
            // See ScPostMultiSelectionChangesMessage (this handles both selection
            // and de-selection of multiple items).
            sc = ScPostMultiSelectionChangesMessage();
            if (sc)
                sc.TraceAndClear();

            return (true);
        }
        else
        {
            m_bProcessMultiSelectionChanges = false;
        }

        HNODE hNodeSel = GetSelectedNode();
        INodeCallback* pNC = GetNodeCallback();
        sc = ScCheckPointers(pNC, (void*) hNodeSel, E_UNEXPECTED);
        if (sc)
            return (true);

        // item = -1 is only expected for deselect in virtual list
        ASSERT( pnmlv->iItem != -1 || (IsVirtualList() && (pnmlv->uOldState & LVIS_SELECTED)));

        if (pnmlv->uOldState & LVIS_SELECTED)
        {
            if (cSelectedItems == 0)
            {
                if (!m_bLastSelWasMultiSel)
                {
                    sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, false, &selInfo);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;
                }
                else
                {
                    m_bLastSelWasMultiSel = false;
                    sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;
                }
            }
            else if (m_bLastSelWasMultiSel)
            {
                // may need to cancel multiselect and send single select notify.
                // if another change comes in, it will cancel the delayed message
                // This fixes a problem that is caused by large icon mode not
                // sending as many noifications as the other modes.

                // See ScPostMultiSelectionChangesMessage (this handles both selection
                // and de-selection of multiple items).
                sc = ScPostMultiSelectionChangesMessage();
                if (sc)
                    sc.TraceAndClear();
            }
        }
        else if (pnmlv->uNewState & LVIS_SELECTED)
        {
            ASSERT(cSelectedItems >= 1);

            if (cSelectedItems == 1)
            {
                sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, true, &selInfo);
                if (sc)
                    sc.TraceAndClear(); // ignore & continue;
            }
            else
            {
                sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, true, 0);
                if (sc)
                    sc.TraceAndClear(); // ignore & continue;

                m_bLastSelWasMultiSel = true;
            }
        }
    }

    return (true);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnVirtualListItemsStateChanged
//
//  Synopsis:    The state of an item or range of items has changed in virtual list.
//
//  Arguments:   lpStateChange -
//
//  Returns:     should return 0 according to docs.
//
//--------------------------------------------------------------------
int CAMCView::OnVirtualListItemsStateChanged(LPNMLVODSTATECHANGE lpStateChange )
{
    DECLARE_SC(sc, TEXT("CAMCView::OnVirtualListItemsStateChanged"));
    sc = ScCheckPointers(lpStateChange);
    if (sc)
    {
        sc.TraceAndClear();
        return 0;
    }

    bool bOldState = (lpStateChange->uOldState & LVIS_SELECTED);
    bool bNewState = (lpStateChange->uNewState & LVIS_SELECTED);
    int  cItems    = (lpStateChange->iTo - lpStateChange->iFrom) + 1;

#ifdef DBG
        Trace (tagListSelection,
               _T("Items %d to %d were %sselected, %d total items selected"),
               lpStateChange->iFrom, lpStateChange->iTo,
               bOldState ? _T("de") : _T("  "),
               cItems );
#endif

    if (bOldState != bNewState)
    {
        sc = ScPostMultiSelectionChangesMessage();
        if (sc)
            sc.TraceAndClear();
    }

    return (0);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScPostMultiSelectionChangesMessage
//
//  Synopsis:    Post selection change message (need to post because multi-sel
//               may not be over, wait till it is quiet.)
//
//               This method posts message telling selection states of multiple
//               items are changed but not if they are selected or de-selected.
//               The m_bLastSelWasMultiSel is used to determine if it is
//               selection or de-selection.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScPostMultiSelectionChangesMessage ()
{
    DECLARE_SC(sc, _T("CAMCView::ScPostMultiSelectionChangesMessage"));

    /*
    * This is a multi-selection, defer notification until we're quiescent
    */
    m_bProcessMultiSelectionChanges = true;
    PostMessage (m_nProcessMultiSelectionChangesMsg);

    // We need to disable all the toolbars, menubuttons
    // during multiselect. Above PostMessage enables
    // stdbar and MMC menubuttons.
    CAMCViewToolbarsMgr* pAMCViewToolbarsMgr = m_ViewData.GetAMCViewToolbarsMgr();
    CMenuButtonsMgr* pMenuBtnsMgr = m_ViewData.GetMenuButtonsMgr();

    sc = ScCheckPointers(pAMCViewToolbarsMgr, pMenuBtnsMgr, E_UNEXPECTED);
    if (sc)
        return 0;

    pAMCViewToolbarsMgr->ScDisableToolbars();
    pMenuBtnsMgr->ScDisableMenuButtons();

    return (sc);
}

void CAMCView::OpenResultItem(HNODE hNode)
{
    /*
     * Bug 139695:  Make certain this function doesn't need to change the
     * active view.  We should only get here as a result of double- clicking
     * or pressing Enter on a scope node in the result pane, in which case
     * the result pane should already be the active view.  If it is, we don't
     * need to change the active view, which can cause the problems listed in
     * the bug.
     */
    ASSERT (m_pListCtrl != NULL);
    ASSERT (GetParentFrame() != NULL);
    ASSERT (GetParentFrame()->GetActiveView() == m_pListCtrl->GetListViewPtr());

    ASSERT(m_pTreeCtrl);
    HTREEITEM htiParent = m_pTreeCtrl->GetSelectedItem();
    ASSERT(htiParent != NULL);

    m_pTreeCtrl->ExpandNode(htiParent);
    m_pTreeCtrl->Expand(htiParent, TVE_EXPAND);

    HTREEITEM hti = m_pTreeCtrl->GetChildItem(htiParent);

    if (hti == NULL)
        return;

    while (hti)
    {
        if (m_pTreeCtrl->GetItemNode(hti) == hNode)
            break;

        hti = m_pTreeCtrl->GetNextItem(hti, TVGN_NEXT);
    }

    if (hti != 0)
    {
        m_pTreeCtrl->Expand(htiParent, TVE_EXPAND);
        m_pTreeCtrl->SelectItem(hti);
    }
}

BOOL CAMCView::OnListCtrlItemDblClk(void)
{
    TRACE_METHOD(CAMCView, OnListCtrlItemDblClk);

    LPARAM lvData = -1;
    if (_GetLVSelectedItemData(&lvData) == -1)
        lvData = LVDATA_BACKGROUND;

    HNODE hNodeSel = GetSelectedNode();
    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);
    if (!pNC)
        return FALSE;

    HRESULT hr = pNC->Notify(hNodeSel, NCLBK_DBLCLICK, lvData, 0);
    if (hr == S_FALSE)
    {
        ASSERT(lvData != LVDATA_BACKGROUND);
        if (!IsVirtualList())
        {
            CResultItem* pri = CResultItem::FromHandle (lvData);

            if ((pri != NULL) && pri->IsScopeItem())
                OpenResultItem (pri->GetScopeNode());
        }
    }

    return TRUE;
}


BOOL CAMCView::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnNotify"));

    NMHDR *pNmHdr = reinterpret_cast<NMHDR*>(lParam);

    sc = ScCheckPointers(pNmHdr, pResult);
    if (sc)
    {
        sc.TraceAndClear();
        return CView::OnNotify(wParam, lParam, pResult);
    }

    *pResult = TRUE; // init

    switch(pNmHdr->code)
    {
    case HDN_ENDTRACKA: // Save the column width changes.
    case HDN_ENDTRACKW: // HDN_BEGINTRACK handles dis-allowing hidden column dragging.
        {
            NMHEADER* nmh = (NMHEADER*)lParam;

            CAMCListView *pAMCListView = m_pListCtrl->GetListViewPtr();
            SC sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
            if (sc)
            {
                sc.TraceAndClear();
                return FALSE;
            }

            sc = pAMCListView->ScOnColumnsAttributeChanged(nmh, HDN_ENDTRACK);
            if (sc)
            {
                sc.TraceAndClear();
                return FALSE;
            }

            // S_FALSE : dont allow the change
            if (sc == SC(S_FALSE))
                return TRUE;

            return CView::OnNotify(wParam, lParam, pResult);
        }
        break;

    case HDN_ENDDRAG: // Column order changes.
        {
            NMHEADER* nmh = (NMHEADER*)lParam;
            if (nmh->pitem->mask & HDI_ORDER)
            {
                CAMCListView *pAMCListView = m_pListCtrl->GetListViewPtr();
                SC sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
                if (sc)
                {
                    sc.TraceAndClear();
                    return FALSE;
                }

                sc = pAMCListView->ScOnColumnsAttributeChanged(nmh, HDN_ENDDRAG);
                if (sc)
                {
                    sc.TraceAndClear();
                    return FALSE;
                }

                // S_FALSE : dont allow the change
                if (sc = SC(S_FALSE))
                    return TRUE;
            }

            return CView::OnNotify(wParam, lParam, pResult);
        }
        break;

    case TVN_BEGINLABELEDIT:
        {
            TV_DISPINFO* ptvdi = (TV_DISPINFO*)lParam;
            if ((ptvdi->item.lParam == CAMCTreeView::LParamFromNode (GetSelectedNode())) &&
                (IsVerbEnabled(MMC_VERB_RENAME) == FALSE))
            {
                return TRUE;
            }

            CMainFrame* pFrame = AMCGetMainWnd();
            if (pFrame != NULL)
                pFrame->SetInRenameMode(true);

            return FALSE;
        }

    case TVN_ENDLABELEDIT:
        {
            TV_DISPINFO* ptvdi = (TV_DISPINFO*)lParam;
            CMainFrame* pFrame = AMCGetMainWnd();
            if (pFrame != NULL)
                pFrame->SetInRenameMode(false);

            USES_CONVERSION;
            return RenameItem(CAMCTreeView::NodeFromLParam (ptvdi->item.lParam), TRUE, 0,
                              T2W(ptvdi->item.pszText), pResult);
        }

    case TVN_KEYDOWN:
        {
            TV_KEYDOWN* ptvkd = reinterpret_cast<TV_KEYDOWN*>(lParam);
            if (ptvkd->wVKey == VK_TAB)
            {
                ScSetFocusToResultPane();
                return TRUE;
            }
            else
            {
                return OnSharedKeyDown(ptvkd->wVKey);
            }
        }

    }

    if (UsingDefColumns() &&
        (pNmHdr->code == HDN_ENDTRACKA || pNmHdr->code == HDN_ENDTRACKW))
    {
        // WARNING: If HD_NOTIFY::pitem::pszText needs to be used you should cast
        // lParam to either HD_NOTIFYA or HD_NOTIFYW depending on the pNmHdr->code
        HD_NOTIFY* phdn = reinterpret_cast<HD_NOTIFY*>(lParam);
        ASSERT(phdn != NULL);

        if (phdn->pitem->mask & HDI_WIDTH)
        {
            int alWidths[2] = {0, 0};
            GetDefaultColumnWidths(alWidths);
            alWidths[phdn->iItem] = phdn->pitem->cxy;
            SetDefaultColumnWidths(alWidths, FALSE);
            return TRUE;
        }
    }

#ifdef DBG
    if (m_pTreeCtrl && m_pTreeCtrl->m_hWnd == pNmHdr->hwndFrom)
    {
        switch (pNmHdr->code)
        {
        case NM_CLICK:  Dbg(DEB_USER2, "\t Tree item clicked\n"); break;
        case NM_DBLCLK: Dbg(DEB_USER2, "\t Tree item dbl-clicked\n"); break;
        case NM_RCLICK: Dbg(DEB_USER2, "\t Tree item R-clicked\n"); break;
        default: break;
        }
    }
#endif

    // HasList() is added to prevent dispatching notifications, when AMCView thinks
    // it does not have a list. This lead to wrong assumptions about the list type
    // and as a result - AV handling messages like GetDisplayInfo
    // See BUG 451896
    if (m_pListCtrl && HasListOrListPad())
    {
        if (m_pListCtrl->GetListViewHWND() == pNmHdr->hwndFrom)
        {
            if (DispatchListCtrlNotificationMsg(lParam, pResult) == TRUE)
                return TRUE;
        }
        else if (m_pListCtrl->GetHeaderCtrl() && m_pListCtrl->GetHeaderCtrl()->m_hWnd == pNmHdr->hwndFrom)
        {
            switch(pNmHdr->code)
            {
                case HDN_ITEMCLICKA:
                case HDN_ITEMCLICKW:
                {
                    HNODE hNodeSel = GetSelectedNode();

                    HD_NOTIFY* phdn = reinterpret_cast<HD_NOTIFY*>(lParam);
                    ASSERT(phdn != NULL);
                    int nCol = phdn->iItem;

                    sc = m_spNodeCallback->Notify(hNodeSel, NCLBK_COLUMN_CLICKED, 0, nCol);
                    if (sc)
                        sc.TraceAndClear();

                    return TRUE;
                }

                // filter related code
                case HDN_FILTERCHANGE:
                {
                    HNODE hNodeSel = GetSelectedNode();
                    int nCol = ((NMHEADER*)lParam)->iItem;
                    sc = m_spNodeCallback->Notify(hNodeSel, NCLBK_FILTER_CHANGE, MFCC_VALUE_CHANGE, nCol);
                    if (sc)
                        sc.TraceAndClear();

                    return TRUE;
                }

                case HDN_FILTERBTNCLICK:
                {
                    HNODE hNodeSel = GetSelectedNode();
                    int nCol = ((NMHDFILTERBTNCLICK*)lParam)->iItem;
                    RECT rc = ((NMHDFILTERBTNCLICK*)lParam)->rc;

                    // rect is relative to owning list box, convert to screen
                    ::MapWindowPoints(m_pListCtrl->GetListViewHWND(), NULL, (LPPOINT)&rc, 2);

                    sc = m_spNodeCallback->Notify(hNodeSel, NCLBK_FILTERBTN_CLICK, nCol, (LPARAM)&rc);
                    *pResult = (sc == SC(S_OK));
                    if (sc)
                        sc.TraceAndClear();

                    return TRUE;
                }
            }
        }
    }

    return CView::OnNotify(wParam, lParam, pResult);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnMinimize
 *
 * PURPOSE: Send the NCLBK_MINIMIZED notification to the node manager.
 *
 * PARAMETERS:
 *    bool  fMinimized : TRUE if the window is being minimized, false if maximized.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnMinimize(bool fMinimized)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnMinimize"));

    HNODE hNode = GetSelectedNode();

    if (hNode == NULL)
        return (sc = E_FAIL);

    INodeCallback*  pNodeCallback = GetNodeCallback();

    if (pNodeCallback == NULL)
        return (sc = E_FAIL);

    sc =  pNodeCallback->Notify (hNode, NCLBK_MINIMIZED, fMinimized, 0);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnSize
 *
 * PURPOSE: Send the size notification to all
 *
 * PARAMETERS:
 *    UINT  nType :
 *    int   cx :
 *    int   cy :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnSize(UINT nType, int cx, int cy)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnSize"));

    if (IsPersisted() && GetDocument())
        GetDocument()->SetFrameModifiedFlag(true);

    sc = ScFireEvent(CAMCViewObserver::ScOnViewResized, this, nType, cx, cy);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScActivate
 *
 * PURPOSE: Sets the view as the active view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScActivate()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScActivate"));

    // get the child frame.
    CChildFrame * pChildFrame = GetParentFrame();
    sc = ScCheckPointers(pChildFrame);
    if(sc)
        return sc;

    if (pChildFrame->IsIconic())
        pChildFrame->MDIRestore();
    else
        pChildFrame->MDIActivate(); // activate the child frame.

    return sc;
}


void CAMCView::OnContextMenu(CWnd* pWnd, CPoint point)
{
    TRACE_METHOD(CAMCView, OnContextMenu);

    /*
     * make sure this child frame is active
     */
    CChildFrame* pFrameWnd = GetParentFrame();
    if (NULL == pFrameWnd)
    {
        TRACE(_T("CAMCView::OnContextMenu: failed call to GetParentFrame()\n" ));
        return;
    }

    pFrameWnd->MDIActivate();

    if (NULL == m_pTreeCtrl)
    {
        TRACE(_T("CAMCView::OnContextMenu: tree control not ready\n" ));
        return;
    }

    // (-1,-1) => came from context menu key or Shift-F10
    // Pop-up context for whatever has focus
    if (point.x == -1 && point.y == -1)
    {
        OnShiftF10();
        return;
    }


    switch (HitTestPane(point))
    {
    case ePane_Results:
    {
        CPoint      pointListCtrlCoord = point;
        CListView*  pListView          = m_pListCtrl->GetListViewPtr();
        pListView->ScreenToClient(&pointListCtrlCoord);

        CWnd* pwndHit = pListView->ChildWindowFromPoint (pointListCtrlCoord,
                                                         CWP_SKIPINVISIBLE);

        /*
         * if the hit window isn't the list view, it must be the list's
         * header window; ignore the context menu request
         */
        if (pwndHit != pListView)
        {
            TRACE (_T("CAMCView::OnContextMenu: ignore right-click on result pane header\n"));
            break;
        }

        if (NULL != m_pListCtrl && pWnd->m_hWnd == m_pListCtrl->GetListViewHWND())
            OnListContextMenu(point);
        else
            TRACE(_T("CAMCView::OnContextMenu: result control not ready\n"));

        // CODEWORK should do something here
        break;
    }
    case ePane_ScopeTree:
    {
        TRACE(_T("CAMCView::OnContextMenu: handle right-click on scope pane\n"));
        CPoint pointTreeCtrlCoord = point;
        m_pTreeCtrl->ScreenToClient(&pointTreeCtrlCoord);

        OnTreeContextMenu( point, pointTreeCtrlCoord, NULL );
        break;
    }
    case ePane_Tasks:
        // TO BE ADDED - put up taskpad context menu
        break;

    case ePane_None:
        TRACE(_T("CAMCView::OnContextMenu: ignore right-click on splitter\n"));
        break;

    default:
        TRACE(_T("CAMCView::OnContextMenu: unexpected return value from HitTestPane()\n"));
        ASSERT(FALSE);
    }
}

void CAMCView::OnTreeContextMenu(CPoint& point, CPoint& pointClientCoord, HTREEITEM htiRClicked)
{
    TRACE_METHOD(CAMCView, OnTreeContextMenu);

    if (NULL == m_pTreeCtrl)
    {
        TRACE(_T("CAMCTreeView::OnTreeContextMenu: IFrame not ready\n"));
        return;
    }

    UINT fHitTestFlags = TVHT_ONITEM;

    if (htiRClicked == NULL)
        htiRClicked = m_pTreeCtrl->HitTest(pointClientCoord, &fHitTestFlags);

    switch(fHitTestFlags)
    {
    case TVHT_ABOVE:
    case TVHT_BELOW:
    case TVHT_TOLEFT:
    case TVHT_TORIGHT:
        // Outside the tree view area so return without doing anything.
        return;

    default:
        break;
    }

    if (NULL == htiRClicked || !(fHitTestFlags & TVHT_ONITEM))
    {
        OnContextMenuForTreeBackground(point);
    }
    else
    {
        HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(htiRClicked);
        ASSERT(hNode != 0);

        OnContextMenuForTreeItem(INDEX_INVALID, hNode, point, CCT_SCOPE, htiRClicked);
    }
}

void CAMCView::OnContextMenuForTreeItem(int iIndex, HNODE hNode,
                       CPoint& point, DATA_OBJECT_TYPES type_of_pane,
                       HTREEITEM htiRClicked, MMC_CONTEXT_MENU_TYPES eMenuType,
                       LPCRECT prcExclude, bool bAllowDefaultItem)
{
    TRACE_METHOD(CAMCView, OnContextMenuForTreeItem);
    DECLARE_SC (sc, _T("CAMCView::OnContextMenuForTreeItem"));

    ASSERT(hNode != 0);
    CContextMenuInfo contextInfo;

    contextInfo.m_displayPoint.x     = point.x;
    contextInfo.m_displayPoint.y     = point.y;
    contextInfo.m_eContextMenuType   = eMenuType;
    contextInfo.m_eDataObjectType    = CCT_SCOPE;
    contextInfo.m_bBackground        = FALSE;
    contextInfo.m_bScopeAllowed      = IsScopePaneAllowed();
    contextInfo.m_hWnd               = m_hWnd;
    contextInfo.m_pConsoleView       = this;
    contextInfo.m_bAllowDefaultItem  = bAllowDefaultItem;

    contextInfo.m_hSelectedScopeNode = GetSelectedNode();
    contextInfo.m_htiRClicked        = htiRClicked;
    contextInfo.m_iListItemIndex     = iIndex;

    /*
     * if given, initialize the rectangle not to obscure
     */
    if (prcExclude != NULL)
        contextInfo.m_rectExclude = *prcExclude;


    // If selected scope node is same as node for which context menu is
    // needed, then add savelist, view menus
    if (contextInfo.m_hSelectedScopeNode == hNode)
    {
        // Show view owner items
        contextInfo.m_dwFlags |= CMINFO_SHOW_VIEWOWNER_ITEMS;

        // Don't need to remove temporary selection, since none was applied
        contextInfo.m_pConsoleTree = NULL;

        if (eMenuType == MMC_CONTEXT_MENU_DEFAULT)
            contextInfo.m_dwFlags |= CMINFO_SHOW_VIEW_ITEMS;

        if (HasListOrListPad())
            contextInfo.m_dwFlags |= CMINFO_SHOW_SAVE_LIST;
    }
    else if (htiRClicked) // htiRClicked is NULL for tree items in list view.
    {
        // TempNodeSelect == TRUE -> menu is not for the node that owns the result pane
        sc = m_pTreeCtrl->ScSetTempSelection (htiRClicked);
        if (sc)
            return;

        contextInfo.m_pConsoleTree = m_pTreeCtrl;
        contextInfo.m_dwFlags     |= CMINFO_USE_TEMP_VERB;
    }

    if (htiRClicked)
        contextInfo.m_dwFlags |= CMINFO_DO_SCOPEPANE_MENU;
    else
        contextInfo.m_dwFlags |= CMINFO_SCOPEITEM_IN_RES_PANE;

    if (HasListOrListPad())
        contextInfo.m_spListView = m_pListCtrl;

    INodeCallback* spNodeCallback = GetNodeCallback();
    ASSERT(spNodeCallback != NULL);

    HRESULT hr = spNodeCallback->Notify(hNode, NCLBK_CONTEXTMENU, 0,
        reinterpret_cast<LPARAM>(&contextInfo));
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::GetTaskpadID
 *
 * PURPOSE: returns the GUID id of the currently selected taskpad.
 *
 * RETURNS:
 *    GUID : the taskpad, if any, else GUID_NULL.
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::GetTaskpadID(GUID &guidID)
{
    ITaskCallback * pTaskCallback = m_ViewData.m_spTaskCallback;
    if(pTaskCallback != NULL)
    {
        pTaskCallback->GetTaskpadID(&guidID);
    }
    else
    {
        guidID = GUID_NULL;
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScInitializeMemento
 *
 * PURPOSE: Initializes the memento from the current view.
 *
 * PARAMETERS:
 *    CMemento & memento :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScInitializeMemento(CMemento &memento)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScInitializeMemento"));

    sc = GetSelectedNodePath(&memento.GetBookmark());
    if (sc)
        return sc;

    GUID guidTaskpad = GUID_NULL;

    HNODE hNode = GetSelectedNode();

    // get Result pane stuff from snapin
    CResultViewType rvt;
    sc = GetNodeCallback()->GetResultPane(hNode, rvt, &guidTaskpad /*this is not used*/);
    if (sc)
        return sc;

    CViewSettings& viewSettings = memento.GetViewSettings();

    // Initialize the CViewSettings.
    sc = viewSettings.ScSetResultViewType(rvt);
    if (sc)
        return sc;

    GUID guid;
    GetTaskpadID(guid); // we use this guid instead of guidTaskpad because
    // the memento should contain the taskpad that is currently being displayed.
    sc = viewSettings.ScSetTaskpadID(guid);

    return sc;

}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnAddToFavorites
 *
 * PURPOSE: Creates a memento from the currently configured view. Saves it into a
 *          shortcut.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCView::OnAddToFavorites()
{
    DECLARE_SC(sc , _T("CAMCView::OnAddToFavorites"));
    USES_CONVERSION;

    CAMCDoc* pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return;

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return;

    CMemento memento;
    sc = ScInitializeMemento(memento); // init the memento with the current view settings.
    if(sc)
        return;

    HNODE hNode = GetSelectedNode();

      tstring strName;
    sc = GetNodeCallback()->GetDisplayName(hNode, strName);
    if (sc)
        return;

    HMTNODE hmtNode;
    sc = m_spNodeCallback->GetMTNode(hNode, &hmtNode);
    if (sc)
        return;

    CCoTaskMemPtr<WCHAR> spszPath;
    sc = pScopeTree->GetPathString(NULL, hmtNode, &spszPath);
    if (sc)
        return;

    sc = ScCheckPointers(pDoc->GetFavorites(), E_UNEXPECTED);
    if (sc)
        return;

    sc = pDoc->GetFavorites()->AddToFavorites(strName.data(), W2CT(spszPath), memento, this);
    if (sc)
        return;

    pDoc->SetModifiedFlag();
}


void CAMCView::OnContextMenuForTreeBackground(CPoint& point, LPCRECT prcExclude, bool bAllowDefaultItem)
{
    TRACE_METHOD(CAMCView, OnContextMenuForTreeBackground);

    HNODE hNode = NULL;

    CContextMenuInfo contextInfo;

    contextInfo.m_displayPoint.x    = point.x;
    contextInfo.m_displayPoint.y    = point.y;
    contextInfo.m_eDataObjectType   = CCT_SCOPE;
    contextInfo.m_bBackground       = TRUE;
    contextInfo.m_bScopeAllowed     = IsScopePaneAllowed();
    contextInfo.m_hWnd              = m_hWnd;
    contextInfo.m_pConsoleView      = this;
    contextInfo.m_bAllowDefaultItem = bAllowDefaultItem;

    /*
     * if given, initialize the rectangle not to obscure
     */
    if (prcExclude != NULL)
        contextInfo.m_rectExclude = *prcExclude;

    INodeCallback* spNodeCallback = GetNodeCallback();
    ASSERT(spNodeCallback != NULL);
    HRESULT hr = spNodeCallback->Notify(hNode, NCLBK_CONTEXTMENU, 0,
        reinterpret_cast<LPARAM>(&contextInfo));
}

SC CAMCView::ScWebCommand (WebCommand eCommand)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (m_pWebViewCtrl == NULL)
    {
        ASSERT (m_pHistoryList);
        if (!m_pHistoryList)
            return FALSE;

        // this is the case when we don't have a web control yet....
        bool bHandled = false;

        switch (eCommand)
        {
            case eWeb_Back:
                m_pHistoryList->Back (bHandled);
                ASSERT(bHandled);
                break;

            case eWeb_Forward:
                m_pHistoryList->Forward (bHandled);
                ASSERT(bHandled);
                break;

            default:
                return FALSE;
        }

        return TRUE;
    }

    switch (eCommand)
    {
        case eWeb_Back:     m_pWebViewCtrl->Back();     break;
        case eWeb_Forward:  m_pWebViewCtrl->Forward();  break;
        case eWeb_Home:     ASSERT(0 && "Should not come here! - remove all code related to Web_Home"); break;
        case eWeb_Refresh:  m_pWebViewCtrl->Refresh();  break;
        case eWeb_Stop:     m_pWebViewCtrl->Stop();     break;
        default:            ASSERT(0);                  return FALSE;
    }

    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScCreateTaskpadHost
 *
 * PURPOSE: Creates a legacy (snapin taskpad) host interface pointer
 *
 * NOTE:    When a view containing a taskpad is navigated away from, the amcview
 *          forgets about the taskpad host pointer, but the html window does not.
 *          When the same view is re-navigated to using History, the amcview needs
 *          a taskpad host pointer, so a new instance is created. Thus at this point
 *          the amcview and the HTML have pointers to different taskpad host
 *          objects. This is OK, because both objects are initialized to the same
 *          amcview, and contain no other state
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScCreateTaskpadHost()
{
    DECLARE_SC(sc , _T("CAMCView::ScCreateTaskpadHost"));

    if(m_spTaskPadHost != NULL)
        return sc;

    CComObject<CTaskPadHost>* pTaskPadHost = NULL;
    sc = CComObject<CTaskPadHost>::CreateInstance(&pTaskPadHost);
    if (sc)
        return sc;

    sc = ScCheckPointers (pTaskPadHost, E_UNEXPECTED);
    if (sc)
        return sc;

    pTaskPadHost->Init (this);
    m_spTaskPadHost = pTaskPadHost;

    return sc;

}

LRESULT CAMCView::OnConnectToCIC (WPARAM wParam, LPARAM lParam)
{
        DECLARE_SC (sc, _T("CAMCView::OnConnectToCIC"));

    // fill out wparam, which is an IUnknown ** (alloc'd by CIC)
    ASSERT (wParam != NULL);
    IUnknown ** ppunk = (IUnknown **)wParam;
    ASSERT (!IsBadReadPtr  (ppunk, sizeof(IUnknown *)));
    ASSERT (!IsBadWritePtr (ppunk, sizeof(IUnknown *)));

        sc = ScCheckPointers (ppunk);
        if (sc)
                return (sc.ToHr());

    // lParam holds MMCCtrl's IUnknown:  we can hang onto this if we
    // need it. Presently not saved or used.

    sc = ScCreateTaskpadHost();
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spTaskPadHost, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();;

    sc = m_spTaskPadHost->QueryInterface(IID_IUnknown, (void **)ppunk);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnGetIconInfoForSelectedNode
//
//  Synopsis:    Icon control sends this message to get the small icon
//               for currently the selected node.
//
//  Arguments:   [wParam] - Out param, ptr to HICON handle.
//               [lParam] - Unused
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CAMCView::OnGetIconInfoForSelectedNode(WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCView::OnGetIconInfoForSelectedNode"));

    HICON *phIcon  = (HICON*)wParam;
    sc = ScCheckPointers(phIcon);
    if (sc)
        return sc.ToHr();

    *phIcon  = NULL;

    sc = ScCheckPointers(m_pTreeCtrl, m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pTreeCtrl->ScGetTreeItemIconInfo(GetSelectedNode(), phIcon);

    return sc.ToHr();
}

HRESULT CAMCView::NotifyListPad (BOOL b)
{
    if (b == TRUE)                  // attaching: save current node
        m_ListPadNode = GetSelectedNode();
    else if (m_ListPadNode == NULL) // detaching, but no hnode
        return E_UNEXPECTED;

    // send notify to snapin
    INodeCallback* pNC = GetNodeCallback();
    HRESULT hr = pNC->Notify (m_ListPadNode, NCLBK_LISTPAD, (long)b, (long)0);

    if (b == FALSE)     // if detaching, ensure that we do this only once
        m_ListPadNode = NULL;

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnConnectToTPLV
 *
 * PURPOSE: Connects the listpad to the HTML frame
 *
 * PARAMETERS:
 *    WPARAM  wParam :  parent window
 *    LPARAM  lParam :  [OUT]: pointer to window to be created and filled out
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnConnectToTPLV(WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC(sc, _T("CAMCView::ScOnConnectToTPLV"));

    HWND  hwnd  = (HWND )wParam;
    if(!IsWindow (hwnd))
        return (sc = S_FALSE);

    if (lParam == NULL) // detaching
    {
        SC sc = m_pListCtrl->ScAttachToListPad (hwnd, NULL);
        if(sc)
            return sc;
    }
    else
    {   // attaching

        sc = ScCreateTaskpadHost();
        if(sc)
            return sc;

        HWND* phwnd = (HWND*)lParam;
        if (IsBadWritePtr (phwnd, sizeof(HWND *)))
            return (sc = E_UNEXPECTED);

        // Attach TaskPad's ListView to the NodeMgr
        sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
        if(sc)
            return sc;

        sc = m_pTreeCtrl->m_spNodeManager->SetTaskPadList(m_pListCtrl);
        if(sc)
            return sc;

        // Attach TaskPad's ListView to the curr selected node
        INodeCallback* pNC = GetNodeCallback();
        sc = ScCheckPointers(pNC, E_UNEXPECTED);
        if(sc)
            return sc;

        HNODE hNodeSel = GetSelectedNode();
        sc = pNC->SetTaskPadList(hNodeSel, m_pListCtrl);
        if(sc) // this test was commented out earlier. Uncommented it so we can figure out why.
            return sc;

        //
        // Attach the listctrl to the list pad.
        //

        // First set the list view options.
        SetListViewOptions(GetListOptions());

        sc = m_pListCtrl->ScAttachToListPad (hwnd, phwnd);
        if(sc)
            return sc;
    }

    RecalcLayout();
    return sc;
}


SC CAMCView::ScShowWebContextMenu ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    PostMessage (m_nShowWebContextMenuMsg);

    return (S_OK);
}

LRESULT CAMCView::OnShowWebContextMenu (WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);

    if (pNC)
        pNC->Notify (GetSelectedNode(), NCLBK_WEBCONTEXTMENU, 0, 0);

    return (0);
}

SC CAMCView::ScSetDescriptionBarText (LPCTSTR pszDescriptionText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    GetRightDescCtrl().SetSnapinText (pszDescriptionText);

    return (S_OK);
}


HWND CAMCView::CreateFavoriteObserver (HWND hwndParent, int nID)
{
    DECLARE_SC (sc, _T("CAMCView::CreateFavoriteObserver"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    CFavTreeCtrl* pFavCtrl = CFavTreeCtrl::CreateInstance();

    if (pFavCtrl != NULL)
    {
        pFavCtrl->Create (NULL, TEXT(""), WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                          g_rectEmpty, CWnd::FromHandle(hwndParent), nID);
        pFavCtrl->ModifyStyleEx (0, WS_EX_CLIENTEDGE, 0);

        CAMCDoc* pDoc = GetDocument();
        ASSERT(pDoc != NULL && pDoc->GetFavorites() != NULL);

        sc = pFavCtrl->ScInitialize(pDoc->GetFavorites(), TOBSRV_HIDEROOT);
        if (sc)
        {
            pFavCtrl->DestroyWindow();      // CFavTreeCtrl::PostNcDestroy will "delete this"
            pFavCtrl = NULL;
        }
    }

    return (pFavCtrl->GetSafeHwnd());
}



int CAMCView::GetListSize ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    return (m_pListCtrl->GetItemCount() * m_pListCtrl->GetColCount());
}

long CAMCView::GetListViewStyle()
{
    DECLARE_SC(sc, _T("CAMCView::GetListViewStyle"));

    sc = ScCheckPointers(m_pTreeCtrl, m_pTreeCtrl->m_spResultData, E_UNEXPECTED);
    if (sc)
        return 0;

    if (HasList())
        return 0;

    long style = 0;

    // First findout if the result view is properly
    // set in the nodemgr by asking IFramePrivate.
    IFramePrivatePtr spFrame = m_pTreeCtrl->m_spResultData;
    sc = ScCheckPointers(spFrame, E_UNEXPECTED);
    if (sc)
        return 0;

    BOOL bIsResultViewSet = FALSE;
    sc = spFrame->IsResultViewSet(&bIsResultViewSet);

    // The result view is set, clean it up.
    if (bIsResultViewSet)
    {
        sc = m_pTreeCtrl->m_spResultData->GetListStyle(&style);
        if (sc)
            return 0;
    }

    return style;
}

void CAMCView::OnListContextMenu(CPoint& point)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnListContextMenu"));

    ASSERT(m_pTreeCtrl != NULL);
    ASSERT(m_pTreeCtrl->m_spResultData != NULL);

    // Determine which item is affected
    UINT fHitTestFlags = 0;
    HRESULTITEM hHitTestItem = 0;
    COMPONENTID componentID = 0;
    int iIndex = -1;

    do // not a loop
    {
        if (!HasList())
            break;

        int cSel = m_pListCtrl->GetSelectedCount();
        ASSERT(cSel >= 0);

        if (cSel == 0)
        {
            OnContextMenuForListItem(INDEX_BACKGROUND, NULL, point);
            return;
        }
        else if (cSel > 1)
        {
            if (IsKeyPressed(VK_SHIFT) || IsKeyPressed(VK_CONTROL))
            {
                HNODE hNodeSel = GetSelectedNode();
                ASSERT(hNodeSel != 0);

                INodeCallback* pNC = GetNodeCallback();
                ASSERT(pNC != NULL);

                if (pNC != NULL)
                {
                    sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, true, 0);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;

                    m_bLastSelWasMultiSel = true;
                }
            }

            iIndex = INDEX_MULTISELECTION; // => MultiSelect
            break;
        }
        else
        {
            LPARAM lvData = LVDATA_ERROR;
            iIndex = _GetLVSelectedItemData(&lvData);
            ASSERT(iIndex != -1);
            ASSERT(lvData != LVDATA_ERROR);

            if (IsVirtualList())
            {
                // for virtual list pass the item index rather than the lparam
                OnContextMenuForListItem(iIndex, iIndex, point);
                return;
            }
            else
            {
                CResultItem* pri = CResultItem::FromHandle (lvData);

                if (pri != NULL)
                {
                    if (pri->IsScopeItem())
                        OnContextMenuForTreeItem(iIndex, pri->GetScopeNode(), point, CCT_SCOPE);
                    else
                        OnContextMenuForListItem(iIndex, lvData, point);
                }

                return;
            }
        }

    } while (0);

    OnContextMenuForListItem(iIndex, hHitTestItem, point);
}

void CAMCView::OnContextMenuForListItem(int iIndex, HRESULTITEM hHitTestItem,
                                    CPoint& point, MMC_CONTEXT_MENU_TYPES eMenuType,
                                    LPCRECT prcExclude, bool bAllowDefaultItem)
{
    CContextMenuInfo contextInfo;

    contextInfo.m_displayPoint.x    = point.x;
    contextInfo.m_displayPoint.y    = point.y;
    contextInfo.m_eContextMenuType  = eMenuType;
    contextInfo.m_eDataObjectType   = CCT_RESULT;
    contextInfo.m_bBackground       = (iIndex == INDEX_BACKGROUND);
    contextInfo.m_bMultiSelect      = (iIndex == INDEX_MULTISELECTION);
    contextInfo.m_bAllowDefaultItem = bAllowDefaultItem;

    if (iIndex >= 0)
        contextInfo.m_resultItemParam = IsVirtualList() ? iIndex : hHitTestItem;
    else if (contextInfo.m_bMultiSelect)
        contextInfo.m_resultItemParam = LVDATA_MULTISELECT;

    contextInfo.m_bScopeAllowed      = IsScopePaneAllowed();
    contextInfo.m_hWnd               = m_hWnd;
    contextInfo.m_pConsoleView       = this;

    contextInfo.m_hSelectedScopeNode = GetSelectedNode();
    contextInfo.m_iListItemIndex     = iIndex;

    if (HasListOrListPad())
        contextInfo.m_spListView = m_pListCtrl;

    if ((INDEX_OCXPANE == iIndex) && HasOCX())
    {
        contextInfo.m_resultItemParam = LVDATA_CUSTOMOCX;
    }
    else if ((INDEX_WEBPANE == iIndex) && HasWebBrowser())
    {
        contextInfo.m_resultItemParam = LVDATA_CUSTOMWEB;
    }

    /*
     * if given, initialize the rectangle not to obscure
     */
    if (prcExclude != NULL)
        contextInfo.m_rectExclude = *prcExclude;

    HNODE hNode = GetSelectedNode();
    ASSERT(hNode != NULL);

    INodeCallback* pNodeCallback = GetNodeCallback();
    ASSERT(pNodeCallback != NULL);

    HRESULT hr = pNodeCallback->Notify(hNode, NCLBK_CONTEXTMENU, 0,
        reinterpret_cast<LPARAM>(&contextInfo));
}

HTREEITEM CAMCView::FindChildNode(HTREEITEM hti, DWORD dwItemDataKey)
{
    hti = m_pTreeCtrl->GetChildItem(hti);

    while (hti && (dwItemDataKey != m_pTreeCtrl->GetItemData(hti)))
    {
        hti = m_pTreeCtrl->GetNextItem(hti, TVGN_NEXT);
    }

    return hti;
}


///////////////////////////////////////////////////////////////////////////////
/// Context Menu Handlers for Result View Item and Background

void CAMCView::ArrangeIcon(long style)
{
#ifdef OLD_STUFF
    ASSERT(m_pTreeCtrl && m_pTreeCtrl->m_pNodeInstCurr);
    if (!m_pTreeCtrl || !m_pTreeCtrl->m_pNodeInstCurr)
        return;

    IFrame* const pFrame = m_pTreeCtrl->m_pNodeInstCurr->GetIFrame();
    ASSERT(pFrame);
    if (!pFrame)
        return;

    IResultDataPrivatePtr pResult = pFrame;
    ASSERT(static_cast<bool>(pResult));
    if (pResult == NULL)
        return ;

    HRESULT hr = pResult->Arrange(style);
    ASSERT(SUCCEEDED(style));
#endif // OLD_STUFF
}

///////////////////////////////////////////////////////////////////////////////
/// Menu handlers

CAMCView::ViewPane CAMCView::GetFocusedPane ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    ASSERT_VALID (this);
    CView* pActiveView = GetParentFrame()->GetActiveView();

    for (ViewPane ePane = ePane_First; ePane <= ePane_Last; ePane = (ViewPane)(ePane+1))
    {
        if (GetPaneView (ePane) == pActiveView)
            return (ePane);
    }

    return (ePane_None);
}

/*+-------------------------------------------------------------------------*
 * CDeferredResultPaneActivation
 *
 *
 * PURPOSE: If the result pane has the focus before and after the node was
 *          selected, then the last event snapin receives is scope selected which
 *          is incorrect. So we first set scope pane as active view but do not
 *          send notifications. Then we set result pane as active view which
 *          sends scope de-select and result pane select.
 *          But when we try to set result pane as active view, the listview may
 *          not be visible yet (if there is view extension, the behavior hides
 *          and then shows the listview).
 *          So we need to wait till listview is setup. We cannot use PostMessage
 *          as the resizing of listview happens using PostMessage which is sent
 *          later (race condition). Therefore we use the idle timer as shown below
 *          so that activation will occur after resizing occurs.
 *
 *+-------------------------------------------------------------------------*/
class CDeferredResultPaneActivation : public CIdleTask
{
public:
    CDeferredResultPaneActivation(HWND hWndAMCView) :
        m_atomTask (AddAtom (_T("CDeferredResultPaneActivation"))),
        m_hWndAMCView(hWndAMCView)
    {
    }

   ~CDeferredResultPaneActivation() {}

    // IIdleTask methods
    SC ScDoWork()
    {
        DECLARE_SC (sc, TEXT("CDeferredResultPaneActivation::ScDoWork"));

        sc = ScCheckPointers((void*)m_hWndAMCView, E_UNEXPECTED);
        if (sc)
           return (sc);

        CWnd *pWnd = CWnd::FromHandle(m_hWndAMCView);
        sc = ScCheckPointers(pWnd, E_UNEXPECTED);
        if (sc)
            return sc;

        CAMCView *pAMCView = dynamic_cast<CAMCView*>(pWnd);

        // Since this method is called by IdleQueue, the target
        // CAMCView may have gone by now, if it does not exist
        // it is not an error (see bug 175737 related to SQL).
        if (! pAMCView)
            return sc;

        sc = pAMCView->ScSetFocusToResultPane();
        if (sc)
            return sc;

        return sc;
    }

    SC ScGetTaskID(ATOM* pID)
    {
        DECLARE_SC (sc, TEXT("CDeferredResultPaneActivation::ScGetTaskID"));
        sc = ScCheckPointers(pID);
        if(sc)
            return sc;

        *pID = m_atomTask;
        return sc;
    }

    SC ScMerge(CIdleTask* pitMergeFrom) {return S_FALSE /*do not merge*/;}

private:
    const ATOM    m_atomTask;
    HWND          m_hWndAMCView;
};


/*+-------------------------------------------------------------------------*
 * CAMCView::ScDeferSettingFocusToResultPane
 *
 * Synopsis: If the result pane has the focus before and after the node was
 *           selected, then the last event snapin receives is scope selected which
 *           is incorrect. So we first set scope pane as active view but do not
 *           send notifications. Then we set result pane as active view which
 *           sends scope de-select and result pane select.
 *           But when we try to set result pane as active view, the listview may
 *           not be visible yet (if there is view extension, the behavior hides
 *           and then shows the listview).
 *           So we need to wait till listview is setup. We cannot use PostMessage
 *           as the resizing of listview happens using PostMessage which is sent
 *           later (race condition). Therefore we use the idle timer as shown below
 *           so that activation will occur after resizing occurs.
 *
 * Returns:  SC
 *
 *--------------------------------------------------------------------------*/
SC CAMCView::ScDeferSettingFocusToResultPane ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState()); // not sure if we need this, but doesn't hurt to have it in here.

    DECLARE_SC (sc, TEXT("CAMCView::ScDeferSettingFocusToResultPane"));

    CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
    sc = ScCheckPointers(pIdleTaskQueue, E_UNEXPECTED);
    if(sc)
        return sc;

    /*
     * create the deferred page break task
     */
    CAutoPtr<CDeferredResultPaneActivation> spDeferredResultPaneActivation(new CDeferredResultPaneActivation (GetSafeHwnd()));
    sc = ScCheckPointers(spDeferredResultPaneActivation, E_OUTOFMEMORY);
    if(sc)
        return sc;

    /*
     * put the task in the queue, which will take ownership of it
     * Activation should happen at lower priority than layout.
     */
    sc = pIdleTaskQueue->ScPushTask (spDeferredResultPaneActivation, ePriority_Low);
    if (sc)
        return sc;

    /*
     * if we get here, the idle task queue owns the idle task, so
     * we can detach it from our smart pointer
     */
    spDeferredResultPaneActivation.Detach();

    /*
     * jiggle the message pump so that it wakes up and checks idle tasks
     */
    PostMessage (WM_NULL);

    return (S_OK);
}


//+-------------------------------------------------------------------
//
//  Member:      ScSetFocusToResultPane
//
//  Synopsis:    Set focus to result pane (list or ocx or web). If result
//               is hidden then set to folder tab else set to tasks pane.
//
//  Arguments:
//
//  Returns:      SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSetFocusToResultPane ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetFocusToResultPane"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (GetFocusedPane() == ePane_Results)
        return (sc);

    // Make active
    // 1. ListView/OCX/Web if it exists else
    // 2. Folder tab if it exists.
    // 3. Tasks in console taskpad.

    CView* rgActivationOrderEntry[] =
    {
        GetPaneView(ePane_Results),     // results
        m_pResultFolderTabView,         // result tab control
        m_pViewExtensionCtrl,           // view extension web page
    };

    const int INDEX_RESULTS_PANE = 0;
    ASSERT (rgActivationOrderEntry[INDEX_RESULTS_PANE] == GetPaneView(ePane_Results));

    int cEntries = (sizeof(rgActivationOrderEntry) / sizeof(rgActivationOrderEntry[0]));

    // get the currently active entry.
    for(int i = 0; i< cEntries; i++)
    {
        CView *pView = rgActivationOrderEntry[i];
        sc = ScCheckPointers(pView, E_UNEXPECTED);
        if (sc)
            continue;

        if (IsWindow (pView->GetSafeHwnd()) &&
            pView->IsWindowVisible() &&
            pView->IsWindowEnabled())
        {
            GetParentFrame()->SetActiveView (pView);
            return (sc);
        }
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScSetFocusToPane
//
//  Synopsis:    Call this member to set focus to any pane.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
SC CAMCView::ScSetFocusToPane (ViewPane ePane)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetFocusToPane"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::ScSetFocusToPane: Invalid pane specifier");
        return (sc = E_FAIL);
    }

    if (GetFocusedPane() == ePane)
        return (sc);

    if (ePane == ePane_Results)
        return (sc = ScSetFocusToResultPane());

    CView* pView = GetPaneView(ePane);

    if (!IsWindow (pView->GetSafeHwnd()) ||
        !pView->IsWindowVisible() ||
        !pView->IsWindowEnabled())
    {
        return (sc = E_FAIL);
    }

    GetParentFrame()->SetActiveView (pView);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetFocusedItem
//
//  Synopsis:    Get the currently selected item's context.
//
//  Arguments:   [hNode]   - [out] The owner of result pane.
//               [lCookie] - [out] If result pane selected the LVDATA.
//               [fScope]  - [out] scope or result
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScGetFocusedItem (HNODE& hNode, LPARAM& lCookie, bool& fScope)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetFocusedItem"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT_VALID (this);

    lCookie = LVDATA_ERROR;
    hNode   = GetSelectedNode();
    if (hNode == NULL)
        return (sc = E_UNEXPECTED);

    switch (m_eCurrentActivePane)
    {
    case eActivePaneScope:
            fScope = true;
        break;

    case eActivePaneResult:
        {
            fScope = false;

            // Calculate the LPARAM for result item.
            if (HasOCX())
                lCookie = LVDATA_CUSTOMOCX;

            else if (HasWebBrowser())
                lCookie = LVDATA_CUSTOMWEB;

            else if (HasListOrListPad())
            {
                int cSel = m_pListCtrl->GetSelectedCount();
                ASSERT(cSel >= 0);

                if (cSel == 0)
                    lCookie = LVDATA_BACKGROUND;
                else if (cSel == 1)
                    _GetLVSelectedItemData (&lCookie);
                else if (cSel > 1)
                    lCookie = LVDATA_MULTISELECT;
            }
            else
            {
                return (sc = E_FAIL); // dont know who has the focus???
            }
        }
        break;

    case eActivePaneNone:
    default:
        sc = E_UNEXPECTED;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::PrivateChangeListViewMode
//
//  Synopsis:    Private function to change view mode. Consider using
//               ScChangeViewMode instead of this function.
//
//  Arguments:   [nMode] - view mode to be set.
//
//--------------------------------------------------------------------
void CAMCView::PrivateChangeListViewMode(int nMode)
{
    DECLARE_SC(sc, TEXT("CAMCView::PrivateChangeListViewMode"));

    if ((nMode < 0) || (nMode > MMCLV_VIEWSTYLE_FILTERED) )
    {
        sc = E_INVALIDARG;
        return;
    }

    // Add a history entry which will be same as current
    // one except for view mode change.

    sc = ScCheckPointers(m_pHistoryList, m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return;

    // change the current history list entry's view mode
    sc = m_pHistoryList->ScChangeViewMode(nMode);
    if(sc)
        return;

    // set the list control's view mode
    sc = m_pListCtrl->SetViewMode(nMode);
    if (!sc)
    {
        m_nViewMode = nMode;
        SetDirty();

        SetDefaultListViewStyle(GetListViewStyle());
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnProcessMultiSelectionChanges
//
//  Synopsis:    message handler for m_nProcessMultiSelectionChangesMsg
//               messages that are posted.
//
//               Handles multi-item de-selection for list view and then
//               send selection for list view items.
//
//               This method knows that selection states of multiple items
//               are changed but not if they are selected or de-selected.
//               The m_bLastSelWasMultiSel is used to determine if it is
//               selection or de-selection.
//
//  Arguments:   none used.
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CAMCView::OnProcessMultiSelectionChanges (WPARAM, LPARAM)
{
    DECLARE_SC(sc, _T("CAMCView::OnProcessMultiSelectionChanges"));

    // Selection change so appropriately enable std-toolbar buttons
    // back, forward, export-list, up-one-level, show/hide-scope, help
    sc = ScUpdateStandardbarMMCButtons();
    if (sc)
        return (0);

    if (! m_bProcessMultiSelectionChanges)
        return (0);

    m_bProcessMultiSelectionChanges = false;

    INodeCallback* pNC = GetNodeCallback();
    HNODE hNodeSel = GetSelectedNode();
    sc = ScCheckPointers((void*) hNodeSel, pNC, m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return (0);

    // If some thing was selected previously send a deselection
    // message before sending a selection message (single item de-select
    // is already handled in OnListItemChanged so just handle multi item
    // deselect here).
    if (m_bLastSelWasMultiSel)
    {
        sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
        m_bLastSelWasMultiSel = false;
    }

    // Now send a selection message
    UINT cSel = m_pListCtrl->GetSelectedCount ();
    if (cSel == 1)
    {
        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = FALSE;

        int iItem = _GetLVSelectedItemData(&selInfo.m_lCookie);
        ASSERT(iItem != -1);

        sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, true, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }
    else if (cSel > 1)
    {
        Dbg(DEB_USER1, _T("    5. LVN_SELCHANGE <MS> <0, 1>\n"));
        sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, true, 0);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

        m_bLastSelWasMultiSel = true;
    }

    return (0);
}

SC CAMCView::ScRenameListPadItem() // obsolete?
{
    DECLARE_SC (sc, _T("CAMCView::ScRenameListPadItem"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    ASSERT(m_pListCtrl != NULL);
    ASSERT(m_pListCtrl->GetListViewPtr() != NULL);

    int cSel = m_pListCtrl->GetSelectedCount();
    if (cSel != 1)
        return (sc = E_FAIL);

    LPARAM lParam;
    int iItem = _GetLVSelectedItemData(&lParam);
    ASSERT(iItem >= 0);
    if (iItem >= 0)
    {
        m_bRenameListPadItem = true;
        m_pListCtrl->GetListViewPtr()->SetFocus();
        m_pListCtrl->GetListViewPtr()->GetListCtrl().EditLabel(iItem);
        m_bRenameListPadItem = false;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOrganizeFavorites
 *
 * PURPOSE: Display the "organize favorites" dialog.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOrganizeFavorites()
{
    DECLARE_SC (sc, TEXT("CAMCView::ScOrganizeFavorites"));

    CAMCDoc* pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if(sc)
        return sc;

    CFavorites *pFavorites = pDoc->GetFavorites();
    sc = ScCheckPointers(pFavorites);
    if(sc)
        return sc;

    pFavorites->OrganizeFavorites(this);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScLineUpIcons
 *
 * PURPOSE: line up the icons in the list
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScLineUpIcons()
{
    DECLARE_SC (sc, TEXT("CAMCView::ScLineUpIcons"));

    ArrangeIcon(LVA_SNAPTOGRID);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAutoArrangeIcons
 *
 * PURPOSE: auto arrange the icons in the list
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAutoArrangeIcons()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAutoArrangeIcons"));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    m_pListCtrl->SetListStyle(m_pListCtrl->GetListStyle() ^ LVS_AUTOARRANGE);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnRefresh
 *
 * PURPOSE: Refreshes the view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnRefresh(HNODE hNode, bool bScope, LPARAM lResultItemParam)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnRefresh"));
    sc = ScCheckPointers((void*)hNode);
    if (sc)
        return sc;

    HWND hwnd = ::GetFocus();

    sc = ScProcessConsoleVerb(hNode, bScope, lResultItemParam, evRefresh);
    ::SetFocus(hwnd);

    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * CLASS:  CDeferredRenameListItem
 *
 * PURPOSE: This class encapsulates means to put a list control in the rename mode
 *          asynchronously. This is needed to assure all mesages are processed before
 *          and no-one will steel the focus ending unexpectidly the edit mode.
 *
 * USAGE:
 *          use CDeferredRenameListItem::ScDoRenameAsIdleTask() to invoke the operation
 *          asyncronously
 *
\***************************************************************************/
class CDeferredRenameListItem : public CIdleTask
{
    // constructor - used internally only
    CDeferredRenameListItem( HWND hwndListCtrl, int iItemIndex ) :
      m_atomTask (AddAtom (_T("CDeferredRenameListItem"))),
      m_hwndListCtrl(hwndListCtrl), m_iItemIndex(iItemIndex)
    {
    }

protected:

    // IIdleTask methods
    SC ScDoWork()
    {
        DECLARE_SC (sc, TEXT("CDeferredRenameListItem::ScDoWork"));

        // get the ListCtrl pointer
        CListCtrl *pListCtrl = (CListCtrl *)CWnd::FromHandlePermanent(m_hwndListCtrl);
        sc = ScCheckPointers( pListCtrl );
        if (sc)
            return sc;

        // do what you are asked for - put LV in the rename mode
        pListCtrl->SetFocus(); // set the focus first. Don't need to do a SetActiveView here, I believe (vivekj)
        pListCtrl->EditLabel( m_iItemIndex );

        return sc;
    }

    SC ScGetTaskID(ATOM* pID)
    {
        DECLARE_SC (sc, TEXT("CDeferredPageBreak::ScGetTaskID"));
        sc = ScCheckPointers(pID);
        if(sc)
            return sc;

        *pID = m_atomTask;
        return sc;
    }

    SC ScMerge(CIdleTask* pitMergeFrom) { return S_FALSE /*do not merge*/; }

public:

    // this method is called to invoke rename asyncronously.
    // it constructs the idle task and puts it into the queue
    static SC ScDoRenameAsIdleTask( HWND hwndListCtrl, int iItemIndex )
    {
        DECLARE_SC(sc, TEXT("CDeferredPageBreak::ScDoRenameAsIdleTask"));

        CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
        sc = ScCheckPointers(pIdleTaskQueue, E_UNEXPECTED);
        if(sc)
            return sc;

        // create the deferred task
        CAutoPtr<CDeferredRenameListItem> spTask(new CDeferredRenameListItem (hwndListCtrl, iItemIndex));
        sc = ScCheckPointers( spTask, E_OUTOFMEMORY);
        if(sc)
            return sc;

        // put the task in the queue, which will take ownership of it
        sc = pIdleTaskQueue->ScPushTask (spTask, ePriority_Normal);
        if (sc)
            return sc;

        // ownership tranfered to the queue, get rid of control over the pointer
        spTask.Detach();

        return sc;
    }

private:
    const ATOM      m_atomTask;
    HWND            m_hwndListCtrl;
    int             m_iItemIndex;
};

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnRename
 *
 * PURPOSE: Allows the user to renames the scope or result item specified by pContextInfo
 *
 * PARAMETERS:
 *    CContextMenuInfo * pContextInfo :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnRename(CContextMenuInfo *pContextInfo)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnRename"));

    sc = ScCheckPointers(pContextInfo, m_pTreeCtrl, m_pListCtrl);
    if(sc)
        return sc;

    if (pContextInfo->m_htiRClicked != NULL)
    {
        m_pTreeCtrl->EditLabel(pContextInfo->m_htiRClicked);
    }
    else
    {
        ASSERT(pContextInfo->m_iListItemIndex >= 0);

        sc = ScCheckPointers(m_pListCtrl->GetListCtrl());
        if(sc)
            return sc;

        // Do this on idle - or else we'll suffer from someone steeling focus
        // Syncronous operation fails in console task case.
        sc = CDeferredRenameListItem::ScDoRenameAsIdleTask( m_pListCtrl->GetListCtrl().m_hWnd, pContextInfo->m_iListItemIndex );
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScRenameScopeNode
 *
 * PURPOSE:  put the specified scope node into rename mode.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode : The scope node
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScRenameScopeNode(HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScRenameScopeNode"));

    sc = ScCheckPointers(m_pTreeCtrl, E_FAIL);
    if(sc)
        return sc;

    sc = m_pTreeCtrl->ScRenameScopeNode(hMTNode);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetStatusBar
 *
 * PURPOSE: Returns the status bar
 *
 * PARAMETERS:
 *    CConsoleStatusBar ** ppStatusBar :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetStatusBar(CConsoleStatusBar **ppStatusBar)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetStatusBar"));

    sc = ScCheckPointers(ppStatusBar);
    if(sc)
        return sc;

    *ppStatusBar = m_ViewData.GetStatusBar();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetProperty
 *
 * PURPOSE: Gets the property for a result item
 *
 * PARAMETERS:
 *    int    m_iIndex :  The index of the item in the list.
 *    BSTR   bstrPropertyName :
 *    PBSTR  pbstrPropertyValue :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetProperty(int iIndex, BSTR bstrPropertyName, PBSTR pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetProperty"));

    sc = ScCheckPointers(GetNodeCallback(), m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    LPARAM resultItemParam  = iIndex; // the virtual list case
    bool   bScopeItem       = false;  // the virtual list case

    if(!IsVirtualList())
    {
        CResultItem *pri = NULL;
        sc = m_pListCtrl->GetLParam(iIndex, pri);
        if(sc)
            return sc;

        resultItemParam = CResultItem::ToHandle(pri);

        sc = ScCheckPointers(pri);
        if(sc)
            return sc;

        bScopeItem      = pri->IsScopeItem();
    }

    sc = GetNodeCallback()->GetProperty(GetSelectedNode(), bScopeItem, resultItemParam, bstrPropertyName, pbstrPropertyValue);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetNodetype
 *
 * PURPOSE: Returns the nodetype for a list item
 *
 * PARAMETERS:
 *    int    iIndex :
 *    PBSTR  Nodetype :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetNodetype(int iIndex, PBSTR Nodetype)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetProperty"));

    sc = ScCheckPointers(GetNodeCallback(), m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    LPARAM resultItemParam  = iIndex; // the virtual list case
    bool   bScopeItem       = false;  // the virtual list case

    if(!IsVirtualList())
    {
        CResultItem *pri = NULL;
        sc = m_pListCtrl->GetLParam(iIndex, pri);
        if(sc)
            return sc;

        resultItemParam = CResultItem::ToHandle(pri);

        sc = ScCheckPointers(pri);
        if(sc)
            return sc;

        bScopeItem      = pri->IsScopeItem();
    }

    sc = GetNodeCallback()->GetNodetypeForListItem(GetSelectedNode(), bScopeItem, resultItemParam, Nodetype);

    return sc;
}



/*+-------------------------------------------------------------------------*
 * CAMCView::ScAddViewExtension
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScAddViewExtension (const CViewExtensionData& ved)
{
    DECLARE_SC (sc, _T("CAMCView::ScAddViewExtension"));

    return (sc);
}


void
CAMCView::OnChangedResultTab(NMHDR *nmhdr, LRESULT *pRes)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnChangedResultTab"));

    NMFOLDERTAB* nmtab = static_cast<NMFOLDERTAB*>(nmhdr);
    int iTab = nmtab->iItem;
    CFolderTab &tab = m_pResultFolderTabView->GetItem(iTab);

    GUID guidTaskpad = tab.GetClsid();

    // check if we're moving to the same taskpad.
    GUID guidCurrentTaskpad;
    GetTaskpadID(guidCurrentTaskpad);
    if(guidTaskpad == guidCurrentTaskpad)
        return;

    // lookup view extension URL
    CViewExtensionURLs::iterator itVE = m_ViewExtensionURLs.find(guidTaskpad);
    LPCTSTR url = (itVE != m_ViewExtensionURLs.end()) ? itVE->second.c_str() : NULL;

    // apply URL
    sc = ScApplyViewExtension(url);
    if (sc)
        sc.TraceAndClear();

    GetNodeCallback()->SetTaskpad(GetSelectedNode(), &guidTaskpad); // if not found, guidTaskpad is set to GUID_NULL.

    // After setting the taskpad enable/disable save list button
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    ASSERT(NULL != pStdToolbar);
    if (NULL != pStdToolbar)
    {
        pStdToolbar->ScEnableExportList(GetListSize() > 0 /*Enable only if LV has items*/);
    }

    // the taskpad changed. Create a new entry in the history list.
    sc = m_pHistoryList->ScModifyViewTab( guidTaskpad );
    if(sc)
        sc.TraceAndClear();
}


HRESULT
CAMCView::GetRootNodePath(
    CBookmark* pbm)
{
    HTREEITEM htiRoot = m_pTreeCtrl->GetRootItem();
    return GetNodePath(htiRoot, htiRoot, pbm);
}

HRESULT
CAMCView::GetSelectedNodePath(
    CBookmark* pbm)
{
    return GetNodePath(m_pTreeCtrl->GetSelectedItem(),
                       m_pTreeCtrl->GetRootItem(),
                       pbm);
}

HRESULT
CAMCView::GetNodePath(
    HTREEITEM hti,
    HTREEITEM htiRoot,
    CBookmark* pbm)
{
    TRACE_METHOD(CAMCView, GetRootNodeID);

    if (hti == NULL)
        return E_FAIL;

    if (htiRoot == NULL)
        return E_FAIL;

    ASSERT(hti     != NULL);
    ASSERT(htiRoot != NULL);

    HNODE hNode     = (HNODE)m_pTreeCtrl->GetItemData(hti);
    HNODE hRootNode = (HNODE)m_pTreeCtrl->GetItemData(htiRoot);

    HRESULT hr = m_spNodeCallback->GetPath(hNode, hRootNode, (LPBYTE) pbm);

    return hr;
}


inline HMTNODE CAMCView::GetHMTNode(HTREEITEM hti)
{
    TRACE_METHOD(CAMCView, GetHMTNode);

    HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);

    HMTNODE hMTNodeTemp;
    HRESULT hr = m_spNodeCallback->GetMTNode(hNode, &hMTNodeTemp);
    CHECK_HRESULT(hr);

    return hMTNodeTemp;
}

HTREEITEM CAMCView::FindHTreeItem(HMTNODE hMTNode, HTREEITEM hti)
{
    TRACE_METHOD(CAMCView, FindHTreeItem);

    while (hti)
    {
        if (hMTNode == GetHMTNode(hti))
            break;

        hti = m_pTreeCtrl->GetNextItem(hti, TVGN_NEXT);
    }

    return hti;
}

UINT CAMCView::ClipPath(CHMTNODEList* pNodeList, POSITION& rpos, HNODE hNode)
{
    TRACE_METHOD(CAMCView, ClipPath);

    UINT uiReturn = ITEM_IS_IN_VIEW;
    CCoTaskMemPtr<HMTNODE> sphMTNode;
    long lLength = 0;

    HRESULT hr = m_spNodeCallback->GetMTNodePath(hNode, &sphMTNode, &lLength);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    ASSERT(lLength == 0 || sphMTNode != NULL);

    for (long i=0; rpos != 0 && i < lLength; i++)
    {
        HMTNODE hMTNode = pNodeList->GetNext(rpos);
        if (hMTNode != sphMTNode[i])
        {
            uiReturn = ITEM_NOT_IN_VIEW;
            break;
        }
    }

    if (uiReturn == ITEM_NOT_IN_VIEW)
        return ITEM_NOT_IN_VIEW;
    return (rpos == 0 && lLength >= i) ? ITEM_IS_PARENT_OF_ROOT : ITEM_IS_IN_VIEW;
}

//
//  GetTreeItem returns TRUE if it can find the htreeitem of the item
//  whose HMTNode is equal to the last element in pNodeList. It returns
//  FALSE if the node does not appear in the view name space or if the
//  the node has not yet been created.
//
//  "pNodeList" is a list of HMTNODEs such that pNodeList[n] is the parent
//  of pNodeList[n+1].
//
UINT CAMCView::GetTreeItem(CHMTNODEList* pNodeList, HTREEITEM* phItem)
{
    TRACE_METHOD(CAMCView, GetTreeItem);

    ASSERT(pNodeList->IsEmpty() == FALSE);

    HTREEITEM   hti = NULL;
    HMTNODE     hMTNodeTemp = 0;

    hti = m_pTreeCtrl->GetRootItem();
    if (hti == NULL)
        return ITEM_NOT_IN_VIEW;

    HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);
    POSITION pos = pNodeList->GetHeadPosition();

    UINT uiReturn = ClipPath(pNodeList, pos, hNode);
    if (uiReturn != ITEM_IS_IN_VIEW)
        return uiReturn;


    HTREEITEM htiTemp = NULL;
    while (pos && hti)
    {
        hMTNodeTemp = (HMTNODE)pNodeList->GetNext(pos);

        hti = FindHTreeItem(hMTNodeTemp, hti);
        ASSERT(hti == NULL || hMTNodeTemp == GetHMTNode(hti));

        htiTemp = hti;

        if (hti != NULL)
            hti = m_pTreeCtrl->GetChildItem(hti);
    }

    if (pos == 0 && htiTemp != NULL)
    {
        // Found the node.
        ASSERT(hMTNodeTemp == pNodeList->GetTail());
        ASSERT(hMTNodeTemp == GetHMTNode(htiTemp));

        *phItem = htiTemp;
        return ITEM_IS_IN_VIEW;
    }
    else
    {
        // The node has not yet been created.
        *phItem = NULL;
        return ITEM_NOT_IN_VIEW;
    }

    return ITEM_IS_IN_VIEW;
}


#define HMTNODE_FIRST   reinterpret_cast<HMTNODE>(TVI_FIRST)
#define HMTNODE_LAST    reinterpret_cast<HMTNODE>(TVI_LAST)

void CAMCView::OnAdd(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnAdd);

    ASSERT(pvui->path.IsEmpty() == FALSE);

    HTREEITEM htiParent;
    if (GetTreeItem(&pvui->path, &htiParent) != ITEM_IS_IN_VIEW || htiParent == NULL)
        return;

    bool bFirstChild = (m_pTreeCtrl->GetChildItem(htiParent) == NULL);

    HNODE hNodeParent = (HNODE)m_pTreeCtrl->GetItemData(htiParent);
    if (m_spNodeCallback->Notify(hNodeParent, NCLBK_EXPAND, 0, 0) == S_FALSE)
    {
        m_pTreeCtrl->SetCountOfChildren(htiParent, 1);
        return; // Don't add if it is not expanded.
    }

    // If the hNode was already expanded add the item.
    IScopeTree* const pScopeTree = GetScopeTree();
    ASSERT(pScopeTree != NULL);
    HNODE hNodeNew = 0;
    HRESULT hr = pScopeTree->CreateNode(pvui->newNode,
                                    reinterpret_cast<LONG_PTR>(GetViewData()),
                                    FALSE, &hNodeNew);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return;

    HTREEITEM hInsertAfter = TVI_LAST;
    int iInsertIndex = -1;

    if (pvui->insertAfter != NULL)
    {
        hInsertAfter = reinterpret_cast<HTREEITEM>(pvui->insertAfter);

        if (pvui->insertAfter == HMTNODE_LAST)
        {
        }
        else if (pvui->insertAfter == HMTNODE_FIRST)
        {
            iInsertIndex = 0;
        }
        else
        {
            HTREEITEM hti = m_pTreeCtrl->GetChildItem(htiParent);
            ASSERT(hti != NULL);

            iInsertIndex = 1;
            while (hti != NULL)
            {
                if (GetHMTNode(hti) == pvui->insertAfter)
                    break;

                hti = m_pTreeCtrl->GetNextSiblingItem(hti);
                iInsertIndex++;
            }

            if (hti)
            {
               hInsertAfter = hti;
            }
            else
            {
                hInsertAfter = TVI_LAST;
                iInsertIndex = -1;
            }
        }
    }

    if (m_pTreeCtrl->InsertNode(htiParent, hNodeNew, hInsertAfter) == NULL)
        return;

    // if parent of the inserted item currently owns a non-virtual result list,
    // add the item to result list too. Don't add the item if a node select is in
    // progress because the tree control will automatically add all scope items
    // as part of the select procedure.
    if (OwnsResultList(htiParent) && CanInsertScopeItemInResultPane() )
    {
        // Ensure the node is enumerated
        m_pTreeCtrl->ExpandNode(htiParent);

        // Add to result pane.
        RESULTDATAITEM tRDI;
        ::ZeroMemory(&tRDI, sizeof(tRDI));
        tRDI.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        tRDI.nCol = 0;
        tRDI.str = MMC_TEXTCALLBACK;
        tRDI.nIndex = iInsertIndex;

        int nImage;
        int nSelectedImage;

        hr = m_spNodeCallback->GetImages(hNodeNew, &nImage, &nSelectedImage);
        ASSERT(hr == S_OK || nImage == 0);

        tRDI.nImage = nImage;
        tRDI.lParam = CAMCTreeView::LParamFromNode (hNodeNew);

        LPRESULTDATA pResultData = m_pTreeCtrl->GetResultData();
        ASSERT(pResultData != NULL);
        hr = pResultData->InsertItem(&tRDI);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
            hr = m_spNodeCallback->SetResultItem(hNodeNew, tRDI.itemID);
    }

    if ((m_pTreeCtrl->GetRootItem() == htiParent) ||
        ((bFirstChild == true) &&
         (m_spNodeCallback->Notify(hNodeParent, NCLBK_GETEXPANDEDVISUALLY, 0, 0) == S_OK)))
    {
        m_pTreeCtrl->Expand(htiParent, TVE_EXPAND);
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnEmptyAddToCArray
 *
 * PURPOSE: Called to check if this view is empty.
 *          If this view is empty then add it to the given CArray
 *          so that the view can be deleted by the owner of CArray (CMainFrame).
 *
 * PARAMETERS:
 *    pHint - CArray of CAMCView*
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCView::OnEmptyAddToCArray(CObject* pHint)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnEmptyAddToCArray"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    // View is not empty.
    if (m_pTreeCtrl->GetRootItem() != NULL)
        return;

    // Ensure that there is at least one *persistable* view
    CAMCDoc* pDoc = dynamic_cast<CAMCDoc*>(GetDocument());
    sc = ScCheckPointers(pDoc);
    if (sc)
    {
        sc.TraceAndClear();
        return;
    }

    // BUG #666149. Empty views should not be deleted if this method is
    // called during a persist operation.
    if(!pDoc->CanCloseViews())
        return;

    int cViews = pDoc->GetNumberOfPersistedViews();
    ASSERT(cViews >= 1);
    if ((cViews == 1) && IsPersisted())
    {
        CMainFrame* pMain = dynamic_cast<CMainFrame*>(AfxGetMainWnd());
        sc = ScCheckPointers(pMain);
        if (sc)
        {
            sc.TraceAndClear();
            return;
        }

        pMain->SendMessage(WM_COMMAND, ID_WINDOW_NEW, 0);
    }

    CChildFrame* pFrame = GetParentFrame();
    sc = ScCheckPointers(pFrame, pHint);
    if (sc)
    {
        sc.TraceAndClear();
        return;
    }

    // Tell CChildFrame that the view is empty.
    pFrame->SetAMCViewIsEmpty();

    // Add this view to empty AMCViews
    CArray<CAMCView*, CAMCView*> *prgEmptyAMCViews = reinterpret_cast<CArray<CAMCView*, CAMCView*> *>(pHint);
    sc = ScCheckPointers(prgEmptyAMCViews);
    if (sc)
    {
        sc.TraceAndClear();
        return;
    }

    prgEmptyAMCViews->Add(this);
}

void CAMCView::OnDelete(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnDelete);

    ASSERT(pvui->path.IsEmpty() == FALSE);

    HTREEITEM hti;
    UINT uiReturn = GetTreeItem(&pvui->path, &hti);

    if (uiReturn == ITEM_NOT_IN_VIEW)
        return;

    ASSERT(uiReturn != ITEM_IS_IN_VIEW || pvui->path.GetTail() == GetHMTNode(hti));

    HTREEITEM htiSel = m_pTreeCtrl->GetSelectedItem();
    BOOL fDeleteThis = (pvui->flag & VUI_DELETE_THIS) ? TRUE : FALSE;
    BOOL fExpandable = (pvui->flag & VUI_DELETE_SETAS_EXPANDABLE) ? TRUE : FALSE;

    if (uiReturn == ITEM_IS_PARENT_OF_ROOT ||
        NULL == hti)
    {
        hti = m_pTreeCtrl->GetRootItem();
        fDeleteThis = TRUE;
        fExpandable = FALSE;
    }

    ASSERT(hti != NULL);

    // If deleted scope item is also shown in the result pane
    // delete it there too. Can't happen with a virtual list.
    // Don't try deleting item if selection is in progress because
    // the scope items haven't been added yet.

    if (fDeleteThis == TRUE &&
        OwnsResultList(m_pTreeCtrl->GetParentItem(hti)) &&
        CanInsertScopeItemInResultPane())
    {
        INodeCallback* pNC = GetNodeCallback();
        HRESULTITEM itemID;
        HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);
        HRESULT hr = pNC->GetResultItem(hNode, &itemID);
        if (SUCCEEDED(hr) && itemID != 0)
        {
            IResultData* pIRD = m_pTreeCtrl->GetResultData();
            pIRD->DeleteItem(itemID, 0);
        }
    }

    m_pTreeCtrl->DeleteNode(hti, fDeleteThis);

    if (fDeleteThis == FALSE && fExpandable == TRUE)
        m_pTreeCtrl->SetItemState(hti, 0, TVIS_EXPANDEDONCE | TVIS_EXPANDED);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnUpdateSelectionForDelete
 *
 * PURPOSE: Called when a scope node is deleted. If the node is an ancestor
 *          of the currently selected node, the selection is changed to the closest
 *          node of the deleted node. This is either the next sibling of the node that is being deleted,
 *          or, if there is no next sibling, the previous sibling, or, if there is none,
 *          the parent.
 *
 * PARAMETERS:
 *    SViewUpdateInfo* pvui :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::OnUpdateSelectionForDelete(SViewUpdateInfo* pvui)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnUpdateSelectionForDelete"));

    // make sure we have a path to the deleted node.
    if(pvui->path.IsEmpty())
    {
        sc = E_UNEXPECTED;
        return;
    }

    HTREEITEM htiToDelete;
    UINT uiReturn = GetTreeItem(&pvui->path, &htiToDelete);

    if (uiReturn == ITEM_IS_IN_VIEW && NULL != htiToDelete)
    {
        HTREEITEM htiSel = m_pTreeCtrl->GetSelectedItem();
        BOOL fDeleteThis = (pvui->flag & VUI_DELETE_THIS);

        // Determine whether the selected node is a descendant of the
        // node bring deleted.
        HTREEITEM htiTemp = htiSel;
        while (htiTemp != NULL && htiTemp != htiToDelete)
        {
            htiTemp = m_pTreeCtrl->GetParentItem(htiTemp);
        }

        if (htiToDelete == htiTemp)
        {
            // The selected node is a descendant of the
            // node being deleted.

            if (fDeleteThis == TRUE)
                htiTemp = m_pTreeCtrl->GetParentItem(htiToDelete);

            if (!htiTemp)
                htiTemp = htiToDelete;

            if (htiTemp != htiSel)
            {
                HNODE hNode = m_pTreeCtrl->GetItemNode(htiSel);

                // the next line is not needed because m_pTreeCtrl->SelectItem() winds up calling OnDeSelectNode anyway.
                // m_pTreeCtrl->OnDeSelectNode(hNode);

                ASSERT(htiTemp != NULL);
                if (htiTemp != NULL)
                    m_pTreeCtrl->SelectItem(htiTemp);
            }
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnUpdateTaskpadNavigation
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      SViewUpdateInfo *  pvui:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
void CAMCView::OnUpdateTaskpadNavigation(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnupdateTaskpadNavigation);

    ASSERT(pvui->newNode != NULL);

    //m_spNodeCallback->UpdateTaskpadNavigation(GetSelectedNode(), pvui->newNode);
}

/*+-------------------------------------------------------------------------*
 * CAMCView::OnModify
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      SViewUpdateInfo *  pvui:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
void CAMCView::OnModify(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnModify);

    ASSERT(pvui->path.IsEmpty() == FALSE);

    HNODE hNode = 0;
    HTREEITEM hti;

    if (GetTreeItem(&pvui->path, &hti) == ITEM_IS_IN_VIEW && hti != NULL)
    {
        ASSERT(m_pTreeCtrl != NULL);
        m_pTreeCtrl->ResetNode(hti);

        /*
         * The name of the selected node and all of its ancestors are
         * displayed in the frame title.  If the modified item is an
         * ancestor of the selected node, we need to update the frame title.
         */
        HTREEITEM htiAncesctor;

        for (htiAncesctor  = m_pTreeCtrl->GetSelectedItem();
             htiAncesctor != NULL;
             htiAncesctor  = m_pTreeCtrl->GetParentItem (htiAncesctor))
        {
            if (htiAncesctor == hti)
            {
                CChildFrame* pFrame = GetParentFrame();
                if (pFrame)
                    pFrame->OnUpdateFrameTitle(TRUE);
                break;
            }
        }

        ASSERT(hti != NULL);

        if (hti != NULL &&
            OwnsResultList(m_pTreeCtrl->GetParentItem(hti)) &&
            !IsVirtualList())
        {
            // Continue only if the currently selected item is the parent
            // of the modified node. In this case we need to update the
            // result view. Can't happen with a virtual list.

            if (hNode == 0)
                hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);

            ASSERT(hNode != NULL);

            HRESULTITEM hri;
            HRESULT hr = m_spNodeCallback->GetResultItem(hNode, &hri);
            CHECK_HRESULT(hr);

            // NOTE: the test for itemID != NULL below is related to bug 372242:
            // MMC asserts on index server root node.
            // What happens is that the snapin adds scope nodes on a SHOW event.
            // These items have not yet been added to the result pane and so itemID
            // comes back NULL.
            if (SUCCEEDED(hr) && hri != NULL)
                m_pListCtrl->OnModifyItem(CResultItem::FromHandle(hri));
        }
    }
}




void CAMCView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    Dbg(DEB_USER1, _T("CAMCView::OnUpdate<0x%08x, 0x%08x, 0x%08x>\n"),
                                            pSender, lHint, pHint);
    SViewUpdateInfo *pvui = reinterpret_cast<SViewUpdateInfo*>(pHint);
    switch (lHint)
    {
    case 0:
        // Sent by CView::OnInitialUpdate()
        break;

    case VIEW_UPDATE_ADD:
        OnAdd(pvui);
        break;

    case VIEW_UPDATE_SELFORDELETE:
        OnUpdateSelectionForDelete(pvui);
        break;

    case VIEW_UPDATE_DELETE:
        OnDelete(pvui);
        break;

    case VIEW_UPDATE_DELETE_EMPTY_VIEW:
        OnEmptyAddToCArray(pHint);
        break;

    case VIEW_UPDATE_MODIFY:
        OnModify(pvui);
        break;

    case VIEW_RESELECT:
        if (m_ViewData.m_spControlbarsCache != NULL)
            m_ViewData.m_spControlbarsCache->DetachControlbars();
        m_pTreeCtrl->ScReselect();
        break;

    case VIEW_UPDATE_TASKPAD_NAVIGATION:
        OnUpdateTaskpadNavigation(pvui);
        break;

    default:
        ASSERT(0);
    }
}

static int static_nViewID = 1;

UINT CAMCView::GetViewID(void)
{
    if (m_nViewID)
        return m_nViewID;
    SetViewID(static_nViewID);
    ++static_nViewID;
    return m_nViewID;
    //UINT const id = m_nViewID ? m_nViewID : m_nViewID = static_nViewID++;
    //return id;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScCompleteInitialization
 *
 * This function completes the initialization process for CAMCView.  It
 * is called from OnInitialUpdate.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScCompleteInitialization()
{
    DECLARE_SC (sc, _T("CAMCView::ScCompleteInitialization"));

    IScopeTree* const pScopeTree = GetScopeTree();
    sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
    if (sc)
        return (sc);

    pScopeTree->QueryIterator(&m_spScopeTreeIter);
    pScopeTree->QueryNodeCallback(&m_spNodeCallback);

    m_ViewData.m_spNodeCallback = GetNodeCallback();
    sc = ScCheckPointers (m_ViewData.m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return (sc);

    CAMCDoc* const pDoc = GetDocument();
    sc = ScCheckPointers (pDoc, E_UNEXPECTED);
    if (sc)
        return (sc);

    if (m_hMTNode == NULL)
    {
        MTNODEID const nodeID = pDoc->GetMTNodeIDForNewView();
        HRESULT hr = pScopeTree->Find(nodeID, &m_hMTNode);

        if (FAILED(hr) || m_hMTNode == 0)
        {
            sc.FromMMC (IDS_ExploredWindowFailed);
            return (sc);
        }
    }

    sc = m_spStandardToolbar->ScInitializeStdToolbar(this);
    if (sc)
        return (sc);

    // Set the iterator to the correct node
    m_spScopeTreeIter->SetCurrent(m_hMTNode);

    bool fShowScopePane            = IsScopePaneAllowed();

    // Intialize the iterator and the callback interface

    SetViewID(pDoc->GetViewIDForNewView());
    GetViewID(); // initialized the view id if GetViewIDForNewView returned 0

    // Insert the root node for this view
    HNODE hNode = 0;
    sc = pScopeTree->CreateNode (m_hMTNode, reinterpret_cast<LONG_PTR>(GetViewData()),
                                 TRUE, &hNode);
    if (sc)
        return (sc);

    sc = ScCheckPointers (hNode, E_UNEXPECTED);
    if (sc)
        return (sc);

    HTREEITEM hti = m_pTreeCtrl->InsertNode(TVI_ROOT, hNode);
    m_htiStartingSelectedNode = hti;

    // If the persisted state is expanded, call INodeCallback::Expand
    m_pTreeCtrl->Expand(hti, TVE_EXPAND);

    /*
     * If a scope pane is permitted in this window, set the scope
     * pane visible, and modify the scope pane & favorites toolbar
     * buttons to the proper checked state.
     */
    sc = ScShowScopePane (fShowScopePane, true);
    if (sc)
        return (sc);

    LPUNKNOWN pUnkResultsPane = NULL;
    pUnkResultsPane = GetPaneUnknown(ePane_Results);
    m_pTreeCtrl->m_spNodeManager->SetResultView(pUnkResultsPane);

    DeferRecalcLayout();

    m_pHistoryList->Clear();
    IdentifyRootNode ();

    // Select the root item
    hti = m_pTreeCtrl->GetRootItem();
    m_pTreeCtrl->SelectItem(hti);

    /*
     * if the document has a custom icon, use it on this window
     */
    if (pDoc->HasCustomIcon())
    {
        GetParentFrame()->SetIcon (pDoc->GetCustomIcon(true),  true);
        GetParentFrame()->SetIcon (pDoc->GetCustomIcon(false), false);
    }

    /*
     * we just initialized, so the view isn't dirty
     */
    SetDirty (false);

    return (sc);
}

void CAMCView::OnInitialUpdate()
{
    DECLARE_SC (sc, _T("CAMCView::OnInitialUpdate"));
    CView::OnInitialUpdate();

    sc = ScCompleteInitialization ();
    if (sc)
        return;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDocumentLoadCompleted
//
//  Synopsis:    The document is completely loaded so all the objects
//               that initialize themself from document are in valid
//               state. Any initialization performed earlier using invalid
//               data can be now re-initialized with proper data.
//
//               The above CAMCView::ScCompleteInitialization is called
//               during the loading of views, thus the document is not
//               completely loaded yet.
//
//  Arguments:   [pDoc] - [in] the CAMCDoc object
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDocumentLoadCompleted (CAMCDoc *pDoc)
{
    DECLARE_SC(sc, _T("CAMCView::ScDocumentLoadCompleted"));
    sc = ScCheckPointers(pDoc);
    if (sc)
        return sc;

    // 1. Need to hide toolbutton "Show/Hide scopetree".
    // The FrameState is loaded after views when CAMCDoc loads document. And it contains
    // whether the "View Customization" is enabled or not. If "View customization" is
    // disabled then we need to disable "Show ScopeTree" button.
    if (! pDoc->AllowViewCustomization())
    {
        CStandardToolbar* pStdToolbar = GetStdToolbar();
        sc = ScCheckPointers(pStdToolbar, E_UNEXPECTED);
        if (sc)
            return (sc);

        sc = pStdToolbar->ScEnableScopePaneBtn (false);
        if (sc)
            return (sc);
    }

    return (sc);
}



/*--------------------------------------------------------------------------*
 * CAMCView::IdentifyRootNode
 *
 * This functions determines if this view is rooted at a non-persistent
 * dynamic node.  If so, we won't persist this view at save time.
 *--------------------------------------------------------------------------*/

void CAMCView::IdentifyRootNode ()
{
    // In order to get results from GetRootNodePath that are meaningful
    // in this context, there needs to be a root item in the tree.
    ASSERT (m_pTreeCtrl->GetRootItem() != NULL);

    CBookmark bm;
    HRESULT   hr = GetRootNodePath (&bm);
    ASSERT (SUCCEEDED (hr) == bm.IsValid());

    m_fRootedAtNonPersistedDynamicNode = (hr != S_OK);
}


void GetFullPath(CAMCTreeView &ctc, HTREEITEM hti, CString &strPath)
{
    TRACE_FUNCTION(GetFullPath);

    if (hti == NULL)
    {
        strPath = _T("");
        return;
    }

    GetFullPath(ctc, ctc.GetParentItem(hti), strPath);

    if (strPath.GetLength() > 0)
        strPath += _T('\\');

    HNODE hNode = ctc.GetItemNode(hti);

    INodeCallback* spCallback = ctc.GetNodeCallback();
    ASSERT(spCallback != NULL);

    tstring strName;
    HRESULT const hr = spCallback->GetDisplayName(hNode, strName);

    strPath += strName.data();
}

LPCTSTR CAMCView::GetWindowTitle(void)
{
    TRACE_METHOD(CAMCView, GetWindowTitle);

    if (HasCustomTitle() && (m_spNodeCallback != NULL))
    {
        HNODE hNode = GetSelectedNode();

        if (hNode != NULL)
        {
            tstring strWindowTitle;

            if (SUCCEEDED(m_spNodeCallback->GetWindowTitle(hNode, strWindowTitle)))
            {
                m_strWindowTitle = strWindowTitle.data();
                return m_strWindowTitle;
            }
        }
    }


    if (m_pTreeCtrl == NULL)
    {
        m_strWindowTitle.Empty();
    }
    else
    {
        GetFullPath(*m_pTreeCtrl,
                    m_pTreeCtrl->GetSelectedItem(),
                    m_strWindowTitle);
    }

    return m_strWindowTitle;
}


void CAMCView::SelectNode(MTNODEID ID, GUID &guidTaskpad)
{
    ScSelectNode(ID);

    // After setting the taskpad enable/disable save list button
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    ASSERT(NULL != pStdToolbar);
    if (NULL != pStdToolbar)
    {
        pStdToolbar->ScEnableExportList(GetListSize() > 0 /*Enable only if LV has items*/);
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSelectNode
//
//  Synopsis:    Select the given node. Normally if the node is not available
//               then we select nearest parent or child. But if bSelectExactNode
//               is true then have to select the exact node else do not select any node.
//
//  Arguments:   [ID]               - [in] node that needs to be selected.
//               [bSelectExactNode] - [in] select exact node or not?
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSelectNode (MTNODEID ID, bool bSelectExactNode)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScSelectNode"));

    IScopeTree* pIST = GetScopeTreePtr();
    sc = ScCheckPointers(pIST, m_pTreeCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    long length = 0;
    CCoTaskMemPtr<MTNODEID> spIDs;

    sc = pIST->GetIDPath(ID, &spIDs, &length);
    if (sc)
        return (sc);

    if ( (length < 1) || (spIDs == NULL) )
        return (sc = E_FAIL);


    sc = m_pTreeCtrl->ScSelectNode(spIDs, length, bSelectExactNode);

    // If select exact node is specified and the node could not be
    // selected then return error without tracing it.
    if (bSelectExactNode && (sc == ScFromMMC(IDS_NODE_NOT_FOUND)) )
    {
        SC scNoTrace = sc;
        sc.Clear();
        return scNoTrace;
    }

    if (sc)
        return sc;

    SetDirty();

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExpandNode
 *
 * PURPOSE: Expands the tree up to the specified node. The expansion can occur
 *          either visually, where the user sees the expansion, or nonvisually,
 *          where all the child items are added but there is no visual effect.
 *
 * PARAMETERS:
 *    MTNODEID id : id of node to expand
 *    bool     bExpand : true to expand the node, false to collapse
 *    bool     bExpandVisually : true to show the changes, else false.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScExpandNode (
    MTNODEID    id,
    bool        fExpand,
    bool        fExpandVisually)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScExpandNode"));

    IScopeTree* pIST = GetScopeTreePtr();
    ASSERT(pIST != NULL);
    if (!pIST)
        return (sc = E_NOINTERFACE);

    long length = 0;
    CCoTaskMemPtr<MTNODEID> spIDs;
    sc = pIST->GetIDPath(id, &spIDs, &length);
    if (sc)
        return (sc);

    ASSERT(length);
    ASSERT(spIDs);

    ASSERT(m_pTreeCtrl != NULL);
    if (m_pTreeCtrl)
        m_pTreeCtrl->ExpandNode(spIDs, length, fExpand, fExpandVisually);

    return (sc);
}

ViewSettings::ViewSettings(CAMCView* v)
    : m_nViewID(v->m_nViewID), m_bDescriptionbarVisible(v->IsDescBarVisible()),
    m_nViewMode(v->m_nViewMode), m_nListViewStyle(v->GetDefaultListViewStyle()),
    m_DefaultLVStyle(v->m_DefaultLVStyle), m_bScopePaneVisible(v->IsScopePaneVisible())
{

    ASSERT(v != NULL);
    v->GetPaneInfo (CConsoleView::ePane_ScopeTree, &m_Scope.cxWidth, &m_Scope.cxMin);
    v->GetDefaultColumnWidths(m_DefaultColumnWidths);
}

/*
 * The location and hidden fields of the scope structure were redundant and are
 * no longer used. Both fields were used to indicate when the scope pane was
 * hidden, which is also determined by the FLAG1_SCOPE_VISIBLE flag. The space
 * has been retained to avoid changing the persisted structure.
 */

struct PersistedViewData
{
    WINDOWPLACEMENT windowPlacement;

    struct
    {
        int location;     // not used, but kept for compatibility
        int min;
        int ideal;
        BOOL hidden;      // not used, but kept for compatibility
    } scope;

    int     viewMode;
    long    listViewStyle;
    ULONG   ulFlag1;
    int     viewID;
    BOOL    descriptionBarVisible;
    int     defaultColumnWidth[2];
};


/*
 * The sense of the FLAG1_NO_xxx flags is negative.  That is, when a
 * FLAG1_NO_xxx flag is set, its corresponding UI element is *not*
 * displayed.  This is to maintain compatibility with console files
 * created before the existence of the FLAG1_NO_xxx flags.  These
 * consoles always had all UI elements displayed, and the then-unused
 * bits in their flags field were defaulted to 0.  To maintain
 * compatibility, we have to maintain that (0 == on).
 */

#define FLAG1_SCOPE_PANE_VISIBLE    0x00000001
#define FLAG1_NO_STD_MENUS          0x00000002
#define FLAG1_NO_STD_BUTTONS        0x00000004
#define FLAG1_NO_SNAPIN_MENUS       0x00000008
#define FLAG1_NO_SNAPIN_BUTTONS     0x00000010
#define FLAG1_DISABLE_SCOPEPANE     0x00000020
#define FLAG1_DISABLE_STD_TOOLBARS  0x00000040
#define FLAG1_CUSTOM_TITLE          0x00000080
#define FLAG1_NO_STATUS_BAR         0x00000100
#define FLAG1_CREATED_IN_USER_MODE  0x00000200  // used to be named FLAG1_NO_AUTHOR_MODE
//#define FLAG1_FAVORITES_SELECTED  0x00000400  // unused, but don't recycle (for compatibility)
#define FLAG1_NO_TREE_ALLOWED     0x00000800    // used for compatibility with MMC1.2 in CAMCView::Load.
                                                // Do not use for any other purposes.
#define FLAG1_NO_TASKPAD_TABS       0x00001000

/***************************************************************************\
 *
 * ARRAY:  mappedViewModes
 *
 * PURPOSE: provides map to be used when persisting ViewMode enumeration
 *
\***************************************************************************/
static const EnumLiteral mappedViewModes[] =
{
    { MMCLV_VIEWSTYLE_ICON,             XML_ENUM_LV_STYLE_ICON },
    { MMCLV_VIEWSTYLE_REPORT,           XML_ENUM_LV_STYLE_REPORT },
    { MMCLV_VIEWSTYLE_SMALLICON,        XML_ENUM_LV_STYLE_SMALLICON },
    { MMCLV_VIEWSTYLE_LIST,             XML_ENUM_LV_STYLE_LIST },
    { MMCLV_VIEWSTYLE_FILTERED,         XML_ENUM_LV_STYLE_FILTERED},
};

/***************************************************************************\
 *
 * ARRAY:  mappedListStyles
 *
 * PURPOSE: provides map to be used when persisting ListView style flag
 *
\***************************************************************************/
static const EnumLiteral mappedListStyles[] =
{
    { LVS_SINGLESEL,            XML_BITFLAG_LV_STYLE_SINGLESEL },
    { LVS_SHOWSELALWAYS,        XML_BITFLAG_LV_STYLE_SHOWSELALWAYS },
    { LVS_SORTASCENDING,        XML_BITFLAG_LV_STYLE_SORTASCENDING },
    { LVS_SORTDESCENDING,       XML_BITFLAG_LV_STYLE_SORTDESCENDING },
    { LVS_SHAREIMAGELISTS,      XML_BITFLAG_LV_STYLE_SHAREIMAGELISTS },
    { LVS_NOLABELWRAP,          XML_BITFLAG_LV_STYLE_NOLABELWRAP },
    { LVS_AUTOARRANGE,          XML_BITFLAG_LV_STYLE_AUTOARRANGE },
    { LVS_EDITLABELS,           XML_BITFLAG_LV_STYLE_EDITLABELS },
    { LVS_OWNERDATA,            XML_BITFLAG_LV_STYLE_OWNERDATA },
    { LVS_NOSCROLL,             XML_BITFLAG_LV_STYLE_NOSCROLL },
    { LVS_ALIGNLEFT,            XML_BITFLAG_LV_STYLE_ALIGNLEFT },
    { LVS_OWNERDRAWFIXED,       XML_BITFLAG_LV_STYLE_OWNERDRAWFIXED },
    { LVS_NOCOLUMNHEADER,       XML_BITFLAG_LV_STYLE_NOCOLUMNHEADER },
    { LVS_NOSORTHEADER,         XML_BITFLAG_LV_STYLE_NOSORTHEADER },
};

/***************************************************************************\
 *
 * ARRAY:  mappedViewFlags
 *
 * PURPOSE: provides map to be used when persisting View flags
 *
\***************************************************************************/
static const EnumLiteral mappedViewFlags[] =
{
    { FLAG1_SCOPE_PANE_VISIBLE,      XML_BITFLAG_VIEW_SCOPE_PANE_VISIBLE },
    { FLAG1_NO_STD_MENUS,            XML_BITFLAG_VIEW_NO_STD_MENUS },
    { FLAG1_NO_STD_BUTTONS,          XML_BITFLAG_VIEW_NO_STD_BUTTONS },
    { FLAG1_NO_SNAPIN_MENUS,         XML_BITFLAG_VIEW_NO_SNAPIN_MENUS },
    { FLAG1_NO_SNAPIN_BUTTONS,       XML_BITFLAG_VIEW_NO_SNAPIN_BUTTONS },
    { FLAG1_DISABLE_SCOPEPANE,       XML_BITFLAG_VIEW_DISABLE_SCOPEPANE },
    { FLAG1_DISABLE_STD_TOOLBARS,    XML_BITFLAG_VIEW_DISABLE_STD_TOOLBARS },
    { FLAG1_CUSTOM_TITLE,            XML_BITFLAG_VIEW_CUSTOM_TITLE },
    { FLAG1_NO_STATUS_BAR,           XML_BITFLAG_VIEW_NO_STATUS_BAR },
    { FLAG1_CREATED_IN_USER_MODE,    XML_BITFLAG_VIEW_CREATED_IN_USER_MODE },
    { FLAG1_NO_TASKPAD_TABS,         XML_BITFLAG_VIEW_NO_TASKPAD_TABS },
};

/***************************************************************************\
 *
 * ARRAY:  mappedSWCommands
 *
 * PURPOSE: provides mapping to persist show commands as literals
 *
\***************************************************************************/
static const EnumLiteral mappedSWCommands[] =
{
    { SW_HIDE,              XML_ENUM_SHOW_CMD_HIDE },
    { SW_SHOWNORMAL,        XML_ENUM_SHOW_CMD_SHOWNORMAL },
    { SW_SHOWMINIMIZED,     XML_ENUM_SHOW_CMD_SHOWMINIMIZED },
    { SW_SHOWMAXIMIZED,     XML_ENUM_SHOW_CMD_SHOWMAXIMIZED },
    { SW_SHOWNOACTIVATE,    XML_ENUM_SHOW_CMD_SHOWNOACTIVATE },
    { SW_SHOW,              XML_ENUM_SHOW_CMD_SHOW },
    { SW_MINIMIZE,          XML_ENUM_SHOW_CMD_MINIMIZE },
    { SW_SHOWMINNOACTIVE,   XML_ENUM_SHOW_CMD_SHOWMINNOACTIVE },
    { SW_SHOWNA,            XML_ENUM_SHOW_CMD_SHOWNA },
    { SW_RESTORE,           XML_ENUM_SHOW_CMD_RESTORE },
    { SW_SHOWDEFAULT,       XML_ENUM_SHOW_CMD_SHOWDEFAULT },
    { SW_FORCEMINIMIZE,     XML_ENUM_SHOW_CMD_FORCEMINIMIZE },
};

/***************************************************************************\
 *
 * ARRAY:  mappedWPFlags
 *
 * PURPOSE: provides mapping to persist WP flags
 *
\***************************************************************************/

static const EnumLiteral mappedWPFlags[] =
{
    { WPF_SETMINPOSITION,       XML_ENUM_WIN_PLACE_SETMINPOSITION },
    { WPF_RESTORETOMAXIMIZED,   XML_ENUM_WIN_PLACE_RESTORETOMAXIMIZED },
#ifdef WPF_ASYNCWINDOWPLACEMENT
    { WPF_ASYNCWINDOWPLACEMENT, XML_ENUM_WIN_PLACE_ASYNCWINDOWPLACEMENT },
#else
    { 4,                        XML_ENUM_WIN_PLACE_ASYNCWINDOWPLACEMENT },
#endif
};


/*+-------------------------------------------------------------------------*
 * PersistViewData(CPersistor &persistor, PersistedViewData viewData)
 *
 *
 * PURPOSE: Persists a PersistedViewData object to the specified persistor.
 *
 *+-------------------------------------------------------------------------*/
void PersistViewData(CPersistor &persistor, PersistedViewData& viewData)
{
    persistor.PersistAttribute(XML_ATTR_VIEW_ID, viewData.viewID);

    // write out the windowPlacement structure.
    persistor.Persist(CXMLWindowPlacement(viewData.windowPlacement));

    // write out the scope structure
    persistor.PersistAttribute(XML_ATTR_VIEW_SCOPE_WIDTH, viewData.scope.ideal);

    if (persistor.IsLoading())
    {
        // initialize for compatibility;
        viewData.scope.hidden = true;
        viewData.scope.location = 0;
        viewData.scope.min = 50;
    }

    // write out the remaining fields
    CPersistor persistorSettings(persistor, XML_TAG_VIEW_SETTINGS_2);

    // create wrapper to persist enumeration values as strings
    CXMLEnumeration viewModePersistor(viewData.viewMode, mappedViewModes, countof(mappedViewModes));
    // persist the wrapper
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_VIEW_MODE,  viewModePersistor);

    // create wrapper to persist flag values as strings
    CXMLBitFlags viewStylePersistor(viewData.listViewStyle, mappedListStyles, countof(mappedListStyles));
    // persist the wrapper
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_LIST_STYLE, viewStylePersistor);

    // create wrapper to persist flag values as strings
    CXMLBitFlags flagPersistor(viewData.ulFlag1, mappedViewFlags, countof(mappedViewFlags));
    // persist the wrapper
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_FLAG, flagPersistor);

    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_DB_VISIBLE, CXMLBoolean(viewData.descriptionBarVisible));
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_DEF_COL_W0, viewData.defaultColumnWidth[0]);
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_DEF_COL_W1, viewData.defaultColumnWidth[1]);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Persist
 *
 * PURPOSE: Persists the CAMCView object to the specified persistor. Based
 *          on CAMCView::Save.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CAMCView::Persist"));

    HRESULT hr;

    CBookmark bmr;
    CBookmark bms;
    if (persistor.IsStoring())
    {
        sc = GetRootNodePath(&bmr);
        if (sc)
            sc.Throw();
        persistor.Persist(bmr, XML_NAME_ROOT_NODE);  // ... its too late for root node when loading

        sc = GetSelectedNodePath(&bms);
        if (sc)
            sc.Throw();
    }
    persistor.Persist(bms, XML_NAME_SELECTED_NODE);

    // mostly copied from CAMCView::Save

    // Get the parent frame
    CWnd* const pParent = GetParent();
    sc = ScCheckPointers(pParent,E_POINTER);
    if (sc)
        sc.Throw();

    // Get the frames state data
    PersistedViewData vd;
    vd.windowPlacement.length = sizeof(vd.windowPlacement);
    const BOOL bGotPlacement = pParent->GetWindowPlacement(&vd.windowPlacement);
    if (!bGotPlacement)
        sc.Throw(E_FAIL);

    if (persistor.IsStoring())
    {
        /*
         * If this window is minimized, make sure we set things up so the
         * WINDOWPLACEMENT.ptMinPosition will be restored by SetWindowPlacement
         * when we load.  If we don't do this, it'll get some random min
         * position, likely not what we want.
         */
        if (vd.windowPlacement.showCmd == SW_SHOWMINIMIZED)
            vd.windowPlacement.flags |= WPF_SETMINPOSITION;


        GetPaneInfo(ePane_ScopeTree, &vd.scope.ideal, &vd.scope.min);
        vd.viewMode = m_nViewMode;
        vd.listViewStyle = GetDefaultListViewStyle();

        vd.ulFlag1 = 0;

        if (IsScopePaneVisible())
            vd.ulFlag1 |= FLAG1_SCOPE_PANE_VISIBLE;

        if (!IsAuthorModeView())
            vd.ulFlag1 |= FLAG1_CREATED_IN_USER_MODE;

        if (!(m_ViewData.m_dwToolbarsDisplayed & STD_MENUS))
            vd.ulFlag1 |= FLAG1_NO_STD_MENUS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & STD_BUTTONS))
            vd.ulFlag1 |= FLAG1_NO_STD_BUTTONS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & SNAPIN_MENUS))
            vd.ulFlag1 |= FLAG1_NO_SNAPIN_MENUS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & SNAPIN_BUTTONS))
            vd.ulFlag1 |= FLAG1_NO_SNAPIN_BUTTONS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & STATUS_BAR))
            vd.ulFlag1 |= FLAG1_NO_STATUS_BAR;

        if (!AreStdToolbarsAllowed ())
            vd.ulFlag1 |= FLAG1_DISABLE_STD_TOOLBARS;

        if (!IsScopePaneAllowed ())
            vd.ulFlag1 |= FLAG1_DISABLE_SCOPEPANE;

        if (HasCustomTitle ())
            vd.ulFlag1 |= FLAG1_CUSTOM_TITLE;

        if (!AreTaskpadTabsAllowed())
            (vd.ulFlag1 |= FLAG1_NO_TASKPAD_TABS);

        vd.viewID = GetViewID();
        vd.descriptionBarVisible = IsDescBarVisible();

        GetDefaultColumnWidths(vd.defaultColumnWidth);
    }

    PersistViewData(persistor,vd);

    if (persistor.IsLoading())
    {
        ASSERT(int(m_nViewID) == vd.viewID);
        m_ViewData.m_nViewID = m_nViewID = vd.viewID;
        if (int(m_nViewID) >= static_nViewID)
            static_nViewID = m_nViewID + 1;

        //SetDefaultColumnWidths(vd.defaultColumnWidth);
        SetDescBarVisible(vd.descriptionBarVisible);

        // we shouldn't restore maximized window position
        // since it may not be proper one for the current resolution
        // related to bug #404118
        WINDOWPLACEMENT orgPlacement;
        ZeroMemory(&orgPlacement,sizeof(orgPlacement));
        orgPlacement.length = sizeof(orgPlacement);
        if (pParent->GetWindowPlacement(&orgPlacement))
        {
          vd.windowPlacement.ptMaxPosition = orgPlacement.ptMaxPosition;
        }

        m_ViewData.SetScopePaneVisible( 0 != (vd.ulFlag1 & FLAG1_SCOPE_PANE_VISIBLE) );

        // Set the location and size of the frame
        const BOOL bPlaced = pParent->SetWindowPlacement(&vd.windowPlacement);
        if (!bPlaced)
            sc.Throw(E_FAIL);

        // Restore window settings
        if (vd.ulFlag1 & FLAG1_DISABLE_SCOPEPANE)
            m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOSCOPEPANE;

        if (vd.ulFlag1 & FLAG1_DISABLE_STD_TOOLBARS)
            m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOTOOLBARS;

        if (vd.ulFlag1 & FLAG1_CUSTOM_TITLE)
            m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_CUSTOMTITLE;

        SetAuthorModeView (!(vd.ulFlag1 & FLAG1_CREATED_IN_USER_MODE));

        if ((vd.ulFlag1 & FLAG1_NO_TASKPAD_TABS))
            SetTaskpadTabsAllowed(FALSE);

        // Apply run time restrictions
        // if at least one type of scope pane allowed then if the selected
        // one is not allowed, switch to the other. If neither is allowed
        // then keep the selection and hide the scope pane.
        if (IsScopePaneAllowed())
        {
            // Restore scope pane settings
            SetPaneInfo(ePane_ScopeTree, vd.scope.ideal, vd.scope.min);

            sc = ScShowScopePane ( m_ViewData.IsScopePaneVisible() );
        }
        else
            sc = ScShowScopePane (false);

        if (sc)
            sc.Throw();

        // Force layout re-calculation
        DeferRecalcLayout();

        // Restore view style & view mode if persisted will be set by nodemgr.
        SetDefaultListViewStyle(vd.listViewStyle);

        DWORD dwToolbars = 0;
        if (!(vd.ulFlag1 & FLAG1_NO_STD_MENUS))
            dwToolbars |= STD_MENUS;
        if (!(vd.ulFlag1 & FLAG1_NO_STD_BUTTONS))
            dwToolbars |= STD_BUTTONS;
        if (!(vd.ulFlag1 & FLAG1_NO_SNAPIN_MENUS))
            dwToolbars |= SNAPIN_MENUS;
        if (!(vd.ulFlag1 & FLAG1_NO_SNAPIN_BUTTONS))
            dwToolbars |= SNAPIN_BUTTONS;
        if (!(vd.ulFlag1 & FLAG1_NO_STATUS_BAR))
            dwToolbars |= STATUS_BAR;

        // display the status bar appropriately
        if (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) != StatusBarOf (dwToolbars))
        {
            CChildFrame* pFrame = GetParentFrame ();
            if (pFrame != NULL)
            {
                pFrame->ToggleStatusBar();
                SetStatusBarVisible(!IsStatusBarVisible());

                ASSERT (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) ==
                                    StatusBarOf (dwToolbars));
            }
        }

        // display the appropriate toolbars
        if (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) != ToolbarsOf (dwToolbars))
        {
            m_spNodeCallback->UpdateWindowLayout(
                    reinterpret_cast<LONG_PTR>(&m_ViewData), dwToolbars);
            ASSERT (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) ==
                    ToolbarsOf (dwToolbars));
        }

        // Update the status of MMC menus.
        sc = ScUpdateMMCMenus();
        if (sc)
            sc.Throw();

        SetDirty (false);
        m_pHistoryList->Clear();
    }

    SaveStartingSelectedNode();

    if (persistor.IsLoading())
    {
        SC sc;

        IScopeTree* const pScopeTree = GetScopeTreePtr();
        if(!pScopeTree)
        {
            sc = E_UNEXPECTED;
            return;
        }

        MTNODEID idTemp = 0;
        bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark, unused
        sc = pScopeTree->GetNodeIDFromBookmark(bms, &idTemp, bExactMatchFound);
        if(sc)
            return;

        sc = ScSelectNode(idTemp);
        if(sc)
            return;
    }

    // if we've stored everything -we're clean
    if (persistor.IsStoring())
        SetDirty (false);
}


bool CAMCView::Load(IStream& stream)
// Caller is responsible for notifying user if false is returned
{
    TRACE_METHOD(CAMCView, Load);

    SetDirty (false);

    // Read the view data from the stream.
    ASSERT(&stream);
    if (!&stream)
        return false;
    PersistedViewData pvd;
    unsigned long bytesRead;
    HRESULT hr = stream.Read(&pvd, sizeof(pvd), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(pvd));
    if (FAILED(hr))
        return false;

    ASSERT(int(m_nViewID) == pvd.viewID);
    m_ViewData.m_nViewID = m_nViewID = pvd.viewID;
    if (int(m_nViewID) >= static_nViewID)
        static_nViewID = m_nViewID + 1;

    //SetDefaultColumnWidths(pvd.defaultColumnWidth);
    SetDescBarVisible(pvd.descriptionBarVisible);

    // Get the parent frame
    CWnd* const pParent = GetParent();
    ASSERT(pParent != NULL);
    if (pParent == NULL)
        return false;

    // we shouldn't restore maximized window position
    // since it may not be proper one for the current resolution
    // related to bug #404118
    WINDOWPLACEMENT orgPlacement;
    ZeroMemory(&orgPlacement,sizeof(orgPlacement));
    orgPlacement.length = sizeof(orgPlacement);
    if (pParent->GetWindowPlacement(&orgPlacement))
    {
      pvd.windowPlacement.ptMaxPosition = orgPlacement.ptMaxPosition;
    }

    // Set the location and size of the frame
    const BOOL bPlaced = pParent->SetWindowPlacement(&pvd.windowPlacement);
    ASSERT(bPlaced != FALSE);
    if (bPlaced == FALSE)
        return false;

    // Restore window settings
    if (pvd.ulFlag1 & FLAG1_DISABLE_SCOPEPANE)
        m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOSCOPEPANE;

    if (pvd.ulFlag1 & FLAG1_DISABLE_STD_TOOLBARS)
        m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOTOOLBARS;

    if (pvd.ulFlag1 & FLAG1_CUSTOM_TITLE)
        m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_CUSTOMTITLE;

    SetAuthorModeView (!(pvd.ulFlag1 & FLAG1_CREATED_IN_USER_MODE));

    if ((pvd.ulFlag1 & FLAG1_NO_TASKPAD_TABS))
        SetTaskpadTabsAllowed(FALSE);

    // Restore scope pane settings
    SetPaneInfo(ePane_ScopeTree, pvd.scope.ideal, pvd.scope.min);

    // The FLAG1_NO_TREE_ALLOWED is used only for compatibility with MMC1.2 console files
    // It is a relic from old console files that does not exist in MMC2.0 console files.
    bool bScopeTreeNotAllowed = (pvd.ulFlag1 & FLAG1_NO_TREE_ALLOWED);

    SC sc;

    if ( (IsScopePaneAllowed()) && (! bScopeTreeNotAllowed) )
        sc = ScShowScopePane ((pvd.ulFlag1 & FLAG1_SCOPE_PANE_VISIBLE) != 0);
    else
        sc = ScShowScopePane (false);

    if (sc)
        return (false);

    // Force layout re-calculation
    DeferRecalcLayout();

    // Restore view style & view mode if persisted will be set by nodemgr.
    SetDefaultListViewStyle(pvd.listViewStyle);

    DWORD dwToolbars = 0;
    if (!(pvd.ulFlag1 & FLAG1_NO_STD_MENUS))
        dwToolbars |= STD_MENUS;
    if (!(pvd.ulFlag1 & FLAG1_NO_STD_BUTTONS))
        dwToolbars |= STD_BUTTONS;
    if (!(pvd.ulFlag1 & FLAG1_NO_SNAPIN_MENUS))
        dwToolbars |= SNAPIN_MENUS;
    if (!(pvd.ulFlag1 & FLAG1_NO_SNAPIN_BUTTONS))
        dwToolbars |= SNAPIN_BUTTONS;
    if (!(pvd.ulFlag1 & FLAG1_NO_STATUS_BAR))
        dwToolbars |= STATUS_BAR;

    // display the status bar appropriately
    if (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) != StatusBarOf (dwToolbars))
    {
        CChildFrame* pFrame = GetParentFrame ();
        if (pFrame != NULL)
        {
            pFrame->ToggleStatusBar();
            SetStatusBarVisible(!IsStatusBarVisible());

            ASSERT (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) ==
                            StatusBarOf (dwToolbars));
        }
    }

    // display the appropriate toolbars
    if (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) != ToolbarsOf (dwToolbars))
    {
        m_spNodeCallback->UpdateWindowLayout(
                reinterpret_cast<LONG_PTR>(&m_ViewData), dwToolbars);
        ASSERT (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) ==
                ToolbarsOf (dwToolbars));
    }

    // Update the status of MMC menus.
    sc = ScUpdateMMCMenus();
    if (sc)
        return false;

    SetDirty (false);
    m_pHistoryList->Clear();

    return true;
}


//+-------------------------------------------------------------------
//
//  Member:     ScSpecialResultpaneSelectionActivate
//
//  Synopsis:    Only the list(/Web/OCX) or the tree can be "active" from the point
//               of view of selected items and MMCN_SELECT. This is not
//               the same as the MFC concept of "active view". There are a couple
//               of views that cannot be active in this sense, such as the taskpad
//               and tab views.
//               When the active view (according to this definition) changes, this
//               function is called. Thus, ScTreeViewSelectionActivate and
//               ScListViewSelectionActivate/ScSpecialResultpaneSelectionActivate
//               are always called in pairs when the activation changes, one to handle
//               deactivation, and one to handle activation.
//
//               Consider the following scenario
//               1) The tree view has (MFC/windows style) focus.
//               2) The user clicks on the taskpad view
//                   Result - selection activation does not change from the tree. All verbs
//                   still correspond to the selected tree item.
//               3) The user clicks on the folder view
//                   Result - once again, selection activation does not chang
//               4) The user clicks on one of the result views eg the list
//                   Result - ScTreeViewSelectionActivate(false) and ScListViewSelectionActivate(true)
//                   Thus verbs and the toolbar now correspond to the selected list item(s).
//               5) The user clicks on the taskpad view.
//                   Result - as in step 2, nothing happens
//               6) The user clicks on the result view
//                   Result - because the active view has not changed, nothing happens.
//
//  Arguments:  [bActivate] - special result pane is selected/de-selected.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSpecialResultpaneSelectionActivate(bool bActivate)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSpecialResultpaneSelectionActivate"));

    /*
     * Bug 331904: prevent recursion
     */
    if (m_fActivatingSpecialResultPane)
    {
        TRACE (_T("CAMCView:ScSpecialResultpaneSelectionActivate: shorting out of recursion\n"));
        return sc;
    }

    do
    {
        m_fActivatingSpecialResultPane = true;

        HNODE hNode = GetSelectedNode();

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = FALSE;
        selInfo.m_bDueToFocusChange = TRUE;
        selInfo.m_bBackground = FALSE;

        INodeCallback* pNodeCallBack = GetNodeCallback();

        if (HasOCX())
        {
            selInfo.m_bResultPaneIsOCX = TRUE;
            selInfo.m_lCookie = LVDATA_CUSTOMOCX;
        }
        else if (HasWebBrowser())
        {
            selInfo.m_bResultPaneIsWeb = TRUE;
            selInfo.m_lCookie = LVDATA_CUSTOMWEB;
        }
        else
        {
            // Dont do anything. Just return.
            m_fActivatingSpecialResultPane = false;
            return sc;
        }

        sc = ScNotifySelect (pNodeCallBack, hNode, false /*fMultiSelect*/, bActivate, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

    } while ( FALSE );

    m_fActivatingSpecialResultPane = false;

    return sc;
}

void CAMCView::CloseView()
{
    DECLARE_SC(sc, TEXT("CAMCView::CloseView"));

    TRACE_METHOD(CAMCView, CloseView);

    // fire event to script
    // this needs to be done while view is still 'alive'
    sc = ScFireEvent(CAMCViewObserver::ScOnCloseView, this);
    if (sc)
        sc.TraceAndClear();

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    ASSERT(pScopeTree != NULL);
    if (pScopeTree != NULL)
    {
        HRESULT hr = pScopeTree->CloseView(m_nViewID);
        ASSERT(hr == S_OK);
    }
}


void CAMCView::OnDestroy()
{
    TRACE_METHOD(CAMCView, OnDestroy);

    // send the view destroy notification to all observers.
    SC sc;
    sc = ScFireEvent(CAMCViewObserver::ScOnViewDestroyed, this);
    if(sc)
        sc.TraceAndClear();

    if (IsPersisted())
    {
        if(m_pDocument != NULL)
            m_pDocument->SetModifiedFlag(TRUE);
        SetDirty();
    }

    CDocument* pDoc = GetDocument();
    ASSERT(pDoc != NULL);

    // if we were in ListPad-mode....
    // this must be detached before destroying the Scopetree,
    // because we need to send a notify to the snapin,
    // which we get from the hnode.
    if (m_pListCtrl->IsListPad())
    {
        sc = m_pListCtrl->ScAttachToListPad (NULL, NULL);
        if(sc)
            sc.TraceAndClear();
    }

    // make sure to stop running scripts if we have a web browser
    if( HasWebBrowser() )
    {
		// no assert - may be already destroyed in DeleteEmptyView
        //ASSERT( m_pWebViewCtrl != NULL );
        if ( m_pWebViewCtrl != NULL )
        {
            m_pWebViewCtrl->DestroyWindow();
            m_pWebViewCtrl = NULL;
        }
    }

    // make sure to stop running scripts if we have a view extension
    if ( m_fViewExtended )
    {
		// no assert - may be already destroyed in DeleteEmptyView
        // ASSERT( m_pViewExtensionCtrl != NULL );
        if ( m_pViewExtensionCtrl != NULL )
        {
            m_pViewExtensionCtrl->DestroyWindow();
            m_pViewExtensionCtrl = NULL;
        }
    }

    if (m_pTreeCtrl != NULL)
    {
        HNODE hNode = GetSelectedNode();
        if (hNode)
            m_pTreeCtrl->OnDeSelectNode(hNode);

        m_pTreeCtrl->DeleteScopeTree();
    }

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    ASSERT(pScopeTree != NULL);
    if (pScopeTree != NULL)
    {
        HRESULT hr = pScopeTree->DeleteView(m_nViewID);
        ASSERT(hr == S_OK);
    }

    CView::OnDestroy();
}

void CAMCView::OnUpdateFileSnapinmanager(CCmdUI* pCmdUI)
{
    pCmdUI->Enable ();
}

void CAMCView::OnSize(UINT nType, int cx, int cy)
{
    TRACE_METHOD(CAMCView, OnSize);

    CView::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
        RecalcLayout();
}

SC CAMCView::ScToggleDescriptionBar()
{
    TRACE_METHOD(CAMCView, ScToggleDescriptionBar);
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    SetDescBarVisible (!IsDescBarVisible());
    SetDirty();

    /*
     * Don't defer this layout.  This may be called by the Customize View
     * dialog which wants to see its updates in real time.  It will be
     * sitting in a modal message loop so we won't get a chance to precess
     * our idle task.
     */
    RecalcLayout();

    return (S_OK);
}

SC CAMCView::ScToggleStatusBar()
{
    TRACE_METHOD(CAMCView, ScToggleStatusBar);
    AFX_MANAGE_STATE (AfxGetAppModuleState());
        DECLARE_SC (sc, _T("CAMCView::ScToggleStatusBar"));

    CChildFrame* pFrame = GetParentFrame();
        sc = ScCheckPointers (pFrame, E_UNEXPECTED);
        if (sc)
                return (sc);

    pFrame->ToggleStatusBar();

    SetStatusBarVisible (!IsStatusBarVisible());
    SetDirty();

    return (sc);
}

SC CAMCView::ScToggleTaskpadTabs()
{
    TRACE_METHOD(CAMCView, ScToggleTaskpadTabs);
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    SetTaskpadTabsAllowed (!AreTaskpadTabsAllowed());
    SetDirty();

    /*
     * Don't defer this layout.  This message will be sent by the
     * Customize View dialog which wants to see its updates in
     * real time.  It will be sitting in a modal message loop so
     * we won't get a chance to precess our idle task.
     */
    RecalcLayout();

    return (S_OK);
}

SC CAMCView::ScToggleScopePane()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScToggleScopePane"));

    sc = ScShowScopePane (!IsScopePaneVisible());
    if (sc)
        return (sc);

    return (sc);
}

void CAMCView::OnActionMenu(CPoint point, LPCRECT prcExclude)
{
    TRACE_METHOD(CAMCView, OnActionMenu);

    UINT fHitTestFlags = 0;
    HTREEITEM hTreeItem = m_pTreeCtrl->GetSelectedItem( );

    ASSERT_VALID (this);

    /*
     * BUG: 99643
     * Right now there is inconsistency between what you get by action menu & right click
     * on a location in taskpad. The action menu always assumes it is tree or if result
     * pane it is list or ocx or web or background. So if a taskpad is selected it assumes
     * the corresponding list item is selected or tree item is selected or background.
     * But right click on taskpad calls CAMCView::OnContextMenu which determines nothing
     * is selected and does nothing. This needs to be addressed.
     */

    ASSERT(eActivePaneNone != m_eCurrentActivePane);

    if (eActivePaneScope == m_eCurrentActivePane)
    {
        if (hTreeItem != NULL)
        {
            HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hTreeItem);
            OnContextMenuForTreeItem(INDEX_INVALID, hNode, point, CCT_SCOPE, hTreeItem, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
        }
        else
        {
            OnContextMenuForTreeBackground(point, prcExclude, false/*bAllowDefaultItem*/);
        }
    }
    else
    {
        if (HasListOrListPad())
        {
            int cSel = m_pListCtrl->GetSelectedCount();
            int nIndex = -1;

            LPARAM lvData = LVDATA_ERROR;
            if (cSel == 0)
                lvData = LVDATA_BACKGROUND;
            else if (cSel == 1)
                nIndex = _GetLVSelectedItemData(&lvData);
            else if (cSel > 1)
                lvData = LVDATA_MULTISELECT;


            ASSERT(lvData != LVDATA_ERROR);
            if (lvData == LVDATA_ERROR)
                return;

            if (lvData == LVDATA_BACKGROUND)
            {
                // Find out which pane has focus to set the CMINFO_DO_SCOPEPANE_MENU flag.
                HNODE hNode = GetSelectedNode();
                DATA_OBJECT_TYPES ePaneType = (GetParentFrame()->GetActiveView() == m_pTreeCtrl) ? CCT_SCOPE : CCT_RESULT;

                OnContextMenuForTreeItem(INDEX_BACKGROUND, hNode, point, ePaneType, hTreeItem, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                return;
            }
            else if (lvData == LVDATA_MULTISELECT)
            {
                OnContextMenuForListItem(INDEX_MULTISELECTION, NULL, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
            }
            else
            {
                if (IsVirtualList())
                {
                    OnContextMenuForListItem(nIndex, (HRESULTITEM)NULL, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                }
                else
                {
                    CResultItem* pri = CResultItem::FromHandle (lvData);

                    if (pri != NULL)
                    {
                        if (pri->IsScopeItem())
                            OnContextMenuForTreeItem(nIndex, pri->GetScopeNode(), point, CCT_RESULT, NULL, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                        else
                            OnContextMenuForListItem(nIndex, lvData, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                    }
                }
            }
        }
        else
        {
            // The active window may be a web page or task pad or ocx.

            LPARAM lvData = LVDATA_ERROR;

            if (HasOCX())
            {
                lvData = LVDATA_CUSTOMOCX;
                OnContextMenuForListItem(INDEX_OCXPANE, (HRESULTITEM)lvData, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
            }
            else if (HasWebBrowser())
            {
                lvData = LVDATA_CUSTOMWEB;
                OnContextMenuForListItem(INDEX_WEBPANE, (HRESULTITEM)lvData, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
            }
            else
            {
                // Some unknown window has the focus.
                ASSERT(FALSE && "Unknown window has the focus");
            }
        }
    }
}


SC CAMCView::ScUpOneLevel()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    TRACE_METHOD(CAMCView, ScUpOneLevel);

    DECLARE_SC (sc, _T("CAMCView::ScUpOneLevel"));
    sc = E_FAIL;

    if (m_pTreeCtrl)
    {
        HTREEITEM htiParent = m_pTreeCtrl->GetParentItem (m_pTreeCtrl->GetSelectedItem());

        if (htiParent)
        {
            m_pTreeCtrl->SelectItem(htiParent);
            m_pTreeCtrl->EnsureVisible(htiParent);
            sc = S_OK;
        }
    }

    return (sc);
}


void CAMCView::OnViewMenu(CPoint point, LPCRECT prcExclude)
{
    TRACE_METHOD(CAMCView, OnViewMenu);

    OnContextMenuForListItem (INDEX_BACKGROUND, NULL, point,
                              MMC_CONTEXT_MENU_VIEW, prcExclude,
                              false /*bAllowDefaultItem*/);
}

void CAMCView::OnDrawClipboard()
{
    if (m_htiCut)
    {
        m_pTreeCtrl->SetItemState(m_htiCut, 0, TVIS_CUT);
    }
    else
    {
        m_pListCtrl->CutSelectedItems(FALSE);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnSettingChange
 *
 * PURPOSE: Handles WM_SETTINGCHANGE. Recalculates the layout. The
 *          result folder tab control needs this, for instance.
 *
 * PARAMETERS:
 *    UINT     uFlags :
 *    LPCTSTR  lpszSection :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    DeferRecalcLayout();
}

void CAMCView::OnUpdatePasteBtn()
{
    DECLARE_SC(sc, TEXT("CAMCView::OnUpdatePasteBtn"));

    HNODE  hNode  = NULL;
    LPARAM lvData = NULL;
    bool   bScope = FALSE;

    sc = ScGetFocusedItem(hNode, lvData, bScope);
    if (sc)
        return;

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(hNode, pNC, E_UNEXPECTED);
    if (sc)
        return;

    sc = pNC->UpdatePasteButton(hNode, bScope, lvData);
    if (sc)
        return;

    return;
}


void CAMCView::OnContextHelp()
{
    ScContextHelp();
}


SC CAMCView::ScContextHelp ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    m_fSnapinDisplayedHelp = false;
    SC sc = SendGenericNotify(NCLBK_CONTEXTHELP);

    // if snap-in hasn't called us to display a topic
    // and it has not handled the notification then
    // display MMC topic by default
    if (!m_fSnapinDisplayedHelp && (sc.ToHr() != S_OK))
        sc = ScHelpTopics ();

    if (sc)
        TraceError (_T("CAMCView::ScContextHelp"), sc);

    return (sc);
}


void CAMCView::OnSnapInHelp()
{
    SendGenericNotify(NCLBK_SNAPINHELP);
}

void CAMCView::OnSnapinAbout()
{
    DECLARE_SC(sc, TEXT("CAMCView::OnSnapinAbout"));

    HNODE hNode = GetSelectedNode();
    sc = ScCheckPointers((void*) hNode, E_UNEXPECTED);
    if (sc)
        return;

    INodeCallback *pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
        return;

    sc = pNC->ShowAboutInformation(hNode);
    if (sc)
        return;

    return;
}

void CAMCView::OnHelpTopics()
{
    ScHelpTopics();
}


SC CAMCView::ScHelpWorker (LPCTSTR pszHelpTopic)
{
    DECLARE_SC (sc, _T("CAMCView::ScShowSnapinHelpTopic"));
    USES_CONVERSION;

    /*
     * generation of the help collection might take a while, so display
     * a wait cursor
     */
    CWaitCursor wait;

    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);

    CAMCDoc* pdoc = GetDocument();

    // Point helpdoc info to current console file path
    if (pdoc->GetPathName().IsEmpty())
        pdoc->GetHelpDocInfo()->m_pszFileName = NULL;
    else
        pdoc->GetHelpDocInfo()->m_pszFileName = T2COLE(pdoc->GetPathName());

    /*
     * smart pointer for automatic deletion of the help file name
     */
    CCoTaskMemPtr<WCHAR> spszHelpFile;

    sc = pNC->Notify (0, NCLBK_GETHELPDOC,
                         reinterpret_cast<LPARAM>(pdoc->GetHelpDocInfo()),
                         reinterpret_cast<LPARAM>(&spszHelpFile));

    if (sc)
        return (sc);

    CAMCApp* pAMCApp = AMCGetApp();
    if (NULL == pAMCApp)
        return (sc = E_UNEXPECTED);

    sc = pAMCApp->ScShowHtmlHelp(W2T(spszHelpFile), (DWORD_PTR) pszHelpTopic);

    return (sc);
}

SC CAMCView::ScHelpTopics ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    return (ScHelpWorker (NULL));
}


SC CAMCView::ScShowSnapinHelpTopic (LPCTSTR pszHelpTopic)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    CString strTopicPath;

    // Add protocol prefix to topic string
    if (pszHelpTopic != NULL)
    {
        strTopicPath = _T("ms-its:");
        strTopicPath += pszHelpTopic;
    }

    SC sc = ScHelpWorker (strTopicPath);

    if (!sc)
        m_fSnapinDisplayedHelp = true;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::UpdateSnapInHelpMenus
//
//  Synopsis:    Update the following Help menu items
//                a) Help on <Snapin> (if snapin does not support HTML help)
//                b) About <Snapin>   (if snapin supports about object)
//
//  Arguments:   [pMenu]  - The help popup menu.
//
//--------------------------------------------------------------------
void CAMCView::UpdateSnapInHelpMenus(CMenu* pMenu)
{
    DECLARE_SC(sc, TEXT("CAMCView::UpdateSnapInHelpMenus"));
    sc = ScCheckPointers(pMenu);
    if (sc)
        return;

    ASSERT_VALID (this);

    HNODE hNode = GetSelectedNode();

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(hNode, pNC, E_UNEXPECTED);
    if (sc)
        goto Error;

    // Empty block for goto's
    {
        // First Make sure this is not a dummy substitute snapin.
        bool bDummySnapin = false;
        sc = pNC->IsDummySnapin (hNode, bDummySnapin);
        if (sc)
            goto Error;

        if (bDummySnapin)
            goto Error;

        // Get the snapin name for "Help on <SnapinName>" or "About <SnapinName>" menus
        CCoTaskMemPtr<WCHAR> spszName;
        CString strMenu;

        // Try to get name of snap-in for custom menu item
        bool bSnapinNameValid = false;
        sc = pNC->GetSnapinName(hNode, &spszName, bSnapinNameValid);
        if (sc)
            goto Error;

        ASSERT( spszName != NULL || bSnapinNameValid );

        USES_CONVERSION;

        // if snapin supports html help, don't give it it's own help command
        bool bStandardHelpExists = false;
        sc = pNC->DoesStandardSnapinHelpExist(hNode, bStandardHelpExists);
        if (sc)
            goto Error;

        if (bStandardHelpExists)
        {
            pMenu->DeleteMenu(ID_HELP_SNAPINHELP, MF_BYCOMMAND);
        }
        else
        {
            if (bSnapinNameValid)
            {
                // "Help on <SnapinName>"
                LoadString(strMenu, IDS_HELP_ON);
                AfxFormatString1(strMenu, IDS_HELP_ON, OLE2T(spszName));
            }
            else
            {
                // ""Help on Snap-in"
                LoadString(strMenu, IDS_HELP_ON_SNAPIN);
            }

            // Either add or modify the custom help menu item
            if (pMenu->GetMenuState(ID_HELP_SNAPINHELP, MF_BYCOMMAND) == (UINT)-1)
            {
                pMenu->InsertMenu(ID_HELP_HELPTOPICS, MF_BYCOMMAND|MF_ENABLED, ID_HELP_SNAPINHELP, strMenu);
            }
            else
            {
                pMenu->ModifyMenu(ID_HELP_SNAPINHELP, MF_BYCOMMAND|MF_ENABLED, ID_HELP_SNAPINHELP, strMenu);
            }
        }

        /* Now add the About <Snapin> menu*/
        bool bAboutExists = false;
        SC scNoTrace = pNC->DoesAboutExist(hNode, &bAboutExists);
        if ( (scNoTrace.IsError()) || (!bAboutExists) )
        {
            pMenu->DeleteMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND);
            return;
        }

        if (bSnapinNameValid)
        {
            // "About on <SnapinName>"
            AfxFormatString1(strMenu, IDS_ABOUT_ON, OLE2T(spszName));
        }
        else
        {
            // Cant get name just delete & return
            pMenu->DeleteMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND);
            return;
        }

        if (pMenu->GetMenuState(ID_SNAPIN_ABOUT, MF_BYCOMMAND) == (UINT)-1)
        {
            pMenu->InsertMenu(-1, MF_BYPOSITION|MF_ENABLED, ID_SNAPIN_ABOUT, strMenu);
        }
        else
        {
            pMenu->ModifyMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND|MF_ENABLED, ID_SNAPIN_ABOUT, strMenu);
        }
    }

Cleanup:
    return;
Error:
    pMenu->DeleteMenu(ID_HELP_SNAPINHELP, MF_BYCOMMAND);
    pMenu->DeleteMenu(ID_SNAPIN_ABOUT, MF_BYCOMMAND);
    goto Cleanup;
}

#ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)
/*
 * Displays errors from the list save function and cleans up the file if necessary
 */

void CAMCView::ListSaveErrorMes(EListSaveErrorType etype, HANDLE hfile, LPCTSTR lpFileName)
{
    CString strMessage;

    switch (etype)
    {

    case LSaveCantCreate:
        //"ERROR: Unable to create file."
        FormatString1 (strMessage, IDS_LISTSAVE_ER1, lpFileName);
        break;

    case LSaveCantWrite:
        // ERROR: Created file but encountered an error while writing to it
        FormatString1 (strMessage, IDS_LISTSAVE_ER2, lpFileName);
        break;

    case LSaveReadOnly:
        //"ERROR: File to be overwritten is read only."
        FormatString1 (strMessage, IDS_LISTSAVE_ER3, lpFileName);
        break;

    default:
        // Should not make it here
        ASSERT(0);
    }
    MMCMessageBox (strMessage);
}


// Saves a list and performs necessary dialog boxes and error checking
SC CAMCView::ScSaveList()
{
    DECLARE_SC(sc, _T("ScSaveList"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    sc = ScExportListWorker();
    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetExportListFile
//
//  Synopsis:    Get the filename, flags for save list.
//
//  Arguments:   [strFileName]       - File Name retval.
//               [bUnicode]          - Unicode or ansi.
//               [bTabDelimited]     - Tab or Comma delimited.
//               [bSelectedRowsOnly] - selected items only or all items.
//
//  Returns:     SC, S_FALSE if user cancels dialog.
//
//--------------------------------------------------------------------
SC CAMCView::ScGetExportListFile (CString& strFileName,
                                  bool& bUnicode,
                                  bool& bTabDelimited,
                                  bool& bSelectedRowsOnly)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetExportListFile"));

    CString strFilter;
    LoadString(strFilter, IDS_ANSI_FILE_TYPE);

#ifdef UNICODE
    {   // limit the lifetime of strUniFilter
        CString strUniFilter;
        LoadString(strUniFilter, IDS_UNICODE_FILE_TYPE);
        strFilter += strUniFilter;
    }
#endif

    // End of Filter char
    strFilter += "|";

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // See if there are any items selected else disable the "Selected items only" check-box.
    CListCtrl& ctlList = m_pListCtrl->GetListCtrl();
    int iItem = ctlList.GetNextItem( -1,LVNI_SELECTED);

    bool bSomeRowSelected = (-1 != iItem);

    // Create the dialog. File extensions are not localized.
    CSaveFileDialog dlgFile(false, _T("txt"), NULL,
                            OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLESIZING,
                            strFilter, bSomeRowSelected);

    // Display the dialog
    if (dlgFile.DoModal() == IDCANCEL)
       return S_FALSE; // S_FALSE if user cancels dialog.

    // Create a wait cursor and redraw the screen (necessary in saving big files)
    CWaitCursor wait;
    AfxGetMainWnd()->RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW );

    // Retrieve the filename
    strFileName = dlgFile.GetPathName();
    bSelectedRowsOnly = (dlgFile.Getflags() & SELECTED);

    switch (dlgFile.GetFileType())
    {
    case FILE_ANSI_TEXT:
        bTabDelimited = true; // Tab delimited.
        bUnicode = false;
        break;

    case FILE_ANSI_CSV:
        bTabDelimited = false; // Comma delimited.
        bUnicode = false;
        break;

#ifdef UNICODE
    case FILE_UNICODE_TEXT:
        bTabDelimited = true; // tab delimited.
        bUnicode = true;
        break;

    case FILE_UNICODE_CSV:
        bTabDelimited = false; // comma delimited.
        bUnicode = true;
        break;
#endif

    default:
        sc = E_UNEXPECTED;
        break;
    }


    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCreateExportListFile
//
//  Synopsis:    Create a file with given name & path. Write unicode marker if needed.
//
//  Arguments:   [strFileName]       - file to create.
//               [bUnicode]          - unicode or ansi file.
//               [bShowErrorDialogs] - Show error dialogs or not.
//               [hFile]             - Retval, handle to file.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCreateExportListFile(const CString& strFileName, bool bUnicode,
                                    bool  bShowErrorDialogs, HANDLE& hFile)
{
    DECLARE_SC(sc, _T("CAMCView::ScCreateExportListFile"));

    // Create a file according to specs
    hFile = CreateFile(strFileName, GENERIC_WRITE,
                       0, NULL, CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD dwAttrib = GetFileAttributes(strFileName);

    // If it did not fail and the file is read-only
    // Not required. Used to determine if the file being overwritten is read only and display appropriate message
    if ((dwAttrib != 0xFFFFFFFF) &&
        (dwAttrib & FILE_ATTRIBUTE_READONLY))
    {
        if (bShowErrorDialogs)
            ListSaveErrorMes(LSaveReadOnly, hFile, strFileName);

        return (sc = E_FAIL);
    }

    // Creation failed
    if (hFile == INVALID_HANDLE_VALUE)
    {
        if (bShowErrorDialogs)
            ListSaveErrorMes(LSaveCantCreate, NULL, strFileName);
        sc.FromWin32(::GetLastError());
        return sc;
    }

    /*
     * for Unicode files, write the Unicode prefix
     */
    if (bUnicode)
    {
        const WCHAR chPrefix = 0xFEFF;
        const DWORD cbToWrite = sizeof (chPrefix);
        DWORD       cbWritten;

        if (!WriteFile (hFile, &chPrefix, cbToWrite, &cbWritten, NULL) ||
            (cbToWrite != cbWritten))
        {
            CloseHandle(hFile);
            DeleteFile( strFileName );

            if (bShowErrorDialogs)
                ListSaveErrorMes(LSaveCantWrite, hFile, strFileName);

            return (sc = E_FAIL);
        }
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExportListWorker
//
//  Synopsis:    Prompt for a file name & write the ListView data to it.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExportListWorker()
{
    DECLARE_SC(sc, _T("CAMCView::ScExportListWorker"));

    CString strFileName;
    bool    bUnicode = false;
    bool    bTabDelimited = false;
    bool    bSelectedRowsOnly = false;

    sc = ScGetExportListFile(strFileName, bUnicode, bTabDelimited, bSelectedRowsOnly);

    if (sc.ToHr() == S_FALSE) // if user cancels dialog.
        return sc;

    sc = ScWriteExportListData(strFileName, bUnicode, bTabDelimited, bSelectedRowsOnly);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScWriteExportListData
//
//  Synopsis:    Write ListView data to given file.
//
//  Arguments:   [strFileName]       - File to create & write to.
//               [bUnicode]          - Unicode or ansi.
//               [bTabDelimited]     - Tab or Comma separated values.
//               [bSelectedRowsOnly] - like Selected rows only.
//               [bShowErrorDialogs] - Show error dialogs or not.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScWriteExportListData (const CString& strFileName,
                                    bool bUnicode,
                                    bool bTabDelimited,
                                    bool bSelectedRowsOnly,
                                    bool bShowErrorDialogs /*true*/)
{
    DECLARE_SC(sc, _T("CAMCView::ScWriteExportListData"));

    // Get number of rows and columns
    const int cRows = m_pListCtrl->GetItemCount();
    const int cCols = m_pListCtrl->GetColCount();

    // If there are no columns inserted then there cannot be any
    // items inserted into the listview. So error out.

    if (cCols <= 0)
        return (sc = E_UNEXPECTED);

    HANDLE hFile = NULL;
    sc = ScCreateExportListFile(strFileName, bUnicode, bShowErrorDialogs, hFile);
    if (sc)
    {
        if (NULL != hFile)
        {
            CloseHandle(hFile);
        }

        return sc;
    }

    // Retrieve the flags
    CString strEol( _T("\r\n") );

    LPCTSTR pszSeparator = _T("\t");
    if (!bTabDelimited)
        pszSeparator = _T(",");

    // Determine how many columns must be printed
    int      printcols   = 1;

    struct ColInfo
    {
        CString strColName;
        BOOL    bHidden;
    };

    ColInfo*  rgColumns = NULL;
    int*     pnColOrder  = NULL;

    // If it is LVS_REPORT, get the list of column names, order
    // and hidden or not flag.
    if ( (m_pListCtrl->GetViewMode() == LVS_REPORT) ||
         (m_pListCtrl->GetViewMode() == MMCLV_VIEWSTYLE_FILTERED) )
    {
        printcols = cCols;

        // Allocate mem to store col names, order, hidden states
        rgColumns = new ColInfo[printcols];
        if (! rgColumns)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        pnColOrder = new int[printcols];
        if (! pnColOrder)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        CHeaderCtrl* pHeader = m_pListCtrl->GetHeaderCtrl();
        sc = ScCheckPointers(pHeader, E_UNEXPECTED);
        if (sc)
            goto Error;

        // Get the order
        if (!Header_GetOrderArray(pHeader->GetSafeHwnd(), printcols, pnColOrder))
        {
            goto Error;
        }

        // Get the name and hidden state of cols
        for (int i = 0; i < printcols ; i++)
        {
            TCHAR   szColName[MAX_PATH * 2];
            HDITEM  hdItem;

            hdItem.mask       = HDI_TEXT | HDI_LPARAM;
            hdItem.pszText    = szColName;
            hdItem.cchTextMax = countof (szColName);

            if (pHeader->GetItem (i, &hdItem))
            {
                CHiddenColumnInfo hci (hdItem.lParam);

                rgColumns[i].strColName = hdItem.pszText;
                rgColumns[i].bHidden    = hci.fHidden;
            }
            else
            {
                goto Error;
            }
        }

       for (int i = 0; i < printcols ; i++)
       {
           // Print the column name according to the order

           if (rgColumns[pnColOrder[i]].bHidden)
               continue;

           if ( (!Write2File(hFile, rgColumns[pnColOrder[i]].strColName, bUnicode)) ||
               ((i < printcols - 1) && (!Write2File(hFile, pszSeparator, bUnicode))))
           {
               goto CantWriteError;
           }
       }

       // Write an EOL character if necessary
       if (!Write2File(hFile, strEol, bUnicode))
       {
          goto CantWriteError;
       }
    }

    {
        // Data for use in the writing stage
        CString strData;
        CListCtrl& ctlList = m_pListCtrl->GetListCtrl();

        // Set iNextType to 0 if all items will be saved or LVNI_SELECTED if only selected ones will be saved
        int iNextType = 0;
        if (bSelectedRowsOnly)
            iNextType = LVNI_SELECTED;

        // Find the first item in the list
        int iItem = ctlList.GetNextItem( -1,iNextType);

        // Iterate until there are no more items to save
        while (iItem != -1)
        {
            for(int ind2 = 0; ind2 < printcols ; ind2++)
            {
                if (rgColumns)
                {
                    // If not hidden get the item
                    if (rgColumns[pnColOrder[ind2]].bHidden)
                        continue;
                    else
                        strData = ctlList.GetItemText( iItem, pnColOrder[ind2]);
                }
                else
                    strData = ctlList.GetItemText( iItem, ind2);

                // Write the text and if necessary a comma
                // If either one fails, then delete the file and return
                if ( (!Write2File(hFile, strData, bUnicode)) ||
                    ((ind2 < printcols - 1) && (!Write2File(hFile, pszSeparator, bUnicode))))
                {
                    goto CantWriteError;

                }
            }

            // Write an EOL character if necessary
            if (!Write2File(hFile, strEol, bUnicode))
            {
                goto CantWriteError;
            }
            // Find the next item to save
            iItem = ctlList.GetNextItem( iItem, iNextType);
        }
    }

Cleanup:
    if (rgColumns)
        delete[] rgColumns;

    if (pnColOrder)
        delete[] pnColOrder;

    CloseHandle(hFile);
    return (sc);

CantWriteError:
    if (bShowErrorDialogs)
        ListSaveErrorMes(LSaveCantWrite, hFile, strFileName);

Error:
    DeleteFile( strFileName );
    goto Cleanup;
}

// Write out a string to the given file
// Used as a separate function to preserve memory
// Returns true if successful, false otherwise
bool CAMCView::Write2File(HANDLE hfile, LPCTSTR strwrite, BOOL fUnicode)
{
	DECLARE_SC(sc, TEXT("CAMCView::Write2File"));

	// parameter check;
	sc = ScCheckPointers( strwrite );
	if (sc)
		return false;

    // Initializes Macro
    USES_CONVERSION;

    // The number of bytes written
    DWORD cbWritten;
    DWORD cbToWrite;

    if (fUnicode)
    {
        // Convert the string to Unicode and write it to hfile
        LPCWSTR Ustring = T2CW( strwrite );
        cbToWrite = wcslen (Ustring) * sizeof (WCHAR);
        WriteFile(hfile, Ustring, cbToWrite, &cbWritten, NULL);
    }
    else
    {
        // Convert the string to ANSI and write it to hfile
        const unsigned char* Astring = (const unsigned char*) T2CA( strwrite );
        cbToWrite = _mbsnbcnt (Astring, _mbslen (Astring));
        WriteFile(hfile, Astring, cbToWrite, &cbWritten, NULL);
    }

    // Make sure that the correct number of bytes were written
    return (cbWritten == cbToWrite);
}
#endif  // IMPLEMENT_LIST_SAVE        See nodemgr.idl (t-dmarm)

// Refreshes all panes and HTML
void CAMCView::OnRefresh()
{
    HWND hwnd = ::GetFocus();

    if (IsVerbEnabled(MMC_VERB_REFRESH))
    {
        ScConsoleVerb(evRefresh);
    }
    else if (HasWebBrowser())
    {
        ScWebCommand(eWeb_Refresh);
    }
    ::SetFocus(hwnd);
}

void CAMCView::OnVerbAccelKey(UINT nID)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnVerbAccelKey"));

    switch (nID)
    {
    case ID_MMC_CUT:
        if (IsVerbEnabled(MMC_VERB_CUT))
            sc = ScConsoleVerb(evCut);
        break;

    case ID_MMC_COPY:
        if (IsVerbEnabled(MMC_VERB_COPY))
            sc = ScConsoleVerb(evCopy);
        break;

    case ID_MMC_PASTE:
        if (IsVerbEnabled(MMC_VERB_PASTE))
        {
            // Check if the dataobject in clipboard can be
            // pasted into the selected node.
            // Then only we send MMCN_PASTE notification to snapin.

            HNODE  hNode  = NULL;
            LPARAM lvData = NULL;
            bool   bScope = FALSE;
            sc = ScGetFocusedItem(hNode, lvData, bScope);
            if (sc)
                break;

            INodeCallback* pNC = GetNodeCallback();
            sc = ScCheckPointers(pNC, hNode, E_UNEXPECTED);
            if (sc)
                break;

            bool bPasteAllowed = false;
            sc = pNC->QueryPasteFromClipboard(hNode, bScope, lvData, bPasteAllowed);

            if (sc)
                break;

            if (bPasteAllowed)
                sc = ScConsoleVerb(evPaste);
        }
        break;

    case ID_MMC_PRINT:
        if (IsVerbEnabled(MMC_VERB_PRINT))
            sc = ScConsoleVerb(evPrint);
        break;

    case ID_MMC_RENAME:
        if (IsVerbEnabled(MMC_VERB_RENAME))
            sc = ScConsoleVerb(evRename);
        break;

    case ID_MMC_REFRESH:
        OnRefresh();
        break;

    default:
        ASSERT(FALSE);
    }

    if (sc)
        return;
}

//
// Handle accelerator keys shared by result and scope panes
//
BOOL CAMCView::OnSharedKeyDown(WORD wVKey)
{
    BOOL bReturn = TRUE;

    if (::GetKeyState(VK_CONTROL) < 0)
    {
        switch (wVKey)
        {
            case 'C':
            case 'c':
            case VK_INSERT:
                OnVerbAccelKey(ID_MMC_COPY);   // Ctrl-C, Ctrl-Insert
                break;

            case 'V':
            case 'v':
                OnVerbAccelKey(ID_MMC_PASTE);  // Ctrl-V
                break;

            case 'X':
            case 'x':
                OnVerbAccelKey(ID_MMC_CUT);    // Ctrl-X
                break;

            default:
                bReturn = FALSE;
         }
     }
     else if (::GetKeyState(VK_SHIFT) < 0)
     {
        switch (wVKey)
        {
            case VK_DELETE:
                OnVerbAccelKey(ID_MMC_CUT);    // Shift-Delete
                break;

            case VK_INSERT:
                OnVerbAccelKey(ID_MMC_PASTE);  // Shift -Insert
                break;

            default:
                bReturn = FALSE;
        }

    }
    else
    {
        switch (wVKey)
        {
            case VK_F2:
                OnVerbAccelKey(ID_MMC_RENAME);   // F2
                break;

            default:
                bReturn = FALSE;
        }
    }

    return bReturn;
}


//+-------------------------------------------------------------------
//
//  Member:      ScConsoleVerb
//
//  Synopsis:    Execute the Console verb.
//
//  Arguments:   [nVerb]  - The verb to be executed.
//
//  Note:        The verb is executed in the context of
//               currently focused item (scope or result).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScConsoleVerb (int nVerb)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT_VALID (this);

    DECLARE_SC (sc, _T("CAMCView::ScConsoleVerb"));

    HNODE  hNode = NULL;
    LPARAM lvData = 0;
    bool   bScope = false;

    // Get the focused item to process the console verb.
    sc = ScGetFocusedItem(hNode, lvData, bScope);
    if (sc)
        return sc;

    sc = ScProcessConsoleVerb(hNode, bScope, lvData, nVerb);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScProcessConsoleVerb
//
//  Synopsis:    Execute the Console verb with given context.
//
//  Arguments:   [hNode]  - The tree node context.
//               [bScope] - Scope or Result pane.
//               [lvData] - LPARAM of result item (if result pane has focus).
//               [nVerb]  - The verb to be executed.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScProcessConsoleVerb(HNODE hNode, bool bScope, LPARAM lvData, int nVerb)
{
    DECLARE_SC (sc, _T("CAMCView::ScProcessConsoleVerb"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT_VALID (this);

    // To maintain compatibility with MMC1.2 (This is init to LVERROR which
    // nodemgr process differently).
    if (bScope)
        lvData = 0;

    if (lvData == LVDATA_BACKGROUND)
    {
        switch (nVerb)
        {
        case evCut:
        case evCopy:
        case evDelete:
        case evRename:
            sc = E_UNEXPECTED;
            return sc;
        }
    }

    NCLBK_NOTIFY_TYPE nclbk = NCLBK_NONE;

    switch (nVerb)
    {
    case evCut:          nclbk = NCLBK_CUT;          break;
    case evCopy:         nclbk = NCLBK_COPY;         break;
    case evDelete:       nclbk = NCLBK_DELETE;       break;
    case evProperties:   nclbk = NCLBK_PROPERTIES;   break;
    case evPrint:        nclbk = NCLBK_PRINT;        break;

    case evPaste:
        {
            INodeCallback* pNC = GetNodeCallback();
            sc = ScCheckPointers(pNC, E_UNEXPECTED);
            if (sc)
                return sc;

            sc = pNC->Paste(hNode, bScope, lvData);

            if (sc)
                return sc;

            sc = ScPaste ();
            if (sc)
                return sc;

            break;
        }

    case evRefresh:
        // if web page on view, send it a refresh first
        if (HasWebBrowser())
            sc = ScWebCommand(eWeb_Refresh);
        if (sc)
            return sc;

        nclbk = NCLBK_REFRESH;
        break;

    case evRename:
        // Enable edit for the item.
        if (bScope == TRUE)
        {
            if (sc = ScCheckPointers(m_pTreeCtrl, E_UNEXPECTED))
                return sc;

            HTREEITEM hti = m_pTreeCtrl->GetSelectedItem();
            if (sc = ScCheckPointers(hti, E_UNEXPECTED))
                return sc;

            m_pTreeCtrl->EditLabel(hti);
        }
        else
        {
            if ( sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED))
                return sc;

            CAMCListView* pListView = m_pListCtrl->GetListViewPtr();
            if (NULL == pListView)
            {
                sc = E_UNEXPECTED;
                return sc;
            }

            int iItem = _GetLVSelectedItemData(&lvData);
            ASSERT(iItem >= 0);
            CListCtrl& listCtrl = pListView->GetListCtrl();
            listCtrl.EditLabel(iItem);
        }
        break;

    default:
        sc = E_UNEXPECTED;
        return sc;
    }

    if (nclbk != NCLBK_NONE)
    {
        // Ask the nodemgr to process the verb.
        INodeCallback* pNC = GetNodeCallback();
        if (pNC == NULL)
        {
            sc = E_UNEXPECTED;
            return sc;
        }

        sc = pNC->Notify(hNode, nclbk, bScope, lvData);
        if (sc)
            return sc;
    }

    if (nclbk == NCLBK_CUT)
        sc = ScCut (bScope ? m_pTreeCtrl->GetSelectedItem() : 0);

    if (sc)
        return sc;


    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScListViewSelectionActivate
//
//  Synopsis:    Only the list(/Web/OCX) or the tree can be "active" from the point
//               of view of selected items and MMCN_SELECT. This is not
//               the same as the MFC concept of "active view". There are a couple
//               of views that cannot be active in this sense, such as the taskpad
//               and tab views.
//               When the active view (according to this definition) changes, this
//               function is called. Thus, ScTreeViewSelectionActivate and
//               ScListViewSelectionActivate/ScSpecialResultpaneSelectionActivate
//               are always called in pairs when the activation changes, one to handle
//               deactivation, and one to handle activation.
//
//               Consider the following scenario
//               1) The tree view has (MFC/windows style) focus.
//               2) The user clicks on the taskpad view
//                   Result - selection activation does not change from the tree. All verbs
//                   still correspond to the selected tree item.
//               3) The user clicks on the folder view
//                   Result - once again, selection activation does not chang
//               4) The user clicks on one of the result views eg the list
//                   Result - ScTreeViewSelectionActivate(false) and ScListViewSelectionActivate(true)
//                   Thus verbs and the toolbar now correspond to the selected list item(s).
//               5) The user clicks on the taskpad view.
//                   Result - as in step 2, nothing happens
//               6) The user clicks on the result view
//                   Result - because the active view has not changed, nothing happens.
//
//  Arguments:   [bActivate] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScListViewSelectionActivate(bool bActivate)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScListViewSelectionActivate"));

    if (m_pListCtrl == NULL)
        return sc;

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
    {
        sc.TraceAndClear();
        return sc;
    }

    HNODE hNodeSel = GetSelectedNode();

    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));
    selInfo.m_bScope = FALSE;
    selInfo.m_bDueToFocusChange = TRUE;

#ifdef DBG
    if (bActivate == TRUE)
    {
        ASSERT(m_bProcessMultiSelectionChanges == false);
    }
#endif // DBG

    /*
     * The below block can never execute. When m_bProcessMultiSelectionChanges is
     * set to true messages are posted to handle multiselection changes. So the
     * handler OnProcessMultiSelectionChanges should have processed the message and the
     * m_bProcessMultiSelectionChanges should have been reset by now. If there is
     * some unknown way to make de-activate the listview before processing the message
     * then below block will be executed that will send de-select notification.
     *
     * The below block sends a de-select multi-select items.
     */
    if (m_bProcessMultiSelectionChanges)
    {
        ASSERT(false); // Would like to know when this block is hit.

        ASSERT(bActivate == false);

        m_bProcessMultiSelectionChanges = false;

        sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

        // Focus change so appropriately enable std-toolbar buttons
        // back, forward, export-list, up-one-level, show/hide-scope, help
        sc = ScUpdateStandardbarMMCButtons();
        if (sc)
            sc.TraceAndClear();
    }

    bool bSelect = bActivate;

    do
    {
        //
        // Multi select
        //

        int cSelected = m_pListCtrl->GetSelectedCount();

        if (cSelected > 1)
        {
            sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, bSelect, 0);
            if (sc)
                sc.TraceAndClear(); // ignore & continue;

            m_bLastSelWasMultiSel = bSelect;
            break;
        }


        //
        // Zero or Single select
        //

        if (cSelected == 0)
        {
            selInfo.m_bBackground = TRUE;
            selInfo.m_lCookie     = LVDATA_BACKGROUND;
        }
        else
        {
#include "pushwarn.h"
#pragma warning(disable: 4552)      // ">=" operator has no effect
            VERIFY(_GetLVSelectedItemData(&selInfo.m_lCookie) >= 0);
#include "popwarn.h"
        }

        ASSERT(cSelected >= 0);
        ASSERT(cSelected <= 1);
        sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, bSelect, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

    } while (0);

    return sc;
}


void CAMCView::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CView::OnShowWindow(bShow, nStatus);
}

int CAMCView::_GetLVItemData(LPARAM *plParam, UINT flags)
{
    HWND hwnd = m_pListCtrl->GetListViewHWND();
    int iItem = ::SendMessage(hwnd, LVM_GETNEXTITEM, (WPARAM) (int) -1,
                              MAKELPARAM(flags, 0));
    if (iItem >= 0)
    {
        if (IsVirtualList())
        {
            *plParam = iItem;
        }
        else
        {
            LV_ITEM lvi;
            ZeroMemory(&lvi, sizeof(lvi));
            lvi.iItem  = iItem;
            lvi.mask = LVIF_PARAM;

#include "pushwarn.h"
#pragma warning(disable: 4553)      // "==" operator has no effect
            VERIFY(::SendMessage(hwnd, LVM_GETITEM, 0, (LPARAM)&lvi) == TRUE);
#include "popwarn.h"

            *plParam = lvi.lParam;
        }
    }

    return iItem;
}

int CAMCView::_GetLVFocusedItemData(LPARAM *plParam)
{
    return (_GetLVItemData (plParam, LVNI_FOCUSED));
}

int CAMCView::_GetLVSelectedItemData(LPARAM *plParam)
{
    return (_GetLVItemData (plParam, LVNI_SELECTED));
}


void CAMCView::SetListViewMultiSelect(BOOL bMultiSelect)
{
    long lStyle = m_pListCtrl->GetListStyle();
    if (bMultiSelect == FALSE)
        lStyle |= LVS_SINGLESEL;
    else
        lStyle &= ~LVS_SINGLESEL;

    m_pListCtrl->SetListStyle(lStyle);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnItemDeselected
 *
 * PURPOSE: Tree observer method. Called when a tree item is deselected.
 *
 * PARAMETERS:
 *    HNODE  hNode : The node that was deselected.
 *
 * NOTE: This function can be merged with the next.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnItemDeselected(HNODE hNode)
{
    DECLARE_SC (sc, TEXT("CAMCView::ScOnItemDeselected"));

    DeSelectResultPane(hNode);

    if (!hNode)
        return sc;

    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));

    // Ask the SnapIn to cleanup any items it has inserted.
    INodeCallback* spNodeCallBack = GetNodeCallback();
    ASSERT(spNodeCallBack != NULL);

    selInfo.m_bScope = TRUE;
    selInfo.m_pView = NULL;

    Dbg(DEB_USER6, _T("T1. CAMCTreeView::OnDeSelectNode<1, 0>\n"));
    sc = ScNotifySelect (spNodeCallBack, hNode, false /*fMultiSelect*/, false, &selInfo);
    if (sc)
        sc.TraceAndClear(); // ignore & continue;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::DeSelectResultPane
 *
 * PURPOSE: Deselects the result pane and sets the view type to invalid.
 *
 * PARAMETERS:
 *    HNODE  hNodeSel :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::DeSelectResultPane(HNODE hNodeSel)
{
    DECLARE_SC(sc, TEXT("CAMCView::DeSelectResultPane"));

    if (m_spTaskPadHost.GetInterfacePtr() != NULL)
    {
        CTaskPadHost *pTaskPadHost = dynamic_cast<CTaskPadHost *>(m_spTaskPadHost.GetInterfacePtr());
        m_spTaskPadHost = NULL;
    }

    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);

    if (hNodeSel == 0)
        return;

    // If there was no list view being displayed return.
    if (HasListOrListPad())
    {
        // if we were in ListPad-mode, undo that.
        if (m_pListCtrl->IsListPad())
        {
            sc = m_pListCtrl->ScAttachToListPad (NULL, NULL);
            if(sc)
                sc.TraceAndClear(); //ignore
        }

        // If we are in edit mode cancel it.
        m_pListCtrl->GetListCtrl().EditLabel(-1);

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = FALSE;

        /*
         * The below block can never execute. When m_bProcessMultiSelectionChanges is
         * set to true messages are posted to handle multiselection changes. So the
         * handler OnProcessMultiSelectionChanges should have processed the message and the
         * m_bProcessMultiSelectionChanges should have been reset by now. If there is
         * some unknown way to make select different node (to deselect result pane)
         * before processing the message then below block will be executed that will
         * send de-select notification.
         *
         * The below block sends a de-select multi-select items.
         */
        if (m_bProcessMultiSelectionChanges)
        {
            ASSERT(false); // Would like to know when this block is hit.

            m_bProcessMultiSelectionChanges = false;

            sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
            if (sc)
                sc.TraceAndClear(); // ignore & continue;
        }
        else
        {
            UINT cSel = m_pListCtrl->GetSelectedCount();
            if (cSel == 1)
            {
                if (cSel)
                {
                    int iItem = _GetLVSelectedItemData(&selInfo.m_lCookie);
                    ASSERT(iItem != -1);
                    sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, false, &selInfo);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;
                }
            }
            else if (cSel > 1)
            {
                sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
                if (sc)
                    sc.TraceAndClear(); // ignore & continue;

                m_bLastSelWasMultiSel = false;
            }
        }
    }
    else
    {
        // If it is OCX or Web send de-select notifications.
        sc = ScSpecialResultpaneSelectionActivate(FALSE);
    }
}


LRESULT CAMCView::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
       // NATHAN
        case WM_NOTIFYFORMAT:
        {
            int id = ::GetDlgCtrlID ((HWND)wParam);
            //if (m_pTreeCtrl == NULL || ((HWND)wParam != m_pTreeCtrl->m_hWnd))
            if (id == IDC_ListView)
                 return NFR_UNICODE;
        }
        break;
#ifdef DBG
        case WM_KEYUP:
        {
            switch (wParam)
            {
            case VK_SHIFT:
            case VK_CONTROL:
                // We removed some code that will work if m_bProcessMultiSelectionChanges
                // is true. I dont see any way the bool being true. Still let us have below
                // assert. If this gets fired then we should call OnProcessMultiSelectionChanges.
                ASSERT(m_bProcessMultiSelectionChanges == false);
                break;
            }
            break;
        }
        break;
#endif
    }

    return CView::WindowProc(message, wParam, lParam);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ChangePane
 *
 * Moves the activation from pane to pane.  The (forward) tab order is
 *
 *      Scope pane (either tree or favorites)
 *      Result pane
 *      Task view (if visible)
 *--------------------------------------------------------------------------*/


class CTabOrderEntry
{
public:
    CView* const        m_pView;
    const bool          m_bValid; // is this entry valid

    CTabOrderEntry(CView *pView)
        :   m_pView  (pView),
            m_bValid ((pView != NULL) && IsWindowVisible (pView->m_hWnd))
    {}
};


void CAMCView::ChangePane(AMCNavDir eDir)
{
    ASSERT_VALID (this);

    CFrameWnd* pFrame      = GetParentFrame();
    CView*     pActiveView = pFrame->GetActiveView();
    HWND       hWndActive  = ::GetFocus();


    CTabOrderEntry rgOrderEntry[] =
    {
        CTabOrderEntry(GetPaneView(ePane_ScopeTree)),   // tree has focus
        CTabOrderEntry(GetPaneView(ePane_Results)),     // results has focus - note the value of INDEX_RESULTS_PANE below.
        CTabOrderEntry(m_pViewExtensionCtrl),           // view extension web page has focus
        CTabOrderEntry(m_pResultFolderTabView),         // result tab control has focus
    };

    /*
     * this is the index of the result pane entry in rgOrderEntry,
     * used for default focus placement if something unexpected happens
     */
    const int INDEX_RESULTS_PANE = 1;
    ASSERT (rgOrderEntry[INDEX_RESULTS_PANE].m_pView == GetPaneView(ePane_Results));

    // Get the navigator if one exists. If so, use it and bail.
    CAMCNavigator* pNav = dynamic_cast<CAMCNavigator*>(pActiveView);
    if (pNav && pNav->ChangePane(eDir))
        return;

    int cEntries = (sizeof(rgOrderEntry) / sizeof(rgOrderEntry[0]));

    // get the currently active entry.
    for(int i = 0; i< cEntries; i++)
    {
        if( (rgOrderEntry[i].m_pView  == pActiveView) )
            break;
    }

    ASSERT(i < cEntries);
    if(i>= cEntries)
    {
        // if we don't know where we are, a bit of defensive coding puts the focus back
        // on the results pane, ie into a known state.
        i = INDEX_RESULTS_PANE;
    }

    int iPrev = i;

    // at this point we've found the right entry.
    int increment   =  (eDir==AMCNAV_PREV) ? -1 : 1;
    int sanityCount = 0;
    while(true)
    {
        i = (i+increment+cEntries) % cEntries;
        if(rgOrderEntry[i].m_bValid)
            break;

        sanityCount++;
        if(sanityCount == cEntries)
        {
            ASSERT(0 && "Something's seriously messed up!!");
            return;
        }
    }

    // update the active view
    if (i != iPrev)
        pFrame->SetActiveView(rgOrderEntry[i].m_pView);
    else
    {
        // if view retains focus and has a navigator,
        // tell navigator to take the focus
        if (pNav)
            pNav->TakeFocus(eDir);
    }

    // if there is a special focus handler, call it.
    CFocusHandler *pFocusHandler = dynamic_cast<CFocusHandler *>(rgOrderEntry[i].m_pView);
    if(pFocusHandler != NULL)
    {
        pFocusHandler->OnKeyboardFocus (LVIS_FOCUSED | LVIS_SELECTED,
                                        LVIS_FOCUSED | LVIS_SELECTED);
    }

}


void CAMCView::OnNextPane()
{
    ChangePane(AMCNAV_NEXT);
}

void CAMCView::OnPrevPane()
{
    ChangePane(AMCNAV_PREV);
}

void CAMCView::OnUpdateNextPane(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}

void CAMCView::OnUpdatePrevPane(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


void RestrictPointToWindow (CWnd* pwnd, CPoint* ppt)
{
    CRect rectWnd;

    pwnd->GetClientRect (rectWnd);

    if (ppt->x < rectWnd.left)
        ppt->x = rectWnd.left;
    else if (ppt->x > rectWnd.right)
        ppt->x = rectWnd.right;

    if (ppt->y < rectWnd.top)
        ppt->y = rectWnd.top;
    else if (ppt->y > rectWnd.bottom)
        ppt->y = rectWnd.bottom;
}


void CAMCView::OnShiftF10()
{
    CRect rect;
    CWnd* pwndFocus = GetFocus();
    CListCtrl& lc = m_pListCtrl->GetListCtrl();

    ASSERT_VALID (this);

    if (pwndFocus == &lc)
    {
        int iItem = lc.GetNextItem (-1, LVNI_SELECTED);
        CPoint pt = 0;

        if (iItem != -1)
        {
            VERIFY (lc.GetItemRect (iItem, rect, LVIR_ICON));
            pt = rect.CenterPoint ();
        }
        else
        {
            CHeaderCtrl* pHeader = m_pListCtrl->GetHeaderCtrl();

            if (pHeader != NULL && pHeader->IsWindowVisible())
            {
                pHeader->GetClientRect(&rect);
                pt.y = rect.Height();
                ASSERT (pt.y >= 0);
            }
        }

        /*
         * make sure the context menu doesn't show up outside the window
         */
        RestrictPointToWindow (&lc, &pt);

        m_pListCtrl->GetListViewPtr()->ClientToScreen(&pt);
        OnListContextMenu(pt);
    }

    else if (pwndFocus == m_pTreeCtrl)
    {
        HTREEITEM hTreeItem = m_pTreeCtrl->GetSelectedItem();
        if (hTreeItem == NULL)
            return;

        m_pTreeCtrl->GetItemRect (hTreeItem, rect, TRUE);

        CPoint ptClient (rect.left, rect.bottom-1);

        /*
         * make sure the context menu doesn't show up outside the window
         */
        RestrictPointToWindow (m_pTreeCtrl, &ptClient);

        CPoint ptScreen = ptClient;

        m_pTreeCtrl->ClientToScreen(&ptScreen);
        OnTreeContextMenu(ptScreen, ptClient, hTreeItem);
    }
}

void CAMCView::OnUpdateShiftF10(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


BOOL CAMCView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    if (nHitTest == HTCLIENT && pWnd == this && !IsTracking())
    {
        CPoint pt (GetMessagePos());
        ScreenToClient (&pt);

        if (m_rectVSplitter.PtInRect (pt))
        {
            SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZEWE));
            return TRUE;
        }
    }


    return CWnd::OnSetCursor(pWnd, nHitTest, message);
}



SC CAMCView::ScCut (HTREEITEM htiCut)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScCut"));

    CMainFrame* pMain = AMCGetMainWnd();
    sc = ScCheckPointers (pMain, E_UNEXPECTED);
    if (sc)
        return (sc);

    pMain->SetWindowToNotifyCBChange(m_hWnd);

    if (htiCut)
        m_pTreeCtrl->SetItemState (htiCut, TVIS_CUT, TVIS_CUT);
    else
        m_pListCtrl->CutSelectedItems (TRUE);

    m_htiCut = htiCut;

    return (S_OK);
}

SC CAMCView::ScPaste ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScPaste"));

    if (!m_htiCut)
        m_pListCtrl->CutSelectedItems(FALSE);

    CMainFrame* pMain = AMCGetMainWnd();
    sc = ScCheckPointers (pMain, E_UNEXPECTED);
    if (sc)
        return (sc);

    pMain->SetWindowToNotifyCBChange(NULL);

    return (S_OK);
}


HRESULT CAMCView::SendGenericNotify(NCLBK_NOTIFY_TYPE nclbk)
{
    BOOL bScope = TRUE;
    MMC_COOKIE lCookie = 0;
    int iItem = -1;

    ASSERT_VALID (this);

    if (m_pListCtrl && m_pListCtrl->GetListViewHWND() == ::GetFocus())
    {
        iItem = _GetLVSelectedItemData(&lCookie);
        if (iItem != -1)
            bScope = FALSE;
    }

    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);
    if (pNC == NULL)
        return E_FAIL;

    HNODE hNodeSel = GetSelectedNode();
    ASSERT(hNodeSel != NULL);
    if (hNodeSel == NULL)
        return E_FAIL;

    // selection notifications should use ScNotifySelect()
    ASSERT ((nclbk != NCLBK_SELECT) && (nclbk != NCLBK_MULTI_SELECT));

    return pNC->Notify(hNodeSel, nclbk, bScope, lCookie);
}

void CAMCView::SaveStartingSelectedNode()
{
    m_htiStartingSelectedNode = m_pTreeCtrl->GetSelectedItem();
}

bool CAMCView::HasNodeSelChanged()
{
    return (m_pTreeCtrl->GetSelectedItem() != m_htiStartingSelectedNode);
}


//+---------------------------------------------------------------------------
//
//  Function:   OnSysKeyDown
//
//  Synopsis:   Handles WM_SYSKEYDOWN message.
//              CAMCTreeView::OnSysKeyDown handles the Tree view so
//              here we handle only the list view (or Result pane)
//
//  Returns:    none
//
//+---------------------------------------------------------------------------
void CAMCView::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
        case VK_LEFT:
            ScWebCommand(eWeb_Back);
            break;

        case VK_RIGHT:
            ScWebCommand(eWeb_Forward);
            break;
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnAppCommand
 *
 * WM_APPCOMMAND handler for CAMCView.  This is used to handle to forward
 * and backward buttons on the IntelliMouse Explorer and the Microsoft
 * Natural Keyboards
 *--------------------------------------------------------------------------*/

LRESULT CAMCView::OnAppCommand(WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC (sc, _T("CAMCView::OnAppCommand"));

    switch (GET_APPCOMMAND_LPARAM (lParam))
    {
        case APPCOMMAND_BROWSER_BACKWARD:
            sc = ScWebCommand (eWeb_Back);
            if (sc)
                break;

            return (TRUE);      // handled here

        case APPCOMMAND_BROWSER_FORWARD:
            sc = ScWebCommand (eWeb_Forward);
            if (sc)
                break;

            return (TRUE);      // handled here

        case APPCOMMAND_BROWSER_REFRESH:
            OnRefresh ();
            return (TRUE);      // handled here
    }

    return (Default());
}


void CAMCView::OnPaletteChanged(CWnd* pwndFocus)
{
    // if displaying a web page, forward the palette change to the shell
    if (HasWebBrowser() && m_pWebViewCtrl != NULL)
    {
        if (m_pWebViewCtrl->m_hWnd != NULL)
        {
            HWND hwndShell = ::GetWindow(m_pWebViewCtrl->m_hWnd, GW_CHILD);

            if (hwndShell != NULL)
                ::SendMessage(hwndShell, WM_PALETTECHANGED, (WPARAM)pwndFocus->m_hWnd, (LPARAM)0);
        }
    }
}


BOOL CAMCView::OnQueryNewPalette()
{
    // if displaying a web page, forward the palette query to the shell
    if (HasWebBrowser() && m_pWebViewCtrl != NULL)
    {
        if (m_pWebViewCtrl->m_hWnd != NULL)
        {
            HWND hwndShell = ::GetWindow(m_pWebViewCtrl->m_hWnd, GW_CHILD);

            if (hwndShell != NULL)
                return ::SendMessage(hwndShell, WM_QUERYNEWPALETTE, (WPARAM)0, (LPARAM)0);
        }
    }

    return 0;
}


BOOL CAMCView::OwnsResultList(HTREEITEM hti)
{
    if (hti == NULL)
        return (false);

    // if result list is active
    if (HasListOrListPad())
    {
        // Get selected node and query node
        HNODE hnodeSelected = GetSelectedNode();
        HNODE hnode = m_pTreeCtrl ? m_pTreeCtrl->GetItemNode(hti) : NULL;

        if (hnodeSelected && hnode)
        {
            INodeCallback* pNC = GetNodeCallback();
            ASSERT(pNC != NULL);

            // See if the selected node uses the query node as a target
            //  S_OK    - yes
            //  S_FALSE - uses a different target node
            //  E_FAIL  - doesn't use a target node
            HRESULT hr = pNC->IsTargetNodeOf(hnodeSelected, hnode);
            if (hr == S_OK)
                return TRUE;
            else if (hr == S_FALSE)
                return FALSE;
            else
                return (hnodeSelected == hnode);
        }
    }

    return FALSE;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnSysColorChange
 *
 * WM_SYSCOLORCHANGE handler for CAMCView.
 *--------------------------------------------------------------------------*/

void CAMCView::OnSysColorChange()
{
    CView::OnSysColorChange();

    /*
     * the list control isn't a window but rather a wrapper on a window,
     * so we need to manually forward on the WM_SYSCOLORCHANGE
     */
    m_pListCtrl->OnSysColorChange();
}


/*+-------------------------------------------------------------------------*
 * TrackerCallback function
 *
 * Called by CViewTracker when tracking of splitter bar is completed. This
 * function applies the changes if the AcceptChange flag is set.
 *--------------------------------------------------------------------------*/

void CALLBACK TrackerCallback(
    TRACKER_INFO*   pInfo,
    bool            bAcceptChange,
    bool            bSyncLayout)
{
    DECLARE_SC (sc, _T("TrackerCallback"));

    if (bAcceptChange)
    {
        CAMCView* pView = dynamic_cast<CAMCView*>(pInfo->pView);
        sc = ScCheckPointers (pView, E_UNEXPECTED);
        if (sc)
            return;

        // Set new width and recompute layout
        pView->m_PaneInfo[CConsoleView::ePane_ScopeTree].cx = pInfo->rectTracker.left;
        pView->SetDirty();

        if (bSyncLayout)
        {
            Trace (tagSplitterTracking, _T("Synchronous layout"));
            pView->RecalcLayout();
            pView->UpdateWindow();
        }
        else
        {
            Trace (tagSplitterTracking, _T("Deferred layout"));
            pView->DeferRecalcLayout();
        }
    }
}


/*+-------------------------------------------------------------------------*
 * PtInWindow
 *
 * Test if point is in a window (pt is in screen coordinates)
 *--------------------------------------------------------------------------*/

BOOL PtInWindow(CWnd* pWnd, CPoint pt)
{
    if (!pWnd->IsWindowVisible())
        return FALSE;

    CRect rect;
    pWnd->GetWindowRect(&rect);

    return rect.PtInRect(pt);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScJiggleListViewFocus
 *
 * Bug 345402:  Make sure the focus rect is on the list control (if it
 * actually has the focus) to wake up any accessibility tools that might
 * be watching for input and focus changes.
 *
 * We post a message here rather than doing it synchronously so we can
 * allow any other processing in the list (like sorting) to happen
 * before we put the focus on the 1st item.  If we didn't wait until after
 * the sort, the item we put the focus on might not be the first item
 * in the list.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScJiggleListViewFocus ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    PostMessage (m_nJiggleListViewFocusMsg);

    return (S_OK);
}


LRESULT CAMCView::OnJiggleListViewFocus (WPARAM, LPARAM)
{
    CAMCListView* pListView = m_pListCtrl->GetListViewPtr();

    /*
     * If the focus is on the list control, make sure that at least one item
     * has the focus rect.  Doing this will wake up any accessibility tools
     * that might be watching (Bug 345402).
     */
    if ((GetFocusedPane() == ePane_Results) &&
        (GetResultView()  == pListView))
    {
        pListView->OnKeyboardFocus (LVIS_FOCUSED, LVIS_FOCUSED);
    }

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnDeferRecalcLayout
 *
 * CAMCView::m_nDeferRecalcLayoutMsg registered message handler for CAMCView.
 *
 * Parameters:
 *     bDoArrange - if non-zero need to call Arrange on list-view so that
 *                  common-control can layout items properly.
 *
 *--------------------------------------------------------------------------*/

LRESULT CAMCView::OnDeferRecalcLayout (WPARAM bDoArrange, LPARAM)
{
    Trace (tagLayout, _T("CAMCView::OnDeferRecalcLayout"));
    RecalcLayout();

    if (bDoArrange && m_pListCtrl)
    {
        int  nViewMode = m_pListCtrl->GetViewMode();

        // Arrange is only for large & small icon modes.
        if ( (nViewMode == MMCLV_VIEWSTYLE_ICON) ||
             (nViewMode == MMCLV_VIEWSTYLE_SMALLICON) )
            m_pListCtrl->Arrange(LVA_DEFAULT);
    }

    return (0);
}


//############################################################################
//############################################################################
//
//  Implementation of class CViewTemplate
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CViewTemplateList::Persist
 *
 * PURPOSE: Used when loading XML. Persist enough information to create a view
 *          The rest of view peristence is dome by CAMCView
 *
 * PARAMETERS:
 *    CPersistor& persistor - persistor to load from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CViewTemplateList::Persist(CPersistor& persistor)
{
    // the view should be stored instead
    ASSERT (persistor.IsLoading());
    // delegate to the base class
    XMLListCollectionBase::Persist(persistor);
}

/***************************************************************************\
 *
 * METHOD:  CViewTemplateList::OnNewElement
 *
 * PURPOSE: Called by XMLListCollectionBase to request persisting of new element
 *          Each new element is created and persisted in this function.
 *
 * PARAMETERS:
 *    CPersistor& persistor - persisto from which the element should be loaded
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CViewTemplateList::OnNewElement(CPersistor& persistor)
{
    CBookmark bm;
    int       iViewId = -1;
    // load information byte for new view
    CPersistor persistorView(persistor, CAMCView::_GetXMLType());
    persistorView.Persist(bm, XML_NAME_ROOT_NODE);
    persistorView.PersistAttribute(XML_ATTR_VIEW_ID, iViewId);

    // store information to the list
    m_ViewsList.push_back(ViewTempl_Type(iViewId, ViewTemplB_Type(bm, persistorView)));
}

//+-------------------------------------------------------------------
//
//  Member:     ScUpdateStandardbarMMCButtons
//
//  Synopsis:   Appropriately enable/disable std-toolbar buttons
//              that are owned by MMC (not verb buttons that snapins own) like
//              back, forward, export-list, up-one-level, show/hide-scope, help.
//
//  Arguments:  None.
//
//--------------------------------------------------------------------
SC CAMCView::ScUpdateStandardbarMMCButtons()
{
    DECLARE_SC (sc, _T("CAMCView::ScUpdateStandardbarMMCButtons"));

    // Get the standard toolbar and change the states.
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    if (NULL == pStdToolbar)
        return (sc = E_UNEXPECTED);

    CAMCDoc *pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return sc;

    // If view is not customizable then hide the "Show/Hide scope tree" button.
    sc = pStdToolbar->ScEnableScopePaneBtn(IsScopePaneAllowed() && pDoc->AllowViewCustomization());

    if (sc)
        sc.TraceAndClear();

    sc = pStdToolbar->ScEnableContextHelpBtn(true);
    if (sc)
        sc.TraceAndClear();


    sc = pStdToolbar->ScEnableExportList(GetListSize() > 0 /*Enable only if LV has items*/);
    if (sc)
        sc.TraceAndClear();


    // Enable/Disable Up-One Level button.
    BOOL bEnableUpOneLevel = !m_pTreeCtrl->IsRootItemSel();
    sc = pStdToolbar->ScEnableUpOneLevel(bEnableUpOneLevel);
    if (sc)
        sc.TraceAndClear();

    // Now update history related buttons.
    sc = ScCheckPointers(m_pHistoryList, E_UNEXPECTED);
    if (sc)
        return sc;

    m_pHistoryList->MaintainWebBar();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScUpdateMMCMenus
//
//  Synopsis:    Show or Hide MMC menus depending on if they are allowed
//               or not. Should do this only if our view owns the menus
//               that is we are the active view.  (Action/View/Favs)
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScUpdateMMCMenus ()
{
    DECLARE_SC(sc, _T("CAMCView::ScUpdateMMCMenus"));

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    if (this != pMainFrame->GetActiveAMCView())
        return (sc = S_OK); // we are not active view so it is ok.

    // We are active view so tell mainframe to update the menus.
    sc = pMainFrame->ScShowMMCMenus(m_ViewData.IsStandardMenusAllowed());
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCreateToolbarObjects
//
//  Synopsis:    Create the CAMCViewToolbars that manages all toolbar data
//               for this view & CStandardToolbar objects.
//
//  Arguments:   None.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCreateToolbarObjects ()
{
    DECLARE_SC(sc, _T("CAMCView::ScCreateToolbarObjects"));

    CMainFrame *pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    // Create the toolbars for this view.
    CMMCToolBar *pMainToolbar = pMainFrame->GetMainToolbar();
    sc = ScCheckPointers(pMainToolbar, E_OUTOFMEMORY);
    if (sc)
        return sc;

    m_spAMCViewToolbars.CreateInstance();
    sc = ScCheckPointers(m_spAMCViewToolbars, E_FAIL);
    if (sc)
        return sc;

    m_ViewData.SetAMCViewToolbarsMgr(m_spAMCViewToolbars);
    sc = m_spAMCViewToolbars->ScInit(pMainToolbar, this);
    if (sc)
        return sc;

    // This CAMCViewToolbars is interested in view activation/de-activation/destruction events.
    AddObserver( (CAMCViewObserver&) (*m_spAMCViewToolbars) );

    // Main toolbar UI is interested in the active CAMCViewToolbars.
    m_spAMCViewToolbars->AddObserver( *static_cast<CAMCViewToolbarsObserver *>(pMainToolbar) );

    // MMC application is interested in the toolbar event, since it needs to inform the script
    CAMCApp *pCAMCApp = AMCGetApp();
    if ( pCAMCApp )
         m_spAMCViewToolbars->AddObserver( *static_cast<CAMCViewToolbarsObserver *>(pCAMCApp) );

    // Create standard toolbar.
    m_spStandardToolbar = std::auto_ptr<CStandardToolbar>(new CStandardToolbar());
    sc = ScCheckPointers(m_spStandardToolbar.get(), E_OUTOFMEMORY);
    if (sc)
        return sc;

    m_ViewData.SetStdVerbButtons(m_spStandardToolbar.get());

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * class CMMCViewFrame
 *
 *
 * PURPOSE: The COM 0bject that exposes the Frame interface off the View object.
 *
 *+-------------------------------------------------------------------------*/
class CMMCViewFrame :
    public CMMCIDispatchImpl<Frame>,
    public CTiedComObject<CAMCView>
{
    typedef CAMCView         CMyTiedObject;
    typedef CMMCViewFrame    ThisClass;

public:
    BEGIN_MMC_COM_MAP(ThisClass)
    END_MMC_COM_MAP()

    //Frame interface
public:
    MMC_METHOD0( Maximize );
    MMC_METHOD0( Minimize );
    MMC_METHOD0( Restore );

    MMC_METHOD1( get_Left, LPINT );
    MMC_METHOD1( put_Left, INT );

    MMC_METHOD1( get_Right, LPINT );
    MMC_METHOD1( put_Right, INT );

    MMC_METHOD1( get_Top, LPINT );
    MMC_METHOD1( put_Top, INT );

    MMC_METHOD1( get_Bottom, LPINT );
    MMC_METHOD1( put_Bottom, INT );
};


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetFrame
 *
 * PURPOSE: Returns a pointer to the COM object that implements the
 *          Frame interface.
 *
 * PARAMETERS:
 *    Frame **ppFrame :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_Frame(Frame **ppFrame)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetFrame") );

    if(!ppFrame)
    {
        sc = E_POINTER;
        return sc;
    }

    // init out parameter
    *ppFrame = NULL;

    // create a CMMCApplicationFrame if not already done so.
    sc = CTiedComObjectCreator<CMMCViewFrame>::ScCreateAndConnect(*this, m_spFrame);
    if(sc)
        return sc;

    if(m_spFrame == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spFrame->AddRef();
    *ppFrame = m_spFrame;

    return sc;
}


/***************************************************************************\
|           Frame interface                                                 |
\***************************************************************************/

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScMaximize
 *
 * PURPOSE: Maximizes frame window of the view
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScMaximize ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScMaximize"));

    CChildFrame *pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    pFrame->ShowWindow(SW_MAXIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScMinimize
 *
 * PURPOSE: Minimizes frame window of the view
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScMinimize ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScMinimize"));

    CChildFrame *pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    pFrame->ShowWindow(SW_MINIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScRestore
 *
 * PURPOSE: Restores frame window of the view
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScRestore ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScRestore"));

    CChildFrame *pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    pFrame->ShowWindow(SW_RESTORE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetFrameCoord
 *
 * PURPOSE: Helper method. Returns specified coordinate of the parent frame
 *
 * PARAMETERS:
 *    LPINT pCoord   - storage for return value
 *    coord_t eCoord - which coordinate to return (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScGetFrameCoord ( LPINT pCoord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetFrameCoord"));

    // get & check frame ptr
    CChildFrame *pFrame = GetParentFrame();
    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    CWnd *pParent = pFrame->GetParent();
        sc = ScCheckPointers (pParent, E_FAIL);
        if (sc)
                return (sc);

    // get coordinates of frame window relative to its parent
    CWindowRect rcFrame (pFrame);
    pParent->ScreenToClient(rcFrame);

    // assign to result
        sc = ScGetRectCoord (rcFrame, pCoord, eCoord);
        if (sc)
                return (sc);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetFrameCoord
 *
 * PURPOSE: Helper method. Sets specified coordinate of the parent frame
 *
 * PARAMETERS:
 *    INT coord      - new value to set
 *    coord_t eCoord - which coordinate to modify (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScSetFrameCoord ( INT coord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetFrameCoord"));

    CChildFrame *pFrame = GetParentFrame();
    sc = ScCheckPointers(pFrame, E_FAIL);
    if (sc)
        return sc;

    CWnd *pParent = pFrame->GetParent();
        sc = ScCheckPointers (pParent, E_FAIL);
        if (sc)
                return (sc);

    // get coordinates of frame window relative to its parent
    CWindowRect rcFrame (pFrame);
    pParent->ScreenToClient(rcFrame);

        // change the rectangle's specified coordinate
        sc = ScSetRectCoord (rcFrame, coord, eCoord);
        if (sc)
                return (sc);

    // move the window
    pFrame->MoveWindow (rcFrame);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetRectCoord
 *
 * PURPOSE: Helper method. Returns specified coordinate of the given rectangle
 *
 * PARAMETERS:
 *    const RECT& rect - rectangle to query
 *    LPINT pCoord     - storage for return value
 *    coord_t eCoord   - which coordinate to return (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScGetRectCoord ( const RECT& rect, LPINT pCoord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetRectCoord"));

    // check parameters
    sc = ScCheckPointers(pCoord);
    if (sc)
        return sc;

    // assign to result
    switch (eCoord)
    {
        case LEFT:      *pCoord = rect.left;    break;
        case RIGHT:     *pCoord = rect.right;   break;
        case TOP:       *pCoord = rect.top;     break;
        case BOTTOM:    *pCoord = rect.bottom;  break;

        default:
            *pCoord = 0;
            sc = E_INVALIDARG;
            break;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetRectCoord
 *
 * PURPOSE: Helper method. Sets specified coordinate of the given rectangle
 *
 * PARAMETERS:
 *        RECT& rect     - rectangle to modify
 *    INT coord      - new value to set
 *    coord_t eCoord - which coordinate to modify (LEFT, TOP, etc)
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScSetRectCoord ( RECT& rect, INT coord, coord_t eCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetRectCoord"));

    // assign coordinate
    switch (eCoord)
    {
        case LEFT:      rect.left   = coord;    break;
        case RIGHT:     rect.right  = coord;    break;
        case TOP:       rect.top    = coord;    break;
        case BOTTOM:    rect.bottom = coord;    break;
        default:        sc = E_INVALIDARG;      break;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Left
 *
 * PURPOSE: Implements Frame.Left property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Left ( LPINT pCoord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Left"));

    sc = ScGetFrameCoord( pCoord, LEFT );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Left
 *
 * PURPOSE: Implements Frame.Left property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Left ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Left"));

    sc = ScSetFrameCoord( coord, LEFT );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Right
 *
 * PURPOSE: Implements Frame.Right property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Right ( LPINT pCoord)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Right"));

    sc = ScGetFrameCoord( pCoord, RIGHT );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Right
 *
 * PURPOSE: Implements Frame.Right property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Right ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Right"));

    sc = ScSetFrameCoord( coord, RIGHT );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Top
 *
 * PURPOSE: Implements Frame.Top property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Top  ( LPINT pCoord)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Top"));

    sc = ScGetFrameCoord( pCoord, TOP );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Top
 *
 * PURPOSE: Implements Frame.Top property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Top  ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Top"));

    sc = ScSetFrameCoord( coord, TOP );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Bottom
 *
 * PURPOSE: Implements Frame.Bottom property's Get method for view
 *
 * PARAMETERS:
 *    LPINT pCoord - storage for return value
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scget_Bottom ( LPINT pCoord)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Bottom"));


    sc = ScGetFrameCoord( pCoord, BOTTOM );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_Bottom
 *
 * PURPOSE: Implements Frame.Bottom property's Put method for view
 *
 * PARAMETERS:
 *    INT coord - value to set
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::Scput_Bottom ( INT coord )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_Bottom"));

    sc = ScSetFrameCoord( coord, BOTTOM );
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetViewExtensionFrame
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    INT  top :
 *    INT  left :
 *    INT  bottom :
 *    INT  right :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScSetViewExtensionFrame(bool bShowListView, INT top, INT left, INT bottom, INT right)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetViewExtensionFrame"))


    /*
     * this method is only available while a view extension is active
     */
    if (!m_fViewExtended)
        return sc; // return silently. NOTE: This method will be removed shortly, as will the view extension hosted frame object,
                   // once mmc moves the mmcview behavior into the web host's element factory.


    /*
     * figure out the maximum bounding rectangle for the hosted view,
     * mapped to view extension-relative coordinates
     */
    CRect rectBound;
    CalcMaxHostedFrameRect (rectBound);

#ifdef DBG
    CString strDebugMsg;
    strDebugMsg.Format (_T("CAMCView::ScSetViewExtFrameCoord  bound=(l=%d,t=%d,r=%d,b=%d), new = (l=%d,t=%d,r=%d,b=%d)"),
                        rectBound.left, rectBound.top, rectBound.right, rectBound.bottom,
                        left,           top,           right,           bottom
                        );
#endif

    /*
     * make sure the requested coordinate is withing the permitted area
     */
    if (left < rectBound.left)
        left = rectBound.left;
    if (right > rectBound.right)
        right = rectBound.right;
    if (top < rectBound.top)
        top = rectBound.top;
    if (bottom > rectBound.bottom)
        bottom = rectBound.bottom;


    /*
     * if we get here, the view extension-relative coordinate supplied
     * is within the acceptable range, now we need to convert it to
     * CAMCView-relative coordinates
     */
    CPoint pointTopLeft(left, top);
    CPoint pointBottomRight(right, bottom);

	if ( GetExStyle() & WS_EX_LAYOUTRTL )
	{
		// IE does not change left/right order on the RTL locales
		// thus we need to mirror it's coordinates
		// see windows bug #195094 ntbugs9 11/30/00
		pointTopLeft.x	   = rectBound.left + (rectBound.right - right);
		pointBottomRight.x = rectBound.left + (rectBound.right - left);
	}

    MapHostedFramePtToViewPt (pointTopLeft);
    MapHostedFramePtToViewPt (pointBottomRight);

    /*
     * set the coordinates
     */
    CRect rectViewExtHostedFrame;

    rectViewExtHostedFrame.left   = pointTopLeft.x;
    rectViewExtHostedFrame.right  = pointBottomRight.x;
    rectViewExtHostedFrame.top    = pointTopLeft.y;
    rectViewExtHostedFrame.bottom = pointBottomRight.y;

    // move the window to the correct location
    CWnd* pwndResult = GetPaneView(ePane_Results);

    sc = ScCheckPointers(pwndResult);
    if(sc)
        return sc;

	if (bShowListView)
		pwndResult->ShowWindow(SW_SHOW);

    ::MoveWindow(*pwndResult, rectViewExtHostedFrame.left, rectViewExtHostedFrame.top,
                 rectViewExtHostedFrame.right - rectViewExtHostedFrame.left,
                 rectViewExtHostedFrame.bottom - rectViewExtHostedFrame.top,
                 TRUE /*bRepaint*/);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CalcMaxHostedFrameRect
 *
 * Returns the maximum rectangle that can be occupied by a view extension's
 * hosted frame, normalized around (0,0).
 *--------------------------------------------------------------------------*/

void CAMCView::CalcMaxHostedFrameRect (CRect& rect)
{
    /*
     * start with the result frame rectangle and inset it a little so
     * we'll see the client edge provided by the view extension's web
     * host view
     */
    rect = m_rectResultFrame;
    rect.DeflateRect (m_sizEdge);

    /*
     * now normalize around (0,0)
     */
    rect.OffsetRect (-rect.TopLeft());
}


/*+-------------------------------------------------------------------------*
 * CAMCView::MapViewPtToHostedFramePt
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::MapViewPtToHostedFramePt (CPoint& pt)
{
    PointMapperWorker (pt, true);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::MapHostedFramePtToViewPt
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::MapHostedFramePtToViewPt (CPoint& pt)
{
    PointMapperWorker (pt, false);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::MapHostedFramePtToViewPt
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::PointMapperWorker (CPoint& pt, bool fViewToHostedFrame)
{
    int nMultiplier = (fViewToHostedFrame) ? -1 : 1;

    /*
     * adjust to the origin of the result frame rectangle and for the
     * web host view's client edge
     */
	pt.Offset (nMultiplier * (m_rectResultFrame.left + m_sizEdge.cx),
			   nMultiplier * (m_rectResultFrame.top  + m_sizEdge.cy));
}


/***************************************************************************\
 *
 * METHOD:  CXMLWindowPlacement::Persist
 *
 * PURPOSE: Persists window placement settings
 *
 * PARAMETERS:
 *    CPersistor &persistor
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CXMLWindowPlacement::Persist(CPersistor &persistor)
{
    // create wrapper to persist flag values as strings
    CXMLBitFlags wpFlagsPersistor(m_rData.flags, mappedWPFlags, countof(mappedWPFlags));
    // persist the wrapper
    persistor.PersistAttribute( XML_ATTR_WIN_PLACEMENT_FLAGS, wpFlagsPersistor );

    // persist show command as literal
    // create wrapper to persist enumeration values as strings
    CXMLEnumeration showCmdPersistor(m_rData.showCmd, mappedSWCommands, countof(mappedSWCommands));
    // persist the wrapper
    persistor.PersistAttribute( XML_ATTR_SHOW_COMMAND,    showCmdPersistor );

    persistor.Persist( XMLPoint( XML_NAME_MIN_POSITION,   m_rData.ptMinPosition ) );
    persistor.Persist( XMLPoint( XML_NAME_MAX_POSITION,   m_rData.ptMaxPosition ) );
    persistor.Persist( XMLRect( XML_NAME_NORMAL_POSITION, m_rData.rcNormalPosition ) );
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_Document
 *
 * PURPOSE: implements View.Document property in object model
 *
 * PARAMETERS:
 *    PPDOCUMENT ppDocument [out] document to which the view belongs
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_Document( PPDOCUMENT ppDocument )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Document"));

    // parameter check
    sc = ScCheckPointers(ppDocument);
    if (sc)
        return sc;

    // get the document
    CAMCDoc* pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return sc;

    // construct com object
    sc = pDoc->ScGetMMCDocument(ppDocument);
    if (sc)
        return sc;

    return (sc);
}

/*******************************************************\
|  helper function to avoid too many stack allocations
\*******************************************************/
static tstring W2T_ForLoop(const std::wstring& str)
{
#if defined(_UNICODE)
    return str;
#else
    USES_CONVERSION;
    return W2CA(str.c_str());
#endif
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScAddFolderTabs
 *
 * PURPOSE: Collects view extensions and taskpads and displays them as tabs
 *
 * PARAMETERS:
 *    HNODE hNode                   - selected scope node
 *    const CLSID &guidTabToSelect  - tab to select
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScAddFolderTabs( HNODE hNode, const CLSID& guidTabToSelect )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAddFolderTabs"));

    sc = ScCheckPointers(m_pResultFolderTabView, E_UNEXPECTED);
    if (sc)
        return sc;

    // cleanup urls
    m_ViewExtensionURLs.clear();

    // cleanup view tabs before we do anything else
    m_pResultFolderTabView->DeleteAllItems();

    // get the callback
    INodeCallback* pNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallBack, m_pResultFolderTabView, E_UNEXPECTED);
    if (sc)
        return sc;

    // collect view extensions
    CViewExtCollection      vecExtensions;
    CViewExtInsertIterator  itExtensions(vecExtensions, vecExtensions.begin());

    sc = pNodeCallBack->GetNodeViewExtensions(hNode, itExtensions);
    if (sc)
    {
        sc.TraceAndClear();
        vecExtensions.clear();
        // continue anyway
    }

    // check if there is something to show
    if(vecExtensions.size() == 0) // no tabs to show.
    {
        m_pResultFolderTabView->SetVisible(false);
    }
    else
    {
        bool bAddDefaultTab = true;

        // add extensions
        CViewExtCollection::iterator iterVE;
        for(iterVE = vecExtensions.begin(); iterVE != vecExtensions.end(); ++iterVE)
        {
            tstring strName( W2T_ForLoop(iterVE->strName) );
            m_pResultFolderTabView->AddItem(strName.c_str(), iterVE->viewID);
            m_ViewExtensionURLs[iterVE->viewID] = W2T_ForLoop(iterVE->strURL);
            // do not add the "normal" tab if we have a valid replacement for it
            if (iterVE->bReplacesDefaultView)
                bAddDefaultTab = false;
        }

        // add the default item.
        if (bAddDefaultTab)
        {
            CStr strNormal;
            strNormal.LoadString(GetStringModule(), IDS_NORMAL);
            m_pResultFolderTabView->AddItem(strNormal, GUID_NULL);
        }

        // select required item and show tabs
        int iIndex = m_pResultFolderTabView->SelectItemByClsid(guidTabToSelect);
        if (iIndex < 0)
            TraceError(_T("CAMCView::ScAddFolderTabs - failed to select requested folder"), SC(E_FAIL));

        // no need for cotrol if we only have one tab
        bool bMoreThanOneTab = (m_pResultFolderTabView->GetItemCount() > 1);
        m_pResultFolderTabView->SetVisible(bMoreThanOneTab);
    }

    // lookup view extension URL
    CViewExtensionURLs::iterator itVE = m_ViewExtensionURLs.find(guidTabToSelect);
    LPCTSTR url = (itVE != m_ViewExtensionURLs.end()) ? itVE->second.c_str() : NULL;

    // apply URL
    sc = ScApplyViewExtension(url);
    if (sc)
        sc.TraceAndClear();

    RecalcLayout();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_ControlObject
 *
 * PURPOSE: returns IDispatch of embeded OCX control
 *          implements View.ControlObject property
 *
 * PARAMETERS:
 *    PPDISPATCH ppControl [out] control's interface
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_ControlObject( PPDISPATCH ppControl)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ControlObject"));

    // parameter check
    sc = ScCheckPointers(ppControl);
    if (sc)
        return sc;

    // init out param
    *ppControl = NULL;

    // have a OCX view?
    if ( (! HasOCX()) || (m_pOCXHostView == NULL))
        return sc.FromMMC( MMC_E_NO_OCX_IN_VIEW );

    // get the control's interface
    CComQIPtr<IDispatch> spDispatch = m_pOCXHostView->GetIUnknown();
    if (spDispatch == NULL)
        return sc = E_NOINTERFACE;

    // return the pointer
    *ppControl = spDispatch.Detach();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScTreeViewSelectionActivate
//
//  Synopsis:    Only the list(/Web/OCX) or the tree can be "active" from the point
//               of view of selected items and MMCN_SELECT. This is not
//               the same as the MFC concept of "active view". There are a couple
//               of views that cannot be active in this sense, such as the taskpad
//               and tab views.
//               When the active view (according to this definition) changes, this
//               function is called. Thus, ScTreeViewSelectionActivate and
//               ScListViewSelectionActivate/ScSpecialResultpaneSelectionActivate
//               are always called in pairs when the activation changes, one to handle
//               deactivation, and one to handle activation.
//
//               Consider the following scenario
//               1) The tree view has (MFC/windows style) focus.
//               2) The user clicks on the taskpad view
//                   Result - selection activation does not change from the tree. All verbs
//                   still correspond to the selected tree item.
//               3) The user clicks on the folder view
//                   Result - once again, selection activation does not chang
//               4) The user clicks on one of the result views eg the list
//                   Result - ScTreeViewSelectionActivate(false) and ScListViewSelectionActivate(true)
//                   Thus verbs and the toolbar now correspond to the selected list item(s).
//               5) The user clicks on the taskpad view.
//                   Result - as in step 2, nothing happens
//               6) The user clicks on the result view
//                   Result - because the active view has not changed, nothing happens.
//
//  Arguments:   [bActivate] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScTreeViewSelectionActivate (bool bActivate)
{
    DECLARE_SC(sc, _T("CAMCView::ScTreeViewSelectionActivate"));

    sc = ScCheckPointers(m_pTreeCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // 1. Setup the SELECTINFO
    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));
    selInfo.m_bScope            = TRUE;
    selInfo.m_pView             = NULL;
    selInfo.m_bDueToFocusChange = TRUE;

    if (HasOCX())
    {
        selInfo.m_bResultPaneIsOCX  = true;
        selInfo.m_lCookie           = LVDATA_CUSTOMOCX;
    }
    else if (HasWebBrowser())
    {
        selInfo.m_bResultPaneIsWeb = TRUE;
        selInfo.m_lCookie = LVDATA_CUSTOMWEB;
    }

    HTREEITEM   htiSelected   = m_pTreeCtrl->GetSelectedItem();
    HNODE       hSelectedNode = (htiSelected != NULL) ? m_pTreeCtrl->GetItemNode (htiSelected) : NULL;

    // insure that this is the active view when we have the focus
    ASSERT ( ( (bActivate)  && (GetParentFrame()->GetActiveView () == m_pTreeCtrl) ) ||
             ( (!bActivate) && (GetParentFrame()->GetActiveView () != m_pTreeCtrl) ) );

    if (hSelectedNode != NULL)
    {
        // Send select notification.
        sc = ScNotifySelect ( GetNodeCallback(), hSelectedNode,
                              false /*fMultiSelect*/, bActivate, &selInfo);
        if (sc)
            return sc;
    }
    else if ( (htiSelected == NULL) && (bActivate) )
    {
        m_pTreeCtrl->SelectItem (m_pTreeCtrl->GetRootItem());
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnTreeViewActivated
//
//  Synopsis:    Observer implementation for tree-view activation.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnTreeViewActivated ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnTreeViewActivated"));

    if (m_eCurrentActivePane == eActivePaneScope) // Scope pane is already active so return.
        return sc;

#ifdef DBG
    Trace (tagViewActivation, _T("Deactivate %s in result pane Activate Scope pane\n"),
                              HasListOrListPad() ? _T("ListView") : (HasOCX() ? _T("OCX") : _T("WebBrowser")));
#endif

    if (m_eCurrentActivePane == eActivePaneResult)
    {
        // Send deactivate to result.
        if (HasListOrListPad())
            sc = ScListViewSelectionActivate (false);
        else if (HasOCX() || HasWebBrowser())
            sc = ScSpecialResultpaneSelectionActivate(false);
        else
            return (sc = E_UNEXPECTED);

        if (sc)
            sc.TraceAndClear();
    }

    // Send select to scope.
    m_eCurrentActivePane = eActivePaneScope;
    sc = ScTreeViewSelectionActivate(true);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnListViewActivated
//
//  Synopsis:    Observer implementation for list-view activation.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnListViewActivated ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnListViewActivated"));

    if (m_eCurrentActivePane == eActivePaneResult) // Result pane is already active so return.
        return sc;

#ifdef DBG
    Trace (tagViewActivation, _T("Deactivate Scope pane Activate ListView in Result pane\n"));
#endif

    if (m_eCurrentActivePane == eActivePaneScope)
    {
        // Send deactivate to scope.
        sc = ScTreeViewSelectionActivate(false);
        if (sc)
            sc.TraceAndClear();
    }

    // Send activate to list.
    m_eCurrentActivePane = eActivePaneResult;
    ASSERT(HasListOrListPad());

    sc = ScListViewSelectionActivate (true);
    if (sc)
        sc.TraceAndClear();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnListViewItemUpdated
 *
 * PURPOSE: called when an item is updated. This method fires an event to all COM observers.
 *
 * PARAMETERS:
 *    int  nIndex :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnListViewItemUpdated (int nIndex)
{
    DECLARE_SC(sc, _T("CAMCView::ScOnListViewItemUpdated"));

    // fire event
    sc = ScFireEvent(CAMCViewObserver::ScOnListViewItemUpdated, this, nIndex);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnOCXHostActivated
//
//  Synopsis:    Observer implementation for ocx or web view activation.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnOCXHostActivated ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnOCXHostActivated"));

    if (m_eCurrentActivePane == eActivePaneResult) // Result pane is already active so return.
        return sc;

#ifdef DBG
    Trace (tagViewActivation, _T("Deactivate Scope pane Activate %s in Result pane\n"),
                              HasOCX() ? _T("OCX") : _T("WebBrowser"));
#endif

    if (m_eCurrentActivePane == eActivePaneScope)
    {
        // Send deactivate to scope.
        sc = ScTreeViewSelectionActivate(false);
        if (sc)
            sc.TraceAndClear();
    }

    // Send select to ocx or web view.
    m_eCurrentActivePane = eActivePaneResult;
    ASSERT(HasOCX() || HasWebBrowser());

    sc = ScSpecialResultpaneSelectionActivate(true);
    if (sc)
        sc.TraceAndClear();

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\caption.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      caption.cpp
 *
 *  Contents:  Implementation file for caption helper functions
 *
 *  History:   19-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "caption.h"
#include "fontlink.h"
#include "util.h"


static void ComputeCaptionRects (CFrameWnd* pwnd, CRect& rectFullCaption,
                                 CRect& rectCaptionText, NONCLIENTMETRICS* pncm);
static bool GradientFillRect (HDC hdc, LPCRECT pRect, bool fActive);
static bool GradientFillRect (HDC hdc, LPCRECT pRect,
                              COLORREF clrGradientLeft,
                              COLORREF clrGradientRight);


/*+-------------------------------------------------------------------------*
 * DrawFrameCaption
 *
 *
 *--------------------------------------------------------------------------*/

bool DrawFrameCaption (CFrameWnd* pwndFrame, bool fActive)
{
	/*
	 * whistler always does the right thing, so short out if we're running there
	 */
	if (IsWhistler())
		return (false);

    CWindowDC dc(pwndFrame);

    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

    /*
     * create the caption font and select it into the DC
     */
    CFont font;
    font.CreateFontIndirect (&ncm.lfCaptionFont);
    CFont* pOldFont = dc.SelectObject (&font);

    /*
     * get the text to draw
     */
    CString strCaption;
    pwndFrame->GetWindowText (strCaption);

    /*
     * create CFontLinker and CRichText objects to determine if we
     * need to draw the text ourselves
     */
    USES_CONVERSION;
    CRichText   rt (dc, T2CW (strCaption));
    CFontLinker fl;

    if (!fl.ComposeRichText(rt) || rt.IsDefaultFontSufficient())
    {
        dc.SelectObject (pOldFont);
        return (false);
    }

    /*-------------------------------------------------------*/
    /* if we get here, the default drawing isn't sufficient; */
    /* draw the caption ourselves                            */
    /*-------------------------------------------------------*/

    /*
     * get the bounding rects for the full caption and the text portion
     */
    CRect rectFullCaption;
    CRect rectCaptionText;
    ComputeCaptionRects (pwndFrame, rectFullCaption, rectCaptionText, &ncm);

    /*
     * clip output to the caption text rect, to minimize destruction
     * in the event that something dire happens
     */
    dc.IntersectClipRect (rectCaptionText);

    /*
     * gradient-fill the full caption rect (not just the title rect)
     * so the gradient will overlay seamlessly
     */
    if (!GradientFillRect (dc, rectFullCaption, fActive))
    {
        const int nBackColorIndex = (fActive) ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION;
        dc.FillSolidRect (rectCaptionText, GetSysColor (nBackColorIndex));
    }

    /*
     * set up text colors and background mix mode
     */
    const int nTextColorIndex = (fActive) ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT;
    COLORREF clrText = dc.SetTextColor (GetSysColor (nTextColorIndex));
    int      nBkMode = dc.SetBkMode (TRANSPARENT);

    /*
     * draw the text
     */
    rt.Draw (rectCaptionText, fl.GetDrawTextFlags ());

    /*
     * restore the DC
     */
    dc.SetTextColor (clrText);
    dc.SetBkMode    (nBkMode);
    dc.SelectObject (pOldFont);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * ComputeCaptionRects
 *
 *
 *--------------------------------------------------------------------------*/

static void ComputeCaptionRects (
    CFrameWnd*          pwnd,
    CRect&              rectFullCaption,
    CRect&              rectCaptionText,
    NONCLIENTMETRICS*   pncm)
{
    /*
     * start with the full window rect, normalized around (0,0)
     */
    pwnd->GetWindowRect (rectFullCaption);
    rectFullCaption.OffsetRect (-rectFullCaption.left, -rectFullCaption.top);

    /*
     * assume sizing border
     */
    rectFullCaption.InflateRect (-GetSystemMetrics (SM_CXSIZEFRAME),
                                 -GetSystemMetrics (SM_CYSIZEFRAME));

    /*
     * correct the height
     */
    rectFullCaption.bottom = rectFullCaption.top + pncm->iCaptionHeight;

    /*
     * assume a system menu
     */
    rectCaptionText = rectFullCaption;
    rectCaptionText.left += pncm->iCaptionWidth + 2;

    /*
     * assume min, max, close buttons
     */
    rectCaptionText.right -= pncm->iCaptionWidth * 3;
}


/*+-------------------------------------------------------------------------*
 * GradientFillRect
 *
 *
 *--------------------------------------------------------------------------*/

static bool GradientFillRect (HDC hdc, LPCRECT pRect, bool fActive)
{
#if (WINVER < 0x0500)
    #define COLOR_GRADIENTACTIVECAPTION     27
    #define COLOR_GRADIENTINACTIVECAPTION   28
#endif

    int nLeftColor  = (fActive) ? COLOR_ACTIVECAPTION         : COLOR_INACTIVECAPTION;
    int nRightColor = (fActive) ? COLOR_GRADIENTACTIVECAPTION : COLOR_GRADIENTINACTIVECAPTION;

    return (GradientFillRect (hdc, pRect,
                              GetSysColor (nLeftColor),
                              GetSysColor (nRightColor)));
}


/*+-------------------------------------------------------------------------*
 * GradientFillRect
 *
 *
 *--------------------------------------------------------------------------*/

static bool GradientFillRect (HDC hdc, LPCRECT pRect, COLORREF clrGradientLeft, COLORREF clrGradientRight)
{
#if (WINVER < 0x0500)
    #define SPI_GETGRADIENTCAPTIONS         0x1008
#endif
    typedef BOOL (WINAPI* GradientFillFuncPtr)( HDC hdc,  CONST PTRIVERTEX pVertex,  DWORD dwNumVertex,
                                        CONST PVOID pMesh,  DWORD dwNumMesh,  DWORD dwMode);

    // Query if gradient caption enabled, if query fails assume disabled
    BOOL bGradientEnabled;
    if (!SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, &bGradientEnabled, 0))
        bGradientEnabled = FALSE;

    if (!bGradientEnabled)
        return (false);

    static GradientFillFuncPtr pfnGradientFill = NULL;
    static bool fAttemptedGetProcAddress = false;

    // Locate GradientFill function
    if (!fAttemptedGetProcAddress)
    {
        fAttemptedGetProcAddress = true;

        HINSTANCE hInst = LoadLibrary(TEXT("msimg32.dll"));

        if (hInst)
            pfnGradientFill = (GradientFillFuncPtr)GetProcAddress(hInst, "GradientFill");
    }

    if (pfnGradientFill == NULL)
        return (false);

    // Do gradient fill
    TRIVERTEX vert[2] ;
    vert [0].x      = pRect->left;
    vert [0].y      = pRect->top;
    vert [0].Red    = (clrGradientLeft << 8) & 0xff00;
    vert [0].Green  = (clrGradientLeft)      & 0xff00;
    vert [0].Blue   = (clrGradientLeft >> 8) & 0xff00;
    vert [0].Alpha  = 0x0000;

    vert [1].x      = pRect->right;
    vert [1].y      = pRect->bottom;
    vert [1].Red    = (clrGradientRight << 8) & 0xff00;
    vert [1].Green  = (clrGradientRight)      & 0xff00;
    vert [1].Blue   = (clrGradientRight >> 8) & 0xff00;
    vert [1].Alpha  = 0x0000;

    GRADIENT_RECT gRect[1];
    gRect[0].UpperLeft  = 0;
    gRect[0].LowerRight = 1;

    (*pfnGradientFill) (hdc, vert,  countof (vert),
                             gRect, countof (gRect), GRADIENT_FILL_RECT_H);
    return (true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\caption.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      caption.h
 *
 *  Contents:  Interface file for caption helper functions
 *
 *  History:   19-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CAPTION_H
#define CAPTION_H
#pragma once


bool DrawFrameCaption (CFrameWnd* pwndFrame, bool fActive);


#endif /* CAPTION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\childfrm.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      childfrm.inl
 *
 *  Contents:  Inline functions for CChildFrame class.
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CHILDFRM_INL
#define CHILDFRM_INL
#pragma once


/*+-------------------------------------------------------------------------*
 * CChildFrame::ScSetStatusText
 *
 * 
 *--------------------------------------------------------------------------*/

inline SC CChildFrame::ScSetStatusText (LPCTSTR pszText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    m_strStatusText = pszText;
    UpdateStatusText ();

    return (SC());
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::UpdateStatusText 
 *
 *
 *--------------------------------------------------------------------------*/

inline void CChildFrame::UpdateStatusText ()
{
    SendMessage (WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
}


#endif /* CHILDFRM_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\childfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       childfrm.h
//
//--------------------------------------------------------------------------

// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef CHILDFRM_H
#define CHILDFRM_H

#include "statbar.h"
#include "constatbar.h"     // for CConsoleStatusBar

class CAMCView;
class CMenuButtonsMgrImpl;

class CChildFrame : public CMDIChildWnd, public CConsoleStatusBar
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

protected:  // control bar embedded members
    CDockManager<CDockSite> m_DockingManager;
    CDockSite               m_StatusDockSite;

protected:
    CAMCStatusBar       m_wndStatusBar;

// Operations
public:
    void ToggleStatusBar();
    void RenderDockSites();
    void SendMinimizeNotification (bool fMinimized) const;
    bool SetCreateVisible (bool fCreateVisible);
    bool IsCustomizeViewEnabled ();

public:
    // CConsoleStatusBar methods
    virtual SC ScSetStatusText    (LPCTSTR pszText);

//Operations
protected:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    public:
    virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

    virtual CWnd* GetMessageBar()
        { return (&m_wndStatusBar); }

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
        HMENU hMenuAlt);
    virtual HACCEL GetDefaultAccelerator();
    virtual void ActivateFrame(int nCmdShow = -1);

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnDestroy();
    afx_msg void OnClose();
    afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
    afx_msg void OnCustomizeView();
    afx_msg void OnNcPaint();
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    //}}AFX_MSG

    afx_msg void OnMaximizeOrRestore(UINT nId);
    afx_msg void OnUpdateCustomizeView(CCmdUI* pCmdUI);
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetIcon(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);

public:
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);

    DECLARE_MESSAGE_MAP()

private:
    CAMCView* m_pAMCView;
    CString m_strStatusText;
    bool    m_fDestroyed;
    bool    m_fCurrentlyMinimized;
    bool    m_fCurrentlyActive;
    bool    m_fCreateVisible;
    bool    m_fChildFrameActive;
	bool	m_fEmptyAMCView;

    std::auto_ptr<CMenuButtonsMgrImpl>  m_spMenuButtonsMgr;

protected:
    void UpdateStatusText();
    HRESULT NotifyCallback (NCLBK_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param) const;


public:
    void SetAMCView(CAMCView* pView)
        { m_pAMCView = pView; }

    CAMCView* GetAMCView() const
        { return m_pAMCView; }

    void SetChildFrameActive(bool bActive = true) { m_fChildFrameActive = bActive; }
    bool IsChildFrameActive() { return m_fChildFrameActive;}

    CMenuButtonsMgrImpl* GetMenuButtonsMgr() { return (m_spMenuButtonsMgr.get()) ; }

	// this method is for CAMCView::OnDeleteEmptyView()
	// to inform the frame not to resist closing - no contents in the view
	void SetAMCViewIsEmpty()	{ m_fEmptyAMCView = true; }
};


#include "childfrm.inl"


#endif /* CHILDFRM_H */

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\cclvctl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cclvctl.h
//
//--------------------------------------------------------------------------

#ifndef _CCLVCTL_H_
#define _CCLVCTL_H_

// cclvctl.h : header file
//
#include <objbase.h>
#include <atlbase.h>
#include <atlcom.h>
#include "imagemap.h"
#include "ndmgr.h"
#include "fontlink.h"
#include "amcnav.h"
#include "dd.h"
#include "columninfo.h"

// Don't let macro override CWnd method
#undef SubclassWindow

class CAMCView;
class CCCListViewCtrl;
class CResultItem;

class CListFontLinker : public CFontLinker
{
public:
    CListFontLinker (CCCListViewCtrl* pListCtrl) : m_pListCtrl (pListCtrl)
        { ASSERT (m_pListCtrl != NULL); }

protected:
    virtual bool IsAnyItemLocalizable () const;
    virtual std::wstring GetItemText (NMCUSTOMDRAW* pnmcd) const;

private:
    CCCListViewCtrl* const m_pListCtrl;
};


class CSysColorImageList : public CImageList
{
public:
    CSysColorImageList (HINSTANCE hInst, UINT nID)
        :   m_hInst  (hInst),
            m_hRsrc  (::FindResource (m_hInst, MAKEINTRESOURCE (nID), RT_BITMAP))
    {
        CreateSysColorImageList();
    }

    void OnSysColorChange ()
    {
        DeleteImageList();
        CreateSysColorImageList();
    }

    operator HIMAGELIST() const
    {
        return (CImageList::operator HIMAGELIST());
    }

private:
    void CreateSysColorImageList ()
    {
        CBitmap bmp;
        bmp.Attach (AfxLoadSysColorBitmap (m_hInst, m_hRsrc));

        /*
         * get the dimensions of the bitmap
         */
        BITMAP bm;
        bmp.GetBitmap (&bm);

        /*
         * assume square images (cx == cy)
         */
        Create (bm.bmHeight, bm.bmHeight, ILC_COLORDDB, bm.bmWidth / bm.bmHeight, 2);
        Add (&bmp, CLR_NONE);
    }

    HINSTANCE   m_hInst;
    HRSRC       m_hRsrc;
};


class CAMCHeaderCtrl : public CHeaderCtrl
{
public:
	bool IsColumnHidden(int iCol);

protected:
    afx_msg void OnSetFocus(CWnd *pOldWnd);
	afx_msg BOOL OnSetCursor( CWnd* pWnd, UINT nHitTest, UINT message );

    DECLARE_MESSAGE_MAP()
};


class CFocusHandler
{
public:
    virtual void OnKeyboardFocus(UINT nState, UINT nStateMask) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CAMCListView

class CAMCListView :
    public CListView,
    public CAMCNavigator,
    public CFocusHandler,
    public CMMCViewDropTarget,
    public CEventSource<CListViewActivationObserver>
{
// Construction
public:
    CAMCListView() :
        m_bVirtual(false),
        m_iDropTarget(-1),
        m_pAMCView(NULL),
        m_bColumnsNeedToBeRestored(true),
        m_bColumnsBeingRestored(false)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CAMCListView);
	}
    ~CAMCListView()
    {
        if (m_header.m_hWnd)
            m_header.UnsubclassWindow();

        DEBUG_DECREMENT_INSTANCE_COUNTER(CAMCListView);
    }

// CFocusHandler implementation
    virtual void OnKeyboardFocus(UINT nState, UINT nStateMask);

// CAMCNavigator implementation
    virtual BOOL ChangePane(AMCNavDir eDir);
    virtual BOOL TakeFocus(AMCNavDir eDir);

    SC ScOnColumnsAttributeChanged(NMHEADER *pNMHeader, UINT code);

    // Setup header width/order/hiddenness from columninfolist data.
    SC ScRestoreColumnsFromPersistedData();

    SC ScGetColumnInfoList(CColumnInfoList *pColumnsList);
    SC ScModifyColumns(const CColumnInfoList& colInfoList);
    SC ScSaveColumnInfoList();
    SC ScGetDefaultColumnInfoList(CColumnInfoList& columnsList);

    SC ScResetColumnStatusData();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCListView)
    public:
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );
    protected:
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

public:

    virtual SC ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint pt, bool& bCopyOperation);
    virtual void RemoveDropTargetHiliting();

    void SetVirtual()
    {
        m_bVirtual = true;
    }

    bool IsInLargeIconMode() const
    {
        return (GetMode() == LVS_ICON);
    }

    bool IsInSmallIconMode() const
    {
        return (GetMode() == LVS_SMALLICON);
    }

    bool IsInListMode() const
    {
        return (GetMode() == LVS_LIST);
    }

    bool IsInReportMode() const
    {
        return (GetMode() == LVS_REPORT);
    }

    bool IsInFilteredReportMode() const
    {
        if (!IsInReportMode())
            return (false);

        CWnd* pwndHeader = GetHeaderCtrl();
        if (pwndHeader == NULL)
            return (false);

        return (pwndHeader->GetStyle() & HDS_FILTERBAR);
    }

    DWORD SetExtendedListViewStyle (DWORD dwExStyle, DWORD dwExMask = 0)
    {
        return (SendMessage (LVM_SETEXTENDEDLISTVIEWSTYLE, dwExMask, dwExStyle));
    }

    CAMCView* GetAMCView() const
    {
        return (m_pAMCView);
    }

    CAMCHeaderCtrl* GetHeaderCtrl() const;

    bool AreColumnsNeedToBeRestored() const { return m_bColumnsNeedToBeRestored;}
    void SetColumnsNeedToBeRestored(bool b = false) {m_bColumnsNeedToBeRestored = b;}

    bool IsColumnHidden(int iCol) const;

protected:
    //{{AFX_MSG(CAMCListView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnPaint();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnBeginTrack(NMHDR * pNotifyStruct, LRESULT * result);
     //}}AFX_MSG

    afx_msg LRESULT OnColumnPersistedDataChanged (WPARAM, LPARAM);

    DECLARE_MESSAGE_MAP()

private:
    bool                    m_bVirtual;

    CAMCView*               m_pAMCView;
    mutable CAMCHeaderCtrl  m_header;           // mutable so GetHeaderCtrl can call CWnd::SubclassWindow
    int                     m_iDropTarget;
    CColumnInfoList         m_defaultColumnInfoList;


    INodeCallback* GetNodeCallback();
    HNODE GetScopePaneSelNode();
    void SelectDropTarget(int iDropTarget);
    bool ActivateSelf (bool fNotify = true);
    bool NeedsCustomPaint ();

    SC ScGetDropTarget(const CPoint& point, HNODE& hNode, bool& bScope, LPARAM& lvData, int& iDrop);

    DWORD GetMode () const
    {
        return (GetStyle() & LVS_TYPEMASK);
    }

private:
    // For columns
    static const UINT m_nColumnPersistedDataChangedMsg;

    // To allow hidden column width changes.
    bool              m_bColumnsBeingRestored;

    // We dont care if restore is success or failure.
    bool              m_bColumnsNeedToBeRestored;
};


/////////////////////////////////////////////////////////////////////////////
// CCCListViewCtrl window

class CCCListViewCtrl :
    public IMMCListView,
    public CComObjectRoot,
    public CEventSource<CListViewObserver>,
    public CTiedObject
{
// Construction
public:
    CCCListViewCtrl();
    virtual ~CCCListViewCtrl();

    // initialization
    SC ScInitialize();

BEGIN_COM_MAP(CCCListViewCtrl)
    COM_INTERFACE_ENTRY(IMMCListView)
END_COM_MAP()

typedef struct _SortParams
{
    BOOL                    bAscending;         // sort direction
    BOOL                    bLexicalSort;       // apply default sort to all items
    int                     nCol;               // Which column to sort on.
    COMPONENTID             OwnerID;
    void *                  lpListView;         // CCCListViewCtrl *
    IResultDataComparePtr   spResultCompare;    // Snap-in component interface
    IResultDataCompareExPtr spResultCompareEx;  //   "
    LPNODECALLBACK          lpNodeCallback;
    LPARAM                  lpUserParam;        // parameter user passes in
    HNODE                   hSelectedNode;      // Currently selected node in scope pane.
} SortParams;


//DECLARE_AGGREGATABLE(CCCListViewCtrl)
//DECLARE_REGISTRY(CNodeInitObject, _T("NODEMGR.NodeInitObject.1"), _T("NODEMGR.NodeInitObject.1"), IDS_NODEINIT_DESC, THREADFLAGS_BOTH)

// Operations
public:
    #ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)
    long GetColCount()  const                { return m_colCount; }
    long GetItemCount() const                { return m_itemCount; }
    #endif

    CAMCListView*   GetListViewPtr() const   { return m_pListView; }
    CListCtrl&      GetListCtrl()    const   { return m_pListView->GetListCtrl(); }
    CAMCHeaderCtrl* GetHeaderCtrl()  const   { return m_pListView->GetHeaderCtrl(); }

    bool AreColumnsNeedToBeRestored() const { return m_pListView->AreColumnsNeedToBeRestored();}
    void SetColumnsNeedToBeRestored(bool b = true) {m_pListView->SetColumnsNeedToBeRestored(b);}

    bool IsColumnHidden(int iCol) const {return m_pListView->IsColumnHidden(iCol);}

    SC  ScGetAMCView(CAMCView **ppAMCView);

    HWND GetListViewHWND() const             { if (m_pListView) return m_pListView->GetSafeHwnd(); else return NULL;}

    BOOL IsVirtual() const { return m_bVirtual; }
    BOOL Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext=NULL);

    SC   ScAttachToListPad (HWND hwnd, HWND* phwnd);  // NULL hwnd == detach
    BOOL    IsListPad () const { return m_SavedHWND != NULL; }

    LRESULT OnCustomDraw (NMLVCUSTOMDRAW* plvcd);
    void OnSysColorChange();

    // IMMCListView Methods
    STDMETHOD(GetListStyle)       ();
    STDMETHOD(SetListStyle)       (long nNewValue);
    STDMETHOD(GetViewMode)        ();
    STDMETHOD(SetViewMode)        (long nViewMode);
    STDMETHOD(InsertItem)         (LPOLESTR str, long iconNdx, LPARAM lParam, long state, COMPONENTID ownerID, long itemIndex, CResultItem*& pri);
    STDMETHOD(DeleteItem)         (HRESULTITEM itemID, long nCol);
    STDMETHOD(FindItemByLParam)   (COMPONENTID ownerID, LPARAM lParam, CResultItem*& pri);
    STDMETHOD(InsertColumn)       (int nCol, LPCOLESTR str, long nFormat, long width);
    STDMETHOD(DeleteColumn)       (int nCol);
    STDMETHOD(DeleteAllItems)     (COMPONENTID ownerID);
    STDMETHOD(SetColumn)          (long nCol, LPCOLESTR str, long nFormat, long width);
    STDMETHOD(GetColumn)          (long nCol, LPOLESTR* str, LPLONG nFormat, int FAR* width);
    STDMETHOD(GetColumnCount)     (int* pnColCnt);
    STDMETHOD(SetItem)            (int nIndex, CResultItem*  pri, long nCol, LPOLESTR str, long nImage, LPARAM lParam, long nState, COMPONENTID ownerID);
    STDMETHOD(GetItem)            (int nIndex, CResultItem*& pri, long nCol, LPOLESTR* str, int FAR *nImage, LPARAM* lParam, unsigned int FAR *nState, BOOL* pbScopeItem);
    STDMETHOD(GetNextItem)        (COMPONENTID ownerID, long nIndex, UINT nState, CResultItem*& pri, long& nIndexNextItem);
    STDMETHOD(GetLParam)          (long nItem, CResultItem*& pri);
    STDMETHOD(ModifyItemState)    (long nItem, CResultItem* pri, UINT add, UINT remove);
    STDMETHOD(SetIcon)            (long nID, HICON hIcon, long nLoc);
    STDMETHOD(SetImageStrip)      (long nID, HBITMAP hbmSmall, HBITMAP hbmLarge, long nStartLoc, long cMask);
    STDMETHOD(MapImage)           (COMPONENTID nID, long nLoc, int far *pResult);
    STDMETHOD(Reset)              ();
    STDMETHOD(Arrange)            (long style);
    STDMETHOD(UpdateItem)         (HRESULTITEM itemID);
    STDMETHOD(Sort)               (LPARAM lUserParam, long* lpParams);
    STDMETHOD(SetItemCount)       (int nItemCount, DWORD dwOptions);
    STDMETHOD(SetVirtualMode)     (BOOL bVirtual);
    STDMETHOD(Repaint)            (BOOL bErase);
    STDMETHOD(SetChangeTimeOut)   (ULONG lTimeout);
    STDMETHOD(SetColumnFilter)    (int nCol, DWORD dwType, MMC_FILTERDATA* pFilterData);
    STDMETHOD(GetColumnFilter)    (int nCol, DWORD* dwType, MMC_FILTERDATA* pFilterData);
    STDMETHOD(SetColumnSortIcon)  (int nNewCol, int nOldCol, BOOL bAscending, BOOL bSetSortIcon);
    STDMETHOD(SetLoadMode)        (BOOL bState);
    STDMETHOD(GetColumnInfoList)  (CColumnInfoList *pColumnsList);
    STDMETHOD(ModifyColumns)      (const CColumnInfoList& columnsList);
    STDMETHOD(RenameItem)         (HRESULTITEM itemID);
    STDMETHOD(GetDefaultColumnInfoList)( CColumnInfoList& columnsList);


    STDMETHOD(OnModifyItem)(CResultItem* pri);

    void CutSelectedItems(BOOL b);
    bool UseFontLinking() const;

    UINT GetSelectedCount()
        { return (GetListCtrl().GetSelectedCount()); }

    // these methods implement access to enumerations for AMCView
    SC Scget_ListItems( PPNODES ppNodes );
    SC Scget_SelectedItems( PPNODES ppNodes);
    SC ScSelect( PNODE pNode);
    SC ScDeselect( PNODE pNode);
    SC ScIsSelected( PNODE pNode, PBOOL pIsSelected);
    SC ScSelectAll();

    // method used from Nodes collections
    SC ScValidateItem( int  iItem, bool &bScopeNode );

    // method transfering requests from Nodes to AMCView (for scope nodes only)
    SC ScGetScopeNodeForItem ( int  iItem, PPNODE ppNode );

    // Columns access methods
    SC Scget_Columns( PPCOLUMNS Columns );
    SC ScItem( long Index, PPCOLUMN ppColumn );
    SC Scget_Count( PLONG pCount );
    SC ScEnumNext(int &pos, PDISPATCH & pDispatch); // should return the next element.
    SC ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, int &pos);
    SC ScEnumReset(int &pos);
    // methods called from Column instances
    SC ScName( /*[out, retval]*/ BSTR *Name, int iColIndex );
    SC Scget_Width( /*[out, retval]*/ PLONG Width, int iColIndex );
    SC Scput_Width( /*[in]*/ long Width, int iColIndex );
    SC Scget_DisplayPosition( /*[out, retval]*/ PLONG DisplayPosition, int iColIndex );
    SC Scput_DisplayPosition( /*[in]*/ long Index, int iColIndex );
    SC Scget_Hidden( /*[out, retval]*/ PBOOL Hidden, int iColIndex );
    SC Scput_Hidden( /*[in]*/ BOOL Hidden , int iColIndex );
    SC ScSetAsSortColumn( /*[in]*/ ColumnSortOrder SortOrder, int iColIndex );
    SC ScIsSortColumn( PBOOL IsSortColumn, int iColIndex );
    // Column/Columns implementation helpers
    struct ColumnData
    {
        int     iColumnWidth;
        int     iColumnOrder;
        bool    bIsHidden;
        // initialization
        void Init()  { iColumnWidth = 0; iColumnOrder = -1; bIsHidden = false; }
        ColumnData() { Init(); }
        // comparison
        bool operator == (const ColumnData& other) const
                     { return ( 0 == memcmp(this, &other, sizeof(ColumnData)) ); }
    };
    SC ScGetColumnData( int iZeroBasedColIndex, ColumnData *pColData );
    SC ScSetColumnData( int iZeroBasedColIndex, const ColumnData& ColData );

    SC ScFindResultItem ( PNODE pNode, int &iItem );

private:
    // helper methods
    SC ScGetNodesEnum   ( bool bSelectedItemsOnly, PPNODES ppNodes );
    SC ScAllocResultItem  ( CResultItem*& pResultItem, COMPONENTID id, LPARAM lSnapinData, int nImage);
    SC ScFreeResultItem   ( CResultItem* pResultItem);

    SC ScRedrawItem       (int nIndex);
    SC ScGetItemIndexFromHRESULTITEM(const HRESULTITEM& itemID, int& nIndex);

    SC ScRedrawHeader(bool bRedraw);

protected:
    CAMCListView* m_pListView;       // current list (points to m_StandardList or m_VirtualList)
    CAMCListView* m_pStandardList;
    CAMCListView* m_pVirtualList;

    HWND m_SavedHWND;
    WINDOWPLACEMENT m_wp;

    CWnd*         m_pParentWnd;

    //void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

    long m_itemCount;      // internal item counter
    long m_nScopeItems; // scope item count
    long m_colCount;       // internal column counter

    // ImageList members
    CImageList      m_smallIL;
    CImageList      m_largeIL;
    CImageIndexMap  m_resultIM;

    // Header Sorting (Up/Down arrow) Icons.
    CSysColorImageList  m_headerIL;

    // Sorting members
    SortParams  m_sortParams;
    static int CALLBACK SortCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams);
    static int SnapinCompare(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2);
    static int SnapinCompareEx(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2);
    static int CALLBACK DefaultCompare(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams);

private:
    CListFontLinker    m_FontLinker;
    NodesPtr           m_spAllNodes;
    NodesPtr           m_spSelNodes;
    ColumnsPtr         m_spColumns;

    BOOL m_bVirtual;
    BOOL m_bFiltered;           // filtering on now
    BOOL m_bEnsureFocusVisible; // force focused item to be visible
    BOOL m_bLoading;
    BOOL m_bDeferredSort;

    void SetFilterHeader(void);
    SC ScSetImageLists ();
    int ResultItemToIndex (CResultItem* pri) const;
    CResultItem* IndexToResultItem (int nItem);
};


////////////////////////////////////////////////////////////////////////////
// CQFilterDll
//
// This class dynamically loads and initializes the quickfilter DLL.
// A single instance of the class should be declared at the global level.
//
class CQFilterDll
{
public:
    CQFilterDll()
    {
        m_hModule = LoadLibrary(_T("qfctrl.dll"));

        if (m_hModule != NULL)
        {
            void (*pfnInitQuickFilter)();
            pfnInitQuickFilter = (void (*)())GetProcAddress(m_hModule, "InitQuickFilter");

            if (pfnInitQuickFilter != NULL)
                (*pfnInitQuickFilter)();
        }
    }

    CQFilterDll::~CQFilterDll()
    {
        if (m_hModule != NULL)
            FreeLibrary(m_hModule);
    }

private:
    HMODULE m_hModule;
};



/*+-------------------------------------------------------------------------*
 * CHiddenColumnInfo
 *
 * Contains information about a hidden column in report view: a flag
 * indicating it's hidden and its width when it's not hidden.
 *
 * This class is stored in HDITEM.lParam for hidden columns, so it *must*
 * be the same size as an LPARAM.
 *--------------------------------------------------------------------------*/

class CHiddenColumnInfo
{
public:
	CHiddenColumnInfo (LPARAM lParam_) : lParam (lParam_)
	{
		COMPILETIME_ASSERT (sizeof(CHiddenColumnInfo) == sizeof(LPARAM));
	}

	CHiddenColumnInfo (int cx_, bool fHidden_) : cx (cx_), fHidden (fHidden_)
	{
		COMPILETIME_ASSERT (sizeof(CHiddenColumnInfo) == sizeof(LPARAM));
	}

	union
	{
		LPARAM	lParam;
		struct
		{
			int	cx      : 16;
			int	fHidden : 1;
		};
	};
};


#endif _CCLVCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\controls.cpp ===
// Controls.cpp : implementation file
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      Controls.cpp
//
//  Contents:  General window controls used in the slate AMC console
//
//  History:   19-Dec-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "docksite.h"
#include "Controls.h"
#include "resource.h"
#include "amc.h"
#include "tbtrack.h"
#include "mainfrm.h"
#include "fontlink.h"
#include "menubar.h"
#include <oleacc.h>
#include "guidhelp.h"
#include "util.h"		// StripTrailingWhitespace

/*
 * if we're supporting old platforms, we need to get MSAA definitions
 * from somewhere other than winuser.h
 */
#if (_WINNT_WIN32 < 0x0500)
	#include <winable.h>
#endif


#ifdef DBG
CTraceTag  tagToolbarAccessibility (_T("Accessibility"), _T("Toolbar"));
#endif


/*+-------------------------------------------------------------------------*
 * CMMCToolBarAccServer
 *
 * Proxy for the accessibility interface IAccPropServer for CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

class CMMCToolBarAccServer :
	public IAccPropServer,
	public CComObjectRoot,
    public CComObjectObserver,
    public CTiedComObject<CMMCToolBarCtrlEx>
{
    typedef CMMCToolBarAccServer	ThisClass;
    typedef CMMCToolBarCtrlEx		CMyTiedObject;

protected:
	CMMCToolBarAccServer()
	{
		Trace (tagToolbarAccessibility, _T("Creating CMMCToolBarAccServer (0x%p)"), this);

        // add itself as an observer for com object events
        GetComObjectEventSource().AddObserver(*static_cast<CComObjectObserver*>(this));
	}

   ~CMMCToolBarAccServer()
	{
		Trace (tagToolbarAccessibility, _T("Destroying CMMCToolBarAccServer (0x%p)"), this);
	}

   /***************************************************************************\
	*
	* METHOD:  ScOnDisconnectObjects
	*
	* PURPOSE: invoked when observed event (request to disconnect) occures
	*          Disconnects from external connections
	*
	* PARAMETERS:
	*
	* RETURNS:
	*    SC    - result code
	*
   \***************************************************************************/
   virtual ::SC ScOnDisconnectObjects()
   {
	   DECLARE_SC(sc, TEXT("CMMCIDispatchImpl<_ComInterface>::ScOnDisconnectObjects"));

	   // QI for IUnknown
	   IUnknownPtr spUnknown = this;

	   // sanity check
	   sc = ScCheckPointers( spUnknown, E_UNEXPECTED );
	   if (sc)
		   return sc;

	   // cutt own references
	   sc = CoDisconnectObject( spUnknown, 0/*dwReserved*/ );
	   if (sc)
		   return sc;

	   return sc;
   }

public:
    BEGIN_COM_MAP(ThisClass)
		COM_INTERFACE_ENTRY(IAccPropServer)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

public:
    // *** IAccPropServer methods ***
    MMC_METHOD5 (GetPropValue, const BYTE* /*pIDString*/, DWORD /*dwIDStringLen*/, MSAAPROPID /*idProp*/, VARIANT* /*pvarValue*/, BOOL* /*pfGotProp*/)
};


/////////////////////////////////////////////////////////////////////////////
// CDescriptionCtrl

CDescriptionCtrl::CDescriptionCtrl() :
    m_cxMargin   (0),
    m_cyText     (0),
    m_cyRequired (0)
{
}

CDescriptionCtrl::~CDescriptionCtrl()
{
}


BEGIN_MESSAGE_MAP(CDescriptionCtrl, CStatic)
    //{{AFX_MSG_MAP(CDescriptionCtrl)
    ON_WM_NCHITTEST()
    ON_WM_CREATE()
    ON_WM_SETTINGCHANGE()
    ON_WM_DESTROY()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP

    ON_WM_DRAWITEM_REFLECT()
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CDescriptionCtrl message handlers


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::PreCreateWindow
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CDescriptionCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style     |= SS_NOPREFIX | SS_CENTERIMAGE | SS_ENDELLIPSIS |
                    SS_LEFTNOWORDWRAP | SS_OWNERDRAW | WS_CLIPSIBLINGS;
    cs.dwExStyle |= WS_EX_STATICEDGE;

    return (CStatic::PreCreateWindow (cs));
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnCreate
 *
 * WM_CREATE handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

int CDescriptionCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CStatic::OnCreate(lpCreateStruct) == -1)
        return -1;

    CreateFont();

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnDestroy
 *
 * WM_DESTROY handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::OnDestroy()
{
    CStatic::OnDestroy();
    DeleteFont();
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnNcHitTest
 *
 * WM_NCHITTEST handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

UINT CDescriptionCtrl::OnNcHitTest(CPoint point)
{
    return (HTCLIENT);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    CStatic::OnSettingChange(uFlags, lpszSection);

    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        DeleteFont ();
        CreateFont ();
    }
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::OnSize
 *
 * WM_SIZE handler for CDescriptionCtrl.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::OnSize(UINT nType, int cx, int cy)
{
	CStatic::OnSize(nType, cx, cy);
	
	/*
	 * Completely redraw when the size changes, so the ellipsis will
	 * be drawn correctly.  Another way to do this would be to use
	 * CS_HREDRAW | CS_VREDRAW, but it's too big a pain to re-register
	 * the static control.  This'll do just fine.
	 */
	InvalidateRect (NULL);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::DrawItem
 *
 * WM_DRAWITEM handler for CDescriptionCtrl.
 *
 * The description control needs to be ownerdraw for a couple of reasons:
 *
 *  1.  If any of the text contains characters that can't be rendered by
 *      the default font, we won't draw them correctly.
 *
 *  2.  If any of the text contains right-to-left reading text (e.g. Arabic
 *      or Hebrew), system mirroring code will incorrectly mix the console
 *      and snap-in text (bug 365469).  The static control will draw the text
 *      in one fell swoop, but we can get around the problem if we draw
 *      the text ourselves in two steps: first console text, then snap-in
 *      text.
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::DrawItem(LPDRAWITEMSTRUCT lpdis)
{
    /*
     * Bug 410450:  When the system is under stress, we might not get a
     * valid DC.  If we don't there's nothing we can do, so short out (and
     * avoid an AV when we later dereference a NULL CDC*).
     */
    CDC* pdcWindow = CDC::FromHandle (lpdis->hDC);
	if (pdcWindow == NULL)
		return;

    /*
     * if we don't have any text, just clear the background
     */
    bool fHasConsoleText = !m_strConsoleText.IsEmpty();
    bool fHasSnapinText  = !m_strSnapinText.IsEmpty();

    if (!fHasConsoleText && !fHasSnapinText)
	{
		FillRect (lpdis->hDC, &lpdis->rcItem, GetSysColorBrush (COLOR_3DFACE));
        return;
	}

    /*
     * figure out the text rectangle; it will be one line high, vertically
     * centered within the window
     */
    CRect rectClient;
    GetClientRect (rectClient);
	const int cxClient = rectClient.Width();
	const int cyClient = rectClient.Height();

    CRect rectText  = rectClient;
    rectText.left  += m_cxMargin;
    rectText.bottom = m_cyText;

    rectText.OffsetRect (0, (cyClient - rectText.Height()) / 2);

    const DWORD dwFlags = DT_LEFT | DT_TOP | DT_SINGLELINE |
                          DT_NOPREFIX | DT_END_ELLIPSIS;

    USES_CONVERSION;
    CFontLinker fl;

	/*
	 * double-buffer drawing for flicker-free redraw
	 */
	CDC dcMem;
	dcMem.CreateCompatibleDC (pdcWindow);
	if (dcMem.GetSafeHdc() == NULL)
		return;

	CBitmap bmpMem;
	bmpMem.CreateCompatibleBitmap (&dcMem, cxClient, cyClient);
	if (bmpMem.GetSafeHandle() == NULL)
		return;

    /*
     * put the right font in the DC, and clear it out
     */
    CFont*  	pOldFont   = dcMem.SelectObject (&m_font);
	CBitmap*	pOldBitmap = dcMem.SelectObject (&bmpMem);
	dcMem.PatBlt (0, 0, cxClient, cyClient, WHITENESS);

    /*
     * if we have console text draw it and update the text rectangle
     * so snap-in text (if any) will be drawn in the right place
     */
    if (fHasConsoleText)
    {
        /*
         * create a CRichText object for the console text and let
         * the font linker parse it into bite-size chunks
         */
        CRichText rt (dcMem, T2CW (static_cast<LPCTSTR>(m_strConsoleText)));
        bool fComposed = fl.ComposeRichText (rt);

        /*
         * draw the console text and adjust the text rectancle in
         * preparation for drawing the snap-in text
         */
        if (fComposed && !rt.IsDefaultFontSufficient())
        {
            CRect rectRemaining;
            rt.Draw (rectText, dwFlags, rectRemaining);

            rectText.left = rectRemaining.left;
        }
        else
        {
            dcMem.DrawText (m_strConsoleText, rectText, dwFlags | DT_CALCRECT);
            dcMem.DrawText (m_strConsoleText, rectText, dwFlags);

            rectText.left  = rectText.right;
            rectText.right = rectClient.right;
        }

        /*
         * leave some space between the console text and the snap-in text
         */
        rectText.left += 2*m_cxMargin;
    }

    /*
     * draw the snap-in text, if any
     */
    if (fHasSnapinText)
    {
        /*
         * create a CRichText object for the console text and let
         * the font linker parse it into bite-size chunks
         */
        CRichText rt (dcMem, T2CW (static_cast<LPCTSTR>(m_strSnapinText)));
        bool fComposed = fl.ComposeRichText (rt);

        /*
         * draw the snap-in text
         */
        if (fComposed && !rt.IsDefaultFontSufficient())
            rt.Draw (rectText, dwFlags);
        else
            dcMem.DrawText (m_strSnapinText, rectText, dwFlags);
    }

	/*
	 * blt to the screen
	 */
	pdcWindow->BitBlt (0, 0, cxClient, cyClient, &dcMem, 0, 0, SRCCOPY);

    /*
     * restore the original font
     */
    dcMem.SelectObject (pOldFont);
    dcMem.SelectObject (pOldBitmap);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::CreateFont
 *
 *
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::CreateFont ()
{
    /*
     * create a copy of the icon title font
     */
    LOGFONT lf;
    SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);

    m_font.CreateFontIndirect (&lf);

    /*
     * figure out how much space we need to fully display our text
     */
    TCHAR ch = _T('0');
    CWindowDC dc(this);
    CFont*  pFont  = dc.SelectObject (&m_font);
    m_cyText = dc.GetTextExtent(&ch, 1).cy;

    ch = _T(' ');
    m_cxMargin = 2 * dc.GetTextExtent(&ch, 1).cx;

    CRect rectRequired (0, 0, 0, m_cyText + 2*GetSystemMetrics(SM_CYEDGE));
    AdjustWindowRectEx (rectRequired, GetStyle(), false, GetExStyle());
    m_cyRequired = rectRequired.Height();

    dc.SelectObject (pFont);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::DeleteFont
 *
 *
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::DeleteFont ()
{
    m_font.DeleteObject();
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::ScOnSelectedItemTextChanged
 *
 * This method observes the text of the selected item in the tree control.
 * The text is reflected in the description bar.
 *--------------------------------------------------------------------------*/

SC CDescriptionCtrl::ScOnSelectedItemTextChanged (LPCTSTR pszSelectedItemText)
{
    if (m_strConsoleText != pszSelectedItemText)
    {
        m_strConsoleText = pszSelectedItemText;
        Invalidate();
    }

	return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CDescriptionCtrl::SetSnapinText
 *
 *
 *--------------------------------------------------------------------------*/

void CDescriptionCtrl::SetSnapinText (const CString& strSnapinText)
{
    if (m_strSnapinText != strSnapinText)
    {
        m_strSnapinText = strSnapinText;
        Invalidate();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrlEx

CToolBarCtrlEx::CToolBarCtrlEx()
{
    m_sizeBitmap.cx = 16;
    m_sizeBitmap.cy = 16;   // docs say 15, but code in toolbar.c says 16

    m_fMirrored = false;

    m_pRebar = NULL;
    m_cx     = 0;
}

CToolBarCtrlEx::~CToolBarCtrlEx()
{
}


BEGIN_MESSAGE_MAP(CToolBarCtrlEx, CToolBarCtrlEx::BaseClass)
    //{{AFX_MSG_MAP(CToolBarCtrlEx)
    ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrlEx message handlers

BOOL CToolBarCtrlEx::Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
    BOOL bRtn=FALSE;

    if (!pParentWnd)
    {
        ASSERT(pParentWnd); // Invalid Parent
    }
    else
    {
        // Initialise the new common controls
        INITCOMMONCONTROLSEX icex;

        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC   = ICC_BAR_CLASSES;

        if (InitCommonControlsEx(&icex))
        {
            // Add toolbar styles to the dwstyle
            dwStyle |=  WS_CHILD | TBSTYLE_FLAT | WS_CLIPCHILDREN |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE;


            if (CWnd::CreateEx(WS_EX_TOOLWINDOW | WS_EX_NOPARENTNOTIFY,
                                   TOOLBARCLASSNAME,
                                   lpszWindowName,
                                   dwStyle,
                                   rect,
                                   pParentWnd,
                                   nID))
            {
                bRtn=TRUE;

                //See if toolbar is mirrored or not
                m_fMirrored = GetExStyle() & WS_EX_LAYOUTRTL;

                // Tells the toolbar what version we are.
                SetButtonStructSize(sizeof(TBBUTTON));

                //REVIEW This may not need to be here.  I'm defaulting buttons w/ text
                //to only have one row.  This may need to be configurable.
                SetMaxTextRows(1);

                CRebarDockWindow* pRebarDock = (CRebarDockWindow*) pParentWnd;
                if (pRebarDock)
                    m_pRebar = pRebarDock->GetRebar();
            }
        }
    }

    return bRtn;
}


void CToolBarCtrlEx::UpdateToolbarSize(void)
{
    /*
     * get the right edge of the right-most visible button
     */
    int cx = 0;
    for (int i = GetButtonCount()-1; i >= 0; i--)
    {
        RECT rcButton;

        if (GetItemRect (i, &rcButton))
        {
            cx = rcButton.right;
            break;
        }
    }

    ASSERT (IsWindow (m_pRebar->GetSafeHwnd()));

    /*
     * if the width has changed, update the band
     */
    if (m_cx != cx)
    {
        m_cx = cx;

        // Set values unique to the band with the toolbar;
        REBARBANDINFO   rbBand;
        rbBand.cbSize     = sizeof (rbBand);
        rbBand.fMask      = RBBIM_SIZE | RBBIM_CHILDSIZE;
        rbBand.cx         = m_cx;
        rbBand.cxMinChild = m_cx;
        rbBand.cyMinChild = HIWORD (GetButtonSize());

        int iBand = GetBandIndex();
        if (iBand != -1)
            m_pRebar->SetBandInfo (iBand, &rbBand);
    }
}


bool CToolBarCtrlEx::IsBandVisible()
{
    return (GetBandIndex() != -1);
}

int CToolBarCtrlEx::GetBandIndex()
{
    REBARBANDINFO rbBand;
    rbBand.cbSize = sizeof(REBARBANDINFO);
    rbBand.fMask  = RBBIM_CHILD;

	if ( m_pRebar == NULL )
		return (-1);

    int nBands = m_pRebar->GetBandCount ();

    for (int i = 0; i < nBands; i++)
    {
        if (m_pRebar->GetBandInfo (i, &rbBand) && (rbBand.hwndChild == m_hWnd))
            return (i);
    }

    return (-1);
}


void CToolBarCtrlEx::Show(BOOL bShow, bool bAddToolbarInNewLine)
{
    if ((m_pRebar == NULL) || !::IsWindow(m_pRebar->m_hWnd))
    {
        ASSERT(FALSE);  // Invalid rebar window handle
        return;
    }


    if (bShow)
    {
        if (false == IsBandVisible())
        {
            REBARBANDINFO rbBand;
            ZeroMemory(&rbBand, sizeof(rbBand));
            rbBand.cbSize     = sizeof(REBARBANDINFO);
            rbBand.fMask      = RBBIM_CHILD | RBBIM_SIZE | RBBIM_CHILDSIZE | RBBIM_ID | RBBIM_STYLE;
            rbBand.hwndChild  = m_hWnd;
            rbBand.wID        = GetWindowLong (m_hWnd, GWL_ID);
            rbBand.cx         = m_cx;
            rbBand.cxMinChild = m_cx;
            rbBand.cyMinChild = HIWORD (GetButtonSize());
            rbBand.fStyle     = RBBS_NOGRIPPER;

            if (bAddToolbarInNewLine)
            {
                // Insert this toolbar in new line.
                rbBand.fStyle |= RBBS_BREAK;
            }

            m_pRebar->InsertBand (&rbBand);
        }
    }
    else
    {
        int iBand = GetBandIndex();
        ASSERT(iBand != -1);
        if (iBand != -1)
            m_pRebar->DeleteBand (iBand);
    }
}


void CToolBarCtrlEx::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
    CToolCmdUIEx state;
    state.m_pOther = this;

    state.m_nIndexMax = (UINT)DefWindowProc(TB_BUTTONCOUNT, 0, 0);
    for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax; state.m_nIndex++)
    {
        // get buttons state
        TBBUTTON button;
        memset(&button, 0, sizeof(TBBUTTON));
        GetButton(state.m_nIndex, &button);
        state.m_nID = button.idCommand;

        // ignore separators
        if (!(button.fsStyle & TBSTYLE_SEP))
        {
            // allow the toolbar itself to have update handlers
            if (CWnd::OnCmdMsg(state.m_nID, CN_UPDATE_COMMAND_UI, &state, NULL))
                continue;

            // allow the owner to process the update
            state.DoUpdate(pTarget, bDisableIfNoHndler);
        }
    }

    // update the dialog controls added to the toolbar
    UpdateDialogControls(pTarget, bDisableIfNoHndler);
}


LRESULT CToolBarCtrlEx::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
    /*
    // handle delay hide/show
    BOOL bVis = GetStyle() & WS_VISIBLE;
    UINT swpFlags = 0;
    if ((m_nStateFlags & delayHide) && bVis)
        swpFlags = SWP_HIDEWINDOW;
    else if ((m_nStateFlags & delayShow) && !bVis)
        swpFlags = SWP_SHOWWINDOW;
    m_nStateFlags &= ~(delayShow|delayHide);
    if (swpFlags != 0)
    {
        SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
            SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    }
    */

    // The code below updates the menus (especially the child-frame
    // system menu when the frame is maximized).

    // the style must be visible and if it is docked
    // the dockbar style must also be visible
    if ((GetStyle() & WS_VISIBLE))
    {
        CFrameWnd* pTarget = (CFrameWnd*)GetOwner();
        if (pTarget == NULL || !pTarget->IsFrameWnd())
            pTarget = GetParentFrame();
        if (pTarget != NULL)
            OnUpdateCmdUI(pTarget, (BOOL)wParam);
    }

    return 0L;

}


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CRebarWnd

CRebarWnd::CRebarWnd() : m_fRedraw(true)
{
}

CRebarWnd::~CRebarWnd()
{
}

BEGIN_MESSAGE_MAP(CRebarWnd, CWnd)
    //{{AFX_MSG_MAP(CRebarWnd)
    ON_WM_CREATE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_ERASEBKGND()
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_SETREDRAW, OnSetRedraw)
    ON_NOTIFY_REFLECT(RBN_AUTOSIZE, OnRebarAutoSize)
    ON_NOTIFY_REFLECT(RBN_HEIGHTCHANGE, OnRebarHeightChange)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRebarWnd message handlers


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnCreate
 *
 * WM_CREATE handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

int CRebarWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    SetTextColor (GetSysColor (COLOR_BTNTEXT));
    SetBkColor   (GetSysColor (COLOR_BTNFACE));

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnSysColorChange
 *
 * WM_SYSCOLORCHANGE handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

void CRebarWnd::OnSysColorChange()
{
    CWnd::OnSysColorChange();

    SetTextColor (GetSysColor (COLOR_BTNTEXT));
    SetBkColor   (GetSysColor (COLOR_BTNFACE));
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnEraseBkgnd
 *
 * WM_ERASEBKGND handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

BOOL CRebarWnd::OnEraseBkgnd(CDC* pDC)
{
    /*
     * If redraw is turned on, forward this on the the window.  If it's
     * not on, we want to prevent erasing the background to minimize
     * flicker.
     */
    if (m_fRedraw)
        return CWnd::OnEraseBkgnd(pDC);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnSetRedraw
 *
 * WM_SETREDRAW handler for CRebarWnd.
 *--------------------------------------------------------------------------*/

LRESULT CRebarWnd::OnSetRedraw (WPARAM wParam, LPARAM)
{
    m_fRedraw = (wParam != FALSE);
    return (Default ());
}


/*+-------------------------------------------------------------------------*
 * CRebarWnd::OnRebarAutoSize
 *
 * RBN_REBARAUTOSIZE handler for CRebarWnd.
 *
 * We want to keep the menu band on a row by itself, without any other
 * toolbars.  To do this, each time the rebar resizes we'll make sure that
 * the first visible band after the menu band starts a new row.
 *
 * A more foolproof way to do this would be to have a separate rebar
 * for the menu.  If we do that, we'll need to insure that tabbing between
 * toolbars (Ctrl+Tab) still works.
 *--------------------------------------------------------------------------*/

void CRebarWnd::OnRebarAutoSize(NMHDR* pNotify, LRESULT* result)
{
    /*
     * insure that the band following the menu is on a new line
     */
    CMainFrame* pFrame = AMCGetMainWnd();
    if (pFrame == NULL)
        return;

    CToolBarCtrlEx* pMenuBar = pFrame->GetMenuBar();
    if (pMenuBar == NULL)
        return;

    int iMenuBand = pMenuBar->GetBandIndex();
    if (iMenuBand == -1)
        return;

    /*
     * if the menu band is the last band on the rebar, we're done
     */
    int cBands = GetBandCount();
    if (iMenuBand == cBands-1)
        return;

    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof (rbbi);
    rbbi.fMask  = RBBIM_STYLE;

    /*
     * if the first visible band following the menu band isn't
     * on a new line, make it so
     */
    for (int iBand = iMenuBand+1; iBand < cBands; iBand++)
    {
        if (GetBandInfo (iBand, &rbbi) && !(rbbi.fStyle & RBBS_HIDDEN))
        {
            if (!(rbbi.fStyle & RBBS_BREAK))
            {
                rbbi.fStyle |= RBBS_BREAK;
                SetBandInfo (iBand, &rbbi);
            }

            break;
        }
    }
}


//+-------------------------------------------------------------------
//
//  Member:     OnRebarHeightChange
//
//  Synopsis:   RBN_HEIGHTCHANGE notification handler.
//
//              When the rebar changes its height, we need to allow the
//              docking host to resize to accomodate it.
//
//  Arguments:  Not used.
//
//--------------------------------------------------------------------
void CRebarWnd::OnRebarHeightChange(NMHDR* pNotify, LRESULT* result)
{
    CRebarDockWindow* pRebarWnd = (CRebarDockWindow*) GetParent();
    if (pRebarWnd && IsWindow(pRebarWnd->m_hWnd))
        pRebarWnd->UpdateWindowSize();
}


CRect CRebarWnd::CalculateSize(CRect maxRect)
{
    CRect rect;
    GetClientRect(&rect);
//    TRACE(_T("rc.bottom=%d\n"),rect.bottom);

    rect.right=maxRect.Width();

    return rect;

}

BOOL CRebarWnd::Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
    BOOL bResult = FALSE;
    ASSERT_VALID(pParentWnd);   // must have a parent

    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_COOL_CLASSES;

    if (!InitCommonControlsEx(&icex))
        return bResult;

    dwStyle |= WS_BORDER | /*WS_CLIPCHILDREN | WS_CLIPSIBLINGS |*/
               CCS_NODIVIDER | CCS_NOPARENTALIGN |
               RBS_VARHEIGHT | RBS_BANDBORDERS;

    if (CWnd::CreateEx (WS_EX_TOOLWINDOW,
                           REBARCLASSNAME,
                           lpszWindowName,
                           dwStyle,
                           rect,
                           pParentWnd,
                           nID))
    {
        // Initialize and send the REBARINFO structure.
        REBARINFO rbi;
        rbi.cbSize = sizeof(REBARINFO);
        rbi.fMask  = 0;
        rbi.himl   = NULL;

        if (SetBarInfo (&rbi))
            bResult=TRUE;
    }


    return bResult;
}


BOOL CRebarWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
    if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return (TRUE);

    return (FALSE);
}


LRESULT CRebarWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    // this is required for Action, View drop-downs
    if ((WM_COMMAND == message) && IsWindow ((HWND) lParam))
        return ::SendMessage((HWND)lParam, message, wParam, lParam);

    return CWnd::WindowProc(message, wParam, lParam);
}



/////////////////////////////////////////////////////////////////////////////
// CToolBar idle update through CToolCmdUI class


void CToolCmdUIEx::Enable(BOOL bOn)
{
    m_bEnableChanged = TRUE;
    CToolBarCtrlEx* pToolBar = (CToolBarCtrlEx*)m_pOther;
    ASSERT(pToolBar != NULL);
    ASSERT(m_nIndex < m_nIndexMax);

    UINT nNewStyle = pToolBar->GetState(m_nID);
    if (!bOn)
    {
        nNewStyle  &= ~TBSTATE_ENABLED;
        // WINBUG: If a button is currently pressed and then is disabled
        // COMCTL32.DLL does not unpress the button, even after the mouse
        // button goes up!  We work around this bug by forcing TBBS_PRESSED
        // off when a button is disabled.
        nNewStyle &= ~TBBS_PRESSED;
    }
    else
    {
        nNewStyle |= TBSTATE_ENABLED;
    }
    //ASSERT(!(nNewStyle & TBBS_SEPARATOR));
    pToolBar->SetState(m_nID, nNewStyle);
}

void CToolCmdUIEx::SetCheck(int nCheck)
{
    ASSERT(nCheck >= 0 && nCheck <= 2); // 0=>off, 1=>on, 2=>indeterminate
    CToolBarCtrlEx* pToolBar = (CToolBarCtrlEx*)m_pOther;
    ASSERT(pToolBar != NULL);
    ASSERT(m_nIndex < m_nIndexMax);

    UINT nNewStyle = pToolBar->GetState(m_nID) &
                ~(TBBS_CHECKED | TBBS_INDETERMINATE | TBBS_CHECKBOX);


    if (nCheck == 1)
        nNewStyle |= TBBS_CHECKED | TBBS_CHECKBOX;
    else if (nCheck == 2)
        nNewStyle |= TBBS_INDETERMINATE;

    pToolBar->SetState(m_nID, nNewStyle);
}

void CToolCmdUIEx::SetText(LPCTSTR)
{

}

void CToolCmdUIEx::SetHidden(BOOL bHidden)
{

    m_bEnableChanged = TRUE;
    CToolBarCtrlEx* pToolBar = (CToolBarCtrlEx*)m_pOther;
    ASSERT(pToolBar != NULL);
    ASSERT(m_nIndex < m_nIndexMax);

    pToolBar->HideButton(m_nID, bHidden);

    pToolBar->UpdateToolbarSize();

}



/////////////////////////////////////////////////////////////////////////////
// CMMCToolBarCtrlEx


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetTrackAccel
 *
 * Manages the accelerator table singleton for CMMCToolBarCtrlEx
 *--------------------------------------------------------------------------*/

const CAccel& CMMCToolBarCtrlEx::GetTrackAccel ()
{
    static ACCEL aaclTrack[] = {
        {   FVIRTKEY,           VK_RETURN,  CMMCToolBarCtrlEx::ID_MTBX_PRESS_HOT_BUTTON   },
        {   FVIRTKEY,           VK_RIGHT,   CMMCToolBarCtrlEx::ID_MTBX_NEXT_BUTTON              },
        {   FVIRTKEY,           VK_LEFT,    CMMCToolBarCtrlEx::ID_MTBX_PREV_BUTTON              },
        {   FVIRTKEY,           VK_ESCAPE,  CMMCToolBarCtrlEx::ID_MTBX_END_TRACKING             },
        {   FVIRTKEY,           VK_TAB,     CMMCToolBarCtrlEx::ID_MTBX_NEXT_BUTTON              },
        {   FVIRTKEY | FSHIFT,  VK_TAB,     CMMCToolBarCtrlEx::ID_MTBX_PREV_BUTTON              },
    };

    static const CAccel TrackAccel (aaclTrack, countof (aaclTrack));
    return (TrackAccel);
}


CMMCToolBarCtrlEx::CMMCToolBarCtrlEx()
{
    m_fTrackingToolBar  = false;
	m_fFakeFocusApplied = false;
}

CMMCToolBarCtrlEx::~CMMCToolBarCtrlEx()
{
}


BEGIN_MESSAGE_MAP(CMMCToolBarCtrlEx, CToolBarCtrlEx)
    //{{AFX_MSG_MAP(CMMCToolBarCtrlEx)
    ON_NOTIFY_REFLECT(TBN_HOTITEMCHANGE, OnHotItemChange)
    ON_WM_LBUTTONDOWN()
    ON_WM_MBUTTONDOWN()
    ON_WM_RBUTTONDOWN()
	ON_WM_DESTROY()
    ON_COMMAND(ID_MTBX_NEXT_BUTTON, OnNextButton)
    ON_COMMAND(ID_MTBX_PREV_BUTTON, OnPrevButton)
    ON_COMMAND(ID_MTBX_END_TRACKING, EndTracking)
    ON_COMMAND(ID_MTBX_PRESS_HOT_BUTTON, OnPressHotButton)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMMCToolBarCtrlEx message handlers

BOOL CMMCToolBarCtrlEx::PreTranslateMessage(MSG* pMsg)
{
    if (CToolBarCtrlEx::PreTranslateMessage (pMsg))
        return (TRUE);

    if ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST))
    {
        const CAccel& TrackAccel = GetTrackAccel();
        ASSERT (TrackAccel != NULL);

        // ...or try to handle it here.
        if (m_fTrackingToolBar && TrackAccel.TranslateAccelerator (m_hWnd, pMsg))
            return (TRUE);
    }

    return (FALSE);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnCreate
 *
 * WM_CREATE handler for CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::OnCreate"));

	if (CToolBarCtrlEx::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	/*
	 * Create our accessibility object so accessibility tools can follow
	 * keyboard access to the toolbar.  If we can't, some accessibility
	 * tools (those that are super paranoid about confirming that objects
	 * for which they receive EVENT_OBJECT_FOCUS have a state of
	 * STATE_SYSTEM_FOCUSED) may not be able to follow along with toolbar
	 * tracking, but we can continue.
	 */
	sc = ScInitAccessibility();
	if (sc)
		sc.TraceAndClear();
	
	return 0;
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnDestroy
 *
 * WM_DESTROY handler for CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnDestroy()
{
	CToolBarCtrlEx::OnDestroy();
	
	/*
	 * if we provided an IAccPropServer to oleacc.dll, revoke it now
	 */
	if (m_spAccPropServices != NULL)
	{
		m_spAccPropServices->ClearHwndProps (m_hWnd, OBJID_CLIENT, CHILDID_SELF,
											 &PROPID_ACC_STATE, 1);
		m_spAccPropServices.Release();
	}
}

/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnLButtonDown
 *
 * Allows the tracker to turn off when someone clicks elsewhere
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnLButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
        EndTracking();
    else
        CToolBarCtrlEx::OnLButtonDown(nFlags, point );
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnMButtonDown
 *
 * Allows the tracker to turn off when someone clicks elsewhere
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnMButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
        EndTracking();
    else
        CToolBarCtrlEx::OnMButtonDown(nFlags, point );
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnRButtonDown
 *
 * Allows the tracker to turn off when someone clicks elsewhere
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnRButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
        EndTracking();
    else
        CToolBarCtrlEx::OnRButtonDown(nFlags, point );
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnNextButton
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnNextButton ()
{
    // In a mirrored toolbar swap left and right keys.
    if (m_fMirrored)
        SetHotItem (GetPrevButtonIndex (GetHotItem ()));
    else
        SetHotItem (GetNextButtonIndex (GetHotItem ()));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnPrevButton
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnPrevButton ()
{
    // In a mirrored toolbar swap left and right keys.
    if (m_fMirrored)
        SetHotItem (GetNextButtonIndex (GetHotItem ()));
    else
        SetHotItem (GetPrevButtonIndex (GetHotItem ()));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::BeginTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::BeginTracking ()
{
    BeginTracking2 (GetMainAuxWnd());
}

void CMMCToolBarCtrlEx::BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
    if (!m_fTrackingToolBar)
    {
        m_fTrackingToolBar = true;
        SetHotItem (GetFirstButtonIndex ());

        // Captures the mouse
        // This prevents the mouse from activating something else without
        // first giving us a chance to deactivate the tool bar.
        SetCapture();
        // make sure to set standard corsor since we've stolen the mouse
        // see BUG 28458 MMC: Mouse icon does not refresh when menu is activated by pressing ALT key
        ::SetCursor( ::LoadCursor( NULL, IDC_ARROW ) );

        if (pAuxWnd != NULL)
            pAuxWnd->TrackToolbar (this);
    }
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::EndTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::EndTracking ()
{
    EndTracking2 (GetMainAuxWnd());
}

void CMMCToolBarCtrlEx::EndTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::EndTracking2"));

	/*
	 * tell accessibility tools that the "focus" went back to the real
	 * focus window
	 */
	sc = ScRestoreAccFocus();
	if (sc)
		sc.TraceAndClear();

    if (m_fTrackingToolBar)
    {
        SetHotItem (-1);
        m_fTrackingToolBar = false;

        // Releases the mouse This gives us a chance to deactivate the tool bar
        // before anything else is activated.
        ReleaseCapture();

        if (pAuxWnd != NULL)
            pAuxWnd->TrackToolbar (NULL);
    }
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnPressHotButton
 *
 *
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnPressHotButton ()
{
    int nHotIndex = GetHotItem();
    ASSERT (m_fTrackingToolBar);
    ASSERT (nHotIndex != -1);

    TBBUTTON    tb;
    GetButton (nHotIndex, &tb);

    // press the button and pause to show the press
    PressButton (tb.idCommand, true);
    UpdateWindow ();
    Sleep (50);

    // EndTracking for surrogate windows will detach the window,
    // so remember everything that we'll need later
    HWND hwnd = m_hWnd;
    CWnd* pwndOwner = SetOwner (NULL);
    SetOwner (pwndOwner);

    // release the button
    PressButton (tb.idCommand, false);
    EndTracking ();

    /*-----------------------------------------------------------------*/
    /* WARNING:  don't use any members of this class beyond this point */
    /*-----------------------------------------------------------------*/

    // make sure drawing is completed
    ::UpdateWindow (hwnd);

    // send a command to our owner
    pwndOwner->SendMessage (WM_COMMAND, MAKEWPARAM (tb.idCommand, BN_CLICKED),
                            (LPARAM) hwnd);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetFirstButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetFirstButtonIndex ()
{
    return (GetNextButtonIndex (-1));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetNextButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetNextButtonIndex (
    int     nStartIndex,
    int     nCount /* = 1 */)
{
    return (GetNextButtonIndexWorker (nStartIndex, nCount, true));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetPrevButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetPrevButtonIndex (
    int nStartIndex,
    int nCount /* = 1 */)
{
    return (GetNextButtonIndexWorker (nStartIndex, nCount, false));
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::GetNextButtonIndexWorker
 *
 *
 *--------------------------------------------------------------------------*/

int CMMCToolBarCtrlEx::GetNextButtonIndexWorker (
    int     nStartIndex,
    int     nCount,
    bool    fAdvance)
{
    ASSERT (nCount >= 0);

    if (!fAdvance)
        nCount = -nCount;

    int  cButtons   = GetButtonCount ();
    int  nNextIndex = nStartIndex;
    bool fIgnorable;

    if (0 == cButtons)
        return nStartIndex;

    /*
     * loop until we find a next index that we don't want to
     * ignore, or until we've checked each of the buttons
     */
    do
    {
        nNextIndex = (nNextIndex + cButtons + nCount) % cButtons;
        fIgnorable = IsIgnorableButton (nNextIndex);

        if (fIgnorable)
            nCount = fAdvance ? 1 : -1;

        // prevent an infinite loop finding the first button
        if ((nStartIndex == -1) && (nNextIndex == cButtons-1))
            nNextIndex = nStartIndex;

    } while (fIgnorable && (nNextIndex != nStartIndex));

    return (nNextIndex);
}


/*+-------------------------------------------------------------------------*
 * IsIgnorableButton
 *
 * Determines if a toolbar button is "ignorable" from a UI perspective,
 * i.e. whether it is hidden, disabled, or a separator.
 *--------------------------------------------------------------------------*/

bool CMMCToolBarCtrlEx::IsIgnorableButton (int nButtonIndex)
{
    TBBUTTON tb;
    GetButton (nButtonIndex, &tb);

    return (::IsIgnorableButton (tb));
}

bool IsIgnorableButton (const TBBUTTON& tb)
{
    if (tb.fsStyle & TBSTYLE_SEP)
        return (true);

    if (tb.fsState & TBSTATE_HIDDEN)
        return (true);

    if (!(tb.fsState & TBSTATE_ENABLED))
        return (true);

    return (false);
}



/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::OnHotItemChange
 *
 * Reflected TBN_HOTITEMCHANGE handler for void CMMCToolBarCtrlEx.
 *--------------------------------------------------------------------------*/

void CMMCToolBarCtrlEx::OnHotItemChange (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);
    CToolbarTrackerAuxWnd*	pAuxWnd = GetMainAuxWnd();
	LPNMTBHOTITEM			ptbhi   = (LPNMTBHOTITEM) pHdr;

	Trace (tagToolbarAccessibility, _T("TBN_HOTITEMCHANGE: idOld=%d idNew=%d"), ptbhi->idOld, ptbhi->idNew);

    /*
     * if we're not in tracking mode, hot item change is OK
     */
    if (pAuxWnd == NULL)
        *pResult = 0;

    /*
     * if we're tracking, but this isn't the tracked toolbar,
     * the hot item change isn't OK
     */
    else if (!IsTrackingToolBar())
        *pResult = 1;

    /*
     * prevent mouse movement over empty portions of
     * the bar from changing the hot item
     */
    else
    {
        const DWORD dwIgnoreFlags = (HICF_MOUSE | HICF_LEAVING);
        *pResult = ((ptbhi->dwFlags & dwIgnoreFlags) == dwIgnoreFlags);
    }

	/*
	 * If we're allowing the hot item change while we're keyboard tracking
	 * the toolbar (to exclude changes due to mouse tracking), send a focus
	 * event so accessibility tools like Magnifier and Narrator can follow
	 * the change.  This fake-focus effect is undone in ScRestoreAccFocus.
	 */
	int idChild;
	if (IsTrackingToolBar()		&&
		(*pResult == 0)			&&
		(ptbhi->idNew != 0)		&&	
		((idChild = CommandToIndex(ptbhi->idNew)) != -1))
	{
		Trace (tagToolbarAccessibility, _T("Sending focus event for button %d"), idChild+1);
		NotifyWinEvent (EVENT_OBJECT_FOCUS, m_hWnd, OBJID_CLIENT, idChild+1 /*1-based*/);
		m_fFakeFocusApplied = true;
	}
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScInitAccessibility
 *
 * Creates the IAccPropServer object that will fool accessibility tools into
 * thinking that this toolbar really has the focus when we're in tracking
 * mode, even though it really doesn't
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScInitAccessibility ()
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScInitAccessibility"));

	/*
	 * if we've already initialized, just return
	 */
	if (m_spAccPropServices != NULL)
		return (sc);

	/*
	 * create a CLSID_AccPropServices provided by the MSAA runtime (oleacc.dll)
	 * This is a new feature in oleacc.dll, so trace failure as an informational
	 * message rather than an error.
	 */
	SC scNoTrace = m_spAccPropServices.CoCreateInstance (CLSID_AccPropServices);
	if (scNoTrace)
	{
#ifdef DBG
		TCHAR szErrorText[256];
		sc.GetErrorMessage (countof(szErrorText), szErrorText);
		StripTrailingWhitespace (szErrorText);

		Trace (tagToolbarAccessibility, _T("Failed to create CLSID_AccPropServices"));
		Trace (tagToolbarAccessibility, _T("SC = 0x%08X = %d = \"%s\""),
			   sc.GetCode(), LOWORD(sc.GetCode()), szErrorText);
#endif	// DBG

		return (sc);
	}

	sc = ScCheckPointers (m_spAccPropServices, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * create the property server
	 */
    sc = CTiedComObjectCreator<CMMCToolBarAccServer>::ScCreateAndConnect(*this, m_spAccPropServer);
	if (sc)
		return (sc);

	sc = ScCheckPointers (m_spAccPropServer, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * collect the properties we'll be providing, insuring there
	 * are no duplicates
	 */
	sc = ScInsertAccPropIDs (m_vPropIDs);
	if (sc)
		return (sc);

	std::sort (m_vPropIDs.begin(), m_vPropIDs.end());	// std::unique needs a sorted range
	m_vPropIDs.erase (std::unique (m_vPropIDs.begin(), m_vPropIDs.end()),
					  m_vPropIDs.end());

	/*
	 * insure m_vPropIDs contains no duplicates (IAccPropServices::SetHwndPropServer
	 * depends on it)
	 */
#ifdef DBG
	for (int i = 0; i < m_vPropIDs.size()-1; i++)
	{
		ASSERT (m_vPropIDs[i] < m_vPropIDs[i+1]);
	}
#endif

	/*
	 * Enable our property server for this window.  We should be able to
	 * hook all properties in one fell swoop, but there's a bug in oleacc.dll
	 * that prevents this.  Hooking the properties one at a time works fine.
	 */
#if 0
	sc = m_spAccPropServices->SetHwndPropServer (m_hWnd,
												 OBJID_CLIENT,
												 CHILDID_SELF,
												 m_vPropIDs.begin(),
												 m_vPropIDs.size(),
												 m_spAccPropServer,
												 ANNO_CONTAINER);
	if (sc)
	{
		Trace (tagToolbarAccessibility, _T("SetHwndPropServer failed"));
		return (sc);
	}
#else
	for (int i = 0; i < m_vPropIDs.size(); i++)
	{
		sc = m_spAccPropServices->SetHwndPropServer (m_hWnd,
													 OBJID_CLIENT,
													 CHILDID_SELF,
													 &m_vPropIDs[i],
													 1,
													 m_spAccPropServer,
													 ANNO_CONTAINER);
		if (sc)
		{
#ifdef DBG
			USES_CONVERSION;
			WCHAR wzPropID[40];
			StringFromGUID2 (m_vPropIDs[i], wzPropID, countof(wzPropID));
			Trace (tagToolbarAccessibility, _T("SetHwndPropServer failed for %s"), W2T(wzPropID));
#endif
			sc.TraceAndClear();	
		}
	}
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScInsertAccPropIDs
 *
 * Inserts the IDs of the accessibility properties supported by
 * CMMCToolBarCtrlEx (see ScGetPropValue).
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScInsertAccPropIDs (PropIDCollection& v)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScInsertAccPropIDs"));
	v.push_back (PROPID_ACC_STATE);
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScGetPropValue
 *
 * Implements IAccPropServer::GetPropValue for CMMCToolBarCtrlEx.  If this
 * funtion is asked for PROPID_ACC_STATE for the currently hot button while
 * we're in tracking mode, it'll return a state that mimics the state
 * returned by a plain toolbar when it really has the focus.
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScGetPropValue (
	const BYTE*	pIDString,
	DWORD		dwIDStringLen,
	MSAAPROPID	idProp,
	VARIANT *	pvarValue,
	BOOL *		pfGotProp)
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScGetPropValue"));

	sc = ScCheckPointers (pIDString, pvarValue, pfGotProp);
	if (sc)
		return (sc);

	/*
	 * assume no prop returned
	 */
	*pfGotProp      = false;
	V_VT(pvarValue) = VT_EMPTY;

	sc = ScCheckPointers (m_spAccPropServer, E_UNEXPECTED);	
	if (sc)
		return (sc);

	/*
	 * extract the child ID from the identity string
	 */
	HWND hwnd;
	DWORD idObject, idChild;
	sc = m_spAccPropServices->DecomposeHwndIdentityString (pIDString, dwIDStringLen,
														   &hwnd, &idObject, &idChild);
	if (sc)
		return (sc);

#ifdef DBG
	#define DEFINE_PDI(p)	PropDebugInfo (p, _T(#p))

	static const struct PropDebugInfo {
		// constructor used to get around nested structure initialization weirdness
		PropDebugInfo(const MSAAPROPID& id, LPCTSTR psz) : idProp(id), pszProp(psz) {}

		const MSAAPROPID&	idProp;
		LPCTSTR				pszProp;
	} rgpdi[] = {
		DEFINE_PDI (PROPID_ACC_NAME            ),
		DEFINE_PDI (PROPID_ACC_VALUE           ),
		DEFINE_PDI (PROPID_ACC_DESCRIPTION     ),
		DEFINE_PDI (PROPID_ACC_ROLE            ),
		DEFINE_PDI (PROPID_ACC_STATE           ),
		DEFINE_PDI (PROPID_ACC_HELP            ),
		DEFINE_PDI (PROPID_ACC_KEYBOARDSHORTCUT),
		DEFINE_PDI (PROPID_ACC_DEFAULTACTION   ),
		DEFINE_PDI (PROPID_ACC_HELPTOPIC       ),
		DEFINE_PDI (PROPID_ACC_FOCUS           ),
		DEFINE_PDI (PROPID_ACC_SELECTION       ),
		DEFINE_PDI (PROPID_ACC_PARENT          ),
		DEFINE_PDI (PROPID_ACC_NAV_UP          ),
		DEFINE_PDI (PROPID_ACC_NAV_DOWN        ),
		DEFINE_PDI (PROPID_ACC_NAV_LEFT        ),
		DEFINE_PDI (PROPID_ACC_NAV_RIGHT       ),
		DEFINE_PDI (PROPID_ACC_NAV_PREV        ),
		DEFINE_PDI (PROPID_ACC_NAV_NEXT        ),
		DEFINE_PDI (PROPID_ACC_NAV_FIRSTCHILD  ),
		DEFINE_PDI (PROPID_ACC_NAV_LASTCHILD   ),
		DEFINE_PDI (PROPID_ACC_VALUEMAP        ),
		DEFINE_PDI (PROPID_ACC_ROLEMAP         ),
		DEFINE_PDI (PROPID_ACC_STATEMAP        ),
	};

	/*
	 * dump the requested property
	 */
	for (int i = 0; i < countof(rgpdi); i++)
	{
		if (rgpdi[i].idProp == idProp)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: %s requested for child %d"), rgpdi[i].pszProp, idChild);
			break;
		}
	}

	if (i == countof(rgpdi))
	{
		USES_CONVERSION;
		WCHAR wzPropID[40];
		StringFromGUID2 (idProp, wzPropID, countof(wzPropID));
		Trace (tagToolbarAccessibility, _T("GetPropValue: Unknown property ID %s"), W2T(wzPropID));
	}

	/*
	 * insure m_vPropIDs is sorted (std::lower_bound depends on it)
	 */
	for (int i = 0; i < m_vPropIDs.size()-1; i++)
	{
		ASSERT (m_vPropIDs[i] < m_vPropIDs[i+1]);
	}
#endif

	/*
	 * if we're asked for a property we didn't claim to support, don't return
	 * anything
	 */
	if (m_vPropIDs.end() == std::lower_bound (m_vPropIDs.begin(), m_vPropIDs.end(), idProp))
	{
		Trace (tagToolbarAccessibility, _T("GetPropValue: Unexpected property request"));
		return (sc);
	}

	/*
	 * get the property
	 */
	sc = ScGetPropValue (hwnd, idObject, idChild, idProp, *pvarValue, *pfGotProp);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScGetPropValue
 *
 * Returns accessibility properties supported by CMMCToolBarCtrlEx.
 *
 * If a property is returned, fGotProp is set to true.  If it is not
 * returned, the value of fGotProp is unchanged, since the property might
 * have been provided by a base/derived class.
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScGetPropValue (
	HWND				hwnd,		// I:accessible window
	DWORD				idObject,	// I:accessible object
	DWORD				idChild,	// I:accessible child object
	const MSAAPROPID&	idProp,		// I:property requested
	VARIANT&			varValue,	// O:returned property value
	BOOL&				fGotProp)	// O:was a property returned?
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScGetPropValue"));

	/*
	 * handle requests for state
	 */
	if (idProp == PROPID_ACC_STATE)
	{
		/*
		 * only override the property for child elements, not the control itself;
		 * don't return a property
		 */
		if (idChild == CHILDID_SELF)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: no state for CHILDID_SELF"));
			return (sc);
		}

		/*
		 * if we're not in tracking mode, don't return a property
		 */
		if (!IsTrackingToolBar())
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: not in tracking mode, no state returned"));
			return (sc);
		}

		/*
		 * if the current hot item isn't the child we're asked for, don't return a property
		 */
		int nHotItem = GetHotItem();
		if (nHotItem != (idChild-1) /*0-based*/)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: hot item is %d, no state returned"), nHotItem);
			return (sc);
		}

		/*
		 * if we get here, we're asked for state for the current hot item;
		 * return STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED to match
		 * what a truly focused toolbar would return
		 */
		V_VT(&varValue) = VT_I4;
		V_I4(&varValue) = STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED | STATE_SYSTEM_FOCUSABLE;
		fGotProp        = true;
		Trace (tagToolbarAccessibility, _T("GetPropValue: Returning 0x%08x"), V_I4(&varValue));
	}

	return (sc);
}



/*+-------------------------------------------------------------------------*
 * CMMCToolBarCtrlEx::ScRestoreAccFocus
 *
 * Sends a fake EVENT_OBJECT_FOCUS event to send accessibility tools back
 * to the true focus window, undoing the effect of our fake focus events
 * in OnHotItemChange.
 *--------------------------------------------------------------------------*/

SC CMMCToolBarCtrlEx::ScRestoreAccFocus()
{
	DECLARE_SC (sc, _T("CMMCToolBarCtrlEx::ScRestoreAccFocus"));

	/*
	 * if we haven't applied fake-focus, we don't need to restore anything
	 */
	if (!m_fFakeFocusApplied)
		return (sc);

	/*
	 * who has the focus now?
	 */
	HWND hwndFocus = ::GetFocus();
	if (hwndFocus == NULL)
		return (sc);

	/*
	 * default to sending the focus for CHILDID_SELF
	 */
	int idChild = CHILDID_SELF;

	/*
	 * get the accessible object for the focus window (don't abort on
	 * failure -- don't convert this HRESULT to SC)
	 */
	CComPtr<IAccessible> spAccessible;
	HRESULT hr = AccessibleObjectFromWindow (hwndFocus, OBJID_CLIENT,
											 IID_IAccessible,
											 (void**) &spAccessible);

	if (hr == S_OK)		// not "SUCCEEDED(hr)", per Accessibility spec
	{
		/*
		 * ask the accessible object which
		 */
		CComVariant varFocusID;
		hr = spAccessible->get_accFocus (&varFocusID);

		if (hr == S_OK)		// not "SUCCEEDED(hr)", per Accessibility spec
		{
			switch (V_VT(&varFocusID))
			{
				case VT_I4:
					idChild = V_I4(&varFocusID);
					break;

				case VT_EMPTY:
					/*
					 * Windows thinks the window has the focus, but its
					 * IAccessible thinks it doesn't.  Trust Windows.
					 */
					Trace (tagToolbarAccessibility, _T("Windows and IAccessible::get_accFocus don't agree on who has the focus"));
					break;

				case VT_DISPATCH:
					Trace (tagToolbarAccessibility, _T("IAccessible::get_accFocus returned VT_DISPATCH, ignoring"));
					break;

				default:
					Trace (tagToolbarAccessibility, _T("IAccessible::get_accFocus returned unexpected VARIANT type (%d)"), V_VT(&varFocusID));
					break;
			}
		}
		else
		{
			Trace (tagToolbarAccessibility, _T("IAccessible::get_accFocus failed, hr=0x%08x"), hwndFocus, hr);
		}
	}
	else
	{
		Trace (tagToolbarAccessibility, _T("Can't get IAccessible from hwnd=0x%p (hr=0x%08x)"), hwndFocus, hr);
	}

	Trace (tagToolbarAccessibility, _T("Sending focus event back to hwnd=0x%p, idChild=%d"), hwndFocus, idChild);
	NotifyWinEvent (EVENT_OBJECT_FOCUS, hwndFocus, OBJID_CLIENT, idChild);
	m_fFakeFocusApplied = false;

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\childfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      childfrm.cpp
//
//  Contents:  Child frame implementation
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Add code to switch views
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"
#include "ChildFrm.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "treectrl.h"
#include "afxpriv.h"
#include "mainfrm.h"
#include "amcpriv.h"
#include "sysmenu.h"
#include "amcmsgid.h"
#include "caption.h"
#include "strings.h"
#include "menubtns.h"

bool CanCloseDoc(void);


/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_DESTROY()
    ON_WM_CLOSE()
    ON_WM_MDIACTIVATE()
    ON_COMMAND(ID_CUSTOMIZE_VIEW, OnCustomizeView)
    ON_WM_NCPAINT()
    ON_WM_NCACTIVATE()
    ON_WM_SYSCOMMAND()
    ON_WM_INITMENUPOPUP()
    //}}AFX_MSG_MAP

    ON_MESSAGE(WM_SETTEXT, OnSetText)
    ON_MESSAGE(WM_GETICON, OnGetIcon)
    ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString)
    ON_COMMAND_RANGE(ID_MMC_MAXIMIZE, ID_MMC_RESTORE, OnMaximizeOrRestore)
    ON_UPDATE_COMMAND_UI(ID_CUSTOMIZE_VIEW, OnUpdateCustomizeView)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
    m_pAMCView            = NULL;
    m_fDestroyed          = false;
    m_fCurrentlyMinimized = false;
    m_fCurrentlyActive    = false;
    m_fCreateVisible      = true;
	m_fEmptyAMCView		  = false;
}
	
CChildFrame::~CChildFrame()
{
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bSuccess=FALSE;

    // Let default implementation fill in most of the details
    if (!CMDIChildWnd::PreCreateWindow(cs))
        return (FALSE);

    // Remove the edge from the window so the splitter can paint it.
    cs.dwExStyle &=~WS_EX_CLIENTEDGE;

    WNDCLASS wc;
    LPCTSTR pszChildFrameClassName = g_szChildFrameClassName;

    if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
    {
        // Clear the H and V REDRAW flags
        wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
        wc.hIcon = AfxGetApp()->LoadIcon(IDR_AMCTYPE);
        wc.lpszClassName = pszChildFrameClassName;

        // Register this new style;
        bSuccess=AfxRegisterClass(&wc);
    }


    // Use the new child frame window class
    cs.lpszClass = pszChildFrameClassName;
    //cs.style &= ~FWS_ADDTOTITLE;

    // force maximized if in SDI User mode
    if (AMCGetApp()->GetMode() == eMode_User_SDI)
        cs.style |= WS_MAXIMIZE;

    // do not paint over the children
    cs.style |= WS_CLIPCHILDREN;

    return bSuccess;
}

/*+-------------------------------------------------------------------------*
 *
 * CChildFrame::OnUpdateFrameTitle
 *
 * PURPOSE: Sets the window title. It might be possible to short out this
 *          function.
 *
 * PARAMETERS:
 *    BOOL  bAddToTitle :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CChildFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    DECLARE_SC(sc,TEXT("CChildFrame::OnUpdateFrameTitle"));

    if ((GetStyle() & FWS_ADDTOTITLE) == 0)
        return;     // leave child window alone!

    CDocument* pDocument = GetActiveDocument();
    if (bAddToTitle && pDocument != NULL)
    {
        sc = ScCheckPointers(m_pAMCView, E_UNEXPECTED);
        if(sc)
            return;

        sc = ScCheckPointers(m_pAMCView->GetWindowTitle());
        if(sc)
            return;

        // set title if changed, but don't remove completely
        AfxSetWindowText(m_hWnd, m_pAMCView->GetWindowTitle());
    }

    // update our parent window last
    GetMDIFrame()->OnUpdateFrameTitle(bAddToTitle);
}

int CChildFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    static UINT anIndicators[] =
    {
        ID_SEPARATOR,           // status line indicator
        IDS_PROGRESS,           // place holder for progress bar
        IDS_STATUS_STATIC,      // place holder for static control
    };

    DECLARE_SC (sc, _T("CChildFrame::OnCreate"));

    if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
    {
        sc = E_UNEXPECTED;
        return -1;
    }

	/*
	 * status bar should be themed (block controls the scope of activator)
	 */
	{
		CThemeContextActivator activator;

		// Create the status bar and panes
		m_wndStatusBar.Create(this, WS_CHILD|WS_VISIBLE|SBARS_SIZEGRIP, 0x1003);
		m_wndStatusBar.CreatePanes(anIndicators, countof(anIndicators));
	}

    // Add the control to the dock site
    m_StatusDockSite.Create(CDockSite::DSS_BOTTOM);
    m_StatusDockSite.Attach(&m_wndStatusBar);
    m_StatusDockSite.Show();

    // Tell the dock manager about the site.
    m_DockingManager.Attach(&m_StatusDockSite);

    CAMCView* const pAMCView = GetAMCView();
    if (pAMCView == NULL)
    {
        sc = E_UNEXPECTED;
        return -1;
    }

    pAMCView->SetChildFrameWnd(m_hWnd);

    SViewData* pVD = pAMCView->GetViewData();
    if (NULL == pVD)
    {
        sc = E_UNEXPECTED;
        return -1;
    }

    // Create the menubuttons manager and toolbars manager (one per view).
    m_spMenuButtonsMgr = std::auto_ptr<CMenuButtonsMgrImpl>(new CMenuButtonsMgrImpl());
    if (NULL == m_spMenuButtonsMgr.get())
    {
        sc = E_UNEXPECTED;
        return -1;
    }

    // Let SViewData be aware of the CMenuButtonsMgr.
    pVD->SetMenuButtonsMgr(static_cast<CMenuButtonsMgr*>(m_spMenuButtonsMgr.get()));

    CMainFrame* pFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pFrame, E_UNEXPECTED);
    if (sc)
        return -1;

    ASSERT_KINDOF (CMainFrame, pFrame);

    // Init the CMenuButtonsMgr.
    sc = m_spMenuButtonsMgr->ScInit(pFrame, this);
    if (sc)
        return -1;

    // Create the Standard toolbar UI.
    pVD->m_spNodeManager->InitViewData(reinterpret_cast<LONG_PTR>(pVD));
    ASSERT(pVD->m_spVerbSet != NULL);

    AppendToSystemMenu (this, eMode_User_SDI);
    RenderDockSites();

    return 0;
}


void CChildFrame::RenderDockSites()
{
    CRect clientRect;
    GetClientRect(&clientRect);

    CWnd* pWnd=GetWindow(GW_CHILD);

    if(pWnd)
    {
        m_DockingManager.BeginLayout();
        m_DockingManager.RenderDockSites(pWnd->m_hWnd, clientRect);
        m_DockingManager.EndLayout();
    }

}


bool CChildFrame::IsCustomizeViewEnabled()
{
    bool fEnable = false;
    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    if (pDoc != NULL)
    {
        fEnable = (AMCGetApp()->GetMode() == eMode_Author) ||
                  pDoc->AllowViewCustomization();
    }

    return (fEnable);
}

void CChildFrame::OnUpdateCustomizeView(CCmdUI* pCmdUI)
{
    pCmdUI->Enable (IsCustomizeViewEnabled());
}

// Display Customize View dialog
// When a child window is maximized, then it becomes a CMainFrame so the handler is
// necessary here to process the Scope Pane command on the system menu
void CChildFrame::OnCustomizeView()
{
    CAMCView* pView = GetAMCView();

    if (pView != NULL)
    {
        INodeCallback*  pCallback = pView->GetNodeCallback();
        SViewData*      pViewData = pView->GetViewData();

        ASSERT (pCallback != NULL);
        ASSERT (pViewData != NULL);

        pCallback->OnCustomizeView (reinterpret_cast<LONG_PTR>(pViewData));
    }
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnInitMenuPopup
 *
 * WM_INITMENUPOPUP handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
    /*
     * Bug 201113:  don't allow child system menus in SDI mode
     */
    if (bSysMenu && (AMCGetApp()->GetMode() == eMode_User_SDI))
    {
        SendMessage (WM_CANCELMODE);
        return;
    }

    CMDIChildWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);

    /*
     * CFrameWnd::OnInitMenuPopup doesn't do UI updates for system menus,
     * so we have to do it here
     */
    if (bSysMenu)
    {
        int nEnable = IsCustomizeViewEnabled() ? MF_ENABLED : MF_GRAYED;
        pPopupMenu->EnableMenuItem (ID_CUSTOMIZE_VIEW, MF_BYCOMMAND | nEnable);
    }
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSize
 *
 * WM_SIZE handler for CChildFrame.
 *--------------------------------------------------------------------------*/
void CChildFrame::OnSize(UINT nType, int cx, int cy)
{
    DECLARE_SC(sc, TEXT("CChildFrame::OnSize"));

    // bypass CMDIChildWnd::OnSize so we won't get MFC's docking stuff
    // (we still need to call Default so Windows' MDI stuff will work right)
    CWnd::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
    {
        RenderDockSites();
        CAMCView* pAMCView = GetAMCView();
        ASSERT (pAMCView != NULL);

        if (pAMCView)
            pAMCView->AdjustTracker (cx, cy);
    }


    // update our parent frame - in case we are now maximized or not
    CMDIFrameWnd*   pwndMDIFrame = GetMDIFrame();

    if (pwndMDIFrame)
        pwndMDIFrame->OnUpdateFrameTitle(TRUE);

    /*
     * If we're moving to or from the minimized state, notify snap-ins.
     * We don't need to send the notification if we're only creating a
     * temporary view that will never be shown.
     */
    if (m_fCurrentlyMinimized != (nType == SIZE_MINIMIZED) && m_fCreateVisible)
    {
        m_fCurrentlyMinimized = (nType == SIZE_MINIMIZED);
        SendMinimizeNotification (m_fCurrentlyMinimized);
    }

    // send the size notification to the view.
    if(GetAMCView())
    {
        sc = GetAMCView()->ScOnSize(nType, cx, cy);
        if(sc)
            return;
    }

}

BOOL CChildFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext)
{
    if (pParentWnd == NULL)
    {
        CWnd* pMainWnd = AfxGetThread()->m_pMainWnd;
        ASSERT(pMainWnd != NULL);
        ASSERT_KINDOF(CMDIFrameWnd, pMainWnd);
        pParentWnd = (CMDIFrameWnd*)pMainWnd;
    }
    ASSERT(::IsWindow(pParentWnd->m_hWndMDIClient));

    // first copy into a CREATESTRUCT for PreCreate
    CREATESTRUCT cs;
    cs.dwExStyle = 0L;
    cs.lpszClass = lpszClassName;
    cs.lpszName = lpszWindowName;
    cs.style = dwStyle;
    cs.x = rect.left;
    cs.y = rect.top;
    cs.cx = rect.right - rect.left;
    cs.cy = rect.bottom - rect.top;
    cs.hwndParent = pParentWnd->m_hWnd;
    cs.hMenu = NULL;
    cs.hInstance = AfxGetInstanceHandle();
    cs.lpCreateParams = (LPVOID)pContext;

    if (!PreCreateWindow(cs))
    {
        PostNcDestroy();
        return FALSE;
    }
    // extended style must be zero for MDI Children (except under Win4)
//  ASSERT(afxData.bWin4 || cs.dwExStyle == 0);
    ASSERT(cs.hwndParent == pParentWnd->m_hWnd);    // must not change

    // now copy into a MDICREATESTRUCT for real create
    MDICREATESTRUCT mcs;
    mcs.szClass = cs.lpszClass;
    mcs.szTitle = cs.lpszName;
    mcs.hOwner = cs.hInstance;
    mcs.x = cs.x;
    mcs.y = cs.y;
    mcs.cx = cs.cx;
    mcs.cy = cs.cy;
    mcs.style = cs.style & ~(WS_MAXIMIZE | WS_VISIBLE);
    mcs.lParam = reinterpret_cast<LPARAM>(cs.lpCreateParams);

    // create the window through the MDICLIENT window
    AfxHookWindowCreate(this);
    HWND hWnd = (HWND)::SendMessage(pParentWnd->m_hWndMDIClient,
        WM_MDICREATE, 0, (LPARAM)&mcs);
    if (!AfxUnhookWindowCreate())
        PostNcDestroy();        // cleanup if MDICREATE fails too soon

    if (hWnd == NULL)
        return FALSE;

    // special handling of visibility (always created invisible)
    if (cs.style & WS_VISIBLE)
    {
        // place the window on top in z-order before showing it
        ::BringWindowToTop(hWnd);

        // show it as specified
        if (cs.style & WS_MINIMIZE)
            ShowWindow(SW_SHOWMINIMIZED);
        else if (cs.style & WS_MAXIMIZE)
            ShowWindow(SW_SHOWMAXIMIZED);
        else
            ShowWindow(SW_SHOWNORMAL);

        // make sure it is active (visibility == activation)
        pParentWnd->MDIActivate(this);

        // refresh MDI Window menu
        ::SendMessage(pParentWnd->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
    }

    ASSERT(hWnd == m_hWnd);
    return TRUE;
}

void CChildFrame::OnDestroy()
{
    // NOTE - The un-hooking of the dock manager stops the rebar sending a height change
    // when the rebar goes away.
    m_DockingManager.RemoveAll();

    m_fDestroyed = true;

    CMDIChildWnd::OnDestroy();
}

void CChildFrame::OnMaximizeOrRestore(UINT nID)
{
    ASSERT(nID == ID_MMC_MAXIMIZE || nID == ID_MMC_RESTORE);

    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    GetWindowPlacement(&wp);

    UINT newShowCmd = (nID == ID_MMC_MAXIMIZE) ? SW_SHOWMAXIMIZED : SW_SHOWNORMAL;

    if (wp.showCmd != newShowCmd)
    {
       wp.showCmd = newShowCmd;
       SetWindowPlacement(&wp);
    }
}


void CChildFrame::OnClose()
{
    CAMCDoc* pDoc = CAMCDoc::GetDocument();
    ASSERT(pDoc != NULL);
    if (pDoc)
    {
        int cViews = 0;
        CAMCViewPosition pos = pDoc->GetFirstAMCViewPosition();
        while (pos != NULL)
        {
            CAMCView* pView = pDoc->GetNextAMCView(pos);

            if ((pView != NULL) && ++cViews >= 2)
                break;
        }

        if (cViews == 1)
        {
            if (!CanCloseDoc())
                return;
        }
        else
        {
            // if not closing last view, then give it
            // a chance to clean up first.
            // (if whole doc is closing CAMCDoc will handle
            //  closing all the views.)
            CAMCView* pView = GetAMCView();
            if (pView != NULL)
            {
                CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();

                /*
                 * Don't allow the user to close the last persisted view.
                 */
                if (pView->IsPersisted() &&
                    (pAMCDoc != NULL) &&
                    (pAMCDoc->GetNumberOfPersistedViews() == 1))
                {
                    MMCMessageBox (IDS_CantCloseLastPersistableView);
                    return;
                }

                pView->CloseView();
            }
        }
    }

    CMDIChildWnd::OnClose();
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnUpdateFrameMenu
 *
 * WM_UPDATEFRAMEMENU handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnUpdateFrameMenu(BOOL bActivate, CWnd* pActivateWnd,
    HMENU hMenuAlt)
{
    ASSERT_VALID (this);
    DECLARE_SC (sc, _T("CChildFrame::OnUpdateFrameMenu"));

    // let the base class select the right menu
    CMDIChildWnd::OnUpdateFrameMenu (bActivate, pActivateWnd, hMenuAlt);

    // make sure the child has the WS_SYSMENU bit
    // (it won't if it's created maximized)
    ModifyStyle (0, WS_SYSMENU);

    // by now, the right menu is selected; reflect it to the toolbar
    CMainFrame* pFrame = static_cast<CMainFrame *>(GetParentFrame ());
    ASSERT_KINDOF (CMainFrame, pFrame);
    pFrame->NotifyMenuChanged ();

    // Add the menubuttons only on activate, the CMenubar
    // removes all menus during deactivate.
    if (bActivate)
    {
        ASSERT(NULL != m_spMenuButtonsMgr.get());
        if (NULL != m_spMenuButtonsMgr.get())
        {
            // Now add the menu buttons to main menu
            sc = m_spMenuButtonsMgr->ScAddMenuButtonsToMainMenu();
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnGetIcon
 *
 * WM_GETICON handler for CChildFrame.
 *
 * NOTE: the control over the icon remains with the callee - it is responsible
 *       for releasing the resource. Coller should never release the returned
 *       handle
 *--------------------------------------------------------------------------*/

LRESULT CChildFrame::OnGetIcon (WPARAM wParam, LPARAM lParam)
{
    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    /*
     * use the custom icon if we have one
     */
    if ((pDoc != NULL) && pDoc->HasCustomIcon())
        return ((LRESULT) pDoc->GetCustomIcon ((wParam == ICON_BIG)));

    /*
     * no custom icon, use the default icon
     */
    const int cxIcon = GetSystemMetrics ((wParam == ICON_BIG) ? SM_CXICON : SM_CXSMICON);
    const int cyIcon = GetSystemMetrics ((wParam == ICON_BIG) ? SM_CYICON : SM_CYSMICON);

    // use cached copy - it never changes
    // do not delete this ever - since we only have one copy,
    // we do not leak. releassing is expensive and does not pay off
    static HICON s_hMMCIcon = (HICON)::LoadImage (AfxGetResourceHandle(),
                                                  MAKEINTRESOURCE (IDR_AMCTYPE),
                                                  IMAGE_ICON, cxIcon, cyIcon, 0);

    return (LRESULT)s_hMMCIcon;
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSysCommand
 *
 * WM_SYSCOMMAND handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID)
    {
        case ID_CUSTOMIZE_VIEW:
            OnCustomizeView();
            break;

        case SC_CLOSE:
        {
			// windows bug#470429(9/24/2001)
			// do extra check only if it is worth keeping the window
			if ( !m_fEmptyAMCView )
			{
				// eat Ctrl+F4 in SDI simulation mode...
				if (AMCGetApp()->GetMode() == eMode_User_SDI)
					break;

				// ...or if Close is disabled or doesn't exist on the system menu
				CMenu*  pSysMenu    = GetSystemMenu (FALSE);
				UINT    nCloseState = pSysMenu->GetMenuState (SC_CLOSE, MF_BYCOMMAND);

				if ((nCloseState == 0xFFFFFFFF) ||
					(nCloseState & (MF_GRAYED | MF_DISABLED)))
					break;
			}

            // all systems go, let MDI have it
            CMDIChildWnd::OnSysCommand(nID, lParam);
            break;
        }

        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
            // eat Ctrl+(Shift+)Tab and Ctrl+(Shift+)F6 in SDI simulation mode
            if (AMCGetApp()->GetMode() != eMode_User_SDI)
                CMDIChildWnd::OnSysCommand(nID, lParam);
            break;

        default:
            CMDIChildWnd::OnSysCommand(nID, lParam);
            break;
    }

}

/*+-------------------------------------------------------------------------*
 * CChildFrame::GetDefaultAccelerator
 *
 *
 *--------------------------------------------------------------------------*/

HACCEL CChildFrame::GetDefaultAccelerator()
{
    // use document specific accelerator table ONLY
    // Dont use CFrameWnd::m_hAccel, because we don't base accelerators
    // on document type but rather on mode. This is taken care of
    // in CAMCDoc.
    return (NULL);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSetMessageString
 *
 * WM_SETMESSAGESTRING handler for CChildFrame.
 *--------------------------------------------------------------------------*/

LRESULT CChildFrame::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
    /*
     * if this we're going to set the idle message string and we've
     * been given a custom status line string, use that one instead
     */
    if ((wParam == AFX_IDS_IDLEMESSAGE) && !m_strStatusText.IsEmpty())
    {
        ASSERT (lParam == 0);
        wParam = 0;
        lParam = (LPARAM)(LPCTSTR) m_strStatusText;
    }

    // sometimes we'll get a WM_SETMESSAGESTRING after being destroyed,
    // don't pass it through or we'll crash inside the status bar code
    if (m_fDestroyed)
        return (0);

    return (CMDIChildWnd::OnSetMessageString (wParam, lParam));
}

void CChildFrame::ToggleStatusBar ()
{
    m_StatusDockSite.Toggle();
    RenderDockSites();

    if (m_StatusDockSite.IsVisible())
        UpdateStatusText ();
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnMDIActivate
 *
 * WM_MDIACTIVATE handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd)
{
    DECLARE_SC (sc, _T("CChildFrame::OnMDIActivate"));
    SetChildFrameActive(bActivate);

    CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

    sc = ScCheckPointers(m_pAMCView, E_UNEXPECTED);
    if (sc)
        return;

    if (bActivate)
    {
        // If the window being de-activated is not of childframe type then this
        // is the first active view (childframe).
        bool bFirstActiveView = pDeactivateWnd ? (FALSE == pDeactivateWnd->IsKindOf (RUNTIME_CLASS (CChildFrame)))
                                               : true;
        sc = m_pAMCView->ScFireEvent(CAMCViewObserver::ScOnActivateView, m_pAMCView, bFirstActiveView);

        // if activation changes - need to set frame to dirty
        CAMCDoc* pDoc = CAMCDoc::GetDocument ();

        if (pDoc == NULL)
            (sc = E_UNEXPECTED).TraceAndClear();
        else
        {
            pDoc->SetFrameModifiedFlag (true);
        }
    }
    else
    {
        // If the window being activated is not of childframe type then this is
        // the last active view (childframe).
        bool bLastActiveView = pActivateWnd ? (FALSE == pActivateWnd->IsKindOf (RUNTIME_CLASS (CChildFrame)))
                                            : true;
        sc = m_pAMCView->ScFireEvent(CAMCViewObserver::ScOnDeactivateView, m_pAMCView, bLastActiveView);
    }

    if (sc)
        return;

    /*
     * Notify snap-ins of an activation change
     */
    NotifyCallback (NCLBK_ACTIVATE, bActivate, 0);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::SendMinimizeNotification
 *
 *
 *--------------------------------------------------------------------------*/

void CChildFrame::SendMinimizeNotification (bool fMinimized) const
{
        if(m_pAMCView != NULL)
            m_pAMCView->ScOnMinimize(m_fCurrentlyMinimized);

}


/*+-------------------------------------------------------------------------*
 * CChildFrame::NotifyCallback
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CChildFrame::NotifyCallback (
    NCLBK_NOTIFY_TYPE   event,
    LONG_PTR            arg,
    LPARAM              param) const
{
    if (m_pAMCView == NULL)
        return (E_FAIL);

    HNODE hNode = m_pAMCView->GetSelectedNode();

    if (hNode == NULL)
        return (E_FAIL);

    INodeCallback*  pNodeCallback = m_pAMCView->GetNodeCallback();

    if (pNodeCallback == NULL)
        return (E_FAIL);

    return (pNodeCallback->Notify (hNode, event, arg, param));
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnNcPaint
 *
 * WM_NCPAINT handler for CChildFrame.
 *--------------------------------------------------------------------------*/

void CChildFrame::OnNcPaint()
{
    Default();
    DrawFrameCaption (this, m_fCurrentlyActive);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnNcActivate
 *
 * WM_NCACTIVATE handler for CChildFrame.
 *--------------------------------------------------------------------------*/

BOOL CChildFrame::OnNcActivate(BOOL bActive)
{
    BOOL rc = CMDIChildWnd::OnNcActivate(bActive);

    m_fCurrentlyActive = bActive;
    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::OnSetText
 *
 * WM_SETTEXT handler for CChildFrame.
 *--------------------------------------------------------------------------*/

LRESULT CChildFrame::OnSetText (WPARAM wParam, LPARAM lParam)
{
    LRESULT rc = Default();
    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::ActivateFrame
 *
 *
 *--------------------------------------------------------------------------*/

void CChildFrame::ActivateFrame(int nCmdShow /*= -1*/)
{
    if ((nCmdShow == -1) && !m_fCreateVisible)
        nCmdShow = SW_SHOWNOACTIVATE;
    /*
     * When this flag [m_fCreateVisible] is set, the frame will show itself with the
     * SW_SHOWMINNOACTIVE flag instead of the default flag.  Doing this will
     * avoid the side effect of restoring the currently active child frame
     * if it is maximized at the time the new frame is created invisibly.
     */
    // The SW_SHOWMINNOACTIVE was changed to SW_SHOWNOACTIVATE.
    // It does preserve the active window from mentioned side effect,
    // plus it also allows scripts (using Object Moded) to create invisible views,
    // position and then show them as normal (not minimized) windows,
    // thus providing same result as creating visible and then hiding the view.
    // While minimized window must be restored first in order to change their position.

    CMDIChildWnd::ActivateFrame (nCmdShow);
}


/*+-------------------------------------------------------------------------*
 * CChildFrame::SetCreateVisible
 *
 *
 *--------------------------------------------------------------------------*/

bool CChildFrame::SetCreateVisible (bool fCreateVisible)
{
    bool fOldState = m_fCreateVisible;
    m_fCreateVisible = fCreateVisible;

    return (fOldState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\cclvctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cclvctl.cpp
//
//--------------------------------------------------------------------------

// cclvctl.cpp : implementation file
//

#include "stdafx.h"
#include "cclvctl.h"
#include <malloc.h>
#include <wtypes.h>
#include "amcdoc.h"
#include "amcview.h"
#include "mmcres.h"
#include "treectrl.h"
#include "util.h"
#include "amcpriv.h"
#include "rsltitem.h"
#include "columninfo.h"
#include "bitmap.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//############################################################################
//############################################################################
//
// Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagList(TEXT("List View"), TEXT("List View"));
CTraceTag tagListImages(_T("Images"), _T("List view (draw when changed)"));
CTraceTag tagColumn(TEXT("Columns"), TEXT("Columns"));
#endif //DBG



DEBUG_DECLARE_INSTANCE_COUNTER(CAMCListView);


//############################################################################
//############################################################################
//
//  Implementation of class CColumnsBase
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CColumnsBase
 *
 *
 * PURPOSE: Implements the Columns automation interface.
 *
 *+-------------------------------------------------------------------------*/
class CColumnsBase :
    public CMMCIDispatchImpl<Columns>,
    public CTiedComObject<CCCListViewCtrl>,
    public CTiedObject      // this is for enumerators
{
public:
    typedef CCCListViewCtrl CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CColumnsBase)
    END_MMC_COM_MAP()

    // Columns interface
public:
    MMC_METHOD2(Item,           long /*Index*/, PPCOLUMN /*ppColumn*/);

    // properties
    MMC_METHOD1(get_Count, PLONG /*pCount*/);
};


// this typedefs the real CColumns class. Implements get__NewEnum using CMMCEnumerator
typedef CMMCNewEnumImpl<CColumnsBase, int> CColumns;


/*+-------------------------------------------------------------------------*
 * class CColumn
 *
 *
 * PURPOSE: Implements the Node automation interface, for a result node
 *
 *+-------------------------------------------------------------------------*/
class CColumn :
    public CMMCIDispatchImpl<Column>,
    public CTiedComObject<CCCListViewCtrl>,
    public CListViewObserver
{
protected:

    typedef CCCListViewCtrl CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CColumn)
    END_MMC_COM_MAP()

    // Column methods
public:
    MMC_METHOD1_PARAM( Name, /*[out, retval]*/ BSTR* /*Name*/ , m_iIndex);
    MMC_METHOD1_PARAM( get_Width, /*[out, retval]*/ PLONG /*Width*/, m_iIndex);
    MMC_METHOD1_PARAM( put_Width, /*[in]*/ long /*Width*/, m_iIndex);
    MMC_METHOD1_PARAM( get_DisplayPosition, /*[out, retval]*/ PLONG /*DisplayPosition*/, m_iIndex);
    MMC_METHOD1_PARAM( put_DisplayPosition, /*[in]*/ long /*Index*/, m_iIndex);
    MMC_METHOD1_PARAM( get_Hidden, /*[out, retval]*/ PBOOL /*Hidden*/, m_iIndex );
    MMC_METHOD1_PARAM( put_Hidden, /*[in]*/ BOOL /*Hidden*/ , m_iIndex );
    MMC_METHOD1_PARAM( SetAsSortColumn, /*[in]*/ ColumnSortOrder /*SortOrder*/, m_iIndex);
    MMC_METHOD1_PARAM( IsSortColumn, PBOOL /*IsSortColumn*/, m_iIndex);

    CColumn() : m_iIndex(-1)  { }
    void SetIndex(int iIndex) { m_iIndex = iIndex; }

    // observed events
    // called when column is inserted to listview
    virtual ::SC ScOnListViewColumnInserted (int nIndex);
    // called when column is deleted from listview
    virtual ::SC ScOnListViewColumnDeleted (int nIndex);

private: // implementation
    int  m_iIndex;
};

/////////////////////////////////////////////////////////////////////////////
// CAMCHeaderCtrl
// This class is defined just to intercept the header's set focus

BEGIN_MESSAGE_MAP(CAMCHeaderCtrl, CHeaderCtrl)
    ON_WM_SETFOCUS()
	ON_WM_SETCURSOR()
END_MESSAGE_MAP()

void CAMCHeaderCtrl::OnSetFocus(CWnd *pOldWnd)
{
    // Make sure list view is made active, but don't steal focus from header
    CAMCListView* pwndParent = dynamic_cast<CAMCListView*>(GetParent());
    ASSERT(pwndParent != NULL);
    pwndParent->GetParentFrame()->SetActiveView(pwndParent, FALSE);

    CHeaderCtrl::OnSetFocus(pOldWnd);
}

//+-------------------------------------------------------------------
//
//  Member:     CAMCHeaderCtrl::OnSetCursor
//
//  Synopsis:   If the cursor is on hidden column do not show the divider
//              cursor. WM_SETCURSOR handler.
//
//  Arguments:  [pWnd]     - window which generated the message.
//              [nHitTest] - hittest flag.
//              [message]  -
//
//  Returns:    BOOL, TRUE stop processing further.
//
//--------------------------------------------------------------------
BOOL CAMCHeaderCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    // 1. If the mouse is on the header window.
	if ( (nHitTest == HTCLIENT) && (pWnd == this) )
	{
        // 2. Get its position.
		CPoint pt (GetMessagePos());
		ScreenToClient (&pt);

        // 3. Do a hit test
		HDHITTESTINFO hitinfo;
		ZeroMemory(&hitinfo, sizeof(hitinfo));
		hitinfo.pt = pt;

		if (SendMessage(HDM_HITTEST, 0, reinterpret_cast<LPARAM>(&hitinfo) ) != -1)
		{
            // 4. If the mouse is on a column of zero width and it is hidden do not
            //    process the message further.

            // 4.a) HHT_ONDIVOPEN : pt is on the divider of an item that has a width of zero.
            //   b) HHT_ONDIVIDER : pt is on the divider between two header items.
		    if ( ( (HHT_ONDIVOPEN | HHT_ONDIVIDER) & hitinfo.flags) &&
				 (IsColumnHidden(hitinfo.iItem /*column index*/)) )
			{
                // Set default arrow cursor.
                ::SetCursor(::LoadCursor(NULL, IDC_ARROW) );
				return TRUE;
			}
		}

	}

    return CHeaderCtrl::OnSetCursor(pWnd, nHitTest, message);
}

//+-------------------------------------------------------------------
//
//  Member:     CAMCHeaderCtrl::IsColumnHidden
//
//  Synopsis:   Is the given column hidden?
//
//  Arguments:  [iCol]     - given column
//
//  Returns:    bool
//
//--------------------------------------------------------------------
bool CAMCHeaderCtrl::IsColumnHidden(int iCol)
{
    // Get param to determine if column is hidden.
    HDITEM hdItem;
    ZeroMemory(&hdItem, sizeof(hdItem));
    hdItem.mask    = HDI_LPARAM;

    if (GetItem(iCol, &hdItem))
	{
		CHiddenColumnInfo hci (hdItem.lParam);

		if (hci.fHidden)
			return true;
	}
	
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// CAMCListView

const UINT CAMCListView::m_nColumnPersistedDataChangedMsg   = ::RegisterWindowMessage (_T("CAMCListView::OnColumnPersistedDataChanged"));

BEGIN_MESSAGE_MAP(CAMCListView, CListView)
    //{{AFX_MSG_MAP(CAMCListView)
    ON_WM_CREATE()
    ON_WM_KEYUP()
    ON_WM_KEYDOWN()
    ON_WM_SYSKEYDOWN()
    ON_WM_SYSCHAR()
    ON_NOTIFY_REFLECT(LVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(LVN_BEGINRDRAG, OnBeginRDrag)
    ON_WM_MOUSEACTIVATE()
    ON_WM_SETFOCUS()
    ON_WM_PAINT()
    ON_WM_SIZE()
    ON_NOTIFY(HDN_BEGINTRACK, 0, OnBeginTrack)
    //}}AFX_MSG_MAP

    ON_REGISTERED_MESSAGE (m_nColumnPersistedDataChangedMsg, OnColumnPersistedDataChanged)

END_MESSAGE_MAP()

BOOL CAMCListView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |= WS_BORDER |
                WS_CLIPSIBLINGS |
                WS_CLIPCHILDREN |
                LVS_SHAREIMAGELISTS |
                LVS_SINGLESEL |
                LVS_EDITLABELS |
                LVS_SHOWSELALWAYS |
                LVS_REPORT;

    return CListView::PreCreateWindow(cs);
}

int CAMCListView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, TEXT("CAMCListView::OnCreate"));

    if (CListView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // Get parent's CWnd for command routing
    m_pAMCView = ::GetAMCView (this);

    /*
     * add extended list view styles (these can't be handled in PreCreateWindow)
     */
    SetExtendedListViewStyle (LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP |
                              LVS_EX_LABELTIP);

    sc = ScRegisterAsDropTarget(m_hWnd);
    if (sc)
        return (-1);

	AddObserver(static_cast<CListViewActivationObserver &>(*m_pAMCView));

    return 0;
}

void CAMCListView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if ((VK_CONTROL == nChar) || (VK_SHIFT == nChar))
    {
        ASSERT (m_pAMCView != NULL);
        m_pAMCView->SendMessage (WM_KEYUP, nChar, MAKELPARAM (nRepCnt, nFlags));
        return;
    }

    CListView::OnKeyUp(nChar, nRepCnt, nFlags);
}

//+-------------------------------------------------------------------
//
//  Member:     OnKeyDown
//
//  Synopsis:   Handle any non-system keys (Without ALT).
//              (Below handle Ctrl+A to multi-select
//               all items in list view).
//
//  Arguments:
//
//  Returns:    None.
//
//
//--------------------------------------------------------------------
void CAMCListView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar)
    {
    case 'A':
    {
        // Check if LV is multi-sel enabled.
		if (GetStyle() & LVS_SINGLESEL)
			break;

        SHORT nKeyState = GetKeyState(VK_CONTROL);
        // Key is down if higher order bits are set in nKeyState.
        nKeyState = nKeyState >> sizeof(SHORT) * 4;
        if (nKeyState == 0)
            break;

        // Ctrl+A --> Select all items in list view.
        LV_ITEM lvi;
        lvi.stateMask = lvi.state = LVIS_SELECTED;
        // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists

        // (wparam = -1) => Message applies to all items.
        // This gives better performance than iterating through all items
        // sending a separate LVM_SETITEMSTATE for each. RAID# 595783
        if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(-1), (LPARAM)(LV_ITEM FAR *)&lvi)) 
            return;
    }

    default:
        break;
    }

    CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCListView::OnSysKeyDown
 *
 * PURPOSE: Handle the WM_SYSCHAR message.
 *
 * PARAMETERS:
 *    UINT  nChar :
 *    UINT  nRepCnt :
 *    UINT  nFlags :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCListView::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if ((VK_LEFT == nChar) || (VK_RIGHT == nChar))
    {
        ASSERT (m_pAMCView != NULL);
        m_pAMCView->SendMessage (WM_SYSKEYDOWN, nChar, MAKELPARAM (nRepCnt, nFlags));
        return;
    }

    CListView::OnSysKeyDown(nChar, nRepCnt, nFlags);
}


void CAMCListView::OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (VK_RETURN == nChar)
    {
        return; // don't call base class, otherwise a beep occurs. Handled by LVN_KEYDOWN
    }


    CListView::OnSysChar(nChar, nRepCnt, nFlags);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCListView::OnPaint
 *
 * PURPOSE: Displays a default message when no items are present in the list.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCListView::OnPaint()
{
    Default();

    if (NeedsCustomPaint())
    {
        COLORREF clrText = ::GetSysColor(COLOR_WINDOWTEXT);
        COLORREF clrTextBk = ::GetSysColor(COLOR_WINDOW);

        CClientDC dc(this);
        // Save dc state
        int nSavedDC = dc.SaveDC();

        CRect rc;
        GetClientRect(&rc);

        CHeaderCtrl* pHC = GetHeaderCtrl();
        if (pHC != NULL &&  ((GetListCtrl().GetStyle() & (LVS_REPORT | LVS_LIST | LVS_SMALLICON | LVS_ICON)) ==LVS_REPORT) ) // make sure that the style is report
        {
            CRect rcH;
            pHC->GetItemRect(0, &rcH);
            rc.top += rcH.bottom;
        }
        rc.top += 10;

        CString strText;
        strText.LoadString(IDS_EMPTY_LIST_MESSAGE); // The message

        // create the font - we do not cache it.
        LOGFONT lf;
        CFont font;
        SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);
        font.CreateFontIndirect(&lf);

        dc.SelectObject(&font); // select the font
        dc.SetTextColor(clrText);
        dc.SetBkColor(clrTextBk);
        dc.FillRect(rc, &CBrush(clrTextBk));

        dc.DrawText(strText, -1, rc, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_NOCLIP);

        // Restore dc
        dc.RestoreDC(nSavedDC);
    }

    // Do not call CListCtrl::OnPaint() for painting messages (Default was called above)
}



/*+-------------------------------------------------------------------------*
 * CAMCListView::OnSize
 *
 * WM_SIZE handler for CAMCListView.
 *--------------------------------------------------------------------------*/

void CAMCListView::OnSize(UINT nType, int cx, int cy)
{
        CListView::OnSize(nType, cx, cy);

        /*
         * if we're custom painting, we need to redraw the list
         * because we need to keep the text horizontally centered
         */
        if (NeedsCustomPaint())
                Invalidate ();
}


/*+-------------------------------------------------------------------------*
 * CAMCListView::NeedsCustomPaint
 *
 * Determines whether we want to draw "There are no items..." in the list
 * view.
 *--------------------------------------------------------------------------*/

bool CAMCListView::NeedsCustomPaint()
{
    CHeaderCtrl* pHC = GetHeaderCtrl();

        // we check the column counts because there is a transition state when no columns are
        // present during which we shouldn't draw anything.

    return (GetListCtrl().GetItemCount() <= 0 && (pHC != NULL) && pHC->GetItemCount()>0);
}


BOOL CAMCListView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (CListView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view did't handle it, give parent view a chance
    if (m_pAMCView != NULL)
    {
        // OnCmdMsg is public in CCmdTarget, but protected in CView
        // cast around it (arghhh!)
        return ((CWnd*)m_pAMCView)->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    }

    return FALSE;
}

int CAMCListView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
    // see CAMCTreeView::OnMouseActivate for an explanation of focus churn
    // avoidance.
    return (MA_ACTIVATE);
}

void CAMCListView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    DECLARE_SC(sc, TEXT("CAMCListView::OnActivateView"));

    #ifdef DBG
    Trace(tagList, _T("ListView::OnActivateView (%s, pAct=0x%08x, pDeact=0x%08x))\n"),
         (bActivate) ? _T("true") : _T("false"), pActivateView, pDeactiveView);
    #endif

    if ( (pActivateView != pDeactiveView) &&
         (bActivate) )
    {
        sc = ScFireEvent(CListViewActivationObserver::ScOnListViewActivated);
        if (sc)
            sc.TraceAndClear();
    }

    CListView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

void CAMCListView::OnSetFocus(CWnd* pOldWnd)
{
    /*
     * if this view has the focus, it should be the active view
     */
    CFrameWnd *pParentFrame = GetParentFrame();

    if(pParentFrame != NULL)
        pParentFrame->SetActiveView (this);

    CListView::OnSetFocus(pOldWnd);

    // If we are currently reparented, then we need to send a setfocus notify
    // to our current parent. This is needed because the listview control caches its
    // parent window on creation and continues to sends all notifications to it.
    if (dynamic_cast<CAMCView*>(GetParent()) == NULL)
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = m_hWnd;
        nmhdr.idFrom   = GetDlgCtrlID();
        nmhdr.code     = NM_SETFOCUS;

        ::SendMessage(GetParent()->m_hWnd, WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCListView::OnKeyboardFocus
 *
 * PURPOSE: Whenever the user switches focus using the TAB keys ONLY, to the
 *          list view control, make sure that at least one item is highlighted.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCListView::OnKeyboardFocus(UINT nState, UINT nStateMask)
{
    CListCtrl &lc = GetListCtrl();

    // Make sure an item has the focus (unless the list is empty)
    if (lc.GetNextItem(-1,LVNI_FOCUSED) == -1 && lc.GetItemCount() > 0)
    {
        /*
         * It would be convenient to use
         *
         *      CListCtrl::SetItemState (int nIndex, UINT nState, UINT nMask)
         *
         * here, but MFC uses LVM_SETITEM for that overload, which
         * doesn't work for virtual lists.  For the overload we use
         * here, MFC uses LVM_SETITEMSTATE, which works fine for
         * virtual lists.
         */
        LV_ITEM lvi;
        lvi.stateMask = nStateMask;
        lvi.state     = nState;

        lc.SetItemState (0, &lvi);
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::OnBeginTrack
//
//  Synopsis:    HDN_BEGINTRACK handler, due to our improper message routing
//               (handling all messages to CAMCView) this message gets lost
//               (CAMCListView::OnCmdMsg passes it to underlying view which
//               handles it & so we handle it here separately.
//
//  Arguments:   [pNotifyStruct] -
//               [result]        -
//
//--------------------------------------------------------------------
void CAMCListView::OnBeginTrack(NMHDR * pNotifyStruct, LRESULT * result)
{
	if (!pNotifyStruct || !result)
		return;

	*result = FALSE;

    NMHEADER* nmh = (NMHEADER*)pNotifyStruct;

    SC sc = ScOnColumnsAttributeChanged(nmh, HDN_BEGINTRACK);
    if (sc)
    {
        sc.TraceAndClear();
        return;
    }

	// S_FALSE : dont allow the change
    if (sc == SC(S_FALSE))
        *result = TRUE;

	return;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::IsColumnHidden
//
//  Synopsis:    Get the LPARAM and check if given column is hidden.
//
//  Arguments:   [iCol] -
//
//  Returns:     bool
//
//--------------------------------------------------------------------
bool CAMCListView::IsColumnHidden(int iCol) const
{
    CAMCHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();

    if (pHeaderCtrl)
		return pHeaderCtrl->IsColumnHidden(iCol);

    return false;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScGetColumnInfoList
//
//  Synopsis:    Get the CColumnInfoList from current list-view.
//
//  Arguments:   [pColumnsList] - [out param], ptr to CColumnsInfoList*
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScGetColumnInfoList (CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CAMCListView::ScGetColumnInfoList"));
    sc = ScCheckPointers(pColumnsList);
    if (sc)
        return sc;

    pColumnsList->clear();

    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;
    int cColumns = pHeader->GetItemCount();

    typedef std::auto_ptr<int> IntArray;

    IntArray spColOrder = IntArray(new int[cColumns]);
    int *pColOrder = spColOrder.get();  // Use a non-smart ptr for ease of use.
    sc = ScCheckPointers(pColOrder, E_OUTOFMEMORY);
    if (sc)
        return sc;

    sc = pHeader->GetOrderArray(pColOrder, cColumns) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    for (int i = 0; i < cColumns; i++)
    {
        // Get the data from header control.
        HDITEM hdItem;
        ZeroMemory(&hdItem, sizeof(hdItem));
        hdItem.mask = HDI_WIDTH | HDI_LPARAM;
        sc = pHeader->GetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
        if (sc)
            return sc;

        // Save the visual index of the ith col
        CColumnInfo colInfo;
        colInfo.SetColIndex(pColOrder[i]);

        // Save the width
		CHiddenColumnInfo hci (hdItem.lParam);

        if (hci.fHidden)
        {
            colInfo.SetColHidden();
            colInfo.SetColWidth(hci.cx);
        }
        else
            colInfo.SetColWidth(hdItem.cxy);

        pColumnsList->push_back(colInfo);
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScModifyColumns
//
//  Synopsis:    Modify the header-control columns with given CColumnsInfoList.
//
//  Arguments:   [colInfoList] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScModifyColumns (const CColumnInfoList& colInfoList)
{
    DECLARE_SC(sc, _T("CAMCListView::ScModifyColumns"));
    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    CAMCView *pAMCView = GetAMCView();
    sc = ScCheckPointers(pHeader, pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // This method is called due to following conditions:
    // 1. Just before inserting first item into list-view.
    // 2. If there are no items in list-view then it is empty LV,
    //    in that case this method is called during OnPaint.
    // 3. The IHeaderCtrlPrivate on CNodeInitObject can also call this method.

    // Once a node is selected & result-pane is setup, case1 or case2 above
    // should happen only once. To avoid multiple calls we use below flag which
    // says that we have attempted to restore the columns from given data.
    // case1 & case2 use this to determine whether to call this method.
    SetColumnsNeedToBeRestored();

    // Check for column consistency. If persisted # of cols & actual # of cols
    // inserted are different then ask column-data to be deleted.
    int cColumns = pHeader->GetItemCount();
    if (colInfoList.size() != cColumns)
    {
        sc = pAMCView->ScDeletePersistedColumnData();
        return sc;
    }

    typedef std::auto_ptr<int> IntArray;

    IntArray spColOrder = IntArray(new int[cColumns]);
    int *pColOrder = spColOrder.get();  // Use a non-smart ptr for ease of use.
    sc = ScCheckPointers(pColOrder, E_OUTOFMEMORY);
    if (sc)
        return sc;

    // Now restore the headers.
    {
        m_bColumnsBeingRestored = true;    // should set this false before leaving this funcion.

        CColumnInfoList::iterator itColInfo;
        int i = 0;

        // Get width/order of each column.
        for (itColInfo = colInfoList.begin(), i = 0;
             itColInfo != colInfoList.end();
             ++itColInfo, i++)
        {
            pColOrder[i] = itColInfo->GetColIndex();

            // First set/reset the lparam
            HDITEM hdItem;
            ZeroMemory(&hdItem, sizeof(hdItem));

            if (itColInfo->IsColHidden())
            {
                // We set the width first and then LPARAM because
                // If we set lparam first then when we set width
                // CAMCView::Notify HDN_ITEMCHANGING. Now we
                // examine the lparam of the item to see if it is hidden.
                // So setting lparam first and then setting width
                // for hiding columns will not work.
                hdItem.mask = HDI_WIDTH;
                hdItem.cxy = 0;
                sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                if (sc)
                    goto Error;

				CHiddenColumnInfo hci (itColInfo->GetColWidth(), true);

                hdItem.mask = HDI_LPARAM;
                hdItem.lParam = hci.lParam;
                sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                if (sc)
                    goto Error;
            }
            else
            {
				CHiddenColumnInfo hci (itColInfo->GetColWidth(), false);

                // Here we need to clear the hidden flag in lParam
                // before changing width So that hidden columns will be made visible.
                hdItem.mask = HDI_LPARAM;
                hdItem.lParam = hci.lParam;
                sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                if (sc)
                    goto Error;

                if ( AUTO_WIDTH == itColInfo->GetColWidth())
                {
                    // If the column is hidden and made visible we do not know its width.
                    // With ListView_SetColumnWidth passing AUTO_WIDTH for width calculates
                    // width automatically. Header_SetItem cannot do this.
                    sc = ListView_SetColumnWidth(GetSafeHwnd(),
                                                 pColOrder[i],
                                                 LVSCW_AUTOSIZE_USEHEADER) ? S_OK : E_FAIL;
                    if (sc)
                        goto Error;
                }
                else
                {
                    hdItem.mask = HDI_WIDTH;
                    hdItem.cxy = itColInfo->GetColWidth();
                    sc = pHeader->SetItem(pColOrder[i], &hdItem) ? S_OK : E_FAIL;
                    if (sc)
                        goto Error;
                }
            }
        }

        // Set the order
        sc = pHeader->SetOrderArray(cColumns, pColOrder) ? S_OK : E_FAIL;
        if (sc)
            goto Error;

		// Now redraw the list view
		InvalidateRect(NULL, TRUE);
    }


Cleanup:
    m_bColumnsBeingRestored = false;

    return (sc);
Error:
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScGetDefaultColumnInfoList
//
//  Synopsis:    Get the default column settings.
//
//  Arguments:   [columnInfoList] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScGetDefaultColumnInfoList (CColumnInfoList& columnInfoList)
{
    DECLARE_SC(sc, _T("CAMCListView::ScRestoreDefaultColumnSettings"));
    if (m_defaultColumnInfoList.size() <= 0)
        return (sc = E_UNEXPECTED);

    columnInfoList = m_defaultColumnInfoList;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScSaveColumnInfoList
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScSaveColumnInfoList ()
{
    DECLARE_SC(sc, _T("CAMCListView::ScSaveColumnInfoList"));

    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    CAMCView *pAMCView = GetAMCView();
    sc = ScCheckPointers(pHeader, pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the column data & give it to CAMCView so that it can
    // inform NodeMgr (thro NodeCallback) about new data.
    CColumnInfoList colInfoList;
    sc = ScGetColumnInfoList (&colInfoList);
    if (sc)
        return sc;

    sc = pAMCView->ScColumnInfoListChanged(colInfoList);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScOnColumnsAttributeChanged
//
//  Synopsis:    Column width/order has changed so get the column data
//               and ask the nodemgr to persist it.
//
//  Arguments:   NMHEADER* - the header change information.
//               code      - the HDN_* notification.
//
//  Returns:     SC, S_OK     - allow the change.
//                   S_FALSE  - dont allow the change.
//
//--------------------------------------------------------------------
SC CAMCListView::ScOnColumnsAttributeChanged (NMHEADER *pNMHeader, UINT code)
{
    DECLARE_SC(sc, _T("CAMCListView::ScOnColumnsAttributeChanged"));
    Trace (tagColumn, _T("CAMCListView::ScOnColumnsAttributeChanged"));

    // If we are applying persisted column data to the header control
    // so allow those changes.
    if (m_bColumnsBeingRestored)
        return sc;

	sc = ScCheckPointers(pNMHeader, pNMHeader->pitem);
	if (sc)
		return sc;

    // User is trying to drag a column make sure it is not a hidden column.
    if ( (code == HDN_BEGINTRACK) && (pNMHeader->pitem->mask & HDI_WIDTH) )
    {
        sc = IsColumnHidden(pNMHeader->iItem) ? S_FALSE : S_OK;
        return sc;
    }

    /*
     * At this point the code is HDN_ENDTRACK (width change completed) or
     * during HDN_ENDDRAG (order changing but not completed).
	 * During both these messages header-control has not updated internal
	 * data, so we post a message & save on message handler.
     */
    if ((code == HDN_ENDDRAG) || (code == HDN_ENDTRACK))
    {
        PostMessage(m_nColumnPersistedDataChangedMsg);
        return sc;
    }

	// Too risky to return error instead at this point, enable this for Blackcomb Beta1.
	// sc = E_FAIL;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::OnColumnPersistedDataChanged
//
//  Synopsis:    CAMCListView::m_nColumnDataChangedMsg registered message handler.
//               Column width/order has changed so get the column data
//               and ask the nodemgr to persist it.
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CAMCListView::OnColumnPersistedDataChanged (WPARAM, LPARAM)
{
    DECLARE_SC(sc, _T("CAMCListView::OnColumnPersistedDataChanged"));
    Trace (tagColumn, _T("CAMCListView::OnColumnPersistedDataChanged"));

    if (m_bColumnsBeingRestored)
        return 0;

    sc = ScSaveColumnInfoList();
    if (sc)
        return 0;

    return (0);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScRestoreColumnsFromPersistedData
//
//  Synopsis:    Get the persisted data for current list-view headers
//               and apply them.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScRestoreColumnsFromPersistedData ()
{
    DECLARE_SC(sc, _T("CAMCListView::ScRestoreColumnsFromPersistedData"));
    Trace (tagColumn, _T("CAMCListView::ScRestoreColumnsFromPersistedData"));

    if (! AreColumnsNeedToBeRestored())
        return sc;

    /*
     * When a node is selected the snapin initially inserts columns with
     * some initial settings which is the default settings. At this point
     * the list view has the default settings, save it before applying
     * the persisted data.
     */
    sc = ScGetColumnInfoList(&m_defaultColumnInfoList);
    if (sc)
        return sc;

    CAMCHeaderCtrl *pHeader = GetHeaderCtrl();
    CAMCView *pAMCView = GetAMCView();
    sc = ScCheckPointers(pHeader, pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the column data.
    CColumnInfoList colInfoList;
    sc = pAMCView->ScGetPersistedColumnInfoList(&colInfoList);

    // Whether there is data or not we tried to restore columns.
    SetColumnsNeedToBeRestored();

    if (sc.IsError() || (sc == SC(S_FALSE)) )
        return sc;

    // Modify headers.
    sc = ScModifyColumns(colInfoList);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScResetColumnStatusData
//
//  Synopsis:    Reset the data used to keep track of hidden column state,
//               columns-restored state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCListView::ScResetColumnStatusData ()
{
    DECLARE_SC(sc, _T("CAMCListView::ScResetColumnStatusData"));

    SetColumnsNeedToBeRestored(true);
    m_defaultColumnInfoList.clear();

    return (sc);
}


BOOL CAMCListView::ChangePane(AMCNavDir eDir)
{
    /*
     * NOTE: We need to get the header control before we get the focus window.
     *
     * The first time GetHeaderCtrl is called, it will subclass the non-MFC
     * header window with an MFC class.  Doing this will put an entry for the
     * header in the permanent window map.  Before GetHeaderCtrl is called,
     * MFC will have never seen the header before, so GetFocus will put an
     * entry in the temporary map.  Temporary CWnd pointers will never match
     * permanent CWnd pointers, even though they wrap the same HWND, so we
     * need to make sure the header is in the permanent map before we do
     * any comparisons.
     */
    CWnd* pwndHeader     = GetHeaderCtrl();
    CWnd* pwndFocus      = GetFocus();
    bool  fFocusOnList   = (pwndFocus == this);
    bool  fFocusOnHeader = (pwndFocus == pwndHeader);

    /*
     * It can't be that both the list and the focus have the focus,
     * although it is possible that neither has the focus.
     */
    ASSERT (!(fFocusOnList && fFocusOnHeader));

    /*
     * If either the list or the header has the focus, then this had
     * better be the active view; if not, it had better not.
     */
    if(!fFocusOnList && !fFocusOnHeader)
        return FALSE;

    /*
     * Set the focus to the header if:
     *
     * 1.  the focus is currently on the list, and
     * 2.  we're moving forward (Tab), and
     * 3.  we're in filter mode
     */
    if (fFocusOnList && (eDir == AMCNAV_NEXT) && IsInFilteredReportMode())
    {
        GetHeaderCtrl()->SetFocus();
        return TRUE;
    }

    /*
     * Otherwise, set the focus to the list if:
     *
     * 1.  the focus is not currently on the list, and
     * 2.  we're moving backward (Shift+Tab)
     */
    // if focus not on list and we're moving backward
    else if (!fFocusOnList && (eDir == AMCNAV_PREV))
    {
        ActivateSelf();
        return TRUE;
    }

    /*
     * didn't change the focus
     */
    return FALSE;
}


BOOL CAMCListView::TakeFocus(AMCNavDir eDir)
{
    if ((eDir == AMCNAV_PREV) && IsInFilteredReportMode())
        GetHeaderCtrl()->SetFocus();
    else
        ActivateSelf();

    ASSERT (GetParentFrame()->GetActiveView() == this);

    return TRUE;
}


/*+-------------------------------------------------------------------------*
 * CAMCListView::ActivateSelf
 *
 * If this isn't currently the active view, then this function makes it the
 * active view; the focus will be set to the list implicitly.
 *
 * If it's already the active view, calling SetActiveView won't set the
 * focus, because it shorts out if the active view isn't changing.  In
 * that case, we have to set the focus ourselves.
 *
 * This function returns true if the list view was made the active view,
 * false if it was already the active view.
 *--------------------------------------------------------------------------*/

bool CAMCListView::ActivateSelf (bool fNotify /* =true */)
{
    CFrameWnd* pwndFrame = GetParentFrame();
    ASSERT (pwndFrame != NULL);

    bool fChangeActiveView = (pwndFrame->GetActiveView() != this);

    if (fChangeActiveView)
        pwndFrame->SetActiveView (this, fNotify);
    else
        SetFocus();

    return (fChangeActiveView);
}


CAMCHeaderCtrl* CAMCListView::GetHeaderCtrl() const
{
    // Is there a header ?
    if (m_header.m_hWnd)
        return (&m_header);

    // if not, try getting it now
    HWND hwndHdr = reinterpret_cast<HWND>(::SendMessage (m_hWnd, LVM_GETHEADER, 0, 0));

    if (hwndHdr != NULL)
    {
        m_header.SubclassWindow(hwndHdr);
        return (&m_header);
    }

    return (NULL);
}


void CAMCListView::SelectDropTarget(int iDropTarget)
{
    if (m_iDropTarget == iDropTarget)
        return;

    CListCtrl& lc = GetListCtrl();

    if (m_iDropTarget != -1)
    {
        // remove hiliting from all items
        // do not use m_iDropTarget - item order and count may be changed already
        int iIndex = -1;
        while ( 0 <= ( iIndex = ListView_GetNextItem(lc, iIndex, LVIS_DROPHILITED) ) )
            ListView_SetItemState(lc, iIndex, 0, LVIS_DROPHILITED);
    }

    if (iDropTarget != -1)
        ListView_SetItemState(lc, iDropTarget, LVIS_DROPHILITED, LVIS_DROPHILITED);

    m_iDropTarget = iDropTarget;
}

/////////////////////////////////////////////////////////////////////////////
// CCCListViewCtrl

DEBUG_DECLARE_INSTANCE_COUNTER(CCCListViewCtrl);

CCCListViewCtrl::CCCListViewCtrl() :
    m_itemCount(0),
    m_nScopeItems(0),
    m_colCount(0),
    m_headerIL (AfxGetResourceHandle(), IDB_SORT),
    m_FontLinker (this)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CCCListViewCtrl);

    // Sort Stuff
    m_sortParams.bAscending = TRUE;
    m_sortParams.nCol = 0;
    m_sortParams.lpListView = this;
    m_sortParams.spResultCompare = NULL;
    m_sortParams.spResultCompareEx = NULL;
    m_sortParams.lpUserParam = NULL;
    m_sortParams.bLexicalSort = FALSE;
    m_sortParams.hSelectedNode = NULL;

    // Start as standard list
    m_bVirtual = FALSE;
    m_bFiltered = FALSE;
    m_pStandardList = new CAMCListView;
    m_pVirtualList = NULL;
    m_bEnsureFocusVisible = FALSE;
    m_bLoading = FALSE;
    m_bDeferredSort = FALSE;

    m_SavedHWND = NULL;
    ZeroMemory (&m_wp, sizeof(WINDOWPLACEMENT));

    m_pListView = m_pStandardList;
}


CCCListViewCtrl::~CCCListViewCtrl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CCCListViewCtrl);

    if (m_SavedHWND != NULL) {
        // change back
        ::SetParent (m_pListView->m_hWnd, m_SavedHWND);
        if (m_wp.length != 0)
            ::SetWindowPlacement (m_pListView->m_hWnd, &m_wp);

        // clear saved window
        m_SavedHWND = NULL;
    }

}


/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::ScInitialize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CCCListViewCtrl::ScInitialize()
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScInitialize"));

    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers(pAMCView, E_FAIL);
    if (sc)
        return sc;

    AddObserver(static_cast<CListViewObserver&>(*pAMCView));

    return sc;
}



//---------------------------------------------------- Utility functions


void CCCListViewCtrl::CutSelectedItems(BOOL bCut)
{
    CListCtrl& lc    = GetListCtrl();
    int nSearchFlags = (bCut) ? LVNI_SELECTED : LVNI_CUT;
    int nNewState    = (bCut) ? LVIS_CUT      : 0;
    int nItem        = -1;

    while ((nItem = lc.GetNextItem (nItem, nSearchFlags)) >= 0)
    {
        lc.SetItemState (nItem, nNewState, LVIS_CUT);
    }
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::IndexToResultItem
 *
 * Returns the CResultItem pointer for a given index.
 *--------------------------------------------------------------------------*/

CResultItem* CCCListViewCtrl::IndexToResultItem (int nItem)
{
    HRESULTITEM hri = GetListCtrl().GetItemData (nItem);

    if (IS_SPECIAL_LVDATA (hri))
        return (NULL);

    return (CResultItem::FromHandle (hri));
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::ResultItemToIndex
 *
 * Returns the index of an item given its CResultItem pointer.  This does a
 * linear search.  If the speed of this function needs to be improved,
 * we'll need a separate CResultItem-to-index map.
 *--------------------------------------------------------------------------*/

int CCCListViewCtrl::ResultItemToIndex (CResultItem* pri) const
{
    /*
     * if this is a virtual list, the CResultItem "pointer" is actually
     * the item index, so convert it.  Note that CResultItem::ToHandle is
     * safe to call with a NULL pointer.
     */
    if (IsVirtual())
        return (CResultItem::ToHandle(pri));

    /*
     * No items have NULL CResultItem pointers, don't bother looking.
     */
    if (pri == NULL)
        return (-1);

    /*
     * Let the list find the matching item.
     */
    LV_FINDINFO lvfi;
    lvfi.flags  = LVFI_PARAM;
    lvfi.lParam = CResultItem::ToHandle(pri);

    return (GetListCtrl().FindItem (&lvfi, -1));
}

/////////////////////////////////////////////////////////////////////////////
// CCCListViewCtrl message handlers


HRESULT CCCListViewCtrl::InsertItem(
    LPOLESTR    str,
    long        iconNdx,
    LPARAM      lParam,
    long        state,
    COMPONENTID ownerID,
    long        itemIndex,
    CResultItem*& priInserted)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::InsertItem"));

    /*
     * init the output parameter
     */
    priInserted = NULL;

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    if (str != MMC_TEXTCALLBACK)
        return (sc = E_INVALIDARG).ToHr();

    // Ask the CAMCListViewCtrl to setup headers.
    sc = ScCheckPointers(m_pListView, E_UNEXPECTED);
    if (! sc.IsError())
        sc = m_pListView->ScRestoreColumnsFromPersistedData();

    if (sc)
        sc.TraceAndClear();

    USES_CONVERSION;

    LV_ITEM     lvi;
    lvi.iSubItem = 0;
    lvi.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.pszText  = LPSTR_TEXTCALLBACK;

    // If the user has specified an icon index, map it and put it in the LV_ITEM struct
    int nMapping = 0;

    if ((iconNdx != MMCLV_NOICON) &&
        m_resultIM.Lookup(&CImageIndexMapKey(ownerID,iconNdx), nMapping))
    {
        lvi.iImage = nMapping;
    }
    else
    {
        lvi.iImage = MMCLV_NOICON;
        iconNdx    = MMCLV_NOICON;
    }

    /*
     * allocate and initialize a CResultItem for this item
     */
    sc = ScAllocResultItem (priInserted, ownerID, lParam, iconNdx);
    if (sc)
        return (sc.ToHr());

    sc = ScCheckPointers (priInserted, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());


    // If the user has specified a state, put it in the LV_ITEM struct
    if (state != MMCLV_NOPARAM)
    {
        lvi.mask     |= LVIF_STATE;
        lvi.state     = state;
        lvi.stateMask = 0xFFFFFFFF;
    }


    // if scope item
    if (priInserted->IsScopeItem())
    {
        // if no index provided add to end of unsorted items
        lvi.iItem = (itemIndex == -1) ? m_nScopeItems : itemIndex;

        // if decending sort, offset from end instead of start
        if (!m_sortParams.bAscending)
            lvi.iItem += (m_itemCount - m_nScopeItems);
    }
    else
    {
        // Add sorted items to end of list (or before unsorted items, if reverse sorting)
        lvi.iItem = m_sortParams.bAscending ? m_itemCount : m_itemCount - m_nScopeItems;
    }

    lvi.lParam = CResultItem::ToHandle(priInserted);

    int nIndex = GetListCtrl().InsertItem (&lvi);

#if (defined(DBG) && defined(DEBUG_LIST_INSERTIONS))
    static int cInserted = 0;
    TRACE3 ("%4d:Inserted item: index=%d, lParam=0x%08x\n", ++cInserted, nIndex, lvi.lParam);
#endif

    if (nIndex == -1 )
    {
        sc = E_FAIL;
        ScFreeResultItem (priInserted);   // ignore failures
        priInserted = NULL;
    }
    else
    {
        // The insert succeeded, increase the internal item counts
        m_itemCount++;

        // we invalidate the rectangle when transitioning from zero to one item because otherwise the
        // empty list message is not erased completely.
        if(m_itemCount == 1)
            GetListCtrl().InvalidateRect(NULL);

        if (priInserted->IsScopeItem())
            m_nScopeItems++;

        // if ensure focus visible style and focus set, force item into view
        if (m_bEnsureFocusVisible && state != MMCLV_NOPARAM && (state & LVIS_FOCUSED))
            GetListCtrl().EnsureVisible(nIndex, FALSE);
    }

    if (sc)
        return sc.ToHr();

    // we have inserted an Item! - broadcast the good message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewItemInserted, nIndex);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


HRESULT CCCListViewCtrl::DeleteItem(HRESULTITEM itemID, long nCol)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::DeleteItem"));

    if (nCol != 0)
        return E_INVALIDARG;

    CListCtrl& lc = GetListCtrl();

    int nItem = IsVirtual() ? static_cast<int>(itemID)
                            : ResultItemToIndex( CResultItem::FromHandle(itemID) );

#if (defined(DBG) && defined(DEBUG_LIST_INSERTIONS))
    static int cDeletes = 0;
    TRACE3 ("%4d:Deleted item:  index=%d, lParam=0x%08x", ++cDeletes, nItem, priDelete);
#endif

    if (nItem < 0 || nItem >= m_itemCount)
    {
        ASSERT(FALSE);
#if (defined(DEBUG_LIST_INSERTIONS))
        TRACE0 ("  (failed)\n");
#endif
        return E_INVALIDARG;
    }

#if (defined(DEBUG_LIST_INSERTIONS))
    TRACE0 ("\n");
#endif

    if (!lc.DeleteItem (nItem))
    {
        sc = E_FAIL;
    }
    else
    {
        // Delete was successful, decrement the ItemCount
        ASSERT(m_itemCount > 0);
        m_itemCount--;

        if (!IsVirtual())
        {
            CResultItem *priDelete = CResultItem::FromHandle(itemID);
            sc = ScCheckPointers (priDelete, E_UNEXPECTED);
            if (sc)
                return (sc.ToHr());

            if (priDelete->IsScopeItem())
                m_nScopeItems--;

            sc = ScFreeResultItem (priDelete);
            if (sc)
                return (sc.ToHr());
        }
    }

    if (sc)
        return sc.ToHr();

    // select the focused item ( this will save a lot of snapins from the confusion
    // since they are not prepared to handle 'no items selected' scenario.
    // Note: we only guard single selection lists - for multiple selection the situation
    // must be handled by snapin, since user can easily unselect the item.
    if ( (::GetFocus() == lc.m_hWnd) && (lc.GetStyle() & LVS_SINGLESEL) )
    {
        // check if focused item is selected
        int iMarkedItem = lc.GetSelectionMark();
        if ( (iMarkedItem >= 0) && !( lc.GetItemState( iMarkedItem, LVIS_SELECTED ) & LVIS_SELECTED ) )
        {
            // NOTE: do not use lc.SetItemState - it uses SetItem which is not supported for virtual lists
            LV_ITEM lvi;
            lvi.stateMask = lvi.state = LVIS_SELECTED;
            if (!lc.SendMessage( LVM_SETITEMSTATE, WPARAM(iMarkedItem), (LPARAM)(LV_ITEM FAR *)&lvi))
                (sc = E_FAIL).TraceAndClear(); // trace is enough - ignore and continue
        }
    }

    // we have deleted an Item! - broadcast the message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewItemDeleted, nItem);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::UpdateItem
//
//  Synopsis:    Update the given item.
//
//  Arguments:   [itemID] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CCCListViewCtrl::UpdateItem(HRESULTITEM itemID)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::UpdateItem"));

    int nIndex = -1;
    sc = ScGetItemIndexFromHRESULTITEM(itemID, nIndex);
    if (sc)
        return sc.ToHr();

    if(nIndex < 0 || nIndex >= m_itemCount)
        return (sc = E_INVALIDARG).ToHr();

	CListCtrl& lc = GetListCtrl();

    /*
     * Since Common Control does not hold any data about virtual list view
     * items they would not know what to invalidate. So we need to invalidate
     * for virtual list views.
     */
	if (IsVirtual())
	{
		RECT rc;

		lc.GetItemRect(nIndex, &rc, LVIR_BOUNDS);
		lc.InvalidateRect(&rc);
	}
	else
	{
		sc = ScRedrawItem(nIndex);
		if (sc)
			return (sc.ToHr());
	}

	lc.UpdateWindow();


    // we have updated an item - broadcast the message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewItemUpdated, nIndex);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScGetItemIndexFromHRESULTITEM
//
//  Synopsis:    Given HRESULTITEM get the index of that item.
//               For virtual listview the itemid is the index.
//
//  Arguments:   [itemID] - [in param]
//               [nIndex] - [out param]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScGetItemIndexFromHRESULTITEM (const HRESULTITEM& itemID, int& nIndex)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScGetItemIndexFromHRESULTITEM"));

    nIndex = -1;

    if (IsVirtual())
	{
        nIndex = itemID;
		return sc;
	}

    CResultItem *pri = CResultItem::FromHandle(itemID);
    sc = ScCheckPointers(pri, E_UNEXPECTED);
    if (sc)
        return sc;

    nIndex = ResultItemToIndex(pri);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScRedrawItem
//
//  Synopsis:    Redraw the given item in listview.
//
//  Arguments:   [nIndex] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScRedrawItem(int nIndex)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::RedrawItem"));

    if(nIndex < 0 || nIndex >= m_itemCount)
        return (sc = E_INVALIDARG);

    if (!GetListCtrl().RedrawItems (nIndex, nIndex))
        return (sc = E_FAIL);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     Sort
//
//  Synopsis:   Sort the list view with given data.
//
//  Arguments:  [lpUserParam]    - Snapin supplied user param.
//              [lParms]         - ptr to CCLVSortParams struct.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
HRESULT CCCListViewCtrl::Sort(LPARAM lUserParam, long* lParms)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Sort"));

    if (IsVirtual())
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    BOOL bResult = FALSE;
    CCLVSortParams* lpParams = reinterpret_cast<CCLVSortParams*>(lParms);
    ASSERT(lpParams != NULL);

    // Note: the hwnd should only be initialize in ::Create
    m_sortParams.bAscending = lpParams->bAscending;
    m_sortParams.nCol = lpParams->nCol;
    m_sortParams.spResultCompare = lpParams->lpResultCompare;
    m_sortParams.spResultCompareEx = lpParams->lpResultCompareEx;
    m_sortParams.lpUserParam = lUserParam;

    // Do not sort on hidden columns.
    if (IsColumnHidden(m_sortParams.nCol))
        return (sc.ToHr());

    {
        // Check view options for scope item sorting
        CAMCView* pAMCView = m_pListView->GetAMCView();
        sc = ScCheckPointers(pAMCView, E_FAIL);
        if (sc)
            return (sc.ToHr());

        SViewData* pViewData = pAMCView->GetViewData();
        sc = ScCheckPointers(pViewData, E_FAIL);
        if (sc)
            return (sc.ToHr());

        m_sortParams.bLexicalSort = ((pViewData->GetListOptions() & RVTI_LIST_OPTIONS_LEXICAL_SORT) != 0);

        LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
        sc = ScCheckPointers(pNodeCallback, E_FAIL);
        if (sc)
            return (sc.ToHr());

        // Do not need to refcount this, because it is being passed to a method that returns.
        m_sortParams.lpNodeCallback = pNodeCallback;

        // Get component ID of node that owns the result view
        HNODE hnodeOwner = pAMCView->GetSelectedNode();
        sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
        if (sc)
            return (sc.ToHr());

        m_sortParams.hSelectedNode = hnodeOwner;

        sc = pNodeCallback->GetNodeOwnerID(hnodeOwner, &m_sortParams.OwnerID);
        if (sc)
            return (sc.ToHr());

        if (m_bLoading)
        {
            bResult = TRUE;
            m_bDeferredSort = TRUE;
        }
        else
        {
			/*
			 * the sort could take awhile, so show a wait cursor
			 */
			CWaitCursor wait;

            // It is lexical sort if
            // 1. LV option specifies lexical sort option or
            // 2. Snapin does not implement IResultDataCompare
            //    or IResultDataCompareEx interfaces.
            BOOL bLexicalSort = ( m_sortParams.bLexicalSort ||
                                  ( (NULL == m_sortParams.spResultCompare) &&
                                    (NULL == m_sortParams.spResultCompareEx) ) );

            if (bLexicalSort)
            {
                bResult = GetListCtrl().SortItems (DefaultCompare, (DWORD_PTR)&m_sortParams);
            }
            else
            {
                bResult = GetListCtrl().SortItems (SortCompareFunc, (DWORD_PTR)&m_sortParams);
            }
        }

        sc = (bResult == TRUE) ? S_OK : E_FAIL;
        if (sc)
            return (sc.ToHr());

        // we have sorted Items! - cannot keep track of them currently
        sc = ScFireEvent(CListViewObserver::ScOnListViewIndexesReset);
        if (sc)
            return (sc.ToHr());
    }

    return sc.ToHr();
}

HRESULT CCCListViewCtrl::FindItemByLParam(COMPONENTID ownerID, LPARAM lParam, CResultItem*& priFound)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::FindItemByLParam"));

    /*
     * init output parameter
     */
    priFound = NULL;

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    /*
     * find a CResultItem that matches the given owner and lParam.
     */
    for (int i = GetListCtrl().GetItemCount()-1; i >= 0; i--)
    {
        CResultItem* pri = IndexToResultItem (i);

        if ((pri != NULL) &&
            (pri->GetOwnerID() == ownerID) &&
            (pri->GetSnapinData() == lParam))
        {
            priFound = pri;
            break;
        }
    }

    if (priFound == NULL)
        return ((sc = E_FAIL).ToHr());

    return sc.ToHr();
}


HRESULT CCCListViewCtrl::GetListStyle()
{
    LONG result;
    ASSERT(::IsWindow(GetListViewHWND()));

    // return the Style masked by the List View Style mask.
    result = ::GetWindowLong(GetListViewHWND(),GWL_STYLE) & 0xffff;

    return result;
}


HRESULT CCCListViewCtrl::SetListStyle(long nNewValue)
{
    HWND hListView = GetListViewHWND();
    if(hListView == NULL)   
    {
        return  E_FAIL;
    }

    ASSERT(::IsWindow(hListView));

    // Protect style bits that shouldn't be changed
    // Use SetViewMode to change the mode, so filtering is properly updated
    const long PRESERVE_MASK = LVS_OWNERDATA | LVS_SHAREIMAGELISTS | 0xffff0000;

    DWORD curStyle = ::GetWindowLong(hListView, GWL_STYLE);
    DWORD newStyle = (curStyle & PRESERVE_MASK) | (nNewValue & ~PRESERVE_MASK);

    // Verify not changing the view mode
    ASSERT( ((curStyle ^ newStyle) & LVS_TYPEMASK) == 0);

    // verify OWNERDATA style is what we think it is
    ASSERT((curStyle & LVS_OWNERDATA) && m_bVirtual || !(curStyle & LVS_OWNERDATA) && !m_bVirtual);

    // Save state of MMC defined "ensure focus visible" syle
    m_bEnsureFocusVisible = (nNewValue & MMC_LVS_ENSUREFOCUSVISIBLE) != 0;

    if (curStyle != newStyle)
    {
        // Apply style changes
        ::SetWindowLong(hListView, GWL_STYLE, newStyle);

        /*
         * The list control does not pass changes to the LVS_NOSORTHEADER flag on to the
         * HeaderCtrl. This section directly accesses the underlying HeaderCtrl and
         * changes the HDS_BUTTONS flag which is the equivalent.
         */

	CAMCHeaderCtrl* pHeaderCtrl = GetHeaderCtrl(); 
        if ((nNewValue & LVS_NOSORTHEADER) ^ (curStyle & LVS_NOSORTHEADER) && pHeaderCtrl)
        {
            if (nNewValue & LVS_NOSORTHEADER)
                pHeaderCtrl->ModifyStyle (HDS_BUTTONS, 0); // Add the style
            else
                pHeaderCtrl->ModifyStyle (0, HDS_BUTTONS); // Remove the style
        }
    }

    return S_OK;
}


HRESULT CCCListViewCtrl::GetViewMode()
{
    ASSERT(::IsWindow(GetListViewHWND()));

    long nViewMode;

    if (m_bFiltered)
        nViewMode = MMCLV_VIEWSTYLE_FILTERED;
    else
        nViewMode = ::GetWindowLong(GetListViewHWND(), GWL_STYLE) & LVS_TYPEMASK;

    return nViewMode;
}


#include "histlist.h"
HRESULT CCCListViewCtrl::SetViewMode(long nViewMode)
{
    ASSERT(nViewMode >= 0 && nViewMode <= MMCLV_VIEWSTYLE_FILTERED);

    CListCtrl& lc = GetListCtrl();

    if (nViewMode < 0 && nViewMode > MMCLV_VIEWSTYLE_FILTERED)
        return E_INVALIDARG;

    CAMCView* pAMCView = dynamic_cast<CAMCView*>(m_pParentWnd);
    if (pAMCView)
        pAMCView->GetHistoryList()->SetCurrentViewMode (nViewMode);

    BOOL bFiltered = FALSE;
    if (nViewMode == MMCLV_VIEWSTYLE_FILTERED)
    {
        bFiltered = TRUE;
        nViewMode = LVS_REPORT;
    }

    lc.ModifyStyle (LVS_TYPEMASK, nViewMode);

    HRESULT hr = S_OK;

    // set filter style
    CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
    ASSERT(NULL != pHeaderCtrl);

    if (bFiltered != m_bFiltered && pHeaderCtrl)
    {
        if (bFiltered)
            pHeaderCtrl->ModifyStyle (0, HDS_FILTERBAR);
        else
            pHeaderCtrl->ModifyStyle (HDS_FILTERBAR, 0);

        m_bFiltered = bFiltered;

        // The header size has changed with the addition/removal of filter.
        // We hide and show the header which will force the list
        // control to recalculate the size, position of new header
        // and list view and display it.
        lc.ModifyStyle(0, LVS_NOCOLUMNHEADER, 0);
        lc.ModifyStyle(LVS_NOCOLUMNHEADER, 0, 0);
    }

    return S_OK;
}


HRESULT CCCListViewCtrl::SetVirtualMode(BOOL bVirtual)
{
    HWND hListView = GetListViewHWND();
    if (hListView == NULL)
    {
        return E_FAIL;
    }

    ASSERT(::IsWindow(hListView));

    HRESULT hr = S_OK;

    // force param to TRUE or FALSE
    bVirtual = bVirtual ? TRUE : FALSE;

    if (bVirtual != m_bVirtual)
    {
        do // false loop
        {
             // list must be empty to switch
            if (m_itemCount != 0)
            {
               ASSERT(FALSE);
               hr = E_FAIL;
               break;
            }

            // get styles to copy to new control
            long curStyle = ::GetWindowLong(hListView, GWL_STYLE) ^ LVS_OWNERDATA;
            long curStyleEx = ::GetWindowLong(hListView, GWL_EXSTYLE);

            long curHdrStyle = 0;

            CAMCHeaderCtrl* pHeaderCtrl = NULL; 
            if ((pHeaderCtrl = GetHeaderCtrl()))
                curHdrStyle = pHeaderCtrl->GetStyle();

            if (bVirtual && !m_pVirtualList)
            {
                m_pVirtualList = new CAMCListView;
                m_pVirtualList->SetVirtual();
            }

            CAMCListView* pNewList = bVirtual ? m_pVirtualList : m_pStandardList;
            CAMCListView* pOldList = m_pListView;

            // Make sure new control has been created
            if (pNewList->m_hWnd == NULL)
            {
                /*
                 * MFC will issue a warning about creating a pane with
                 * no document.  That's OK, since CAMCView::AttachListView-
                 * AsResultPane will patch thing up later.
                 */
                ASSERT (pOldList != NULL);
                if (!Create(curStyle, g_rectEmpty, m_pParentWnd, pOldList->GetDlgCtrlID()))
                {
                    ASSERT(FALSE);
                    hr = E_FAIL;
                    break;
                }
                
            }

            // update member variables (this switches to the new control)
            m_bVirtual = bVirtual;
            m_pListView = bVirtual ? m_pVirtualList : m_pStandardList;

            hListView = GetListViewHWND(); // Get new list view handle
            if (hListView == NULL)
            {
                hr = E_FAIL;
                break;
            }

            // Set current styles on new control
            ::SetWindowLong(hListView, GWL_STYLE, curStyle);
            ::SetWindowLong(hListView, GWL_EXSTYLE, curStyleEx);

            // Note we have switched to the other control by now so this is getting the
            // header of the new list
    
            pHeaderCtrl = GetHeaderCtrl(); 
            if (pHeaderCtrl)
                ::SetWindowLong(pHeaderCtrl->m_hWnd, GWL_STYLE, curHdrStyle);

             // hide the old list control and show the new one
            ::ShowWindow(pOldList->m_hWnd, SW_HIDE);
            ::ShowWindow(m_pListView->m_hWnd, SW_SHOWNA);
        }
        while (0);
    }

    return hr;
}



HRESULT CCCListViewCtrl::InsertColumn(int nCol, LPCOLESTR str, long nFormat, long width)
{
    // Cannot change a column that is not in the list.
    if(!str || !*str)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    LV_COLUMN newCol;
    void* pvoid = &newCol;

    // Cannot insert a column with any items in the list.
    if(m_itemCount)
    {
        hr = E_FAIL;
    }
    else
    {
        newCol.mask=0;

        USES_CONVERSION;

        // if the user specified a string, put it in the struct.
        if(str!=MMCLV_NOPTR)
        {
            newCol.mask|=LVCF_TEXT;
            newCol.pszText=OLE2T((LPOLESTR)str);
        }

        // if the user specified a format, put it in the struct.
        if(nFormat!=MMCLV_NOPARAM)
        {
            newCol.mask|=LVCF_FMT;
            newCol.fmt=nFormat;
        }

        // if the user specified a width, put it in the struct.
        if(width!=MMCLV_NOPARAM)
        {
            newCol.mask|=LVCF_WIDTH;
            // if the user requested auto-width, calculate the width.
            // else just store the passed width.
            if(width==MMCLV_AUTO)
            {
                // if the user did pass a string, calculate the width based off the string.
                // else the width is 0.
                if(str!=MMCLV_NOPTR)
                {
                    CSize sz(0,0);
                    CClientDC dc( m_pListView );
                    dc.SelectObject( m_pListView->GetFont());
                    sz=dc.GetTextExtent(OLE2CT((LPOLESTR)str),_tcslen(OLE2T((LPOLESTR)
                    str)));
                    newCol.cx=sz.cx+CCLV_HEADERPAD;
                }
                else
                {
                    newCol.cx=0;
                }
            }
            else
            {
                newCol.cx=width;
            }
        }

        int nRet = GetListCtrl().InsertColumn (nCol, &newCol);

        if (-1 == nRet)
            hr = E_FAIL;
        else
        {
            // set lparam (HDI_HIDDEN flag) if the width is HIDE_COLUMN
            if (HIDE_COLUMN == width)
            {
				CHiddenColumnInfo hci (0, true);

                HDITEM hdItem;
                ::ZeroMemory(&hdItem, sizeof(hdItem));
                hdItem.mask    = HDI_LPARAM;
                hdItem.lParam  = hci.lParam;

                // We do not care if this call fails
		 
                CAMCHeaderCtrl* pHeaderCtrl = NULL; 
                if ((pHeaderCtrl = GetHeaderCtrl()))
                    pHeaderCtrl->SetItem(nRet, &hdItem);
            }
            else
            {
				CHiddenColumnInfo hci (newCol.cx, false);

                // set lparam with the width.
                HDITEM hdItem;
                ::ZeroMemory(&hdItem, sizeof(hdItem));
                hdItem.mask    = HDI_LPARAM;
                hdItem.lParam  = hci.lParam;

                // We do not care if this call fails
                if (GetHeaderCtrl())
                    GetHeaderCtrl()->SetItem(nRet, &hdItem);
            }

            // insert was successful, increment the column count.
            m_colCount++;
        }

    }

    // we have inserted a column! - broadcast the message to observers
    if (SUCCEEDED(hr))
    {
        SC sc = ScFireEvent(CListViewObserver::ScOnListViewColumnInserted, nCol);
        if (sc)
            return sc.ToHr();
    }

    return hr;
}

HRESULT CCCListViewCtrl::DeleteColumn(int nCol)
{
    if (nCol < 0 || nCol >= m_colCount)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    // Cannot delete a column if there are items in the list.
    if(m_itemCount)
    {
        hr = E_FAIL;
    }
    else
    {

        if (!GetListCtrl().DeleteColumn (nCol))
            hr = E_FAIL;
        else
            // Successful delete, decrement the column count.
            m_colCount--;
    }

    // we have deleteded a column! - broadcast the message to observers
    if (SUCCEEDED(hr))
    {
        SC sc = ScFireEvent(CListViewObserver::ScOnListViewColumnDeleted, nCol);
        if (sc)
            return sc.ToHr();
    }

    return hr;
}

HRESULT CCCListViewCtrl::GetColumnCount(int* pnColCnt)
{
    *pnColCnt =  m_colCount;
    return S_OK;
}

HRESULT CCCListViewCtrl::DeleteAllItems(COMPONENTID ownerID)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::DeleteAllItems"));

    CListCtrl& lc = GetListCtrl();

    const bool bHasItemsToDelete = (m_itemCount > 0);
    // Nothing in the list -> nothing to do.
    if (bHasItemsToDelete)
    {
        if (IsVirtual())
        {
            if (lc.DeleteAllItems ())
                m_itemCount = 0;
            else
                sc = E_FAIL;
        }
        else if (ownerID == TVOWNED_MAGICWORD)
        {
            /*
             * free all of the CResultItem objects
             */
            for (int i = m_itemCount - 1; i >= 0; i--)
            {
                CResultItem* pri = IndexToResultItem (i);

                if (pri != NULL)
                {
                    sc = ScFreeResultItem(pri);
                    if (sc)
                        return (sc.ToHr());
                }
            }

            if (lc.DeleteAllItems ())
            {
                // Delete all succeded, ItemCount is now 0;
                m_itemCount = 0;
                m_nScopeItems = 0;
            }

            else
                sc = E_FAIL;
        }
        else
        {
            // PERF: turn of redraw while all the items are deleted. This has a huge impact.
            lc.SetRedraw(false);

            for(int i = m_itemCount - 1; i >= 0; i--)
            {
                CResultItem* pri = IndexToResultItem (i);

                if ((pri != NULL) && (pri->GetOwnerID() == ownerID))
                {
                    if (lc.DeleteItem (i))
                    {
                        m_itemCount--;

                        sc = ScFreeResultItem(pri);
                        if(sc)
                            break; // don't return here because lc.SetRedraw(true) must be called
                    }

                    else
                        sc = E_FAIL;
                }
            }

            // reenable the list control's drawing ability
            lc.SetRedraw(true);

            // ensure that the listview redraws itself
            lc.Invalidate();
        }
    }

    if (sc)
        return sc.ToHr();

    if (bHasItemsToDelete)
    {
        // we have deleted all Items! - broadcast the message to observers
        sc = ScFireEvent(CListViewObserver::ScOnListViewIndexesReset);
        if (sc)
            return sc.ToHr();
    }

    return sc.ToHr();
}

HRESULT CCCListViewCtrl::SetColumn(long nCol, LPCOLESTR str, long nFormat, long width)
{
    // Cannot change a column that is not in the list.
    if((nCol + 1) > m_colCount)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    LV_COLUMN newCol;
    newCol.mask=0;

    USES_CONVERSION;

    // if the user specified a string, put it in the struct.
    if(str!=MMCLV_NOPTR)
    {
        newCol.mask|=LVCF_TEXT;
        newCol.pszText=OLE2T((LPOLESTR)str);
    }

    // if the user specified a format, put it in the struct.
    if(nFormat!=MMCLV_NOPARAM)
    {
        newCol.mask|=LVCF_FMT;
        newCol.fmt=nFormat;
    }

    // if the user specified a width, put it in the struct.
    if(width!=MMCLV_NOPARAM)
    {
        newCol.mask|=LVCF_WIDTH;
        // if the user requested auto-width, calculate the width.
        // else just store the passed width.
        if(width==MMCLV_AUTO)
        {
            // if the user did pass a string, calculate the width based off the string.
            // else the width is 0.
            if(str!=MMCLV_NOPTR)
            {
                CSize sz(0,0);
                CClientDC dc( m_pListView );
                dc.SelectObject( m_pListView->GetFont() );
                sz=dc.GetTextExtent(OLE2T((LPOLESTR)str),_tcslen(OLE2T((LPOLESTR)str)));
                newCol.cx=sz.cx+15;
            }
            else
            {
                newCol.cx=0;
            }
        }
        else
        {
            newCol.cx=width;
        }

        // Get the lParam to see if this is a hidden column.
        HDITEM hdItem;
        ::ZeroMemory(&hdItem, sizeof(hdItem));
        hdItem.mask    = HDI_LPARAM;

	CAMCHeaderCtrl* pHeaderCtrl = NULL; 
        if ((pHeaderCtrl = GetHeaderCtrl()) == NULL)
        {
            return E_FAIL;
        }
        BOOL bRet = pHeaderCtrl->GetItem(nCol, &hdItem);
        ASSERT(bRet);

        CHiddenColumnInfo hciOld (hdItem.lParam);
        CHiddenColumnInfo hci (0);

        ::ZeroMemory(&hdItem, sizeof(hdItem));
        hdItem.mask    = HDI_LPARAM;

        // If the column is to be hidden then
        // remember the (Old width) and (HIDDEN_FLAG).
        if (HIDE_COLUMN == newCol.cx)
        {
			hci.cx      = hciOld.cx;
			hci.fHidden = true;
        }

        // If the column was hidden then
        // remember the (New width supplied) and (HIDDEN_FLAG).
        if (hciOld.fHidden)
        {
			hci.cx      = newCol.cx;
			hci.fHidden = true;
        }

		hdItem.lParam = hci.lParam;

        // We do not care if this call fails
        pHeaderCtrl->SetItem(nCol, &hdItem);

        // Common control does not know anything about hidden
        // columns, so if the column is hidden clear the
		// width mask.
		if (hci.fHidden)
		{
			newCol.mask = newCol.mask & (~LVCF_WIDTH);
		}
    }

    if (!GetListCtrl().SetColumn (nCol, &newCol))
        hr = E_FAIL;

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::GetColumn
 *
 * PURPOSE: Returns information about the nCol'th column
 *
 * PARAMETERS:
 *    long      nCol :      the column index
 *    LPOLESTR* str :       if non-NULL, points to column name on exit
 *    LPLONG    nFormat :   [out] the column format
 *    int *     width:      [out] the width of the column
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CCCListViewCtrl::GetColumn(long nCol, LPOLESTR* str, LPLONG nFormat, int FAR *width)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::GetColumn"));

#ifdef DBG
    if((nCol+1)>m_colCount)
        return E_INVALIDARG;
#endif

    LV_COLUMN col;

    UINT                 cBufferSize  = 25; // grows as needed. The size here is actually half the initially allocated size
    CAutoArrayPtr<TCHAR> buffer;  // we use CAutoArrayPtr because the destructor calls delete[]
    // Set up the mask to select the values we are interested in.
    UINT   mask         = (nFormat!=MMCLV_NOPTR?LVCF_FMT:0)|(width!=MMCLV_NOPTR?LVCF_WIDTH:0);

    do
    {
        // If the user requested a string, reflect this in the struct.
        if(str!=NULL)
        {
            buffer.Delete(); // get rid of the old buffer, if any

            cBufferSize *= 2; // twice the previous size.
            buffer.Attach(new TCHAR[cBufferSize]);
            if(buffer==NULL)
                return(sc = E_OUTOFMEMORY).ToHr();

            mask|=LVCF_TEXT;
            col.cchTextMax=cBufferSize;
            col.pszText=buffer;
        }

        col.mask = mask;

        sc = GetListCtrl().GetColumn (nCol, &col) ? S_OK : E_FAIL;
        if(sc)
            return sc.ToHr();

    }   while(str!=NULL && (cBufferSize == _tcslen(buffer) + 1) ); //loop if the string filled up the buffer.
    // This is conservative - even if the buffer was just big enough, we loop again.

    // Success! fill in the requested args and return.
    USES_CONVERSION;
    if(str!=MMCLV_NOPTR)
        *str = ::CoTaskDupString(T2OLE(buffer));

    if(nFormat!=MMCLV_NOPTR)
        *nFormat=col.fmt;

    if(width!=MMCLV_NOPTR)
        *width=col.cx;

    return sc.ToHr();
}

HRESULT CCCListViewCtrl::SetItem(int nItem,
                               CResultItem* pri,
                               long nCol,
                               LPOLESTR str,
                               long nImage,
                               LPARAM lParam,
                               long nState,
                               COMPONENTID ownerID)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::SetItem"));

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    ASSERT(pri != NULL || nItem >= 0);

    // if this is a debug build, perform validity checks on the args. else leave it to the user.
    if (nCol<0 || nCol >= m_colCount || (str != MMCLV_NOPTR && str != MMC_TEXTCALLBACK))
        return (sc = E_INVALIDARG).ToHr();

    if (pri != NULL)
    {
        nItem = ResultItemToIndex(pri);
        if (nItem == -1)
            return (sc = E_INVALIDARG).ToHr();
    }

    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask=0;
    lvi.iItem = nItem;
    USES_CONVERSION;
    lvi.mask|=LVIF_TEXT;
    lvi.pszText=LPSTR_TEXTCALLBACK;

    // If the user has specified an icon index, put it in the LV_ITEM struct
    if((nImage!=MMCLV_NOICON)&&(m_resultIM.Lookup(&CImageIndexMapKey((COMPONENTID)ownerID,nImage), lvi.iImage)))
        lvi.mask|=LVIF_IMAGE;

    // If the user requested a state.  put it in the LV_ITEM struct.
    if(nState!=MMCLV_NOPARAM)
    {
        lvi.mask|=LVIF_STATE;
        lvi.stateMask=0xFFFFFFFF;
        lvi.state=nState;
    }

    lvi.iSubItem=nCol;

    CListCtrl& lc = GetListCtrl();

    if (!lc.SetItem (&lvi))
        sc = E_FAIL;

    // If the user has specified an lParam or image, and the Set was succesful,
    // put the lParam and the image's back index in the mapping.
    if (!sc.IsError())
    {
        if ((pri == NULL) && ((pri = IndexToResultItem (nItem)) == NULL))
            sc = E_FAIL;

        if (!sc.IsError())
        {
            if (lParam != MMCLV_NOPARAM)
                pri->SetSnapinData (lParam);

            if (nImage != MMCLV_NOICON)
                pri->SetImageIndex (nImage);
        }

        // if ensure focus visible style and focus set, force item into view
        if (m_bEnsureFocusVisible && nState != MMCLV_NOPARAM && (nState & LVIS_FOCUSED))
            lc.EnsureVisible(nItem, FALSE);
    }

    return (sc.ToHr());
}


HRESULT CCCListViewCtrl::GetNextItem(COMPONENTID ownerID, long nIndex,
                                   UINT nState, CResultItem*& priNextItem, long& nIndexNextItem)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::GetNextItem"));

    CListCtrl& lc = GetListCtrl();

    priNextItem    = 0;
    nIndexNextItem = -1;

    while (1)
    {
        nIndex = lc.GetNextItem (nIndex, nState);

        if (nIndex == -1)
            break;

        if (IsVirtual())
        {
            nIndexNextItem = nIndex;
            break;
        }

        CResultItem* pri = IndexToResultItem (nIndex);

        if ((pri != NULL) && ((pri->GetOwnerID() == ownerID) || (pri->IsScopeItem())))
        {
            priNextItem    = pri;
            nIndexNextItem = nIndex;
            break;
        }
    }

    return (sc = (nIndexNextItem != -1) ? S_OK : S_FALSE).ToHr();
}

HRESULT CCCListViewCtrl::GetItem(
    int         nItem,
    CResultItem*& pri,
    long        nCol,
    LPOLESTR*   str,
    int*        pnImage,
    LPARAM*     pLParam,
    UINT*       pnState,
    BOOL*       pbScopeItem)
{
    USES_CONVERSION;
    if ((nCol < 0) || (nCol >= m_colCount))
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    CListCtrl& lc = GetListCtrl();

    if (IsVirtual())
    {
        //Virtual list can only be queried for state
        if ((pri != NULL) || (nItem < 0) || (nItem >= m_itemCount) ||
            (str != MMCLV_NOPTR) || (pnImage != MMCLV_NOPTR) || (pLParam != MMCLV_NOPTR))
        {
            ASSERT(FALSE);
            hr = E_INVALIDARG;
        }
        else if (pnState != MMCLV_NOPTR)
        {
            *pnState = lc.GetItemState (nItem, 0xFFFFFFFF);

            // for virtual list, it's never a scope item
            if (pbScopeItem != NULL)
                *pbScopeItem = FALSE;
        }
    }
    else
    {
        if (pri != 0)
            nItem = ResultItemToIndex(pri);

        if (nItem < 0 || nItem >= m_itemCount)
            hr = E_INVALIDARG;

        else
        {
            pri = IndexToResultItem (nItem);
			if ( pri == NULL )
				return E_UNEXPECTED;

            // if the text was requested, get that seperatly so that we can use GETITEMTEXT to
            // dynamically size the buffer.
            if (str != MMCLV_NOPTR)
            {
                CString strText = lc.GetItemText (nItem, nCol);
                *str = ::CoTaskDupString (T2COLE (strText));
            }


            // get the state if requested
            if (pnState != MMCLV_NOPTR)
                *pnState = lc.GetItemState (nItem, 0xFFFFFFFF);

            // Nodemgr will unravel pri & get required data (lparam & image index).
            if (pri->IsScopeItem())
                return hr;

            // get the image, pLParam, or scope item,  if requested
            if ((pnImage  != MMCLV_NOPTR) ||
                (pLParam  != MMCLV_NOPTR) ||
                (pbScopeItem != NULL))
            {
                if (pri != NULL)
                {
                    if (pnImage != MMCLV_NOPTR)
                        *pnImage = pri->GetImageIndex();

                    if (pLParam != MMCLV_NOPTR)
                        *pLParam = pri->GetSnapinData();

                    // set the scope item flag
                    if (pbScopeItem != NULL)
                        *pbScopeItem = pri->IsScopeItem();
                }
                else
                    hr = E_FAIL;

            }
        }
    }

    return hr;
}


HRESULT CCCListViewCtrl::GetLParam(long nItem, CResultItem*& pri)
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::GetLParam"));

    if (IsVirtual())
        return (sc = E_UNEXPECTED).ToHr();

    pri = IndexToResultItem (nItem);
    if (pri == NULL)
        sc = E_FAIL;

    return (sc.ToHr());
}

HRESULT CCCListViewCtrl::ModifyItemState(long nItem, CResultItem* pri,
                                       UINT add, UINT remove)
{
    ASSERT(((pri != 0) && !IsVirtual()) || (nItem >= 0));

    // Can only set focus and selected states for virtual item
    if (IsVirtual() && ((add | remove) & ~(LVIS_FOCUSED | LVIS_SELECTED)))
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    HRESULT hr = E_FAIL;

    if (pri != 0 && !IsVirtual())
        nItem = ResultItemToIndex(pri);

    if (nItem >= 0)
    {
        LV_ITEM lvi;
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.iItem     = nItem;
        lvi.mask      = LVIF_STATE;
        lvi.stateMask = add | remove;
        lvi.state     = add;

        hr = (GetListCtrl().SetItemState (nItem, &lvi)) ? S_OK : E_FAIL;

        // if ensure focus visible style and focus set, force item into view
        if (m_bEnsureFocusVisible && (add & LVIS_FOCUSED))
            GetListCtrl().EnsureVisible(nItem, FALSE);
    }

    return hr;
}


HRESULT CCCListViewCtrl::SetIcon(long ownerID, HICON hIcon, long nLoc)
{
	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());

    /*
     * pick the flags out of nLoc
     */
    bool fChangeLargeIcon = nLoc & ILSIF_LEAVE_SMALL_ICON;
    bool fChangeSmallIcon = nLoc & ILSIF_LEAVE_LARGE_ICON;
    nLoc &= ~ILSIF_LEAVE_MASK;

    /*
     * make sure the XOR below will work
     */
    ASSERT ((fChangeLargeIcon == 0) || (fChangeLargeIcon == 1));
    ASSERT ((fChangeSmallIcon == 0) || (fChangeSmallIcon == 1));

    CImageIndexMapKey searchKey((COMPONENTID)ownerID, nLoc);
    int nNdx1;
    int nNdx2;

    HRESULT hr = S_OK;

    BOOL fExists = m_resultIM.Lookup(&searchKey, nNdx1);

    /*
     * are we changing the large or small icon only?
     */
    if (fChangeSmallIcon ^ fChangeLargeIcon)
    {
        /*
         * there must be an icon at nLoc already
         */
        if (!fExists)
            hr = E_INVALIDARG;

        /*
         * changing the large icon?
         */
        else if (fChangeLargeIcon)
        {
            if (m_largeIL.Replace(nNdx1, hIcon) != nNdx1)
                hr = E_FAIL;
        }

        /*
         * otherwise, changing the small icon?
         */
        else
        {
            if (m_smallIL.Replace(nNdx1, hIcon) != nNdx1)
                hr = E_FAIL;
        }
    }
    else if (fExists)
    {
        nNdx2 = m_smallIL.Replace(nNdx1, hIcon);

        if (nNdx2 == -1)
        {
            hr = E_FAIL;
        }
        else
        {
            if(nNdx2 != nNdx1)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                nNdx2 = m_largeIL.Replace(nNdx1, hIcon);
                if(nNdx2 != nNdx1)
                    hr = E_UNEXPECTED;
            }
        }
    }
    else
    {
        // Insert items and store indices in large and small
        nNdx1 = m_smallIL.Add(hIcon);

        if (nNdx1 != -1)
            nNdx2 = m_largeIL.Add(hIcon);

        if (nNdx1 == -1)
        {
            hr = E_FAIL;
        }
        else if (nNdx2 == -1)
        {
            m_smallIL.Remove (nNdx1);
            hr = E_FAIL;
        }
        else if(nNdx1 != nNdx2)
        {
            m_smallIL.Remove (nNdx1);
            m_largeIL.Remove (nNdx2);
            hr = E_UNEXPECTED;
        }
        else
        {
            // Generate a new key and store the values in the maps
            PImageIndexMapKey pKey = new CImageIndexMapKey((COMPONENTID)ownerID, nLoc);
            m_resultIM[pKey] = nNdx1;
        }
    }

#ifdef DBG
	if (tagListImages.FAny())
	{
		DrawOnDesktop (m_smallIL, 0, 0);
		DrawOnDesktop (m_largeIL, 0, 32);
	}
#endif

	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
    return hr;
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::SetImageStrip
 *
 * Adds one or more images to the imagelist.  Bitmaps are owned (and
 * released) by the caller.
 *--------------------------------------------------------------------------*/

HRESULT CCCListViewCtrl::SetImageStrip (
	long	ownerID,
	HBITMAP	hbmSmall,
	HBITMAP	hbmLarge,
	long 	nStartLoc,
	long	cMask)
{
	DECLARE_SC (sc, _T("CCCListViewCtrl::SetImageStrip"));
	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());

	/*
	 * valid start index?
	 */
    if (nStartLoc < 0)
		return ((sc = E_INVALIDARG).ToHr());

	/*
	 * valid bitmaps?
	 */
	sc = ScCheckPointers (hbmSmall, hbmLarge);
	if (sc)
		return (sc.ToHr());

    BITMAP bmSmall;
    if (!GetObject (hbmSmall, sizeof(BITMAP), &bmSmall))
		return (sc.FromLastError().ToHr());

    BITMAP bmLarge;
    if (!GetObject (hbmLarge, sizeof(BITMAP), &bmLarge))
		return (sc.FromLastError().ToHr());

	/*
	 * are the small and large bitmaps of the integral dimensions,
	 * and do they have the same number of images?
	 */
    if ( (bmSmall.bmHeight != 16) || (bmLarge.bmHeight != 32) ||
		 (bmSmall.bmWidth   % 16) || (bmLarge.bmWidth   % 32) ||
		((bmSmall.bmWidth   / 16) != (bmLarge.bmWidth   / 32)))
    {
		return ((sc = E_INVALIDARG).ToHr());
    }

	const int cEntries = bmSmall.bmWidth / 16;

	/*
	 * make copies of the input bitmaps because CImageList::Add (which calls
	 * ImageList_AddMasked) will screw up the background color
	 */
	CBitmap bmpSmall, bmpLarge;
	bmpSmall.Attach (CopyBitmap (hbmSmall));
	bmpLarge.Attach (CopyBitmap (hbmLarge));

	if ((bmpSmall.GetSafeHandle() == NULL) || (bmpLarge.GetSafeHandle() == NULL))
		return (sc.FromLastError().ToHr());

	/*
	 * add the small image
	 */
    const int nFirstNewIndexSmall = m_smallIL.Add (&bmpSmall, cMask);
	if (nFirstNewIndexSmall == -1)
		return (sc.FromLastError().ToHr());

	/*
	 * add the large image
	 */
    const int nFirstNewIndexLarge = m_largeIL.Add (&bmpLarge, cMask);
    if (nFirstNewIndexLarge == -1)
    {
		/*
		 * Images can be added many at a time, but only removed one at
		 * a time.  Remove each entry we added.
		 */
		for (int i = 0; i < cEntries; i++)
			m_smallIL.Remove (nFirstNewIndexSmall);

		ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
		return (sc.FromLastError().ToHr());
    }

	/*
	 * if the starting indices of the large and small images aren't
	 * the same, we screwed
	 */
    if (nFirstNewIndexSmall != nFirstNewIndexLarge)
    {
		/*
		 * Images can be added many at a time, but only removed one at
		 * a time.  Remove each entry we added.
		 */
		for (int i = 0; i < cEntries; i++)
		{
			m_smallIL.Remove (nFirstNewIndexSmall);
			m_largeIL.Remove (nFirstNewIndexLarge);
		}

		ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
		return ((sc = E_UNEXPECTED).ToHr());
    }

	// Keep the map updated for each newly inserted image.
	for(int i=0; i < cEntries; i++)
	{
		CImageIndexMapKey searchKey((COMPONENTID)ownerID, nStartLoc+i);

		// if the item exists in the map, replace the value, else create a new
		// key and set the value.

		int nIndex = nFirstNewIndexSmall;
		// use copy of nFirstNewIndexSmall as Lookup modifies nIndex.
		if(m_resultIM.Lookup(&searchKey, nIndex))
			m_resultIM[&searchKey] = nFirstNewIndexSmall+i;
		else
			m_resultIM[new CImageIndexMapKey((COMPONENTID)ownerID, nStartLoc+i)] = nFirstNewIndexSmall+i;
	}

#ifdef DBG
	if (tagListImages.FAny())
	{
		DrawOnDesktop (m_smallIL, 0,  0);
		DrawOnDesktop (m_largeIL, 0, 32);
	}
#endif

	ASSERT (m_smallIL.GetImageCount() == m_largeIL.GetImageCount());
	return (sc.ToHr());
}

HRESULT CCCListViewCtrl::MapImage(long ownerID, long nLoc, int far *pResult)
{
    CImageIndexMapKey searchKey((COMPONENTID)ownerID, nLoc);
    HRESULT hr = S_OK;

    ASSERT(pResult);

    if(!(m_resultIM.Lookup(&searchKey, *((int *)pResult))))
        hr = E_FAIL;

    return hr;
}


HRESULT CCCListViewCtrl::Reset()
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::Reset"));

    // Note: we must call this->DeleteAllItems(TVOWNED_MAGICWORD) & not
    // GetListCtrl().DeleteAllItems() to ensure that all internal data
    // is cleaned up.
    DeleteAllItems(TVOWNED_MAGICWORD);

    ASSERT(GetListCtrl().GetItemCount() == 0);
    ASSERT(m_itemCount == 0);
    ASSERT(m_nScopeItems == 0);

    m_resultIM.RemoveAll();

    m_smallIL.DeleteImageList();
    m_largeIL.DeleteImageList();

    sc = ScSetImageLists();
    if (sc)
        return (sc.ToHr());

    // Delete all columns
    while (SUCCEEDED (DeleteColumn(0))) {};

    if (m_pListView)
        sc = m_pListView->ScResetColumnStatusData();

    if (sc)
        sc.TraceAndClear();

    // reset lexical sorting until Sort is called again
    m_sortParams.bLexicalSort = FALSE;

    // release the snap-in's compare interfaces
    m_sortParams.spResultCompare = NULL;
    m_sortParams.spResultCompareEx = NULL;

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:     SortCompareFunc
//
//  Synopsis:   Compare two items, called by list control sort.
//
//  Arguments:  [lParam1]      - Item1's lparam.
//              [lParam2]      - Item2's lparam.
//              [pSortParams_] - ptr to SortParams.
//
//  Note:       If snapin wants lexical sort do default-compare.
//              Else if snapin has IResultDataCompare[Ex] then call it
//              Else do default-compare.
//
//  Returns:    -1 : item1 < item2
//               0 : item1 == item2
//              +1 : item1 > item2
//
//--------------------------------------------------------------------
int CALLBACK CCCListViewCtrl::SortCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams_)
{
    SortParams*  pSortParams = reinterpret_cast<SortParams*>(pSortParams_);
    ASSERT (pSortParams != NULL);

    CCCListViewCtrl* pListView   = reinterpret_cast<CCCListViewCtrl*>(pSortParams->lpListView);
    ASSERT (pListView != NULL);

    CResultItem* pri1 = CResultItem::FromHandle (lParam1);
    CResultItem* pri2 = CResultItem::FromHandle (lParam2);

    if (pri1 == NULL || pri2 == NULL)
    {
        ASSERT(FALSE);
        return 0;
    }

    BOOL bScope1 = pri1->IsScopeItem();
    BOOL bScope2 = pri2->IsScopeItem();

    int iResult;

    // if snap-in provides extended compare method
    if (pSortParams->spResultCompareEx != NULL)
    {
        ASSERT(pSortParams->lpNodeCallback);
        if (NULL == pSortParams->lpNodeCallback)
            return 0;             // Error

        COMPONENTID ItemID;
        BOOL bOwned1 = !bScope1 ||
                        ((pSortParams->lpNodeCallback->GetNodeOwnerID(pri1->GetScopeNode(), &ItemID) == S_OK) &&
                         (ItemID == pSortParams->OwnerID));

        BOOL bOwned2 = !bScope2 ||
                        ((pSortParams->lpNodeCallback->GetNodeOwnerID(pri2->GetScopeNode(), &ItemID) == S_OK) &&
                         (ItemID == pSortParams->OwnerID));

        // let snap-in order all items that it owns (scope and result)
        // put rest of items items after owned items
        if (bOwned1 && bOwned2)
            iResult = SnapinCompareEx(pSortParams, pri1, pri2);
        else if (bOwned1 || bOwned2)
            iResult = bOwned1 ? -1 : 1;
        else
			// DefaultCompare flips results depending on ascending or descending.
            return DefaultCompare(lParam1, lParam2, pSortParams_);
    }
    // do default sorting
    else
    {
        // pass result items to original compare method if provided, else to default sort
        if (!bScope1 && !bScope2)
        {
            if (pSortParams->spResultCompare != NULL)
                iResult = SnapinCompare(pSortParams, pri1, pri2);
            else
                // DefaultCompare flips results depending on ascending or descending.
                return DefaultCompare(lParam1, lParam2, pSortParams_);
        }
        // do not order scope items, just put them ahead of result items
        else
        {
            iResult = (bScope1 && bScope2) ? 0 : (bScope1 ? -1 : 1);
        }
    }

    // flip order for descending sort
    return pSortParams->bAscending ? iResult : -iResult;
}


//+-------------------------------------------------------------------
//
//  Member:     DefaultCompare
//
//  Synopsis:   Compare two items, called by list control sort.
//              This is used if snapin wants default compare or
//              if it does not implement IResultDataCompare or
//              IResultDataCompareEx interfaces
//
//  Arguments:  [lParam1]      - Item1's lparam.
//              [lParam2]      - Item2's lparam.
//              [pSortParams] - ptr to SortParams.
//
//  Note:       If one is scope item and other is result item
//                          place scope item before result item.
//              Else get the text for both items and do string compare.
//
//  Returns:    -1 : item1 < item2
//               0 : item1 == item2
//              +1 : item1 > item2
//
//--------------------------------------------------------------------
int CALLBACK CCCListViewCtrl::DefaultCompare(LPARAM lParam1, LPARAM lParam2, LPARAM pSortParams_)
{
    SortParams*  pSortParams = reinterpret_cast<SortParams*>(pSortParams_);
    ASSERT(NULL != pSortParams);
    if (NULL == pSortParams)
        return 0;

    CResultItem* pri1 = CResultItem::FromHandle (lParam1);
    CResultItem* pri2 = CResultItem::FromHandle (lParam2);
    ASSERT( (NULL != pri1) && (NULL != pri2));
    if ( (NULL == pri1) || (NULL == pri2) )
        return 0;

    bool bScope1 = pri1->IsScopeItem();
    bool bScope2 = pri2->IsScopeItem();

    // If one of the item is scope pane item
    // scope item goes before result item.
    if (bScope1 != bScope2)
	{
		int iResult = bScope1 ? -1 : 1;
		return pSortParams->bAscending ? iResult : -iResult;
	}

    LPNODECALLBACK lpNodeCallback = pSortParams->lpNodeCallback;
    ASSERT(lpNodeCallback);
    if (NULL == lpNodeCallback)
         return 0;

    HRESULT hr = E_FAIL;
    CString strText1;
    CString strText2;

    if (bScope1)
    {
        // Both scope items, get the text for each item.
        HNODE hNode1 = pri1->GetScopeNode();
        HNODE hNode2 = pri2->GetScopeNode();

        USES_CONVERSION;
		tstring strName;

        // GetDisplayName uses a static array to return name so no need to free it.
        hr = lpNodeCallback->GetDisplayName(hNode1, strName);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
            strText1 = strName.data();

        hr = lpNodeCallback->GetDisplayName(hNode2, strName);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
            strText2 = strName.data();
    }
    else // both items are result items.
    {
        ASSERT(!bScope1 && ! bScope2);
        CCCListViewCtrl* pListView   = reinterpret_cast<CCCListViewCtrl*>(pSortParams->lpListView);
        ASSERT (pListView != NULL);
        ASSERT(pListView->IsVirtual() == FALSE); // Virtual list sort should not come here.

        LV_ITEMW lvi;
        ZeroMemory(&lvi, sizeof(LV_ITEMW));
        lvi.mask       = LVIF_TEXT;
        lvi.iSubItem   = pSortParams->nCol;
        lvi.cchTextMax = MAX_PATH;
        WCHAR szTemp[MAX_PATH+1];
        lvi.pszText    = szTemp;

        ASSERT(NULL != pSortParams->hSelectedNode);
        if (NULL != pSortParams->hSelectedNode)
        {
            lvi.lParam = lParam1;
            hr = lpNodeCallback->GetDispInfo(pSortParams->hSelectedNode, &lvi);
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                strText1 = lvi.pszText;

            lvi.lParam = lParam2;
            hr = lpNodeCallback->GetDispInfo(pSortParams->hSelectedNode, &lvi);
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                strText2 = lvi.pszText;
        }

    }

    if (strText1.IsEmpty() && strText2.IsEmpty())
        return (0);

	int rc = 0;

	/*
	 * Bug 9595: Do locale-sensitive, case-insensitive comparison
	 */
	switch (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, strText1, -1, strText2, -1))
	{
		case CSTR_LESS_THAN:
			rc = -1;
			break;

		case CSTR_EQUAL:
			rc = 0;
			break;

		case CSTR_GREATER_THAN:
			rc = 1;
			break;

		default:
			/*
			 * if an error occurred, fall back to locale-insensitive,
			 * case-insensitive comparison
			 */
			rc = _tcsicmp (strText1, strText2);
			break;
	}

	return pSortParams->bAscending ? rc: -rc;
}


int CCCListViewCtrl::SnapinCompare(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2)
{
    ASSERT(pSortParams->spResultCompare != NULL);

    // Set nResult to the current column
    int nResult = pSortParams->nCol;

    HRESULT hr = pSortParams->spResultCompare->Compare(pSortParams->lpUserParam, pri1->GetSnapinData(), pri2->GetSnapinData(), &nResult);

    return SUCCEEDED(hr) ? nResult : 0;
}

int CCCListViewCtrl::SnapinCompareEx(SortParams* pSortParams, CResultItem* pri1, CResultItem* pri2)
{
    ASSERT(pSortParams->spResultCompareEx != NULL);

    RDITEMHDR rdch1;
    RDITEMHDR rdch2;

    if (pri1->IsScopeItem())
    {
        rdch1.dwFlags = RDCI_ScopeItem;
        pSortParams->lpNodeCallback->GetNodeCookie(pri1->GetScopeNode(), &rdch1.cookie);
    }
    else
    {
        rdch1.dwFlags = 0;
        rdch1.cookie = pri1->GetSnapinData();
    }

    if (pri2->IsScopeItem())
    {
        rdch2.dwFlags = RDCI_ScopeItem;
        pSortParams->lpNodeCallback->GetNodeCookie(pri2->GetScopeNode(), &rdch2.cookie);
    }
    else
    {
        rdch2.dwFlags = 0;
        rdch2.cookie = pri2->GetSnapinData();
    }

    rdch1.lpReserved = 0;
    rdch2.lpReserved = 0;

    RDCOMPARE rdc;
    rdc.cbSize = sizeof(rdc);
    rdc.dwFlags = 0;
    rdc.nColumn = pSortParams->nCol;
    rdc.lUserParam = pSortParams->lpUserParam;
    rdc.prdch1 = &rdch1;
    rdc.prdch2 = &rdch2;

    int nResult = 0;
    HRESULT hr = pSortParams->spResultCompareEx->Compare(&rdc, &nResult);

    return SUCCEEDED(hr) ? nResult : 0;
}


HRESULT CCCListViewCtrl::Arrange(long style)
{
    return ((GetListCtrl().Arrange (style)) ? S_OK : S_FALSE);
}


HRESULT CCCListViewCtrl::Repaint(BOOL bErase)
{
    m_pListView->Invalidate(bErase);
    return S_OK;
}



HRESULT CCCListViewCtrl::SetItemCount(int iItemCount, DWORD dwOptions)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::SetItemCount"));

    ASSERT(iItemCount >= 0);
    ASSERT((dwOptions & ~(LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL)) == 0);

    // Ask the CAMCListViewCtrl to setup headers & set the flag.
    sc = ScCheckPointers(m_pListView, E_UNEXPECTED);
    if (! sc.IsError())
        sc = m_pListView->ScRestoreColumnsFromPersistedData();

    if (sc)
        sc.TraceAndClear();

    int iTop = ListView_GetTopIndex(GetListCtrl());

    if (ListView_SetItemCountEx (GetListCtrl(), iItemCount, dwOptions))
    {
        // if virtual list, update the item count
        // if not virtual, SetItemCount just reserves space for new items
        if (IsVirtual())
            m_itemCount = iItemCount;
    }
    else
    {
        ASSERT(FALSE);
        sc = E_FAIL;
    }

    iTop = ListView_GetTopIndex(GetListCtrl());

    if (sc)
        return sc.ToHr();

    // we cannot track any items any more - broadcast the message to observers
    sc = ScFireEvent(CListViewObserver::ScOnListViewIndexesReset);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


HRESULT CCCListViewCtrl::SetChangeTimeOut(ULONG lTimeout)
{
    BOOL bStat = FALSE;

    CAMCHeaderCtrl* pHeaderCtrl = NULL; 
    if ((pHeaderCtrl = GetHeaderCtrl()))
        bStat = ::SendMessage(pHeaderCtrl->m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)lTimeout);

    return (bStat ? S_OK : E_FAIL);
}


HRESULT CCCListViewCtrl::SetColumnFilter(int nCol, DWORD dwType, MMC_FILTERDATA* pFilterData)
{
    HRESULT hr = S_OK;

    USES_CONVERSION;

    HD_ITEM item;

    do // not a loop
    {
        CAMCHeaderCtrl* pHeaderCtrl = NULL; 
        if ((pHeaderCtrl = GetHeaderCtrl()) == NULL)
        {
            hr = E_FAIL;
            break;
        }

        DWORD dwTypeOnly = dwType & ~MMC_FILTER_NOVALUE;
        BOOL bHasValue = !(dwType & MMC_FILTER_NOVALUE);

        // Validate filter type
        ASSERT(dwTypeOnly == MMC_INT_FILTER || dwTypeOnly == MMC_STRING_FILTER);
        if (!(dwTypeOnly == MMC_INT_FILTER || dwTypeOnly == MMC_STRING_FILTER))
        {
            hr = E_INVALIDARG;
            break;
        }

        // Check for non-null filterdata and pszText
        if ( ((dwType == MMC_STRING_FILTER || bHasValue) && pFilterData == NULL) ||
            (dwType == MMC_STRING_FILTER && bHasValue && pFilterData->pszText == NULL) )
        {
            ASSERT(FALSE);
            hr = E_POINTER;
            break;
        }

        ZeroMemory(&item, sizeof(item));
        item.mask = HDI_FILTER;
        item.type = dwType;

        HD_TEXTFILTER textFilter;

        switch (dwTypeOnly)
        {
        case MMC_INT_FILTER:
            item.pvFilter = &pFilterData->lValue;
            break;

        case MMC_STRING_FILTER:
            {
                item.pvFilter = &textFilter;
                textFilter.cchTextMax = pFilterData->cchTextMax;

                if (bHasValue)
                    textFilter.pszText = OLE2T(pFilterData->pszText);
                break;
            }

        default:
            ASSERT(FALSE);
        }

        if (!pHeaderCtrl->SetItem(nCol, &item))
        {
            ASSERT(FALSE);
            hr = E_FAIL;
        }
    }
    while(0);

    return hr;
}


HRESULT CCCListViewCtrl::GetColumnFilter(int nCol, DWORD* pdwType, MMC_FILTERDATA* pFilterData)
{

    HRESULT hr = S_OK;

    USES_CONVERSION;
    HD_ITEM item;


    do  // not a loop
    {
        CAMCHeaderCtrl* pHeaderCtrl = NULL; 
        if ((pHeaderCtrl = GetHeaderCtrl()) == NULL)
        {
            hr = E_FAIL;
            break;
        }

        ASSERT(pdwType != NULL);
        if (pdwType == NULL)
        {
            hr = E_POINTER;
            break;
        }

        ASSERT(*pdwType == MMC_INT_FILTER || *pdwType == MMC_STRING_FILTER);
        if (!(*pdwType == MMC_INT_FILTER || *pdwType == MMC_STRING_FILTER))
        {
            hr = E_INVALIDARG;
            break;
        }

        ASSERT(!(*pdwType == MMC_STRING_FILTER && pFilterData != NULL && pFilterData->pszText == NULL));
        if ((*pdwType == MMC_STRING_FILTER && pFilterData != NULL && pFilterData->pszText == NULL))
        {
            hr = E_INVALIDARG;
            break;
        }

        ZeroMemory(&item, sizeof(item));
        item.mask = HDI_FILTER;
        item.type = *pdwType;

        HD_TEXTFILTER textFilter;

        if (pFilterData != 0)
        {
            switch (*pdwType)
            {
            case MMC_INT_FILTER:
                item.pvFilter = &pFilterData->lValue;
                break;

            case MMC_STRING_FILTER:
                {
                    item.pvFilter = &textFilter;
                    textFilter.pszText = (LPTSTR)alloca((pFilterData->cchTextMax + 1) * sizeof(TCHAR));
                    textFilter.pszText[0] = 0;
                    textFilter.cchTextMax = pFilterData->cchTextMax;
                    break;
                }

            default:
                ASSERT(FALSE);
            }
        }

        BOOL bStat = pHeaderCtrl->GetItem(nCol, &item);
        if (!bStat)
            hr = E_FAIL;

        // NOTE: pHeaderCtrl->GetItem() fails when a string filter is empty
        // Until this is fixed, assume that the error is caused by this
        // and fake an empty string result
        if (hr == E_FAIL && item.type == MMC_STRING_FILTER)
        {
            item.type |= HDFT_HASNOVALUE;
            hr = S_OK;
        }

        // if requested string filter value, convert to caller's buffer
        if (hr == S_OK && item.type == MMC_STRING_FILTER && pFilterData != NULL)
        {
            ocscpy(pFilterData->pszText, T2OLE(textFilter.pszText));
        }

        *pdwType = item.type;
    }
    while(0);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnSortIcon
//
//  Synopsis:   Set sort arrow if needed.
//
//  Arguments:  [nNewCol]      - The column for which arrow should be set.
//              [nOldCol]      - The previous column, remove sort arrow.
//              [bAscending]   - Ascending/Descending.
//              [bSetSortIcon] - If arrow is needed or not.
//
//  Returns:    S_OK.
//
//  History:    04-01-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
HRESULT CCCListViewCtrl::SetColumnSortIcon(int nNewCol, int nOldCol,
                                           BOOL bAscending, BOOL bSetSortIcon)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::SetColumnSortIcon"));

    LVCOLUMN lvcol, lvOriginalCol;
    ZeroMemory(&lvcol, sizeof(lvcol));
    lvcol.mask = LVCF_FMT | LVCF_IMAGE;
    ZeroMemory(&lvOriginalCol, sizeof(lvOriginalCol));
    lvOriginalCol.mask = LVCF_FMT;

    // update the old column
    if ( nOldCol >= 0 )
    {
        // retrieve old frmt settings
        if ( !GetListCtrl().GetColumn(nOldCol, &lvOriginalCol) )
            return (sc = E_FAIL).ToHr();

        // make the new format settings
        // transfer old values such as LVCFMT_CENTER, which we do not want to change
        // see windows bugs (ntbug09) #153029 10/09/00
        lvcol.fmt = lvOriginalCol.fmt & ~(LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);

        // Reset the previous column's sort icon with blank icon.
        lvcol.iImage = -1;
        if ( !GetListCtrl().SetColumn(nOldCol, &lvcol) )
            return (sc = E_FAIL).ToHr();
    }

    // We have to add sort icon only if LV items can be sorted.
    // This is possible only if any of following condition is true.
    //    a. there are any result items in result pane         OR
    //    b. snapin supports IResultDataCompare                OR
    //    c. snapin supports IResultDataCompareEx              OR
    //    d. snapin wants default lexical sort                 OR
    //    e. snapin has virtual list

    BOOL bCanSortListView = (0 != (m_itemCount - m_nScopeItems))     ||
                            (NULL != m_sortParams.spResultCompare)   ||
                            (NULL != m_sortParams.spResultCompareEx) ||
                            (TRUE == m_sortParams.bLexicalSort)      ||
                            (IsVirtual());

    if ( bCanSortListView && bSetSortIcon)
    {
        // retrieve old frmt settings
        if ( !GetListCtrl().GetColumn(nNewCol, &lvOriginalCol) )
            return (sc = E_FAIL).ToHr();

        // make the new format settings
        // transfer old values such as LVCFMT_CENTER, which we do not want to change
        // see windows bugs (ntbug09) #153029 10/09/00
        lvcol.fmt = lvOriginalCol.fmt | LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT;

        // Set the sort icon for new column.
        lvcol.iImage = (bAscending) ? 0 : 1;
        if ( !GetListCtrl().SetColumn(nNewCol, &lvcol) )
            return (sc = E_FAIL).ToHr();
    }

    // De-select all the items in virtual list.
    if (IsVirtual())
    {
        int nItem = -1;
        LV_ITEM lvi;
        lvi.stateMask = LVIS_SELECTED;
        lvi.state     = ~LVIS_SELECTED;

       while ( (nItem = GetListCtrl().GetNextItem(nItem, LVNI_SELECTED)) != -1)
       {
          GetListCtrl().SetItemState(nItem, &lvi);
       }
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScRedrawHeader
//
//  Synopsis:    Need to send WM_SETREDRAW to headers to reduce flicker
//               when persisted column data is applied.
//               Turn it off before sending MMCN_SHOW to snapins and turn
//               it on after MMCN_SHOW returns.
//
//  Arguments:   [bRedraw] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScRedrawHeader (bool bRedraw)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScRedrawHeader"));

    CAMCHeaderCtrl* pHeader = GetHeaderCtrl();
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    int nViewMode  = GetViewMode();

    // Turn off/on the header only if it is report or filtered mode.

    // If turned on in other modes comctl does not take care of different
    // mode and will show headers (eg: in large icon mode).

    if ( (nViewMode != MMCLV_VIEWSTYLE_REPORT) && (nViewMode != MMCLV_VIEWSTYLE_FILTERED) )
		return sc;

    pHeader->SetRedraw(bRedraw);

    // If redraw is true then repaint the control.
    if (bRedraw)
        pHeader->InvalidateRect(NULL);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::SetLoadMode
 *
 * PURPOSE:  Turn on/off redraw on list control & header control when
 *           persisted list view settings (columns...) are applied.
 *
 * PARAMETERS:
 *    BOOL bState - load state, true -> turn-off redraw, false -> turn-on redraw
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CCCListViewCtrl::SetLoadMode(BOOL bState)
{
	DECLARE_SC(sc, TEXT("CCCListViewCtrl::SetLoadMode"));

    if (bState == m_bLoading)
        return (sc.ToHr());

    if (bState)
    {
        // turn off drawing during loading

		// 1. Turn off header.
        sc = ScRedrawHeader(false);
        if (sc)
            sc.TraceAndClear();

		// 2. Turn off the listcontrol.
		GetListCtrl().SetRedraw(false);
    }
    else
    {
        sc = ScCheckPointers(m_pListView, E_UNEXPECTED);
        if (sc)
            sc.TraceAndClear();
        else
        {
            sc = m_pListView->ScRestoreColumnsFromPersistedData();
            if (sc)
                sc.TraceAndClear();
        }

        // if sort requested while loading, sort the loaded items now
        if (m_bDeferredSort)
        {
			/*
			 * the sort could take awhile, so show a wait cursor
			 */
			CWaitCursor wait;

            GetListCtrl().SortItems (SortCompareFunc, (DWORD_PTR)&m_sortParams);
            m_bDeferredSort = FALSE;
        }

		// 1. Important, first turn on list and then header else header will not be redrawn.
		GetListCtrl().SetRedraw(true);

		// 2. Turn on the header.
        sc = ScRedrawHeader(true);
        if (sc)
            sc.TraceAndClear();
    }

    m_bLoading = bState;

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::GetColumnInfoList
//
//  Synopsis:    Get the current column settings.
//
//  Arguments:   [pColumnsList] - [out param], ptr to CColumnsInfoList.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CCCListViewCtrl::GetColumnInfoList (CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::GetColumnInfoList"));
    sc = ScCheckPointers(pColumnsList);
    if (sc)
        return sc.ToHr();

    CAMCListView *pAMCListView = GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pAMCListView->ScGetColumnInfoList(pColumnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ModifyColumns
//
//  Synopsis:    Modify the columns with given data.
//
//  Arguments:   [columnsList] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CCCListViewCtrl::ModifyColumns (const CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ModifyColumns"));
    CAMCListView *pAMCListView = GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pAMCListView->ScModifyColumns(columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::GetDefaultColumnInfoList
//
//  Synopsis:    Get the default column settings
//
//  Arguments:   [columnInfoList] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CCCListViewCtrl::GetDefaultColumnInfoList (CColumnInfoList& columnInfoList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetDefaultColumnInfoList"));
    CAMCListView *pAMCListView = GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pAMCListView->ScGetDefaultColumnInfoList(columnInfoList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::RenameItem
 *
 * PURPOSE: Puts the specified result item into rename mode.
 *
 * PARAMETERS:
 *    CResultItem* pri :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CCCListViewCtrl::RenameItem(HRESULTITEM itemID)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::RenameItem"));

    int nIndex = -1;
    sc = ScGetItemIndexFromHRESULTITEM(itemID, nIndex);
    if (sc)
        return sc.ToHr();

    if(nIndex < 0 || nIndex >= m_itemCount)
        return (sc = E_INVALIDARG).ToHr();

    // must have the focus to rename
    if (::GetFocus()!= GetListCtrl())
        SetFocus(GetListCtrl());

    // if the rename failed, E_FAIL is returned.
    if(NULL==GetListCtrl().EditLabel(nIndex))
        return (sc=E_FAIL).ToHr();

    return sc.ToHr();
}



HRESULT CCCListViewCtrl::OnModifyItem(CResultItem* pri)
{
    HRESULT hr = S_OK;

    int nItem = ResultItemToIndex(pri);
    if(nItem < 0 || nItem >= m_itemCount)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    LV_ITEM     lvi;
    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask        = LVIF_TEXT | LVIF_IMAGE;
    lvi.iItem       = nItem;
    lvi.pszText     = LPSTR_TEXTCALLBACK;
    lvi.iImage      = I_IMAGECALLBACK;

    GetListCtrl().SetItem( &lvi );

    if (!GetListCtrl().RedrawItems (nItem, nItem))
        hr = E_FAIL;
    CHECK_HRESULT(hr);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:      CCCListViewCtrl::ScSelectAll
//
//  Synopsis:    Select all the items in the list view.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CCCListViewCtrl::ScSelectAll ()
{
    DECLARE_SC(sc, _T("CCCListViewCtrl::ScSelectAll"));

    LV_ITEM lvi;
    lvi.stateMask = lvi.state = LVIS_SELECTED;
    for (int i = 0; i < GetListCtrl().GetItemCount(); ++i)
    {
        // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
        if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(i), (LPARAM)(LV_ITEM FAR *)&lvi))
            return (sc = E_FAIL);
    }

    return (sc);
}


//-------------------------------------------------- Windows Hooks

BOOL CCCListViewCtrl::Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext /*=NULL*/ )
{
	DECLARE_SC (sc, _T("CCCListViewCtrl::Create"));
    ASSERT(pParentWnd != NULL && IsWindow(pParentWnd->m_hWnd));

    BOOL bRet = FALSE;

    // standard or virtual ?
    CAMCListView* pListView = (dwStyle & LVS_OWNERDATA) ? m_pVirtualList : m_pStandardList;

    ASSERT(pListView->m_hWnd == NULL);

    if (pListView->Create(NULL, NULL, dwStyle, rect, pParentWnd, nID, pContext))
    {
        // Attach image lists
        sc = ScSetImageLists ();
		if (sc)
		{
			pListView->DestroyWindow();
			return (false);
		}

        // update member variables
        m_bVirtual   = (dwStyle & LVS_OWNERDATA) ? TRUE : FALSE;
        m_pListView  = pListView;
        m_pParentWnd = pParentWnd;

        bRet = TRUE;
    }

    int iTop = ListView_GetTopIndex(GetListCtrl());

    return bRet;
}

SC CCCListViewCtrl::ScSetImageLists ()
{
	DECLARE_SC (sc, _T("CCCListViewCtrl::ScSetImageLists"));
    CListCtrl& lc = GetListCtrl();

    /*
     * if we need to create one list, we should need to create both
     */
    ASSERT ((m_smallIL.GetSafeHandle() == NULL) == (m_largeIL.GetSafeHandle() == NULL));

    /*
     * create the image lists, if necessary
     */
    if (m_smallIL.GetSafeHandle() == NULL)
    {
        if (!m_smallIL.Create(16, 16, ILC_COLORDDB | ILC_MASK, 20, 10) ||
			!m_largeIL.Create(32, 32, ILC_COLORDDB | ILC_MASK, 20, 10))
		{
			goto Error;
		}

        // Add standard MMC bitmaps
        CBitmap bmSmall;
        CBitmap bmLarge;
        if (!bmSmall.LoadBitmap(IDB_AMC_NODES16) || !bmLarge.LoadBitmap(IDB_AMC_NODES32))
			goto Error;

        sc = SetImageStrip (TVOWNED_MAGICWORD, bmSmall, bmLarge, 0, RGB(255,0,255));
		if (sc)
			goto Error;
    }

    /*
     * attach them to the list control
     */
    lc.SetImageList (&m_smallIL, LVSIL_SMALL);
    lc.SetImageList (&m_largeIL, LVSIL_NORMAL);

    /*
     * setting the small image list for the list control overwrites
     * the image list for the header control; fix it up
     */
	{
		CWnd* pwndHeader = GetHeaderCtrl();
		if (pwndHeader != NULL)
			Header_SetImageList (*pwndHeader, (HIMAGELIST) m_headerIL);
	}
	
	return (sc);

Error:
	/*
	 * DeleteImageList is safe to call on uncreated CImageLists
	 */
	m_smallIL.DeleteImageList();
	m_largeIL.DeleteImageList();

	/*
	 * If we haven't filled in the SC with an error code, try last error.
	 * Some (many) APIs fail without setting the last error, so if we still
	 * don't have an error code, give it a generic E_FAIL.
	 */
	if (!sc.IsError())
	{
		sc.FromLastError();

		if (!sc.IsError())
			sc = E_FAIL;
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::OnSysColorChange
 *
 * WM_SYSCOLORCHANGE handler for CCCListViewCtrl.
 *--------------------------------------------------------------------------*/

void CCCListViewCtrl::OnSysColorChange()
{
    m_headerIL.OnSysColorChange();

    CWnd* pwndHeader = GetHeaderCtrl();
    if (pwndHeader != NULL)
        Header_SetImageList (*pwndHeader, (HIMAGELIST) m_headerIL);
}

/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::ScAttachToListPad
 *
 * PURPOSE: Attaches/Detaches the list view to the listpad window. The listpad
 *          window is an IE frame. Attaching occurs by reparenting the list view.
 *
 * PARAMETERS:
 *    HWND  hwnd :  The new parent window, or NULL to detach
 *    HWND* phwnd : 1) non-NULL phwnd: The list view window handle is returned as
 *                     an out parameter
 *                  2) NULL phwnd: Detaches the list view control from the list pad.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
SC
CCCListViewCtrl::ScAttachToListPad (HWND hwnd, HWND* phwnd)
{
    DECLARE_SC (sc, TEXT("CCCListViewCtrl::ScAttachToListPad"));

    CAMCView* pAMCView = dynamic_cast<CAMCView*>(m_pParentWnd); // pointer is checked before usage, no need to test here.

    if (phwnd)
    {
        // attaching

        // are we still attached?
        if (m_SavedHWND)
        {
            //Attaching to ListPad when already attached - just make window exactly the same size as (new) parent
            RECT r;
            ::GetWindowRect (hwnd, &r);

            m_pListView->SetWindowPos (NULL, 0, 0,
                                       r.right-r.left,
                                       r.bottom-r.top, SWP_NOZORDER | SWP_NOACTIVATE);

            return sc;
        }
        else
        {
            // save current parent hwnd and its state
            m_SavedHWND = ::GetParent (m_pListView->m_hWnd);
            m_wp.length = sizeof(WINDOWPLACEMENT);
            ::GetWindowPlacement (m_pListView->m_hWnd, &m_wp);

            // switch to new one
            ::SetParent (m_pListView->m_hWnd, hwnd);
            m_pListView->ShowWindow (SW_SHOW);

            // make window exactly the same size as (new) parent
            RECT r;
            ::GetWindowRect (hwnd, &r);
            m_pListView->SetWindowPos (NULL, 0, 0,
                                       r.right-r.left,
                                       r.bottom-r.top, SWP_NOZORDER);

            // return back my window
            *phwnd = m_pListView->m_hWnd;

            // notify snapin of attach
            if (pAMCView)
                pAMCView->NotifyListPad (phwnd != NULL);
        }
    }
    else
    {
        // detaching
        if (m_SavedHWND == NULL)    // this may get called repeatedly...
            return S_OK;

        // notify snapin of detach
        if (pAMCView)
            pAMCView->NotifyListPad (phwnd != NULL);

        // change back parent window and its state
        HWND hWndNewParent = m_pListView->m_hWnd;

        ::SetParent (m_pListView->m_hWnd, m_SavedHWND);
        if (m_wp.length != 0)
        {
            m_wp.showCmd = SW_HIDE;
            ::SetWindowPlacement (m_pListView->m_hWnd, &m_wp);
        }

        // clear saved window and state
        m_SavedHWND = NULL;
        ZeroMemory (&m_wp, sizeof(WINDOWPLACEMENT));
        Reset();
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::OnCustomDraw
 *
 * NM_CUSTOMDRAW handler for CCCListViewCtrl.
 *--------------------------------------------------------------------------*/

LRESULT CCCListViewCtrl::OnCustomDraw (NMLVCUSTOMDRAW* plvcd)
{
    ASSERT (CWnd::FromHandle (plvcd->nmcd.hdr.hwndFrom) == m_pListView);

    return (m_FontLinker.OnCustomDraw (&plvcd->nmcd));
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::UseFontLinking
 *
 *
 *--------------------------------------------------------------------------*/

bool CCCListViewCtrl::UseFontLinking () const
{
    CAMCView* pAMCView = m_pListView->GetAMCView();
    ASSERT (pAMCView != NULL);

    DWORD dwListOptions = pAMCView->GetViewData()->GetListOptions();
    return (dwListOptions & RVTI_LIST_OPTIONS_USEFONTLINKING);
}

/*+-------------------------------------------------------------------------*
 * CListFontLinker::GetItemText
 *
 *
 *--------------------------------------------------------------------------*/

std::wstring CListFontLinker::GetItemText (NMCUSTOMDRAW* pnmcd) const
{
    NMLVCUSTOMDRAW* plvcd = reinterpret_cast<NMLVCUSTOMDRAW *>(pnmcd);

    int iItem     = pnmcd->dwItemSpec;
    int iSubItem  = (pnmcd->dwDrawStage & CDDS_SUBITEM) ? plvcd->iSubItem : 0;
    CListCtrl& lc = m_pListCtrl->GetListViewPtr()->GetListCtrl();

    USES_CONVERSION;
    return (std::wstring (T2CW (lc.GetItemText (iItem, iSubItem))));
}


/*+-------------------------------------------------------------------------*
 * CListFontLinker::IsAnyItemLocalizable
 *
 *
 *--------------------------------------------------------------------------*/

bool CListFontLinker::IsAnyItemLocalizable () const
{
    return (m_pListCtrl->UseFontLinking ());
}

//############################################################################
//############################################################################

class CMMCResultNode;

/*+-------------------------------------------------------------------------*
 * class CNodes
 *
 *
 * PURPOSE: base class for Nodes collections. Implements most of required methods
 *
 *+-------------------------------------------------------------------------*/
class CNodes :
    public CMMCIDispatchImpl<Nodes>,
    public CTiedComObject<CCCListViewCtrl>, // is tied to CCCListViewCtrl
    public CTiedObject,                     // enumerators are tied to it
    public CListViewObserver
{
protected:
    typedef CCCListViewCtrl CMyTiedObject; // tied to CCCListViewCtrl
private:
    // define collection type for cached Nodes
    typedef std::pair<int /*index*/, CMMCResultNode * /*pNode*/> col_entry_t;
    typedef std::vector<col_entry_t> col_t;

    // define comparison functor for b-search in a collection
    struct index_less : public std::binary_function<col_entry_t, int, bool>
    {
        bool operator()(const col_entry_t& x, const int& y) const { return (x.first < y); }
    };

public:
    BEGIN_MMC_COM_MAP(CNodes)
    END_MMC_COM_MAP()

    // returning self as tied object
    // class implements enumerator methods itself, but it is used as a base

    // we need to tell all node we are going down
    virtual ~CNodes() { InvalidateConnectedNodes(); }
    // Nodes interface
public:
    // methods forwarded to the list control
    STDMETHODIMP get_Count( PLONG pCount );
    STDMETHODIMP Item( long Index, PPNODE ppNode );

public:
    // observed events
    virtual ::SC ScOnListViewIndexesReset();
    virtual ::SC ScOnListViewItemInserted(int iIndex);
    virtual ::SC ScOnListViewItemDeleted (int iIndex);


    // Nodes enumeration impl
    ::SC ScEnumReset (int &pos);
    ::SC ScEnumNext  (int &pos, PDISPATCH & pDispatch);
    ::SC ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, int &pos);

    // node object helpers
    ::SC ScGetDisplayName(int iItem, CComBSTR& bstrName);
    ::SC ScUnadviseNodeObj(CMMCResultNode *node); // called from ~CMMCResultNode()

    // asked by ListControl [forwarded by Node] to check if Node belongs to it.
    // false if unconnected, else tries to match the owner
    bool IsTiedToThisList(CCCListViewCtrl *pvc);

    // returns Node representing the item (may reuse/create/forward-to-scope-tree)
    ::SC ScGetNode (int iItem, PPNODE ppNode );
    ::SC ScGetListCtrl(CCCListViewCtrl **ppListCtrl); // returns the tied list control

private:  // implementation helpers
    ::SC ScAdvancePosition( int& pos, unsigned nItems ); // returns S_FALSE if adv. less than req.
    // initializators
    void SetSelectedItemsOnly(bool bSelOnly)        { m_bSelectedItemsOnly = bSelOnly; }

    // breaks connection between Nodes and any Node object
    void InvalidateConnectedNodes();

    // data members
    bool            m_bSelectedItemsOnly;
    col_t           m_Nodes;

    friend class CCCListViewCtrl;
};

// this typedefs the CNodesEnum class. Implements get__NewEnum using CMMCEnumerator and a _Positon object
typedef CMMCNewEnumImpl<CNodes, int, CNodes> CNodesEnum;

//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CMMCResultNode
 *
 *
 * PURPOSE: Implements the Node automation interface, for a result node
 *
 *+-------------------------------------------------------------------------*/
class CMMCResultNode :
    public CMMCIDispatchImpl<Node>
{
public:
    BEGIN_MMC_COM_MAP(CMMCResultNode)
    END_MMC_COM_MAP()

    // Node methods
public:
    STDMETHODIMP get_Name( PBSTR  pbstrName);
    STDMETHODIMP get_Property( BSTR PropertyName,  PBSTR  PropertyValue);
    STDMETHODIMP get_Bookmark( PBSTR pbstrBookmark);
    STDMETHODIMP IsScopeNode(PBOOL pbIsScopeNode);
    STDMETHODIMP get_Nodetype(PBSTR Nodetype);

    CMMCResultNode();
    ~CMMCResultNode();

    SC  ScGetListCtrl(CCCListViewCtrl **ppListCtrl);

    int GetIndex() { return m_iIndex; }
    // asked by ListControl to check if Node belongs to it. false if orphan,
    // forwarded to Nodes else
    bool IsTiedToThisList(CCCListViewCtrl *pvc) { return (m_pNodes != NULL && m_pNodes->IsTiedToThisList(pvc)); }
private: // implementation
    ::SC      ScGetAMCView(CAMCView **ppAMCView);
    void    Invalidate() { m_iIndex = -1; m_pNodes = NULL; }
    int     m_iIndex;
    CNodes  *m_pNodes;

    friend class CNodes;
};
//############################################################################
//############################################################################
//
//  CCCListViewCtrl methods managing Node & Nodes objects
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScFindResultItem
 *
 * PURPOSE: finds the index in ListView for item identified by Node [helper]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to examine
 *    int &iItem    - storage for resulting index
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScFindResultItem( PNODE pNode, int &iItem )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSelect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    iItem = -1;

    // what type of node do we have
    
    BOOL bScopeNode = FALSE;
    sc = pNode->IsScopeNode(&bScopeNode);
    if (sc)
        return sc;

    if (bScopeNode) // scope node
    {
        // we do not have scope items in virtual lists
        if (IsVirtual())
            return sc = ScFromMMC(MMC_E_RESULT_ITEM_NOT_FOUND);

        // find the result item (with the help of the owner class)

        // check for view
        sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
        if (sc)
            return sc;

        // get AMCView
        CAMCView* pAMCView = m_pListView->GetAMCView();
        sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
        if (sc)
            return sc;

        // forward the request
        HRESULTITEM itm;
        sc = pAMCView->ScFindResultItemForScopeNode( pNode, itm );
        if (sc)
            return sc;

        // get the index of item
        iItem = ResultItemToIndex(CResultItem::FromHandle(itm));

        if (iItem < 0)
            return sc = E_UNEXPECTED; // shouldn't be so
    }
    else // result node
    {
        // convert the pointer
        CMMCResultNode *pResNode = dynamic_cast<CMMCResultNode *>(pNode);
        sc = ScCheckPointers(pResNode); // invalid param. isn't it ?
        if (sc)
            return sc;

        // now check if it's actually comming from this list
        if (!pResNode->IsTiedToThisList(this))
            return sc = E_INVALIDARG;

        iItem = pResNode->GetIndex();
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScSelect
 *
 * PURPOSE: selects item identified by node [implements View.Select()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to select
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScSelect( PNODE pNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSelect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // find the result item
    int nIdxToSelect = -1;
    sc = ScFindResultItem( pNode, nIdxToSelect );
    if (sc)
        return sc;

    // perform the action on list control
    // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
    LV_ITEM lvi;
    lvi.stateMask = lvi.state = LVIS_SELECTED;
    if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(nIdxToSelect), (LPARAM)(LV_ITEM FAR *)&lvi))
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScDeselect
 *
 * PURPOSE: deselects item identified by node [implements View.Deselect()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to deselect
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScDeselect( PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScDeselect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // find the result item
    int nIdxToSelect = -1;
    sc = ScFindResultItem( pNode, nIdxToSelect );
    if (sc)
        return sc;

    // perform the action on list control
    // NOTE: do not use GetListCtrl().SetItemState - it uses SetItem which is not supported for virtual lists
    LV_ITEM lvi;
    lvi.stateMask = LVIS_SELECTED;
    lvi.state = 0;
    if (!GetListCtrl().SendMessage( LVM_SETITEMSTATE, WPARAM(nIdxToSelect), (LPARAM)(LV_ITEM FAR *)&lvi))
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScIsSelected
 *
 * PURPOSE: checks the status of item identified by node [implements View.IsSelected]
 *
 * PARAMETERS:
 *    PNODE pNode       - node to examine
 *    PBOOL pIsSelected - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScIsSelected( PNODE pNode,  PBOOL pIsSelected)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScIsSelected"));

    // parameter check
    sc = ScCheckPointers(pNode, pIsSelected);
    if (sc)
        return sc;

    *pIsSelected = FALSE;

    // find the result item
    int nIdxToSelect = -1;
    sc = ScFindResultItem( pNode, nIdxToSelect );
    if (sc)
        return sc;

    // perform the action on list control
    if ( 0 != (GetListCtrl().GetItemState( nIdxToSelect, LVIS_SELECTED ) & LVIS_SELECTED ))
        *pIsSelected = TRUE;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_ListItems
 *
 * PURPOSE:   returns Nodes enumeration including all list items
 *
 * PARAMETERS:
 *    PPNODES ppNodes - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_ListItems( PPNODES ppNodes )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_ListItems"));

    // get proper enumeration
    const bool bSelectedItemsOnly = false;
    sc = ScGetNodesEnum(bSelectedItemsOnly, ppNodes);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_SelectedItems
 *
 * PURPOSE:   returns Nodes enumeration including selected list items
 *
 * PARAMETERS:
 *    PPNODES ppNodes - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_SelectedItems( PPNODES ppNodes)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_SelectedItems"));

    // get proper enumeration
    const bool bSelectedItemsOnly = true;
    sc = ScGetNodesEnum(bSelectedItemsOnly, ppNodes);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScValidateItem
 *
 * PURPOSE: helper function inspecting the index validity and node type
 *
 * PARAMETERS:
 *    int  iItem        - item to inspect
 *    bool &bScopeNode  - result: is it a scope node
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScValidateItem( int  iItem, bool &bScopeNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScValidateItem"));

    // check the index
    if (iItem < 0 || iItem >= GetListCtrl().GetItemCount())
        return sc = E_INVALIDARG;


    bScopeNode = false; // its always false for virtual lists
    if (!IsVirtual())
    {
        // now try to guess what kind of result item we have
        CResultItem* pri = IndexToResultItem (iItem);
        sc = ScCheckPointers(pri, E_UNEXPECTED);
        if (sc)
            return sc;

        bScopeNode = pri->IsScopeItem();
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScGetNodesEnum
 *
 * PURPOSE: returns [creates if needed] com object Nodes
 *
 * PARAMETERS:
 *    EnumType enumType - type of enumeration requested [all items/selected items]
 *    PPNODES ppNodes   - storage for the result (addref'ed for the caller)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScGetNodesEnum(bool bSelectedItemsOnly, PPNODES ppNodes)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetNodesEnum"));

    // parameter check
    sc = ScCheckPointers ( ppNodes );
    if (sc)
        return sc;

    // result initialization
    *ppNodes = NULL;

    // get a reference to proper variable
    NodesPtr& rspNodes = bSelectedItemsOnly ? m_spSelNodes : m_spAllNodes;

    if (rspNodes == NULL) // don't we have it ready?
    {
        // create a CNodesEnum object
        sc = CTiedComObjectCreator<CNodesEnum>::ScCreateAndConnect(*this, rspNodes);
        if (sc)
            return (sc);

        // get the actual object
        typedef CComObject<CNodesEnum> CNodesEnumObj;
        CNodesEnumObj *pNodesEnum = dynamic_cast<CNodesEnumObj*>(rspNodes.GetInterfacePtr());

        // check the pointer
        sc = ScCheckPointers( pNodesEnum, E_UNEXPECTED );
        if(sc)
            return sc;

        // update internal data
        pNodesEnum->SetSelectedItemsOnly(bSelectedItemsOnly);
        // add new object as an observer to the view
        AddObserver(static_cast<CListViewObserver&>(*pNodesEnum));
    }

    // addref and return the pointer for the client.
    *ppNodes = rspNodes;
    (*ppNodes)->AddRef();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScGetScopeNodeForItem
 *
 * PURPOSE: transit point for Scope Node request - comes from enumeration, forwarded
 *          to AMCView and further to ScopeTree
 *
 * PARAMETERS:
 *    int  iItem        - node index to retrieve
 *    PPNODE ppNode     - result storage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScGetScopeNodeForItem( int iItem,  PPNODE ppNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetScopeNodeForItem"));

    // check the parameters
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;

    // initialize the result
    *ppNode = NULL;

    // now try to guess what kind of result item we have
    CResultItem* pri = IndexToResultItem(iItem);
    sc = ScCheckPointers(pri, E_UNEXPECTED);
    if (sc)
        return sc;

    // get the hNode
    HNODE hNode = pri->GetScopeNode();

    // check for view
    sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
    if (sc)
        return sc;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward the request
    sc = pAMCView->ScGetScopeNode( hNode, ppNode );
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CCCListViewCtrl::ScGetAMCView
 *
 * PURPOSE: Returns a pointer to the parent CAMCView
 *
 * PARAMETERS:
 *    CAMCView ** ppAMCView :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CCCListViewCtrl::ScGetAMCView(CAMCView **ppAMCView)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetAMCView"));

    sc = ScCheckPointers(ppAMCView);
    if(sc)
        return sc;

    *ppAMCView = NULL;

    // check for view
    sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
    if (sc)
        return sc;

    // get AMCView
    *ppAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers(*ppAMCView, E_UNEXPECTED);

    return sc;
}

//############################################################################
//############################################################################
//
//  Implementation of class CNodes
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CNodes::ScEnumReset
 *
 * PURPOSE: resets position for Nodes enumeration
 *
 * PARAMETERS:
 *    int &pos  - position to reset
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScEnumReset(int &pos)
{
    DECLARE_SC(sc, TEXT("CNodes::ScEnumReset"));

    pos = -1;
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNodes::ScGetListCtrl
 *
 * PURPOSE: Returns a pointer to the list control
 *
 * GUARANTEE: if the function succeeds, the list control pointer is valid.
 *
 * PARAMETERS:
 *    CCCListViewCtrl ** ppListCtrl :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNodes::ScGetListCtrl(CCCListViewCtrl **ppListCtrl)
{
    DECLARE_SC(sc, TEXT("CNodes::ScGetListCtrl"));

    sc = ScCheckPointers(ppListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    *ppListCtrl = NULL;
    sc = ScGetTiedObject(*ppListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(*ppListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CNodes::ScAdvancePosition
 *
 * PURPOSE: advances position (index) of item depending on collection type
 *
 * PARAMETERS:
 *    int& pos   - position to update
 *    int nItems - count of items to skip
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScAdvancePosition( int& pos, unsigned nItems )
{
    DECLARE_SC(sc, TEXT("CNodes::ScAdvancePosition"));

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // inspect if we aren't behind the end
    int nCount = pListCtrl->GetListCtrl().GetItemCount();
    if (pos >= nCount)
        return sc = E_FAIL; // we did not got a valid position

    // advance depending on collection type
    if (m_bSelectedItemsOnly)
    {
        // we only can do it by iterating
        for (int i = 0; i < nItems; i++)
        {
            int iItem = pListCtrl->GetListCtrl().GetNextItem( pos, LVNI_SELECTED );
            if (iItem < 0)
                return sc = S_FALSE; // we didn't advance as much as requested
            pos = iItem;
        }
    }
    else // all_items selection
    {
        pos += nItems;
        if (pos >= nCount)
        {
            pos = nCount - 1;
            return sc = S_FALSE; // we didn't advance as much as requested
        }
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScEnumNext
 *
 * PURPOSE: Retrieves next item from enumeration [ Implements Nodes.Next ]
 *
 * PARAMETERS:
 *    int &pos                  - position to start from
 *    IDispatch * &pDispatch    - resulting item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScEnumNext(int &pos, IDispatch * &pDispatch)
{
    DECLARE_SC(sc, TEXT("CNodes::ScEnumNext"));

    // get the index of next item
    sc = ScAdvancePosition( pos, 1 /*nItems*/ );
    if (sc.IsError() || sc == SC(S_FALSE))
        return sc;

    // get the result node for the index
    PNODE pNode = NULL;
    sc = ScGetNode( pos, &pNode );
    if (sc)
        return sc;

    // assign to result
    pDispatch = pNode;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScEnumSkip
 *
 * PURPOSE: skips items in enumeration [implements Nodes.Skip method]
 *
 * PARAMETERS:
 *    unsigned long celt            - positions to skip
 *    unsigned long &celtSkipped    - result: positions skiped
 *    int &pos                      - position to update
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScEnumSkip(unsigned long celt,unsigned long &celtSkipped, int &pos)
{
    DECLARE_SC(sc, TEXT("CNodes::ScEnumSkip"));

    // init val.
    celtSkipped = 0;

    // save the position for evaluation
    int org_pos = pos;

    // advance the position
    sc = ScAdvancePosition( pos, celt );
    if (sc)
        return sc;

    // calculate items skipped
    celtSkipped = pos - org_pos;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CNodes::get_Count
 *
 * PURPOSE: returns count of object in enumeration [Implements Nodes.Count]
 *
 * PARAMETERS:
 *    PLONG pCount  - storage for result
 *
 * RETURNS:
 *    HRESULT  - result code
 *
\***************************************************************************/
STDMETHODIMP CNodes::get_Count( PLONG pCount )
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CNodes::get_Count"));

    // parameter check
    sc = ScCheckPointers ( pCount );
    if (sc)
        return sc.ToHr();

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    // get count from the control
    if (m_bSelectedItemsOnly)
        *pCount = pListCtrl->GetListCtrl().GetSelectedCount();
    else
        *pCount = pListCtrl->GetListCtrl().GetItemCount();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodes::Item
 *
 * PURPOSE: - returns Item from enumeration [Implements Nodes.Item]
 *
 * PARAMETERS:
 *    long Index    - Index of item to retrieve
 *    PPNODE ppNode - storage for resulting node ptr
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
STDMETHODIMP CNodes::Item( long Index, PPNODE ppNode )
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CNodes::Item"));

    // parameter check
    sc = ScCheckPointers ( ppNode );
    if (sc)
        return sc.ToHr();

    *ppNode = NULL;

    // check the index
    if (Index <= 0)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    int iPos = -1; // just before the first item at start
    // get to the right item
    sc = ScAdvancePosition(iPos, Index);
    if (sc == SC(S_FALSE))    // didn't get far enough?
        sc = E_INVALIDARG;   // means we've got the wrong Index
    if (sc) // got an error?
        return sc.ToHr();

    // now get the node
    sc = ScGetNode( iPos, ppNode );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScGetNode
 *
 * PURPOSE: Retrieves cached or creates new Node object
 *
 * PARAMETERS:
 *    int iIndex        - index of result item
 *    PPNODE ppNode     - storage for resulting node
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScGetNode(int iItem, PPNODE ppNode)
{
    DECLARE_SC(sc, TEXT("CNodes::ScGetNode"));

    // parameter check
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;

    // initial return value
    *ppNode = NULL;

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // inspect what kind of item we have
    bool bScopeNode = false; 
    sc = pListCtrl->ScValidateItem( iItem, bScopeNode );
    if (sc)
        return sc;

    if (bScopeNode)
    {
        // do not handle this - pass to the owner
        sc = pListCtrl->ScGetScopeNodeForItem ( iItem, ppNode );
        if (sc)
            return sc;

        return sc;
    }

    // "normal" list item (not a scope node) - we can handle ourselves

    // find either the entry or the place to insert
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iItem, index_less());

    if (it!= m_Nodes.end() && it->first == iItem)
    {
        // we already have it!!! , recheck!
        sc = ScCheckPointers(it->second, E_UNEXPECTED);
        if (sc)
            return sc;

        // return it!
        *ppNode = it->second;
        (*ppNode)->AddRef();
        return sc;
    }

    // doesn't exist - need to create one

    typedef CComObject<CMMCResultNode> CResultNode;
    CResultNode *pResultNode = NULL;
    CResultNode::CreateInstance(&pResultNode);

    sc = ScCheckPointers(pResultNode, E_OUTOFMEMORY);
    if(sc)
        return sc;

    // update the information on the node
    pResultNode->m_iIndex = iItem;
    pResultNode->m_pNodes = this;

    m_Nodes.insert(it, col_entry_t(iItem, pResultNode));
    // return it!
    *ppNode = pResultNode;
    (*ppNode)->AddRef();

    return sc;
}
/***************************************************************************\
 *
 * METHOD:  CNodes::ScGetDisplayName
 *
 * PURPOSE:     retrievs the display name of the Node
 *
 * PARAMETERS:
 *    int iIndex            - index of the result item
 *    CComBSTR& bstrName    - storage for resulting text
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScGetDisplayName(int iItem, CComBSTR& bstrName)
{
    DECLARE_SC(sc, TEXT("CNodes::ScGetDisplayName"));

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // check the index
    if (iItem < 0 || iItem >= pListCtrl->GetListCtrl().GetItemCount())
        return sc = E_INVALIDARG;

    // get the text
    bstrName = pListCtrl->GetListCtrl().GetItemText( iItem, 0 /*column*/);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScUnadviseNodeObj
 *
 * PURPOSE: Remove Node from collection. called from ~CMMCResultNode()
 *
 * PARAMETERS:
 *    CMMCResultNode *node - node to remove
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScUnadviseNodeObj(CMMCResultNode *node)
{
    DECLARE_SC(sc, TEXT("CNodes::ScUnadviseNodeObj"));

    // parameter check
    sc = ScCheckPointers(node);
    if (sc)
        return sc;

    // index of the node
    int iIndex = node->m_iIndex;

    // find the entry by index
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iIndex, index_less());

    if (it== m_Nodes.end() || it->first != iIndex)
    {
        // we do not have it ???
        sc = E_UNEXPECTED;
        return sc;
    }

    // remove from collection
    m_Nodes.erase(it);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScOnListViewIndexesReset
 *
 * PURPOSE: Fired Event handler. Wipes the cached info
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScOnListViewIndexesReset()
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnListViewIndexesReset"));

    InvalidateConnectedNodes();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::InvalidateConnectedNodes
 *
 * PURPOSE: wipes out the cache. invalidates alive nodes
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CNodes::InvalidateConnectedNodes()
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnListViewIndexesReset"));

    // orphan all alive nodes - we do not keep pointers
    col_t::iterator it;
    for (it = m_Nodes.begin(); it != m_Nodes.end(); ++it)
    {
        // get the pointer to com object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_POINTER);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }
        // reset the container info
        pNode->Invalidate();
    }

    // clear the collection;
    m_Nodes.clear();
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScOnListViewItemInserted
 *
 * PURPOSE: Fired Event handler. shifts index info
 *
 * PARAMETERS:
 *    int iIndex - index of newly inserted item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScOnListViewItemInserted(int iIndex)
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnListViewItemInserted"));

    // find the insertion point
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iIndex, index_less());

    // increment all the entries following it
    while (it != m_Nodes.end())
    {
        // increment index in own collection
        ++(it->first);
        // get the pointer to com object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc;
        // increment member on com object
        ++(pNode->m_iIndex);
        // get to the next item
        ++it;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::ScOnListViewItemDeleted
 *
 * PURPOSE: Fired Event handler. shifts index info
 *
 * PARAMETERS:
 *    int iIndex - index of removed item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodes::ScOnListViewItemDeleted (int iIndex)
{
    DECLARE_SC(sc, TEXT("CNodes::ScOnlistViewItemDeleted"));

    // find the insertion point
    col_t::iterator it = std::lower_bound(m_Nodes.begin(), m_Nodes.end(), iIndex, index_less());

    // if we have an object at the position, get rid of it!
    if (it != m_Nodes.end() && it->first == iIndex)
    {
        // get pointer to the object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc;
        // reset the container info
        pNode->Invalidate();
        it = m_Nodes.erase(it);
    }

    // decrement all the entries following it
    while (it != m_Nodes.end())
    {
        // decrement index in own collection
        --(it->first);
        // get the pointer to com object
        CMMCResultNode * const pNode = it->second;
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc;
        // decrement member on com object
        --(pNode->m_iIndex);
        // get to the next item
        ++it;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNodes::IsTiedToThisList
 *
 * PURPOSE: this method is called from node which needs to know if it
 *          belongs to the the this list (as a result item on it)
 *
 * PARAMETERS:
 *    CCCListViewCtrl *pvc
 *
 * RETURNS:
 *    false if unconnected or belongs to other list
 *
\***************************************************************************/
bool CNodes::IsTiedToThisList(CCCListViewCtrl *pvc)
{
    DECLARE_SC(sc, TEXT("CNodes::IsTiedToThisList"));

    // get the tied object
    CCCListViewCtrl *pListCtrl = NULL;
    sc = ScGetTiedObject(pListCtrl);
    if(sc)
        return false;

    // recheck the pointer
    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return false;

    return (pListCtrl == pvc);
}

//############################################################################
//############################################################################
//
//  Implementation of class CMMCResultNode
//
//############################################################################
//############################################################################

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::CMMCResultNode
 *
 * PURPOSE: default constructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCResultNode::CMMCResultNode() : m_pNodes(NULL), m_iIndex(-1)
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::CMMCResultNode"));
    Invalidate();
}

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::~CMMCResultNode
 *
 * PURPOSE: Destructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCResultNode::~CMMCResultNode()
{
    DECLARE_SC(sc, TEXT("CMMCResultNode::~CMMCResultNode"));

    // informing container about desruction
    if (m_pNodes)
    {
        sc = m_pNodes->ScUnadviseNodeObj(this);
        if (sc)
            sc.TraceAndClear();
    }
}

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::get_Name
 *
 * PURPOSE: Returns the display name of the node.
 *
 * PARAMETERS:
 *    PBSTR  pbstrName - result (name)
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCResultNode::get_Name( PBSTR  pbstrName)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Name"));

    // check the parameters
    sc = ScCheckPointers( pbstrName );
    if (sc)
        return sc.ToHr();

    // initialize output
    *pbstrName = NULL;

    // check the container
    sc = ScCheckPointers( m_pNodes, E_FAIL );
    if (sc)
        return sc.ToHr();

    // ask owner about the name
    CComBSTR bstrResult;
    sc = m_pNodes->ScGetDisplayName(m_iIndex, bstrResult);
    if (sc)
        return sc.ToHr();

    // return the result result
    *pbstrName = bstrResult.Detach();

    // recheck pointer before return
    sc = ScCheckPointers( *pbstrName, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CMMCResultNode::ScGetAMCView
 *
 * PURPOSE: Returns a pointer to the view.
 *
 * PARAMETERS:
 *    CAMCView ** ppAMCView :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMMCResultNode::ScGetAMCView(CAMCView **ppAMCView)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCResultNode::ScGetAMCView"));

    // check parameters
    sc = ScCheckPointers(ppAMCView);
    if(sc)
        return sc;

    // init out parameter
    *ppAMCView = NULL;

   // check the container
    sc = ScCheckPointers( m_pNodes, E_FAIL );
    if (sc)
        return sc;

    CCCListViewCtrl *pListCtrl = NULL;

    sc = m_pNodes->ScGetListCtrl(& pListCtrl);
    if(sc)
        return sc;

    sc = ScCheckPointers(pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = pListCtrl->ScGetAMCView(ppAMCView);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCResultNode::get_Property
 *
 * PURPOSE: Returns the specified clipboard format data (must be a text
 *          format) for the node.
 *
 * PARAMETERS:
 *    BSTR   PropertyName :
 *    PBSTR  PropertyValue :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCResultNode::get_Property( BSTR PropertyName,  PBSTR  PropertyValue)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Property"));

    CAMCView *pAMCView = NULL;

    sc = ScGetAMCView(&pAMCView);
    if(sc)
        return sc.ToHr();


    sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();


    sc = pAMCView->ScGetProperty(m_iIndex, PropertyName, PropertyValue);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CMMCResultNode::get_Nodetype
 *
 * PURPOSE: Returns the GUID nodetype identifier for the node.
 *
 * PARAMETERS:
 *    PBSTR  Nodetype : [out] the nodetype identifier.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCResultNode::get_Nodetype(PBSTR Nodetype)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Nodetype"));

    CAMCView *pAMCView = NULL;

    sc = ScGetAMCView(&pAMCView);
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pAMCView->ScGetNodetype(m_iIndex, Nodetype);

    return sc.ToHr();
}



/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::get_Bookmark
 *
 * PURPOSE: Returns error always - not valid for result items
 *
 * PARAMETERS:
 *    PBSTR pbstrBookmark
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCResultNode::get_Bookmark( PBSTR pbstrBookmark )
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCResultNode::get_Bookmark"));

    // check the parameters
    sc = ScCheckPointers( pbstrBookmark );
    if (sc)
        return sc.ToHr();

    // initialize output
    *pbstrBookmark = NULL;

    // report the error - always
    sc = ScFromMMC( MMC_E_NO_BOOKMARK );
    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCResultNode::IsScopeNode
 *
 * PURPOSE: returns TRUE if it's a scope node ( i.e. always returns FALSE)
 *
 * PARAMETERS:
 *    PBOOL pbIsScopeNode
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCResultNode::IsScopeNode(PBOOL pbIsScopeNode)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCResultNode::IsScopeNode"));

    sc = ScCheckPointers( pbIsScopeNode );
    if(sc)
        return sc.ToHr();

    // if it's here it's for sure not a scope node
   *pbIsScopeNode = FALSE;

   return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::ScAllocResultItem
 *
 * Allocates a CResultItem for a list control item.
 *--------------------------------------------------------------------------*/

SC CCCListViewCtrl::ScAllocResultItem (
    CResultItem*& pri,                  /* O:new list item                  */
    COMPONENTID id,                     /* I:owning component ID            */
    LPARAM      lSnapinData,            /* I:snap-in's data for this item   */
    int         nImage)                 /* I:image index                    */
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::ScAllocResultItem"));

    pri = new CResultItem (id, lSnapinData, nImage);

    sc = ScCheckPointers (pri, E_OUTOFMEMORY);
    if (sc)
        return (sc);

    return (sc);
}



/*+-------------------------------------------------------------------------*
 * CCCListViewCtrl::ScFreeResultItem
 *
 * Frees a CResultItem that was allocated with ScAllocResultItem.
 *--------------------------------------------------------------------------*/

SC CCCListViewCtrl::ScFreeResultItem (
    CResultItem*  priFree)                /* I:list item to free              */
{
    DECLARE_SC (sc, _T("CCCListViewCtrl::ScFreeResultItem"));

    sc = ScCheckPointers (priFree, E_UNEXPECTED);
    if (sc)
        return (sc);

    delete priFree;

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Columns
 *
 * PURPOSE: returns pointer to Columns object; create one if required
 *
 * PARAMETERS:
 *    PPCOLUMNS ppColumns   - resulting pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_Columns(PPCOLUMNS ppColumns)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Columns"));

    // Check received parameters
    sc = ScCheckPointers(ppColumns);
    if (sc)
        return sc;

    // initialize
    *ppColumns = NULL;

    // create the object when required
    sc = CTiedComObjectCreator<CColumns>::ScCreateAndConnect(*this, m_spColumns);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(m_spColumns, E_UNEXPECTED);
    if (sc)
        return sc;

    // return the pointer
    *ppColumns = m_spColumns;
    (*ppColumns)->AddRef();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Count
 *
 * PURPOSE: returns the count of columns in LV
 *
 * PARAMETERS:
 *    PLONG pCount
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_Count( PLONG pCount )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Count"));

    // Check received parameters
    sc = ScCheckPointers(pCount);
    if (sc)
        return sc;

    // return the result
    *pCount = GetColCount();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScEnumNext
 *
 * PURPOSE:     advances position pointer for Columns enum. returns the object at the pos
 *
 * PARAMETERS:
 *    int &iZeroBasedPos    - position to modify
 *    PDISPATCH & pDispatch - resulting pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScEnumNext(int &iZeroBasedPos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScEnumNext"));

    // initialize
    pDispatch = NULL;

    // advance;
    iZeroBasedPos++;

    // recheck the pos
    if (iZeroBasedPos < 0)
        return sc = E_UNEXPECTED;

    // no more columns?
    if (iZeroBasedPos >= GetColCount())
        return sc = S_FALSE;

    // retrieve the column
    ColumnPtr spColumn;
    // ScItem accepts 1-based index
    sc = ScItem( iZeroBasedPos + 1, &spColumn );
    if (sc)
        return sc;

    //return the interface.
    pDispatch = spColumn.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScEnumSkip
 *
 * PURPOSE: skips several items for Columns enum
 *
 * PARAMETERS:
 *    unsigned long celt
 *    unsigned long& celtSkipped
 *    int &iZeroBasedPos
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, int &iZeroBasedPos)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScEnumSkip"));

    // init [out] param
    celtSkipped = 0;

    // recheck the pos
    if (iZeroBasedPos < -1)
        return sc = E_UNEXPECTED;

    // already past the end?
    if (iZeroBasedPos >= GetColCount())
        return sc = S_FALSE;

    // how far can we advance ?;
    celtSkipped = GetColCount() - iZeroBasedPos;
    if (celtSkipped > celt)
        celtSkipped = celt;

    // advance
    iZeroBasedPos += celtSkipped;

    return sc = ((celtSkipped == celt) ? S_OK : S_FALSE);
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScEnumReset
 *
 * PURPOSE:     resets position index for Columns enum
 *
 * PARAMETERS:
 *    int &iZeroBasedPos  position to modify
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScEnumReset(int &iZeroBasedPos)
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScEnumReset"));

    iZeroBasedPos = -1;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScItem
 *
 * PURPOSE:     returns Column com object from Columns collection
 *
 * PARAMETERS:
 *    long lOneBasedIndex - [in] - column index (1 based)
 *    PPCOLUMN ppColumn   - [out] - resulting object
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScItem( long lOneBasedIndex, PPCOLUMN ppColumn )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScItem"));

    // Check received parameters
    sc = ScCheckPointers(ppColumn);
    if (sc)
        return sc;

    // initialize output
    *ppColumn = NULL;

    // check the index
    int iZeroBasedIndex = lOneBasedIndex - 1;
    if (iZeroBasedIndex < 0 || iZeroBasedIndex >= GetColCount())
        return sc = ::ScFromMMC(MMC_E_INVALID_COLUMN_INDEX);

    // construct the object
    typedef CComObject<CColumn> CComColumn;
    ColumnPtr /*CComPtr<CComColumn>*/ spColumn;

    // create the object when required
    sc = CTiedComObjectCreator<CColumn>::ScCreateAndConnect(*this, spColumn);
    if (sc)
        return sc;

    // get 'raw' pointer
    CComColumn *pColumn = dynamic_cast<CComColumn *>(spColumn.GetInterfacePtr());

    // recheck the pointer
    sc = ScCheckPointers(pColumn, E_UNEXPECTED);
    if (sc)
        return sc;

    // initialize the object
    pColumn->SetIndex(iZeroBasedIndex);

    // let it observe what's going on and manage its own index
    AddObserver(static_cast<CListViewObserver&>(*pColumn));

    // return the pointer
    *ppColumn = spColumn;
    (*ppColumn)->AddRef();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScName
 *
 * PURPOSE:         Returns column name. Implements Column.Name property
 *
 * PARAMETERS:
 *    BSTR *Name                - the returned name
 *    int iZeroBasedColIndex    - index of column of interest
 *
 * RETURNS:
 *    SC    - result code
 *
 \***************************************************************************/
SC CCCListViewCtrl::ScName( /*[out, retval]*/ BSTR *Name, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScName"));

    // Check received parameters
    sc = ScCheckPointers(Name);
    if (sc)
        return sc;

    // initialize output
    *Name = NULL;

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    LPOLESTR pstrName = NULL;
    sc = GetColumn(iZeroBasedColIndex, &pstrName, MMCLV_NOPTR, MMCLV_NOPTR);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pstrName, E_UNEXPECTED);
    if (sc)
        return sc;

    *Name = ::SysAllocString(pstrName);
    ::CoTaskMemFree(pstrName);

    // recheck the result
    sc = ScCheckPointers(*Name, E_OUTOFMEMORY);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScGetColumnData
 *
 * PURPOSE:     helper for Column com object implementation
 *              - checks column index
 *              - retrieves information about the column
 *
 * PARAMETERS:
 *    int iZeroBasedColIndex        - column index
 *    ColumnData *pColData          - storage for resulting data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScGetColumnData( int iZeroBasedColIndex, ColumnData *pColData )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetColumnData"));

    // Check received parameters (its internal function, so it's unexpected if the params are bad)
    sc = ScCheckPointers(pColData, E_UNEXPECTED);
    if (sc)
        return sc;

    // init the structure;
    pColData->Init();

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    // need to get the header control for managing columns
    CAMCHeaderCtrl* pHeader = GetHeaderCtrl();

    // check!
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    // get the lParam
    HDITEM hdItem;
    ::ZeroMemory(&hdItem, sizeof(hdItem));
    hdItem.mask    = HDI_LPARAM | HDI_WIDTH | HDI_ORDER;
    BOOL bRet = pHeader->GetItem(iZeroBasedColIndex, &hdItem);
    if (!bRet)
        return sc = E_FAIL;

	CHiddenColumnInfo hci (hdItem.lParam);

    pColData->iColumnOrder =    hdItem.iOrder;
    pColData->bIsHidden =       hci.fHidden;
    pColData->iColumnWidth =    hdItem.cxy;
    if (pColData->bIsHidden)    // special case for hidden columns
        pColData->iColumnWidth = hci.cx;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScSetColumnData
 *
 * PURPOSE:     helper for Column com object implementation
 *              - modifies column
 *              NOTE - not to be used for SHOW/HIDE operations
 *
 * PARAMETERS:
 *    int iZeroBasedColIndex        - column index
 *    const ColumnData& rColData    - modified column data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScSetColumnData( int iZeroBasedColIndex, const ColumnData& rColData )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSetColumnData"));

    ColumnData oldColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &oldColData );
    if (sc)
        return sc;

    // check if anything  has changed
    if (oldColData == rColData)
        return sc;

    // the visibility of column cannot be changed directly
    // the snapin has be notified about that.
    // the request should never come here
    if (rColData.bIsHidden != oldColData.bIsHidden)
        return sc = E_UNEXPECTED;

    // need to get the header control for managing columns
    CAMCHeaderCtrl* pHeader = GetHeaderCtrl();

    // check!
    sc = ScCheckPointers(pHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    // now set the new data
    HDITEM hdItem;
    ::ZeroMemory(&hdItem, sizeof(hdItem));

    // set the width properly (no mater if colum is hidden)
    if (rColData.bIsHidden)
    {
		CHiddenColumnInfo hci (rColData.iColumnWidth, true);

        hdItem.lParam = hci.lParam;
        hdItem.mask   = HDI_LPARAM;
    }
    else
    {
        hdItem.mask = HDI_WIDTH;
        hdItem.cxy = rColData.iColumnWidth;
    }

    // set the order info
    hdItem.mask   |= HDI_ORDER;
    hdItem.iOrder = rColData.iColumnOrder;

    // set the column data
    BOOL bRet = pHeader->SetItem(iZeroBasedColIndex, &hdItem);
    if (!bRet)
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Width
 *
 * PURPOSE:     Returns width of column. Implements get for Column.Width
 *
 * PARAMETERS:
 *    PLONG Width               - resulting width
 *    int iZeroBasedColIndex    - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
 \***************************************************************************/
SC CCCListViewCtrl::Scget_Width( /*[out, retval]*/ PLONG Width, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Width"));

    // Check received parameters
    sc = ScCheckPointers(Width);
    if (sc)
        return sc;

    // initialize output
    *Width = 0;

    // retrieve data for column (this also checks the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    *Width = strColData.iColumnWidth;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scput_Width
 *
 * PURPOSE:     Sets width of column. Implements put for Column.Width
 *
 * PARAMETERS:
 *    LONG Width                - new width
 *    int iZeroBasedColIndex    - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
 \***************************************************************************/
SC CCCListViewCtrl::Scput_Width( /*[in]*/ long Width, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scput_Width"));

    ColumnData strColData;
    // retrieve current column data
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // change the width
    strColData.iColumnWidth = Width;

    // set modified column data
    sc = ScSetColumnData( iZeroBasedColIndex, strColData );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_DisplayPosition
 *
 * PURPOSE:  Returns display position of column. Imnplements get for Column.DisplayPosition
 *
 * PARAMETERS:
 *    PLONG DisplayPosition          - display position ( 1 based )
 *    int iZeroBasedColIndex         - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_DisplayPosition( /*[out, retval]*/ PLONG DisplayPosition, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_DisplayPosition"));

    // Check received parameters
    sc = ScCheckPointers(DisplayPosition);
    if (sc)
        return sc;

    // initialize
    *DisplayPosition = 0;

    // retrieve data for column (this also checks the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // it's not legal for hidden columns ( or unfair at least :-)
    if (strColData.bIsHidden)
        return sc = E_UNEXPECTED;

    int iColumnOrder = strColData.iColumnOrder;
    int iDisplayPosition = iColumnOrder + 1;

    // that would be it. BUT we may have hidden columns with smaller order numbers
    // we need ti iteratre to find it out

    int nColumnCount = GetColCount();
    for (int i = 0; i <nColumnCount; i++)
    {
        // retrieve data for column (this also checks the index)
        sc = ScGetColumnData( i, &strColData );
        if (sc)
            return sc;

        // we will not take into account any hidden column
        if (strColData.iColumnOrder < iColumnOrder && strColData.bIsHidden)
        {
            // decrement position, since hidden columns do not affect visual position
            iDisplayPosition --;
        }
    }

    // return the display position
    *DisplayPosition = iDisplayPosition;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scput_DisplayPosition
 *
 * PURPOSE: Moves column (visually) to specified position
 *          Implements put for Column.DisplayPosition
 *
 * PARAMETERS:
 *   long lVisualPosition    - Position to move to (1 based)
 *   int iZeroBasedColIndex  - column index to move
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scput_DisplayPosition( /*[in]*/ long lVisualPosition, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scput_DisplayPosition"));

    // check the params
    if (lVisualPosition < 1)
        return sc = E_INVALIDARG;

    // retrieve current column data (this will check the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // we need to iterate and see what index and iOrder represents the requested position

    int nColumnCount = GetColCount();

    // will create a map from iOrder to visual status to make life easier
    // and benefit from the fact that items get sorted when inserting
    std::map<int,bool> mapColumnsByDisplayPos;
    for (int i = 0; i <nColumnCount; i++)
    {
        ColumnData strCurrColData;
        sc = ScGetColumnData( i, &strCurrColData );
        if (sc)
            return sc;

        // insert to the map
        mapColumnsByDisplayPos[strCurrColData.iColumnOrder] = strCurrColData.bIsHidden;
    }

    // now find out the right iOrder for the new position
    std::map<int,bool>::iterator it;
    int iNewOrder = 1;
    int nCurrPos = 0;
    for (it = mapColumnsByDisplayPos.begin(); it != mapColumnsByDisplayPos.end(); ++it)
    {
        iNewOrder = it->first;
        bool bHidden = it->second;

        // olny visible items are counted when it comes to display position
        if (!bHidden)
            ++nCurrPos;

        if (nCurrPos == lVisualPosition)
            break; // we've found the good place to move in
    }
    // note - if position is not found - iNewOrder will mark the last column.
    // good - that's a reasonable place for insertion to default to.
    // that means column will go to the end if given index was bigger than count
    // of visible columns

    strColData.iColumnOrder = iNewOrder;
    sc = ScSetColumnData( iZeroBasedColIndex, strColData );
    if (sc)
        return sc;

    // Now redraw the list view
    InvalidateRect(GetListCtrl(), NULL, TRUE);

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scget_Hidden
 *
 * PURPOSE:  Returns hidden status for collumn. Implements get for Column.Hidden
 *
 * PARAMETERS:
 *    PBOOL Hidden           - resulting status
 *    int iZeroBasedColIndex - index of the column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scget_Hidden( /*[out, retval]*/ PBOOL pHidden, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scget_Hidden"));

    // check parameters
    sc = ScCheckPointers(pHidden);
    if (sc)
        return sc;

    // initialize
    *pHidden = FALSE;

    // retrieve current column data (this will check the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // return the hidden status
    *pHidden = strColData.bIsHidden;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::Scput_Hidden
 *
 * PURPOSE: Hides or shows the column. Implements put for Column.Hidden
 *
 * PARAMETERS:
 *    BOOL Hidden            - new status for column
 *    int iZeroBasedColIndex - index of column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::Scput_Hidden( /*[in]*/ BOOL Hidden , int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::Scput_Hidden"));

    // retrieve current column data (this will check the index)
    ColumnData strColData;
    sc = ScGetColumnData( iZeroBasedColIndex, &strColData );
    if (sc)
        return sc;

    // check if we do have a change in status
    if (strColData.bIsHidden == (bool)Hidden)
        return sc;

    // will never hide the 0 column!!!
    if (Hidden && iZeroBasedColIndex == 0)
        return sc = ::ScFromMMC(MMC_E_ZERO_COLUMN_INVISIBLE);

    // check for view
    sc = ScCheckPointers( m_pListView, E_UNEXPECTED);
    if (sc)
        return sc;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get component node that owns the result view
    HNODE hnodeOwner = pAMCView->GetSelectedNode();
    sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
    if (sc)
        return sc.ToHr();

    LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // forward the request to CEnumeratedNode - owner of the view
    sc = pNodeCallback->ShowColumn(hnodeOwner, iZeroBasedColIndex, !Hidden);
    if (sc)
        return sc.ToHr();

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScSetAsSortColumn
 *
 * PURPOSE:  Sorts LV by specified column. Implements Column.SetAsSortColumn
 *
 * PARAMETERS:
 *    ColumnSortOrder SortOrder - sort order requested
 *    int iZeroBasedColIndex    - index of sort column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScSetAsSortColumn( /*[in]*/ ColumnSortOrder SortOrder, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScSetAsSortColumn"));

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get component node that owns the result view
    HNODE hnodeOwner = pAMCView->GetSelectedNode();
    sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
    if (sc)
        return sc.ToHr();


    LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // forward the request to CEnumeratedNode - owner of the view
    sc = pNodeCallback->SetSortColumn(hnodeOwner, iZeroBasedColIndex, SortOrder == SortOrder_Ascending);
    if (sc)
        return sc.ToHr();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CCCListViewCtrl::ScIsSortColumn
 *
 * PURPOSE: Checks if the column is the one LV is sorted by
 *          Implements Column.IsSortColumn
 *
 * PARAMETERS:
 *    PBOOL IsSortColumn        - result (TRUE/FALSE)
 *    int iZeroBasedColIndex    - column index
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CCCListViewCtrl::ScIsSortColumn( PBOOL IsSortColumn, int iZeroBasedColIndex )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScIsSortColumn"));

    // check the param
    sc = ScCheckPointers(IsSortColumn);
    if (sc)
        return sc;

    // initialize
    *IsSortColumn = FALSE;

    // recheck the column index
    // (it's not something the script sent - it's internal data)
    if (iZeroBasedColIndex < 0 || iZeroBasedColIndex >= GetColCount())
        return sc = E_UNEXPECTED;

    // get AMCView
    CAMCView* pAMCView = m_pListView->GetAMCView();
    sc = ScCheckPointers( pAMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get component node that owns the result view
    HNODE hnodeOwner = pAMCView->GetSelectedNode();
    sc = ScCheckPointers((LPVOID)hnodeOwner, E_FAIL);
    if (sc)
        return sc.ToHr();


    LPNODECALLBACK pNodeCallback = pAMCView->GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // forward the request to CEnumeratedNode - owner of the view
    int iSortCol = -1;
    sc = pNodeCallback->GetSortColumn(hnodeOwner, &iSortCol);
    if (sc)
        return sc.ToHr();

    // see if this column is the one LV is sorted by
    *IsSortColumn = (iSortCol == iZeroBasedColIndex);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CColumn::ScOnListViewColumnInserted
 *
 * PURPOSE: Handler for event fired by LV, informing that new column was inserted
 *
 * PARAMETERS:
 *    int nIndex    - index of newly inserted column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CColumn::ScOnListViewColumnInserted (int nIndex)
{
    DECLARE_SC(sc, TEXT("CColumn::ScOnListViewColumnInserted "));

    // increment own index if column inserted ahead
    if (m_iIndex >= nIndex)
        m_iIndex++;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CColumn::ScOnListViewColumnDeleted
 *
 * PURPOSE: Handler for event fired by LV, informing that new column was deleted
 *
 * PARAMETERS:
 *    int nIndex - index of deleted column
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CColumn::ScOnListViewColumnDeleted (int nIndex)
{
    DECLARE_SC(sc, TEXT("CColumn::ScOnListViewColumnDeleted "));

    // decrement own index if column deleted ahead
    if (m_iIndex > nIndex)
        m_iIndex--;
    // disconnect from world if it's me who just died
    else if (m_iIndex == nIndex)
    {
        // I'm hit. I'm hit. I'm hit.
        m_iIndex = -1;
        // disconnect from the tied object
        if (IsTied())
        {
            CMyTiedObject *pTied = NULL;
            sc = ScGetTiedObject(pTied);
            if (sc)
                return sc;

            sc = ScCheckPointers(pTied, E_UNEXPECTED);
            if (sc)
                return sc;

            // break the connection
            pTied->RemoveFromList(this);
            Unadvise();
        }
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\controls.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       controls.h
//
//--------------------------------------------------------------------------

// Controls.h
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONTROLS_H__
#define __CONTROLS_H__
#pragma once

#include "conuiobservers.h"		// for CTreeViewObserver
#include <initguid.h>
#include <oleacc.h>

#ifdef DBG
extern CTraceTag tagToolbarAccessibility;
#endif


bool IsIgnorableButton (const TBBUTTON& tb);

class CRebarWnd;
class CAccel;
class CToolbarTrackerAuxWnd;

/////////////////////////////////////////////////////////////////////////////
// CDescriptionCtrl window

class CDescriptionCtrl : public CStatic, public CTreeViewObserver
{
// Construction
public:
    CDescriptionCtrl();

// Attributes
public:
    void SetSnapinText (const CString& strSnapinText);

    const CString& GetSnapinText () const
        { return (m_strSnapinText); }

    int GetHeight() const
        { return (m_cyRequired); }

	/*
	 * handlers for events fired to tree view observers
	 */
    virtual SC ScOnSelectedItemTextChanged (LPCTSTR pszNewText);

private:
    void CreateFont();
    void DeleteFont();

private:
    CString m_strConsoleText;
    CString m_strSnapinText;
    CFont   m_font;
    int     m_cxMargin;
    int     m_cyText;
    int     m_cyRequired;


// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDescriptionCtrl)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDescriptionCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CDescriptionCtrl)
    afx_msg UINT OnNcHitTest(CPoint point);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG

    afx_msg void DrawItem(LPDRAWITEMSTRUCT lpdis);

    DECLARE_MESSAGE_MAP()

//Attributes
protected:

};

/////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// CToolBarCtrlBase window


/*+-------------------------------------------------------------------------*
 * CToolBarCtrlBase
 *
 * This class only exists to provide simple wrappers around new toolbar
 * control messages that the version of MFC we use doesn't support.  It
 * will be removed when MFC supports the new messages.
 *
 * If you need functionality other than that, derive a class from
 * CToolBarCtrlBase.
 *--------------------------------------------------------------------------*/

class CToolBarCtrlBase : public CToolBarCtrl
{
private:
    CImageList* GetImageList_(int msg);
    CImageList* SetImageList_(int msg, CImageList* pImageList, int idImageList = 0);

public:
    CImageList* GetImageList();
    CImageList* SetImageList(CImageList* pImageList, int idImageList = 0);
    CImageList* GetHotImageList();
    CImageList* SetHotImageList(CImageList* pImageList);
    CImageList* GetDisabledImageList();
    CImageList* SetDisabledImageList(CImageList* pImageList);

    /*
     * CToolBarCtrl::SetOwner doesn't return the previous parent
     * and doesn't handle a NULL owner
     */
    CWnd* SetOwner (CWnd* pwndNewOwner);

    void SetMaxTextRows(int iMaxRows);
    void SetButtonWidth(int cxMin, int cxMax);
    DWORD GetButtonSize(void);

    #if (_WIN32_IE >= 0x0400)
        int GetHotItem ();
        int SetHotItem (int iHot);
        CSize GetPadding ();
        CSize SetPadding (CSize size);
        bool GetButtonInfo (int iID, LPTBBUTTONINFO ptbbi);
        bool SetButtonInfo (int iID, LPTBBUTTONINFO ptbbi);
    #endif  // _WIN32_IE >= 0x0400
};


///////////////////////////////////////////////////////////////////////////
// CToolBarCtrlEx window

class CToolBarCtrlEx : public CToolBarCtrlBase
{
	typedef CToolBarCtrlBase BaseClass;

// Construction
public:
    CToolBarCtrlEx();

// Attributes
public:
    CSize GetBitmapSize(void);

// Operations
public:
    void Show(BOOL bShow, bool bAddToolbarInNewLine = false);
    bool IsBandVisible();
    int  GetBandIndex();
    void UpdateToolbarSize(void);
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CToolBarCtrlEx)
    public:
    virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
    virtual BOOL SetBitmapSize(CSize sz);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CToolBarCtrlEx();

// Overridables
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);


    // Generated message map functions
protected:
    //{{AFX_MSG(CToolBarCtrlEx)
    afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()


protected:
    CSize       m_sizeBitmap;
    CRebarWnd*  m_pRebar;
    int         m_cx;  // Current Width
    bool        m_fMirrored;

};

////////////////////////////////////////////////////////////////////////////
// CRebarWnd window

class CRebarWnd : public CWnd
{
// Construction
public:
    CRebarWnd();

// Attributes
public:

// Operations
public:
    CRect CalculateSize(CRect maxRect);

    LRESULT GetBarInfo(REBARINFO* prbi);
    LRESULT SetBarInfo(REBARINFO* prbi);
    LRESULT InsertBand(LPREBARBANDINFO lprbbi);
    LRESULT SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);
    LRESULT GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);
    LRESULT DeleteBand(UINT uBand);
    CWnd *  SetParent(CWnd* pwndParent);
    UINT GetBandCount ();
    UINT GetRowCount ();
    UINT GetRowHeight (UINT uRow);

    #if (_WIN32_IE >= 0x0400)
        int  HitTest (LPRBHITTESTINFO lprbht);
        BOOL GetRect (UINT uBand, LPRECT lprc);
        int IdToIndex (UINT uBandID);
        CWnd* GetToolTips ();
        void  SetToolTips (CWnd* pwndTips);
        COLORREF GetBkColor ();
        COLORREF SetBkColor (COLORREF clrBk);
        COLORREF GetTextColor ();
        COLORREF SetTextColor (COLORREF clrBack);
        LRESULT SizeToRect (LPRECT lprc);

        // for manual drag control
        // lparam == cursor pos
                // -1 means do it yourself.
                // -2 means use what you had saved before
        void BeginDrag (UINT uBand, CPoint point);
        void BeginDrag (UINT uBand, DWORD dwPos);
        void EndDrag ();
        void DragMove (CPoint point);
        void DragMove (DWORD dwPos);
        UINT GetBarHeight ();
        void MinimizeBand (UINT uBand);
        void MaximizeBand (UINT uBand, BOOL fIdeal = false);
        void GetBandBorders (UINT uBand, LPRECT lprc);
        LRESULT ShowBand (UINT uBand, BOOL fShow);
        LRESULT MoveBand (UINT uBandFrom, UINT uBandTo);
        CPalette* GetPalette ();
        CPalette* SetPalette (CPalette* ppal);
    #endif      // _WIN32_IE >= 0x0400

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRebarWnd)
    public:
    virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
    protected:
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRebarWnd();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRebarWnd)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSysColorChange();
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    //}}AFX_MSG
    afx_msg LRESULT OnSetRedraw(WPARAM, LPARAM);
    afx_msg void OnRebarAutoSize(NMHDR* pNotify, LRESULT* result);
    afx_msg void OnRebarHeightChange(NMHDR* pNotify, LRESULT* result);
    DECLARE_MESSAGE_MAP()

private:
    bool    m_fRedraw;
};


////////////////////////////////////////////////////////////////////////////
// CTabCtrlEx window


/*+-------------------------------------------------------------------------*
 * CTabCtrlEx
 *
 * This class only exists to provide simple wrappers around new tab
 * control messages that the version of MFC we use doesn't support.  It
 * will be removed when MFC supports the new messages.
 *
 * If you need functionality other than that, derive a class from
 * CTabCtrlEx.
 *--------------------------------------------------------------------------*/

class CTabCtrlEx : public CTabCtrl
{
public:
    void  DeselectAll (bool fExcludeFocus);
    bool  HighlightItem (UINT nItem, bool fHighlight);
    DWORD GetExtendedStyle ();
    DWORD SetExtendedStyle (DWORD dwExStyle, DWORD dwMask = 0);
    bool  GetUnicodeFormat ();
    bool  SetUnicodeFormat (bool fUnicode);
    void  SetCurFocus (UINT nItem);
    bool  SetItemExtra (UINT cbExtra);
    int   SetMinTabWidth (int cx);
};



/////////////////////////////////////////////////////////////////////////////
// CToolBar idle update through CToolCmdUIEx class

class CToolCmdUIEx : public CCmdUI        // class private to this file !
{
public: // re-implementations only
    virtual void Enable(BOOL bOn);
    virtual void SetCheck(int nCheck);
    virtual void SetText(LPCTSTR lpszText);
    void SetHidden(BOOL bHidden);
};



/////////////////////////////////////////////////////////////////////////////
// CMMCToolBarCtrlEx window

class CMMCToolBarCtrlEx : public CToolBarCtrlEx, public CTiedObject
{
    static const CAccel& GetTrackAccel();

    bool    m_fTrackingToolBar;
	bool	m_fFakeFocusApplied;	// have we send fake OBJ_FOCUS events?

// Construction
public:
    CMMCToolBarCtrlEx();

// Attributes
public:
    enum
    {
        ID_MTBX_NEXT_BUTTON = 0x5400,   // could be anything
        ID_MTBX_PREV_BUTTON,
        ID_MTBX_PRESS_HOT_BUTTON,
        ID_MTBX_END_TRACKING,

        ID_MTBX_FIRST = ID_MTBX_NEXT_BUTTON,
        ID_MTBX_LAST  = ID_MTBX_END_TRACKING,
    };

    bool IsTrackingToolBar () const
    {
        return (m_fTrackingToolBar);
    }


// Operations
public:
    virtual int GetFirstButtonIndex ();
    int GetNextButtonIndex (int nStartIndex, int nIncrement = 1);
    int GetPrevButtonIndex (int nStartIndex, int nIncrement = 1);

private:
    int GetNextButtonIndexWorker (int nStartIndex, int nIncrement, bool fAdvance);

protected:
    bool IsIgnorableButton (int nButtonIndex);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMCToolBarCtrlEx)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMMCToolBarCtrlEx();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMMCToolBarCtrlEx)
    afx_msg void OnHotItemChange(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG

    afx_msg void OnNextButton ();
    afx_msg void OnPrevButton ();
    afx_msg void OnPressHotButton ();
    DECLARE_MESSAGE_MAP()

public:
    afx_msg void BeginTracking ();
    afx_msg void EndTracking   ();

    virtual void BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd);
    virtual void EndTracking2   (CToolbarTrackerAuxWnd* pAuxWnd);

	// *** IAccPropServer methods ***
	SC ScGetPropValue (
		const BYTE*			pIDString,
		DWORD				dwIDStringLen,
		MSAAPROPID			idProp,
		VARIANT *			pvarValue,
		BOOL *				pfGotProp);

protected:
	typedef std::vector<MSAAPROPID> PropIDCollection;

	/*
	 * Derived classes can override this to handle properties they support.
	 * The base class should always be called first.
	 */
	virtual SC ScGetPropValue (
		HWND				hwnd,		// I:accessible window
		DWORD				idObject,	// I:accessible object
		DWORD				idChild,	// I:accessible child object
		const MSAAPROPID&	idProp,		// I:property requested
		VARIANT&			varValue,	// O:returned property value
		BOOL&				fGotProp);	// O:was a property returned?

	virtual SC ScInsertAccPropIDs (PropIDCollection& v);

private:
	// Accessibility stuff
	SC ScInitAccessibility ();
	SC ScRestoreAccFocus ();

	CComPtr<IAccPropServices>	m_spAccPropServices;
	CComPtr<IAccPropServer>		m_spAccPropServer;
	PropIDCollection			m_vPropIDs;
};


#include "controls.inl"

#endif //__CONTROLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\controls.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      controls.inl
 *
 *  Contents:  Inline functions for controls.h
 *
 *  History:   7-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*+-------------------------------------------------------------------------*
 * CToolBarCtrlBase inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline CImageList* CToolBarCtrlBase::GetImageList_(int msg)
{
    return (CImageList::FromHandle ((HIMAGELIST) SendMessage (msg)));
}

// Toolbar with multiple imagelists.
inline CImageList* CToolBarCtrlBase::SetImageList_(int msg, CImageList* pImageList, int idImageList)
{
    return (CImageList::FromHandle ((HIMAGELIST) SendMessage (msg, idImageList, (LPARAM)pImageList->GetSafeHandle())));
}

inline CImageList* CToolBarCtrlBase::GetImageList()
{
    return (GetImageList_(TB_GETIMAGELIST));
}

// Toolbar with multiple imagelists.
inline CImageList* CToolBarCtrlBase::SetImageList(CImageList* pImageList, int idImageList)
{
    return (SetImageList_(TB_SETIMAGELIST, pImageList, idImageList));
}

inline CImageList* CToolBarCtrlBase::GetHotImageList()
{
    return (GetImageList_(TB_GETHOTIMAGELIST));
}

inline CImageList* CToolBarCtrlBase::SetHotImageList(CImageList* pImageList)
{
    return (SetImageList_(TB_SETHOTIMAGELIST, pImageList));
}

inline CImageList* CToolBarCtrlBase::GetDisabledImageList()
{
    return (GetImageList_(TB_GETDISABLEDIMAGELIST));
}

inline CImageList* CToolBarCtrlBase::SetDisabledImageList(CImageList* pImageList)
{
    return (SetImageList_(TB_SETDISABLEDIMAGELIST, pImageList));
}

inline void CToolBarCtrlBase::SetMaxTextRows(int iMaxRows)
{
    SendMessage (TB_SETMAXTEXTROWS, iMaxRows);
}

inline void CToolBarCtrlBase::SetButtonWidth(int cxMin, int cxMax)
{
    SendMessage (TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
}

inline DWORD CToolBarCtrlBase::GetButtonSize(void)
{
    return SendMessage (TB_GETBUTTONSIZE);
}

inline CWnd* CToolBarCtrlBase::SetOwner(CWnd* pwndNewParent)
{
    return (CWnd::FromHandle ((HWND) SendMessage (TB_SETPARENT, (WPARAM) pwndNewParent->GetSafeHwnd())));
}

#if (_WIN32_IE >= 0x0400)
inline int CToolBarCtrlBase::GetHotItem ()
{
    return (SendMessage (TB_GETHOTITEM));
}

inline int CToolBarCtrlBase::SetHotItem (int iHot)
{
    return (SendMessage (TB_SETHOTITEM, iHot));
}

inline CSize CToolBarCtrlBase::GetPadding ()
{
    return (CSize (SendMessage (TB_GETPADDING)));
}

inline CSize CToolBarCtrlBase::SetPadding (CSize size)
{
    return (CSize (SendMessage (TB_SETPADDING, 0, MAKELPARAM (size.cx, size.cy))));
}

inline bool CToolBarCtrlBase::GetButtonInfo (int iID, LPTBBUTTONINFO ptbbi)
{
    return (SendMessage (TB_GETBUTTONINFO, iID, (LPARAM) ptbbi) != 0);
}

inline bool CToolBarCtrlBase::SetButtonInfo (int iID, LPTBBUTTONINFO ptbbi)
{
    return (SendMessage (TB_SETBUTTONINFO, iID, (LPARAM) ptbbi) != 0);
}
#endif  // _WIN32_IE >= 0x0400



/*+-------------------------------------------------------------------------*
 * CToolBarCtrlEx inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline BOOL CToolBarCtrlEx::SetBitmapSize(CSize sz)
{
    if (!BaseClass::SetBitmapSize(sz))
        return (FALSE);

    m_sizeBitmap = sz;
    return (TRUE);
}

inline CSize CToolBarCtrlEx::GetBitmapSize(void)
{
    return m_sizeBitmap;
}


/*+-------------------------------------------------------------------------*
 * CTabCtrlEx inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline void CTabCtrlEx::DeselectAll (bool fExcludeFocus)
{
    SendMessage (TCM_DESELECTALL, fExcludeFocus);
}

inline bool CTabCtrlEx::HighlightItem (UINT nItem, bool fHighlight)
{
    return (SendMessage (TCM_HIGHLIGHTITEM, nItem, MAKELONG (fHighlight, 0)) ? true : false);
}

inline DWORD CTabCtrlEx::GetExtendedStyle ()
{
    return (SendMessage (TCM_GETEXTENDEDSTYLE));
}

inline DWORD CTabCtrlEx::SetExtendedStyle (DWORD dwExStyle, DWORD dwMask /* =0 */)
{
    return (SendMessage (TCM_SETEXTENDEDSTYLE, dwMask, dwExStyle));
}

inline bool CTabCtrlEx::GetUnicodeFormat ()
{
    return (SendMessage (TCM_GETUNICODEFORMAT) ? true : false);
}

inline bool CTabCtrlEx::SetUnicodeFormat (bool fUnicode)
{
    return (SendMessage (TCM_SETUNICODEFORMAT, fUnicode) ? true : false);
}

inline void CTabCtrlEx::SetCurFocus (UINT nItem)
{
    SendMessage (TCM_SETCURFOCUS, nItem);
}

inline bool CTabCtrlEx::SetItemExtra (UINT cbExtra)
{
    return (SendMessage (TCM_SETITEMEXTRA, cbExtra) ? true : false);
}

inline int CTabCtrlEx::SetMinTabWidth (int cx)
{
    return (SendMessage (TCM_SETMINTABWIDTH, 0, cx));
}



/*+-------------------------------------------------------------------------*
 * CRebarWnd inline functions
 *
 *
 *--------------------------------------------------------------------------*/

inline LRESULT CRebarWnd::SetBarInfo(REBARINFO* prbi)
{
    ASSERT (prbi != NULL);
    return SendMessage (RB_SETBARINFO, 0, (LPARAM)prbi);
}

inline LRESULT CRebarWnd::GetBarInfo(REBARINFO* prbi)
{
    ASSERT (prbi != NULL);
    return SendMessage (RB_GETBARINFO, 0, (LPARAM)prbi);
}

inline LRESULT CRebarWnd::InsertBand(LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    return SendMessage (RB_INSERTBAND, -1, (LPARAM)lprbbi);
}

inline LRESULT CRebarWnd::SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    return SendMessage (RB_SETBANDINFO, uBand, (LPARAM)lprbbi);
}

inline LRESULT CRebarWnd::GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    return SendMessage (RB_GETBANDINFO, uBand, (LPARAM)lprbbi);
}

inline LRESULT CRebarWnd::DeleteBand(UINT uBand)
{
    return SendMessage (RB_DELETEBAND, uBand);
}

inline CWnd* CRebarWnd::SetParent(CWnd* pwndParent)
{
    return CWnd::FromHandle((HWND)SendMessage (RB_SETPARENT, (WPARAM) pwndParent->GetSafeHwnd()));
}

inline UINT CRebarWnd::GetBandCount()
{
    return SendMessage (RB_GETBANDCOUNT);
}

inline UINT CRebarWnd::GetRowCount()
{
    return SendMessage (RB_GETROWCOUNT);
}

inline UINT CRebarWnd::GetRowHeight(UINT uRow)
{
    return SendMessage (RB_GETROWHEIGHT);
}

#if (_WIN32_IE >= 0x0400)
inline int CRebarWnd::HitTest (LPRBHITTESTINFO lprbht)
{
    ASSERT (lprbht != NULL);
    return SendMessage (RB_HITTEST, 0, (LPARAM) lprbht);
}

inline BOOL CRebarWnd::GetRect (UINT uBand, LPRECT lprc)
{
    ASSERT (lprc != NULL);
    return SendMessage (RB_GETRECT, uBand, (LPARAM) lprc);
}

inline int CRebarWnd::IdToIndex (UINT uBandID)
{
    return SendMessage (RB_IDTOINDEX, uBandID);
}

inline CWnd* CRebarWnd::GetToolTips ()
{
    return CWnd::FromHandle ((HWND)SendMessage (RB_GETTOOLTIPS));
}

inline void CRebarWnd::SetToolTips (CWnd* pwndTips)
{
    SendMessage (RB_SETTOOLTIPS, (WPARAM) pwndTips->GetSafeHwnd());
}

inline COLORREF CRebarWnd::GetBkColor ()
{
    return SendMessage (RB_GETBKCOLOR);
}

inline COLORREF CRebarWnd::SetBkColor (COLORREF clrBk)
{
    return SendMessage (RB_SETBKCOLOR, 0, clrBk);
}

inline COLORREF CRebarWnd::GetTextColor ()
{
    return SendMessage (RB_GETTEXTCOLOR);
}

inline COLORREF CRebarWnd::SetTextColor (COLORREF clrText)
{
    return SendMessage (RB_SETTEXTCOLOR, 0, clrText);
}

inline LRESULT CRebarWnd::SizeToRect (LPRECT lprc)
{
    ASSERT (lprc != NULL);
    return SendMessage (RB_SIZETORECT, 0, (LPARAM) lprc);
}

inline void CRebarWnd::BeginDrag (UINT uBand, CPoint point)
{
    BeginDrag (uBand, MAKELONG (point.x, point.y));
}

inline void CRebarWnd::BeginDrag (UINT uBand, DWORD dwPos)
{
    SendMessage (RB_BEGINDRAG, uBand, dwPos);
}

inline void CRebarWnd::EndDrag ()
{
    SendMessage (RB_ENDDRAG);
}

inline void CRebarWnd::DragMove (CPoint point)
{
    DragMove (MAKELONG (point.x, point.y));
}

inline void CRebarWnd::DragMove (DWORD dwPos)
{
    SendMessage (RB_BEGINDRAG, 0, dwPos);
}

inline UINT CRebarWnd::GetBarHeight()
{
    return SendMessage (RB_GETBARHEIGHT);
}

inline void CRebarWnd::MinimizeBand(UINT uBand)
{
    SendMessage (RB_MINIMIZEBAND, uBand);
}

inline void CRebarWnd::MaximizeBand(UINT uBand, BOOL fIdeal /* =false */)
{
    SendMessage (RB_MAXIMIZEBAND, uBand, fIdeal);
}

inline void CRebarWnd::GetBandBorders(UINT uBand, LPRECT lprc)
{
    ASSERT (lprc != NULL);
    SendMessage (RB_GETBANDBORDERS, uBand, (LPARAM) lprc);
}

inline LRESULT CRebarWnd::ShowBand(UINT uBand, BOOL fShow)
{
    return SendMessage (RB_SHOWBAND, uBand, fShow);
}

inline CPalette* CRebarWnd::GetPalette()
{
    return CPalette::FromHandle((HPALETTE) SendMessage (RB_GETPALETTE));
}

inline CPalette* CRebarWnd::SetPalette(CPalette * ppal)
{
    return CPalette::FromHandle((HPALETTE)SendMessage (RB_SETPALETTE, 0, (LPARAM)ppal->GetSafeHandle()));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "..\inc\StdDbg.h"

#ifdef DBG
    DECLARE_DEBUG(AMCConUI)
    #define DBG_COMP    AMCConUIInfoLevel
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\conuiptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       conuiptrs.h
//
//--------------------------------------------------------------------------

#pragma once
        
#ifndef CONUIPTRS_H
#define CONUIPTRS_H

#include <comptr.h>

DEFINE_CIP(_Application);
DEFINE_CIP(Document);
DEFINE_CIP(Views);
DEFINE_CIP(View);
DEFINE_CIP(SnapIns);
DEFINE_CIP(SnapIn);
DEFINE_CIP(ScopeNamespace);
DEFINE_CIP(Frame);
DEFINE_CIP(Nodes);
DEFINE_CIP(Node);
DEFINE_CIP(ContextMenu);
DEFINE_CIP(MenuItem);
DEFINE_CIP(ViewEvents);

#endif // CONUIPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\conuiobservers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      conuiobservers.h
//
//  Contents:  Observer interface class definitions used by all conui.
//
//  History:   24-Nov-99 VivekJ  Created
//
//

#pragma once

class CAMCView;
class CAMCViewToolbars;
class CAMCDoc;

/*+-------------------------------------------------------------------------*
 * class CTreeViewObserver
 *
 *
 * PURPOSE: The general interface for a class that observes a scope tree
 *          control.
 *
 *+-------------------------------------------------------------------------*/
class CTreeViewObserver : public CObserverBase
{
public:
    virtual SC ScOnItemAdded     (TVINSERTSTRUCT *pTVInsertStruct, HTREEITEM hti, HMTNODE hMTNode)  {DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnItemDeleted   (HNODE hNode, HTREEITEM hti)                                       {DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnItemDeselected(HNODE hNode)                                                      {DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnSelectedItemTextChanged (LPCTSTR pszNewText)										{DEFAULT_OBSERVER_METHOD;}
    virtual SC ScOnTreeViewActivated ()										                        {DEFAULT_OBSERVER_METHOD;}
};


/*+-------------------------------------------------------------------------*
 * class CAMCViewObserver
 *
 *
 * PURPOSE: Interface for observers of CAMCView
 *
 *+-------------------------------------------------------------------------*/
class CAMCViewObserver : public CObserverBase
{
public:
    virtual SC  ScOnViewCreated     (CAMCView *pAMCView) {DEFAULT_OBSERVER_METHOD;} // called when a view is created.
    virtual SC  ScOnViewDestroyed   (CAMCView *pAMCView) {DEFAULT_OBSERVER_METHOD;} // called when a view is destroyed
    virtual SC  ScOnViewResized     (CAMCView *pAMCView, UINT nType, int cx, int cy) {DEFAULT_OBSERVER_METHOD;} // called when a view is resized
    virtual SC  ScOnViewTitleChanged(CAMCView *pAMCView) {DEFAULT_OBSERVER_METHOD;} // called when the view title changes.
    virtual SC  ScOnActivateView    (CAMCView *pAMCView, bool bFirstActiveView) {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
    virtual SC  ScOnDeactivateView  (CAMCView *pAMCView, bool bLastActiveView)  {DEFAULT_OBSERVER_METHOD;} // called when the view is de-activated.
    virtual SC  ScOnCloseView       (CAMCView *pView )  {DEFAULT_OBSERVER_METHOD;} // called before view is closed.
    virtual SC  ScOnViewChange      (CAMCView *pView, HNODE hNode )  {DEFAULT_OBSERVER_METHOD;} // called when scope node selection changes.
    virtual SC  ScOnResultSelectionChange(CAMCView *pView )  {DEFAULT_OBSERVER_METHOD;} // called when the result selection on view changes.
    virtual SC  ScOnListViewItemUpdated(CAMCView *pView , int nIndex)  {DEFAULT_OBSERVER_METHOD;} // called when a list view item is updated.
};

/*+-------------------------------------------------------------------------*
 * class CListViewObserver
 *
 *
 * PURPOSE: Interface for observers of CListView
 *
 *+-------------------------------------------------------------------------*/
class CListViewObserver : public CObserverBase
{
public:
    // observed events
    virtual SC ScOnListViewIndexesReset()              { DEFAULT_OBSERVER_METHOD } // called when result contents is removed or reordered (sort) so no indexes can be considered valid after it
    virtual SC ScOnListViewItemInserted(int nIndex)    { DEFAULT_OBSERVER_METHOD } // called when item is inserted to result data    
    virtual SC ScOnListViewItemDeleted (int nIndex)    { DEFAULT_OBSERVER_METHOD } // called when item is deleted from result data    
    virtual SC ScOnListViewColumnInserted (int nIndex) { DEFAULT_OBSERVER_METHOD } // called when column is inserted to listview    
    virtual SC ScOnListViewColumnDeleted (int nIndex)  { DEFAULT_OBSERVER_METHOD } // called when column is deleted from listview
    virtual SC ScOnListViewItemUpdated (int nIndex)    { DEFAULT_OBSERVER_METHOD } // called when an item is updated
};

//+-------------------------------------------------------------------
//
//  Class:      CAMCViewToolbarsObserver
//
//  Synopsis:   For any one to take note of active CAMCViewToolbars object
//              The main toolbar observes for which CAMCViewToolbar
//              is active so that that object can receive toolbutton
//              clicked & tooltip events.
//
//+-------------------------------------------------------------------
class CAMCViewToolbarsObserver : public CObserverBase
{
public:
    virtual SC  ScOnActivateAMCViewToolbars   (CAMCViewToolbars *pAMCViewToolbars) {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
    virtual SC  ScOnDeactivateAMCViewToolbars ()                                   {DEFAULT_OBSERVER_METHOD;} // called when the view is de-activated.
    virtual SC  ScOnToolbarButtonClicked      ()                                   {DEFAULT_OBSERVER_METHOD;} // called when the view is de-activated.
};

//+-------------------------------------------------------------------
//
//  Class:      CListViewActivationObserver
//
//  Synopsis:   For any one to observe when the CAMCListView being activated or deactivated.
//
//+-------------------------------------------------------------------
class CListViewActivationObserver : public CObserverBase
{
public:
    virtual SC  ScOnListViewActivated () {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
};


//+-------------------------------------------------------------------
//
//  Class:      COCXHostActivationObserver
//
//  Synopsis:   For any one to observe when the OCX or WEB host being activated or deactivated.
//
//+-------------------------------------------------------------------
class COCXHostActivationObserver : public CObserverBase
{
public:
    virtual SC  ScOnOCXHostActivated () {DEFAULT_OBSERVER_METHOD;} // called when the view is activated.
};

//+-------------------------------------------------------------------
//
//  Class:      CAMCDocumentObserver
//
//  Synopsis:   Observes the document object.
//
//+-------------------------------------------------------------------
class CAMCDocumentObserver : public CObserverBase
{
public:
    virtual SC  ScDocumentLoadCompleted (CAMCDoc *pDoc) {DEFAULT_OBSERVER_METHOD;} // called when the document is loaded.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\dd.h ===
#pragma once
#ifndef DD_H_INCLUDED
#define DD_H_INCLUDED

/*
    Classes participating in Drag-And-Drop:
        CMMCDropSource
            1.  Implements IDropSource interface and the created instance of this class
                is given to OLE for d&d operation
            2.  Implements static member ScDoDragDrop which creates the instance and starts d&d
                by calling OLE Api function
        CMMCDropTarget ( TiedComObject tied to CMMCViewDropTarget )
            Implements interface IDropTarget interface and the created instance of this class
            is given to OLE for d&d operation. Its instances are tied to CMMCViewDropTarget instance
            and it places the call to this class in respond to method invocations made by OLE
        CMMCViewDropTarget
            Adds d&d support to the view by creating the instance of CMMCDropTarget (TiedComObject)
            and registering it with OLE, responding to method calls made by that instance and invoking
            virtual methods on derived class to do the HitTest/Drop. 
            Registration in done by invoking protected method ScRegisterAsDropTarget.
            Target is revoke on destructor.
        CAMCTreeView
            Derives from CMMCViewDropTarget. Registers after window is created.
            Implements virtual methods to HitTest / Perform the Drop.
        CAMCListView
            Derives from CMMCViewDropTarget. Registers after window is created.
            Implements virtual methods to HitTest / Perform the Drop.
*/

/***************************************************************************\
 *
 * CLASS:  CMMCViewDropTarget
 *
 * PURPOSE: Defines common behavior for D&D-enabled view,
 *          Also defines the interface for HitTest function
 *
 * USAGE:   Derive your view from this class (CAMCListView and CAMCTreeView does)
 *          Implement virtual methods ScDropOnTarget and RemoveDropTargetHiliting in your class
 *          Add a call to ScRegisterAsDropTarget() after the window is created
 *
\***************************************************************************/
class CMMCViewDropTarget : public CTiedObject
{
protected: 
    
    // these methods should only be used by the derived class

    // construction - destruction
    CMMCViewDropTarget();
    ~CMMCViewDropTarget();

    // drop target registration
    SC ScRegisterAsDropTarget(HWND hWnd);

public:

    // interface methods the derived class must implement
    virtual SC   ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint pt, bool& bCopyOperation) = 0;
    virtual void RemoveDropTargetHiliting() = 0;


    // accessory used by tied com object to display the context menu
    HWND GetWindowHandle() { return m_hwndOwner; }

private:
    // implementation helper - creates tied com object
    SC ScCreateTarget(IDropTarget **ppTarget);

    IDropTargetPtr m_spTarget;  // tied com object
    HWND           m_hwndOwner; // window handle of the wiew
};

#endif DD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\dd.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dd.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8/3/1997   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"


#include "AMCDoc.h"         // AMC Console Document
#include "amcview.h"
#include "TreeCtrl.h"
#include "cclvctl.h"
#include "amcpriv.h"
#include "mainfrm.h"
#include "rsltitem.h"
#include "conview.h"

/***************************************************************************\
 *
 * CLASS:  CMMCDropSource
 *
 * PURPOSE: Implements everything required for drop source:
 *          a) com object to register with OLE
 *          b) static method to perform drag&drop operation
 *
 * USAGE:   All you need is to invoke CMMCDropSource::ScDoDragDrop static method
 *
\***************************************************************************/
class CMMCDropSource :
public IDropSource,
public CComObjectRoot
{
public:

BEGIN_COM_MAP(CMMCDropSource)
    COM_INTERFACE_ENTRY(IDropSource)
END_COM_MAP()

    // IDropSource methods
    STDMETHOD(QueryContinueDrag)( BOOL fEscapePressed,  DWORD grfKeyState );
    STDMETHOD(GiveFeedback)( DWORD dwEffect );

    // method to perform D&D
    static SC ScDoDragDrop(IDataObject *pDataObject, bool bCopyAllowed, bool bMoveAllowed);
};

/***************************************************************************\
 *
 * CLASS:  CMMCDropTarget
 *
 * PURPOSE: Implements com object to be osed by OLE for drop target operations
 *
 * USAGE:   Used by CMMCViewDropTarget, which creates and registers it with OLE
 *          to be invoked on OLE D&D opeartions on the window (target)
 *
\***************************************************************************/
class CMMCDropTarget :
public CTiedComObject<CMMCViewDropTarget>,
public IDropTarget,
public CComObjectRoot
{
public:
    typedef CMMCViewDropTarget MyTiedObject;

BEGIN_COM_MAP(CMMCDropTarget)
    COM_INTERFACE_ENTRY(IDropTarget)
END_COM_MAP()

    // IDropTarget methods

    STDMETHOD(DragEnter)( IDataObject * pDataObject, DWORD grfKeyState,
                          POINTL pt, DWORD * pdwEffect );
    STDMETHOD(DragOver)( DWORD grfKeyState, POINTL pt, DWORD * pdwEffect );
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)( IDataObject * pDataObject, DWORD grfKeyState,
                     POINTL pt, DWORD * pdwEffect  );
private:

    // implementation helpers

    SC ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, POINTL pt, bool& bCopyOperation);
    SC ScRemoveDropTargetHiliting();
    static SC ScAddMenuString(CMenu& menu, DWORD id, UINT idString);
    SC ScDisplayDropMenu(POINTL pt, DWORD dwEffectsAvailable, DWORD& dwSelected);
    DWORD CalculateEffect(DWORD dwEffectsAvailable, DWORD grfKeyState, bool bCopyPreferred);

private:
    IDataObjectPtr m_spDataObject;      // cached data object
    bool           m_bRightDrag;        // operation is right click drag
    bool           m_bCopyByDefault;    // if default operation is copy (not move)
};

//////////////////////////////////////////////////////////////////////////////
////////// CAMCTreeView methods for supporting d&d ///////////////////////////
//////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::ScDropOnTarget
 *
 * PURPOSE: called to hittest or perform drop operation
 *
 * PARAMETERS:
 *    bool bHitTestOnly         [in] - HitTest / drop
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    CPoint point              [in] - current cursor position
 *    bool& bCopyOperation      [in/out]
 *                                 [in] -  operation to perform (HitTest == false)
 *                                 [out] - default op. (HitTest == true)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCTreeView::ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint point, bool& bCopyOperation)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::ScDropOnTarget"));

    // 1. see where it falls
    CTreeCtrl& ctc = GetTreeCtrl();
    UINT flags;
    HTREEITEM htiDrop = ctc.HitTest(point, &flags);

    if (flags & TVHT_NOWHERE)
        return sc = S_FALSE; // not an error, but no paste;

    // 2. if we missed the tree item...
    if (!htiDrop)
    {
        // really mad if it was a paste
        if (! bHitTestOnly)
            MessageBeep(0);

        return sc = S_FALSE; // not an error, but no paste;
    }

    // 3. get the target node

    HNODE hNode = (HNODE) ctc.GetItemData(htiDrop);

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
        return sc;

    // 4. ask what snapin thinks about this paste
    bool bGetDataObjectFromClipboard = false;
    bool bPasteAllowed = false;
    bool bIsCopyDefaultOperation = false;
    sc = pNC->QueryPaste(hNode, /*bScope*/ true, /*LVDATA*/ NULL,
                         pDataObject, bPasteAllowed, bIsCopyDefaultOperation);
    if (sc)
        return sc;

    if (!bPasteAllowed)
        return sc = S_FALSE; // not an error, but no paste;

    // 5. visual effect
    ctc.SelectDropTarget(htiDrop);

    // 6. OK so far. If it was a test - we passed
    if (bHitTestOnly)
    {
        bCopyOperation = bIsCopyDefaultOperation;
        return sc;
    }

    // 7. do paste NOW
    sc = pNC->Drop(hNode, /*bScope*/TRUE, /*LVDATA*/NULL, pDataObject, !bCopyOperation);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::RemoveDropTargetHiliting
 *
 * PURPOSE: called to remove hiliting put for drop target
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCTreeView::RemoveDropTargetHiliting()
{
    CTreeCtrl& ctc = GetTreeCtrl();
    ctc.SelectDropTarget(NULL);
}

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::OnBeginRDrag
 *
 * PURPOSE: called when the drag operation is initiated with right mouse button
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCTreeView::OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    OnBeginDrag(pNMHDR, pResult);
}

/***************************************************************************\
 *
 * METHOD:  CAMCTreeView::OnBeginDrag
 *
 * PURPOSE: called when the drag operation is initiated with
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CAMCTreeView::OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCTreeView::OnBeginDrag"));

    // 1. parameter check
    sc = ScCheckPointers( pNMHDR, pResult );
    if (sc)
        return;

    *pResult = 0;

    // 2. get node calback
    CTreeCtrl& ctc = GetTreeCtrl();
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    HNODE hNode = (HNODE) ctc.GetItemData(pNMTreeView->itemNew.hItem);

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers( pNC, E_UNEXPECTED );
    if (sc)
        return;

    // 3. get data object
    IDataObjectPtr spDO;
    bool bCopyAllowed = false;
    bool bMoveAllowed = false;
    sc = pNC->GetDragDropDataObject(hNode, TRUE, 0, 0, &spDO, bCopyAllowed, bMoveAllowed);
    if ( sc != S_OK || spDO == NULL)
        return;

    // 4. start d&d
    sc = CMMCDropSource::ScDoDragDrop(spDO, bCopyAllowed, bMoveAllowed);
    if (sc)
        return;
}

//////////////////////////////////////////////////////////////////////////////
////////// CAMCListView methods for supporting d&d ///////////////////////////
//////////////////////////////////////////////////////////////////////////////

// helpers

INodeCallback* CAMCListView::GetNodeCallback()
{
    ASSERT (m_pAMCView != NULL);
    return (m_pAMCView->GetNodeCallback());
}

HNODE CAMCListView::GetScopePaneSelNode()
{
    ASSERT (m_pAMCView != NULL);
    return (m_pAMCView->GetSelectedNode());
}

/***************************************************************************\
 *
 * METHOD:  CAMCListView::ScDropOnTarget
 *
 * PURPOSE: called to hittest or perform drop operation
 *
 * PARAMETERS:
 *    bool bHitTestOnly         [in] - HitTest / drop
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    CPoint point              [in] - current cursor position
 *    bool& bCopyOperation      [in/out]
 *                                 [in] -  operation to perform (HitTest == false)
 *                                 [out] - default op. (HitTest == true)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCListView::ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, CPoint point, bool& bCopyOperation)
{
    DECLARE_SC(sc, TEXT("CAMCListView::ScDropOnTarget"));

    // 1. sanity check
    sc = ScCheckPointers( m_pAMCView , E_UNEXPECTED );
    if (sc)
        return sc;

    // 2. see if view does not have a paste tabu (listpads do)
    if (!m_pAMCView->CanDoDragDrop())
        return sc = (bHitTestOnly ? S_FALSE : E_FAIL); // not an error if testing

    // 3. HitTest the target
    HNODE  hNode  = NULL;
    bool   bScope = false;
    LPARAM lvData = NULL;
    int    iDrop  = -1;

    sc = ScGetDropTarget(point, hNode, bScope, lvData, iDrop);
    if (sc.IsError() || (sc == SC(S_FALSE)))
        return sc;

    // 4. get the callback
    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(pNC, E_UNEXPECTED);
    if (sc)
        return sc;

    // 5. ask what snapin thinks about this paste
    const bool bGetDataObjectFromClipboard = false;
    bool bPasteAllowed = false;
    bool bIsCopyDefaultOperation = false;
    sc = pNC->QueryPaste(hNode, bScope, lvData,
                         pDataObject, bPasteAllowed, bIsCopyDefaultOperation);
    if (sc)
        return sc;

    if (!bPasteAllowed)
        return sc = S_FALSE; // not an error, but no paste;

    // 6. visual effect
    SelectDropTarget(iDrop);

    // 7. OK so far. If it was a test - we passed
    if (bHitTestOnly)
    {
        bCopyOperation = bIsCopyDefaultOperation;
        return sc;
    }

    // 8. do paste NOW
    sc = pNC->Drop(hNode, bScope, lvData, pDataObject, !bCopyOperation);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCListView::RemoveDropTargetHiliting
 *
 * PURPOSE: called to remove target hiliting
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCListView::RemoveDropTargetHiliting()
{
    SelectDropTarget(-1);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCListView::ScGetDropTarget
//
//  Synopsis:    Get the drop target item (result item or scope item).
//
//  Arguments:   [point]  - where the drop is done.
//               [hNode]  - Owner node of result pane.
//               [bScope] - scope or result selected.
//               [lvData] - If result the LPARAM of result item.
//               [iDrop]  - index of the lv item that is drop target.
//
//  Returns:     SC, S_FALSE means no drop target item.
//
//--------------------------------------------------------------------
SC CAMCListView::ScGetDropTarget(const CPoint& point, HNODE& hNode, bool& bScope, LPARAM& lvData, int& iDrop)
{
    DECLARE_SC(sc, _T("CAMCListView::ScGetDropTarget"));

    hNode = NULL;
    bScope = false;
    lvData = NULL;
    iDrop  = -1;

    CListCtrl& lc = GetListCtrl();
    UINT flags;
    iDrop = lc.HitTest(point, &flags);

    // background is drop target.
    if (iDrop < 0)
    {
        hNode = GetScopePaneSelNode();
        bScope = true;
        return sc;
    }

    // Need to change this to LVIS_DROPHILITED.
    if (lc.GetItemState(iDrop, LVIS_SELECTED) & LVIS_SELECTED)
    {
        HWND hWnd = ::GetForegroundWindow();
        if (hWnd && (hWnd == m_hWnd))
            return (sc = S_FALSE);
    }

	/*
	 * virtual list?  lvData is the item index, hNode is the item selected
	 * in the scope pane
	 */
	if (m_bVirtual)
	{
		hNode  = GetScopePaneSelNode();
		lvData = iDrop;
		bScope = false;
	}
	else
	{
		LPARAM  lParam = lc.GetItemData(iDrop);
		ASSERT (lParam != 0);
		if (lParam == 0)
			return (sc = S_FALSE);

		CResultItem* pri = CResultItem::FromHandle(lParam);

		if (pri == NULL)
			return (sc = S_FALSE);

		if (pri->IsScopeItem())
		{
			hNode = pri->GetScopeNode();
			bScope = true;
		}
		else
		{
			hNode = GetScopePaneSelNode();
			lvData = lParam;
		}
	}

    sc = ScCheckPointers(hNode, E_UNEXPECTED);
    if (sc)
        return sc;

    return (sc);
}


/***************************************************************************\
 *
 * METHOD:  CAMCListView::OnBeginRDrag
 *
 * PURPOSE: called when the drag operation is initiated with right mouse button
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCListView::OnBeginRDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    OnBeginDrag(pNMHDR, pResult);
}

/***************************************************************************\
 *
 * METHOD:  CAMCListView::OnBeginDrag
 *
 * PURPOSE: called when the drag operation is initiated
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCListView::OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCListView::OnBeginDrag"));

    // 1. parameter check
    sc = ScCheckPointers( pNMHDR, pResult );
    if (sc)
        return;

    *pResult = 0;

    // 2. sanity check
    sc = ScCheckPointers( m_pAMCView, E_UNEXPECTED );
    if (sc)
        return;

    // 3. see if view does not have a paste tabu (listpads do)
    if (!m_pAMCView->CanDoDragDrop())
        return;

    // 4. get selected items
    CListCtrl& lc = GetListCtrl();
    UINT cSel = lc.GetSelectedCount();
    if (cSel <= 0)
    {
        sc = E_UNEXPECTED;
        return;
    }

    // 5. get node callback
    HNODE hNode = GetScopePaneSelNode();
    long iSel = lc.GetNextItem(-1, LVIS_SELECTED);
    LONG_PTR lvData = m_bVirtual ? iSel : lc.GetItemData(iSel);

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers( pNC, E_UNEXPECTED );
    if (sc)
        return;

    // 6. retrieve data object
    IDataObjectPtr spDO;
    bool bCopyAllowed = false;
    bool bMoveAllowed = false;
    sc = pNC->GetDragDropDataObject(hNode, FALSE, (cSel > 1), lvData, &spDO, bCopyAllowed, bMoveAllowed);
    if ( sc != S_OK || spDO == NULL)
	{
		/*
		 * Problem: 
		 * If snapin does not return dataobject then drag & drop is not possible.
		 * Assume focus in on tree, user downclick's and drags a result item
		 * At this time common control sends LVN_ITEMCHANGED to mmc. MMC translates
		 * this to MMCN_SELECT and tells snapin that result item is selected.
		 * Now when user releases the mouse the tree item still has focus & selection,
		 * but the snapin thinks result item is selected (also verbs correspond to 
		 * result item). 
		 *
		 * Solution:
		 * So we will set focus to the result pane.
		 */
		sc = m_pAMCView->ScSetFocusToPane(CConsoleView::ePane_Results);
        return;
	}

    // 7. do d&d
    sc = CMMCDropSource::ScDoDragDrop(spDO, bCopyAllowed, bMoveAllowed);
    if (sc)
        return;

	/*
	 * Problem:
	 * If a result item is dropped into another result item or another
	 * scope item in list-view then focus disappears from that item.
	 * But there should be always an item selected after any de-select. 
	 * We cannot change the focus to result pane because if focus is already
	 * in result pane, this change focus does nothing and no item is selected.
	 * So we change the focus to scope pane. For this we first change the focus
	 * to result pane and then to scope pane. Because if tree already has focus, 
	 * setting focus to tree does nothing (CAMCView::ScOnTreeViewActivated).
	 *
	 * Solution:
	 * So we change the focus to result pane and then to scope pane.
	 */
	sc = m_pAMCView->ScSetFocusToPane(CConsoleView::ePane_Results);
	if (sc)
		return;

	sc = m_pAMCView->ScSetFocusToPane(CConsoleView::ePane_ScopeTree);
	if (sc)
		return;

	return;
}

//////////////////////////////////////////////////////////////////////////////
///////////////////// CMMCViewDropTarget methods /////////////////////////////
//////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::CMMCViewDropTarget
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCViewDropTarget::CMMCViewDropTarget() : m_hwndOwner(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::~CMMCViewDropTarget
 *
 * PURPOSE: destructor. Revokes drop target for derived view class
 *
\***************************************************************************/
CMMCViewDropTarget::~CMMCViewDropTarget()
{
    DECLARE_SC(sc, TEXT("CViewDropTarget::~CViewDropTarget"));

    if (m_hwndOwner != NULL)
        sc = RevokeDragDrop(m_hwndOwner);
}

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::ScRegisterAsDropTarget
 *
 * PURPOSE: This method is called by the derived class after the view window
 *          is created. Method registers the drop target for the window.
 *
 * PARAMETERS:
 *    HWND hWnd [in] - drop target view handle
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCViewDropTarget::ScRegisterAsDropTarget(HWND hWnd)
{
    DECLARE_SC(sc, TEXT("CMMCViewDropTarget::ScRegister"));

    // 1. parameter check
    if (hWnd == NULL)
        return sc = E_INVALIDARG;

    // 2. sanity check - should not come here twice
    if (m_spTarget != NULL)
        return sc = E_UNEXPECTED;

    // 3. create a drop target com object
    IDropTargetPtr spTarget;
    sc = ScCreateTarget(&spTarget);
    if (sc)
        return sc;

    // 4. recheck
    sc = ScCheckPointers(spTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 5. register with OLE
    sc = RegisterDragDrop(hWnd, spTarget);
    if (sc)
        return sc;

    // 6. store info into members
    m_spTarget.Attach( spTarget.Detach() );
    m_hwndOwner = hWnd;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCViewDropTarget::ScCreateTarget
 *
 * PURPOSE: helper. creates tied com object to regiter with OLE
 *
 * PARAMETERS:
 *    IDropTarget **ppTarget [out] tied com object
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCViewDropTarget::ScCreateTarget(IDropTarget **ppTarget)
{
    DECLARE_SC(sc, TEXT("CMMCViewDropTarget::ScCreateTarget"));

    // 1. check parameters
    sc = ScCheckPointers(ppTarget);
    if (sc)
        return sc;

    // 2. init out parameter
    *ppTarget = NULL;

    // 3. create com object to register as target
    IDropTargetPtr spDropTarget;
    sc = CTiedComObjectCreator<CMMCDropTarget>::ScCreateAndConnect(*this, spDropTarget);
    if (sc)
        return sc;

    sc = ScCheckPointers(spDropTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 4. pass reference to client
    *ppTarget = spDropTarget.Detach();

    return sc;
}

/*---------------------------------------------------------------------------*\
|                   class CMMCDropSource methods                              |
\*---------------------------------------------------------------------------*/

/***************************************************************************\
 *
 * METHOD:  CMMCDropSource::QueryContinueDrag
 *
 * PURPOSE: implements IDropSource::QueryContinueDrag interface used bu OLE
 *
 * PARAMETERS:
 *    BOOL fEscapePressed   [in] - ESC was pressed
 *    DWORD grfKeyState     [in] - mouse & control button state
 *
 * RETURNS:
 *    HRESULT  - error or  S_OK(continue), DRAGDROP_S_CANCEL(cancel), DRAGDROP_S_DROP(drop)
 *
\***************************************************************************/
STDMETHODIMP CMMCDropSource::QueryContinueDrag( BOOL fEscapePressed,  DWORD grfKeyState )
{
    DECLARE_SC(sc, TEXT("CMMCDropSource::QueryContinueDrag"));

    // 1. quit on cancel
    if (fEscapePressed)
        return (sc = DRAGDROP_S_CANCEL).ToHr();

    // 2. inspect mouse buttons
    DWORD mButtons = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON) );
    if ( mButtons == 0 ) // all released?
        return (sc = DRAGDROP_S_DROP).ToHr();

    // 3. quit also if more than one mouse button is pressed
    if ( mButtons != MK_LBUTTON && mButtons != MK_RBUTTON && mButtons != MK_MBUTTON )
        return (sc = DRAGDROP_S_CANCEL).ToHr();

    // 4. else just continue ...

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropSource::GiveFeedback
 *
 * PURPOSE: Gives feedback for d&d operations
 *
 * PARAMETERS:
 *    DWORD dwEffect
 *
 * RETURNS:
 *    DRAGDROP_S_USEDEFAULTCURSORS
 *
\***************************************************************************/
STDMETHODIMP CMMCDropSource::GiveFeedback( DWORD dwEffect )
{
    // nothing special by now
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropSource::ScDoDragDrop
 *
 * PURPOSE: Performs DragAndDrop operation
 *          This is static method to be used to initiate drag and drop
 *
 * PARAMETERS:
 *    IDataObject *pDataObject [in] data object to copy/move
 *    bool bCopyAllowed        [in] if copy is allowed
 *    bool bMoveAllowed        [in] if move is allowed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropSource::ScDoDragDrop(IDataObject *pDataObject, bool bCopyAllowed, bool bMoveAllowed)
{
    DECLARE_SC(sc, TEXT("CMMCDropSource::ScDoDragDrop"));

    // 1. cocreate com object for OLE
    typedef CComObject<CMMCDropSource> ComCMMCDropSource;
    ComCMMCDropSource *pSource = NULL;
    sc = ComCMMCDropSource::CreateInstance(&pSource);
    if (sc)
        return sc;

    // 2. recheck
    sc = ScCheckPointers(pSource, E_UNEXPECTED);
    if (sc)
    {
        delete pSource;
        return sc;
    }

    // 3. QI for IDropSource interface
    IDropSourcePtr spDropSource = pSource;
    sc = ScCheckPointers(spDropSource, E_UNEXPECTED);
    if (sc)
    {
        delete pSource;
        return sc;
    }

    // 4. perform DragDrop
    DWORD dwEffect = DROPEFFECT_NONE;
    const DWORD dwEffectAvailable = (bCopyAllowed ? DROPEFFECT_COPY : 0)
                                   |(bMoveAllowed ? DROPEFFECT_MOVE : 0);
    sc = DoDragDrop(pDataObject, spDropSource, dwEffectAvailable, &dwEffect);
    if (sc)
        return sc;

    return sc;
}

/*---------------------------------------------------------------------------*\
|                   class CMMCDropTarget methods                              |
\*---------------------------------------------------------------------------*/

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::DragEnter
 *
 * PURPOSE: Invoked by OLE when d&d cursor enters the window for which
 *          this target was registered.
 *
 * PARAMETERS:
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    DWORD grfKeyState         [in] - current key state
 *    POINTL pt                 [in] - current cursor position
 *    DWORD * pdwEffect         [out] - operations supported
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::DragEnter( IDataObject * pDataObject, DWORD grfKeyState,
                                        POINTL pt, DWORD * pdwEffect )
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::DragEnter"));

    // 1. cache for drag over
    m_spDataObject = pDataObject;

    // 2. parameter check
    sc = ScCheckPointers(pDataObject, pdwEffect);
    if (sc)
        return sc.ToHr();

    // 3. let it happen - will do more exact filtering on DragOver
    *pdwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::DragOver
 *
 * PURPOSE: called continuosly while cursor is drgged over the window
 *
 * PARAMETERS:
 *    DWORD grfKeyState         [in] - current key state
 *    POINTL pt                 [in] - current cursor position
 *    DWORD * pdwEffect         [out] - operations supported
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::DragOver( DWORD grfKeyState, POINTL pt, DWORD * pdwEffect )
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::DragOver"));

    // 1. parameter check
    sc = ScCheckPointers(pdwEffect);
    if (sc)
        return sc.ToHr();

    // 2. sanity check
    sc = ScCheckPointers(m_spDataObject, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    bool bCopyByDefault = false; // initially we are to move

    // 3. ask the view to estimate what can be done in this position
    sc = ScDropOnTarget( true /*bHitTestOnly*/, m_spDataObject, pt, bCopyByDefault );
    if ( sc == S_OK )
        *pdwEffect = CalculateEffect( *pdwEffect, grfKeyState, bCopyByDefault );
    else
        *pdwEffect = DROPEFFECT_NONE; // no-op on failure or S_FALSE

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::DragLeave
 *
 * PURPOSE: called when cursor leave the window
 *
 * PARAMETERS:
 *    void
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::DragLeave(void)
{
    DECLARE_SC(sc, TEXT("DragLeave"));

    // 1. release data object
    m_spDataObject = NULL;

    // 2. ask the view to remove hiliting it put on target
    sc = ScRemoveDropTargetHiliting();
    if (sc)
        sc.TraceAndClear();

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::Drop
 *
 * PURPOSE: Called when data is dropped on target
 *
 * PARAMETERS:
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    DWORD grfKeyState         [in] - current key state
 *    POINTL pt                 [in] - current cursor position
 *    DWORD * pdwEffect         [out] - operation performed
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCDropTarget::Drop( IDataObject * pDataObject, DWORD grfKeyState,
                                   POINTL pt, DWORD * pdwEffect  )
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::DragEnter"));

    // 1. release in case we have anything
    m_spDataObject = NULL;

    // 2. parameter check
    sc = ScCheckPointers(pDataObject, pdwEffect);
    if (sc)
        return sc.ToHr();

    // 3. init operation with cached value
    bool bCopyOperation = m_bCopyByDefault;

    // 4. see what operation to perform
    if (m_bRightDrag)
    {
        // 4.1. give user the choice
        DWORD dwSelected = ( m_bCopyByDefault ? DROPEFFECT_COPY : DROPEFFECT_MOVE );
        sc = ScDisplayDropMenu( pt, *pdwEffect, dwSelected );
        if (sc)
            return sc.ToHr();

        *pdwEffect = dwSelected;
    }
    else
    {
        // 4.2. inspect keyboard
        *pdwEffect = CalculateEffect(*pdwEffect, grfKeyState, bCopyOperation);
    }

    // 5. perform
    if (*pdwEffect != DROPEFFECT_NONE) // not canceled yet?
    {
        // now the final decision - copy or move
        bCopyOperation = ( *pdwEffect & DROPEFFECT_COPY );

        // Let it happen. Drop.
        sc = ScDropOnTarget( false /*bHitTestOnly*/, pDataObject, pt, bCopyOperation );
        if ( sc != S_OK )
            *pdwEffect = DROPEFFECT_NONE;
    }

    // 6. remove hiliting. reuse DragLeave (don't care about the results)
    DragLeave();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScDropOnTarget
 *
 * PURPOSE: helper, forwarding calls to the view
 *          Called as a request to hittest / perform drop operation
 *
 * PARAMETERS:
 *    bool bHitTestOnly         [in] - HitTest / drop
 *    IDataObject * pDataObject [in] - data object to copy/move
 *    POINTL pt                 [in] - current cursor position
 *    bool& bCopyOperation      [in/out]
 *                                 [in] -  operation to perform (HitTest == false)
 *                                 [out] - default op. (HitTest == true)
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScDropOnTarget(bool bHitTestOnly, IDataObject * pDataObject, POINTL pt, bool& bCopyOperation)
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScDropOnTarget"));

    // 1. get tied object - view
    CMMCViewDropTarget *pTarget = NULL;
    sc = ScGetTiedObject(pTarget);
    if (sc)
        return sc;

    // 2. recheck
    sc = ScCheckPointers(pTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 3. calculate client coordinates
    CPoint point(pt.x, pt.y);
    ScreenToClient(pTarget->GetWindowHandle(), &point);

    // 4. forward to the view
    sc = pTarget->ScDropOnTarget( bHitTestOnly, pDataObject, point, bCopyOperation );
    if ( sc != S_OK )
        ScRemoveDropTargetHiliting(); // remove hiliting if missed the traget
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScRemoveDropTargetHiliting
 *
 * PURPOSE: helper, forwarding calls to the view
 *          Called to cancel visual effects on target
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScRemoveDropTargetHiliting()
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScRemoveDropTargetHiliting"));

    // `. get tied object - view
    CMMCViewDropTarget *pTarget = NULL;
    sc = ScGetTiedObject(pTarget);
    if (sc)
        return sc;

    sc = ScCheckPointers(pTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 2. forward to the view
    pTarget->RemoveDropTargetHiliting();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScAddMenuString
 *
 * PURPOSE: Helper. Adds resource string to paste context menu
 *
 * PARAMETERS:
 *    CMenu& menu   [in] - menu to modify
 *    DWORD id      [in] - menu command
 *    UINT idString [in] - id of resource string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScAddMenuString(CMenu& menu, DWORD id, UINT idString)
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScAddMenuString"));

    // 1. load the string
    CString strItem;
    bool bOK = LoadString( strItem, idString );
    if ( !bOK )
        return sc = E_FAIL;

    // 2. add to the menu
    bOK = menu.AppendMenu( MF_STRING, id, strItem );
    if ( !bOK )
        return sc = E_FAIL;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::ScDisplayDropMenu
 *
 * PURPOSE: Helper. Displays paste context menu
 *
 * PARAMETERS:
 *    POINTL pt                 [in] - point where the menu should appear
 *    DWORD dwEffectsAvailable  [in] - available commands
 *    DWORD& dwSelected         [in] - selected command
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDropTarget::ScDisplayDropMenu(POINTL pt, DWORD dwEffectsAvailable, DWORD& dwSelected)
{
    DECLARE_SC(sc, TEXT("CMMCDropTarget::ScDisplayDropMenu"));

    CMenu menu;

    // 0. create the menu
    bool bOK = menu.CreatePopupMenu();
    if ( !bOK )
        return sc = E_FAIL;

    // 1. add choice for copy
    if ( dwEffectsAvailable & DROPEFFECT_COPY )
    {
        sc = ScAddMenuString(menu, DROPEFFECT_COPY, IDS_DragDrop_CopyHere);
        if (sc)
            return sc;
    }

    // 2. add choice for move
    if ( dwEffectsAvailable & DROPEFFECT_MOVE )
    {
        sc = ScAddMenuString(menu, DROPEFFECT_MOVE, IDS_DragDrop_MoveHere);
        if (sc)
            return sc;
    }

    // 3. add separator if copy or paste was added
    if ( dwEffectsAvailable & ( DROPEFFECT_COPY | DROPEFFECT_MOVE ) )
    {
        bool bOK = menu.AppendMenu( MF_SEPARATOR );
        if ( !bOK )
            return sc = E_FAIL;
    }

    // 4. always add choice for cancel
    sc = ScAddMenuString(menu, DROPEFFECT_NONE, IDS_DragDrop_Cancel);
    if (sc)
        return sc;

    // 5. set the default item
    if ( dwSelected != DROPEFFECT_NONE )
    {
        bool bOK = menu.SetDefaultItem( dwSelected );
        if ( !bOK )
            return sc = E_FAIL;
    }

    // 6. find the tied object
    CMMCViewDropTarget *pTarget = NULL;
    sc = ScGetTiedObject(pTarget);
    if (sc)
        return sc;

    sc = ScCheckPointers(pTarget, E_UNEXPECTED);
    if (sc)
        return sc;

    // 7. display the menu
    dwSelected = menu.TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
                                     pt.x, pt.y, CWnd::FromHandlePermanent( pTarget->GetWindowHandle() ) );

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDropTarget::CalculateEffect
 *
 * PURPOSE: Helper. calculates drop effect by combining:
 *          a) available operations
 *          b) the default operation
 *          c) keyboard key combination
 *
 * PARAMETERS:
 *    DWORD dwEffectsAvailable [in] available operations
 *    DWORD grfKeyState        [in] keyboard / mouse state
 *    bool  bCopyPreferred      [in] default operation
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
DWORD CMMCDropTarget::CalculateEffect(DWORD dwEffectsAvailable, DWORD grfKeyState, bool bCopyPreferred)
{
    const bool bShiftPressed =   (grfKeyState & MK_SHIFT);
    const bool bControlPressed = (grfKeyState & MK_CONTROL);
    const bool bRightClickDrag  = (grfKeyState & MK_RBUTTON);

    m_bRightDrag = bRightClickDrag;
    m_bCopyByDefault = bCopyPreferred;

    if (!bRightClickDrag) // affected by keyboard only in non-right-drag
    {
        // do nothing if user holds on shift+control
        if ( bShiftPressed && bControlPressed )
            return DROPEFFECT_NONE;

        // modify by user interactive preferences
        if ( bShiftPressed )
        {
            // if user cannot get what he wants to - indicate it
            if ( !(dwEffectsAvailable & DROPEFFECT_MOVE) )
                return DROPEFFECT_NONE;

            bCopyPreferred = false;
        }
        else if ( bControlPressed )
        {
            // if user cannot get what he wants to - indicate it
            if ( !(dwEffectsAvailable & DROPEFFECT_COPY) )
                return DROPEFFECT_NONE;

            bCopyPreferred = true;
        }
    }

    // return preferred, if available
    if ( bCopyPreferred && (dwEffectsAvailable & DROPEFFECT_COPY) )
        return DROPEFFECT_COPY;

    if ( !bCopyPreferred && (dwEffectsAvailable & DROPEFFECT_MOVE) )
        return DROPEFFECT_MOVE;

    // preferred not available - return what is available

    if ( dwEffectsAvailable & DROPEFFECT_COPY )
    {
        m_bCopyByDefault = true;
        return DROPEFFECT_COPY;
    }
    else if ( dwEffectsAvailable & DROPEFFECT_MOVE )
    {
        m_bCopyByDefault = false;
        return DROPEFFECT_MOVE;
    }

    return DROPEFFECT_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\docksite.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       docksite.cpp
//
//--------------------------------------------------------------------------

// DockSite.cpp : implementation file
//

#include "stdafx.h"
#include "amc.h"
#include "DockSite.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "commctrl.h"


/////////////////////////////////////////////////////////////////////////////
// CDockSite

CDockSite::CDockSite() : m_rect(0, 0, 0, 0)
{
    m_pManagedWindows = NULL;
    m_style = DSS_TOP;
    m_bVisible = FALSE;
}

BOOL CDockSite::Create(DSS_STYLE style)
{
    // Not supported
    ASSERT(style != DSS_LEFT && style != DSS__RIGHT);

    m_pManagedWindows = new CList<CDockWindow*, CDockWindow*>;
    m_style = style;

    return TRUE;
}


CDockSite::~CDockSite()
{
    delete m_pManagedWindows;
}

/////////////////////////////////////////////////////////////////////////////
// Operations

BOOL CDockSite::Attach(CDockWindow* pWnd)
{
    ASSERT(pWnd != NULL);
    m_pManagedWindows->AddTail(pWnd);

    return TRUE;
}


BOOL CDockSite::Detach(CDockWindow* pWnd)
{
    ASSERT(pWnd != NULL);
    return TRUE;
}

void CDockSite::Show(BOOL bState)
{
    // insure its 0 or 1
    BOOL b = (bState & 0x1);

    ASSERT(m_pManagedWindows != NULL);

    if (b == m_bVisible || m_pManagedWindows == NULL)
        return ;

    m_bVisible = b;


    POSITION pos;
    CDockWindow* pWindow;

    pos = m_pManagedWindows->GetHeadPosition();

    while(pos)
    {
        pWindow = m_pManagedWindows->GetNext(pos);

        if (pWindow != NULL)
            pWindow->Show(b);
    }
}

void CDockSite::RenderLayout(HDWP& hdwp, CRect& clientRect, CPoint& xyLocation)
{
    // No support for other styles
    ASSERT(m_style == DSS_TOP || m_style == DSS_BOTTOM);
    ASSERT(hdwp != 0);

    CRect siteRect(0,0,0,0);
    CRect controlRect(0,0,0,0);

    CDockWindow* pWindow;

    if (m_bVisible == TRUE)
    {

        POSITION pos;
        pos = m_pManagedWindows->GetHeadPosition();

        // Default point for the DSS_TOP
        int x = 0, y = xyLocation.y;

        while (pos)
        {
            pWindow = m_pManagedWindows->GetNext(pos);

            if ((pWindow != NULL) && pWindow->IsVisible ())
            {
                // Compute the size of the dockwindow rect
                controlRect = pWindow->CalculateSize(clientRect);

                siteRect += controlRect;
                if (m_style == DSS_BOTTOM)
                    y = xyLocation.y - siteRect.Height();

                DeferWindowPos(hdwp, pWindow->m_hWnd, NULL , x, y,
                               clientRect.Width(), controlRect.Height(),
                               SWP_NOZORDER|SWP_NOACTIVATE);

                if (m_style == DSS_TOP)
                    y += siteRect.Height();

            }
        }
    }

    clientRect.bottom -= siteRect.Height();
}

/////////////////////////////////////////////////////////////////////////////
// CDockWindow

IMPLEMENT_DYNAMIC(CDockWindow, CWnd)

CDockWindow::CDockWindow()
{
    m_bVisible = FALSE;
}

CDockWindow::~CDockWindow()
{
}

void CDockWindow::Show(BOOL bState)
{
    bool state = (bState != FALSE);

    if (state != IsVisible())
    {
        SetVisible(state);
        ShowWindow(state ? SW_SHOWNORMAL : SW_HIDE);
    }
}

BEGIN_MESSAGE_MAP(CDockWindow, CWnd)
    //{{AFX_MSG_MAP(CDockWindow)
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

LRESULT CDockWindow::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    ASSERT_VALID(this);

    LRESULT lResult;
    switch (message)
    {
    case WM_NOTIFY:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_DELETEITEM:
    case WM_COMPAREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        // send these messages to the owner if not handled
        if (OnWndMsg(message, wParam, lParam, &lResult))
            return lResult;
        else
            return GetOwner()->SendMessage(message, wParam, lParam);
        break;

    case WM_COMMAND:
        if (OnWndMsg(message, wParam, lParam, &lResult))
            return lResult;
        else
        {
            CRebarDockWindow* pRebar = dynamic_cast<CRebarDockWindow*>(this);
            ASSERT(NULL != pRebar);
            if (pRebar)
            {
                // In case of tool-button click, send this message to
                // the owner (the toolbar).
                return pRebar->GetRebar()->SendMessage(message, wParam, lParam);
            }
            else
            {
                // We want to know when this code is hit. Below is a
                // benign assert for this purpose.
                ASSERT(FALSE);

                // send these messages to the owner if there is no rebar.
                return GetOwner()->SendMessage(message, wParam, lParam);
            }
        }
        break;

    }

    // otherwise, just handle in default way
    lResult = CWnd::WindowProc(message, wParam, lParam);
    return lResult;


}


/////////////////////////////////////////////////////////////////////////////
// CDockWindow message handlers

void CDockWindow::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CWnd::OnShowWindow(bShow, nStatus);

    // keep our visibility flag in sync with the true visibility state of the window
    m_bVisible = bShow;
}


/////////////////////////////////////////////////////////////////////////////
// CStatBar

IMPLEMENT_DYNAMIC(CStatBar, CDockWindow)

CStatBar::CStatBar()
{
    m_nCount = 10;
    m_pPaneInfo = new STATUSBARPANE[10] ;
}

CStatBar::~CStatBar()
{
    delete [] m_pPaneInfo;
}


#define USE_CCS_NORESIZE    0

CRect CStatBar::CalculateSize(CRect maxRect)
{
    // default rect is 0,0 for hidden windows
    CRect rect(0,0,0,0);

    if (IsVisible())
    {
#if USE_CCS_NORESIZE
        CClientDC dc(this);
        CFont* pOldFont = dc.SelectObject(GetFont());
        TEXTMETRIC tm;

        // Compute the height for the status bar based on the font it is using
        // Note: tm.tmInternalLeading is added for spacing
        dc.GetTextMetrics(&tm);
        //rect.SetRect(0, 0,maxRect.Width(), tm.tmHeight+tm.tmInternalLeading);
        rect.SetRect(0, 0,50, tm.tmHeight+tm.tmInternalLeading);
        dc.SelectFont (pOldFont);
#else
        /*
         * Bug 188319: if we let the status bar handle its own sizing
         * (~CCS_NORESIZE), we can just use the client rect here
         */
        GetClientRect (rect);
#endif
    }

    return rect;
};

void CStatBar::GetItemRect(int nIndex, LPRECT lpRect)
{
    SendMessage(SB_GETRECT, (WPARAM)nIndex, (LPARAM)lpRect);
}

void CStatBar::SetPaneStyle(int nIndex, UINT nStyle)
{
    ASSERT(nIndex >=0 && nIndex < m_nCount);
    ASSERT(m_pPaneInfo != NULL);

    m_pPaneInfo[nIndex].m_style = nStyle;
    SendMessage(SB_SETTEXT, (WPARAM)(nIndex | nStyle), (LPARAM)((LPCTSTR)m_pPaneInfo[nIndex].m_paneText));
}

void CStatBar::SetPaneText(int nIndex, LPCTSTR lpszText, BOOL bUpdate)
{
    m_pPaneInfo[nIndex].m_paneText = lpszText;
    SetPaneStyle(nIndex, m_pPaneInfo[nIndex].m_style);

    if (bUpdate == TRUE)
    {
        CRect rect;
        GetItemRect(nIndex, &rect);
        InvalidateRect(rect, TRUE);
    }
}


BEGIN_MESSAGE_MAP(CStatBar, CDockWindow)
    //{{AFX_MSG_MAP(CStatBar)
    ON_WM_SIZE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CStatBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
    ASSERT_VALID(pParentWnd);   // must have a parent


    /*
     * Bug 188319: let the status bar handle its own sizing (~CCS_NORESIZE)
     */
    dwStyle |=  WS_CLIPSIBLINGS
                | CCS_NOPARENTALIGN
                | CCS_NOMOVEY
#if USE_CCS_NORESIZE
                | CCS_NORESIZE
#endif
                | CCS_NODIVIDER;


    // create status window
    CRect rect(0,0,0,0);
    CWnd::Create(STATUSCLASSNAME, _T("Ready"), dwStyle, rect, pParentWnd, nID);

    return TRUE;
}

BOOL CStatBar::CreatePanes(UINT* pIndicatorArray, int nCount)
{
    ASSERT(nCount <= 10);        // Note: No realloc implemented.  If needed, do it.
    UINT array[10] = {0};
    int nTotal = 0;

    CClientDC dc(this);

    // Default to 1 pane the full width of the status bar
    if (pIndicatorArray == NULL)
        m_nCount = 1;

    m_nCount = nCount;


    for (int i = 0; i < m_nCount; i++)
    {
        // Load the string from the resource and determine its width
        CString s;
        CSize sz;

        if (pIndicatorArray[i] != ID_SEPARATOR)
        {
            LoadString(s, pIndicatorArray[i]);
            GetTextExtentPoint32(dc.m_hDC, (LPCTSTR)s, s.GetLength(), &sz);
            m_pPaneInfo[i].m_width = sz.cx+3;
            array[i] = m_pPaneInfo[i].m_width;
            nTotal += array[i];
        }

        // Reset values in-case LoadString fails
        sz.cx = 0;
        s = _T("");
    }

    return SendMessage(SB_SETPARTS, (WPARAM) m_nCount,
        (LPARAM)array);
}

/*
    UpdateAllPanes - Assumes the first pane is the one that is stretchy
    This means only m_pPaneInfo[nCount].m_width == -1 and the rest have
    a 0 or greater width.
*/
void CStatBar::UpdateAllPanes(int clientWidth)
{
    enum
    {
        eBorder_cyHorzBorder,
        eBorder_cxVertBorder,
        eBorder_cxGutter,

        eBorder_Count
    };

    int anBorders[eBorder_Count];
    int anPartWidths[10] = {0};

    ASSERT(m_nCount <= countof(anPartWidths));
    ASSERT(m_nCount > 0);

    // Get the border widths.  anBorders[2] is the border width between rectangles
    SendMessage(SB_GETBORDERS, 0, (LPARAM)anBorders);

    // Starting from right to left
    // The right-most pane is ends at the client width
    int nCount = m_nCount - 1;
    clientWidth -= anBorders[eBorder_cxVertBorder]; // substract vertical border from right side

    anPartWidths[nCount] = clientWidth;
    clientWidth -= m_pPaneInfo[nCount].m_width;
    clientWidth -= anBorders[eBorder_cxGutter]; // substract between pane border

    --nCount;

    for (int i = nCount; i >= 0; i--)
    {
        if (clientWidth >= 0)
            anPartWidths[i] = clientWidth;

        //TRACE(_T("Pane#:%d currentWidth: %d"));
        clientWidth -= m_pPaneInfo[i].m_width;
        clientWidth -= anBorders[eBorder_cxGutter]; // substract between pane border
    }

    SendMessage (SB_SETPARTS, m_nCount, (LPARAM)anPartWidths);
}

/////////////////////////////////////////////////////////////////////////////
// CStatBar message handlers
void CStatBar::OnSize(UINT nType, int cx, int cy)
{
    if (cx > 0)
        UpdateAllPanes(cx);

    CDockWindow::OnSize(nType, cx, cy);
}


/////////////////////////////////////////////////////////////////////////////
// CRebarDockWindow

BEGIN_MESSAGE_MAP(CRebarDockWindow, CDockWindow)
    //{{AFX_MSG_MAP(CRebarDockWindow)
    ON_WM_CREATE()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SIZE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CRebarDockWindow::CRebarDockWindow()
{
    m_bTracking = false;
}

CRebarDockWindow::~CRebarDockWindow()
{
}

BOOL CRebarDockWindow::PreCreateWindow(CREATESTRUCT& cs)
{
     BOOL bSuccess=FALSE;

     // Let default implementation fill in most of the details
    CWnd::PreCreateWindow(cs);

    WNDCLASS wc;
    if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
    {
        // Clear the H and V REDRAW flags
        wc.style        &= ~(CS_HREDRAW | CS_VREDRAW);
        wc.lpszClassName = SIZEABLEREBAR_WINDOW;
        wc.hCursor       = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
        wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
        // Register this new style;
        bSuccess=AfxRegisterClass(&wc);
    }

    // Use the new child frame window class
    cs.lpszClass = SIZEABLEREBAR_WINDOW;

    return bSuccess;
}


BOOL CRebarDockWindow::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{

    ASSERT_VALID(pParentWnd);   // must have a parent

    return CWnd::Create(NULL,NULL,dwStyle, g_rectEmpty, pParentWnd, nID);
}


CRect CRebarDockWindow::CalculateSize(CRect maxRect)
{
    CRect rect(0,0,0,0);

    if (IsVisible())
    {
        rect = m_wndRebar.CalculateSize(maxRect);
        rect.bottom += SIZEABLEREBAR_GUTTER;
    }

    return rect;
}

/////////////////////////////////////////////////////////////////////////////
// CRebarDockWindow message handlers


int CRebarDockWindow::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CDockWindow::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndRebar.Create (NULL, WS_VISIBLE | WS_CHILD | RBS_AUTOSIZE,
                            g_rectEmpty, this, ID_REBAR))
        return (-1);

    return 0;
}

void CRebarDockWindow::UpdateWindowSize(void)
{
    CFrameWnd*  pFrame = GetParentFrame();

    if (pFrame->IsKindOf (RUNTIME_CLASS (CChildFrame)))
        static_cast<CChildFrame*>(pFrame)->RenderDockSites();

    else if (pFrame->IsKindOf (RUNTIME_CLASS (CMainFrame)))
        static_cast<CMainFrame*>(pFrame)->RenderDockSites();
}


void CRebarDockWindow::OnLButtonDown(UINT nFlags, CPoint point)
{
    // set the tracking flag on
    m_bTracking=TRUE;

    // capture the mouse
    SetCapture();
}

void CRebarDockWindow::OnLButtonUp(UINT nFlags, CPoint point)
{
    // set the tracking flag off
    m_bTracking=FALSE;

    // release mouse capture
    ReleaseCapture();
}

void CRebarDockWindow::OnMouseMove(UINT nFlags, CPoint point)
{
    // Reposition Bands
    if (m_bTracking)
        UpdateWindowSize();
    else
        CDockWindow::OnMouseMove(nFlags, point);
}


BOOL CRebarDockWindow::InsertBand(LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    BOOL bReturn=FALSE;

    if (IsWindow(m_wndRebar.m_hWnd))
        bReturn = m_wndRebar.InsertBand(lprbbi);

    return bReturn;
}


LRESULT CRebarDockWindow::SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    ASSERT(lprbbi!=NULL);
    BOOL bReturn=FALSE;

    if (IsWindow(m_wndRebar.m_hWnd))
        bReturn = m_wndRebar.SetBandInfo(uBand, lprbbi);

    return bReturn;
}

void CRebarDockWindow::OnSize(UINT nType, int cx, int cy)
{
    CDockWindow::OnSize(nType, cx, cy);
    m_wndRebar.MoveWindow (0, 0, cx, cy - SIZEABLEREBAR_GUTTER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\docksite.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       docksite.h
//
//--------------------------------------------------------------------------

#ifndef __DOCKSITE_H__
#define __DOCKSITE_H__

#include "controls.h"
// DockSite.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDockSite window

// Forward references
class CDockWindow;
class CDockSite;
class CReBar;

template <class T>
class CDockManager
{
// Construction
public:
    CDockManager();
    ~CDockManager();

//Operations
public:
    // Add a site
    BOOL Attach(T* pSite);
    BOOL Detach(T* pSite);
    void RemoveAll();
    virtual void BeginLayout(int nWindows = 5);
    virtual void EndLayout();
    virtual void RenderDockSites(HWND hView, CRect& clientRect);

protected:
    CList<T*, T*>*   m_pManagedSites;   // Array of View's that have docksite
    HDWP             m_hDWP;            // Handle for BeginDeferWindowPos
};

template <class T>
CDockManager<T>::CDockManager()
{
    m_pManagedSites = new CList<T*, T*>;
    m_hDWP = 0;
}

template <class T>
CDockManager<T>::~CDockManager()
{
    delete m_pManagedSites;
}

template <class T>
BOOL CDockManager<T>::Attach(T* pView)
{
    ASSERT(pView != NULL);
    return (m_pManagedSites->AddTail(pView) != NULL);
}


template <class T>
BOOL CDockManager<T>::Detach(T* pView)
{
    ASSERT(pView != NULL);
    POSITION pos = m_pManagedSites->Find(pView);

    if (pos == NULL)
        return FALSE;

    return m_pManagedSites->RemoveAt(pos);
}

template <class T>
void CDockManager<T>::RemoveAll()
{
    m_pManagedSites->RemoveAll();
}

template <class T>
void CDockManager<T>::BeginLayout(int nWindows)
{
    m_hDWP = ::BeginDeferWindowPos(nWindows);
}

template <class T>
void CDockManager<T>::EndLayout()
{
    ::EndDeferWindowPos(m_hDWP);
    m_hDWP = 0;
}

template <class T>
void CDockManager<T>::RenderDockSites(HWND hView, CRect& clientRect)
{
    ASSERT(m_hDWP != 0);

    T* pDockSite;
    POSITION pos = m_pManagedSites->GetHeadPosition();

    // No sites in to manage
    if (pos == NULL)
        return ;

    // Save a copy of the full client rect
    CRect  savedClient;
    CRect  totalSite(0,0,0,0);
    CPoint point(0, 0);
    
    int yTop = 0;
    int yBottom = clientRect.bottom;

    savedClient.CopyRect(&clientRect);

    while (pos)
    {
        pDockSite = m_pManagedSites->GetNext(pos);

        ASSERT(pDockSite != NULL);

        // Set the y coordinate for the site layout logic
        if (pDockSite->GetStyle() == CDockSite::DSS_TOP)
            point.y = yTop;
        else
            point.y = yBottom;

        pDockSite->RenderLayout(m_hDWP, clientRect, point);

        // totalSite = saveRect - clientRect
        totalSite = savedClient;
        totalSite -= clientRect;

        // Adjust the y coordinate for the next site in the list
        if (pDockSite->GetStyle() == CDockSite::DSS_TOP)
            yTop += totalSite.Height();
        else
            yBottom -= totalSite.Height();

        // client rect before the site adjusts it
        savedClient = clientRect;
    }

    // Position the view window
    ::DeferWindowPos(m_hDWP, hView, NULL, savedClient.left,     // x
                                          savedClient.top+yTop, //y
                                          savedClient.Width(), 
                                          savedClient.Height(), 
                                        SWP_NOZORDER|SWP_NOACTIVATE);
}

class CDockSite
{
// Construction
public:

    enum DSS_STYLE
    {
        DSS_TOP = 0,    // Locate site at the window top
        DSS_BOTTOM,     // Locate site at the window bottom 
        DSS_LEFT,       // Locate site at the window left-side
        DSS__RIGHT,     // 
    };

public:
    CDockSite();

    // Create this site for the parent window pParent and allocate room for 10 CDockWindows.
    BOOL Create(DSS_STYLE style=DSS_TOP);


// Operations
public:

public:
    // Add a window to be docked to this site
    BOOL Attach(CDockWindow* pWnd);

    // Remove a window from the site
    BOOL Detach(CDockWindow* pWnd);

    // Compute all the regions sizes for layout
    bool IsVisible();
    void Toggle();
    DSS_STYLE GetStyle();

    virtual void RenderLayout(HDWP& hdwp, CRect& clientRect, CPoint& xyLocation);
    virtual void Show(BOOL bState = TRUE);

// Attributes
private:
    CList<CDockWindow*, CDockWindow*>*   m_pManagedWindows;  // Array of CDockWindow
    CWnd*                   m_pParentWnd;       // Window that contains the docksite
    DSS_STYLE               m_style;            // Style of the site
    CRect                   m_rect;             // Rectangle for the docksite size
    BOOL                    m_bVisible;         // Docksite visible or hidded

// Implementation
public:
    virtual ~CDockSite();
};

/////////////////////////////////////////////////////////////////////////////
inline CDockSite::DSS_STYLE CDockSite::GetStyle()
{
    return m_style;
}

inline bool CDockSite::IsVisible()
{
    return (m_bVisible != FALSE);
}

inline void CDockSite::Toggle()
{
    Show(!m_bVisible);
}


/////////////////////////////////////////////////////////////////////////////
// CDockWindow window

class CDockWindow : public CWnd
{
    DECLARE_DYNAMIC (CDockWindow)

    enum DWS_STYLE
    {
        DWS_HORIZONTAL, // Place window horizontally within the site
        DWS_VERTICAL,   // Place window vetically within the site
    };

// Construction
public:
    CDockWindow();

// Attributes
public:

// Operations
public:
    // Given the maxRect, determine the toolwindow size and calculate size
    virtual CRect CalculateSize(CRect maxRect) = 0;

    // Top level create to initialize the CDockWindow and control
    virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID) = 0;

    // Make visible/hidden
    virtual void Show(BOOL bState);
    bool IsVisible();
    void SetVisible(BOOL bState);

private:
    BOOL m_bVisible;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDockWindow)
    protected:
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDockWindow();

    // Generated message map functions
protected:
    //{{AFX_MSG(CDockWindow)
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


inline bool CDockWindow::IsVisible()
{
    return (m_bVisible != FALSE);
};

inline void CDockWindow::SetVisible(BOOL bState)
{
    m_bVisible = bState & 0x1;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CStatBar window

struct STATUSBARPANE
{
    // default to sunken text with stretchy width
    STATUSBARPANE() { m_style = 0; m_width = -1; }

    int         m_width;
    UINT        m_style;
    CString     m_paneText;
};

class CStatBar : public CDockWindow
{
    DECLARE_DYNAMIC(CStatBar)

// Construction
public:
    CStatBar();

// Attributes
public:

private:
    int              m_nCount;      // number of panes
    STATUSBARPANE*   m_pPaneInfo;   // array of pane structures, default is 10, no realloc implemented

// Operations
public:
    BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
    CRect CalculateSize(CRect maxRect);    

    void GetItemRect(int nIndex, LPRECT lpRect);
    void SetPaneStyle(int nIndex, UINT nStyle);

    BOOL CreatePanes(UINT* pIndicatorArray=NULL, int nCount=10);
    void SetPaneText(int nIndex, LPCTSTR lpszText, BOOL bUpdate = TRUE);
    void UpdateAllPanes(int clientWidth);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStatBar)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStatBar();

    // Generated message map functions
protected:
    //{{AFX_MSG(CStatBar)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
};


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRebarDockWindow window

#define SIZEABLEREBAR_GUTTER 6
#define SIZEABLEREBAR_WINDOW _T("SizeableRebar")

class CRebarDockWindow : public CDockWindow
{
// Construction
public:
    CRebarDockWindow();

// Attributes
public:

private:
    enum { ID_REBAR = 0x1000 };

    CRebarWnd   m_wndRebar;
    bool        m_bTracking;

// Operations
public:
    BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
    CRect CalculateSize(CRect maxRect);
    void UpdateWindowSize(void);
    BOOL InsertBand(LPREBARBANDINFO lprbbi);
    LRESULT SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);

    CRebarWnd* GetRebar ()
        { return &m_wndRebar; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRebarDockWindow)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRebarDockWindow();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRebarDockWindow)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __DOCKSITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\evtsink.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       evtsink.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "winnls.h"

#include "AMC.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "histlist.h"
#include "exdisp.h" // for the IE dispatch interfaces.
#include "websnk.h"
#include "evtsink.h"
#include "WebCtrl.h"
#include "cstr.h"
#include "constatbar.h"

#ifdef DBG
CTraceTag tagWebEventSink(TEXT("Web View"), TEXT("Web Event Sink"));
#endif // DBG
                                 
CWebEventSink::CWebEventSink()
:   m_bBrowserBackEnabled(false), m_bBrowserForwardEnabled(false), 
    m_pWebViewControl(NULL), m_pStatusBar(NULL), m_pwndProgressCtrl(NULL), 
    m_pHistoryList(NULL)
{
}

SC
CWebEventSink::ScInitialize(CAMCWebViewCtrl *pWebViewControl)
{
    DECLARE_SC(sc, TEXT("CWebEventSink::ScInitialize"));

    sc = ScCheckPointers(pWebViewControl);
    if(sc)
        return sc;

    m_pWebViewControl = pWebViewControl;

    CAMCView* pAMCView         = dynamic_cast<CAMCView*>(pWebViewControl->GetParent());
    CFrameWnd* pwndParentFrame = pWebViewControl->GetParentFrame();

    sc = ScCheckPointers(pAMCView, pwndParentFrame);
    if(sc)
        return sc;

    m_pHistoryList = pAMCView->GetHistoryList();
    sc = ScCheckPointers(m_pHistoryList);
    if(sc)
        return sc;

    // Create the status bar for this instance of the web control
    m_pStatusBar = dynamic_cast<CConsoleStatusBar*>(pwndParentFrame);
    sc = ScCheckPointers(m_pStatusBar, E_UNEXPECTED);
    if(sc)
        return sc;
    
    // find the progress control on the status bar for the parent frame
    CAMCStatusBar* pwndStatusBar =
            reinterpret_cast<CAMCStatusBar*>(pwndParentFrame->GetMessageBar());
    sc = ScCheckPointers(pwndStatusBar);
    if(sc)
        return sc;

    ASSERT_KINDOF (CAMCStatusBar, pwndStatusBar);
    m_pwndProgressCtrl = pwndStatusBar->GetStatusProgressCtrlHwnd();

    m_fLastTextWasEmpty = false;

    return sc;
}

CWebEventSink::~CWebEventSink()
{
    /*
     * clear the status bar text
     */
    if (m_pStatusBar != NULL)
        m_pStatusBar->ScSetStatusText(NULL);
}

void CWebEventSink::SetActiveTo(BOOL /*bState*/)
{
}


STDMETHODIMP_(void) CWebEventSink::BeforeNavigate(BSTR URL, long Flags, BSTR TargetFrameName, VARIANT* PostData,
                    BSTR Headers, VARIANT_BOOL* Cancel)
{
    Trace(tagWebEventSink, TEXT("BeginNavigate(URL:%s, flags:%0X, targetfrm:%s, headers:%s)\n"), URL, Flags, TargetFrameName, Headers);

    bool bPageBreak = IsPageBreak(URL);
    m_pHistoryList->OnPageBreakStateChange(bPageBreak);

    m_pHistoryList->UpdateWebBar (HB_STOP, TRUE);  // turn on "stop" button
}

STDMETHODIMP_(void) CWebEventSink::CommandStateChange(int Command, VARIANT_BOOL Enable)
{
    if(Command == CSC_NAVIGATEFORWARD)
    {
        m_bBrowserForwardEnabled = Enable;
    }
    else if(Command == CSC_NAVIGATEBACK)
    {
        m_bBrowserBackEnabled = Enable;
    }

}

STDMETHODIMP_(void) CWebEventSink::DownloadBegin()
{
    Trace(tagWebEventSink, TEXT("DownloadBegin()"));
}

STDMETHODIMP_(void) CWebEventSink::DownloadComplete()
{
    Trace(tagWebEventSink, TEXT("DownloadComplete()"));
}

STDMETHODIMP_(void) CWebEventSink::FrameBeforeNavigate(BSTR URL, long Flags, BSTR TargetFrameName, VARIANT* PostData,
                    BSTR Headers, VARIANT_BOOL* Cancel)
{
    m_pHistoryList->UpdateWebBar (HB_STOP, TRUE);  // turn on "stop" button
}

STDMETHODIMP_(void) CWebEventSink::FrameNavigateComplete(BSTR URL)
{
}

STDMETHODIMP_(void) CWebEventSink::FrameNewWindow(BSTR URL, long Flags, BSTR TargetFrameName,   VARIANT* PostData,
                    BSTR Headers, VARIANT_BOOL* Processed)
{
}

bool CWebEventSink::IsPageBreak(BSTR URL)
{
    USES_CONVERSION;
    CStr  strURL = OLE2T(URL);
    strURL.MakeLower();

    bool bPageBreak = (_tcsstr(strURL, PAGEBREAK_URL) != NULL);
    return bPageBreak;
}

STDMETHODIMP_(void) CWebEventSink::NavigateComplete(BSTR URL)
{
    Trace(tagWebEventSink, TEXT("NavigateComplete()\n"));

    // Set progress bar position to 0
    m_pwndProgressCtrl->SetPos (0);

    bool bPageBreak = IsPageBreak(URL);
    m_pHistoryList->OnPageBreakStateChange(bPageBreak);

    // send the browser state across AFTER sending the OnPageBreakStateChange and BEFORE
    // the OnPageBreak.
    m_pHistoryList->OnBrowserStateChange(m_bBrowserForwardEnabled, m_bBrowserBackEnabled);

    if(bPageBreak)
    {
       // Extract the Page Break ID. Since bPageBreak is true, the URL
       // is guaranteed to be prefixed with PAGEBREAK_URL
       USES_CONVERSION;
       LPCTSTR szPageBreakID = OLE2CT(URL) + _tcslen(PAGEBREAK_URL);
       int nPageBreakID = _tstoi(szPageBreakID);

       //PageBreakIDs start with 1; _tstoi returns 0 if it can't convert
       ASSERT(nPageBreakID != 0);

       m_pHistoryList->ScOnPageBreak(nPageBreakID);
    }
}

STDMETHODIMP_(void) CWebEventSink::NewWindow(BSTR URL, long Flags, BSTR TargetFrameName,
                VARIANT* PostData, BSTR Headers, BSTR Referrer)
{
}

STDMETHODIMP_(void) CWebEventSink::Progress(long Progress, long ProgressMax)
{
    Trace(tagWebEventSink, TEXT("Progress(Progress:%ld ProgressMax:%ld)\n"), Progress, ProgressMax);

    // display progress only if the web view is visible.
    if(m_pWebViewControl && m_pWebViewControl->IsWindowVisible())
    {
        m_pwndProgressCtrl->SetRange (0, ProgressMax);
        m_pwndProgressCtrl->SetPos (Progress);
    }


    // maintain "stop" button
    m_pHistoryList->UpdateWebBar (HB_STOP, ProgressMax != 0);
}

STDMETHODIMP_(void) CWebEventSink::PropertyChange(BSTR szProperty)
{
}

STDMETHODIMP_(void) CWebEventSink::Quit(VARIANT_BOOL* pCancel)
{
    Trace(tagWebEventSink, TEXT("Quit()"));
}

STDMETHODIMP_(void) CWebEventSink::StatusTextChange(BSTR bstrText)
{
    // display progress only if the web view is visible.
    if(m_pWebViewControl && m_pWebViewControl->IsWindowVisible())
    {
        bool fThisTextIsEmpty = ((bstrText == NULL) || (bstrText[0] == 0));

        if (m_fLastTextWasEmpty && fThisTextIsEmpty)
            return;

        m_fLastTextWasEmpty = fThisTextIsEmpty;

        Trace(tagWebEventSink, TEXT("StatusTextChange(%s)"), bstrText);

        USES_CONVERSION;
        m_pStatusBar->ScSetStatusText(W2T( bstrText));
    }
}

STDMETHODIMP_(void) CWebEventSink::TitleChange(BSTR Text)
{
    Trace(tagWebEventSink, TEXT("TitleChange(%s)"), Text);
}

STDMETHODIMP_(void) CWebEventSink::WindowActivate()
{
}

STDMETHODIMP_(void) CWebEventSink::WindowMove()
{
}

STDMETHODIMP_(void) CWebEventSink::WindowResize()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\favorite.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favorite.cpp
//
//--------------------------------------------------------------------------

// favorite.cpp

#include "stdafx.h"
#include "amcdoc.h"
#include "favorite.h"
#include "favui.h"


//############################################################################
//############################################################################
//
//  Implementation of class CFavObject
//
//############################################################################
//############################################################################

CFavObject::CFavObject(bool bIsGroup)
: m_pFavParent(NULL), m_pFavNext(NULL), m_pFavChild(NULL), m_bIsGroup(bIsGroup), m_strName(_T("")),
  m_strPath(_T(""))
{
}

CFavObject::~CFavObject()
{
    // delete siblings iteratively
    CFavObject* pFavSib = GetNext();
    while(pFavSib)
    {
        CFavObject* pFavNext = pFavSib->GetNext();
        pFavSib->SetNext(NULL);

        delete pFavSib;
        pFavSib = pFavNext;
    }

    // delete children recursively
    if (GetChild())
        delete GetChild();
}


int
CFavObject::GetImage()
{
    return ( IsGroup() ? eStockImage_Folder : eStockImage_Favorite);
}

int
CFavObject::GetOpenImage()
{
    return ( IsGroup() ? eStockImage_OpenFolder: eStockImage_Favorite);
}



DWORD
CFavObject::GetChildCount()
{
    ASSERT(IsGroup());
    DWORD dwCount = 0;
    CFavObject *pObject = m_pFavChild;

    while(pObject != NULL)
    {
        dwCount++;
        pObject = pObject->GetNext();
    }

    return dwCount;
}

void CFavObject::AddChild(CFavObject* pFavNew, CFavObject* pFavPrev)
{
    ASSERT(IsGroup());
    ASSERT(pFavNew != NULL);

    // if adding to end, locate last child
    if (pFavPrev == LAST_FAVORITE)
    {
        pFavPrev = GetChild();
        if (pFavPrev != NULL)
            while (pFavPrev->GetNext()) pFavPrev = pFavPrev->GetNext();
    }

    // if no previous object
    if (pFavPrev == NULL)
    {
        // add as first child
        pFavNew->SetNext(GetChild());
        SetChild(pFavNew);
    }
    else
    {
        // add after previous
        pFavNew->SetNext(pFavPrev->GetNext());
        pFavPrev->SetNext(pFavNew);
    }

    // always set self as parent
    pFavNew->SetParent(this);
}

void CFavObject::RemoveChild(CFavObject* pFavDelete)
{
    ASSERT(pFavDelete != NULL);
    ASSERT(pFavDelete->GetParent() == this);

    if (GetChild() == pFavDelete)
    {
        SetChild(pFavDelete->GetNext());
    }
    else
    {
        CFavObject* pFavPrev = GetChild();
        while(pFavPrev != NULL && pFavPrev->GetNext() != pFavDelete)
            pFavPrev = pFavPrev->GetNext();

        ASSERT(pFavPrev != NULL);
        pFavPrev->SetNext(pFavDelete->GetNext());
    }

    pFavDelete->SetNext(NULL);
}

void CFavObject::SetPath(LPCTSTR pszPath)
{
    // Drop first part of path (because it is always the console root)
    // unless the shortcut is to the root itself
    TCHAR* pSep = _tcschr(pszPath, _T('\\'));
    m_strPath = (pSep != NULL) ? CharNext(pSep) : pszPath;
}


HRESULT
CFavObject::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (nVersion == 1)
    {
        try
        {
            stm >> m_bIsGroup;
            stm >> m_strName;

            if(IsGroup())
            {
                DWORD cChildren = 0;
                stm >> cChildren;

                for(int i = 0; i< cChildren; i++)
                {
                    CFavObject *pObject = new CFavObject(true);   // the true parameter gets overwritten.
                    hr = pObject->ReadSerialObject(stm, nVersion);
                    if(FAILED(hr))
                    {
                        delete pObject;
                        pObject = NULL;
                        return hr;
                    }

                    AddChild(pObject);
                }

                hr = S_OK;
            }
            else // is an item
            {
                hr = m_memento.Read(stm);
                stm >> m_strPath;
            }
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return hr;
}


//############################################################################
//############################################################################
//
//  Implementation of class CFavorites
//
//############################################################################
//############################################################################
CFavorites::CFavorites() : m_pFavRoot(NULL)
{
    // create root group
    CString strName;
    LoadString(strName, IDS_FAVORITES);

    m_pFavRoot = new CFavObject(true /*bIsGroup*/);
    m_pFavRoot->m_strName = strName;
}


CFavorites::~CFavorites()
{
    // delete the entire tree
    if (m_pFavRoot != NULL)
        delete m_pFavRoot;
}


/////////////////////////////////////////////////////////
// CTreeSource methods

TREEITEMID CFavorites::GetRootItem()
{
    return TIDFromFavObj(m_pFavRoot);
}


TREEITEMID CFavorites::GetParentItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return TIDFromFavObj(pFav->GetParent());
}


TREEITEMID CFavorites::GetChildItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);
    return TIDFromFavObj(pFav->GetChild());
}


TREEITEMID CFavorites::GetNextSiblingItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return TIDFromFavObj(pFav->GetNext());
}


LPARAM CFavorites::GetItemParam(TREEITEMID tid)
{
    return 0;
}

void CFavorites::GetItemName(TREEITEMID tid, LPTSTR pszName, int cchMaxName)
{
    DECLARE_SC(sc, TEXT("CFavorites::GetItemName"));
    sc = ScCheckPointers(pszName);
    if (sc)
        return;

    CFavObject* pFav = FavObjFromTID(tid);

    sc = StringCchCopy(pszName, cchMaxName, pFav->GetName());
    if (sc)
        return;
}

void CFavorites::GetItemPath(TREEITEMID tid, LPTSTR pszPath, int cchMaxPath)
{
    DECLARE_SC(sc, TEXT("CFavorites::GetItemPath"));
    sc = ScCheckPointers(pszPath);
    if (sc)
        return;

    CFavObject* pFav = FavObjFromTID(tid);

    sc = StringCchCopy(pszPath, cchMaxPath, pFav->GetPath());
    if (sc)
        return;
}

int CFavorites::GetItemImage(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return pFav->GetImage();
}

int CFavorites::GetItemOpenImage(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return pFav->GetOpenImage();
}



BOOL CFavorites::IsFolderItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    return pFav->IsGroup();
}


///////////////////////////////////////////////////////////////////////////
// CFavorites methods

HRESULT CFavorites::AddFavorite(TREEITEMID tidParent, LPCTSTR strName,
                                CFavObject** ppFavRet)
{
    ASSERT(tidParent != NULL && strName != NULL);
    ASSERT(FavObjFromTID(tidParent)->IsGroup());

    CFavObject* pFavParent = reinterpret_cast<CFavObject*>(tidParent);

    // Create a favorite item
    CFavObject* pFavItem = new CFavObject(false /*bIsGroup*/);
    if (pFavItem == NULL)
        return E_OUTOFMEMORY;

    pFavItem->m_strName = strName;

    // Add to end of group
    pFavParent->AddChild(pFavItem);

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemAdded(TIDFromFavObj(pFavItem));
    }

    if (ppFavRet)
        *ppFavRet = pFavItem;

    return S_OK;
}


HRESULT CFavorites::AddGroup(TREEITEMID tidParent, LPCTSTR strName, CFavObject** ppFavRet)
{
    ASSERT(tidParent != NULL && strName != NULL);
    ASSERT(FavObjFromTID(tidParent)->IsGroup());

    CFavObject* pFavParent = reinterpret_cast<CFavObject*>(tidParent);

    CFavObject* pFavGrp = new CFavObject(true /*bIsGroup*/);
    if (pFavGrp == NULL)
        return E_OUTOFMEMORY;

    pFavGrp->m_strName = strName;

    pFavParent->AddChild(pFavGrp);

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemAdded(TIDFromFavObj(pFavGrp));
    }

    if (ppFavRet)
        *ppFavRet = pFavGrp;

    return S_OK;
}


HRESULT CFavorites::DeleteItem(TREEITEMID tid)
{
    CFavObject* pFav = FavObjFromTID(tid);

    CFavObject* pFavParent = pFav->GetParent();

    if (pFavParent)
        pFavParent->RemoveChild(pFav);
    else
        m_pFavRoot = NULL;

    delete pFav;

    // Notify all observers of deletion
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemRemoved((TREEITEMID)pFavParent, tid);
    }

    return S_OK;
}

HRESULT CFavorites::MoveItem(TREEITEMID tid, TREEITEMID tidNewGroup, TREEITEMID tidPrev)
{
    CFavObject* pFav = FavObjFromTID(tid);
    CFavObject* pFavPrev = FavObjFromTID(tidPrev);

    ASSERT(FavObjFromTID(tidNewGroup)->IsGroup());
    CFavObject* pFavNewGroup = reinterpret_cast<CFavObject*>(tidNewGroup);

    // Verify not moving item into itself or under itself
    CFavObject* pFavTemp = pFavNewGroup;
    while (pFavTemp != NULL)
    {
        if (pFavTemp == pFav)
            return E_FAIL;
        pFavTemp = pFavTemp->GetParent();
    }

    // Remove object from current group
    CFavObject* pFavParent = pFav->GetParent();
    ASSERT(pFavParent != NULL);
    pFavParent->RemoveChild(pFav);

    // Notify all observers of removal
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemRemoved((TREEITEMID)pFavParent, tid);
    }

    // Insert item into the new group
    pFavNewGroup->AddChild(pFav, pFavPrev);

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter1)
    {
        (*iter1)->ItemAdded(tid);
    }

    return S_OK;
}


HRESULT CFavorites::SetItemName(TREEITEMID tid, LPCTSTR pszName)
{
    CFavObject* pFav = FavObjFromTID(tid);
    ASSERT(pszName != NULL && pszName[0] != 0);

    // Change item name
    pFav->m_strName = pszName;

    // Notify all observers of change
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemChanged(tid, TIA_NAME);
    }

    return S_OK;
}


HRESULT CFavorites::AddToFavorites(LPCTSTR szName, LPCTSTR szPath, CMemento &memento, CWnd* pwndHost)
{
	DECLARE_SC (sc, _T("CFavorites::AddToFavorites"));
    CAddFavDialog dlg(szName, this, pwndHost);

    CFavObject* pFavItem = NULL;
    sc = dlg.CreateFavorite(&pFavItem);

    // Note: S_FALSE is returned if user cancels dialog
	if (sc.ToHr() != S_OK)
		return (sc.ToHr());

	sc = ScCheckPointers (pFavItem, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    pFavItem->SetPath(szPath);
    pFavItem->SetMemento(memento);

    return S_OK;
}

CImageList* CFavorites::GetImageList()
{
    if (m_ImageList != NULL)
        return CImageList::FromHandle (m_ImageList);

    do
    {
        BOOL bStat = m_ImageList.Create(16, 16, ILC_COLORDDB | ILC_MASK, 20, 10);
        if (!bStat)
            break;

        CBitmap bmap;
        bStat = bmap.LoadBitmap(IDB_AMC_NODES16);
        if (!bStat)
            break;

        int ipos = m_ImageList.Add(bmap, RGB(255,0,255));
        if (ipos == -1)
            break;
    }
    while (0);

	return CImageList::FromHandle (m_ImageList);
}


HRESULT CFavorites::OrganizeFavorites(CWnd* pwndHost)
{
    COrganizeFavDialog dlg(this, pwndHost);
    dlg.DoModal();

    return S_OK;
}


HRESULT
CFavorites::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr =  m_pFavRoot->ReadSerialObject(stm, nVersion);
    if(FAILED(hr))
        return hr;

    // Notify all observers of addition
    FOR_EACH_OBSERVER(CTreeObserver, iter)
    {
        (*iter)->ItemRemoved(NULL, TIDFromFavObj(m_pFavRoot));
        (*iter)->ItemAdded(TIDFromFavObj(m_pFavRoot));
    }

    return hr;
}

bool
CFavorites::IsEmpty()
{
    // the list is empty if the root has no children.
    return (m_pFavRoot->GetChild()==NULL);
}

/*****************************************************************\
|  METHOD: CFavorites::Persist
|  DESCR:  Persists favorites, by delegating to root item
\*****************************************************************/
void
CFavorites::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CFavorites::Persist"));

    sc = ScCheckPointers(m_pFavRoot, E_POINTER);
    if (sc)
        sc.Throw();

    persistor.Persist(*m_pFavRoot);
}

/*****************************************************************\
|  METHOD: CFavoriteXMLList::PersistItself
|  DESCR:  "soft" version of Persist - ignores missing element
|  RETURN: true == element exists and persistence succeeded
\*****************************************************************/
bool
CFavoriteXMLList::PersistItself(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CFavoriteXMLList::PersistItself"));

    if (persistor.IsLoading())
    {
        if (!persistor.HasElement(GetXMLType(), NULL))
            return false;
    }

    persistor.Persist(*this);
    return true;
}

/*****************************************************************\
|  METHOD: CFavoriteXMLList::Persist
|  DESCR:  Perists collection (linked list) contents
\*****************************************************************/
void
CFavoriteXMLList::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
    {
        for (CFavObject *pObj = m_rpRoot; pObj; pObj = pObj->GetNext())
        {
            persistor.Persist(*pObj);
        }
    }
    else
    {
        ASSERT(m_rpRoot == NULL); // this is to upload new entries only!!!
        m_rpRoot = NULL;
        XMLListCollectionBase::Persist(persistor);
    }
}

/*****************************************************************\
|  METHOD: CFavoriteXMLList::OnNewElement
|  DESCR:  called for every new element when loading
\*****************************************************************/
void
CFavoriteXMLList::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CFavoriteXMLList::OnNewElement"));

    CFavObject **pObj = &m_rpRoot;
    while (*pObj)
        pObj = &(*pObj)->m_pFavNext;

    CFavObject *pNewObj = new CFavObject(false);
    *pObj = pNewObj;

    sc = ScCheckPointers(pNewObj, E_OUTOFMEMORY);
    if (sc)
        sc.Throw();

    pNewObj->SetParent(m_Parent);
    persistor.Persist(*pNewObj);
}

/*****************************************************************\
|  METHOD: CFavObject::Persist
|  DESCR:  Persists Favorites item.
\*****************************************************************/
void
CFavObject::Persist(CPersistor &persistor)
{
    persistor.PersistString(XML_ATTR_NAME, m_strName);
    // persist the type of favorite
    CStr strType(IsGroup() ? XML_VAL_FAVORITE_GROUP : XML_VAL_FAVORITE_SINGLE);
    persistor.PersistAttribute(XML_ATTR_FAVORITE_TYPE, strType);
    m_bIsGroup = (0 == strType.CompareNoCase(XML_VAL_FAVORITE_GROUP));

    // its either group or memento.
    if (IsGroup())
    {
        CFavoriteXMLList children(m_pFavChild, this);
        children.PersistItself(persistor);
    }
    else // if (!IsGroup())
    {
        persistor.Persist(m_memento);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\evtsink.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       evtsink.h
//
//--------------------------------------------------------------------------

#ifndef _EVT_SINK_H
#define _EVT_SINK_H

class CAMCStatusBarText;
class CHistoryList;
class CAMCWebViewCtrl;
class CAMCProgressCtrl;

/*+-------------------------------------------------------------------------*
 * class CWebEventSink
 * 
 *
 * PURPOSE: Receives notifications from a web browser. There is only one
 *          place where a CWebEventSink object is created - within CWebCtrl
 *          ::Create.
 *
 *          The notifications received by this object can be used to activate
 *          other events and states.
 *+-------------------------------------------------------------------------*/
class CWebEventSink : 
    public IDispatchImpl<IWebSink, &IID_IWebSink, &LIBID_MMCInternalWebOcx>,
    public CComObjectRoot
{
public:
    CWebEventSink();
   ~CWebEventSink();
   SC ScInitialize(CAMCWebViewCtrl *pWebViewControl);

   BEGIN_COM_MAP(CWebEventSink)
       COM_INTERFACE_ENTRY(IDispatch)
       COM_INTERFACE_ENTRY(IWebSink)
   END_COM_MAP()

   DECLARE_NOT_AGGREGATABLE(CWebEventSink)

    // DWebBrowserEvents methods
public:
    STDMETHOD_(void, BeforeNavigate)(BSTR URL, long Flags,
           BSTR TargetFrameName, VARIANT* PostData,
           BSTR Headers, VARIANT_BOOL* Cancel);

    STDMETHOD_(void, CommandStateChange)(int Command, VARIANT_BOOL Enable);
    STDMETHOD_(void, DownloadBegin)();
    STDMETHOD_(void, DownloadComplete)();
    STDMETHOD_(void, FrameBeforeNavigate)(BSTR URL, long Flags,
           BSTR TargetFrameName, VARIANT* PostData,
           BSTR Headers, VARIANT_BOOL* Cancel);


    STDMETHOD_(void, FrameNavigateComplete)(BSTR URL);
    STDMETHOD_(void, FrameNewWindow)(BSTR URL, long Flags, BSTR TargetFrameName,
            VARIANT* PostData, BSTR Headers, VARIANT_BOOL* Processed);

    STDMETHOD_(void, NavigateComplete)(BSTR URL);
    STDMETHOD_(void, NewWindow)(BSTR URL, long Flags, BSTR TargetFrameName,
                        VARIANT* PostData, BSTR Headers, BSTR Referrer);

    STDMETHOD_(void, Progress)(long Progress, long ProgressMax);
    STDMETHOD_(void, PropertyChange)(BSTR szProperty);
    STDMETHOD_(void, Quit)(VARIANT_BOOL* pCancel);

    STDMETHOD_(void, StatusTextChange)(BSTR bstrText);
    STDMETHOD_(void, TitleChange)(BSTR Text);
    STDMETHOD_(void, WindowActivate)();
    STDMETHOD_(void, WindowMove)();
    STDMETHOD_(void, WindowResize)();

private:
    bool IsPageBreak(BSTR URL);

// Window activation helper
public:
    void SetActiveTo(BOOL bState);

// Attributes
private:
    CAMCWebViewCtrl  *  m_pWebViewControl;

// Status bar members
    CConsoleStatusBar*  m_pStatusBar;
    CAMCProgressCtrl*   m_pwndProgressCtrl;
    CHistoryList*       m_pHistoryList;
    bool                m_fLastTextWasEmpty;
    bool                m_bBrowserForwardEnabled;
    bool                m_bBrowserBackEnabled;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\favorite.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favorite.h
//
//--------------------------------------------------------------------------

// favorite.h

#ifndef _FAVORITE_H_
#define _FAVORITE_H_

#include "treeobsv.h"
#include "tstring.h"
#include "imageid.h"

/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include "atlapp.h"
#include "atlctrls.h"

class CFavorites;
class CFavObject;
class CMemento;

// Extra spacing for favorite tree views
#define FAVVIEW_ITEM_SPACING 4

#define LAST_FAVORITE ((CFavObject*)TREEID_LAST)

//
// CFavObject - class for favorite groups and items.
//
class CFavObject : public CXMLObject
{
    friend CFavorites;

private:
    CFavObject(bool bIsGroup);
    ~CFavObject();

public:

    LPCTSTR GetName() { return m_strName.data(); }

    CFavObject* GetParent() { return m_pFavParent; }
    CFavObject* GetNext()   { return m_pFavNext; }
    CFavObject* GetChild()  { return m_pFavChild;}

    BOOL    IsGroup()       {return m_bIsGroup;}
    DWORD   GetChildCount();
    int     GetImage();
    int     GetOpenImage();

    void    AddChild(CFavObject* pFav, CFavObject* pFavPrev = LAST_FAVORITE);
    void    RemoveChild(CFavObject* pFavRemove);

	CMemento* GetMemento()             {return &m_memento; }
	void SetMemento(CMemento &memento) {m_memento = memento; }

    LPCTSTR GetPath()            { return m_strPath.data(); }
    void SetPath(LPCTSTR szPath);

protected:
    void    SetNext  (CFavObject* pFav) { m_pFavNext = pFav; }
    void    SetChild (CFavObject* pFav) { m_pFavChild = pFav; }
    void    SetParent(CFavObject* pFav) { m_pFavParent = pFav; }

    CFavObject* m_pFavParent;
    CFavObject* m_pFavNext;
    CFavObject* m_pFavChild;

public:
    // pseudo-CSerialObject methods. The real version number is saved with the containing object, for efficiency.
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);

    DEFINE_XML_TYPE(XML_TAG_FAVORITES_ENTRY);
    virtual void    Persist(CPersistor &persistor);
    friend class CFavoriteXMLList;
    // these are persisted
protected:
    bool                m_bIsGroup;
    CStringTableString  m_strName;
    CStringTableString  m_strPath;
    CMemento            m_memento;
};

/*****************************************************************\
|  CLASS: CFavoriteXMLList
|  DESCR: implements persisting of linked list as a collection
\*****************************************************************/
class CFavoriteXMLList : public XMLListCollectionBase
{
    CFavObject * &m_rpRoot;
    CFavObject * m_Parent;
public:
    CFavoriteXMLList(CFavObject * &rpRoot, CFavObject *Parent) : m_rpRoot(rpRoot), m_Parent(Parent) {}
    // PersistItself should be called instead of CPersistor's Persist method
    // implements "softer" loading algorythm
    bool    PersistItself(CPersistor& persistor);
protected:
    virtual void Persist(CPersistor& persistor);
    virtual void OnNewElement(CPersistor& persistor);
    DEFINE_XML_TYPE(XML_TAG_FAVORITES_LIST);
};

class CFavorites : public CTreeSource,
                   public EventSourceImpl<CTreeObserver>,
                   public CSerialObject,
                   public CXMLObject
{
public:

    CFavorites();
    ~CFavorites();

    // CTreeSource methods
    STDMETHOD_(TREEITEMID, GetRootItem)     ();
    STDMETHOD_(TREEITEMID, GetParentItem)   (TREEITEMID tid);
    STDMETHOD_(TREEITEMID, GetChildItem)    (TREEITEMID tid);
    STDMETHOD_(TREEITEMID, GetNextSiblingItem) (TREEITEMID tid);

    STDMETHOD_(LPARAM,  GetItemParam)   (TREEITEMID tid);
    STDMETHOD_(void,    GetItemName)    (TREEITEMID tid, LPTSTR pszName, int cchMaxName);
    STDMETHOD_(void,    GetItemPath)    (TREEITEMID tid, LPTSTR pszPath, int cchMaxName);
    STDMETHOD_(int,     GetItemImage)   (TREEITEMID tid);
    STDMETHOD_(int,     GetItemOpenImage) (TREEITEMID tid);
    STDMETHOD_(BOOL,    IsFolderItem)   (TREEITEMID tid);

    // CFavorites methods
	HRESULT AddToFavorites(LPCTSTR szName, LPCTSTR szPath, CMemento &memento, CWnd* pwndHost);
    HRESULT OrganizeFavorites(CWnd* pwndHost);

    HRESULT AddFavorite(TREEITEMID tidParent, LPCTSTR strName, CFavObject** ppFavRet = NULL);
	HRESULT AddGroup   (TREEITEMID tidParent, LPCTSTR strName, CFavObject** ppFavRet = NULL);
    HRESULT DeleteItem (TREEITEMID tidRemove);
    HRESULT MoveItem   (TREEITEMID tid, TREEITEMID tidNewParent, TREEITEMID tidPrev);
    HRESULT SetItemName(TREEITEMID tid, LPCTSTR pszName);
    HRESULT GetMemento (TREEITEMID tid, CMemento* pmemento);

    CFavObject* FavObjFromTID(TREEITEMID tid) { return reinterpret_cast<CFavObject*>(tid); }
    TREEITEMID TIDFromFavObj(CFavObject* pFav) { return reinterpret_cast<TREEITEMID>(pFav); }

    bool    IsEmpty();

    CImageList* GetImageList();

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);

    DEFINE_XML_TYPE(XML_TAG_FAVORITES_LIST);
    virtual void    Persist(CPersistor &persistor);
private:

	/*
	 * Theming: use WTL::CImageList instead of MFC's CImageList so we can
	 * insure a theme-correct imagelist will be created.
	 */
    WTL::CImageList m_ImageList;

    // these get persisted
private:
    CFavObject* m_pFavRoot;
};

#endif //_FAVORITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\favui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favui.h
//
//--------------------------------------------------------------------------

// favui.h - favorites UI header

#ifndef _FAVUI_H_
#define _FAVUI_H_

#include "trobimpl.h"
#include "mmcres.h"

class CAddFavDialog : public CDialog
{
public:
    enum { IDD = IDD_ADDFAVORITE };

    CAddFavDialog(LPCTSTR szName, CFavorites* pFavorites, CWnd* pParent = NULL);
    ~CAddFavDialog();

    HRESULT CreateFavorite(CFavObject** ppfavRet);

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();

    afx_msg void OnAddFolder();
    afx_msg void OnChangeName();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_ADDFAVORITE);

    DECLARE_MESSAGE_MAP()

    CTreeObserverTreeImpl m_FavTree;
    CEdit           m_FavName;
    CFavorites*     m_pFavorites;
    LONG_PTR        m_lAdviseCookie;
    HRESULT         m_hr;
    CFavObject*     m_pfavItem;
    CString         m_strName;
};


class CAddFavGroupDialog : public CDialog
{
public:
    enum { IDD = IDD_NEWFAVFOLDER };

    CAddFavGroupDialog(CWnd* pParent);
    ~CAddFavGroupDialog();

    LPCTSTR GetGroupName() { return m_strName; }

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_NEWFAVFOLDER);

    DECLARE_MESSAGE_MAP()
    afx_msg void OnChangeName();

    CEdit   m_GrpName;
    TCHAR   m_strName[MAX_PATH];
};


class COrganizeFavDialog : public CDialog
{
public:
    enum { IDD = IDD_FAVORGANIZE };

    COrganizeFavDialog(CFavorites* pFavorites, CWnd* pParent = NULL);
    ~COrganizeFavDialog();

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();

    afx_msg void OnAddFolder();
    afx_msg void OnDelete();
    afx_msg void OnRename();
    afx_msg void OnMoveTo();
    afx_msg void OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult);
    afx_msg void OnBeginLabelEdit(NMHDR* pMNHDR, LRESULT* plResult);
    afx_msg void OnEndLabelEdit(NMHDR* pMNHDR, LRESULT* plResult);

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_FAVORGANIZE);

    DECLARE_MESSAGE_MAP()

    CTreeObserverTreeImpl m_FavTree;
    CStatic         m_FavName;
    CStatic         m_FavInfo;
    CFont           m_FontBold;
    CFavorites*     m_pFavorites;
    LONG_PTR        m_lAdviseCookie;
    BOOL            m_bRenameMode;
    TREEITEMID      m_tidRenameItem;
};


class CFavFolderDialog : public CDialog
{
public:
    enum { IDD = IDD_FAVSELECTFOLDER };

    CFavFolderDialog(CFavorites* pFavorites, CWnd* pParent);
    ~CFavFolderDialog();

    TREEITEMID GetFolderID() { return m_tidFolder; }

protected:
    // method overrides
    virtual BOOL OnInitDialog();
    virtual void OnOK();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_FAVSELECTFOLDER);

    DECLARE_MESSAGE_MAP()

    CTreeObserverTreeImpl m_FavTree;
    TREEITEMID      m_tidFolder;
    CFavorites*     m_pFavorites;
    LONG_PTR        m_lAdviseCookie;
};


// Container for CTreeObserverTreeImpl control which makes it a favorites
// tree viewer control. This class attaches the tree control to the
// favorites data source and handles all the necessart notifications from
// the tree control. It sends a MMC message to its parent whenever the tree
// selection changes.
// The primary purpose for this class is to provide a self-contained favorites
// viewer that the node manager can use in a non-MFC dialog.
class CFavTreeCtrl : public CWnd
{
private:
    /*
     * Make the ctor private so it's only accessible to CreateInstace.
     * That way, we can insure that instances of this class can only
     * be created in well-known ways (i.e. on the heap).  Using this
     * technique means that this class can't be used as a base class
     * or member of another class, but we can live with those restrictions.
     *
     * We need to go to this trouble because this class is used (only)
     * on the nodemgr side of things, in the Task Wizard.  It refers to
     * it only by handle (see CAMCView::ScCreateFavoriteObserver), and has
     * no access to this class, so it can't delete it.  If we make the
     * class self-deleting, everything's copasetic.
     */
    CFavTreeCtrl() {}

public:
    static CFavTreeCtrl* CreateInstance()
        { return (new CFavTreeCtrl); }

    SC ScInitialize(CFavorites* pFavorites, DWORD dwStyles);

    DECLARE_MESSAGE_MAP()

    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult);

    virtual void PostNcDestroy();

private:
    enum {IDC_FAVTREECTRL = 1000};

    CTreeObserverTreeImpl m_FavTree;
};


#endif // _FAVUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\favui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       favui.cpp
//
//--------------------------------------------------------------------------

// favui.cpp - favorites tree configuration UI

#include "stdafx.h"
#include "amcdoc.h"
#include "favorite.h"
#include "favui.h"
#include "amcmsgid.h"
#include "amcview.h"
#include "mmcres.h"

void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable);

BEGIN_MESSAGE_MAP(CAddFavDialog, CDialog)
    //{{AFX_MSG_MAP(CAddFavDialog)
    ON_COMMAND(IDC_ADDFAVFOLDER, OnAddFolder)
    ON_EN_CHANGE(IDC_FAVNAME, OnChangeName)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()


CAddFavDialog::CAddFavDialog(LPCTSTR szName, CFavorites* pFavorites, CWnd* pParent)
   : CDialog(CAddFavDialog::IDD, pParent),
     m_pFavorites(pFavorites), m_lAdviseCookie(NULL)
{
    m_strName = szName;
    ASSERT(pFavorites != NULL);
}

CAddFavDialog::~CAddFavDialog()
{
    // disconnect fav view from source
    if (m_lAdviseCookie )
    {
        ASSERT(m_pFavorites != NULL);
        HRESULT hr = m_pFavorites->Unadvise(m_lAdviseCookie);
        ASSERT(SUCCEEDED(hr));

        m_FavTree.SetTreeSource(NULL);
    }

    // detach classes from windows
    m_FavTree.Detach();
    m_FavName.Detach();
}


HRESULT CAddFavDialog::CreateFavorite(CFavObject** pfavRet)
{
    m_pfavItem = NULL;

    if (DoModal() != IDOK)
        return S_FALSE;

    if (pfavRet != NULL)
        *pfavRet = m_pfavItem;

    return m_hr;
}


BOOL CAddFavDialog::OnInitDialog()
{
	DECLARE_SC (sc, _T("CAddFavDialog::OnInitDialog"));
    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    // Attach tree ctrl to favorites tree object
    BOOL bStat = m_FavTree.SubclassDlgItem(IDC_FAVTREE, this);
    ASSERT(bStat);

    bStat = m_FavName.Attach(GetDlgItem(IDC_FAVNAME)->GetSafeHwnd());
    ASSERT(bStat);

    m_FavName.SetWindowText(m_strName);
    m_FavName.SetSel(0,lstrlen(m_strName));
    m_FavName.SetFocus();

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

    // Show only folders
    m_FavTree.SetStyle(TOBSRV_FOLDERSONLY);

	/*
	 * validate m_pFavorites
	 */
	sc = ScCheckPointers (m_pFavorites, E_UNEXPECTED);
	if (sc)
	{
		EndDialog (IDCANCEL);
		return (0);
	}

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(m_pFavorites->GetImageList(), TVSIL_NORMAL);

    // attach view to source as observer
    HRESULT hr = m_pFavorites->Advise(static_cast<CTreeObserver*>(&m_FavTree), &m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr) && m_lAdviseCookie != 0);

    // hand tree data source to tree view
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(m_pFavorites));

    // Select the root
    m_FavTree.SetSelection(m_pFavorites->GetRootItem());

    // return 0 so focus isn't changed
    return 0;
}

void CAddFavDialog::OnChangeName()
{
    EnableButton(m_hWnd, IDOK, (m_FavName.LineLength() != 0));
}

void CAddFavDialog::OnOK( )
{
    // Get favorite name
    TCHAR strName[MAX_PATH];

    m_hr = E_FAIL;
    m_pfavItem = NULL;

    int cChar = m_FavName.GetWindowText(strName, countof(strName));
    ASSERT(cChar != 0);
    if (cChar == 0)
        return;

    // Get selected folder
    TREEITEMID tid = m_FavTree.GetSelection();
    ASSERT(tid != NULL);
    if (tid == NULL)
        return;

    // Detach fav tree from source because it doesn't need updating
    ASSERT(m_pFavorites != NULL);
    HRESULT hr = m_pFavorites->Unadvise(m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr));
    m_lAdviseCookie = 0;

    // Inform source of disconnection
    m_FavTree.SetTreeSource(NULL);

    // Create a favorite
    ASSERT(m_pFavorites != NULL);
    m_hr = m_pFavorites->AddFavorite(tid, strName, &m_pfavItem);
    ASSERT(SUCCEEDED(hr));

    CDialog::OnOK();
}

void CAddFavDialog::OnAddFolder()
{
    ASSERT(m_pFavorites != NULL);

    // Get selected group
    TREEITEMID tidParent = m_FavTree.GetSelection();
    ASSERT(tidParent != NULL);

    // Put up dialog to get folder name
    CAddFavGroupDialog dlgAdd(this);
    if (dlgAdd.DoModal() != IDOK)
        return;

    LPCTSTR strName = dlgAdd.GetGroupName();
    ASSERT(strName[0] != 0);

    CFavObject* pfavGroup = NULL;
    HRESULT hr = m_pFavorites->AddGroup(tidParent, strName, &pfavGroup);
    if (SUCCEEDED(hr))
    {
        ASSERT(pfavGroup != NULL);
        m_FavTree.SetSelection(reinterpret_cast<TREEITEMID>(pfavGroup));
    }
}


/////////////////////////////////////////////////////////////////////
// CAddFavGroup dialog

BEGIN_MESSAGE_MAP(CAddFavGroupDialog, CDialog)
    //{{AFX_MSG_MAP(CAddFavGroupDialog)
    ON_EN_CHANGE(IDC_FAVFOLDER, OnChangeName)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()


CAddFavGroupDialog::CAddFavGroupDialog(CWnd* pParent)
   : CDialog(CAddFavGroupDialog::IDD, pParent)
{
}

CAddFavGroupDialog::~CAddFavGroupDialog()
{
    // detach classes from windows
    m_GrpName.Detach();
}

CAddFavGroupDialog::OnInitDialog()
{
    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    BOOL bStat = m_GrpName.Attach(GetDlgItem(IDC_FAVFOLDER)->GetSafeHwnd());
    ASSERT(bStat);

    // Set default favorite name and select it
    CString strDefault;
    LoadString(strDefault, IDS_NEWFOLDER);

    m_GrpName.SetWindowText(strDefault);
    m_GrpName.SetSel(0,lstrlen(strDefault));
    m_GrpName.SetFocus();

    // return 0 so focus isn't changed
    return 0;
}

void CAddFavGroupDialog::OnChangeName()
{
    EnableButton(m_hWnd, IDOK, (m_GrpName.LineLength() != 0));
}

void CAddFavGroupDialog::OnOK( )
{
    // Get group name
    int cChar = GetDlgItemText(IDC_FAVFOLDER, m_strName, sizeof(m_strName)/sizeof(TCHAR));
    ASSERT(cChar != 0);

    CDialog::OnOK();
}

//////////////////////////////////////////////////////////////////////////////
//
BEGIN_MESSAGE_MAP(COrganizeFavDialog, CDialog)
    //{{AFX_MSG_MAP(COrganizeFavDialog)
    ON_COMMAND(IDC_ADDFAVFOLDER, OnAddFolder)
    ON_COMMAND(IDC_FAVRENAME, OnRename)
    ON_COMMAND(IDC_FAVDELETE, OnDelete)
    ON_COMMAND(IDC_FAVMOVETO, OnMoveTo)
    ON_NOTIFY(TVN_SELCHANGED, IDC_FAVTREE, OnSelChanged)
    ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_FAVTREE, OnBeginLabelEdit)
    ON_NOTIFY(TVN_ENDLABELEDIT, IDC_FAVTREE, OnEndLabelEdit)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()


COrganizeFavDialog::COrganizeFavDialog(CFavorites* pFavorites, CWnd* pParent)
   : CDialog(COrganizeFavDialog::IDD, pParent),
     m_pFavorites(pFavorites), m_lAdviseCookie(NULL), m_tidRenameItem(0), m_bRenameMode(FALSE)
{
    ASSERT(pFavorites != NULL);
}

COrganizeFavDialog::~COrganizeFavDialog()
{
    // disconnect fav view from source
    if (m_lAdviseCookie)
    {
        ASSERT(m_pFavorites != NULL);
        m_pFavorites->Unadvise(m_lAdviseCookie);
        m_FavTree.SetTreeSource(NULL);
    }

    // detach classes from windows
    m_FavTree.Detach();
    m_FavName.Detach();
    m_FavInfo.Detach();
}


BOOL COrganizeFavDialog::OnInitDialog()
{
	DECLARE_SC (sc, _T("COrganizeFavDialog::OnInitDialog"));
    ASSERT(m_pFavorites != NULL);

    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    // Attach tree ctrl to favorites tree object
    BOOL bStat = m_FavTree.SubclassDlgItem(IDC_FAVTREE, this);
    ASSERT(bStat);

    bStat = m_FavName.Attach(GetDlgItem(IDC_FAVNAME)->GetSafeHwnd());
    ASSERT(bStat);

    bStat = m_FavInfo.Attach(GetDlgItem(IDC_FAVINFO)->GetSafeHwnd());
    ASSERT(bStat);

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

	/*
	 * validate m_pFavorites
	 */
	sc = ScCheckPointers (m_pFavorites, E_UNEXPECTED);
	if (sc)
	{
		EndDialog (IDCANCEL);
		return (0);
	}

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(m_pFavorites->GetImageList(), TVSIL_NORMAL);

    // Attach view to source as observer
    HRESULT hr = m_pFavorites->Advise(static_cast<CTreeObserver*>(&m_FavTree), &m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr) && m_lAdviseCookie != 0);

    // Hand tree data source to tree view
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(m_pFavorites));

    // Select the root item and give it focus
    m_FavTree.SetSelection(m_pFavorites->GetRootItem());
    m_FavTree.SetFocus();

    // Create bold font for favorite name control
    LOGFONT logfont;
    m_FavName.GetFont()->GetLogFont(&logfont);

    logfont.lfWeight = FW_BOLD;
    if (m_FontBold.CreateFontIndirect(&logfont))
        m_FavName.SetFont(&m_FontBold);


    // return 0 so focus isn't changed
    return 0;
}

void COrganizeFavDialog::OnOK( )
{
    // if in rename mode, end it with success
    if (m_bRenameMode)
    {
        m_FavTree.SendMessage(TVM_ENDEDITLABELNOW, FALSE);
        return;
    }

    CDialog::OnOK();
}


void COrganizeFavDialog::OnCancel( )
{
    // if in rename mode, cancel it
    if (m_bRenameMode)
    {
        m_FavTree.SendMessage(TVM_ENDEDITLABELNOW, FALSE);
        return;
    }

    CDialog::OnOK();
}


void COrganizeFavDialog::OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult)
{
    ASSERT(pMNHDR != NULL);
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pMNHDR;

    TREEITEMID tid = pnmtv->itemNew.lParam;

    TCHAR name[100];
    m_pFavorites->GetItemName(tid, name, countof(name));
    m_FavName.SetWindowText(name);

    if (m_pFavorites->IsFolderItem(tid))
    {
        CString strPath;
        LoadString(strPath, IDS_FAVFOLDER);
        m_FavInfo.SetWindowText(strPath);
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        m_pFavorites->GetItemPath(tid, szPath, countof(szPath));
        m_FavInfo.SetWindowText(szPath);
    }

    // Disable some operation for the root item
    BOOL bRoot = (tid == m_pFavorites->GetRootItem());

    EnableButton(m_hWnd, IDC_FAVRENAME, !bRoot);
    EnableButton(m_hWnd, IDC_FAVDELETE, !bRoot);
    EnableButton(m_hWnd, IDC_FAVMOVETO, !bRoot);
}


void COrganizeFavDialog::OnBeginLabelEdit(NMHDR* pMNHDR, LRESULT* plResult)
{
    // Only allow renaming if an item has been selected
    // This is to prevent an edit starting from an item click because
    // that is confusing when used with the single-click expand style.
    // (returning TRUE disables it)

    if (m_tidRenameItem != 0)
    {
        m_bRenameMode = TRUE;
        *plResult = FALSE;
    }
    else
    {
        *plResult = TRUE;
    }
}


void COrganizeFavDialog::OnEndLabelEdit(NMHDR* pMNHDR, LRESULT* plResult)
{
    ASSERT(m_bRenameMode && m_tidRenameItem != 0);

    *plResult = FALSE;

    if (m_tidRenameItem != 0)
    {
        NMTVDISPINFO* pnmtvd = (NMTVDISPINFO*)pMNHDR;

        // Is this for the expected item?
        ASSERT(pnmtvd->item.lParam == m_tidRenameItem);

        if (pnmtvd->item.pszText != NULL && pnmtvd->item.pszText[0] != 0)
        {
            m_pFavorites->SetItemName(m_tidRenameItem, pnmtvd->item.pszText);
            *plResult = TRUE;

            // update displayed name in info window
            m_FavName.SetWindowText(pnmtvd->item.pszText);
        }

        m_tidRenameItem = 0;
     }

     m_bRenameMode = FALSE;
}


void COrganizeFavDialog::OnAddFolder()
{
    ASSERT(m_pFavorites != NULL);

    // Get selected group
    TREEITEMID tidParent = m_FavTree.GetSelection();
    ASSERT(tidParent != NULL);

    // if selected item is not a group then
    // add the new group as a sibling
    if (!m_pFavorites->IsFolderItem(tidParent))
        tidParent = m_pFavorites->GetParentItem(tidParent);

    // Put up dialog to get folder name
    CAddFavGroupDialog dlgAdd(this);
    if (dlgAdd.DoModal() != IDOK)
        return;

    LPCTSTR strName = dlgAdd.GetGroupName();
    ASSERT(strName[0] != 0);

    CFavObject* pfavGroup = NULL;
    HRESULT hr = m_pFavorites->AddGroup(tidParent, strName, &pfavGroup);
    if (SUCCEEDED(hr))
    {
        m_FavTree.ExpandItem(tidParent);
    }
}


void COrganizeFavDialog::OnDelete()
{
    TREEITEMID tid = m_FavTree.GetSelection();

    if (tid != 0 && tid != m_pFavorites->GetRootItem())
        m_pFavorites->DeleteItem(tid);
}

void COrganizeFavDialog::OnRename()
{
    ASSERT(m_pFavorites != NULL);

    // Get selected item
    TREEITEMID tid = m_FavTree.GetSelection();

    if (tid != 0 && tid != m_pFavorites->GetRootItem())
    {
        HTREEITEM hti = m_FavTree.FindHTI(tid, TRUE);
        ASSERT(hti != NULL);

        m_tidRenameItem = tid;
        m_FavTree.SetFocus();
        m_FavTree.EditLabel(hti);
    }
}

void COrganizeFavDialog::OnMoveTo()
{
    ASSERT(m_pFavorites != NULL);

    // Put up dialog to get destination folder ID
    CFavFolderDialog dlgAdd(m_pFavorites, this);
    if (dlgAdd.DoModal() != IDOK)
        return;

    TREEITEMID  tidNewParent = dlgAdd.GetFolderID();

    // Get selected object
    TREEITEMID tid = m_FavTree.GetSelection();
    ASSERT(tid != NULL);

    HRESULT hr = m_pFavorites->MoveItem(tid, tidNewParent, TREEID_LAST);

    // on failure tell user selected destination is invalid
}

/////////////////////////////////////////////////////////////////////
// CFavFolderDialog dialog

BEGIN_MESSAGE_MAP(CFavFolderDialog, CDialog)
    //{{AFX_MSG_MAP(CFavFolderDialog)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()

CFavFolderDialog::CFavFolderDialog(CFavorites* pFavorites, CWnd* pParent)
   : CDialog(CFavFolderDialog::IDD, pParent),
   m_pFavorites(pFavorites), m_lAdviseCookie(NULL)
{
    ASSERT(pFavorites != NULL);
}

CFavFolderDialog::~CFavFolderDialog()
{
    // disconnect fav view from source
    if (m_lAdviseCookie )
    {
        ASSERT(m_pFavorites != NULL);
        m_pFavorites->Unadvise(m_lAdviseCookie);
        m_FavTree.SetTreeSource(NULL);
    }

    // detach classes from windows
    m_FavTree.Detach();
}

CFavFolderDialog::OnInitDialog()
{
	DECLARE_SC (sc, _T("CFavFolderDialog::OnInitDialog"));
    ASSERT(m_pFavorites != NULL);

    CDialog::OnInitDialog();

    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);

    // Attach tree ctrl to favorites tree object
    BOOL bStat = m_FavTree.SubclassDlgItem(IDC_FAVTREE, this);
    ASSERT(bStat);

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

    // Show only folders
    m_FavTree.SetStyle(TOBSRV_FOLDERSONLY);

	/*
	 * validate m_pFavorites
	 */
	sc = ScCheckPointers (m_pFavorites, E_UNEXPECTED);
	if (sc)
	{
		EndDialog (IDCANCEL);
		return (0);
	}

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(m_pFavorites->GetImageList(), TVSIL_NORMAL);

    // attach view to source as observer
    HRESULT hr = m_pFavorites->Advise(static_cast<CTreeObserver*>(&m_FavTree), &m_lAdviseCookie);
    ASSERT(SUCCEEDED(hr) && m_lAdviseCookie != 0);

    // hand tree data source to tree view
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(m_pFavorites));

    // Select the root and give it focus
    m_FavTree.SetSelection(m_pFavorites->GetRootItem());
    m_FavTree.SetFocus();

    // return 0 so focus isn't changed
    return 0;

}


void CFavFolderDialog::OnOK()
{
    // Get group name
    m_tidFolder = m_FavTree.GetSelection();

    // disconnect fav view from source before window goes away
    if (m_lAdviseCookie)
    {
        ASSERT(m_pFavorites != NULL);
        m_pFavorites->Unadvise(m_lAdviseCookie);
        m_FavTree.SetTreeSource(NULL);
        m_lAdviseCookie = 0;
    }

    CDialog::OnOK();
}


//////////////////////////////////////////////////////////////////////////////
//  CFavTreeCtrl

SC CFavTreeCtrl::ScInitialize(CFavorites* pFavorites, DWORD dwStyles)
{
	DECLARE_SC (sc, _T("CFavTreeCtrl::Initialize"));

	/*
	 * validate pFavorites
	 */
	sc = ScCheckPointers (pFavorites);
	if (sc)
		return (sc);

    // Attach favorites image list to tree control
    m_FavTree.SetImageList(pFavorites->GetImageList(), TVSIL_NORMAL);

    m_FavTree.SetStyle(dwStyles);

    // Attach favorites data source
    m_FavTree.SetTreeSource(static_cast<CTreeSource*>(pFavorites));

	return (sc);
}

int CFavTreeCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    RECT rect;
    GetClientRect(&rect);
    m_FavTree.Create(WS_VISIBLE | TVS_SINGLEEXPAND | TVS_TRACKSELECT |
                     TVS_FULLROWSELECT, rect, this, IDC_FAVTREECTRL);

    // Add extra space between items
    TreeView_SetItemHeight(m_FavTree, TreeView_GetItemHeight(m_FavTree) + FAVVIEW_ITEM_SPACING);

    // Dont' show the "Favorites" root item
    m_FavTree.SetStyle(TOBSRV_HIDEROOT);
    return 0;
}

void CFavTreeCtrl::PostNcDestroy()
{
    /*
     * Commit suicide.  See the comment for this class's ctor for reasoning
     * why this is safe.
     */
    delete this;
}

void  CFavTreeCtrl::OnSize(UINT nType, int cx, int cy)
{
    // size tree control to parent
    m_FavTree.MoveWindow(0, 0, cx, cy);
}

void  CFavTreeCtrl::OnSetFocus(CWnd* pOldWnd)
{
    // pass focus to tree control
    m_FavTree.SetFocus();
}

void  CFavTreeCtrl::OnSelChanged(NMHDR* pMNHDR, LRESULT* plResult)
{
    ASSERT(pMNHDR != NULL);
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pMNHDR;

    TREEITEMID tid = pnmtv->itemNew.lParam;
    CFavObject* pFav = (CFavObject*)tid;

    WPARAM wParam = pFav->IsGroup() ?
                        NULL : reinterpret_cast<WPARAM>(pFav->GetMemento());

    GetParent()->SendMessage(MMC_MSG_FAVORITE_SELECTION, wParam, 0);
}

BEGIN_MESSAGE_MAP(CFavTreeCtrl, CWnd)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_SETFOCUS()
    ON_NOTIFY(TVN_SELCHANGED, IDC_FAVTREECTRL, OnSelChanged)
END_MESSAGE_MAP()


//--------------------------------------------------------------------------
// EnableButton
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    ASSERT(::IsWindow(hWndCtrl));

    if (!bEnable && ::GetFocus() == hWndCtrl)
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if (hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl)
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member     : OnFavoritesMenu
//
//  Synopsis   : Display the favorites menu.
//
//  Arguments  : [point] - x,y co-ordinates for menu.
//
//  Returns    : None.
//
//--------------------------------------------------------------------
void CAMCView::OnFavoritesMenu(CPoint point, LPCRECT prcExclude)
{
	DECLARE_SC (sc, _T("CAMCView::OnFavoritesMenu"));
    TRACE_METHOD(CAMCView, OnFavoritesMenu);

    CMenu menu;
    VERIFY( menu.CreatePopupMenu() );

    // Default items available only in Author mode.
    if (AMCGetApp()->GetMode() == eMode_Author)
    {
        CString strItem;

        // Menu Command Ids for below items are string resource
        // IDs. The real favorites use the TREEITEMID as ID,
        // which are pointers and wont clash with below resource
        // IDs which are less than 0xFFFF
        LoadString(strItem, IDS_ADD_TO_FAVORITES);
		int iSeparator = strItem.Find(_T('\n'));
		if (iSeparator > 0)
			strItem = strItem.Left(iSeparator);

        VERIFY(menu.AppendMenu(MF_DEFAULT, IDS_ADD_TO_FAVORITES, (LPCTSTR)strItem));

        LoadString(strItem, IDS_ORGANIZEFAVORITES);
		iSeparator = strItem.Find(_T('\n'));
		if (iSeparator > 0)
			strItem = strItem.Left(iSeparator);

        VERIFY(menu.AppendMenu(MF_DEFAULT, IDS_ORGANIZEFAVORITES, (LPCTSTR)strItem));
    }

    CAMCDoc* pDoc = GetDocument();
    ASSERT(pDoc);
    CFavorites* pFavorites = pDoc->GetFavorites();

	/*
	 * Index 0 of the vector is unused (a 0 return from TrackPopupMenu
	 * means nothing was selected).  Put a placeholder there.
	 */
	TIDVector vItemIDs;
	vItemIDs.push_back (NULL);

	/*
	 * make sure IDS_ADD_TO_FAVORITES and IDS_ORGANIZEFAVORITES
	 * won't conflict with any indices in the TID vector, given a
	 * reasonable upper bound on the number of favorites
	 */
	const int cMaxReasonableFavorites = 1024;
	ASSERT             (vItemIDs.size ()	  <= cMaxReasonableFavorites);
	COMPILETIME_ASSERT (IDS_ADD_TO_FAVORITES  >  cMaxReasonableFavorites);
	COMPILETIME_ASSERT (IDS_ORGANIZEFAVORITES >  cMaxReasonableFavorites);

    // Add existing favorites.
    if ( (NULL != pFavorites) && (pFavorites->IsEmpty() == false))
    {
        TREEITEMID tid = pFavorites->GetRootItem();
        if (NULL != tid)
        {
            tid = pFavorites->GetChildItem(tid);
            if (NULL != tid)
            {
                // Add separator.
                if (AMCGetApp()->GetMode() == eMode_Author)
                    VERIFY(menu.AppendMenu(MF_SEPARATOR, 0, _T("")));

                // Add child items.
                AddFavItemsToCMenu(menu, pFavorites, tid, vItemIDs);
            }
        }
    }

    // Display the context menu.
	TPMPARAMS* ptpm = NULL;
	TPMPARAMS tpm;

	/*
	 * if given, initialize the rectangle not to obscure
	 */
	if (prcExclude != NULL)
	{
		tpm.cbSize    = sizeof(tpm);
		tpm.rcExclude = *prcExclude;
		ptpm          = &tpm;
	}

    LONG lSelected = TrackPopupMenuEx (
			menu.GetSafeHmenu(),
            TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTBUTTON | TPM_VERTICAL,
            point.x,
            point.y,
            GetSafeHwnd(),
            ptpm );

    // Handle the selection.

    switch (lSelected)
    {
		case 0: // Nothing is selected
			break;
	
		case IDS_ADD_TO_FAVORITES: // Bring the Add To Favorites dialog.
			OnAddToFavorites();
			break;
	
		case IDS_ORGANIZEFAVORITES: // Bring the organize favorites dialog.
			{
				CAMCDoc* pDoc = GetDocument();
				ASSERT(pDoc != NULL && pDoc->GetFavorites() != NULL);
	
				pDoc->GetFavorites()->OrganizeFavorites(this);
			}
			break;
	
		default: // This is a favorite item. Select it.
			{
				CFavorites* pFavs = GetDocument()->GetFavorites();
				sc = ScCheckPointers (pFavs, E_UNEXPECTED);
				if (sc)
					break;
	
				sc = (lSelected < vItemIDs.size()) ? S_OK : E_UNEXPECTED;
				if (sc)
					break;
	
				TREEITEMID tid = vItemIDs[lSelected];
				CFavObject* pFavObj = pFavs->FavObjFromTID(tid);
	
				sc = ScCheckPointers (pFavObj, E_UNEXPECTED);
				if (sc)
					break;
	
				sc = ScViewMemento(pFavObj->GetMemento());
                if (sc == ScFromMMC(IDS_NODE_NOT_FOUND) )
                {
                    MMCMessageBox(sc, MB_ICONEXCLAMATION | MB_OK);
                    sc.Clear();
                    return;
                }

                if (sc)
                    return;
			}
			break;
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member     : AddFavItemsToCMenu.
//
//  Synopsis   : Enumerate the favorites tree and add them as menu items.
//
//  Arguments  : [menu]  - Parent menu item.
//               [pFavs] - Favorites object.
//               [tid]   - Tree Item ID.
//
//  Returns    : None.
//
//--------------------------------------------------------------------
void CAMCView::AddFavItemsToCMenu(CMenu& menu, CFavorites* pFavs, TREEITEMID tid, TIDVector& vItemIDs)
{
    TCHAR szName[MAX_PATH];

    while (NULL != tid)
    {
        UINT nFlags = MF_DEFAULT;
        UINT_PTR nCommandID;

        // If this is folder item then
        // create a popup menu.
        if (pFavs->IsFolderItem(tid))
        {
            TREEITEMID tidChild = pFavs->GetChildItem(tid);

            CMenu submenu;
            VERIFY(submenu.CreatePopupMenu());

            // Add the children.
            if (NULL != tidChild)
            {
                AddFavItemsToCMenu(submenu, pFavs, tidChild, vItemIDs);
            }
            else
            {
                // Add an empty item.
                CString strItem;
                LoadString(strItem, IDS_Empty);
                VERIFY(submenu.AppendMenu(MF_GRAYED, 0, (LPCTSTR)strItem));
            }

            HMENU hSubmenu = submenu.Detach();
            ASSERT( NULL != hSubmenu );

            nFlags = MF_POPUP;
            nCommandID = (UINT_PTR)hSubmenu;
        }
		else
		{
			/*
			 * The command ID will be used as an index into vItemIDs,
			 * so the ID for this item is the size of the vector *before*
			 * the item is added to the vector.
			 */
			nCommandID = vItemIDs.size();
			vItemIDs.push_back (tid);
		}

        pFavs->GetItemName(tid, szName, countof(szName));
        VERIFY(menu.AppendMenu(nFlags, nCommandID, szName));

        // Get the next sibling.
        tid = pFavs->GetNextSiblingItem(tid);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\filedlgex.cpp ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Largely based on original implementation by Michael Lemley.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
// CFileDialogEx implements a CFileDialog that uses the new Windows
// 2000 style open/save dialog. Use companion class CDocManagerEx in an
// MFC framework app.
//
#include "stdafx.h"
#include <afxpriv.h>
#include "FileDlgEx.h"

IMPLEMENT_DYNAMIC(CFileDialogEx, CFileDialog)

CFileDialogEx::CFileDialogEx(BOOL bOpenFileDialog, LPCTSTR lpszDefExt,
	LPCTSTR lpszFileName, DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
	CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
		dwFlags, lpszFilter, pParentWnd)
{
}


BEGIN_MESSAGE_MAP(CFileDialogEx, CFileDialog)
	//{{AFX_MSG_MAP(CFileDialogEx)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*+-------------------------------------------------------------------------*
 * HasModernFileDialog
 *
 * Returns true if the system we're running on supports the "modern" file
 * open/save dialog (i.e. the one with the places bar).  Systems that
 * qualify are Win2K and higher, and WinMe and higher.
 *--------------------------------------------------------------------------*/

BOOL HasModernFileDialog()
{
	OSVERSIONINFO osvi = { sizeof(osvi) };

	if (!GetVersionEx (&osvi))
		return (false);

	switch (osvi.dwPlatformId)
	{
		// detect Win2K+
		case VER_PLATFORM_WIN32_NT:
			if (osvi.dwMajorVersion >= 5)
				return (true);
			break;

		// detect WinMe+
		case VER_PLATFORM_WIN32_WINDOWS:
			if ( (osvi.dwMajorVersion >= 5) ||
				((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion >= 90)))
				return (true);
			break;
	}

	return (false);
}

//////////////////
// DoModal override copied mostly from MFC, with modification to use
// m_ofnEx instead of m_ofn.
//
INT_PTR CFileDialogEx::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
	ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook

	// zero out the file buffer for consistent parsing later
	ASSERT(AfxIsValidAddress(m_ofn.lpstrFile, m_ofn.nMaxFile));
	DWORD nOffset = lstrlen(m_ofn.lpstrFile)+1;
	ASSERT(nOffset <= m_ofn.nMaxFile);
	memset(m_ofn.lpstrFile+nOffset, 0, (m_ofn.nMaxFile-nOffset)*sizeof(TCHAR));

	// WINBUG: This is a special case for the file open/save dialog,
	//  which sometimes pumps while it is coming up but before it has
	//  disabled the main window.
	HWND hWndFocus = ::GetFocus();
	BOOL bEnableParent = FALSE;
	m_ofn.hwndOwner = PreModal();
	AfxUnhookWindowCreate();
	if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
	{
		bEnableParent = TRUE;
		::EnableWindow(m_ofn.hwndOwner, FALSE);
	}

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);

	if (m_ofn.Flags & OFN_EXPLORER)
		pThreadState->m_pAlternateWndInit = this;
	else
		AfxHookWindowCreate(this);

	memset(&m_ofnEx, 0, sizeof(m_ofnEx));
	memcpy(&m_ofnEx, &m_ofn, sizeof(m_ofn));
   if (HasModernFileDialog())
	   m_ofnEx.lStructSize = sizeof(m_ofnEx);

	int nResult;
	if (m_bOpenFileDialog)
		nResult = ::GetOpenFileName((OPENFILENAME*)&m_ofnEx);
	else
		nResult = ::GetSaveFileName((OPENFILENAME*)&m_ofnEx);

	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

	if (nResult)
		ASSERT(pThreadState->m_pAlternateWndInit == NULL);
	pThreadState->m_pAlternateWndInit = NULL;

	// WINBUG: Second part of special case for file open/save dialog.
	if (bEnableParent)
		::EnableWindow(m_ofnEx.hwndOwner, TRUE);
	if (::IsWindow(hWndFocus))
		::SetFocus(hWndFocus);

	PostModal();
	return nResult ? nResult : IDCANCEL;
}

//////////////////
// When the open dialog sends a notification, copy m_ofnEx to m_ofn in
// case handler function is expecting updated information in the
// OPENFILENAME struct.
//
BOOL CFileDialogEx::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	memcpy(&m_ofn, &m_ofnEx, sizeof(m_ofn));
   m_ofn.lStructSize = sizeof(m_ofn);

   return CFileDialog::OnNotify( wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\filedlgex.h ===
////////////////////////////////////////////////////////////////
// MSDN -- August 2000
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 6.0, runs on Windows 98 and probably NT too.
//
#pragma once

// Windows 2000 version of OPENFILENAME.
// The new version has three extra members.
// This is copied from commdlg.h
//
struct OPENFILENAMEEX : public OPENFILENAME {
  void *        pvReserved;
  DWORD         dwReserved;
  DWORD         FlagsEx;
};

/////////////////////////////////////////////////////////////////////////////
// CFileDialogEx: Encapsulate Windows-2000 style open dialog.
//
class CFileDialogEx : public CFileDialog {
	DECLARE_DYNAMIC(CFileDialogEx)
public:
	CFileDialogEx(BOOL bOpenFileDialog, // TRUE for open, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

	// override
	virtual INT_PTR DoModal();

protected:
	OPENFILENAMEEX m_ofnEx;	// new Windows 2000 version of OPENFILENAME

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()
	//{{AFX_MSG(CFileDialogEx)
	//}}AFX_MSG
};

BOOL HasModernFileDialog();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\fontlink.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      fontlink.cpp
 *
 *  Contents:  Implementation file for CFontLinker
 *
 *  History:   17-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "fontlink.h"
#include "macros.h"

#ifdef DBG
CTraceTag  tagFontlink (_T("Font Linking"), _T("Font Linking"));
#endif


/*+-------------------------------------------------------------------------*
 * GetFontFromDC
 *
 * Returns the font that's currently selected into a DC
 *--------------------------------------------------------------------------*/

HFONT GetFontFromDC (HDC hdc)
{
    HFONT hFont = (HFONT) SelectObject (hdc, GetStockObject (SYSTEM_FONT));
    SelectObject (hdc, hFont);

    return (hFont);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::CFontLinker
 *
 *
 *--------------------------------------------------------------------------*/

CFontLinker::CFontLinker ()
{
	m_cPendingPostPaints = 0;
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::~CFontLinker
 *
 *
 *--------------------------------------------------------------------------*/

CFontLinker::~CFontLinker ()
{
	ASSERT (m_cPendingPostPaints == 0);
    ReleaseFonts();
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::ReleaseFonts
 *
 * Releases all fonts returned by IMLangFontLink
 *--------------------------------------------------------------------------*/

void CFontLinker::ReleaseFonts()
{
    /*
     * release the fonts
     */
    std::for_each (m_FontsToRelease.begin(), m_FontsToRelease.end(),
                   FontReleaser (GetFontLink()));

    /*
     * purge the caches
     */
    m_FontsToRelease.clear();
    m_CodePages.clear();

}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw
 *
 * NM_CUSTOMDRAW handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw (NMCUSTOMDRAW* pnmcd)
{
    switch (pnmcd->dwDrawStage & ~CDDS_SUBITEM)
    {
        case CDDS_PREPAINT:     return (OnCustomDraw_PrePaint     (pnmcd));
        case CDDS_POSTPAINT:    return (OnCustomDraw_PostPaint    (pnmcd));
        case CDDS_ITEMPREPAINT: return (OnCustomDraw_ItemPrePaint (pnmcd));
    }

    return (CDRF_DODEFAULT);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw_PrePaint
 *
 * NM_CUSTOMDRAW (CDDS_PREPAINT) handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw_PrePaint (NMCUSTOMDRAW* pnmcd)
{
	m_cPendingPostPaints++;		// this line must be before the Trace
    Trace (tagFontlink, _T("(0x%08X) PrePaint(%d):---------------------------------------------------------"), this, m_cPendingPostPaints);

	/*
	 * Under certain rare, timing-dependent circumstances (see bug 96465),
	 * we can get nested calls to custom draw from the listview control.
	 * If this is not a nested custom draw, our font and codepage collections
	 * should be empty.
	 */
	if (m_cPendingPostPaints == 1)
	{
		ASSERT (m_FontsToRelease.empty());
		ASSERT (m_CodePages.empty());
	}

	/*
	 * we always need a CDDS_POSTPAINT so we can keep our accounting correct
	 */
	LRESULT rc = CDRF_NOTIFYPOSTPAINT;

    /*
     * get draw notifications for each item and subitem if any items
	 * are localizable
     */
    if (IsAnyItemLocalizable())
        rc |= CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYSUBITEMDRAW;

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw_PostPaint
 *
 * NM_CUSTOMDRAW (CDDS_POSTPAINT) handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw_PostPaint (NMCUSTOMDRAW* pnmcd)
{
    Trace (tagFontlink, _T("(0x%08X) PostPaint(%d):--------------------------------------------------------"), this, m_cPendingPostPaints);
	m_cPendingPostPaints--;		// this line must be after the Trace

	/*
	 * if this is the final CDDS_POSTPAINT we'll get, release our fonts
	 */
	if (m_cPendingPostPaints == 0)
	{
		Trace (tagFontlink, _T("(0x%08X) releasing fonts..."), this);
		ReleaseFonts ();
	}

    return (CDRF_DODEFAULT);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::OnCustomDraw_ItemPrePaint
 *
 * NM_CUSTOMDRAW (CDDS_ITEMPAINT) handler for CFontLinker.
 *--------------------------------------------------------------------------*/

LRESULT CFontLinker::OnCustomDraw_ItemPrePaint (NMCUSTOMDRAW* pnmcd)
{
    DECLARE_SC(sc, TEXT("CFontLinker::OnCustomDraw_ItemPrePaint"));

    /*
     * if this item isn't localizable, do the default thing
     */
    if (!IsItemLocalizable (pnmcd))
        return (CDRF_DODEFAULT);

#ifdef DBG
    USES_CONVERSION;
    TCHAR pszPrefix[80];

    sc = StringCchPrintf(pszPrefix, countof(pszPrefix), _T("(0x%08X) ItemPrePaint:  "), this);
    if (sc)
        sc.TraceAndClear(); // Truncation is okay, so ignore return.

    LOGFONT lf;
    HFONT hFont;

    hFont = GetFontFromDC (pnmcd->hdc);
    GetObject (hFont, sizeof (lf), &lf);

    Trace (tagFontlink, _T("%sdefault font = (face=%s, weight=%d)"),
         pszPrefix, lf.lfFaceName, lf.lfWeight);

    /*
     * compute all of the fonts needed for this;
     * if we couldn't, do the default thing
     */
    Trace (tagFontlink, _T("%s    text = \"%s\""),
         pszPrefix, W2CT (GetItemText(pnmcd).data()));
#endif

    CRichText rt (pnmcd->hdc, GetItemText (pnmcd));

    if (!ComposeRichText (rt))
    {
        Trace (tagFontlink, _T("%s    unable to determine font, using default"), pszPrefix);
        return (CDRF_DODEFAULT);
    }

    /*
     * if the default font in the DC is sufficient, do the default thing
     */
    if (rt.IsDefaultFontSufficient ())
    {
        Trace (tagFontlink, _T("%s    default font is sufficient"), pszPrefix);
        return (CDRF_DODEFAULT);
    }

    /*
     * if the default font isn't sufficient, but there's a single
     * font that is, select it into the DC and let the control draw
     * the text
     */
    if (rt.IsSingleFontSufficient ())
    {
#ifdef DBG
        hFont = rt.GetSufficientFont();
        GetObject (hFont, sizeof (lf), &lf);
        Trace (tagFontlink, _T("%s    using single font = (face=%s, weight=%d)"),
             pszPrefix, lf.lfFaceName, lf.lfWeight);
#endif

        SelectObject (pnmcd->hdc, rt.GetSufficientFont());
        return (CDRF_NEWFONT);
    }

    /*
     * TODO: handle drawing the icon and indented text
     */
    Trace (tagFontlink, _T("%s    (punting...)"), pszPrefix);
    return (CDRF_DODEFAULT);

    /*
     * if we get here, two or more fonts are required to draw the
     * text; draw it ourselves, and tell the control not to do anything
     */
    rt.Draw (&pnmcd->rc, GetDrawTextFlags());
    return (CDRF_SKIPDEFAULT);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::ComposeRichText
 *
 * Computes all of the fonts required to draw a given Unicode string
 *--------------------------------------------------------------------------*/

bool CFontLinker::ComposeRichText (CRichText& rt)
{
    /*
     * get the code pages for the given DC's font
     */
    DWORD dwDefaultFontCodePages;

    if (!GetFontCodePages (rt.m_hdc, rt.m_hDefaultFont, dwDefaultFontCodePages))
        return (false);

    IMLangFontLink* pFontLink = GetFontLink();
    if (pFontLink == NULL)
        return (false);

    const LPCWSTR pszText = rt.m_strText.data();
    const int     cchText = rt.m_strText.length();
    int   cchDone = 0;
    DWORD dwPriorityCodePages = NULL;

    /*
     * build up the collection of TextSegmentFontInfos for the text
     */
    while (cchDone < cchText)
    {
        TextSegmentFontInfo tsfi;
        DWORD dwTextCodePages;

        /*
         * find out which code pages support the next segment of text
         */
        if (FAILED(pFontLink->GetStrCodePages (pszText + cchDone,
                                                cchText - cchDone,
                                                dwPriorityCodePages,
                                                &dwTextCodePages, &tsfi.cch)) )
        {
            rt.m_TextSegments.clear();
            return (false);
        }

        /*
         * if the default font can render the text, things are easy
         */
        if (dwDefaultFontCodePages & dwTextCodePages)
            tsfi.hFont = rt.m_hDefaultFont;

        /*
         * otherwise, ask IFontLink for the font to use
         */
        else
        {
            /*
             * get the font
             */
            if (FAILED (pFontLink->MapFont (rt.m_hdc, dwTextCodePages,
                                            rt.m_hDefaultFont, &tsfi.hFont)))
            {
                rt.m_TextSegments.clear();
                return (false);
            }

            /*
             * add this font to the set of fonts to release when we're done
             */
            std::pair<FontSet::iterator, bool> rc =
                            m_FontsToRelease.insert (tsfi.hFont);

            /*
             * if it was already there, release it now to keep
             * the ref counts right
             */
            if (!rc.second)
                pFontLink->ReleaseFont (tsfi.hFont);
        }

        rt.m_TextSegments.push_back (tsfi);
        cchDone += tsfi.cch;
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::GetMultiLang
 *
 *
 *--------------------------------------------------------------------------*/

IMultiLanguage* CFontLinker::GetMultiLang ()
{
    if (m_spMultiLang == NULL)
        m_spMultiLang.CreateInstance (CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER);

    return (m_spMultiLang);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::GetFontLink
 *
 *
 *--------------------------------------------------------------------------*/

IMLangFontLink* CFontLinker::GetFontLink ()
{
    if (m_spFontLink == NULL)
        m_spFontLink = GetMultiLang ();

    return (m_spFontLink);
}


/*+-------------------------------------------------------------------------*
 * CFontLinker::GetFontCodePages
 *
 * Returns a bit mask representing the code pages supported by the font.
 *--------------------------------------------------------------------------*/

bool CFontLinker::GetFontCodePages (
    HDC     hdc,
    HFONT   hFont,
    DWORD&  dwFontCodePages)
{
    /*
     * check the code page cache to see if we've
     * asked MLang about this font before
     */
    FontToCodePagesMap::const_iterator itCodePages = m_CodePages.find (hFont);

    if (itCodePages != m_CodePages.end())
    {
        dwFontCodePages = itCodePages->second;
        return (true);
    }

    /*
     * this font isn't in our code page cache yet;
     * ask MLang for the code pages
     */
    IMLangFontLink* pFontLink = GetFontLink();

    if (pFontLink == NULL)
        return (false);

    if (FAILED (pFontLink->GetFontCodePages (hdc, hFont, &dwFontCodePages)))
        return (false);

    /*
     * put the code pages in the cache
     */
    m_CodePages[hFont] = dwFontCodePages;

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CRichText::Draw
 *
 *
 *--------------------------------------------------------------------------*/

bool CRichText::Draw (
    LPCRECT rect,                       /* i:rect to draw in                */
    UINT    uFormat,                    /* i:DrawText format flags          */
    LPRECT  prectRemaining /*=NULL*/)   /* o:space remaining after drawing  */
    const
{
    HFONT   hOriginalFont = GetFontFromDC (m_hdc);
    CRect   rectDraw      = rect;
    LPCWSTR pszDraw       = m_strText.data();

    TextSegmentFontInfoCollection::const_iterator it = m_TextSegments.begin();

    /*
     * draw each segment
     */
    while (it != m_TextSegments.end())
    {
        /*
         * select the font for this segment
         */
        SelectObject (m_hdc, it->hFont);

        /*
         * measure the width of this segment
         */
        CRect rectMeasure = rectDraw;
        DrawTextW (m_hdc, pszDraw, it->cch, rectMeasure, uFormat | DT_CALCRECT);

        /*
         * draw this segment
         */
        DrawTextW (m_hdc, pszDraw, it->cch, rectDraw, uFormat);

        /*
         * set up for the next segment
         */
        pszDraw      += it->cch;
        rectDraw.left = rectMeasure.right;
        ++it;

        /*
         * if we've run out of rect to draw in, short out
         */
        if (rectDraw.IsRectEmpty ())
            break;
    }

    /*
     * if the caller wants it, return the remaining rectangle after drawing
     */
    if (prectRemaining != NULL)
        *prectRemaining = rectDraw;

    /*
     * re-select the original font
     */
    SelectObject (m_hdc, hOriginalFont);
    return (true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\ftab.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ftab.h
 *
 *  Contents:  Interface file for CFolderTab, CFolderTabView
 *
 *  History:   06-May-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/
#ifndef FTAB_H
#define FTAB_H

class CFolderTabMetrics
{
public:
                CFolderTabMetrics();
    int         GetXOffset()     const;
    int         GetXMargin()     const;
    int         GetYMargin()     const;      // top/bottom text margin.
    int         GetYBorder()     const;      // top border thickness.
    int         GetTextHeight()  const      { return m_textHeight;}
    int         GetExtraYSpace() const;
    int         GetTabHeight()   const;
    int         GetUpDownWidth() const;
    int         GetUpDownHeight()const;


    void        SetStyle(DWORD dwStyle)     { m_dwStyle = dwStyle;}
    void        SetTextHeight(int textHeight){ m_textHeight = textHeight;}


protected:
    DWORD       m_dwStyle;
    int         m_textHeight;                // height, in pixels, of the text in a rectangle.

};

/*+-------------------------------------------------------------------------*
 * class CFolderTab
 *
 *
 * PURPOSE: Encapsulates a single tab on the tab control
 *
 *+-------------------------------------------------------------------------*/
class CFolderTab : public CFolderTabMetrics
{
private:
    CString     m_sText; // tab text
    CRect       m_rect;         // bounding rect
    CRgn        m_rgn;          // polygon region to fill (trapezoid)
    CLSID       m_clsid;
    CPoint      m_rgPts[4];

    void        SetRgn();           // called by ComputeRgn() and SetWidth()
    int         ComputeRgn(CDC& dc, int x);
    int         Draw           (CDC& dc, CFont& font, BOOL bSelected, bool bFocused);
    int         DrawTrapezoidal(CDC& dc, CFont& font, BOOL bSelected, bool bFocused);

    BOOL        HitTest(CPoint pt)          { return m_rgn.PtInRegion(pt);}
    const CRect& GetRect() const            { return m_rect;}
    void        GetTrapezoid(const CRect& rc, CPoint* pts) const;
    int         GetWidth() const;
    void        SetWidth(int nWidth);
    void        Offset(const CPoint &point);

    friend class CFolderTabView;

public:
    CFolderTab();
    CFolderTab(const CFolderTab &other);
    CFolderTab &operator = (const CFolderTab &other);
    void    SetText(LPCTSTR lpszText)   { m_sText = lpszText; }
    LPCTSTR GetText() const             { return m_sText;}
    void    SetClsid(const CLSID& clsid){ m_clsid = clsid;}
    CLSID   GetClsid()                  { return m_clsid;}
};

enum
{
    FTN_TABCHANGED = 1
};                 // notification: tab changed

struct NMFOLDERTAB : public NMHDR
{      // notification struct
    int iItem;                                       // item index
    const CFolderTab* pItem;                     // ptr to data, if any
};

/*+-------------------------------------------------------------------------*
 * CFolderTabView
 *
 *
 * PURPOSE: Provides an Excel-like tab control
 *
 *+-------------------------------------------------------------------------*/
class CFolderTabView :
	public CView,
	public CFolderTabMetrics,
	public CTiedObject
{
    typedef  CView  BC;
    typedef  std::list<CFolderTab> CFolderTabList;
    typedef  CFolderTabList::iterator  iterator;


protected:
    CFolderTabList  m_tabList;                    // array of CFolderTabs
    int             m_iCurItem;                  // current selected tab
    CFont           m_fontNormal;                // current font, normal ntab
    CFont           m_fontSelected;              // current font, selected tab
    CView *         m_pParentView;
    bool            m_bVisible;
	bool			m_fHaveFocus;
    int             m_sizeX;
    int             m_sizeY;
    HWND            m_hWndUpDown;               // the up-down control
    int             m_nPos;                     // the first tab displayed
	CComPtr<IAccessible>	m_spTabAcc;			// the CTabAccessible object

    // helpers
    void DrawTabs(CDC& dc, const CRect& rc);

    void CreateFonts();
    void DeleteFonts();

public:
    CFolderTabView(CView *pParentView);
    virtual ~CFolderTabView();

    BOOL CreateFromStatic(UINT nID, CWnd* pParent);

    virtual BOOL Create(DWORD dwWndStyle, const RECT& rc,
                        CWnd* pParent, UINT nID, DWORD dwFtabStyle=0);

    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );

    void        Layout (CRect& rectTotal, CRect& rectFTab);
    CFolderTab &GetItem(int iPos);
    int         GetSelectedItem()       { return m_iCurItem;}
    int         GetItemCount()          { return m_tabList.size();}
    int         GetDesiredHeight()      { return GetSystemMetrics(SM_CYHSCROLL);}
    BOOL        AddItem(LPCTSTR lpszText, const CLSID& clsid);
    BOOL        RemoveItem(int iPos);
    void        DeleteAllItems();
    void        RecomputeLayout();
    int         HitTest(CPoint pt);
    int         SelectItem(int iTab, bool bEnsureVisible = false);
    int         SelectItemByClsid(const CLSID& clsid);
    void        SetFonts(CFont& fontNormal, CFont& fontSelected);
    void        SetVisible(bool bVisible) {m_bVisible = bVisible;}
    bool        IsVisible()             { return m_bVisible;}

public:
    // *** IAccessible methods ***
    SC Scget_accParent				(IDispatch** ppdispParent);
    SC Scget_accChildCount			(long* pChildCount);
    SC Scget_accChild				(VARIANT varChildID, IDispatch ** ppdispChild);
    SC Scget_accName				(VARIANT varChildID, BSTR* pszName);
    SC Scget_accValue				(VARIANT varChildID, BSTR* pszValue);
    SC Scget_accDescription			(VARIANT varChildID, BSTR* pszDescription);
    SC Scget_accRole				(VARIANT varChildID, VARIANT *pvarRole);
    SC Scget_accState				(VARIANT varChildID, VARIANT *pvarState);
    SC Scget_accHelp				(VARIANT varChildID, BSTR* pszHelp);
    SC Scget_accHelpTopic			(BSTR* pszHelpFile, VARIANT varChildID, long* pidTopic);
    SC Scget_accKeyboardShortcut	(VARIANT varChildID, BSTR* pszKeyboardShortcut);
    SC Scget_accFocus				(VARIANT * pvarFocusChild);
    SC Scget_accSelection			(VARIANT * pvarSelectedChildren);
    SC Scget_accDefaultAction		(VARIANT varChildID, BSTR* pszDefaultAction);
    SC ScaccSelect					(long flagsSelect, VARIANT varChildID);
    SC ScaccLocation				(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChildID);
    SC ScaccNavigate				(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    SC ScaccHitTest					(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    SC ScaccDoDefaultAction			(VARIANT varChildID);
    SC Scput_accName				(VARIANT varChildID, BSTR szName);
    SC Scput_accValue				(VARIANT varChildID, BSTR pszValue);

private:
    void        ShowUpDownControl(BOOL bShow);
    void        EnsureVisible(int iTab);
    int         ComputeRegion(CClientDC& dc);
    int         GetTotalTabWidth(CClientDC& dc);

	SC			ScFireAccessibilityEvent (DWORD dwEvent, LONG idObject);
	SC			ScValidateChildID (VARIANT &var);
	SC			ScValidateChildID (LONG id);

protected:
            void Paint(bool bFocused);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnPaint();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg int  OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message );
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
    afx_msg void OnHScroll(NMHDR *nmhdr, LRESULT *pRes);
    afx_msg LRESULT OnGetObject(WPARAM wParam, LPARAM lParam);

    DECLARE_DYNAMIC(CFolderTabView);
    DECLARE_MESSAGE_MAP()
};


#endif // FTAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\ftab.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ftab.h
 *
 *  Contents:  Implementation file for CFolderTab, CFolderTabView
 *
 *  History:   06-May-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "ftab.h"
#include "amcview.h"
#include <oleacc.h>

/*
 * if we're supporting old platforms, we need to build MSAA stubs
 */
#if (_WINNT_WIN32 < 0x0500)
	#include <winable.h>
	
	#define COMPILE_MSAA_STUBS
	#include "msaastub.h"
	
	#define WM_GETOBJECT	0x003D
#endif


#ifdef DBG
CTraceTag  tagTabAccessibility (_T("Accessibility"), _T("Tab Control"));
#endif


/*+-------------------------------------------------------------------------*
 * ValueOf
 *
 * Returns the value contained in the given variant.  The variant is
 * expected to be of type VT_I4.
 *--------------------------------------------------------------------------*/

inline LONG ValueOf (VARIANT& var)
{
	ASSERT (V_VT (&var) == VT_I4);		// prevalidation is expected
	return (V_I4 (&var));
}


/*+-------------------------------------------------------------------------*
 * CTabAccessible
 *
 * Implements the accessibility interface IAccessible for CFolderTabView.
 *--------------------------------------------------------------------------*/

class CTabAccessible :
	public CMMCIDispatchImpl<IAccessible, &GUID_NULL, &LIBID_Accessibility>,
    public CTiedComObject<CFolderTabView>
{
    typedef CTabAccessible	ThisClass;
    typedef CFolderTabView	CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(ThisClass)
    END_MMC_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

public:
    // *** IAccessible methods ***
    MMC_METHOD1 (get_accParent,				IDispatch** /*ppdispParent*/);
    MMC_METHOD1 (get_accChildCount,			long* /*pChildCount*/);
    MMC_METHOD2 (get_accChild,				VARIANT /*varChildID*/, IDispatch ** /*ppdispChild*/);
    MMC_METHOD2 (get_accName,				VARIANT /*varChildID*/, BSTR* /*pszName*/);
    MMC_METHOD2 (get_accValue,				VARIANT /*varChildID*/, BSTR* /*pszValue*/);
    MMC_METHOD2 (get_accDescription,		VARIANT /*varChildID*/, BSTR* /*pszDescription*/);
    MMC_METHOD2 (get_accRole,				VARIANT /*varChildID*/, VARIANT */*pvarRole*/);
    MMC_METHOD2 (get_accState,				VARIANT /*varChildID*/, VARIANT */*pvarState*/);
    MMC_METHOD2 (get_accHelp,				VARIANT /*varChildID*/, BSTR* /*pszHelp*/);
    MMC_METHOD3 (get_accHelpTopic,			BSTR* /*pszHelpFile*/, VARIANT /*varChildID*/, long* /*pidTopic*/);
    MMC_METHOD2 (get_accKeyboardShortcut,	VARIANT /*varChildID*/, BSTR* /*pszKeyboardShortcut*/);
    MMC_METHOD1 (get_accFocus,				VARIANT * /*pvarFocusChild*/);
    MMC_METHOD1 (get_accSelection,			VARIANT * /*pvarSelectedChildren*/);
    MMC_METHOD2 (get_accDefaultAction,		VARIANT /*varChildID*/, BSTR* /*pszDefaultAction*/);
    MMC_METHOD2 (accSelect,					long /*flagsSelect*/, VARIANT /*varChildID*/);
    MMC_METHOD5 (accLocation,				long* /*pxLeft*/, long* /*pyTop*/, long* /*pcxWidth*/, long* /*pcyHeight*/, VARIANT /*varChildID*/);
    MMC_METHOD3 (accNavigate,				long /*navDir*/, VARIANT /*varStart*/, VARIANT * /*pvarEndUpAt*/);
    MMC_METHOD3 (accHitTest,				long /*xLeft*/, long /*yTop*/, VARIANT * /*pvarChildAtPoint*/);
    MMC_METHOD1 (accDoDefaultAction,		VARIANT /*varChildID*/);
    MMC_METHOD2 (put_accName,				VARIANT /*varChildID*/, BSTR /*szName*/);
    MMC_METHOD2 (put_accValue,				VARIANT /*varChildID*/, BSTR /*pszValue*/);
};



//############################################################################
//############################################################################
//
//  Implementation of class CFolderTabMetrics
//
//############################################################################
//############################################################################

CFolderTabMetrics::CFolderTabMetrics()
: m_dwStyle(0), m_textHeight(0)
{
}

int CFolderTabMetrics::GetXOffset()     const {return 8;}
int CFolderTabMetrics::GetXMargin()     const {return 2;}
int CFolderTabMetrics::GetYMargin()     const {return 1;}
int CFolderTabMetrics::GetYBorder()     const {return 1;}
int CFolderTabMetrics::GetExtraYSpace() const {return 0;}
int CFolderTabMetrics::GetTabHeight()   const {return GetTextHeight() + 2 * GetYMargin() + 2 * GetYBorder();}
int CFolderTabMetrics::GetUpDownWidth() const {return 2*GetTabHeight();} //for nice square buttons
int CFolderTabMetrics::GetUpDownHeight()const {return GetTabHeight();} // the up-down control is as tall as the tabs


//############################################################################
//############################################################################
//
//  Implementation of class CFolderTab
//
//############################################################################
//############################################################################

CFolderTab::CFolderTab()
{
}

CFolderTab::CFolderTab(const CFolderTab &other)
{
    *this = other;
}

CFolderTab &
CFolderTab::operator = (const CFolderTab &other)
{
    if((CFolderTab *) this == (CFolderTab *) &other)
       return *this;

    m_sText   = other.m_sText;
    m_rect    = other.m_rect;
    m_clsid   = other.m_clsid;
    m_dwStyle = other.m_dwStyle;
    m_textHeight = other.m_textHeight;

    return *this;
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::GetWidth
 *
 * PURPOSE: Returns the width of the tab.
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTab::GetWidth() const
{
    return m_rect.Width() + 1; // rect.Width() returns right-left, need to add 1 for inclusive width.
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::SetWidth
 *
 * PURPOSE:  Sets the width of the tab.
 *
 * PARAMETERS:
 *    int  nWidth :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTab::SetWidth(int nWidth)
{
    ASSERT(nWidth > 0);
    ASSERT(GetWidth() >= nWidth);

    int delta = nWidth - (m_rect.Width() + 1);
    m_rect.right = m_rect.left + nWidth -1;

    m_rgPts[2].x+=delta;
    m_rgPts[3].x+=delta;
    SetRgn();
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::Offset
 *
 * PURPOSE:     Adds a certain offset to the internal array of points.
 *
 * PARAMETERS:
 *    const  CPoint :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTab::Offset(const CPoint &point)
{
    m_rect.OffsetRect(point);
    m_rgPts[0].Offset(point);
    m_rgPts[1].Offset(point);
    m_rgPts[2].Offset(point);
    m_rgPts[3].Offset(point);
    m_rgn.OffsetRgn(point);
}

void
CFolderTab::SetRgn()
{
    m_rgn.DeleteObject();
    m_rgn.CreatePolygonRgn(m_rgPts, 4, WINDING);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::ComputeRgn
 *
 * PURPOSE: Compute the the points, rect and region for a tab.
 *          Input x is starting x pos.
 *
 * PARAMETERS:
 *    CDC& dc :
 *    int  x :
 *
 * RETURNS:
 *    int: The actual width of the tab
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTab::ComputeRgn(CDC& dc, int x)
{

    CRect& rc = m_rect;
    rc.SetRectEmpty();

    // calculate desired text rectangle
    dc.DrawText(m_sText, &rc, DT_CALCRECT);
    rc.right  += 2*GetXOffset() + 2*GetXMargin();                       // add margins
    rc.bottom = rc.top + GetTabHeight();
    rc += CPoint(x,0);                                                  // shift right

    // create region
    GetTrapezoid(rc, m_rgPts);
    SetRgn();

    return rc.Width();
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::GetTrapezoid
 *
 * PURPOSE: Given the bounding rect, compute trapezoid region.
 *          Note that the right and bottom edges not included in rect or
 *          trapezoid; these are normal rules of geometry.
 *
 * PARAMETERS:
 *    const   CRect :
 *    CPoint* pts :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CFolderTab::GetTrapezoid(const CRect& rc, CPoint* pts) const
{
    pts[0] = CPoint(rc.left,                  rc.top    );
    pts[1] = CPoint(rc.left + GetXOffset(),   rc.bottom );
    pts[2] = CPoint(rc.right- GetXOffset()-1, rc.bottom );
    pts[3] = CPoint(rc.right-1,               rc.top    );
}

//////////////////
// Draw tab in normal or highlighted state
//
int CFolderTab::Draw(CDC& dc, CFont& font, BOOL bSelected, bool bFocused)
{
    return DrawTrapezoidal(dc, font, bSelected, bFocused);
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTab::DrawTrapezoidal
 *
 * PURPOSE: Draws a trapezoidal tab.
 *
 * PARAMETERS:
 *    CDC&   dc :
 *    CFont& font :
 *    BOOL   bSelected :
 *    bool   bFocused :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int CFolderTab::DrawTrapezoidal(CDC& dc, CFont& font, BOOL bSelected, bool bFocused)
{
    COLORREF bgColor = GetSysColor(bSelected ? COLOR_WINDOW     : COLOR_3DFACE);
    COLORREF fgColor = GetSysColor(bSelected ? COLOR_WINDOWTEXT : COLOR_BTNTEXT);

    CBrush brush(bgColor);                   // background brush
    dc.SetBkColor(bgColor);                  // text background
    dc.SetTextColor(fgColor);                // text color = fg color

    CPen blackPen (PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    CPen shadowPen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));

    // Fill trapezoid
    CPoint pts[4];
    CRect rc = m_rect;
    GetTrapezoid(rc, pts);
    CPen* pOldPen = dc.SelectObject(&blackPen);
    dc.FillRgn(&m_rgn, &brush);

    // Draw edges. This is requires two corrections:
    // 1) Trapezoid dimensions don't include the right and bottom edges,
    // so must use one pixel less on bottom (cybottom)
    // 2) the endpoint of LineTo is not included when drawing the line, so
    // must add one pixel (cytop)
    //
    {
        pts[1].y--;         // correction #1: true bottom edge y-coord
        pts[2].y--;         // ...ditto
        pts[3].y--;         // correction #2:   extend final LineTo
    }
    dc.MoveTo(pts[0]);                      // upper left
    dc.LineTo(pts[1]);                      // bottom left
    dc.SelectObject(&shadowPen);            // bottom line is shadow color
    dc.MoveTo(pts[1]);                      // line is inside trapezoid bottom
    dc.LineTo(pts[2]);                      // ...
    dc.SelectObject(&blackPen);         // upstroke is black
    dc.LineTo(pts[3]);                      // y-1 to include endpoint
    if(!bSelected)
    {
        // if not highlighted, upstroke has a 3D shadow, one pixel inside
        pts[2].x--;     // offset left one pixel
        pts[3].x--;     // ...ditto
        dc.SelectObject(&shadowPen);
        dc.MoveTo(pts[2]);
        dc.LineTo(pts[3]);
    }
    dc.SelectObject(pOldPen);

    // draw text
    rc.DeflateRect(GetXOffset() + GetXMargin(), GetYMargin());
    CFont* pOldFont = dc.SelectObject(&font);
    dc.DrawText(m_sText, &rc, DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS);
    dc.SelectObject(pOldFont);

    if(bFocused) // draw the focus rectangle
    {
        // make some more space.
        rc.top--;
        rc.bottom++;
        rc.left--;
        rc.right++;

        dc.DrawFocusRect(&rc);
    }

    return m_rect.right;
}

//############################################################################
//############################################################################
//
//  Implementation of class CFolderTabView
//
//############################################################################
//############################################################################
IMPLEMENT_DYNAMIC(CFolderTabView, CView)
BEGIN_MESSAGE_MAP(CFolderTabView, CView)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEACTIVATE()
	ON_WM_KEYDOWN()
	ON_WM_SETTINGCHANGE()
	ON_WM_SIZE()
	ON_WM_HSCROLL()
	ON_MESSAGE(WM_GETOBJECT, OnGetObject)
END_MESSAGE_MAP()

CFolderTabView::CFolderTabView(CView *pParentView)
: m_bVisible(false), m_pParentView(pParentView)
{
    m_iCurItem   = -1;		// nothing currently selected
    m_dwStyle    = 0;
    m_textHeight = 0;
    m_sizeX      = 0;
    m_sizeY      = 0;
    m_hWndUpDown = NULL;
    m_nPos       = 0; // the first tab is the one drawn
	m_fHaveFocus = false;
}

CFolderTabView::~CFolderTabView()
{
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScFireAccessibilityEvent
 *
 * Fires accessibility events for the folder tab view
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScFireAccessibilityEvent (
	DWORD	dwEvent,					/* I:event to fire					*/
	LONG	idObject)					/* I:object generating the event	*/
{
	DECLARE_SC (sc, _T("CFolderTabView::ScFireAccessibilityEvent"));

	/*
	 * Accessibility events are fired after the event takes place (e.g.
	 * EVENT_OBJECT_CREATE is sent after the child is created, not before).
	 * Because of this the child ID for EVENT_OBJECT_DESTROY is not
	 * necessarily valid, so we shouldn't validate in that case.
	 */
	if (dwEvent != EVENT_OBJECT_DESTROY)
	{
		sc = ScValidateChildID (idObject);
		if (sc)
			return (sc);
	}

	NotifyWinEvent (dwEvent, m_hWnd, OBJID_CLIENT, idObject);	// returns void
	return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::OnHScroll
 *
 * PURPOSE: Called when the position of the scroll bar is changed
 *
 * PARAMETERS:
 *    UINT        nSBCode :
 *    UINT        nPos :
 *    CScrollBar* pScrollBar :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )
{
    // we're only interested in SB_THUMBPOSITION
    if(nSBCode != SB_THUMBPOSITION)
        return;

    // if the position has not changed, do nothing.
    if(nPos == m_nPos)
        return;

    m_nPos = nPos;  // change the position
    RecomputeLayout();
    InvalidateRect(NULL, true); // redraw everything.
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnSetFocus
 *
 * WM_SETFOCUS handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnSetFocus(CWnd* pOldWnd)
{
	m_fHaveFocus = true;

    InvalidateRect(NULL);
    BC::OnSetFocus(pOldWnd);

	/*
	 * If we have any tabs, one of them will get the focus.  Fire the
	 * focus accessibility event, ignoring errors.  We do this after
	 * calling the base class, so this focus event will override the
	 * "focus to the window" event sent by the system on our behalf.
	 */
	if (GetItemCount() > 0)
		ScFireAccessibilityEvent (EVENT_OBJECT_FOCUS, m_iCurItem+1 /*1-based*/);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnKillFocus
 *
 * WM_KILLFOCUS handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnKillFocus(CWnd* pNewWnd)
{
	m_fHaveFocus = false;

    InvalidateRect(NULL);
    BC::OnKillFocus(pNewWnd);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnMouseActivate
 *
 * WM_MOUSEACTIVATE handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

int CFolderTabView::OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message )
{
    //short-circuit the MFC base class code, which sets the keyboard focus here as well...
    return MA_ACTIVATE;
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnCmdMsg
 *
 * WM_COMMAND handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

BOOL CFolderTabView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (BC::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view didn't handle it, give parent view a chance
    if (m_pParentView != NULL)
        return static_cast<CWnd*>(m_pParentView)->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    else
        return FALSE;
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnKeyDown
 *
 * WM_KEYDOWN handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
{
    int cSize = m_tabList.size();

    if( (cSize == 0) || ( (nChar != VK_LEFT) && (nChar != VK_RIGHT) ) )
    {
        BC::OnKeyDown(nChar, nRepCnt, nFlags);
        return;
    }

    ASSERT( (nChar == VK_LEFT) || (nChar == VK_RIGHT) );

    int iNew = GetSelectedItem() + (nChar==VK_LEFT ? -1 : 1);
	if(iNew < 0)
		iNew = 0; // does not wrap

	if(iNew >= cSize)
		iNew = cSize -1; // does not wrap

    SelectItem(iNew, true /*bEnsureVisible*/);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

void CFolderTabView::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    CView::OnSettingChange(uFlags, lpszSection);

    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        DeleteFonts ();
        CreateFonts ();
        InvalidateRect(NULL, true); // redraw everything.
        RecomputeLayout ();
    }
}

//////////////////
// Create folder tab control from static control.
// Destroys the static control. This is convenient for dialogs
//
BOOL CFolderTabView::CreateFromStatic(UINT nID, CWnd* pParent)
{
    CStatic wndStatic;
    if(!wndStatic.SubclassDlgItem(nID, pParent))
        return FALSE;
    CRect rc;
    wndStatic.GetWindowRect(&rc);
    pParent->ScreenToClient(&rc);
    wndStatic.DestroyWindow();
    rc.bottom = rc.top + GetDesiredHeight();
    return Create(WS_CHILD|WS_VISIBLE, rc, pParent, nID);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::Create
 *
 * PURPOSE: Creates the folder tab control
 *
 * PARAMETERS:
 *    DWORD  dwStyle :
 *    const  RECT :
 *    CWnd*  pParent :
 *    UINT   nID :
 *    DWORD  dwFtabStyle :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL CFolderTabView::Create(DWORD dwStyle, const RECT& rc,
                            CWnd* pParent, UINT nID, DWORD dwFtabStyle)
{
    ASSERT(pParent);
    ASSERT(dwStyle & WS_CHILD);

    m_dwStyle = dwFtabStyle;

    static LPCTSTR lpClassName = _T("AMCCustomTab");
    static BOOL bRegistered = FALSE; // registered?
    if(!bRegistered)
    {
        WNDCLASS wc;
        memset(&wc, 0, sizeof(wc));
        wc.lpfnWndProc = ::DefWindowProc; // will get hooked by MFC
        wc.hInstance = AfxGetInstanceHandle();
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = lpClassName;
        if(!AfxRegisterClass(&wc))
        {
            TRACE(_T("*** CFolderTabView::AfxRegisterClass failed!\n"));
            return FALSE;
        }
        bRegistered = TRUE;
    }
    if(!BC::CreateEx(0, lpClassName, NULL, dwStyle, rc, pParent, nID))
        return FALSE;

    // initialize fonts
    CreateFonts();

	/*
	 * Bug 141015:  Create a buddy window for the up-down control.  It will
	 * never be visible, but we need it so UDM_GETPOS sent to the up-down
	 * will work.  Narrator will send this message when the up-down becomes
	 * visible, but it will fail if there's no buddy (sad, but true).  It
	 * fails by returning an LRESULT with a non-zero high-order word
	 * (specifically, 0x00010000), so Narrator translates and announces
	 * "65536" instead of the true value.
	 *
	 * This is only required for Narrator support, so if it fails it's
	 * not sufficient reason to fail CFolderTabView creation altogether.
	 */
	HWND hwndBuddy = CreateWindow (_T("edit"), NULL, WS_CHILD, 0, 0, 0, 0,
								   m_hWnd, 0, AfxGetInstanceHandle(), NULL);

    // create the up-down control
    DWORD dwUpDownStyle = WS_CHILD | WS_BORDER |
						  UDS_SETBUDDYINT |		// for Narrator support
						  UDS_HORZ /*to display the arrows left to right*/; // NOTE: the control is created invisible on purpose.
    m_hWndUpDown = CreateUpDownControl(dwUpDownStyle, 0, 0,
                        GetUpDownWidth(),   //width
                        GetUpDownHeight(),  //height
                        m_hWnd,
                        1 /*nID*/,
                        AfxGetInstanceHandle(),
                        hwndBuddy,
                        0 /*nUpper*/,
                        0 /*nLower*/,
                        0 /*nPos*/);

    return TRUE;
}

void CFolderTabView::CreateFonts ()
{
    LOGFONT lf;
    SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);
    m_fontNormal.CreateFontIndirect(&lf);

    // Get the font height (converting from points to pixels)
    CClientDC dc(NULL);
    TEXTMETRIC tm;
	CFont *pFontOld = dc.SelectObject(&m_fontNormal);
    dc.GetTextMetrics(&tm);

    m_textHeight = tm.tmHeight;

	// set the old font back.
	dc.SelectObject(pFontOld);

    lf.lfWeight = FW_BOLD;
    m_fontSelected.CreateFontIndirect(&lf);
}

void CFolderTabView::DeleteFonts ()
{
    m_fontNormal.DeleteObject();
    m_fontSelected.DeleteObject();
}

//////////////////
// copy a font
//
static void CopyFont(CFont& dst, CFont& src)
{
    dst.DeleteObject();
    LOGFONT lf;
    VERIFY(src.GetLogFont(&lf));
    dst.CreateFontIndirect(&lf);
}

//////////////////
// Set normal, selected fonts
//
void CFolderTabView::SetFonts(CFont& fontNormal, CFont& fontSelected)
{
    CopyFont(m_fontNormal, fontNormal);
    CopyFont(m_fontSelected, fontSelected);
}

//////////////////
// Paint function
//

void CFolderTabView::OnDraw(CDC* pDC)
{
}

void CFolderTabView::OnPaint()
{
    Paint (m_fHaveFocus);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::EnsureVisible
 *
 * PURPOSE: Changes the layout to ensure that the specified tab is visible.
 *
 * NOTE:    Does NOT invalidate the rect, for efficiency.
 *
 * PARAMETERS:
 *    UINT  iTab :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::EnsureVisible(int iTab)
{
    if((iTab < 0) || (iTab > m_tabList.size()))
    {
        ASSERT(0 && "Should not come here.");
        return;
    }

    if(!::IsWindowVisible(m_hWndUpDown))
        return; // the up-down control is hidden, meaning that all tabs are visible

	RecomputeLayout(); // make sure we have the correct dimensions

	if(m_nPos == iTab)
		return; // the tab already shows as much as it can.

    if(m_nPos > iTab) // the first visible tab is to the right of iTab. Make iTab the first visible tab
    {
        m_nPos = iTab;
        RecomputeLayout();
        return;
    }

    iterator iter = m_tabList.begin();
    std::advance(iter, iTab); // get the correct item

    CRect rcCurTab = iter->GetRect();

    // loop: Increase the start tab position until the right edge of iTab fits.
    while((m_nPos < iTab) && (rcCurTab.right > m_sizeX))
    {
        m_nPos++;
        RecomputeLayout();
        rcCurTab = iter->GetRect();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::Paint
 *
 * PURPOSE: Completely redraws the tab control.
 *
 * PARAMETERS:
 *    bool  bFocused :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::Paint(bool bFocused)
{
    CPaintDC dc(this); // device context for painting

    CRect rc;
    GetClientRect(&rc);

    // draw all the normal (non-selected) tabs
    iterator iterSelected = m_tabList.end();
    int i = 0;
    bool bDraw = true;
    for(iterator iter= m_tabList.begin(); iter!= m_tabList.end(); ++iter, i++)
    {
        if(i!=m_iCurItem)
        {
            if(bDraw && iter->Draw(dc, m_fontNormal, FALSE, false) > rc.right)
                bDraw = false;
        }
        else
        {
            iterSelected = iter;
        }
    }

    ASSERT(iterSelected != m_tabList.end());

    /*
     * Bug 350942: selected tab shouldn't be bold
     */
    // draw selected tab last so it will be "on top" of the others
    iterSelected->Draw(dc, /*m_fontSelected*/ m_fontNormal, TRUE, bFocused);

    // draw border: line along the top edge, excluding seleted tab
    CPoint pts[4];
    CRect rcCurTab = iterSelected->GetRect();
    iterSelected->GetTrapezoid(&rcCurTab, pts);

    CPen blackPen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));

    CPen* pOldPen = dc.SelectObject(&blackPen);
    int y = pts[0].y;
    dc.MoveTo(rc.left,      y);
    dc.LineTo(pts[0].x,     y);
    dc.MoveTo(pts[3].x,     y);
    dc.LineTo(rc.right,     y);

    dc.SelectObject(pOldPen);
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::OnLButtonDown
 *
 * PURPOSE: Selects the tab pointed to on a left mouse click
 *
 * PARAMETERS:
 *    UINT    nFlags :
 *    CPoint  pt :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    int iTab = HitTest(pt);
    if(iTab>=0 && iTab!=m_iCurItem)
    {
        SelectItem(iTab, true /*bEnsureVisible*/);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::HitTest
 *
 * PURPOSE: Computes which tab is at the specified point.
 *
 * PARAMETERS:
 *    CPoint  pt :
 *
 * RETURNS:
 *    int: The tab index, or -1 if none.
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::HitTest(CPoint pt)
{
    CRect rc;
    GetClientRect(&rc);
    if(rc.PtInRect(pt))
    {
        int i = 0;
        for( iterator iter= m_tabList.begin(); iter!= m_tabList.end(); ++iter, i++)
        {
            if(iter->HitTest(pt))
                return i;
        }
    }
    return -1;
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::SelectItem
 *
 * PURPOSE: Selects the iTab'th tab and returns the index of the tab selected,
 *          or -1 if an error occurred.
 *
 * PARAMETERS:
 *    int   iTab :
 *    bool  bEnsureVisible : If true, repositions the tab to make it visible.
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::SelectItem(int iTab, bool bEnsureVisible)
{
    if(iTab<0 || iTab>=GetItemCount())
        return -1;      // bad

    bool bSendTabChanged = (iTab != m_iCurItem); // send a message only if a different item got selected

    // repaint the control
    m_iCurItem = iTab;              // set new selected tab
    if(bEnsureVisible)
        EnsureVisible(iTab);
    else
        RecomputeLayout();

    InvalidateRect(NULL, true);

    if(bSendTabChanged)
    {
		/*
		 * If the selection changed, fire the selection accessibility event.
		 * We do it before sending FTN_TABCHANGED so that if the FTN_TABCHANGED
		 * handler selects another item, observers will get the selection
		 * events in the right order (ignore errors)
		 */
		ScFireAccessibilityEvent (EVENT_OBJECT_SELECTION, m_iCurItem+1 /*1-based*/);

		/*
		 * if our window has the focus, focus changes with selection,
		 * so send focus event, too (ignore errors)
		 */
		if (m_fHaveFocus)
			ScFireAccessibilityEvent (EVENT_OBJECT_FOCUS, m_iCurItem+1 /*1-based*/);

        // send the FTN_TABCHANGED message
        NMFOLDERTAB nm;
        nm.hwndFrom = m_hWnd;
        nm.idFrom = GetDlgCtrlID();
        nm.code = FTN_TABCHANGED;
        nm.iItem = iTab;
        CWnd* pParent = GetParent();
        pParent->SendMessage(WM_NOTIFY, nm.idFrom, (LPARAM)&nm);
    }

    return m_iCurItem;
}


int
CFolderTabView::SelectItemByClsid(const CLSID& clsid)
{
    bool bFound = false;
    int i=0;
    for(iterator iter= m_tabList.begin(); iter!= m_tabList.end(); ++iter, i++)
    {
        if(IsEqualGUID(iter->GetClsid(),clsid))
        {
            bFound = true;
            break;
        }
    }

    if(!bFound)
    {
        ASSERT(0 && "Invalid folder tab.");
        return -1;
    }

    return SelectItem(i);
}


CFolderTab &
CFolderTabView::GetItem(int iPos)
{
    ASSERT(!(iPos<0 || iPos>=GetItemCount()));

    CFolderTabList::iterator iter = m_tabList.begin();
    std::advance(iter, iPos);
    return *iter;
}


int CFolderTabView::AddItem(LPCTSTR lpszText, const CLSID& clsid)
{
    CFolderTab tab;
    tab.SetText(lpszText);
    tab.SetClsid(clsid);
    tab.SetStyle(m_dwStyle);
    tab.SetTextHeight(m_textHeight);

    m_tabList.push_back(tab);

    RecomputeLayout();
    InvalidateRect(NULL, true);

	int nNewItemIndex = m_tabList.size() - 1;	// 0-based

	/*
	 * tell observers we created a new tab, after it's been created (ignore errors)
	 */
	ScFireAccessibilityEvent (EVENT_OBJECT_CREATE, nNewItemIndex+1 /*1-based*/);

    return (nNewItemIndex);
}

BOOL CFolderTabView::RemoveItem(int iPos)
{
    if( (iPos < 0) || (iPos>= m_tabList.size()) )
        return false;

    CFolderTabList::iterator iter = m_tabList.begin();
    std::advance(iter, iPos);
    m_tabList.erase(iter);

	/*
	 * tell observers we destroyed a tab, after it's been destroyed but before
	 * we might send selection/focus notifications in SelectItem (ignore errors)
	 */
	ScFireAccessibilityEvent (EVENT_OBJECT_DESTROY, iPos+1 /*1-based*/);

	/*
	 * If we're deleting the currently selected tab, the selection needs to
	 * move somewhere else.  If there are tabs following the current one,
	 * we'll move the selection to the next tab; otherwise, we'll move to
	 * the previous one.
	 */
	if ((iPos == m_iCurItem) && !m_tabList.empty())
	{
		/*
		 * if there are tabs to the following the one we just deleted,
		 * increment m_iCurItem so the subsequent call to SelectItem
		 * will recognize that the selection change and send the proper
		 * notifications.
		 */
		if (m_iCurItem < m_tabList.size())
			m_iCurItem++;

		SelectItem (m_iCurItem-1, true /*bEnsureVisible*/);
	}
	else
	{
		/*
		 * if we deleted a tab before the selected tab, decrement the
		 * selected tab index to keep things in sync
		 * m_iCurItem will become -1 when the last tab is removed, which is correct
		 */
		if (iPos <= m_iCurItem)
			m_iCurItem--;

		InvalidateRect(NULL, true);
		RecomputeLayout();
	}

    return true;
}

void CFolderTabView::DeleteAllItems()
{
	const int cChildren = m_tabList.size();
    m_tabList.clear();
	m_iCurItem = -1;		// nothing is selected

    InvalidateRect(NULL, true);
    RecomputeLayout();

	/*
	 * Tell accessibility observers that each tab is destroyed.  Notify
	 * in last-to-first order so IDs remain sane during this process.
	 */
	for (int idChild = cChildren /*1-based*/; idChild >= 1; idChild--)
	{
		ScFireAccessibilityEvent (EVENT_OBJECT_DESTROY, idChild);
	}

	/*
	 * If we have the focus, tell accessibility observers that the
	 * control itself has the focus.  We do this to be consistent with
	 * other controls (like the list view)
	 */
	if (m_fHaveFocus)
		ScFireAccessibilityEvent (EVENT_OBJECT_FOCUS, CHILDID_SELF);
}

void CFolderTabView::OnSize(UINT nType, int cx, int cy)
{
    m_sizeX = cx;
    m_sizeY = cy;

    CView::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
	{
        RecomputeLayout();
	}

}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::ShowUpDownControl
 *
 * PURPOSE: Shows or hides the up/down control
 *
 * PARAMETERS:
 *    BOOL  bShow : true to show, false to hide.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::ShowUpDownControl(BOOL bShow)
{
    BOOL bVisible = (m_hWndUpDown != NULL) && ::IsWindowVisible(m_hWndUpDown); // was the up-down control visible previously?
    if(bShow)
    {
        if(!bVisible)
        {
            ::SendMessage(m_hWndUpDown, UDM_SETRANGE32, (WPARAM) 0 /*iLow*/, (LPARAM) m_tabList.size()-1 /*zero-based*/);
            ::SendMessage(m_hWndUpDown, UDM_SETPOS,     (WPARAM) 0,          (LPARAM) m_nPos /*nPos*/);
            ::ShowWindow(m_hWndUpDown, SW_SHOW);

            InvalidateRect(NULL, true);
        }
    }
    else
    {
        // hide the updown control
        if(m_hWndUpDown)
            ::ShowWindow(m_hWndUpDown, SW_HIDE);

        if(bVisible) // invalidate only on a transition from visible to invisible
            InvalidateRect(NULL, true);

		m_nPos = 0;
    }

}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::GetTotalTabWidth
 *
 * PURPOSE: Computes the total width of all the tabs.
 *
 * PARAMETERS:
 *    CClientDC& dc :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::GetTotalTabWidth(CClientDC& dc)
{
    int x = 0;

    // compute the width "as is", ie without taking into account the actual space available.
    for(iterator iter = m_tabList.begin(); iter!= m_tabList.end(); ++iter)
    {
        x += iter->ComputeRgn(dc, x) - GetXOffset();
    }

    return x;
}

/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::ComputeRegion
 *
 * PURPOSE: Computes the location and regions for all the tabs
 *
 * PARAMETERS:
 *    CClientDC& dc :
 *
 * RETURNS:
 *    int
 *
 *+-------------------------------------------------------------------------*/
int
CFolderTabView::ComputeRegion(CClientDC& dc)
{
    int x = GetTotalTabWidth(dc);

    // subtract the top-left x coordinate of the m_nPos'th tab from all x coordinates, thereby creating a shift
    iterator iter = m_tabList.begin();
    std::advance(iter, m_nPos); // advance to the m_nPos'th tab

    int xOffset = iter->GetRect().left;

	x = GetUpDownWidth() - xOffset; // shift everything to the left by xOffset

    for(iterator iterTemp = m_tabList.begin(); iterTemp!= m_tabList.end(); ++iterTemp)
    {
        x += iterTemp->ComputeRgn(dc, x) - GetXOffset();
    }

    return x;
}


/*+-------------------------------------------------------------------------*
 *
 * CFolderTabView::RecomputeLayout
 *
 * PURPOSE: Determines the location of all the tabs, and whether or not the
 *          up/down control should be displayed.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CFolderTabView::RecomputeLayout()
{
	// set the size of the updown control
    if(m_hWndUpDown)
        ::SetWindowPos(m_hWndUpDown, NULL /*hWndInsertAfter*/, 0 /*left*/, 0 /*top*/,
                     GetUpDownWidth(), GetUpDownHeight(), SWP_NOMOVE| SWP_NOZORDER);

	// set the correct text height for the tabs
    for(iterator iterTemp = m_tabList.begin(); iterTemp!= m_tabList.end(); ++iterTemp)
		iterTemp->SetTextHeight(GetTextHeight());


    CClientDC dc(this);
    CFont* pOldFont = dc.SelectObject(&m_fontSelected); // use the bold font to compute with.

    int totalWidth = GetTotalTabWidth(dc); // the width of ALL tabs

    if(totalWidth <= m_sizeX)
    {
        // there's enough space to show all tabs. Hide the updown control
        ShowUpDownControl(false);
    }
    else
    {
        // not enough width for all tabs.
        BOOL bVisible = ::IsWindowVisible(m_hWndUpDown); // was the up-down control visible previously?

        if(!bVisible) // the up-down control was not visible, so make it visible.
        {
            m_nPos = 0;
            ShowUpDownControl(true);
        }

        ComputeRegion(dc); // make sure we leave space for the tab

    }

    dc.SelectObject(pOldFont);
}


void CFolderTabView::Layout(CRect& rectTotal, CRect& rectFTab)
{
    int cy = GetTabHeight() + GetExtraYSpace();
    rectFTab        = rectTotal;
    if(!IsVisible())
        return;

    rectFTab.top    = rectFTab.bottom - cy;
    rectTotal.bottom= rectFTab.top;
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::OnGetObject
 *
 * WM_GETOBJECT handler for CFolderTabView.
 *--------------------------------------------------------------------------*/

LRESULT CFolderTabView::OnGetObject (WPARAM wParam, LPARAM lParam)
{
	DECLARE_SC (sc, _T("CFolderTabView::OnGetObject"));

	/*
	 * ignore requests for objects other than OBJID_CLIENT
	 */
    if (lParam != OBJID_CLIENT)
	{
		Trace (tagTabAccessibility, _T("WM_GETOBJECT: (lParam != OBJID_CLIENT), returning 0"));
		return (0);
	}

	/*
	 * create our accessibility object
	 */
    if ((sc = CTiedComObjectCreator<CTabAccessible>::ScCreateAndConnect(*this, m_spTabAcc)).IsError() ||
		(sc = ScCheckPointers (m_spTabAcc, E_UNEXPECTED)).IsError())
	{
		sc.TraceAndClear();
		Trace (tagTabAccessibility, _T("WM_GETOBJECT: error creating IAccessible object, returning 0"));
		return (0);
	}

	/*
	 * return a pointer to the IAccessible interface
	 */
	Trace (tagTabAccessibility, _T("WM_GETOBJECT: returning IAccessible*"));
    return (LresultFromObject (IID_IAccessible, wParam, m_spTabAcc));
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accParent
 *
 * Retrieves the IDispatch interface of the object's parent.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accParent(IDispatch ** ppdispParent)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accParent"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accParent"));

	sc = ScCheckPointers (ppdispParent);
	if(sc)
		return (sc);

	/*
	 * return the accessibility interface for the OBJID_WINDOW object
	 */
	sc = AccessibleObjectFromWindow (m_hWnd, OBJID_WINDOW, IID_IDispatch,
									 (void **)ppdispParent);
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accChildCount
 *
 * Retrieves the number of children belonging to this object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accChildCount(long* pChildCount)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accChildCount"));

	sc = ScCheckPointers (pChildCount);
	if(sc)
		return (sc);

	*pChildCount = GetItemCount();
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accChildCount: returning %d"), GetItemCount());

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accChild
 *
 * Retrieves the address of an IDispatch interface for the specified child.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accChild(VARIANT varChildID, IDispatch ** ppdispChild)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accChild"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accChild"));

	sc = ScCheckPointers (ppdispChild);
	if (sc)
		return (sc);

	// init out parameter
	(*ppdispChild) = NULL;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * all children are simple elements exposed through their parent,
	 * not accessible objects in their own right
	 */
	sc = S_FALSE;

	Trace (tagTabAccessibility, TEXT("returning parent's IDispatch for child %d"), ValueOf(varChildID));
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accName
 *
 * Retrieves the name of the specified object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accName(VARIANT varChildID, BSTR* pbstrName)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accName"));

	sc = ScCheckPointers (pbstrName);
	if(sc)
		return (sc);

	// init out parameter
	*pbstrName = NULL;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * the tab control itself doesn't have a name; otherwise, get the
	 * name of the requested tab
	 */
	LONG idChild = ValueOf (varChildID);
	if (idChild == CHILDID_SELF)
	{
		sc = S_FALSE;
	}
	else
	{
		CFolderTab& tab = GetItem (idChild-1);
		CComBSTR bstrName (tab.GetText());
		*pbstrName = bstrName.Detach();
	}

#ifdef DBG
	USES_CONVERSION;
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accName: child %d, returning \"%s\""),
		   idChild,
		   (*pbstrName) ? W2T(*pbstrName) : _T("<None>"));
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accValue
 *
 * Retrieves the value of the specified object. Not all objects have a value.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accValue(VARIANT varChildID, BSTR* pbstrValue)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accValue"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accValue"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * tabs don't have values
	 */
	sc = S_FALSE;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accDescription
 *
 * Retrieves a string that describes the visual appearance of the specified
 * object. Not all objects have a description.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accDescription(VARIANT varChildID, BSTR* pbstrDescription)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accDescription"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accDescription"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * tabs don't have descriptions
	 */
	sc = S_FALSE;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accRole
 *
 * Retrieves information that describes the role of the specified object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accRole(VARIANT varChildID, VARIANT *pvarRole)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accRole"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accRole"));

	sc = ScCheckPointers (pvarRole);
	if(sc)
		return (sc);

	// init out parameter
	VariantInit (pvarRole);

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * the tab control has a "page tab list" role; an individual tab has a
	 * "page tab" role
	 */
	V_VT(pvarRole) = VT_I4;
	V_I4(pvarRole) = (ValueOf (varChildID) == CHILDID_SELF)
						? ROLE_SYSTEM_PAGETABLIST
						: ROLE_SYSTEM_PAGETAB;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accState
 *
 * Retrieves the current state of the specified object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accState(VARIANT varChildID, VARIANT *pvarState)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accState"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	LONG idChild = ValueOf (varChildID);

	/*
	 * all items are focusable
	 */
	V_VT(pvarState) = VT_I4;
	V_I4(pvarState) = STATE_SYSTEM_FOCUSABLE;

	/*
	 * is this for a tab?
	 */
	if (idChild != CHILDID_SELF)
	{
		/*
		 * all tabs are selectable
		 */
		V_I4(pvarState) |= STATE_SYSTEM_SELECTABLE;

		/*
		 * if this is the selected item, give it the selected state
		 */
		if ((idChild - 1 /*1-based*/) == GetSelectedItem())
		{
			V_I4(pvarState) |= STATE_SYSTEM_SELECTED;

			/*
			 * if the tab control also has the focus, give the selected
			 * item the focused state as well
			 */
			if (m_fHaveFocus)
				V_I4(pvarState) |= STATE_SYSTEM_FOCUSED;
		}
	}
	else
	{
		if (m_fHaveFocus)
			V_I4(pvarState) |= STATE_SYSTEM_FOCUSED;
	}

	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accState: child %d, returning 0x%08x"), idChild, V_I4(pvarState));
	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accHelp
 *
 * Retrieves an object's Help property string. Not all objects need to
 * support this property.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accHelp(VARIANT varChildID, BSTR* pbstrHelp)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accHelp"));

	sc = ScCheckPointers (pbstrHelp);
	if (sc)
		return (sc);

	/*
	 * no help
	 */
	*pbstrHelp = NULL;

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accHelpTopic
 *
 * Retrieves the full path of the WinHelp file associated with the specified
 * object and the identifier of the appropriate topic within that file. Not
 * all objects need to support this property.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChildID, long* pidTopic)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accHelpTopic"));

	sc = ScCheckPointers (pbstrHelpFile, pidTopic);
	if (sc)
		return (sc);

	/*
	 * no help topic
	 */
	*pbstrHelpFile = NULL;
	*pidTopic      = 0;

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accKeyboardShortcut
 *
 * Retrieves the specified object's shortcut key or access key (also known
 * as the mnemonic). All objects that have a shortcut key or access key
 * should support this property.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accKeyboardShortcut(VARIANT varChildID, BSTR* pbstrKeyboardShortcut)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accKeyboardShortcut"));

	sc = ScCheckPointers (pbstrKeyboardShortcut);
	if (sc)
		return (sc);

	/*
	 * no shortcut keys
	 */
	*pbstrKeyboardShortcut = NULL;

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accFocus
 *
 * Retrieves the object that has the keyboard focus.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accFocus(VARIANT * pvarFocusChild)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accFocus"));

	sc = ScCheckPointers (pvarFocusChild);
	if (sc)
		return (sc);

	/*
	 * if we have the focus, return the (1-based) ID of the selected tab;
	 * otherwise, return VT_EMPTY
	 */
	if (m_fHaveFocus)
	{
		V_VT(pvarFocusChild) = VT_I4;
		V_I4(pvarFocusChild) = GetSelectedItem() + 1;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accFocus: returning %d"), V_I4(pvarFocusChild));
	}
	else
	{
		V_VT(pvarFocusChild) = VT_EMPTY;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accFocus: returning VT_EMPTY"));
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accSelection
 *
 * Retrieves the selected children of this object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accSelection(VARIANT * pvarSelectedChildren)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accSelection"));

	sc = ScCheckPointers (pvarSelectedChildren);
	if (sc)
		return (sc);

	/*
	 * return the (1-based) ID of the selected tab, if there is one
	 */
	if (GetSelectedItem() != -1)
	{
		V_VT(pvarSelectedChildren) = VT_I4;
		V_I4(pvarSelectedChildren) = GetSelectedItem() + 1;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accSelection: returning %d"), V_I4(pvarSelectedChildren));
	}
	else
	{
		V_VT(pvarSelectedChildren) = VT_EMPTY;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accSelection: returning VT_EMPTY"));
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scget_accDefaultAction
 *
 * Retrieves a string that describes the object's default action. Not all
 * objects have a default action.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scget_accDefaultAction(VARIANT varChildID, BSTR* pbstrDefaultAction)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scget_accDefaultAction"));

	sc = ScCheckPointers (pbstrDefaultAction);
	if (sc)
		return (sc);

	/*
	 * default to "no default action"
	 */
	*pbstrDefaultAction = NULL;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * individual tabs have a default action of "Switch", just like WC_TABCONTROL
	 */
	if (ValueOf(varChildID) != CHILDID_SELF)
	{
		CString strDefaultAction (MAKEINTRESOURCE (IDS_TabAccessiblity_DefaultAction));
		CComBSTR bstrDefaultAction (strDefaultAction);

		*pbstrDefaultAction = bstrDefaultAction.Detach();
	}
	else
	{
		sc = S_FALSE;	// no default action
	}

#ifdef DBG
	USES_CONVERSION;
	Trace (tagTabAccessibility, TEXT("CFolderTabView::Scget_accDefaultAction: child %d, returning \"%s\""),
		   ValueOf(varChildID),
		   (*pbstrDefaultAction) ? W2T(*pbstrDefaultAction) : _T("<None>"));
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccSelect
 *
 * Modifies the selection or moves the keyboard focus of the specified
 * object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccSelect(long flagsSelect, VARIANT varChildID)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccSelect"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccSelect"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	LONG idChild = ValueOf(varChildID);

	/*
	 * can't select the tab control itself, only child elements
	 */
	if (idChild == CHILDID_SELF)
		return (sc = E_INVALIDARG);

	/*
	 * the tab control doesn't support multiple selection, so reject
	 * requests dealing with multiple selection
	 */
	const long lInvalidFlags = SELFLAG_EXTENDSELECTION	|
							   SELFLAG_ADDSELECTION		|
							   SELFLAG_REMOVESELECTION;

	if (flagsSelect & lInvalidFlags)
		return (sc = E_INVALIDARG);

	/*
	 * activate this view, if we're requested to take the focus
	 */
	if (flagsSelect & SELFLAG_TAKEFOCUS)
	{
		CFrameWnd* pFrame = GetParentFrame();
		sc = ScCheckPointers (pFrame, E_FAIL);
		if (sc)
			return (sc);

		pFrame->SetActiveView (this);
	}

	/*
	 * select the given tab, if requested
	 */
	if (flagsSelect & SELFLAG_TAKESELECTION)
	{
		if (SelectItem (idChild - 1 /*0-based*/, true /*bEnsureVisible*/) == -1)
			return (sc = E_FAIL);
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccLocation
 *
 * Retrieves the specified object's current screen location.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccLocation (
	long*	pxLeft,
	long*	pyTop,
	long*	pcxWidth,
	long*	pcyHeight,
	VARIANT	varChildID)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccLocation"));
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccLocation"));

	sc = ScCheckPointers (pxLeft, pyTop, pcxWidth, pcyHeight);
	if(sc)
		return (sc);

	// init out parameters
	*pxLeft = *pyTop = *pcxWidth = *pcyHeight = 0;

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	LONG idChild = ValueOf(varChildID);
	CRect rectLocation;

	/*
	 * for the tab control itself, get the location of the entire window
	 */
	if (idChild == CHILDID_SELF)
		GetWindowRect (rectLocation);

	/*
	 * otherwise, get the rectangle of the tab and convert it to screen coords
	 */
	else
	{
		rectLocation = GetItem(idChild-1).GetRect();
		MapWindowPoints (NULL, rectLocation);
	}

	*pxLeft    = rectLocation.left;
	*pyTop     = rectLocation.top;
	*pcxWidth  = rectLocation.Width();
	*pcyHeight = rectLocation.Height();

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccNavigate
 *
 * Traverses to another user interface element within a container and if
 * possible, retrieves the object.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccNavigate (long lNavDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccNavigate"));

	sc = ScCheckPointers (pvarEndUpAt);
	if (sc)
		return (sc);

	// init out parameters
	VariantInit (pvarEndUpAt);

	sc = ScValidateChildID (varStart);
	if (sc)
		return (sc);

	LONG idFrom = ValueOf (varStart);
	LONG idTo   = -1;

	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccNavigate: start=%d, direction=%d"), idFrom, lNavDir);

	switch (lNavDir)
	{
		case NAVDIR_UP:
		case NAVDIR_DOWN:
			/*
			 * the tab control doesn't have the concept of up and down,
			 * so there's no screen element in that direction; just leave
			 * idTo == -1 and the code below the switch will take care
			 * of the rest
			 */
			break;

		case NAVDIR_FIRSTCHILD:
		case NAVDIR_LASTCHILD:
			/*
			 * NAVDIR_FIRSTCHILD and NAVDIR_LASTCHILD must be relative
			 * to CHILDID_SELF
			 */
			if (idFrom != CHILDID_SELF)
				return (sc = E_INVALIDARG);

			idTo = (lNavDir == NAVDIR_FIRSTCHILD) ? 1 : GetItemCount();
            break;

		case NAVDIR_LEFT:
		case NAVDIR_PREVIOUS:
			/*
			 * if we're moving relative to a child element, bump idTo;
			 * if not, just leave idTo == -1 and the code below the switch
			 * will take of the rest
			 */
			if (idFrom != CHILDID_SELF)
				idTo = idFrom - 1;
            break;

		case NAVDIR_RIGHT:
		case NAVDIR_NEXT:
			/*
			 * if we're moving relative to a child element, bump idTo;
			 * if not, just leave idTo == -1 and the code below the switch
			 * will take of the rest
			 */
			if (idFrom != CHILDID_SELF)
				idTo = idFrom + 1;
            break;

		default:
			return (sc = E_INVALIDARG);
			break;
	}

	/*
	 * if we're trying to navigate to an invalid child ID, return "no element
	 * in that direction"
	 */
	if ((idTo < 1) || (idTo > GetItemCount()))
	{
		V_VT(pvarEndUpAt) = VT_EMPTY;
		sc                = S_FALSE;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccNavigate: VT_EMPTY"));
	}

	/*
	 * otherwise return the new child ID (don't change the selection here;
	 * the client will call IAccessible::accSelect to do that)
	 */
	else
	{
		V_VT(pvarEndUpAt) = VT_I4;
		V_I4(pvarEndUpAt) = idTo;
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccNavigate: end=%d"), idTo);
	}

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccHitTest
 *
 * Retrieves the child element or child object at a given point on the screen.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccHitTest (long x, long y, VARIANT* pvarChildAtPoint)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccHitTest"));

	sc = ScCheckPointers (pvarChildAtPoint);
	if(sc)
		return (sc);

	// init out parameters
	VariantInit (pvarChildAtPoint);

	/*
	 * hit-test the given point, converted to client coordinates
	 */
	CPoint pt (x, y);
	ScreenToClient (&pt);
	int nHitTest = HitTest (pt);
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccHitTest: x=%d y=%d"), x, y);

	/*
	 * not on a tab?  see if it's within the client rect
	 */
	if (nHitTest == -1)
	{
		CRect rectClient;
		GetClientRect (rectClient);

		if (rectClient.PtInRect (pt))
		{
			V_VT(pvarChildAtPoint) = VT_I4;
			V_I4(pvarChildAtPoint) = CHILDID_SELF;
		}
		else
		{
			V_VT(pvarChildAtPoint) = VT_EMPTY;
			sc                     = S_FALSE;		// no element there
		}
	}

	/*
	 * otherwise, it is on a tab; return the 1-based ID
	 */
	else
	{
		V_VT(pvarChildAtPoint) = VT_I4;
		V_I4(pvarChildAtPoint) = nHitTest + 1;
	}

#ifdef DBG
	if (V_VT(pvarChildAtPoint) == VT_I4)
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccHitTest: returning %d"), ValueOf (*pvarChildAtPoint));
	else
		Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccHitTest: returning VT_EMPTY"));
#endif

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScaccDoDefaultAction
 *
 * Performs the specified object's default action. Not all objects have a
 * default action.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScaccDoDefaultAction (VARIANT varChildID)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScaccDoDefaultAction"));

	sc = ScValidateChildID (varChildID);
	if(sc)
		return (sc);

	/*
	 * the tab control doesn't have a default action
	 */
	LONG idChild = ValueOf (varChildID);
	Trace (tagTabAccessibility, TEXT("CFolderTabView::ScaccDoDefaultAction: child %d"), idChild);
	if (idChild == CHILDID_SELF)
		return (sc = E_INVALIDARG);

	/*
	 * select the given tab item
	 */
	if (SelectItem (idChild - 1 /*0-based*/, true /*bEnsureVisible*/) == -1)
		return (sc = E_FAIL);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scput_accName
 *
 * This is no longer supported. The SetWindowText or control-specific APIs
 * should be used in place of this method.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scput_accName(VARIANT varChildID, BSTR bstrName)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scput_accName"));

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = E_NOTIMPL);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::Scput_accValue
 *
 * This is no longer supported. Control-specific APIs should be used in
 * place of this method.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::Scput_accValue(VARIANT varChildID, BSTR bstrValue)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::Scput_accValue"));

	sc = ScValidateChildID (varChildID);
	if (sc)
		return (sc);

	return (sc = E_NOTIMPL);
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScValidateChildID
 *
 * Determines if the supplied variant represents a valid child ID.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScValidateChildID (VARIANT &var)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScValidateChildID"));

	/*
	 * child IDs must be VT_I4's
	 */
	if (V_VT(&var) != VT_I4)
		return (sc = E_INVALIDARG);

	return (ScValidateChildID (ValueOf(var)));
}


/*+-------------------------------------------------------------------------*
 * CFolderTabView::ScValidateChildID
 *
 * Determines if the supplied ID is valid child ID.
 *--------------------------------------------------------------------------*/

SC CFolderTabView::ScValidateChildID (LONG idChild)
{
	DECLARE_SC (sc, TEXT("CFolderTabView::ScValidateChildID"));

	/*
	 * child ID must be either CHILDID_SELF or a valid tab index
	 */
	if ((idChild < CHILDID_SELF) || (idChild > GetItemCount()))
		return (sc = E_INVALIDARG);

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\fontlink.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      fontlink.h
 *
 *  Contents:  Interface file for CFontLinker
 *
 *  History:   17-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef FONTLINK_H
#define FONTLINK_H
#pragma once

#include <string>
#include <mlang.h>
#include <comdef.h>


HFONT GetFontFromDC (HDC hdc);

class CRichText;


class CFontLinker
{
public:
    CFontLinker ();
    virtual ~CFontLinker ();

    LRESULT OnCustomDraw (NMCUSTOMDRAW* pnmcd);
    void ReleaseFonts ();
    bool ComposeRichText (CRichText& rt);

    IMultiLanguage* GetMultiLang ();
    IMLangFontLink* GetFontLink ();

    virtual bool IsAnyItemLocalizable () const
        { return (true); }

    virtual bool IsItemLocalizable (NMCUSTOMDRAW* pnmcd) const
        { return (true); }

    virtual UINT GetDrawTextFlags () const
        { return (DT_LEFT | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX | DT_SINGLELINE); }

    virtual std::wstring GetItemText (NMCUSTOMDRAW* pnmcd) const
        { return (L""); }

private:
    LRESULT OnCustomDraw_PrePaint     (NMCUSTOMDRAW* pnmcd);
    LRESULT OnCustomDraw_PostPaint    (NMCUSTOMDRAW* pnmcd);
    LRESULT OnCustomDraw_ItemPrePaint (NMCUSTOMDRAW* pnmcd);
    bool GetFontCodePages (HDC hdc, HFONT hFont, DWORD& dwFontCodePages);

    typedef std::set<HFONT>         FontSet;
    typedef std::map<HFONT, DWORD>  FontToCodePagesMap;

    FontSet             m_FontsToRelease;
    FontToCodePagesMap  m_CodePages;
    IMultiLanguagePtr   m_spMultiLang;
    IMLangFontLinkPtr   m_spFontLink;
	UINT				m_cPendingPostPaints;

    struct FontReleaser : public std::unary_function<HFONT, HRESULT>
    {
    public:
        FontReleaser (IMLangFontLink* pFontLink) : m_spFontLink (pFontLink) {}

        HRESULT operator() (HFONT hFont)
        {
            ASSERT (m_spFontLink != NULL);
            return (m_spFontLink->ReleaseFont (hFont));
        }

    private:
        IMLangFontLinkPtr const m_spFontLink;
    };
};


struct TextSegmentFontInfo
{
    HFONT   hFont;
    long    cch;
};


class CRichText
{
    friend class CFontLinker;

public:
    CRichText (HDC hdc, std::wstring strText)
        :   m_hdc          (hdc),
            m_strText      (strText),
            m_hDefaultFont (GetFontFromDC (hdc))
        {}

    ~CRichText ()
        {}

    bool IsDefaultFontSufficient () const
        { return (IsSingleFontSufficient() &&
                  GetSufficientFont() == m_hDefaultFont); }

    bool IsSingleFontSufficient () const
        { return (m_TextSegments.size() == 1); }

    HFONT GetSufficientFont () const
        { return (m_TextSegments.front().hFont); }

    bool Draw (
        LPCRECT rect,                       /* i:rect to draw in                */
        UINT    uFormat,                    /* i:DrawText format flags          */
        LPRECT  prectRemaining = NULL)      /* o:space remaining after drawing  */
        const;

private:
    typedef std::vector<TextSegmentFontInfo> TextSegmentFontInfoCollection;

    const HDC           m_hdc;
    const std::wstring  m_strText;
    const HFONT         m_hDefaultFont;

    TextSegmentFontInfoCollection m_TextSegments;
};


#endif /* FONTLINK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       HelpArr.h
//
//--------------------------------------------------------------------------
#ifndef _HELPARR_H_
#define _HELPARR_H_

#define IDH_DISABLEHELP ((DWORD)-1)

#define IDH_ADDSNAPIN_LV_SNAP_INS                       2001
#define IDH_PROPPAGE_CONSOLE_CHANGE_ICON                2002
#define IDH_PROPPAGE_CONSOLE_CONSOLE_ICON               2003
#define IDH_PROPPAGE_CONSOLE_CONSOLE_MODE               2004
#define IDH_PROPPAGE_CONSOLE_CONSOLE_MODE_DESCRIPTION   2005
#define IDH_PROPPAGE_CONSOLE_CUSTOM_TITLE               2006
#define IDH_PROPPAGE_CONSOLE_DONTSAVECHANGES            2007
#define IDH_URL_INPUT_URL_EDIT                          2008
#define IDH_ADDFAVORITE_ADDFAVFOLDER                    2009
#define IDH_ADDFAVORITE_FAVNAME                         2010
#define IDH_ADDFAVORITE_FAVTREE                         2011
#define IDH_FAVORGANIZE_ADDFAVFOLDER                    2012
#define IDH_FAVORGANIZE_FAVDELETE                       2013
#define IDH_FAVORGANIZE_FAVINFO                         2014
#define IDH_FAVORGANIZE_FAVMOVETO                       2015
#define IDH_FAVORGANIZE_FAVNAME                         2016
#define IDH_FAVORGANIZE_FAVRENAME                       2017
#define IDH_FAVORGANIZE_FAVTREE                         2018
#define IDH_FAVSELECTFOLDER_FAVTREE                     2019
#define IDH_LIST_SAVE_SEL                               2020
#define IDH_NEWFAVFOLDER_FAVFOLDER                      2021
#define IDH_PROPPAGE_CONSOLE_AllowViewCustomization     2022
#define IDH_DISKCLEANUP_DESCRIPTION                     1032
#define IDH_DELETE_TEMP_FILES                           1031


const DWORD g_aHelpIDs_IDD_URL_INPUT[]=
{
IDC_URL_EDIT,   IDH_URL_INPUT_URL_EDIT,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADDSNAPIN[]=
{
IDC_LV_SNAP_INS,    IDH_ADDSNAPIN_LV_SNAP_INS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_CONSOLE[]=
{
IDC_CONSOLE_MODE,   IDH_PROPPAGE_CONSOLE_CONSOLE_MODE,
IDC_CONSOLE_MODE_DESCRIPTION,   IDH_PROPPAGE_CONSOLE_CONSOLE_MODE_DESCRIPTION,
IDC_DONTSAVECHANGES,    IDH_PROPPAGE_CONSOLE_DONTSAVECHANGES,
IDC_CHANGE_ICON,    IDH_PROPPAGE_CONSOLE_CHANGE_ICON,
IDC_CUSTOM_TITLE,   IDH_PROPPAGE_CONSOLE_CUSTOM_TITLE,
IDC_CONSOLE_ICON,   IDH_PROPPAGE_CONSOLE_CONSOLE_ICON,
IDC_AllowViewCustomization, IDH_PROPPAGE_CONSOLE_AllowViewCustomization,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_DISK_CLEANUP[]=
{
IDC_DISKCLEANUP_DESCRIPTION,  IDH_DISKCLEANUP_DESCRIPTION,
IDC_DELETE_TEMP_FILES,        IDH_DELETE_TEMP_FILES,
IDC_DISKCLEANUP_OCCUPIED,     IDH_DISKCLEANUP_DESCRIPTION,
IDC_DISKCLEANUP_TO_DELETE,    IDH_DISKCLEANUP_DESCRIPTION,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADDFAVORITE[]=
{
IDC_FAVNAME,    IDH_ADDFAVORITE_FAVNAME,
IDC_FAVTREE,    IDH_ADDFAVORITE_FAVTREE,
IDC_ADDFAVFOLDER,   IDH_ADDFAVORITE_ADDFAVFOLDER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FAVORGANIZE[]=
{
IDC_ADDFAVFOLDER,   IDH_FAVORGANIZE_ADDFAVFOLDER,
IDC_FAVRENAME,  IDH_FAVORGANIZE_FAVRENAME,
IDC_FAVMOVETO,  IDH_FAVORGANIZE_FAVMOVETO,
IDC_FAVDELETE,  IDH_FAVORGANIZE_FAVDELETE,
IDC_FAVNAME,    IDH_FAVORGANIZE_FAVNAME,
IDC_FAVINFO,    IDH_FAVORGANIZE_FAVINFO,
IDC_FAVTREE,    IDH_FAVORGANIZE_FAVTREE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FAVSELECTFOLDER[]=
{
IDC_FAVTREE,    IDH_FAVSELECTFOLDER_FAVTREE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_LIST_SAVE[]=
{
IDC_SEL,    IDH_LIST_SAVE_SEL,
    0, 0
};

const DWORD g_aHelpIDs_IDD_NEWFAVFOLDER[]=
{
IDC_FAVFOLDER,  IDH_NEWFAVFOLDER_FAVFOLDER,
    0, 0
};


// Handle context sensitive dialog help for the conui subsystem
void HelpWmHelp(LPHELPINFO pHelpInfo, const DWORD* pHelpIDs);
void HelpContextMenuHelp(HWND hWnd, ULONG_PTR p);

#define ON_MMC_CONTEXT_HELP()                                                   \
        ON_MESSAGE(WM_HELP,          OnWmHelp)                                  \
        ON_MESSAGE(WM_CONTEXTMENU,   OnWmContextMenu)                           \


#define IMPLEMENT_CONTEXT_HELP(g_helpIds)                                         \
                                                                                  \
LRESULT OnWmHelp(WPARAM wParam, LPARAM lParam)                                    \
{                                                                                 \
    HelpWmHelp(reinterpret_cast<LPHELPINFO>(lParam), g_helpIds);                  \
    return true;                                                                  \
}                                                                                 \
                                                                                  \
LRESULT OnWmContextMenu(WPARAM wParam, LPARAM lParam)                             \
{                                                                                 \
    HelpContextMenuHelp((HWND)wParam,                                             \
                        (ULONG_PTR)(LPVOID) g_helpIds);                           \
    return TRUE;                                                                  \
}



#endif // _HELPAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\histlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       histlist.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "histlist.h"
#include "cstr.h"
#include "amcmsgid.h"
#include "websnk.h"
#include "webctrl.h"


//############################################################################
//############################################################################
//
//  Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagHistory(TEXT("History"), TEXT("History"));

LPCTSTR SzHistoryEntryType(CHistoryEntry &entry)
{
    if(entry.IsListEntry())
        return TEXT("ListView");

    else if(entry.IsOCXEntry())
        return TEXT("OCXView ");

    else if(entry.IsWebEntry())
        return TEXT("WebView ");

    else
        ASSERT(0 && "Should not come here");
        return TEXT("Illegal entry");
}

#define TraceHistory(Name, iter)                                                                                           \
        {                                                                                                                  \
            USES_CONVERSION;                                                                                               \
            Trace(tagHistory, TEXT("%s hNode = %d, %s, viewMode = %d, strOCX = \"%s\" iterator = %d "), \
                Name, iter->hnode, SzHistoryEntryType(*iter), iter->viewMode,                                         \
                TEXT(""), (LPARAM) &*iter);                                             \
        }

#else  // DBG

#define TraceHistory(Name, iter)

#endif // DBG


//############################################################################
//############################################################################
//
//  Implementation of class CHistoryEntry
//
//############################################################################
//############################################################################

bool
CHistoryEntry::operator == (const CHistoryEntry &other) const
{
    if( hnode != other.hnode)
        return false;

    if( guidTaskpad != other.guidTaskpad)
        return false;

    if(resultViewType != other.resultViewType) // NOTE: implement operator == for CResultViewType.
        return false;

    return true;
}

bool
CHistoryEntry::operator != (const CHistoryEntry &other) const
{
    return !operator == (other);
}


//############################################################################
//############################################################################
//
//  Implementation of class CHistoryList
//
//############################################################################
//############################################################################


int CHistoryList::s_nPageBreak = 0;

CHistoryList::CHistoryList(CAMCView* pAMCView)
: m_bBrowserBackEnabled(false),
  m_bBrowserForwardEnabled(false),
  m_pWebViewCtrl(NULL),
  m_bPageBreak(false),
  m_bWithin_CHistoryList_Back(false),
  m_bWithin_CHistoryList_Forward(false),
  m_bNavigateAfterPageBreak(false)
{
    m_pView = pAMCView;
    m_iterCurrent  = m_entries.begin();
    m_navState    = MMC_HISTORY_READY; // not busy

}
CHistoryList::~CHistoryList()
{
}

SC
CHistoryList::ScOnPageBreak(int nPageBreakID)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScOnPageBreak"));

    // handle recursion
    if(MMC_HISTORY_PAGE_BREAK == m_navState)
    {
        USES_CONVERSION;
        Trace(tagHistory, _T("OnPageBreak() - while inserting pagebreak"));

        // we were trying to navigate to a page break
        if(m_bNavigateAfterPageBreak)
        {
            m_bNavigateAfterPageBreak = false;
            m_pWebViewCtrl->Navigate( OLE2CT(m_szURLToNavigate.data()), NULL );
        }

        m_navState = MMC_HISTORY_READY;
        return sc;
    }

    bool bHandled = false;

    //Page breaks are only hit if navigating out of a current web entry.  The web
    //entry keeps track of the bounding page breaks.  From this, we can determine
    //whether we are navigating forward or backwards in history
    ASSERT(m_iterCurrent->IsWebEntry());
    bool bCurrentStateIsForward = (nPageBreakID > m_iterCurrent->prevPageBreakID);

    if(bCurrentStateIsForward)
    {
        Trace(tagHistory, _T("OnPageBreak() - while going Forward"));
        Forward(bHandled, false);
    }
    else
    {
        Trace(tagHistory, _T("OnPageBreak() - while going Back"));
        Back(bHandled, false);
    }

    if(!bHandled)
    {
        Trace(tagHistory, _T("OnPageBreak() - unhandled, passing back to web browser"));
        if (bCurrentStateIsForward)
            GetWebViewCtrl()->Forward();
        else
            GetWebViewCtrl()->Back();
    }

    return sc;
}

void
CHistoryList::OnPageBreakStateChange(bool bPageBreak)
{
    m_bPageBreak = bPageBreak;

    return;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::OnBrowserStateChange
 *
 * PURPOSE:     Callback that receives events from the IE control that the
 *              forward/back button needs to be enabled/disabled. A
 *              combination of this information with any non-HTML states in the
 *              history list is used to enable/disable the actual UI.
 *
 * PARAMETERS:
 *    bool  bForward :
 *    bool  bEnable :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::OnBrowserStateChange(bool bEnableForward, bool bEnableBack)
{
#if DBG
    CStr strTrace;
    strTrace.Format(_T("OnBrowserStateChange() - bEnableForward = %s, bEnableBack = %s"),
                    bEnableForward ? _T("true") : _T("false"), 
                    bEnableBack  ? _T("true") : _T("false"));
    Trace(tagHistory, strTrace);
#endif

    // handle the forward case.
    if(m_bBrowserForwardEnabled && !bEnableForward && !m_bPageBreak)
    {
        // the button was originally enabled but is now disabled.
        // This means that the user branched forward. So we need to throw away
        // any history ahead of the present time.
        if(m_iterCurrent != m_entries.end())
        {
            iterator iterTemp = m_iterCurrent;
            TraceHistory(TEXT("CHistoryList::Deleting all subsequent entries after"), iterTemp);
            ++iterTemp;
            m_entries.erase(iterTemp, m_entries.end());
        }
    }

    m_bBrowserForwardEnabled = bEnableForward;
    m_bBrowserBackEnabled    = bEnableBack;

    MaintainWebBar();
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::IsFirst
 *
 * PURPOSE:
 *
 * RETURNS:
 *    BOOL: TRUE if we should not light up the "Back" button.
 *
 *+-------------------------------------------------------------------------*/
BOOL
CHistoryList::IsFirst()
{
    return (m_iterCurrent == m_entries.begin());
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::IsLast
 *
 * PURPOSE:
 *
 * RETURNS:
 *    BOOL : TRUE if we should not light up the "Forward" button
 *
 *+-------------------------------------------------------------------------*/
BOOL
CHistoryList::IsLast()
{
    // see notes above
    if(m_iterCurrent == m_entries.end())
        return TRUE;

    // find next unique entry, if any
    iterator iter = m_iterCurrent;
    ++iter;            // this must exist, we've already taken care of the end case.
    return(iter == m_entries.end());
}

SC
CHistoryList::ScDoPageBreak()
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScDoPageBreak"));

    sc = ScCheckPointers(GetWebViewCtrl());
    if(sc)
        return sc;

    Trace(tagHistory, _T("ScDoPageBreak()"));

    // navigate to the "break" page.
    m_navState = MMC_HISTORY_PAGE_BREAK;


    CStr strResultPane;
    sc = ScGeneratePageBreakURL (strResultPane);
    if (sc)
        return (sc);

    GetWebViewCtrl()->Navigate(strResultPane, NULL);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScAddEntry
 *
 * PURPOSE: Adds a history entry
 *
 * PARAMETERS:
 *    CResultViewType & rvt :
 *    int               viewMode:       The list view mode (large icon, etc)
 *    GUID &            guidTaskpad :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScAddEntry(CResultViewType &rvt, int viewMode, GUID &guidTaskpad)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScAddEntry"));

    if(m_navState != MMC_HISTORY_READY)
    {
#ifdef DBG
        CHistoryEntry entry;
        entry.viewMode = viewMode;
        entry.resultViewType = rvt;
        entry.guidTaskpad = guidTaskpad;
        TraceHistory(TEXT("CHistoryList::Busy-RejectEntry"), (&entry));
#endif //DBG
        MaintainWebBar();
        return sc;
    }

    BOOL bIsWebEntry = rvt.HasWebBrowser();

    // must be in the MMC_HISTORY_READY state at this point, ie not busy.
    // figure out current node
    HNODE hnode = m_pView->GetSelectedNode();
    if(hnode == NULL)
        return sc; // not initialized yet

   /*  if selection change includes the web page (either as 'from' or 'to' node)
    *  we need to perform proper separation of the webentries by inserting the pagebreaks.
    *  This is to be done to ensure 2 goals:
    *   - to detect when navigation should leave the IE history and use MMC history navigation
    *   - to ensure we always leave IE only after navigating to a pagebreak - to stop the
    *     scripts on the page as soon as we hide it. to achieve that we need pagebreaks
    *     before every web page and after every web page.
    *
    *  to do so we need one of the following:
    *
    *  1. Add a pagebreak (used when selection changes from the web page to non-web view)
    *  2. Add a pagebreak and navigate 
    *       (a. when selection changes from web page to another web page)
    *       (b. when selection changes from non-web view to the webpage 
    *        and it is the first web page in the history)
    *  3. Navigate only. ( when selection changes from non-web view to the 
    *       webpage [except #2.b case] - pagebreak had to be added when leaving the 
    *       previous web page)
    *
    *   inverting the said will result in:
    *   - add a pagebreak if :
    *       C1: web page is a 'from' node (#1. and #2.a.)
    *       C2: web page is a 'to' node 
    *        && no previous web pages 
    *        && 'from' node is a non-web view (#2.b)
    *   - navigate to web page if:
    *       C3: "to' node is the web page
    */

    // see if we were in the web before this
    // Note: both following variables may be false (in case it there are no entries)
    bool bPreviousPageWasWeb = (m_entries.size() != 0) && m_iterCurrent->IsWebEntry();
    bool bPreviousPageWasNonWeb = (m_entries.size() != 0) && !bPreviousPageWasWeb;

    CHistoryEntry* prevWebPageEntry = GetPreviousWebPageEntry();

    // see if we need a pagebreak
    bool bNeedAPageBreak = false;
    if ( bPreviousPageWasWeb ) 
    {
        // condition C1 in the comment above
        bNeedAPageBreak = true;
    }
    else if ( bIsWebEntry && !prevWebPageEntry && bPreviousPageWasNonWeb ) 
    {
        // condition C2 in the comment above
        bNeedAPageBreak = true;
    }


    DeleteSubsequentEntries();

    // add an entry to the end of the list.
    CHistoryEntry entry;
    ZeroMemory(&entry, sizeof(entry));
    m_entries.push_back(entry);
    m_iterCurrent = m_entries.end();
    --m_iterCurrent;        // points to the newly inserted item.

    m_iterCurrent->viewMode       = viewMode;
    m_iterCurrent->guidTaskpad    = guidTaskpad;
    m_iterCurrent->hnode          = hnode;
    m_iterCurrent->resultViewType = rvt;

    //The lower bounding page break is recorded as the upper bound page break of the
    //previous web entry if one exists.
    //
    if(bIsWebEntry && prevWebPageEntry)
    {
        m_iterCurrent->prevPageBreakID = prevWebPageEntry->nextPageBreakID;
    }

    TraceHistory(TEXT("CHistoryList::AddEntry"), m_iterCurrent);


    m_bNavigateAfterPageBreak = false; // initialize
    
    // See the above comment. This if-else sequence does every possible combination
    if(bIsWebEntry && bNeedAPageBreak)
    {
        USES_CONVERSION;
        sc = ScDoPageBreak();
        if(sc)
            return sc;

        m_szURLToNavigate = rvt.GetURL();
        m_bNavigateAfterPageBreak = true;


        //This case is hit when there is no previous web entry in the history.  A new 
        //page break has been inserted before navigating to the URL.
        //The page break generator uses a pre-increment, so s_nPageBreak is the ID of the
        //newly generated page break;
        m_iterCurrent->prevPageBreakID = s_nPageBreak;
    }
    else if(bIsWebEntry && !bNeedAPageBreak)
    {
        USES_CONVERSION;
        m_pWebViewCtrl->Navigate( OLE2CT( rvt.GetURL() ), NULL );

    }
    else if(!bIsWebEntry && bNeedAPageBreak)
    {
        sc = ScDoPageBreak();
        if(sc)
            return sc;

        if (prevWebPageEntry)
        {
            //currently in a web entry and are navigating out of it,
            //so the newly generated page break is an upper bound
            //for the web entry.
            prevWebPageEntry->nextPageBreakID = s_nPageBreak;
        }
    }
    else // (!bIsWebEntry && !bNeedAPageBreak)
    {
        // do nothing
    }

    Compact();
    MaintainWebBar();
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::DeleteSubsequentEntries
 *
 * PURPOSE: When a new entry is inserted, all subsequent entries need to be
 *          deleted, because a new branch has been taken.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::DeleteSubsequentEntries()
{
    if(m_iterCurrent == m_entries.end())
        return; // nothing to do.

    iterator iterTemp = m_iterCurrent;
    ++iterTemp;

    while(iterTemp != m_entries.end())
    {
        iterator iterNext = iterTemp;
        ++iterNext; // point to the next element.

        TraceHistory(TEXT("CHistoryList::DeleteSubsequentEntries"), iterTemp);

        m_entries.erase(iterTemp);
        iterTemp = iterNext;
    }

    // the current entry must be the last at this stage.
    #ifdef DBG
    {
        iterator iterTemp = m_iterCurrent;
        ++iterTemp;
        ASSERT(iterTemp == m_entries.end());
    }
    #endif

}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::Back
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    bool & bHandled :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CHistoryList::Back(bool &bHandled, bool bUseBrowserHistory)
{
    Trace(tagHistory, TEXT("Back()"));

    // change the state to indicate we are navigating back.
    // and assure it is reset on function exit
    m_bWithin_CHistoryList_Back = true;
    CAutoAssignOnExit<bool, false> auto_reset( m_bWithin_CHistoryList_Back );

    // if we're in browser mode AND
    // if the back button is enabled by the browser use browser history.
    if( (m_iterCurrent->IsWebEntry()) && bUseBrowserHistory)
    {
        if(m_bBrowserBackEnabled)
        {
            Trace(tagHistory, TEXT("Back() web entry - not handling"));
            bHandled = false;
            return S_OK;
        }
    }

    bHandled = true;

    // BOGUS assert - amcview calls Back when ALT <- is pressed
    // regardless of the state of the button.
    //ASSERT (m_iterCurrent != m_entries.begin());
    if(m_iterCurrent == m_entries.begin())
        return S_FALSE;

    --m_iterCurrent;

    HRESULT hr = ExecuteCurrent();
    if(FAILED(hr))
        return hr;

    if(m_iterCurrent->IsWebEntry())
    {
        if(m_bPageBreak)      // if we're at a page break, go past it.
        {
            Trace(tagHistory, TEXT("Back() - stepped on the pagebreak"));
            bHandled = false; // this tells the caller to use the Browser's Back button.
        }
    }

    return hr;
}


/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::Forward
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    bool & bHandled :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CHistoryList::Forward(bool &bHandled, bool bUseBrowserHistory)
{
    // change the state to indicate we are navigating forward.
    // and assure it is reset on function exit
    m_bWithin_CHistoryList_Forward = true;
    CAutoAssignOnExit<bool, false> auto_reset( m_bWithin_CHistoryList_Forward );

    // if we're in browser mode AND
    // if the forward button is enabled by the browser use browser history.
    if( (m_iterCurrent->IsWebEntry()) && bUseBrowserHistory)
    {
        if(m_bBrowserForwardEnabled)
        {
            bHandled = false;
            return S_OK;
        }
    }

    bHandled = true;

    //jmessec: 2002/05/23: This ASSERT should be valid now that we have test iterator code below,
    //since we should now never iterate past the end of our list. Consider putting it back in

    // BOGUS assert - amcview calls Forward when ALT -> is pressed
    //  regardless of the state of the Forward button.
    //ASSERT (m_iterCurrent != m_entries.end());
    if(m_iterCurrent == m_entries.end())
        return S_FALSE;

    //create a temporary iterator to probe whether or 
    //not we are already at the end of the hist list
    iterator iterTestHistoryEnd = m_iterCurrent; 

    ++iterTestHistoryEnd;

    if(iterTestHistoryEnd == m_entries.end())
    {
        return S_FALSE;
    }

    ++m_iterCurrent;

    HRESULT hr = ExecuteCurrent();
    if(FAILED(hr))
        return hr;

    if(m_iterCurrent->IsWebEntry())
    {
        if(m_bPageBreak)      // if we're at a page break, go past it.
            bHandled = false; // this tells the caller to use the Browser's Forward button.
    }

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ExecuteCurrent
 *
 * PURPOSE: Sets the state of MMC to that of the current History entry. Called
 *          by Back() and Forward().
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CHistoryList::ExecuteCurrent()
{
    DECLARE_SC(sc, TEXT("CHistoryList::ExecuteCurrent"));
    INodeCallback* pNC = m_pView->GetNodeCallback();
    MTNODEID id;

    TraceHistory(TEXT("CHistoryList::ExecuteCurrent"), m_iterCurrent);

    pNC->GetMTNodeID (m_iterCurrent->hnode, &id);
    m_navState = MMC_HISTORY_NAVIGATING;

    // store values to local variables to avoid losing them
    // when an entry is removed from history
    GUID guidTaskpad = m_iterCurrent->guidTaskpad;
    bool bIsListEntry = m_iterCurrent->IsListEntry();
    DWORD viewMode = m_iterCurrent->viewMode;

    m_pView->SelectNode (id, guidTaskpad);

    if(bIsListEntry)
    {
        sc = m_pView->ScChangeViewMode(viewMode);
        if (sc)
            sc.TraceAndClear();
    }

    m_navState = MMC_HISTORY_READY;

    MaintainWebBar();
    return sc.ToHr();
}

void CHistoryList::MaintainWebBar()
{
    bool bWebEntry = ((m_entries.size() != 0) && m_iterCurrent->IsWebEntry());

    UpdateWebBar ( HB_BACK,    ( bWebEntry && m_bBrowserBackEnabled    ) || !IsFirst());    // back
    UpdateWebBar ( HB_FORWARD, ( bWebEntry && m_bBrowserForwardEnabled ) || !IsLast () );   // forward
}

void CHistoryList::UpdateWebBar (HistoryButton button, BOOL bOn)
{
    DECLARE_SC (sc, _T("CHistoryList::UpdateWebBar"));

    if (NULL == m_pView)
    {
        sc = E_UNEXPECTED;
        return;
    }

    CStandardToolbar* pStandardToolbar = m_pView->GetStdToolbar();
    if (NULL == pStandardToolbar)
    {
        sc = E_UNEXPECTED;
        return;
    }

    switch (button)
    {
    case HB_BACK:
        sc = pStandardToolbar->ScEnableButton(IDS_MMC_WEB_BACK, bOn);
        break;
    case  HB_STOP:
        sc = pStandardToolbar->ScEnableButton(IDS_MMC_WEB_STOP, bOn);
        break;
    case  HB_FORWARD:
        sc = pStandardToolbar->ScEnableButton(IDS_MMC_WEB_FORWARD, bOn);
        break;
    }

}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScGetCurrentResultViewType
 *
 * PURPOSE: Returns the current history entry.
 *
 * PARAMETERS:
 *    CResultViewType & rvt :
 *    int&              viewMode :
 *    GUID &            guidTaskpad :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScGetCurrentResultViewType (CResultViewType &rvt, int& viewMode, GUID &guidTaskpad)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScGetCurrentResultViewType"));

    if(m_iterCurrent == m_entries.end())
        return (sc = E_FAIL); // should never happen

    rvt         = m_iterCurrent->resultViewType;
    viewMode    = m_iterCurrent->viewMode;
    guidTaskpad = m_iterCurrent->guidTaskpad;

    return sc;
}

void CHistoryList::SetCurrentViewMode (long nViewMode)
{
    if(m_navState != MMC_HISTORY_READY)
        return;
    if(m_iterCurrent == m_entries.end())
        return;

    m_iterCurrent->viewMode = nViewMode;
}

void CHistoryList::Clear()
{
    Trace(tagHistory, TEXT("Clear"));
    m_entries.erase(m_entries.begin(), m_entries.end());
    m_iterCurrent = m_entries.begin();
    MaintainWebBar();
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScModifyViewTab
 *
 * PURPOSE: Adds an entry to the history list, which is the same as the current
 *          entry, except that the changes specified by the dwFlags and history
 *          entry parameters are applied
 *
 * PARAMETERS:
 *    const GUID& guidTab :      Specifies guid of selected view tab
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScModifyViewTab(const GUID& guidTab)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScAddModifiedEntry"));

    // we are not going to modify anything if we navigating "Back" or ""Forward" 
    // thru the history enries
    if ( m_bWithin_CHistoryList_Back || m_bWithin_CHistoryList_Forward )
        return sc;

    if( m_iterCurrent == m_entries.end() )
    {
        return (sc = E_UNEXPECTED);
    }

    // for web we cannot add new entries without reselecting the node
    // (same is true about deleting subsequen entries)
    // since that would make MMC and IE histories out of sync
    // instead we just modify the current history entry
    
    if ( !m_iterCurrent->IsWebEntry() ) // in case it is a regular entry
    {
        DeleteSubsequentEntries();  // delete everything ahead of this one.

        // add an entry to the end of the list.
        CHistoryEntry entry;
        ZeroMemory(&entry, sizeof(entry));
        m_entries.push_back(entry);
        iterator iterNew = m_entries.end();
        --iterNew;  // point to the new entry.

        // create a duplicate of the current entry.
        *iterNew = *m_iterCurrent;

        //set the pointer.
        m_iterCurrent = iterNew;
    }

    // change the guid of the tab.
    m_iterCurrent->guidTaskpad = guidTab;

    // we're done.
    Compact();
    MaintainWebBar();
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::ScChangeViewMode
 *
 * PURPOSE: Changes the view mode of the current entry. Changing the view
 *          mode does not add a new entry. Instead, history remembers the last
 *          view mode that a node was at and always restores to that
 *
 * PARAMETERS:
 *    int  viewMode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHistoryList::ScChangeViewMode(int viewMode)
{
    DECLARE_SC(sc, TEXT("CHistoryList::ScChangeViewMode"));

    if( m_iterCurrent == m_entries.end() )
    {
        return (sc = E_UNEXPECTED);
    }

    m_iterCurrent->viewMode = viewMode; // set the view mode.

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::DeleteEntry
 *
 * PURPOSE: Deletes all entries for a node from the history list.
 *
 * PARAMETERS:
 *    HNODE  hnode :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::DeleteEntry (HNODE hnode)
{
    for(iterator i= m_entries.begin(); i != m_entries.end(); )
    {
        if(i->hnode == hnode)
        {
            iterator iNext = i;
            ++iNext;
            if(m_iterCurrent==i)
                m_iterCurrent=iNext;
            TraceHistory(TEXT("CHistoryList::Deleting entry"), i);
            m_entries.erase(i);

            i= iNext;
        }
        else
        {
            ++i;
        }
    }
    Compact();
    MaintainWebBar();
}

/*+-------------------------------------------------------------------------*
 *
 * CHistoryList::Compact
 *
 * PURPOSE: 1) Removes redundancies in the history list by eliminating duplicates.
 *          2) Ensures that a maximum of MAX_HISTORY_ENTRIES entries is retained.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CHistoryList::Compact()
{
    if (m_entries.size() == 0)
        return;

    // discard duplicates.
    for (iterator i= m_entries.begin(); i != m_entries.end(); )
    {
        iterator iNext = i;
        ++iNext;
        if(iNext == m_entries.end())
            break;

        // do not delete if it is a webentry (there is no way for us to tell IE
        // to delete that history entry).
        if ( (i->IsWebEntry() == false) && ( *i == *iNext))
        {
            if(m_iterCurrent==i)
                m_iterCurrent=iNext;

            TraceHistory(TEXT("CHistoryList::Deleting entry"), i);
            m_entries.erase(i);
            i = iNext;
        }
        else
        {
            ++i;
        }
    }

    iterator iter = m_entries.begin();
    iterator iterNext = iter;
    int nExcess = m_entries.size() - MAX_HISTORY_ENTRIES;
    while(nExcess-- > 0)
    {
        iterNext = iter;
        ++iterNext;

        if(iter == m_iterCurrent)   // make sure we don't delete the current entry.
            break;

        TraceHistory(TEXT("CHistoryList::Deleting entry"), i);
        m_entries.erase(iter);
        iter = iterNext;
    }
}

/***************************************************************************\
 *
 * METHOD:  CHistoryList::GetPreviousWebPageEntry
 *
 * PURPOSE: looks back to see if there are any web pages in the history
 *          up to the current mark (including it)
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CHistoryEntry* : Previous web entry if any, NULL otherwise    
 *
\***************************************************************************/
CHistoryEntry* CHistoryList::GetPreviousWebPageEntry()
{
    if ( m_entries.size() && m_iterCurrent == m_entries.end() )
    {
        ASSERT(FALSE); // need to point to a valid entry !!!
        return NULL;
    }

    // will loop past the current entry.
    iterator end = m_iterCurrent;
    ++end;

    for ( iterator it = m_entries.begin(); it != end; ++it )
    {
        if ( it->IsWebEntry() )
            return it.operator->(); //Using operator -> to get a pointer to the History entry
    }

    return NULL;
}


/*+-------------------------------------------------------------------------*
 * ScGetPageBreakURL
 *
 * Returns the URL for MMC's HTML page containing a page break.
 *--------------------------------------------------------------------------*/

SC CHistoryList::ScGeneratePageBreakURL(CStr& strPageBreakURL)
{
    DECLARE_SC (sc, _T("ScGeneratePageBreakURL"));

    /*
     * clear out the old value, if any
     */
    strPageBreakURL.Empty();

    // generate new pagebreak URL every time ( prevent web browser from compacting it)
    strPageBreakURL.Format( _T("%s%d"),  PAGEBREAK_URL, ++s_nPageBreak );

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\histlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       histlist.h
//
//--------------------------------------------------------------------------

#pragma once

#ifndef _HISTORY_LIST_H
#define _HISTORY_LIST_H

#include <exdisp.h>
#include <mshtml.h>

#include "amcview.h"
#include "treectrl.h"
#include "resultview.h"

#include <windowsx.h>   // for globalallocptr macro


enum NavState
{
    MMC_HISTORY_READY      = 0,
    MMC_HISTORY_NAVIGATING = 1,
    MMC_HISTORY_BUSY       = 2,
    MMC_HISTORY_PAGE_BREAK = 3
};

enum HistoryButton
{
    HB_BACK                = -1,
    HB_STOP                = 0,
    HB_FORWARD             = 1
};


class CHistoryEntry
{
public:
    bool operator == (const CHistoryEntry &other) const;
    bool operator != (const CHistoryEntry &other) const;

    bool IsWebEntry()   {return resultViewType.HasWebBrowser();}
    bool IsListEntry()  {return resultViewType.HasList();}
    bool IsOCXEntry()   {return resultViewType.HasOCX();}

public:
    int              viewMode;       // valid only if the result view is a list. This field is not a part of CResultViewType because the snapin does not specify this.
    HNODE            hnode;          // currently selected node in scope tree
    GUID             guidTaskpad;    // the selected taskpad
    CResultViewType  resultViewType; // all the details about the result pane

    // PageBreakIDs are used to integrate with IE history. Each web entry owns a
    // bit of the IE history, which is bounded by 2 page break URLs.  The 
    // following properties keep track of these page break bounds.
    int              prevPageBreakID;// used only for Web Entries
    int              nextPageBreakID;// used only for Web Entries
};

/*+-------------------------------------------------------------------------*
 * class CHistoryList
 *
 *
 * PURPOSE: Maintains a list of all the states visited by the user for a view.
 *
 *+-------------------------------------------------------------------------*/
class CHistoryList
{
    typedef std::list<CHistoryEntry> HistoryEntryList;

    enum {MAX_HISTORY_ENTRIES = 100};

public:
    typedef HistoryEntryList::iterator iterator;

    CHistoryList(CAMCView* pView);
   ~CHistoryList();


    static SC ScGeneratePageBreakURL(CStr& strResultPane);

    void    Attach (CAMCWebViewCtrl* pWebViewCtrl)  {m_pWebViewCtrl = pWebViewCtrl;}
    BOOL    IsFirst();  // should we light up the "Back"    button?
    BOOL    IsLast();   // should we light up the "Forward" button?
    HRESULT Back   (bool &bHandled, bool bUseBrowserHistory = true);
    HRESULT Forward(bool &bHandled, bool bUseBrowserHistory = true);
    SC      ScAddEntry (CResultViewType &rvt, int viewMode, GUID &guidTaskpad); // adds new entry at current location
    void    DeleteEntry (HNODE hnode);
    SC      ScModifyViewTab(const GUID& guidTab);
    SC      ScChangeViewMode(int viewMode);
    void    MaintainWebBar();
    void    Compact();
    HRESULT ExecuteCurrent();
    void    UpdateWebBar (HistoryButton button, BOOL bOn);
    void    Clear();
    void    OnBrowserStateChange(bool bEnableForward, bool bEnableBack);
    SC      ScOnPageBreak(int nPageBreakID);
    SC      ScDoPageBreak();
    void    OnPageBreakStateChange(bool bPageBreak);
    void    DeleteSubsequentEntries();

    NavState GetNavigateState()                 { return m_navState; }
    void    SetNavigateState(NavState state)    { m_navState = state; }
    SC      ScGetCurrentResultViewType (CResultViewType &rvt, int& viewMode, GUID &guidTaskpad);
    void    SetCurrentViewMode (long nViewMode);

private:
    CAMCWebViewCtrl* GetWebViewCtrl()   {return m_pWebViewCtrl;}
    CHistoryEntry*   GetPreviousWebPageEntry();

private:
    iterator         m_iterCurrent;   // current index
    HistoryEntryList m_entries;       // array (note: using array-size doubling scheme)
    CAMCView*        m_pView;         // to get current node
    NavState         m_navState;      // TRUE when busy

    CAMCWebViewCtrl *m_pWebViewCtrl;  // used to navigate to a page break.

    bool             m_bBrowserForwardEnabled;
    bool             m_bBrowserBackEnabled;
    bool             m_bPageBreak;     // are we sitting at a page break right now?
    bool             m_bWithin_CHistoryList_Back; // to know "Back" is on stack
    bool             m_bWithin_CHistoryList_Forward; // to know "Forward" is on stack
    bool             m_bNavigateAfterPageBreak;      // should we navigate after a page break?
    wstring          m_szURLToNavigate;              // if m_bNavigateAfterPageBreak is true, this is the URL to navigate to.

    static int       s_nPageBreak; // used to generate unique URLs for page breaks
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\idle.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      idle.cpp
 *
 *  Contents:  Implementation file for CIdleTaskQueue
 *
 *  History:   13-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"

//############################################################################
//############################################################################
//
// Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagIdle(TEXT("IdleTaskQueue"), TEXT("IdleTaskQueue"));
#endif //DBG

//############################################################################
//############################################################################
//
// Implementation of CIdleTask
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CIdleTask);

CIdleTask::CIdleTask()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleTask);
}

CIdleTask::~CIdleTask()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CIdleTask);

}

CIdleTask::CIdleTask(const CIdleTask &rhs)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleTask);
    *this = rhs;
}

CIdleTask&
CIdleTask::operator= (const CIdleTask& rhs)
{
    return *this;
}


//############################################################################
//############################################################################
//
// Implementation of CIdleQueueEntry
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CIdleQueueEntry);

CIdleQueueEntry::CIdleQueueEntry(const CIdleQueueEntry &rhs)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    *this = rhs;
}


CIdleQueueEntry&
CIdleQueueEntry::operator= (const CIdleQueueEntry& rhs)
{
    m_pTask     = rhs.m_pTask;
    m_ePriority = rhs.m_ePriority;
    return (*this);
}


//############################################################################
//############################################################################
//
// Implementation of CIdleTaskQueue
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CIdleTaskQueue);

CIdleTaskQueue::CIdleTaskQueue()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleTaskQueue);
}

CIdleTaskQueue::~CIdleTaskQueue()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CIdleTaskQueue);

    while(!m_queue.empty())
    {
        CIdleTask *pIdleTask = m_queue.top().GetTask();
        m_queue.pop();

        ASSERT(pIdleTask != NULL);
        if(pIdleTask!=NULL)
        {
            delete pIdleTask;
        }
    }
}

/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::ScPushTask
 *
 *
 * Adds the given task the list of tasks to execute at idle time.
 *
 * S_OK     the task was added to the list.
 * S_FALSE  the task was merged with an existing task.
 * other    the task was not added to the list
 *
 *--------------------------------------------------------------------------*/

SC CIdleTaskQueue::ScPushTask (
    CIdleTask* pitToPush,
    IdleTaskPriority ePriority)
{
    SC   sc;
    ATOM idToPush;

    /*
     * validate the parameters
     */
    if (IsBadWritePtr (pitToPush, sizeof (*pitToPush)))
    {
        sc = E_POINTER;
        goto Error;
    }

    if ((ePriority < ePriority_Low) || (ePriority > ePriority_High))
    {
        ASSERT (false && "Invalid idle task priority");
        sc = E_INVALIDARG;
        goto Error;
    }

    sc = pitToPush->ScGetTaskID (&idToPush);
    if(sc)
        goto Error;

#ifdef DBG
    TCHAR szNameToPush[64];
    if (0 == GetAtomName (idToPush, szNameToPush, countof (szNameToPush)))
    {
        sc.FromLastError();
        goto Error;
    }
#endif

    /*
     * if we have tasks in the queue, look for one we can merge with
     */
    if (!m_queue.empty())
    {
        Queue::iterator it    = m_queue.begin();
        Queue::iterator itEnd = m_queue.end();

        while ( (!sc.IsError()) &&
               (it = FindTaskByID(it, itEnd, idToPush)) != itEnd)
        {
#ifdef DBG
            ATOM idMergeTarget;
            it->GetTask()->ScGetTaskID(&idMergeTarget);

            TCHAR szMergeTargetName[64];
            if (0 == GetAtomName (idMergeTarget, szMergeTargetName, countof (szMergeTargetName)))
            {
                sc.FromLastError();
                goto Error;
            }

            Trace (tagIdle, _T("%s (0x%08x) %smerged with %s (0x%08x) (%d idle tasks)"),
                 szNameToPush,
                 pitToPush,
                 (sc) ? _T("not ") : _T(""),
                 szMergeTargetName,
                 it->GetTask(),
                 m_queue.size());
#endif

            sc = it->GetTask()->ScMerge(pitToPush);
            if(sc==S_OK) //  successfully merged? just return
            {
                delete pitToPush;
                sc = S_FALSE;
                goto Cleanup;
            }

            // bump past the task we didn't merge with
            ++it;
        }
    }

    m_queue.push (CIdleQueueEntry (pitToPush, ePriority));

#ifdef DBG
    Trace (tagIdle, _T("%s (0x%08x) pushed, priority %d (%d idle tasks)"),
         szNameToPush,
         pitToPush,
         ePriority,
         m_queue.size());
#endif

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CIdleTaskQueue::ScPushTask"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::ScPerformNextTask
 *
 *
 * Performs the next task, if any.
 * Removes the highest priority idle task from the task list, and calls ScDoWork() on it.
 *
 *--------------------------------------------------------------------------*/
SC
CIdleTaskQueue::ScPerformNextTask ()
{
	DECLARE_SC (sc, _T("CIdleTaskQueue::ScPerformNextTask"));

    if (m_queue.empty())
		return (sc);

    CAutoPtr<CIdleTask> spIdleTask (m_queue.top().GetTask());
    if (spIdleTask == NULL)
		return (sc = E_UNEXPECTED);

    m_queue.pop();

#ifdef DBG
	ATOM idTask;
	spIdleTask->ScGetTaskID(&idTask);

	TCHAR szTaskName[64];
	if (0 == GetAtomName (idTask, szTaskName, countof (szTaskName)))
        return (sc.FromLastError());

	Trace (tagIdle, _T("Performing %s (0x%08x) (%d idle tasks remaining)"),
		 szTaskName,
		 (CIdleTask*) spIdleTask,
		 m_queue.size());
#endif

    sc = spIdleTask->ScDoWork();
    if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::ScGetTaskCount
 *
 * Returns the number of tasks in the idle list.
 *--------------------------------------------------------------------------*/

SC CIdleTaskQueue::ScGetTaskCount (LONG_PTR* plCount)
{
    SC sc;

    if (IsBadWritePtr (plCount, sizeof (*plCount)))
    {
        sc = E_POINTER;
        goto Error;
    }

    *plCount = m_queue.size();

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CIdleTaskQueue::ScGetTaskCount"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 * CIdleTaskQueue::FindTaskByID
 *
 *
 *--------------------------------------------------------------------------*/

CIdleTaskQueue::Queue::iterator CIdleTaskQueue::FindTaskByID (
    CIdleTaskQueue::Queue::iterator itFirst,
    CIdleTaskQueue::Queue::iterator itLast,
    ATOM                                idToFind)
{
    return (std::find_if (itFirst, itLast,
                          std::bind2nd (EqualTaskID(), idToFind)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\imagemap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       imagemap.h
//
//--------------------------------------------------------------------------

#ifndef __IMAGEMAP_H
#define __IMAGEMAP_H

#include "ndmgr.h"

class CImageIndexMapKey
{
public:
	COMPONENTID	m_ID;
	int			m_nIndex;

	CImageIndexMapKey()
	{
		m_ID = NULL;
		m_nIndex = 0;
	}

	CImageIndexMapKey(COMPONENTID ID, int nIndex)
	{
		m_ID = ID;
		m_nIndex = nIndex;
	}
};

typedef CImageIndexMapKey * PImageIndexMapKey;

template<>
inline UINT HashKey(PImageIndexMapKey keyPtr)
{
	return(((static_cast<UINT>(keyPtr->m_ID) << 16) & 0xFFFF0000)|
			(static_cast<UINT>(keyPtr->m_nIndex) & 0x0000FFFF));
}

template<>
inline void DestructElements(PImageIndexMapKey *keyArray, int nCount)
{
	for(int i=0;i<nCount;i++)
		delete keyArray[i];
}

template<>
inline BOOL CompareElements(const PImageIndexMapKey *p1, const PImageIndexMapKey *p2)
{
	return(((*p1)->m_ID == (*p2)->m_ID)&&((*p1)->m_nIndex == (*p2)->m_nIndex));
}

#define INITIAL_HASHSIZE 223

class CImageIndexMap : public CMap <PImageIndexMapKey, PImageIndexMapKey, int, int &>
{
public:
	CImageIndexMap()
	{
		InitHashTable(INITIAL_HASHSIZE);
	}
};

#undef INITIAL_HASHSIZE
#endif // __IMAGEMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\idle.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      idle.h
 *
 *  Contents:  Interface file for CIdleTaskQueue
 *
 *  History:   13-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef IDLE_H
#define IDLE_H
#pragma once

#include <queue>

typedef enum tagIdleTaskPriority
{
    ePriority_Low,
    ePriority_Normal,
    ePriority_High
} IdleTaskPriority;


class CIdleTask
{
public:
    CIdleTask();
    virtual ~CIdleTask();

    CIdleTask(const CIdleTask &rhs);
    CIdleTask&   operator= (const CIdleTask& rhs);

    virtual SC ScDoWork() = 0;
    virtual SC ScGetTaskID(ATOM* pID) = 0;

    /*
     * Merge from pitMergeFrom into the called idle task.
     *
     * S_OK     the tasks have been merged and pitMergeFrom can be discarded
     *
     * S_FALSE  these two tasks cannot be merged and you wish the idle task
     *          manager to continue searching for idle tasks into which
     *          pitMergeFrom can be merged.
     *
     * E_FAIL   these two tasks cannot be merged and you do not wish the idle
     *          task manager to continue searching for idle tasks into which
     *          pitMergeFrom can be merged.
     */
    virtual SC ScMerge(CIdleTask* pitMergeFrom) = 0;
};



class CIdleQueueEntry
{
public:
    CIdleQueueEntry () :
        m_ePriority (ePriority_Normal)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    }

    CIdleQueueEntry (CIdleTask *pIdleTask, IdleTaskPriority ePriority = ePriority_Normal) :
        m_pTask(pIdleTask), m_ePriority (ePriority)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    }

    ~CIdleQueueEntry()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CIdleQueueEntry);
    }

    CIdleQueueEntry(const CIdleQueueEntry &rhs);
    CIdleQueueEntry&   operator= (const CIdleQueueEntry& rhs);

    bool operator< (const CIdleQueueEntry& other) const
    {
        return (m_ePriority < other.m_ePriority);
    }

private:
    CIdleTask *         m_pTask;
    IdleTaskPriority    m_ePriority;

public:
    CIdleTask *         GetTask()      const {return m_pTask;}
    IdleTaskPriority    GetPriority () const {return m_ePriority;}

};


/*
 * Determines if a CIdleQueueEntry matches a given task ID.
 */
struct EqualTaskID : std::binary_function<CIdleQueueEntry, ATOM, bool>
{
    bool operator()(const CIdleQueueEntry& iqe, ATOM idToMatch) const
    {
        ATOM id;

        SC  sc = iqe.GetTask()->ScGetTaskID(&id);
        if(sc)
            return (false);

        return (id == idToMatch);
    }
};


/*
 * accessible_priority_queue - thin wrapper around std::prority_queue to
 * provide access to the container iterators
 */
template<class _Ty, class _C = std::vector<_Ty>, class _Pr = std::less<typename _C::value_type> >
class accessible_priority_queue : public std::priority_queue<_Ty, _C, _Pr>
{
public:
    typedef typename _C::iterator iterator;

    iterator begin()
        { return (c.begin()); }

    iterator end()
        { return (c.end()); }
};


class CIdleTaskQueue
{
public:
    CIdleTaskQueue();
    ~CIdleTaskQueue();


    // CIdleTaskManager methods
    SC ScPushTask     (CIdleTask* pitToPush, IdleTaskPriority ePriority);
    SC ScPerformNextTask();
    SC ScGetTaskCount (LONG_PTR* plCount);

private:
    typedef accessible_priority_queue<CIdleQueueEntry> Queue;

    Queue::iterator FindTaskByID (
        Queue::iterator itFirst,
        Queue::iterator itLast,
        ATOM            idToFind);

private:
    Queue   m_queue;

};

#endif /* IDLE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\kbdnav.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      kbdnav.cpp
 *
 *  Contents:  Implementation of CKeyboardNavDelayTimer
 *
 *  History:   4-May-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "kbdnav.h"


#ifdef DBG
CTraceTag tagKeyboardNavDelay (_T("Keyboard Navigation"), _T("Keyboard Navigation Delay"));
#endif


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::CKeyboardNavDelayTimer
 *
 * Constructs a CKeyboardNavDelayTimer object.
 *--------------------------------------------------------------------------*/

CKeyboardNavDelayTimer::CKeyboardNavDelayTimer () :
    m_nTimerID  (0)
{
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::~CKeyboardNavDelayTimer
 *
 * Destroys a CKeyboardNavDelayTimer object.
 *--------------------------------------------------------------------------*/

CKeyboardNavDelayTimer::~CKeyboardNavDelayTimer ()
{
    ScStopTimer();
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::TimerProc
 *
 * Callback function called when a timer started by this class fires.
 *--------------------------------------------------------------------------*/

VOID CALLBACK CKeyboardNavDelayTimer::TimerProc (
	HWND		hwnd,
	UINT		uMsg,
	UINT_PTR	idEvent,
	DWORD		dwTime)
{
	CTimerMap& TimerMap = GetTimerMap();

	/*
	 * locate the CKeyboardNavDelayTimer object corresponding to this timer event
	 */
    CTimerMap::iterator itTimer = TimerMap.find (idEvent);

    // ASSERT(itTimer != TimerMap.end());
    // The above assertion is not valid because: (From the SDK docs):
    // The KillTimer function does not remove WM_TIMER messages already posted to the message queue.

    if (itTimer != TimerMap.end())
    {
        CKeyboardNavDelayTimer *pNavDelay = itTimer->second;

		if (pNavDelay != NULL)
		{
			Trace (tagKeyboardNavDelay, _T ("Timer fired: id=%d"), pNavDelay->m_nTimerID);
			pNavDelay->OnTimer();
		}
    }
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::ScStartTimer
 *
 *
 *--------------------------------------------------------------------------*/

SC CKeyboardNavDelayTimer::ScStartTimer()
{
	DECLARE_SC (sc, _T("CKeyboardNavDelayTimer::ScStartTimer"));

    /*
     * shouldn't start a timer if it's started already
     */
    ASSERT (m_nTimerID == 0);

    /*
     * Get the menu popout delay and use that for the delay before
     * changing the result pane.  If the system doesn't support
     * SPI_GETMENUSHOWDELAY (i.e. Win95, NT4), use a value slightly
     * longer than the longer of keyboard repeat delay and keyboard
     * repeat rate.
     */
    DWORD dwDelay;

    if (!SystemParametersInfo (SPI_GETMENUSHOWDELAY, 0, &dwDelay, false))
    {
        /*
         * Get the keyboard delay and convert to milliseconds.  The ordinal
         * range is from 0 (approximately 250 ms dealy) to 3 (approximately
         * 1 sec delay).  The equation to convert from ordinal to approximate
         * milliseconds is:
         *
         *      msec = (ordinal + 1) * 250;
         */
        DWORD dwKeyboardDelayOrdinal;
        SystemParametersInfo (SPI_GETKEYBOARDDELAY, 0, &dwKeyboardDelayOrdinal, false);
        DWORD dwKeyboardDelay = (dwKeyboardDelayOrdinal + 1) * 250;

        /*
         * Get the keyboard speed and convert to milliseconds.  The ordinal
         * range is from 0 (approximately 2.5 reps per second, or 400 msec
         * interval) to 31 (approximately 30 reps per second, or 33 msec
         * interval).  (The documentation has this reversed.)  The equation
         * to convert from ordinal to approximate milliseconds is:
         *
         *      msec = (ordinal * -12) + 400;
         */
        DWORD dwKeyboardRateOrdinal;
        SystemParametersInfo (SPI_GETKEYBOARDSPEED,  0, &dwKeyboardRateOrdinal, false);
        DWORD dwKeyboardRate = (dwKeyboardRateOrdinal * -12) + 400;

        dwDelay = std::_MAX (dwKeyboardDelay, dwKeyboardRate) + 50;
    }

    m_nTimerID = SetTimer(NULL, 0, dwDelay, TimerProc);
	if (m_nTimerID == 0)
		return (sc.FromLastError());

    GetTimerMap()[m_nTimerID] = this; // set up the timer map.
    Trace (tagKeyboardNavDelay, _T("Started new timer: id=%d, delay=%d milliseconds"), m_nTimerID, dwDelay);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::ScStopTimer
 *
 * Stops the timer running for this CKeyboardNavDelayTimer, if it is running
 *--------------------------------------------------------------------------*/

SC CKeyboardNavDelayTimer::ScStopTimer()
{
	DECLARE_SC (sc, _T("CKeyboardNavDelayTimer::ScStopTimer"));

    if (m_nTimerID != 0)
    {
		CTimerMap&			TimerMap = GetTimerMap();
		CTimerMap::iterator	itTimer  = TimerMap.find (m_nTimerID);
		ASSERT (itTimer != TimerMap.end());

        TimerMap.erase (itTimer);
        Trace (tagKeyboardNavDelay, _T("Stopped timer: id=%d"), m_nTimerID);
        UINT_PTR nTimerID = m_nTimerID;
		m_nTimerID = 0;

        if (!KillTimer (NULL, nTimerID))
			return (sc.FromLastError());
    }

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CKeyboardNavDelayTimer::GetTimerMap
 *
 * Returns a reference to the data structure that maps timer IDs to
 * CKeyboardNavDelayTimer objects.
 *--------------------------------------------------------------------------*/

CKeyboardNavDelayTimer::CTimerMap& CKeyboardNavDelayTimer::GetTimerMap()
{
    static CTimerMap map;
    return (map);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\kbdnav.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      kbdnav.h
 *
 *  Contents:  Interface file for CKeyboardNavDelayTimer
 *
 *  History:   4-May-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#ifdef DBG
extern CTraceTag tagKeyboardNavDelay;
#endif

class CKeyboardNavDelayTimer
{
public:
	typedef std::map<UINT_PTR, CKeyboardNavDelayTimer*>  CTimerMap;

	CKeyboardNavDelayTimer();
   ~CKeyboardNavDelayTimer();

	SC ScStartTimer();
	SC ScStopTimer();
	virtual void OnTimer() = 0;

private:
	static VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
	static CTimerMap& GetTimerMap();

private:
	UINT_PTR	m_nTimerID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mainfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mainfrm.cpp
//
//  Contents:  Main frame for amc
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Add code to test switching views
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "AMC.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "treectrl.h"
#include "menubar.h"
#include "mdiuisim.h"
#include "toolbar.h"
#include "props.h"
#include "sysmenu.h"

#include "amcmsgid.h"
#include "HtmlHelp.h"

#include "strings.h"
#include "ndmgrp.h"
#include "amcmsgid.h"
#include "tbtrack.h"
#include "caption.h"
#include "scriptevents.h"


#ifdef DBG
CTraceTag tagMainFrame(TEXT("CMainFrame"), TEXT("Messages"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CMMCApplicationFrame
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CMMCApplicationFrame
 *
 *
 * PURPOSE: The COM 0bject that exposes the Frame interface off the Application object.
 *
 *+-------------------------------------------------------------------------*/
class CMMCApplicationFrame :
    public CMMCIDispatchImpl<Frame>,
    public CTiedComObject<CMainFrame>
{
    typedef CMainFrame CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CMMCApplicationFrame)
    END_MMC_COM_MAP()

    //Frame interface
public:
    STDMETHOD(Maximize)();
    STDMETHOD(Minimize)();
    STDMETHOD(Restore)();

    STDMETHOD(get_Left)(int *pLeft)      {return GetCoordinate(pLeft, eLeft);}
    STDMETHOD(put_Left)(int left)        {return PutCoordinate(left, eLeft);}

    STDMETHOD(get_Right)(int *pRight)    {return GetCoordinate(pRight, eRight);}
    STDMETHOD(put_Right)(int right)      {return PutCoordinate(right, eRight);}

    STDMETHOD(get_Top)(int *pTop)        {return GetCoordinate(pTop, eTop);}
    STDMETHOD(put_Top)(int top)          {return PutCoordinate(top, eTop);}

    STDMETHOD(get_Bottom)(int *pBottom)  {return GetCoordinate(pBottom, eBottom);}
    STDMETHOD(put_Bottom)(int bottom)    {return PutCoordinate(bottom, eBottom);}

private:
    enum eCoordinate { eLeft, eRight, eTop, eBottom };

    STDMETHOD(GetCoordinate)(int *pCoordinate, eCoordinate e);
    STDMETHOD(PutCoordinate)(int coordinate,   eCoordinate e);
};


/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::Maximize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::Maximize()
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::Maximize"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    // do the operation
    sc = pTiedObj->ScMaximize();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::Minimize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::Minimize()
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::Minimize"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    // do the operation
    sc = pTiedObj->ScMinimize();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::Restore
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::Restore()
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::Restore"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    sc = pTiedObj->ScRestore();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::GetCoordinate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    int *        pCoordinate :
 *    eCoordinate  e :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::GetCoordinate(int *pCoordinate, eCoordinate e)
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::GetCoordinate"));

    // check parameters
    if(!pCoordinate)
    {
        sc = E_POINTER;
        return sc.ToHr();
    }

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    RECT rect;

    // do the operation
    sc = pTiedObj->ScGetPosition(rect);
    if(sc)
        return sc.ToHr();

    switch(e)
    {
    case eTop:
        *pCoordinate = rect.top;
        break;

    case eBottom:
        *pCoordinate = rect.bottom;
        break;

    case eLeft:
        *pCoordinate = rect.left;
        break;

    case eRight:
        *pCoordinate = rect.right;
        break;

    default:
        ASSERT(0 && "Should not come here!!");
        break;
    }


    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplicationFrame::PutCoordinate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    int          coordinate :
 *    eCoordinate  e :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplicationFrame::PutCoordinate(int coordinate,   eCoordinate e)
{
    DECLARE_SC(sc, TEXT("CMMCApplicationFrame::PutCoordinate"));

    CMyTiedObject *pTiedObj = NULL;

    sc = ScGetTiedObject(pTiedObj);
    if(sc)
        return sc.ToHr();

    RECT rect;

    sc = pTiedObj->ScGetPosition(rect);
    if(sc)
        return sc.ToHr();

    switch(e)
    {
    case eTop:
        rect.top    = coordinate;
        break;

    case eBottom:
        rect.bottom = coordinate;
        break;

    case eLeft:
        rect.left   = coordinate;
        break;

    case eRight:
        rect.right  = coordinate;
        break;

    default:
        ASSERT(0 && "Should not come here!!");
        break;
    }


    sc = pTiedObj->ScSetPosition(rect);

    return sc.ToHr();
}

//############################################################################
//############################################################################
//
//  Misc declarations
//
//############################################################################
//############################################################################

static TBBUTTON MainButtons[] =
{
 { 0, ID_FILE_NEW           , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 0 },
 { 1, ID_FILE_OPEN          , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 1 },
 { 2, ID_FILE_SAVE          , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 2 },
 { 0, 0                     , TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, 0 },
 { 3, ID_WINDOW_NEW         , TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, 3 },
};


/*
 * remove the definition that WTL might have given us
 */
#ifdef ID_VIEW_REFRESH
#undef ID_VIEW_REFRESH
#endif

enum DoWeNeedThis
{
    ID_VIEW_REFRESH     =  12797
};

//############################################################################
//############################################################################
//
//  Implementation of class CMainFrame
//
//############################################################################
//############################################################################

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

// CODEWORK message reflection not working yet
BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_DRAWCLIPBOARD()
    ON_WM_CHANGECBCHAIN()
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateFilePrint)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_SETUP, OnUpdateFilePrintSetup)
    ON_WM_CLOSE()
    ON_COMMAND(ID_VIEW_TOOLBAR, OnViewToolbar)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, OnUpdateViewToolbar)
    ON_WM_SIZE()
    ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpTopics)
    ON_COMMAND(ID_VIEW_REFRESH, OnViewRefresh)
    ON_UPDATE_COMMAND_UI(ID_VIEW_REFRESH, OnUpdateViewRefresh)
    ON_WM_DESTROY()
    ON_WM_SYSCOMMAND()
    ON_WM_INITMENUPOPUP()
    ON_COMMAND(ID_CONSOLE_PROPERTIES, OnConsoleProperties)
    ON_WM_MOVE()
    ON_WM_ACTIVATE()
    ON_WM_NCACTIVATE()
    ON_WM_NCPAINT()
    ON_WM_PALETTECHANGED()
    ON_WM_QUERYNEWPALETTE()
    ON_COMMAND(ID_WINDOW_NEW, OnWindowNew)
    ON_WM_SETTINGCHANGE()
 	ON_WM_MENUSELECT()
    ON_MESSAGE(WM_UNINITMENUPOPUP, OnUnInitMenuPopup)
   //}}AFX_MSG_MAP

#ifdef DBG
    ON_COMMAND(ID_MMC_TRACE_DIALOG, OnMMCTraceDialog)
#endif

    ON_MESSAGE(WM_SETTEXT, OnSetText)

    ON_MESSAGE(MMC_MSG_PROP_SHEET_NOTIFY, OnPropertySheetNotify)
    ON_MESSAGE(MMC_MSG_SHOW_SNAPIN_HELP_TOPIC, OnShowSnapinHelpTopic)

    // The following entry is placed here for compatibilty with versions
    // of mmc.lib that were compiled with the incorrect value for message
    // MMC_MSG_SHOW_SNAPIN_HELP_TOPIC. MMC.lib function MMCPropertyHelp
    // sends this message to the mainframe window when called by a snap-in.

    ON_MESSAGE(MMC_MSG_SHOW_SNAPIN_HELP_TOPIC_ALT, OnShowSnapinHelpTopic)

END_MESSAGE_MAP()

//+-------------------------------------------------------------------
//
//  Member:      CMainFrame::OnMenuSelect
//
//  Synopsis:    Handles WM_MENUSELECT, sets status bar text for the
//               given menu item.
//
//  Arguments:   [nItemID] - the resource id of menu item.
//               [nFlags]  - MF_* flags
//               [hMenu]   -
//
//  Returns:     none
//
//--------------------------------------------------------------------
void CMainFrame::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hMenu)
{
    DECLARE_SC(sc, TEXT("CMainFrame::OnMenuSelect"));
    if (nFlags & MF_SYSMENU)
        return;

    CString strText = TEXT("");
    CString strStatusText;

	/*
	 * We need to handle special cases, most of the menu items have status text with them.
	 * The exception being, the favoties list, the windows list in windows menu and popup menus.
	 * The reason is the menu ids are not unique in main menu because we do TrackPopupMenu at
	 * three places first one for File, Window & Help menus done in menubar.cpp, second for
	 * Action & View menu in cmenu.cpp and third favorites menu in favui.cpp.
	 */

	/*
	 * Special case 1: Check to see if current menu is favorites menu, if so need to get status
	 * text for favorites list except for "Add to favorites.." and "Organize favorites.." items.
	 * The below test can break if "Add to Favorites..." is moved in menu resource.
	 */
	if ((IDS_ADD_TO_FAVORITES != nItemID) &&
		(IDS_ORGANIZEFAVORITES != nItemID) &&
		(GetMenuItemID(hMenu, 0) == IDS_ADD_TO_FAVORITES) )
	{
		strStatusText.LoadString(IDS_FAVORITES_ACTIVATE);
	}
	/*
	 * Special case 2: Handle any popup menus (popup menus dont have any ID).
	 */
    else if (nFlags & MF_POPUP)
	{
        // do nothing
	}
	// Special case 3: Assume mmc supports maximum of 1024 windows for status bar text sake.
    else if ( (nItemID >= AFX_IDM_FIRST_MDICHILD) && (nItemID <= AFX_IDM_FIRST_MDICHILD+1024) )
    {
        strStatusText.LoadString(ID_WINDOW_ACTIVATEWINDOW);
    }
	else
    {
        strText.LoadString(nItemID);

        int iSeparator = strText.Find(_T('\n'));
        if (iSeparator < 0) // No status text so use the menu text as status text.
            strStatusText = strText;
        else
            strStatusText = strText.Mid(iSeparator);
    }

    CChildFrame *pChildFrame = dynamic_cast<CChildFrame*>(GetActiveFrame());
    if (!pChildFrame)
        return;

    sc = pChildFrame->ScSetStatusText(strStatusText);
    if (sc)
        return;

	return;
}




/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScGetFrame
 *
 * PURPOSE: Returns a pointer to the COM object that implements the
 *          Frame interface.
 *
 * PARAMETERS:
 *    Frame **ppFrame :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScGetFrame(Frame **ppFrame)
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScGetFrame") );

    if(!ppFrame)
    {
        sc = E_POINTER;
        return sc;
    }

    *ppFrame = NULL;

    // NOTE the com object cannot be cached with a smart pointer owned by CMainFrame
    // since CMainFrame is VERY LONG living guy - it will lock mmc.exe from exitting
    // it could be used by creating CComObjectCached, but CTiedComObjectCreator does
    // not support that
    // see bug # 101564
    CComPtr<Frame> spFrame;
    // create a CMMCApplicationFrame if not already done so.
    sc = CTiedComObjectCreator<CMMCApplicationFrame>::ScCreateAndConnect(*this, spFrame);
    if(sc)
        return sc;

    if(spFrame == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    *ppFrame = spFrame.Detach();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScMaximize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScMaximize()
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScMaximize"));

    ShowWindow(SW_MAXIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScMinimize
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScMinimize()
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScMinimize"));

    ShowWindow(SW_MINIMIZE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScRestore
 *
 * PURPOSE:  Restores the position of the main frame.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScRestore()
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScRestore"));

    ShowWindow(SW_RESTORE);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScSetPosition
 *
 * PURPOSE: Sets the position of the main frame
 *
 * PARAMETERS:
 *    const  RECT :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScSetPosition(const RECT &rect)
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScSetPosition"));

    int width  = rect.right - rect.left + 1;
    int height = rect.bottom - rect.top + 1;

    SetWindowPos(NULL /*hWndInsertAfter*/, rect.left, rect.top, width, height, SWP_NOZORDER);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::ScGetPosition
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    RECT & rect :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMainFrame::ScGetPosition(RECT &rect)
{
    DECLARE_SC(sc, TEXT("CMainFrame::ScGetPosition"));

    GetWindowRect(&rect);

    return sc;
}



// OnActivate is overridden to work around a SQL snap-in problem under
// Win9x. When SQL tries to force focus back to its property sheet it
// causes an infinite recursion of the OnActivate call.
// This override discards any activation that occurs during the processing
// of a prior activation.
void CMainFrame::OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized )
{
    Trace(tagMainFrame, TEXT("OnActivate: nState=%d"), nState);

    static bActivating = FALSE;

    m_fCurrentlyActive = (nState != WA_INACTIVE);

    // if activating
    if (m_fCurrentlyActive)
    {
        CAMCApp* pApp = AMCGetApp();
        ASSERT(NULL != pApp);

        // if windows and we're already activating, prevent recursion
        if ( (NULL != pApp) && (pApp->IsWin9xPlatform() == true) && bActivating)
            return;

        // Process activation request
        bActivating = TRUE;
        CMDIFrameWnd::OnActivate(nState, pWndOther, bMinimized);
        bActivating = FALSE;
    }
    else
    {
        // if we have accelarators hilited (it happen when one press Alt+TAB)
        // we need to remove them now.
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));

        // Let unactivate through
        CMDIFrameWnd::OnActivate(nState, pWndOther, bMinimized);
    }
}


CAMCView* CMainFrame::GetActiveAMCView()
{
    CChildFrame *pChildFrame = dynamic_cast<CChildFrame*>(GetActiveFrame());
    if (!pChildFrame)
        return NULL;

    CAMCView* pAMCView = pChildFrame->GetAMCView();
    ASSERT(pAMCView != NULL);
    ASSERT(::IsWindow(*pAMCView));

    if (pAMCView && ::IsWindow(*pAMCView))
        return pAMCView;

    return NULL;
}

CAMCTreeView* CMainFrame::_GetActiveAMCTreeView()
{
    CAMCView* pAMCView = GetActiveAMCView();
    CAMCTreeView* pAMCTreeView = pAMCView ? pAMCView->GetTreeCtrl() : NULL;
    if (pAMCTreeView && ::IsWindow(*pAMCTreeView))
        return pAMCTreeView;

    return NULL;
}

void CMainFrame::OnDrawClipboard()
{
    if (m_hwndToNotifyCBChange != NULL &&
        ::IsWindow(m_hwndToNotifyCBChange))
    {
        ::SendMessage(m_hwndToNotifyCBChange, WM_DRAWCLIPBOARD, 0, 0);
        m_hwndToNotifyCBChange = NULL;
    }

    if (m_hwndNextCB != NULL &&
        ::IsWindow(m_hwndNextCB))
    {
        ::SendMessage(m_hwndNextCB, WM_DRAWCLIPBOARD, 0, 0);
    }

    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    if (pAMCDoc)
    {
        CAMCViewPosition pos = pAMCDoc->GetFirstAMCViewPosition();
        while (pos != NULL)
        {
            CAMCView* v = pAMCDoc->GetNextAMCView(pos);

            if (v && ::IsWindow(*v))
                v->OnUpdatePasteBtn();
        }
    }
}

void CMainFrame::OnChangeCbChain(HWND hWndRemove, HWND hWndAfter)
{
    if (m_hwndNextCB == hWndRemove)
        m_hwndNextCB = hWndAfter;
    else if (m_hwndNextCB != NULL && ::IsWindow(m_hwndNextCB))
        ::SendMessage(m_hwndNextCB, WM_CHANGECBCHAIN,
                      (WPARAM)hWndRemove, (LPARAM)hWndAfter);
}

void CMainFrame::OnWindowNew()
{
    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    ASSERT(pAMCDoc != NULL);
    if (pAMCDoc != NULL)
    {
        pAMCDoc->SetMTNodeIDForNewView(ROOTNODEID);
        pAMCDoc->CreateNewView(true);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
    :
    m_hwndToNotifyCBChange(NULL),
    m_hwndNextCB(NULL),
    m_fCurrentlyMinimized(false),
    m_fCurrentlyActive(false)
{
    CommonConstruct();
}

void CMainFrame::CommonConstruct(void)
{
    m_pRebar = NULL;
    m_pMenuBar = NULL;
    m_pToolBar = NULL;
    m_pMDIChildWndFocused = NULL;
    m_hMenuCurrent = NULL;
    m_pToolbarTracker = NULL;
    SetInRenameMode(false);
}


CMainFrame::~CMainFrame()
{
    delete m_pMenuBar;
    delete m_pToolBar;
    delete m_pRebar;
    delete m_pToolbarTracker;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, TEXT("CMainFrame::OnCreate"));

    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndMDIClient.SubclassWindow(m_hWndMDIClient))
    {
        ASSERT(0 && "Failed to subclass MDI client window\n");
        return -1;
    }

    ASSERT(m_wndMDIClient.m_hWnd == m_hWndMDIClient);

    // create the rebar
    m_pRebar = new CRebarDockWindow;
    m_pRebar->Create(this,WS_CHILD|WS_VISIBLE, IDR_REBAR);

    // Create the toolbar like we just created the stat bar
    //m_wndToolBar.Create(this, WS_CHILD|WS_VISIBLE|SBARS_SIZEGRIP, 0x1003);
    m_ToolBarDockSite.Create(CDockSite::DSS_TOP);
    m_ToolBarDockSite.Attach(m_pRebar);
    m_ToolBarDockSite.Show();

    m_DockingManager.Attach(&m_ToolBarDockSite);

    AddMainFrameBars();

    m_hwndNextCB = SetClipboardViewer();
    if (m_hwndNextCB == NULL)
    {
        LRESULT lr = GetLastError();
        ASSERT(lr == 0);
    }

    // append our modifications to the system menu
    AppendToSystemMenu (this, eMode_Last + 1);

    // create the toolbar tracker
    m_pToolbarTracker = new CToolbarTracker (this);

    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    DECLARE_SC(sc, TEXT("CMainFrame::PreCreateWindow"));

    if (!CMDIFrameWnd::PreCreateWindow(cs))
        return (FALSE);

    static TCHAR szClassName[countof (MAINFRAME_CLASS_NAME)];
    static bool  fFirstTime = true;

    if (fFirstTime)
    {
        USES_CONVERSION;
        sc = StringCchCopy(szClassName, countof (MAINFRAME_CLASS_NAME), W2T (MAINFRAME_CLASS_NAME));
        if (sc)
            return FALSE;

        fFirstTime = false;
    }

    WNDCLASS    wc;
    HINSTANCE   hInst    = AfxGetInstanceHandle();
    BOOL        fSuccess = GetClassInfo (hInst, szClassName, &wc);

    // if we haven't already registered...
    if (!fSuccess && ::GetClassInfo (hInst, cs.lpszClass, &wc))
    {
        // ...register a uniquely-named window class so
        // MMCPropertyHelp the correct main window
        wc.lpszClassName = szClassName;
        wc.hIcon         = GetDefaultIcon();
        fSuccess = AfxRegisterClass (&wc);
    }

    if (fSuccess)
    {
        // Use the new child frame window class
        cs.lpszClass = szClassName;

        // remove MFC's title-munging styles
        cs.style &= ~(FWS_ADDTOTITLE | FWS_PREFIXTITLE);
    }

    return (fSuccess);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


// this code is duplicated in ..\nodemgr\propsht.cpp
BOOL CALLBACK MyEnumThreadWindProc (HWND current, LPARAM lParam)
{  // this enumerates non-child-windows created by a given thread

   if (!IsWindow (current))
      return TRUE;   // this shouldn't happen, but does!!!

   if (!IsWindowVisible (current))  // if they've explicitly hidden a window,
      return TRUE;                  // don't set focus to it.

   // we'll return hwnd in here
   HWND * phwnd = reinterpret_cast<HWND *>(lParam);

   // don't bother returning property sheet dialog window handle
   if (*phwnd == current)
      return TRUE;

   // also, don't return OleMainThreadWndClass window
   TCHAR szCaption[14];
   if (GetWindowText (current, szCaption, countof(szCaption)))
       if (!lstrcmp (szCaption, _T("OLEChannelWnd")))
          return TRUE;

   // anything else will do
   *phwnd = current;
   return FALSE;
}


/***************************************************************************\
 *
 * METHOD:  FArePropertySheetsOpen
 *
 * PURPOSE: Checks if there are propperty sheets open and asks to close them
 *          It is implemented as the following steps:
 *          1. Collect all property pages (and their children) to the stack
 *          2. Bring all the pages to the front, maintainig their z-order
 *          3. Disable all those windows, plus MMC main window to disallow switching to them
 *             untill message box is dissmissed
 *          4. Put all disabled windows to the stack, to be able to re-enable them
 *          5. (if there are any sheets) display message box asking to close the sheets
 *          6. Re-enable disabled windows
 *
 * PARAMETERS:
 *    CString* pstrUserMsg - [in] message to display
 *    bool bBringToFrontAndAskToClose [in] if need to proceed whole way. false -> just inspect and do nothing
 *
 * RETURNS:
 *    bool - [true == there are windows to close]
 *
\***************************************************************************/
bool FArePropertySheetsOpen(CString* pstrUserMsg, bool bBringToFrontAndAskToClose /* = true */ )
{
    std::stack<HWND, std::vector<HWND> >  WindowStack;
    std::stack<HWND, std::vector<HWND> >  EnableWindowStack;

    ASSERT (WindowStack.empty());

    HWND hwndData = NULL;

    while (TRUE)
    {
        USES_CONVERSION;

        // Note: No need to localize this string
        hwndData = ::FindWindowEx(NULL, hwndData, W2T(DATAWINDOW_CLASS_NAME), NULL);
        if (hwndData == NULL)
            break;  // No more windows

        ASSERT(IsWindow(hwndData));

        // Check if the window belongs to the current process
        DWORD dwPid = 0;        // Process Id
        ::GetWindowThreadProcessId(hwndData, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        DataWindowData* pData = GetDataWindowData (hwndData);
        ASSERT (pData != NULL);

        HWND hwndPropSheet = pData->hDlg;
        ASSERT (IsWindow (hwndPropSheet));
		
		// don't allow lost data window to block mmc from exiting
		// windows bug #425049	ntbug9 6/27/2001
		if ( !IsWindow (hwndPropSheet) )
			continue;

        // if propsheet has other windows or prop pages up,
        // then we send focus to them....

        // grab first one that isn't property sheet dialog
        HWND hwndOther = pData->hDlg;
        EnumThreadWindows (::GetWindowThreadProcessId(pData->hDlg, NULL),
                           MyEnumThreadWindProc, (LPARAM)&hwndOther);

        // if we got another window for this property sheet, we'll want
        // it to be on top of the property sheet after the shuffle, so
        // put it under the property sheet on the stack
        if (IsWindow (hwndOther) && (hwndOther != hwndPropSheet))
            WindowStack.push (hwndOther);

        // push the property sheet on the stack
        // of windows to bring to the foreground
        WindowStack.push (hwndPropSheet);
    }

    bool fFoundSheets = !WindowStack.empty();

    // we did the investigation, see if we were asked to do more
    if ( !bBringToFrontAndAskToClose )
        return (fFoundSheets);

    HWND hwndMsgBoxParent = NULL;

    // if we found property sheets, bring them to the foreground,
    // maintaining their original Z-order
    while (!WindowStack.empty())
    {
        HWND hwnd = WindowStack.top();
        WindowStack.pop();

        SetActiveWindow (hwnd);
        SetForegroundWindow (hwnd);

		if ( ::IsWindowEnabled(hwnd) )
		{
			// disable the pages while message box is displayed
			::EnableWindow( hwnd, FALSE );
			// remember to enable when done
			EnableWindowStack.push(hwnd);
		}
        hwndMsgBoxParent = hwnd; // the last one wins the right to be the parent :-)
    }

    if (fFoundSheets && pstrUserMsg)
    {
        // parent the message box on the top-most property page to make it obvios to the user
        CString strCaption;
        LPCTSTR szCaption = LoadString(strCaption, IDR_MAINFRAME) ? (LPCTSTR)strCaption : NULL;

        // disable main window as well
        CWnd *pMainWnd = AfxGetMainWnd();
        if ( pMainWnd && pMainWnd->IsWindowEnabled() )
        {
            pMainWnd->EnableWindow( FALSE );
            // remember to enable when done
            EnableWindowStack.push( pMainWnd->m_hWnd );
        }

        ::MessageBox( hwndMsgBoxParent, *pstrUserMsg, szCaption , MB_ICONSTOP | MB_OK );
    }

    // make everything functional again
    while (!EnableWindowStack.empty())
    {
        // enable the disabled window
        ::EnableWindow( EnableWindowStack.top(), TRUE );
        EnableWindowStack.pop();
    }

    return (fFoundSheets);
}


bool CanCloseDoc(void)
{
    CString strMessage;
    CString strConsoleName;

    AfxGetMainWnd()->GetWindowText (strConsoleName);
    FormatString1 (strMessage, IDS_ClosePropertyPagesBeforeClosingTheDoc,
                       strConsoleName);

    bool fPropSheets = FArePropertySheetsOpen(&strMessage);

    return !fPropSheets;
}


void CMainFrame::OnClose()
{
    /*
     * Bug 233682:  We need to make sure that we only handle WM_CLOSE when
     * it's dispatched from our main message pump.  If it comes from elsewhere
     * (like the message pump in a modal dialog or message box), then we're
     * likely in a state where we can't shut down cleanly.
     */
    CAMCApp* pApp = AMCGetApp();

    if (!pApp->DidCloseComeFromMainPump())
    {
        pApp->DelayCloseUntilIdle();
        return;
    }

    // Reset the flag so that while processing this WM_CLOSE if there is
    // any more WM_CLOSE messages from other sources it will not be processed.
    pApp->ResetCloseCameFromMainPump();

    if (!CanCloseDoc())
        return;

    // since this process includes event posting
    // - we should guard the function from reentrance
    static bool bInProgress = false;
    if (!bInProgress)
    {
        bInProgress = true;
        CMDIFrameWnd::OnClose();
        bInProgress = false;
    }
}

void CMainFrame::OnUpdateFilePrint(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}

void CMainFrame::OnUpdateFilePrintSetup(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}

#ifdef DBG
/*+-------------------------------------------------------------------------*
 *
 * CMainFrame::OnMMCTraceDialog
 *
 * PURPOSE: In Debug mode, shows the Trace dialog, in response to the hotkey.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMainFrame::OnMMCTraceDialog()
{
    DoDebugTraceDialog();
}


#endif

/***************************************************************************\
 *
 * METHOD:  ScUpdateAllScopes
 *
 * PURPOSE: Just calls CDocument::UpdateAllViews.
 *          If we want to Update all views to delete empty views then
 *          First it gets list of empty views and then it closes them.
 *
 * PARAMETERS:
 *    lHint - [in] The action to perform.
 *    lParam - [in] Extra context info.
 *
 * RETURNS:
 *    SC
 *
\***************************************************************************/
SC CMainFrame::ScUpdateAllScopes(LONG lHint, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, TEXT("CMainFrame::ScUpdateAllScopes"));

    // Updating all scopes may be requested as a result of document being deleted
    // in that case we do not have a document, and thus do not have any views.
    // So we are done.
    if (NULL == CAMCDoc::GetDocument())
        return sc;

    // Special case, we cannot destroy the view during CDocument::UpdateAllViews
    // as CDocument is enumerating the view collection. Nor we can do PostMessage 
    // to close view as scripts in (479627) web pages execute. Therefore we get the
    // list of empty views and then destroy them.
    if (lHint == VIEW_UPDATE_DELETE_EMPTY_VIEW)
    {
        // Get the list of AMCViews to be deleted.
        if (lParam != NULL)
            return (sc = E_UNEXPECTED);
        
        CArray<CAMCView*, CAMCView*> rgEmptyAMCViews;
        CAMCDoc::GetDocument()->UpdateAllViews (NULL, lHint, reinterpret_cast<CObject*>(&rgEmptyAMCViews));
        
        // Now destroy each view.
        for (int i = 0; i < rgEmptyAMCViews.GetSize(); i++)
        {
            CAMCView *pAMCView = rgEmptyAMCViews.GetAt(i);
            sc = ScCheckPointers(pAMCView);
            if (sc)
            {
                sc.TraceAndClear();
                continue;
            }
            
            CChildFrame* pFrame = pAMCView->GetParentFrame();
            
            sc = ScCheckPointers(pFrame);
            if (sc)
            {
                sc.TraceAndClear();
                continue;
            }
        
            // Send WM_CLOSE Synchronously else the web page views with scripts in them will
            // have their scripts executed and may AV.
            pFrame->SendMessage(WM_SYSCOMMAND, SC_CLOSE, 0);
        }

    }
	else
		CAMCDoc::GetDocument()->UpdateAllViews (NULL, lHint, 
												reinterpret_cast<CObject*>(lParam));

    return (sc);
}


void CMainFrame::OnViewToolbar()
{
    m_ToolBarDockSite.Toggle();
    RenderDockSites();
}

void CMainFrame::OnUpdateViewToolbar(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_ToolBarDockSite.IsVisible());
    pCmdUI->Enable(true);
}


void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
    // Don't call MFC version to size window
//  CMDIFrameWnd::OnSize (nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
    {
        RenderDockSites();
        MDIIconArrange();
    }

    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    if (pDoc != NULL)
        pDoc->SetFrameModifiedFlag();

    /*
     * If we're moving to or from the minimized state, notify child windows.
     */
    if (m_fCurrentlyMinimized != (nType == SIZE_MINIMIZED))
    {
        m_fCurrentlyMinimized = (nType == SIZE_MINIMIZED);
        SendMinimizeNotifications (m_fCurrentlyMinimized);
    }
}


void CMainFrame::OnMove(int x, int y)
{
    CMDIFrameWnd::OnMove (x, y);

    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    if (pDoc != NULL)
        pDoc->SetFrameModifiedFlag();
}

void CMainFrame::RenderDockSites()
{
    ASSERT_VALID (this);

    CRect clientRect;
    GetClientRect(&clientRect);

    m_DockingManager.BeginLayout();
    m_DockingManager.RenderDockSites(m_hWndMDIClient, clientRect);
    m_DockingManager.EndLayout();
}


void CMainFrame::AddMainFrameBars(void)
{
	/*
	 * activate our fusion context so the bars will be themed
	 */
	CThemeContextActivator activator;

    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMainFrame::AddMainFrameBars"));
    sc = ScCheckPointers(m_pRebar);
    if (sc)
        return;

    // insert the menu bar
    ASSERT (m_pMenuBar == NULL);
    m_pMenuBar = new CMenuBar;
    sc = ScCheckPointers(m_pMenuBar);
    if (sc)
        return;

    m_pMenuBar->Create  (this, m_pRebar, WS_VISIBLE, ID_MENUBAR);
    m_pMenuBar->SetMenu (GetMenu ());
    m_pMenuBar->Show    (TRUE);

    ASSERT(NULL == m_pToolBar);
    m_pToolBar = new CMMCToolBar();
    sc = ScCheckPointers(m_pToolBar);
    if (sc)
        return;

    // Create the toolbar.
    sc = m_pToolBar->ScInit(m_pRebar);
    if (sc)
        return;

    m_pToolBar->Show(TRUE, true /* In new line*/);
}


SC CMainFrame::ScCreateNewView (CreateNewViewStruct* pcnvs, bool bEmitScriptEvents /*= true*/)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    DECLARE_SC (sc, _T("CMainFrame::ScCreateNewView"));
    CAMCView* pNewView = NULL;  // avoid "initialization skipped by 'goto Error'"

    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    ASSERT(pAMCDoc != NULL);
    if (pAMCDoc == NULL)
        return (sc = E_UNEXPECTED);

    if (pcnvs == NULL)
        return (sc = E_POINTER);

    if ((AMCGetApp()->GetMode() == eMode_User_SDI) && pcnvs->fVisible)
        return (sc = E_FAIL);

    pAMCDoc->SetMTNodeIDForNewView (pcnvs->idRootNode);
    pAMCDoc->SetNewWindowOptions   (pcnvs->lWindowOptions);
    pNewView = pAMCDoc->CreateNewView (pcnvs->fVisible, bEmitScriptEvents);

    if (pNewView == NULL)
    {
        pcnvs->pViewData = NULL;
        return (sc = E_FAIL);
    }

    pcnvs->pViewData = pNewView->GetViewData();
    pcnvs->hRootNode = pNewView->GetRootNode();

    return (sc);
}


void CMainFrame::OnHelpTopics()
{
    ScOnHelpTopics();
}

SC CMainFrame::ScOnHelpTopics()
{
    DECLARE_SC(sc, _T("CMainFrame::ScOnHelpTopics"));
    /*
     * if there is a view, route through it so the snap-in gets a crack
     * at the help message (just like Help Topics from the Help menu).
     */
    CConsoleView* pConsoleView = NULL;
    sc = ScGetActiveConsoleView (pConsoleView);
    if (sc)
        return (sc);

    if (pConsoleView != NULL)
    {
        sc = pConsoleView->ScHelpTopics ();
        return sc;
    }

    HH_WINTYPE hhWinType;
    ZeroMemory(&hhWinType, sizeof(hhWinType));

    CAMCApp* pAMCApp = AMCGetApp();
    if (NULL == pAMCApp)
        return (sc = E_UNEXPECTED);

    sc = pAMCApp->ScShowHtmlHelp(SC::GetHelpFile(), 0);

    return sc;
}


void CMainFrame::OnViewRefresh()
{
    // if this doesn't fire before 10/1/99, remove this, OnUpdateViewRefresh, and all references to ID_VIEW_REFRESH (vivekj)
    ASSERT(false && "If this assert ever fires, then we need ID_VIEW_REFRESH (see above) and we can remove the 'Do we need this?' and this assert");
    CAMCTreeView* pAMCTreeView = _GetActiveAMCTreeView();
    if (pAMCTreeView)
        pAMCTreeView->ScReselect();
}

void CMainFrame::OnUpdateViewRefresh(CCmdUI* pCmdUI)
{
    // if this doesn't fire before 10/1/99, remove this, OnUpdateView, and all references to ID_VIEW_REFRESH (vivekj)
    ASSERT(false && "If this assert ever fires, then we need ID_VIEW_REFRESH (see above) and we can remove the 'Do we need this?' and this assert");
    pCmdUI->Enable(TRUE);
}

void CMainFrame::OnDestroy()
{
    DECLARE_SC(sc, _T("CMainFrame::OnDestroy"));
    // NTRAID#NTBUG9-684811-2002/09/10 - MMC does not send WM_CHANGECBCHAIN message on shutdown if next viewer is NULL.
    // since MMC could be the last window in the chain, it needs to call ChangeClipboardChain even
    // if m_hwndNextCB is null
    if (ChangeClipboardChain(m_hwndNextCB) == FALSE)
    {
        sc.FromLastError();
        sc.TraceAndClear();
    }

    CMDIFrameWnd::OnDestroy();
}


void CMainFrame::OnUpdateFrameMenu(HMENU hMenuAlt)
{
    // let the base class select the right menu
    CMDIFrameWnd::OnUpdateFrameMenu (hMenuAlt);

    // by now, the right menu is on the frame; reflect it to the toolbar
    NotifyMenuChanged ();
}


void CMainFrame::NotifyMenuChanged ()
{
    CMenu*  pMenuCurrent = NULL;

    // make sure we don't have menus for MDI or SDI User mode
    switch (AMCGetApp()->GetMode())
    {
        case eMode_Author:
        case eMode_User:
        case eMode_User_MDI:
        case eMode_User_SDI:
            pMenuCurrent = CWnd::GetMenu();
            break;

        default:
            ASSERT (false);
            break;
    }

    m_hMenuCurrent = pMenuCurrent->GetSafeHmenu();

    if (m_pMenuBar != NULL)
    {
        // reflect the new menu on the menu bar
        m_pMenuBar->SetMenu (pMenuCurrent);

        // detach the menu from the frame
        SetMenu (NULL);
    }
}


BOOL CMainFrame::PreTranslateMessage(MSG* pMsg)
{
	/*
	 * If mainframe is not the active window then do not translate
	 * the messages. (See Bug# 119355)
	 */
	if (!m_fCurrentlyActive)
		return (FALSE);

    CRebarWnd* pwndRebar = m_pRebar->GetRebar();

    // give the rebar a crack
    if (pwndRebar && pwndRebar->PreTranslateMessage (pMsg))
        return (TRUE);

    // give the menu bar a crack (for menu accelerators)
    if (m_pMenuBar && m_pMenuBar->PreTranslateMessage (pMsg))
        return (TRUE);

    // give the base class a crack
    if ((InRenameMode() == false) &&
        (CMDIFrameWnd::PreTranslateMessage(pMsg)))
            return (TRUE);

    // not translated
    return (FALSE);
}


void CMainFrame::OnIdle ()
{
    if (m_pMenuBar != NULL)
    {
        CMDIChildWnd*   pwndActive = MDIGetActive ();

        // The menus are always visible in SDI & MDI modes.
        switch (AMCGetApp()->GetMode())
        {

            case eMode_User_SDI:
            {
                BOOL bMaximized = (pwndActive != NULL) ? pwndActive->IsZoomed () : false;
                ASSERT (bMaximized);
                ASSERT (IsMenuVisible());
            }
            break;

            case eMode_User_MDI:
                ASSERT (pwndActive != NULL);
                ASSERT (IsMenuVisible());
                break;
        }

        ASSERT (m_pMenuBar->GetMenu() != NULL);

        m_pMenuBar->OnIdle ();
    }
}

void CMainFrame::ShowMenu (bool fShow)
{
    CRebarWnd * pwndRebar = m_pRebar->GetRebar();
    pwndRebar->ShowBand (pwndRebar->IdToIndex (ID_MENUBAR), fShow);

    /*---------------------------------------------------------------------*/
    /* if we're showing, the rebar must be showing, too;                   */
    /* if we're hiding, the rebar should be hidden if no bands are visible */
    /*---------------------------------------------------------------------*/
    if ( fShow && !m_pRebar->IsVisible())
    {
        m_pRebar->Show (fShow);
        RenderDockSites ();
    }
}

static bool IsRebarBandVisible (CRebarWnd* pwndRebar, int nBandID)
{
    REBARBANDINFO   rbbi;
    ZeroMemory (&rbbi, sizeof (rbbi));
    rbbi.cbSize = sizeof (rbbi);
    rbbi.fMask  = RBBIM_STYLE;

    pwndRebar->GetBandInfo (pwndRebar->IdToIndex (nBandID), &rbbi);

    return ((rbbi.fStyle & RBBS_HIDDEN) == 0);
}

bool CMainFrame::IsMenuVisible ()
{
    return (IsRebarBandVisible (m_pRebar->GetRebar(), ID_MENUBAR));
}

/////////////////////////////////////////////////////////////////////////////
// Special UI processing depending on current active child

CString CMainFrame::GetFrameTitle()
{
    /*
     * If there's no active child window, then the document
     * is being closed.  Just use the default title.
     */
    if (MDIGetActive() != NULL)
    {
        CAMCDoc* pDocument = CAMCDoc::GetDocument();

        /*
         * If there's a document, use its title.
         */
        if (pDocument != NULL)
            return (pDocument->GetCustomTitle());
    }

    return (m_strGenericTitle);
}

void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    AfxSetWindowText(m_hWnd, GetFrameTitle());
}

BOOL CMainFrame::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
    if (!CMDIFrameWnd::LoadFrame(nIDResource, dwDefaultStyle, pParentWnd, pContext))
        return (FALSE);

    // save the title we'll use for the main frame if there's no console open
    m_strGenericTitle = m_strTitle;

    return (TRUE);
}

void CMainFrame::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID)
    {
        case ID_HELP_HELPTOPICS:
            OnHelpTopics ();
            break;

        case ID_CUSTOMIZE_VIEW:
        {
            CChildFrame* pwndActive = dynamic_cast<CChildFrame*>(MDIGetActive ());

            if (pwndActive != NULL)
                pwndActive->OnSysCommand (nID, lParam);
            else
                CMDIFrameWnd::OnSysCommand(nID, lParam);
            break;
        }

        default:
            CMDIFrameWnd::OnSysCommand(nID, lParam);
            break;
    }
}

void CMainFrame::UpdateChildSystemMenus ()
{
    ProgramMode eMode = AMCGetApp()->GetMode();

    // make necessary modifications to existing windows' system menus
    for (CWnd* pwndT = MDIGetActive();
         pwndT != NULL;
         pwndT = pwndT->GetWindow (GW_HWNDNEXT))
    {
        CMenu*  pSysMenu = pwndT->GetSystemMenu (FALSE);

        if (pSysMenu != NULL)
        {
            // if not in author mode, protect author mode windows from
            // user close
            if (eMode != eMode_Author)
            {
                // Get AMCView object for this frame
                CChildFrame *pChildFrm = dynamic_cast<CChildFrame*>(pwndT);
                ASSERT(pChildFrm != NULL);

                CAMCView* pView = pChildFrm->GetAMCView();
                ASSERT(pView != NULL);

                // if it's an author mode view, don't let user close it
                if (pView && pView->IsAuthorModeView())
                    pSysMenu->EnableMenuItem (SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
            }

            // if we're not in SDI User mode, append common stuff
            if (eMode != eMode_User_SDI)
                AppendToSystemMenu (pwndT, eMode);
        }
    }
}

void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
    CMDIFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);

    if (bSysMenu)
    {
        int nEnable = MF_GRAYED;
        CChildFrame* pwndActive = dynamic_cast<CChildFrame*>(MDIGetActive ());

        // if there's an active child, let it handle system menu validation
        if ((pwndActive != NULL) && (pwndActive->IsCustomizeViewEnabled()))
            nEnable = MF_ENABLED;

        pPopupMenu->EnableMenuItem (ID_CUSTOMIZE_VIEW, MF_BYCOMMAND | nEnable);
    }
    else
    {
        // Check if Help menu by testing for "Help Topics" item
        if (pPopupMenu->GetMenuState(ID_HELP_HELPTOPICS, MF_BYCOMMAND) != UINT(-1))
        {
            // View will update item
            CAMCView* pView = GetActiveAMCView();
            if (pView != NULL)
            {
                pView->UpdateSnapInHelpMenus(pPopupMenu);
            }
        }
    }
}

LRESULT CMainFrame::OnShowSnapinHelpTopic (WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC (sc, _T("CMainFrame::OnShowSnapinHelpTopic"));

    CConsoleView* pConsoleView;
    sc = ScGetActiveConsoleView (pConsoleView);

    if (sc)
        return (sc.ToHr());

    /*
     * ScGetActiveConsoleView will return success (S_FALSE) even if there's no
     * active view.  This is a valid case, occuring when there's no console
     * file open.  In this particular circumstance, it is an unexpected
     * failure since we shouldn't get to this point in the code if there's
     * no view.
     */
    sc = ScCheckPointers (pConsoleView, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    // forward this on the the active AMC view window
    USES_CONVERSION;
    sc = pConsoleView->ScShowSnapinHelpTopic (W2T (reinterpret_cast<LPOLESTR>(lParam)));

    return (sc.ToHr());
}

SC CMainFrame::ScGetMenuAccelerators (LPTSTR pBuffer, int cchBuffer)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if ((m_pMenuBar != NULL) && IsMenuVisible())
        m_pMenuBar->GetAccelerators (cchBuffer, pBuffer);

    else if (cchBuffer > 0)
        pBuffer[0] = 0;

    return (S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:      CMainFrame::ScShowMMCMenus
//
//  Synopsis:    Show or hide MMC menus. (Action/View/Favs)
//
//  Arguments:   bShow
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMainFrame::ScShowMMCMenus (bool bShow)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMainFrame::ScShowMMCMenus"));

    if ((m_pMenuBar != NULL) && IsMenuVisible())
        sc = m_pMenuBar->ScShowMMCMenus(bShow);
    else
        return (sc = E_UNEXPECTED);

    return (sc);
}

//////////////////////////////////////////////////////////////////////////////
// This message is received from the node manager whenever a property
// sheet use the MMCPropertyChangeNotify() api.
// The wParam contains a copy of the handle information which must be freed.
//
LRESULT CMainFrame::OnPropertySheetNotify(WPARAM wParam, LPARAM lParam)
{
    TRACE_METHOD(CAMCView, OnPropertySheetNotify);

    ASSERT(wParam != 0);
    LPPROPERTYNOTIFYINFO pNotify = reinterpret_cast<LPPROPERTYNOTIFYINFO>(wParam);

    // Crack the information from the handle object and send a notify to the snap-in
    ASSERT((pNotify->pComponent != NULL || pNotify->pComponentData != NULL));

    if (pNotify->pComponent != NULL)
        pNotify->pComponent->Notify(NULL, MMCN_PROPERTY_CHANGE, pNotify->fScopePane, lParam);

    else if (pNotify->pComponentData != NULL)
        pNotify->pComponentData->Notify(NULL, MMCN_PROPERTY_CHANGE, pNotify->fScopePane, lParam);

    ::GlobalFree(pNotify);
    return TRUE;
}


LRESULT CMainFrame::OnSetText (WPARAM wParam, LPARAM lParam)
{
    LRESULT rc;
    CAMCDoc* pDoc = CAMCDoc::GetDocument();

    /*
     * If the document has a custom title, we don't want to append
     * the maxed child's title to the main frame's title.  To do this,
     * we'll bypass DefFrameProc and go directly to DefWindowProc.
     */
    if ((pDoc != NULL) && pDoc->HasCustomTitle())
        rc = CWnd::DefWindowProc (WM_SETTEXT, wParam, lParam);
    else
        rc = Default();

    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}

void CMainFrame::OnPaletteChanged( CWnd* pwndFocus)
{
    if (pwndFocus != this)
    {
        CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
        if (pAMCDoc)
        {
            HWND hwndFocus = pwndFocus->GetSafeHwnd();
            CAMCViewPosition pos = pAMCDoc->GetFirstAMCViewPosition();
            while (pos != NULL)
            {
                CAMCView* pv = pAMCDoc->GetNextAMCView(pos);

                if (pv)
                    pv->SendMessage(WM_PALETTECHANGED, (WPARAM)hwndFocus);
            }
        }
    }

    CMDIFrameWnd::OnPaletteChanged(pwndFocus);
}

BOOL CMainFrame::OnQueryNewPalette()
{
    CAMCView* pAMCView = GetActiveAMCView();
    if (pAMCView != NULL)
        return pAMCView->SendMessage(WM_QUERYNEWPALETTE);

    return CMDIFrameWnd::OnQueryNewPalette();
}

void CMainFrame::OnConsoleProperties()
{
    CConsolePropSheet().DoModal();
}

void CMainFrame::SetIconEx (HICON hIcon, BOOL fBig)
{
    if (hIcon == NULL)
        hIcon = GetDefaultIcon();

    SetIcon (hIcon, fBig);

    /*
     * make sure the child icon on the menu bar gets updated
     */
    ASSERT (m_pMenuBar != NULL);
    m_pMenuBar->InvalidateMaxedChildIcon();
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::GetDefaultIcon
 *
 *
 *--------------------------------------------------------------------------*/

HICON CMainFrame::GetDefaultIcon () const
{
    return (AfxGetApp()->LoadIcon (IDR_MAINFRAME));
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::SendMinimizeNotifications
 *
 * Causes each CChildFrame to send NCLBK_MINIMIZED.
 *--------------------------------------------------------------------------*/

void CMainFrame::SendMinimizeNotifications (bool fMinimized) const
{
    CWnd* pwndMDIChild;

    for (pwndMDIChild  = m_wndMDIClient.GetWindow (GW_CHILD);
         pwndMDIChild != NULL;
         pwndMDIChild  = pwndMDIChild->GetWindow (GW_HWNDNEXT))
    {
        // There used to be an ASSERT_ISKINDOF. However, that had to change to an if
        // since the active background denies that assumption. See bug 428906.
        if(pwndMDIChild->IsKindOf(RUNTIME_CLASS(CChildFrame)))
            (static_cast<CChildFrame*>(pwndMDIChild))->SendMinimizeNotification (fMinimized);
    }
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::OnNcActivate
 *
 * WM_NCACTIVATE handler for CMainFrame.
 *--------------------------------------------------------------------------*/

BOOL CMainFrame::OnNcActivate(BOOL bActive)
{
    BOOL rc = CMDIFrameWnd::OnNcActivate(bActive);
    DrawFrameCaption (this, m_fCurrentlyActive);

    return (rc);
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::OnNcPaint
 *
 * WM_NCPAINT handler for CMainFrame.
 *--------------------------------------------------------------------------*/

void CMainFrame::OnNcPaint()
{
    Default();
    DrawFrameCaption (this, m_fCurrentlyActive);
}


/*+-------------------------------------------------------------------------*
 * MsgForwardingEnumProc
 *
 *
 *--------------------------------------------------------------------------*/

static BOOL CALLBACK MsgForwardingEnumProc (HWND hwnd, LPARAM lParam)
{
    /*
     * if this isn't an MFC window, forward the message
     */
    if (CWnd::FromHandlePermanent(hwnd) == NULL)
    {
        const MSG* pMsg = (const MSG*) lParam;
        SendMessage (hwnd, pMsg->message, pMsg->wParam, pMsg->lParam);
    }

    /*
     * continue enumeration
     */
    return (true);
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CMainFrame.
 *--------------------------------------------------------------------------*/

void CMainFrame::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    CMDIFrameWnd::OnSettingChange(uFlags, lpszSection);

    /*
     * MFC will send WM_SETTINGCHANGEs to all descendent MFC windows.
     * There are some non-MFC windows owned by nodemgr that we also want
     * to get this message.  We'll send these manually.
     */
    const MSG* pMsg = GetCurrentMessage();
    EnumChildWindows (m_hWnd, MsgForwardingEnumProc, (LPARAM) pMsg);

    /*
     * If we're in SDI mode, then there can be some redrawing problems
     * around the caption if the caption height changes significantly.
     * (This is a USER MDI bug.)  We can work around it by manually
     * placing the maximized child window within the MDI client.
     *
     * Note that restoring and re-maximizing the active child window
     * will put the window in the right place, it has the side effect
     * of undesired window flicker (see 375430, et al) as well as
     * a bunch of annoying sound effects if you have sounds associated
     * with the "Restore Down" and/or "Maximize" sound events.
     */
    if (AMCGetApp()->GetMode() == eMode_User_SDI)
    {
        CMDIChildWnd* pwndActive = MDIGetActive();

        if (pwndActive)
        {
            /*
             * get the size of the MDI client
             */
            CRect rect;
            m_wndMDIClient.GetClientRect (rect);

            /*
             * inflate the MDI client's client rect by the size of sizing
             * borders, and add room for the caption at the top
             */
            rect.InflateRect (GetSystemMetrics (SM_CXFRAME),
                              GetSystemMetrics (SM_CYFRAME));
            rect.top -= GetSystemMetrics (SM_CYCAPTION);

            /*
             * put the window in the right place
             */
            pwndActive->MoveWindow (rect);
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::ScGetActiveStatusBar
 *
 * Returns the CConsoleStatusBar interface for the active view.  If there's no
 * active view, pStatusBar is set to NULL and S_FALSE is returned.
 *--------------------------------------------------------------------------*/

SC CMainFrame::ScGetActiveStatusBar (
    CConsoleStatusBar*& pStatusBar)     /* O:CConsoleStatusBar for active view*/
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CMainFrame::ScGetActiveStatusBar"));

    pStatusBar = dynamic_cast<CConsoleStatusBar*>(GetActiveFrame());

    if (pStatusBar == NULL)
        sc = S_FALSE;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMainFrame::ScGetActiveConsoleView
 *
 * Returns the CConsoleView interface for the active view.  If there's no
 * active view, pConsoleView is set to NULL and S_FALSE is returned.
 *--------------------------------------------------------------------------*/

SC CMainFrame::ScGetActiveConsoleView (
    CConsoleView*& pConsoleView)        /* O:CConsoleView for active view   */
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CMainFrame::ScGetActiveConsoleView"));

    pConsoleView = GetActiveAMCView();

    if (pConsoleView == NULL)
        sc = S_FALSE;

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CMainFrame::OnUnInitMenuPopup
 *
 * PURPOSE: Used to remove accelerators once system menus are dismissed
 *
 * PARAMETERS:
 *    WPARAM wParam
 *    LPARAM lParam
 *
 * RETURNS:
 *    LRESULT    - result code
 *
\***************************************************************************/
afx_msg LRESULT CMainFrame::OnUnInitMenuPopup(WPARAM wParam, LPARAM lParam)
{
    // hide accelerators whenever leaving system popup
    if ( HIWORD(lParam) & MF_SYSMENU )
    {
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mdiclint.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       MDIClint.cpp
//
//--------------------------------------------------------------------------

// MDIClint.cpp : implementation file
//

#include "stdafx.h"
#include "amc.h"
#include "MDIClint.h"
#include "amcview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


//############################################################################
//############################################################################
//
// Implementation of CMDIClientWnd
//
//############################################################################
//############################################################################
CMDIClientWnd::CMDIClientWnd()
{
}

CMDIClientWnd::~CMDIClientWnd()
{
}


BEGIN_MESSAGE_MAP(CMDIClientWnd, CWnd)
    //{{AFX_MSG_MAP(CMDIClientWnd)
    ON_WM_CREATE()
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


int CMDIClientWnd::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    return BC::OnCreate(lpCreateStruct);

    // Do not add anything here because this function will never be called.
    // The CMDIClientWnd window is subclassed after it is created.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mainfrm.h ===
///+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mainfrm.h
//
//--------------------------------------------------------------------------

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DOCKSITE_H__
#include "docksite.h"
#endif

//forward prototypes
class CAMCView;
class CAMCTreeView;
class CMenuBar;
class CMMCToolBar;
class CToolbarTracker;

#ifndef _STATBAR_H
#include "statbar.h"
#endif

#include "MDIClint.h"
#include "conframe.h"       // for CConsoleFrame


#define ID_MENUBAR      0x1001
#define ID_TOOLBAR      0x1002

class CMainFrame : public CMDIFrameWnd, public CConsoleFrame, public CTiedObject
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame();

// Attributes
public:
    SC  ScGetFrame(Frame** ppFrame);
    SC  ScMaximize();
    SC  ScMinimize();
    SC  ScRestore();
    SC  ScSetPosition(const RECT &rect);
    SC  ScGetPosition(RECT &rect);

// Operations
public:
    void NotifyMenuChanged ();
    void OnIdle ();
    void SetInRenameMode(bool b)
    {
        m_bInRenameMode = b;
    }

    bool InRenameMode(void) const
    {
        return m_bInRenameMode;
    }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual void OnUpdateFrameMenu(HMENU hMenuAlt);

public:  // control bar embedded members
    CMenuBar *          m_pMenuBar;
    CMMCToolBar*        m_pToolBar;
    CMDIClientWnd       m_wndMDIClient;

//Operations
public:
    void RenderDockSites();
    bool IsMenuVisible();
    void ShowMenu(bool bShow);
    void UpdateChildSystemMenus ();
    void SetIconEx (HICON hIcon, BOOL fBig);

    void SetFocusedChildWnd(CMDIChildWnd* pWnd) { m_pMDIChildWndFocused = pWnd; }
    CMDIChildWnd* GetFocusedChildWnd() { return m_pMDIChildWndFocused; }
    void SetWindowToNotifyCBChange(HWND hwnd) { m_hwndToNotifyCBChange = hwnd; }
    CAMCView* GetActiveAMCView();

    HACCEL& GetAccelTable()
    {
        return (m_hAccelTable);
    }

    CMenu* GetMenu () const
    {
        return (CMenu::FromHandle (m_hMenuCurrent));
    }

    CRebarWnd* GetRebar () const
    {
        return (m_pRebar->GetRebar());
    }

    CRebarDockWindow* GetRebarDockWindow()
    {
        return (m_pRebar);
    }

    CToolbarTracker* GetToolbarTracker () const
    {
        return (m_pToolbarTracker);
    }

    CMenuBar* GetMenuBar() const
    {
        return (m_pMenuBar);
    }

    CMMCToolBar* GetMainToolbar()
    {
        return m_pToolBar;
    }
public:
    // CConsoleFrame methods
    virtual SC ScGetActiveStatusBar   (CConsoleStatusBar*& pStatusBar);
    virtual SC ScGetActiveConsoleView (CConsoleView*& pConsoleView);
    virtual SC ScCreateNewView        (CreateNewViewStruct* pcnvs,
                                       bool bEmitScriptEvents = true);
    virtual SC ScUpdateAllScopes      (LONG lHint, LPARAM lParam);
    virtual SC ScGetMenuAccelerators  (LPTSTR pBuffer, int cchBuffer);
    virtual SC ScShowMMCMenus         (bool bShow);

protected:  // control bar embedded members
    virtual CWnd* GetMessageBar()
        { return (NULL); }

    HICON GetDefaultIcon () const;

    CDockManager<CDockSite>    m_DockingManager;
    CDockSite   m_ToolBarDockSite;
    CRebarDockWindow*   m_pRebar;
    CToolbarTracker*    m_pToolbarTracker;

    CMDIChildWnd*   m_pMDIChildWndFocused;

//Operations
protected:
    void AddMainFrameBars(void);
    void CommonConstruct(void);

// Generated message map functions
// CODEWORK message reflection not working yet
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDrawClipboard();
    afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
    afx_msg void OnUpdateFilePrint(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFilePrintSetup(CCmdUI* pCmdUI);
    afx_msg void OnClose();
    afx_msg void OnViewToolbar();
    afx_msg void OnUpdateViewToolbar(CCmdUI* pCmdUI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnViewRefresh();
    afx_msg void OnUpdateViewRefresh(CCmdUI* pCmdUI);
    afx_msg void OnDestroy();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
    afx_msg void OnConsoleProperties();
    afx_msg void OnMove(int x, int y);
    afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnNcPaint();
    afx_msg void OnPaletteChanged(CWnd* pwndFocus);
    afx_msg BOOL OnQueryNewPalette( );
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LRESULT OnUnInitMenuPopup(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG

    #ifdef DBG
    afx_msg void OnMMCTraceDialog();
    #endif

    afx_msg LRESULT OnShowSnapinHelpTopic(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnPropertySheetNotify(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg void OnWindowNew();
    DECLARE_MESSAGE_MAP()

    // These need to be public so that the app can get to them.
public:
    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);

    afx_msg void OnHelpTopics();
    SC           ScOnHelpTopics();


private:
    HWND    m_hwndNextCB;
    HWND    m_hwndToNotifyCBChange;
    HMENU   m_hMenuCurrent;
    bool    m_bInRenameMode;
    bool    m_fCurrentlyMinimized;
    bool    m_fCurrentlyActive;
    CString m_strGenericTitle;

    CString GetFrameTitle();
    CAMCTreeView* _GetActiveAMCTreeView();
    void SendMinimizeNotifications (bool fMinimized) const;
};


inline CMainFrame* AMCGetMainWnd()
{
    /*
     * Note:  the dynamic_cast here can fail.  Under certain, not understood
     * circumstances, AfxGetMainWnd can return a pointer to CTempWnd instead
     * of CMainFrame.
     *
     * Any callers of this function *must* check for a NULL return value.
     */

    CWnd *pWnd = AfxGetMainWnd();
    CMainFrame *pMainFrame = NULL;

    try
    {
        pMainFrame = dynamic_cast<CMainFrame*>(pWnd);
    }
    catch (...)
    {
        pMainFrame = NULL;
    }

    return (pMainFrame);
}

inline CRebarWnd* AMCGetRebar()
{
    CMainFrame* pMainFrame = AMCGetMainWnd();
    if (NULL == pMainFrame)
        return NULL;

    return pMainFrame->GetRebar();
}

bool FArePropertySheetsOpen(CString* pstrUserMsg, bool bBringToFrontAndAskToClose = true);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mdiclint.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       MDIClint.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_MDICLINT_H__22C6BB09_294D_11D1_A7D4_00C04FD8D565__INCLUDED_)
#define AFX_MDICLINT_H__22C6BB09_294D_11D1_A7D4_00C04FD8D565__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MDIClint.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CMDIClientWnd window

class CMDIClientWnd : public CWnd
{
    typedef CWnd BC;
// Construction
public:
    CMDIClientWnd();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMDIClientWnd)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMDIClientWnd();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMDIClientWnd)
        // NOTE - the ClassWizard will add and remove member functions here.
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP();
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MDICLINT_H__22C6BB09_294D_11D1_A7D4_00C04FD8D565__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mdiuisim.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      mdiuisim.h  
 *
 *  Contents:  Interface file for CMDIMenuDecoration
 *
 *  History:   17-Nov-97 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_MDIUISIM_H__EB2A4CC1_5F5E_11D1_8009_0000F875A9CE__INCLUDED_)
#define AFX_MDIUISIM_H__EB2A4CC1_5F5E_11D1_8009_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CMDIMenuDecoration window


// window styles
#define MMDS_CLOSE          0x0001
#define MMDS_MINIMIZE       0x0002
#define MMDS_MAXIMIZE       0x0004
#define MMDS_RESTORE        0x0008
#define MMDS_AUTOSIZE       0x0010

#define MMDS_BTNSTYLES      0x000F


class CMDIMenuDecoration : public CWnd
{
    class CMouseTrackContext
    {
    public:
        CMouseTrackContext (CMDIMenuDecoration*, CPoint);
        ~CMouseTrackContext ();

        void Track (CPoint);
        int HitTest (CPoint) const;
        void ToggleHotButton ();

        int                 m_nHotButton;

    private:    
        CMDIMenuDecoration* m_pMenuDec;
        CRect               m_rectButton[4];
        bool                m_fHotButtonPressed;
    };
    
    typedef std::auto_ptr<CMouseTrackContext>   CMouseTrackContextPtr;
    friend class CMouseTrackContext;

    CMouseTrackContextPtr   m_spTrackCtxt;

// Construction
public:
    CMDIMenuDecoration();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMDIMenuDecoration)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMDIMenuDecoration();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMDIMenuDecoration)
    afx_msg void OnPaint();
    afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CMenu*  GetActiveSystemMenu ();
    bool    IsSysCommandEnabled (int nSysCommand, CMenu* pSysMenu = NULL);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MDIUISIM_H__EB2A4CC1_5F5E_11D1_8009_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mdiuisim.cpp ===
/*--------------------------------------------------------------------------*
 * 
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      mdiuisim.cpp
 *
 *  Contents:  Implementation file for CMDIMenuDecoration
 *
 *  History:   17-Nov-97 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "mdiuisim.h"


struct MDIDataMap {
    DWORD   dwStyle;
    int     nCommand;
};

const int cMapEntries = 4;

const MDIDataMap anMDIDataMap[cMapEntries] = {
    {   MMDS_CLOSE,     SC_CLOSE    },      // DFCS_CAPTIONCLOSE   
    {   MMDS_MINIMIZE,  SC_MINIMIZE },      // DFCS_CAPTIONMIN     
    {   MMDS_MAXIMIZE,  SC_MAXIMIZE },      // DFCS_CAPTIONMAX     
    {   MMDS_RESTORE,   SC_RESTORE  },      // DFCS_CAPTIONRESTORE 
};

// this array is in the order the decorations are drawn, left-to-right
const int anDrawOrder[cMapEntries] = {
    DFCS_CAPTIONMIN, 
    DFCS_CAPTIONRESTORE,  
    DFCS_CAPTIONMAX, 
    DFCS_CAPTIONCLOSE
};



/*--------------------------------------------------------------------------*
 * DrawCaptionControl 
 *
 *
 *--------------------------------------------------------------------------*/

static void DrawCaptionControl (
    CDC *   pdc,
    LPCRECT pRect,
    int     nIndex,
    bool    fPushed)
{
    const int   cxInflate = -1;
    const int   cyInflate = -2;
    CRect       rectDraw  = pRect;

    rectDraw.InflateRect (cxInflate, cyInflate);
    rectDraw.OffsetRect  ((nIndex == DFCS_CAPTIONMIN) ? 1 : -1, 0);

    if (fPushed)
        nIndex |= DFCS_PUSHED;

    pdc->DrawFrameControl (rectDraw, DFC_CAPTION, nIndex);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::CMouseTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CMDIMenuDecoration::CMouseTrackContext::CMouseTrackContext (
    CMDIMenuDecoration* pMenuDec,
    CPoint              point)
    :   m_fHotButtonPressed (false),
        m_pMenuDec          (pMenuDec)
{
    ASSERT_VALID (m_pMenuDec);

    // set up hit testing rectangles for each button
    int     cxButton = GetSystemMetrics (SM_CXMENUSIZE);
    int     cyButton = GetSystemMetrics (SM_CYMENUSIZE);
    DWORD   dwStyle  = m_pMenuDec->GetStyle ();
    
    CRect   rectT (0, 0, cxButton, cyButton);
    
    for (int i = 0; i < cMapEntries; i++)
    {
        int nDataIndex = anDrawOrder[i];

        if (dwStyle & anMDIDataMap[nDataIndex].dwStyle)
        {
            m_rectButton[nDataIndex] = rectT;
            rectT.OffsetRect (cxButton, 0);
        }
        else
            m_rectButton[nDataIndex].SetRectEmpty();
    }

    m_nHotButton = HitTest (point);
    ASSERT (m_nHotButton != -1);

    // if the user clicked on a disbled button, we don't want to track -- punt!
    if (!m_pMenuDec->IsSysCommandEnabled (anMDIDataMap[m_nHotButton].nCommand))
        AfxThrowUserException ();

    // press the hot button initially
    ToggleHotButton ();

    // capture the mouse
    m_pMenuDec->SetCapture ();
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::~CMouseTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CMDIMenuDecoration::CMouseTrackContext::~CMouseTrackContext ()
{
    ReleaseCapture();

    if (m_fHotButtonPressed)
        ToggleHotButton ();
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::Track 
 *
 *
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::CMouseTrackContext::Track (CPoint point)
{
    int nButton = HitTest (point);

    /*-----------------------------------------------------*/
    /* if we're over the hot button and it's not pressed,  */
    /* or we're not over the hot button and it is pressed, */
    /* toggle the state of the hot button                  */
    /*-----------------------------------------------------*/
    if (((nButton != m_nHotButton) &&  m_fHotButtonPressed) ||
        ((nButton == m_nHotButton) && !m_fHotButtonPressed))
    {
        ToggleHotButton ();
    }
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::ToggleHotButton 
 *
 *
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::CMouseTrackContext::ToggleHotButton ()
{
    DrawCaptionControl (&CClientDC (m_pMenuDec),
                        m_rectButton[m_nHotButton], m_nHotButton,
                        m_fHotButtonPressed = !m_fHotButtonPressed);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::CMouseTrackContext::HitTest 
 *
 *
 *--------------------------------------------------------------------------*/

int CMDIMenuDecoration::CMouseTrackContext::HitTest (CPoint point) const
{
    for (int i = 0; i < countof (m_rectButton); i++)
    {
        if (m_rectButton[i].PtInRect (point))
            return (i);
    }

    return (-1);
}


/////////////////////////////////////////////////////////////////////////////
// CMDIMenuDecoration

CMDIMenuDecoration::CMDIMenuDecoration()
{
    // anMDIDataMap is indexed by these values
    ASSERT (DFCS_CAPTIONCLOSE   == 0);
    ASSERT (DFCS_CAPTIONMIN     == 1);
    ASSERT (DFCS_CAPTIONMAX     == 2);
    ASSERT (DFCS_CAPTIONRESTORE == 3);
}

CMDIMenuDecoration::~CMDIMenuDecoration()
{
}


BEGIN_MESSAGE_MAP(CMDIMenuDecoration, CWnd)
    //{{AFX_MSG_MAP(CMDIMenuDecoration)
    ON_WM_PAINT()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMDIMenuDecoration message handlers



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnPaint
 *
 * WM_PAINT handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnPaint() 
{
    CPaintDC dcPaint (this);

//#define DRAW_OFF_SCREEN
#ifndef DRAW_OFF_SCREEN
    CDC& dc = dcPaint;
#else
    CRect rect;
    GetClientRect (rect);
    const int cx = rect.Width();
    const int cy = rect.Height();

    CDC dcMem;
    CDC& dc = dcMem;
    dcMem.CreateCompatibleDC (&dcPaint);

    CBitmap bmMem;
    bmMem.CreateCompatibleBitmap (&dcPaint, cx, cy);

    CBitmap* pbmOld = dcMem.SelectObject (&bmMem);
#endif

    if (dcPaint.m_ps.fErase)
        dc.FillRect (&dcPaint.m_ps.rcPaint, AMCGetSysColorBrush (COLOR_BTNFACE));

    int     cxButton = GetSystemMetrics (SM_CXMENUSIZE);
    int     cyButton = GetSystemMetrics (SM_CYMENUSIZE);
    DWORD   dwStyle  = GetStyle ();

    CRect   rectDraw (0, 0, cxButton, cyButton);

    // make sure we don't have both the maximize and restore styles
    ASSERT ((dwStyle & (MMDS_MAXIMIZE | MMDS_RESTORE)) != 
                       (MMDS_MAXIMIZE | MMDS_RESTORE));

    // we shouldn't get here if we're tracking
    ASSERT (m_spTrackCtxt.get() == NULL);

    CMenu*  pSysMenu = GetActiveSystemMenu ();

    for (int i = 0; i < cMapEntries; i++)
    {
        int nDataIndex = anDrawOrder[i];

        if (dwStyle & anMDIDataMap[nDataIndex].dwStyle)
        {
            int nState = nDataIndex;

            if (!IsSysCommandEnabled (anMDIDataMap[nDataIndex].nCommand, pSysMenu))
                nState |= DFCS_INACTIVE;

            DrawCaptionControl (&dc, rectDraw, nState, false);
            rectDraw.OffsetRect (cxButton, 0);
        }
    }

#ifdef DRAW_OFF_SCREEN
    dcPaint.BitBlt (0, 0, cx, cy, &dcMem, 0, 0, SRCCOPY);
    dcMem.SelectObject (pbmOld);
#endif
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnWindowPosChanging
 *
 * WM_WINDOWPOSCHANGING handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
    DWORD   dwStyle = GetStyle ();

    if (dwStyle & MMDS_AUTOSIZE)
    {
        int cxButton = GetSystemMetrics (SM_CXMENUSIZE);
        int cyButton = GetSystemMetrics (SM_CYMENUSIZE);

        lpwndpos->cx = 0;
        lpwndpos->cy = cyButton;

        dwStyle &= MMDS_BTNSTYLES;

        while (dwStyle != 0)
        {
            if (dwStyle & 1)
                lpwndpos->cx += cxButton;

            dwStyle >>= 1;
        }
    }

    else
        CWnd::OnWindowPosChanging(lpwndpos);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnLButtonDown
 *
 * WM_LBUTTONDOWN handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

// this routine needs placement new syntax -- 
// temporarily remove MFC's incompatible placement new definition
#ifdef _DEBUG
#undef new
#endif

void CMDIMenuDecoration::OnLButtonDown(UINT nFlags, CPoint point) 
{
    typedef std::auto_ptr<char> CharPtr;

    CWnd::OnLButtonDown(nFlags, point);

    try
    {
        /*------------------------------------------------------------------*/
        /* This looks ugly.  We'd like to write:                            */
        /*                                                                  */
        /*     m_spTrackCtxt = CMouseTrackContextPtr (                      */
        /*                         new CMouseTrackContext (this, point));   */
        /*                                                                  */
        /* but CMouseTrackContext's ctor might throw an exception.  If it   */
        /* does, the smart pointer won't yet have been initialized so the   */
        /* CMouseTrackContext won't be deleted.                             */
        /*                                                                  */
        /* To get around it, we'll create a smart pointer pointing to a     */
        /* dynamically-allocated buffer of the right size.  That buffer     */
        /* will not leak with an exception.  We can then use a placement    */
        /* new to initialize a CMouseTrackContext in the hunk of memory.    */
        /* It's now not a problem if the CMouseTrackContext throws, because */
        /* the buffer is still protected it's own smart pointer.  Once      */
        /* the placement new completes successfully, we can transfer        */
        /* ownership of the object to a CMouseTrackContext smart pointer    */
        /* and we're golden.                                                */
        /*------------------------------------------------------------------*/
                                                                        
        // allocate a hunk of memory and construct a CMouseTrackContext in it
        CharPtr spchBuffer = CharPtr (new char[sizeof (CMouseTrackContext)]);
        CMouseTrackContext* pNewCtxt = new (spchBuffer.get()) CMouseTrackContext (this, point);

        // if we get here, the CMouseTrackContext initialized properly,
        // so we can transfer ownership to the CMouseTrackContext smart pointer
        spchBuffer.release ();
        m_spTrackCtxt = CMouseTrackContextPtr (pNewCtxt);
    }
    catch (CUserException* pe)       
    {
        // do nothing, just eat the exception
        pe->Delete();
    }
}

#ifdef _DEBUG
#define new DEBUG_NEW
#endif



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnLButtonUp
 *
 * WM_LBUTTONUP handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnLButtonUp(UINT nFlags, CPoint point) 
{
    if (m_spTrackCtxt.get() != NULL)
    {
        const int nHotButton = m_spTrackCtxt->m_nHotButton;
        const int nHitButton = m_spTrackCtxt->HitTest (point);

        // delete the track context
        m_spTrackCtxt = CMouseTrackContextPtr (NULL);

        if (nHitButton == nHotButton)
        {
            int cmd = anMDIDataMap[nHotButton].nCommand;

            // make sure the command looks like a valid sys command
            ASSERT (cmd >= 0xF000);

            ClientToScreen (&point);
            GetOwner()->SendMessage (WM_SYSCOMMAND, cmd,
                                     MAKELPARAM (point.x, point.y));
        }

    }
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::OnMouseMove
 *
 * WM_MOUSEMOVE handler for CMDIMenuDecoration.
 *--------------------------------------------------------------------------*/

void CMDIMenuDecoration::OnMouseMove(UINT nFlags, CPoint point) 
{
    if (m_spTrackCtxt.get() != NULL)
        m_spTrackCtxt->Track (point);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::GetActiveSystemMenu 
 *
 *
 *--------------------------------------------------------------------------*/

CMenu* CMDIMenuDecoration::GetActiveSystemMenu ()
{
    CFrameWnd* pwndFrame = GetParentFrame()->GetActiveFrame();
    ASSERT (pwndFrame != NULL);

    CMenu*  pSysMenu = pwndFrame->GetSystemMenu (FALSE);
    ASSERT (pSysMenu != NULL);

    return (pSysMenu);
}



/*--------------------------------------------------------------------------*
 * CMDIMenuDecoration::IsSysCommandEnabled 
 *
 *
 *--------------------------------------------------------------------------*/

bool CMDIMenuDecoration::IsSysCommandEnabled (int nSysCommand, CMenu* pSysMenu)
{
    if (pSysMenu == NULL)
        pSysMenu = GetActiveSystemMenu ();

    int nState = pSysMenu->GetMenuState (nSysCommand, MF_BYCOMMAND);
    ASSERT (nState != 0xFFFFFFFF);

    return ((nState & MF_GRAYED) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\menubar.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      menubar.cpp
 *
 *  Contents:  Implementation file for CMenuBar
 *
 *  History:   14-Nov-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/


#include "stdafx.h"
#include "menubar.h"
#include "mdiuisim.h"
#include "amc.h"
#include "amcdoc.h"
#include "mainfrm.h"
#include "tbtrack.h"
#include "mnemonic.h"
#include "childfrm.h"
#include "menubtns.h"
#include <algorithm>
#include <mmsystem.h>
#include <oleacc.h>
#include "amcview.h"
#include "favorite.h"
#include "util.h"

/*
 * if we're supporting old platforms, we need to get MSAA definitions
 * from somewhere other than winuser.h
 */
#if (_WINNT_WIN32 < 0x0500)
	#include <winable.h>
#endif

/*--------*/
/* SAccel */
/*--------*/
struct SAccel : public ACCEL
{
    SAccel (WORD key_, WORD cmd_, BYTE fVirt_)
    {
        ZeroMemory (this, sizeof (*this));
        key   = key_;
        cmd   = cmd_;
        fVirt = fVirt_;
    }
};


/*--------------------*/
/* CPopupTrackContext */
/*--------------------*/
class CPopupTrackContext
{
public:
    CPopupTrackContext (CMenuBar* pMenuBar, int nCurrentPopupIndex);
    ~CPopupTrackContext ();

    // control over monitoring
    void StartMonitoring();
    bool WasAnotherPopupRequested(int& iNewIdx);

private:
    typedef std::vector<int>                    BoundaryCollection;
    typedef BoundaryCollection::iterator        BoundIt;
    typedef BoundaryCollection::const_iterator  BoundConstIt;

    BoundaryCollection  m_ButtonBoundaries;
    CMenuBar* const     m_pMenuBar;
    HHOOK               m_hhkMouse;
    HHOOK               m_hhkKeyboard;
    HHOOK               m_hhkCallWnd;
    CRect               m_rectAllButtons;
    CPoint              m_ptLastMouseMove;
    int                 m_nCurrentPopupIndex;

    CWnd*               m_pMaxedMDIChild;
    const CPoint        m_ptLButtonDown;
    const UINT          m_dwLButtonDownTime;
    const int           m_cButtons;
    int                 m_cCascadedPopups;
    bool                m_fCurrentlyOnPopupItem;
    bool                m_bPopupMonitorHooksActive;
    int                 m_iRequestForNewPopup;

    LRESULT MouseProc    (int nCode, UINT msg, LPMOUSEHOOKSTRUCT pmhs);
    LRESULT KeyboardProc (int nCode, int vkey, int cRepeat, bool fDown, LPARAM lParam);
    LRESULT CallWndProc  (int nCode, BOOL bCurrentThread, LPCWPSTRUCT lpCWP);

    int  HitTest (CPoint pt) const;
    int  MapBoundaryIteratorToButtonIndex (BoundConstIt it) const;
    void MaybeCloseMDIChild (CPoint pt);
    void DismissCurrentPopup (bool fTrackingComplete);
    void NotifyNewPopup (int nNewPopupIndex);

    void  SetPopupMonitorHooks();
    void  RemovePopupMonitorHooks();
    static LRESULT CALLBACK MouseProc    (int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK KeyboardProc (int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK CallWndProc  (int nCode, WPARAM wParam, LPARAM lParam);
    static CPopupTrackContext*  s_pTrackContext;
};

CPopupTrackContext* CPopupTrackContext::s_pTrackContext = NULL;



const TCHAR chChildSysMenuMnemonic = _T('-');



/*--------------------------------------------------------------------------*
 * AddMnemonic
 *
 *
 *--------------------------------------------------------------------------*/

template<class OutputIterator>
static void AddMnemonic (
    TCHAR           chMnemonic,
    int             cmd,
    BYTE            fVirt,
    OutputIterator  it)
{
    ASSERT (chMnemonic != _T('\0'));

    TCHAR chLower = (TCHAR)CharLower((LPTSTR)chMnemonic);
    TCHAR chUpper = (TCHAR)CharUpper((LPTSTR)chMnemonic);

    /*
     * add the lowercase mnemonic
     */
    *it++ = SAccel (chLower, (WORD) cmd, fVirt);

    /*
     * if the uppercase mnemonic character is different from the
     * lowercase character, add the uppercase mnemonic as well
     */
    if (chUpper != chLower)
        *it++ = SAccel (chUpper, (WORD) cmd, fVirt);
}



/*--------------------------------------------------------------------------*
 * PrepBandInfo
 *
 *
 *--------------------------------------------------------------------------*/

static void PrepBandInfo (LPREBARBANDINFO prbi, UINT fMask)
{
    ZeroMemory (prbi, sizeof (REBARBANDINFO));
    prbi->cbSize = sizeof (REBARBANDINFO);
    prbi->fMask  = fMask;
}



/////////////////////////////////////////////////////////////////////////////
// CMenuBar

BEGIN_MESSAGE_MAP(CMenuBar, CMMCToolBarCtrlEx)
    //{{AFX_MSG_MAP(CMenuBar)
    ON_NOTIFY_REFLECT(TBN_DROPDOWN, OnDropDown)
    ON_NOTIFY_REFLECT(TBN_GETDISPINFO, OnGetDispInfo)
    ON_NOTIFY_REFLECT(TBN_HOTITEMCHANGE, OnHotItemChange)
    ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, OnCustomDraw)
    ON_WM_SYSCOMMAND()
    ON_WM_SETTINGCHANGE()
    ON_WM_DESTROY()
    ON_COMMAND(ID_MTB_ACTIVATE_CURRENT_POPUP, OnActivateCurrentPopup)
    //}}AFX_MSG_MAP

    ON_MESSAGE(WM_POPUP_ASYNC, OnPopupAsync)
    ON_COMMAND(CMMCToolBarCtrlEx::ID_MTBX_PRESS_HOT_BUTTON, OnActivateCurrentPopup)
    ON_COMMAND_RANGE(ID_MTB_MENU_FIRST, ID_MTB_MENU_LAST, OnAccelPopup)
    ON_UPDATE_COMMAND_UI_RANGE(ID_MTB_MENU_FIRST, ID_MTB_MENU_LAST, OnUpdateAllCmdUI)
END_MESSAGE_MAP()




/*--------------------------------------------------------------------------*
 * CMenuBar::GetMenuUISimAccel
 *
 * Manages the accelerator table singleton for CMenuBar
 *--------------------------------------------------------------------------*/

const CAccel& CMenuBar::GetMenuUISimAccel ()
{
    static ACCEL aaclTrack[] = {
        {   FVIRTKEY,   VK_RETURN,  CMenuBar::ID_MTB_ACTIVATE_CURRENT_POPUP },
        {   FVIRTKEY,   VK_UP,      CMenuBar::ID_MTB_ACTIVATE_CURRENT_POPUP },
        {   FVIRTKEY,   VK_DOWN,    CMenuBar::ID_MTB_ACTIVATE_CURRENT_POPUP },
    };

    static const CAccel MenuUISimAccel (aaclTrack, countof (aaclTrack));
    return (MenuUISimAccel);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::CMenuBar
 *
 *
 *--------------------------------------------------------------------------*/

CMenuBar::CMenuBar ()
{
    m_pMDIFrame                = NULL;
    m_pwndLastActive           = NULL;
    m_pRebar                   = NULL;
    m_hMenuLast                = NULL;
    m_hMaxedChildIcon          = NULL;
    m_fDestroyChildIcon        = false;
    m_fDecorationsShowing      = false;
    m_fMaxedChildIconIsInvalid = false;
    m_CommandIDUnUsed.clear();
    m_vMenuAccels.clear();
    m_vTrackingAccels.clear();
    m_bInProgressDisplayingPopup = false;
}



/*--------------------------------------------------------------------------*
 * CMenuBar::~CMenuBar
 *
 *
 *--------------------------------------------------------------------------*/

CMenuBar::~CMenuBar ()
{
    DeleteMaxedChildIcon();
}



/*--------------------------------------------------------------------------*
 * CMenuBar::Create
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CMenuBar::Create (
    CFrameWnd *         pwndFrame,
    CRebarDockWindow*   pParentRebar,
    DWORD               dwStyle,
    UINT                idWindow)
{
    ASSERT_VALID (pwndFrame);
    ASSERT_VALID (pParentRebar);

    // create the window
    if (!CMMCToolBarCtrlEx::Create (NULL, dwStyle | TBSTYLE_LIST,
                                    g_rectEmpty, pParentRebar, idWindow))
        return (FALSE);

    // initialize to hidded accelerator state
    SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));

    // insert a hidden button for the maximized child's system menu
    InsertButton (0, (LPCTSTR) NULL, ID_MTB_MENU_SYSMENU, NULL, 0, 0);

    TBBUTTONINFO btni;
    btni.cbSize  = sizeof (btni);
    btni.dwMask  = TBIF_STATE | TBIF_SIZE;
    btni.fsState = TBSTATE_HIDDEN;
    btni.cx      = static_cast<WORD>(GetSystemMetrics (SM_CXSMICON));

    SetButtonInfo (ID_MTB_MENU_SYSMENU, &btni);

#ifdef SHRINK_PADDING
    CSize sizePad = GetPadding();
    sizePad.cx = 3;
    SetPadding (sizePad);
#endif  // SHRINK_PADDING

    SetMenuFont ();
    m_pRebar = pParentRebar->GetRebar();

    return (TRUE);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::Create
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CMenuBar::Create (
    CMDIFrameWnd *      pwndFrame,
    CRebarDockWindow*   pParentRebar,
    DWORD               dwStyle,
    UINT                idWindow)
{
    if (!Create ((CFrameWnd*) pwndFrame, pParentRebar, dwStyle, idWindow))
        return (FALSE);

    m_pMDIFrame = pwndFrame;

    // this is a menu for an MDI frame window; create MDI decorations
    m_pMDIDec = std::auto_ptr<CMDIMenuDecoration>(new CMDIMenuDecoration);
    m_pMDIDec->Create (NULL, NULL,
                       WS_CHILD | MMDS_MINIMIZE |
                            MMDS_RESTORE | MMDS_CLOSE | MMDS_AUTOSIZE,
                       g_rectEmpty, this, ID_MDIDECORATION);

    // the rebar will re-parent the decoration, make sure we remain the owner
    m_pMDIDec->SetOwner (this);

    // insert the MDI decoration band
    REBARBANDINFO   rbi;
    PrepBandInfo (&rbi, RBBIM_CHILD | RBBIM_STYLE | RBBIM_ID);

    rbi.fStyle    = RBBS_FIXEDSIZE | RBBS_HIDDEN;
    rbi.hwndChild = m_pMDIDec->m_hWnd;
    rbi.wID       = ID_MDIDECORATION;

    ASSERT (m_pRebar != NULL);
    m_pRebar->InsertBand (&rbi);

    // resize the decoration window, *after* inserting the band
    SizeDecoration ();

    // there's bug in rebar which will show a band's
    // child, even with RBBS_HIDDEN, work around it
    m_pMDIDec->ShowWindow (SW_HIDE);

    return (TRUE);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::PreTranslateMessage
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CMenuBar::PreTranslateMessage(MSG* pMsg)
{
    // show accelerators, since user indicated he wants to control using the keyboard
    if ( (pMsg->message == WM_SYSKEYDOWN ) &&
         (!(pMsg->lParam & 0x40000000)/*not repeating*/) )
    {
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    }

    if (CMMCToolBarCtrlEx::PreTranslateMessage (pMsg))
        return (TRUE);

    if ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST))
    {
        CMainFrame* pFrame = AMCGetMainWnd();
        if ((pFrame == NULL) || !pFrame->IsMenuVisible())
            return (FALSE);

        // if we're in menu mode, check menu mode-only accelerators
        if (IsTrackingToolBar ())
        {
            const CAccel& MenuUISimAccel = GetMenuUISimAccel();

            ASSERT (MenuUISimAccel != NULL);
            if (MenuUISimAccel.TranslateAccelerator (m_hWnd, pMsg))
                return (TRUE);

            ASSERT (m_TrackingAccel != NULL);
            if (m_TrackingAccel.TranslateAccelerator (m_hWnd, pMsg))
                return (TRUE);
        }

        if ((m_MenuAccel != NULL) && m_MenuAccel.TranslateAccelerator (m_hWnd, pMsg))
            return (TRUE);

        // handle Alt+- when child is maximized
        if (m_fDecorationsShowing &&
            (pMsg->message == WM_SYSCHAR) &&
            (pMsg->wParam  == chChildSysMenuMnemonic))
        {
            SendMessage (WM_COMMAND, ID_MTB_MENU_SYSMENU);
            return (TRUE);
        }
    }

    return (FALSE);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::SetMenu
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::SetMenu (CMenu* pMenu)
{
    HMENU hMenu = pMenu->GetSafeHmenu();

    // don't need to do anything if we're setting the same menu as last time
    if (hMenu == m_hMenuLast)
        return;

    // remember this menu for optimization next time
    m_hMenuLast = hMenu;

    // delete all but the first existing buttons from the toolbar
    while (DeleteButton(1))
    {
    }

    // delete the previous dynamic accelerator table
    m_MenuAccel.DestroyAcceleratorTable ();
    m_strAccelerators.Empty ();

    // this should have been done in CMenuBar::Create
    ASSERT (GetBitmapSize().cx == 0);

    if (pMenu != NULL)
    {
        CString      strMenuText;

        // Clear the accels before calling InsertButton
        // which adds accels for each button.
        m_vMenuAccels.clear();
        m_vTrackingAccels.clear();

        int cMenuItems     = pMenu->GetMenuItemCount();

        // Initialize Unused command IDs pool.
        m_CommandIDUnUsed.clear();
        for (INT idCommand = ID_MTB_FIRST_COMMANDID;
             idCommand < ID_MTB_MENU_LAST;
             idCommand++)
        {
            m_CommandIDUnUsed.insert(idCommand);
        }

        for (int i = 0; i < cMenuItems; i++)
        {
            // get the menu text and add it to the toolbar
            pMenu->GetMenuString (i, strMenuText, MF_BYPOSITION);

            // sometimes empty items will be appended to the menu, ignore them
            if (strMenuText.IsEmpty ())
                continue;

            if (m_CommandIDUnUsed.empty())
            {
                ASSERT(FALSE);
            }

            // See if this top level menu has sub menus, if so when menu is clicked
            // it is popped up else it is Action or View or Favorites menu
            // for which submenu is dynamic and has to be constructured.
            // So we set the TBBUTTON.dwData member with submenu (for static menus)
            // or NULL for for dynamic menus like Action, View, Favorites.
            CMenu* pSubMenu = pMenu->GetSubMenu(i);
            DWORD_PTR dwMenuData = NULL;
            BYTE      byState = 0;

            if (pSubMenu)
            {
                // Get an unused command id for this button.
                CommandIDPool::iterator itCommandID = m_CommandIDUnUsed.begin();
                idCommand = *itCommandID;
                m_CommandIDUnUsed.erase(itCommandID);
                dwMenuData = reinterpret_cast<DWORD_PTR>(pSubMenu->GetSafeHmenu());
            }
            else
            {
                UINT uMenuID = pMenu->GetMenuItemID(i);
                switch (uMenuID)
                {
                case ID_ACTION_MENU:
                    idCommand = ID_MTB_MENU_ACTION;
                    break;

                case ID_VIEW_MENU:
                    idCommand = ID_MTB_MENU_VIEW;
                    break;

                case ID_FAVORITES_MENU:
                    idCommand = ID_MTB_MENU_FAVORITES;
                    break;

                case ID_SNAPIN_MENU_PLACEHOLDER:
                   /*
                    * We add a hidden menu as a marker. Later when snapin
                    * calls to insert a menu button we find the position
                    * of this menu and add snapin menu before it.
                    */
                    idCommand = ID_MTB_MENU_SNAPIN_PLACEHOLDER;
                    byState |= TBSTATE_HIDDEN; // Add this as hidden.
                    break;

                default:
                    ASSERT(FALSE);
                    return;
                    break;
                }

                bool bShow = IsStandardMenuAllowed(uMenuID);
                if (! bShow)
                    byState |= TBSTATE_HIDDEN;

            }


            // append this button to the end of the toolbar
            InsertButton (-1, strMenuText, idCommand, dwMenuData, byState, TBSTYLE_AUTOSIZE);
        }

        // add the accelerator for the child system menu
        std::back_insert_iterator<AccelVector>
            itTrackingInserter = std::back_inserter (m_vTrackingAccels);

        AddMnemonic (chChildSysMenuMnemonic, ID_MTB_MENU_SYSMENU, 0,    itTrackingInserter);
    }


    UpdateToolbarSize ();
    AutoSize ();
}



//+-------------------------------------------------------------------
//
//  Member:     InsertButton
//
//  Synopsis:   Insert a menu (button) to the main menu and then
//              if there is a mnemonic char add it to accelerator
//              and re-load the accelerators.
//
//  Arguments:  [nIndex]     - index after which to insert.
//              [strText]    - menu text.
//              [idCommand]  - ID of command to notify with.
//              [dwMenuData] - either submenu to be displayed (for static menus)
//                             or NULL for Action, View & Favorites.
//              [fsState]    - additional button states.
//              [fsStyle]    - additional button styles.
//
//  Returns:    BOOL
//
//  Note:       dwMenuData is handle to submenu for File, Window, Help menus whose
//              sub-menu is static. But for top level menus like Action, View, Favorites,
//              and Snapin menus it is NULL.
//
//--------------------------------------------------------------------
BOOL CMenuBar::InsertButton (
    int             nIndex,
    const CString&  strText,
    int             idCommand,
    DWORD_PTR       dwMenuData,
    BYTE            fsState,
    BYTE            fsStyle)
{
    TBBUTTON    btn;

    btn.iBitmap   = nIndex;
    btn.idCommand = idCommand;

    if (fsState & TBSTATE_HIDDEN)
        btn.fsState   = fsState;
    else
        btn.fsState   = TBSTATE_ENABLED  | fsState;

    btn.fsStyle   = TBSTYLE_DROPDOWN | fsStyle;
    btn.dwData    = dwMenuData;
    btn.iString   = AddString (strText);

    ASSERT(GetButtonCount() <= cMaxTopLevelMenuItems);
    ASSERT (btn.idCommand <= ID_MTB_MENU_LAST);

    BOOL bRet = CMMCToolBarCtrlEx::InsertButton (nIndex, &btn);
    if (bRet == FALSE)
        return bRet;

    // Successfully added the menu button. Now add
    // the accelerator for this item to our dynamic tables
    TCHAR chMnemonic = GetMnemonicChar (static_cast<LPCTSTR>(strText));

    if (chMnemonic != _T('\0'))
    {

        std::back_insert_iterator<AccelVector>
            itMenuInserter = std::back_inserter (m_vMenuAccels);
        std::back_insert_iterator<AccelVector>
            itTrackingInserter = std::back_inserter (m_vTrackingAccels);

        // add the Alt+<mnemonic> accelerator for use all the time
        AddMnemonic (chMnemonic, idCommand, FALT, itMenuInserter);

        // add the <mnemonic> accelerator for use when we're in menu mode
        AddMnemonic (chMnemonic, idCommand, 0,    itTrackingInserter);

        m_strAccelerators += (TCHAR)CharLower((LPTSTR)chMnemonic);
        m_strAccelerators += (TCHAR)CharUpper((LPTSTR)chMnemonic);
    }

    // Re-load the accelerators
    LoadAccels();

    return bRet;
}


//+-------------------------------------------------------------------
//
//  Member:     LoadAccels
//
//  Synopsis:   Load the accelerators. (This destorys old accel table
//              and creates accel table).
//
//  Arguments:  None.
//
//  Returns:    void
//
//--------------------------------------------------------------------
void CMenuBar::LoadAccels()
{
    // create the accelerator tables for the menu
    m_MenuAccel    .CreateAcceleratorTable (m_vMenuAccels.begin (),
                                            m_vMenuAccels.size  ());
    m_TrackingAccel.CreateAcceleratorTable (m_vTrackingAccels.begin (),
                                            m_vTrackingAccels.size  ());
}

//+-------------------------------------------------------------------
//
//  Member:     InsertMenuButton
//
//  Synopsis:   Insert a menu button to the main menu, called by
//              CMenuButtonsMgr to add any snapin menus.
//
//  Arguments:  [lpszButtonText] - menu text.
//              [bHidden]        - Is this menu to be inserted hidden or not.
//              [iPreferredPos]  - The preferred position of this button.
//
//  Returns:    LONG, the command id of the inserted button.
//                    -1 if failed.
//
// Note:        The snapin added menus should be added before the Window menu.
//              For this a hidden menu is added (in SetMenu) which tells the
//              position where snapin menu is to be added. If iPreferredPos is -1
//              then find the position of this menu and add the menu before it.
//
//--------------------------------------------------------------------
LONG CMenuBar::InsertMenuButton(LPCTSTR lpszButtonText,
                                BOOL bHidden,
                                                                int  iPreferredPos)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (m_CommandIDUnUsed.size() == 0)
        return -1;

    // Get a command id for this button from the pool
    CommandIDPool::iterator itCommandID = m_CommandIDUnUsed.begin();
    int idCommand = *itCommandID;
    m_CommandIDUnUsed.erase(itCommandID);

    CString str = lpszButtonText;

    // Add snapin  menus before the SNAPIN_MENU_PLACE holder.
    // See CMenubar::SetMenu.
        if (-1 == iPreferredPos)
        iPreferredPos = CommandToIndex(ID_MTB_MENU_SNAPIN_PLACEHOLDER);

    BOOL bSuccess = InsertButton(iPreferredPos,
                                 str, idCommand,
                                 NULL,
                                 bHidden ? TBSTATE_HIDDEN : 0,
                                 TBSTYLE_AUTOSIZE);

    if (bSuccess)
    {
        UpdateToolbarSize ();
        AutoSize ();
        return idCommand;
    }

    return -1;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteMenuButton
//
//  Synopsis:   Delete a menu button from the main menu, called by
//              CMenuButtonsMgr
//
//  Arguments:  [nCommandID]      - Command ID of the menu.
//
//  Returns:    BOOL
//
//  Note:       Delete should also delete the accelerator.
//
//--------------------------------------------------------------------
BOOL CMenuBar::DeleteMenuButton(INT nCommandID)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    int iIndex = CommandToIndex(nCommandID);

    // We need to delete the mnemonics. So let us get the old
    // mnemonic before deleting the button.

    // 1. Get the menu text (string) index.
    TBBUTTON tbbi;
    ZeroMemory(&tbbi, sizeof(tbbi));
    BOOL bSuccess = GetButton(iIndex, &tbbi);
    if (FALSE == bSuccess)
        return bSuccess;

    // 2. Delete the button.
    bSuccess = DeleteButton(iIndex);
    ASSERT(bSuccess);
    if (FALSE == bSuccess)
        return bSuccess;

    // Add the command id to the unused pool.
    m_CommandIDUnUsed.insert(nCommandID);

    // Get the mnemonic and Delete it.
    ASSERT(m_ToolbarStringPool.size() > tbbi.iString);
    CString strText = m_ToolbarStringPool[tbbi.iString];
    for (AccelVector::iterator itAccel = m_vMenuAccels.begin();
         itAccel != m_vMenuAccels.end();
         itAccel++)
    {
        if (itAccel->cmd == (WORD)nCommandID)
        {
            m_vMenuAccels.erase(itAccel);
            break;
        }
    }

    for (AccelVector::iterator itTrack = m_vTrackingAccels.begin();
         itTrack != m_vTrackingAccels.end();
         itTrack++)
    {
        if (itTrack->cmd == (WORD)nCommandID)
        {
            m_vTrackingAccels.erase(itTrack);
            break;
        }
    }

    // Delete the mnemonic from m_strAccelerators.
    TCHAR chMnemonicOld = GetMnemonicChar (static_cast<LPCTSTR>(strText));
    if (chMnemonicOld != _T('\0'))
    {
        // CString::Remove cannot be used as it is for VC6. We use the tstring
        // to remove chars from the mnemonic string.
        tstring tstrAccels = m_strAccelerators;

        tstring::iterator itNewEnd = std::remove(tstrAccels.begin(), tstrAccels.end(), (TCHAR)CharUpper((LPTSTR)chMnemonicOld));
        tstrAccels.erase(itNewEnd, tstrAccels.end());
        itNewEnd = std::remove(tstrAccels.begin(), tstrAccels.end(), (TCHAR)CharLower((LPTSTR)chMnemonicOld));
        tstrAccels.erase(itNewEnd, tstrAccels.end());
        m_strAccelerators = tstrAccels.data();
    }

    return bSuccess;
}

//+-------------------------------------------------------------------
//
//  Member:     SetMenuButton
//
//  Synopsis:   Modify menu button text, called by CMenuButtonsMgr
//
//  Arguments:  [nCommandID]     - Command ID.
//              [lpszButtonText] - New text.
//
//  Returns:    LONG, command id of the menu (-1 if failed to change).
//
//  Note:       We delete the old button and add a new button with this
//              name and button id.
//              The reason for not calling SetButtonInfo is it does not allow us
//              to change the string index (iString in TBBUTTON).
//
//--------------------------------------------------------------------
LONG CMenuBar::SetMenuButton(INT nCommandID, LPCTSTR lpszButtonText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    // Note the index and hidden state.
    int iIndex = CommandToIndex(nCommandID);
    bool bHidden = IsButtonHidden(nCommandID);

    // Please see the note above about why we do Delete and Insert
    // instead of Set.
    BOOL bSuccess = DeleteMenuButton(nCommandID);

    if (bSuccess)
        return InsertMenuButton(lpszButtonText, bHidden, iIndex);

    return -1;
}


/*--------------------------------------------------------------------------*
 * CMenuBar::SetMenuFont
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::SetMenuFont ()
{
    // delete the old font
    m_MenuFont.DeleteObject ();

    // query the system for the current menu font
    NONCLIENTMETRICS    ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    // use it here, too
    m_MenuFont.CreateFontIndirect (&ncm.lfMenuFont);
    SetFont (&m_MenuFont, FALSE);

    /*
     * get the metrics for the menu text, so we can use it's height
     */
    TEXTMETRIC tm;
    CWindowDC dc(this);
    CFont* pOldFont = dc.SelectObject (&m_MenuFont);
    dc.GetTextMetrics (&tm);
    dc.SelectObject (pOldFont);

    /*
     * Menu item buttons will contain only text (no bitmaps), so set the
     * bitmap width to 0 so we don't have unwanted whitespace.
     *
     * We need to reserve height for the bitmap, though.  If we don't do
     * this, then the toolbar will calculate its own height to be too
     * small when there aren't any buttons with text.  (This occurs in MDI
     * user mode when the active child is maximized.  In that case, the
     * system menu button is visible, but we have no menu items.)
     */
    SetBitmapSize (CSize (0, std::_MAX ((int) tm.tmHeight,
                                        GetSystemMetrics (SM_CXSMICON))));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnActivateCurrentPopup
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::OnActivateCurrentPopup ()
{
    PopupMenu (GetHotItem(), false /*bHighlightFirstItem*/);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnDestroy
 *
 * WM_DESTROY handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnDestroy()
{
    CMMCToolBarCtrlEx::OnDestroy();
    GetMaxedChildIcon (NULL);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnSysCommand
 *
 * WM_SYSCOMMAND handler for CMenuBar.
 *
 * If we want to get the right sound effects for the action, we'll need to
 * let DefWindowProc handle the message.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnSysCommand(UINT nID, LPARAM lParam)
{
    ASSERT (m_pMDIFrame != NULL);

    BOOL            bMaximized;
    CMDIChildWnd*   pwndActive = m_pMDIFrame->MDIGetActive (&bMaximized);

    // if the user has quick fingers he may succeed in issuing the command
    // while the document is being closed - thus there may not be any
    // child windows at all. We ignore the command in such case
    // see bug #119775: MMC Crashes when snapin delays in closing down.
    if (pwndActive == NULL)
        return;

    switch (nID & 0xFFF0)
    {
        case SC_MINIMIZE:   pwndActive->ShowWindow  (SW_MINIMIZE);  break;
        case SC_MAXIMIZE:   pwndActive->ShowWindow  (SW_MAXIMIZE);  break;
        case SC_RESTORE:    pwndActive->ShowWindow  (SW_RESTORE);   break;
        case SC_CLOSE:      pwndActive->SendMessage (WM_CLOSE);     break;
        default:
            CMMCToolBarCtrlEx::OnSysCommand (nID, lParam);
            break;
    }
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        // the system menu font may have changed; update it now
        SetMenuFont ();

        // resize the decoration window
        SizeDecoration ();

        // update the size of the system menu button
        TBBUTTONINFO btni;
        btni.cbSize  = sizeof (btni);
        btni.dwMask  = TBIF_SIZE;
        btni.cx      = static_cast<WORD>(GetSystemMetrics (SM_CXSMICON));
        SetButtonInfo (ID_MTB_MENU_SYSMENU, &btni);

        m_fMaxedChildIconIsInvalid = true;

        // auto-size the toolbar
        UpdateToolbarSize ();
        AutoSize ();
    }
}



/*--------------------------------------------------------------------------*
 * CMenuBar::SizeDecoration
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::SizeDecoration ()
{
    if (m_pMDIDec.get() == NULL)
        return;

    // jiggle the window's size so it will auto-size...
    m_pMDIDec->SetWindowPos (NULL, 0, 0, 10, 10,
                             SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);

    CRect   rect;
    m_pMDIDec->GetClientRect (rect);

    // ...and update its band to accomodate it
    REBARBANDINFO   rbi;
    PrepBandInfo (&rbi, RBBIM_SIZE | RBBIM_CHILDSIZE);
    rbi.cx         = rect.Width();
    rbi.cxMinChild = rect.Width();
    rbi.cyMinChild = rect.Height();

    m_pRebar->SetBandInfo (GetDecorationBandIndex (), &rbi);
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnDropDown
 *
 * Reflected TBN_DROPDOWN handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg void CMenuBar::OnDropDown (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);

    // pop up the menu. Use async method, because toolbar will
    // keeb the button hilited until this function returns
    PopupMenuAsync (CommandToIndex (((LPNMTOOLBAR) pHdr)->iItem));

    // drop down notification handled here
    *pResult = TBDDRET_DEFAULT;
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnGetDispInfo
 *
 * Reflected TBN_GETDISPINFO handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg void CMenuBar::OnGetDispInfo (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);

    if (m_fDecorationsShowing)
    {
        NMTBDISPINFO*   ptbdi = reinterpret_cast<NMTBDISPINFO *>(pHdr);

        if ((ptbdi->dwMask & TBNF_IMAGE) &&
            (ptbdi->idCommand != ID_MTB_MENU_SYSMENU))
        {
            ptbdi->iImage = -1;
        }
    }
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnCustomDraw
 *
 * Reflected NM_CUSTOMDRAW handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg void CMenuBar::OnCustomDraw (
    NMHDR *     pHdr,
    LRESULT *   pResult)
{
    ASSERT (CWnd::FromHandle (pHdr->hwndFrom) == this);
    LPNMCUSTOMDRAW pnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(pHdr);

    switch (pnmcd->dwDrawStage)
    {
        case CDDS_PREPAINT:
            // notify for individual buttons
            *pResult = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
            // draw the system menu button manually
            if (pnmcd->dwItemSpec == ID_MTB_MENU_SYSMENU)
            {
                if (m_fMaxedChildIconIsInvalid)
                    GetMaxedChildIcon (m_pMDIFrame->MDIGetActive());

                if (m_hMaxedChildIcon != NULL)
                {
                    /*
                     * compute the location at which we'll draw,
                     * biasing down and to the left
                     */
                    CRect rect = pnmcd->rc;
                    int dx = (rect.Width()  - GetSystemMetrics(SM_CXSMICON)    ) / 2;
                    int dy = (rect.Height() - GetSystemMetrics(SM_CYSMICON) + 1) / 2;



					/*
					 * Preserve icon shape when BitBlitting it to a
					 * mirrored DC.
					 */
					DWORD dwLayout=0L;
					if ((dwLayout=GetLayout(pnmcd->hdc)) & LAYOUT_RTL)
					{
						SetLayout(pnmcd->hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
					}

                    DrawIconEx (pnmcd->hdc,
                                rect.left + dx,
                                rect.top  + dy,
                                m_hMaxedChildIcon, 0, 0, 0,
                                NULL, DI_NORMAL);


					/*
					 * Restore the DC to its previous layout state.
					 */
					if (dwLayout & LAYOUT_RTL)
					{
						SetLayout(pnmcd->hdc, dwLayout);
					}
                }

                // skip the default drawing
                *pResult = CDRF_SKIPDEFAULT;
            }
            else
            {
                // do the default drawing
                *pResult = CDRF_DODEFAULT;
            }
            break;
    }
}



/*--------------------------------------------------------------------------*
 * CMenuBar::PopupMenuAsync
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::PopupMenuAsync (int nItemIdex)
{
    PostMessage (WM_POPUP_ASYNC, nItemIdex);
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnPopupAsync
 *
 * WM_POPUP_ASYNC handler for void CMenuBar.
 *--------------------------------------------------------------------------*/

afx_msg LRESULT CMenuBar::OnPopupAsync (WPARAM wParam, LPARAM)
{
    PopupMenu (wParam, false /*bHighlightFirstItem*/);
    return (0);
}

/***************************************************************************\
 *
 * METHOD:  CMenuBar::OnHotItemChange
 *
 * PURPOSE: Called when item hiliting changes. Used here to detect when menu
 *          is dissmissed to reset the UI
 *
 * PARAMETERS:
 *    NMHDR* pNMHDR
 *    LRESULT* pResult
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
afx_msg void CMenuBar::OnHotItemChange(NMHDR* pNMHDR, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CMenuBar::OnHotItemChange"));

    // parameter chack
    sc = ScCheckPointers(pNMHDR, pResult);
    if (sc)
        return;

    // init out parameter
    *pResult = 0;

    // let the base class do it's job
    CMMCToolBarCtrlEx::OnHotItemChange(pNMHDR, pResult);

    // if menu is dismissed and not because of popup being displayed,
    // we need to revert to initial state by hiding accelerators
    LPNMTBHOTITEM lpNmTbHotItem = (LPNMTBHOTITEM)pNMHDR;
    if ( (*pResult == 0) &&
         (lpNmTbHotItem->dwFlags & HICF_LEAVING) &&
         !m_bInProgressDisplayingPopup )
    {
        SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CMenuBar::PopupMenu
 *
 * PURPOSE: Displays the popup menu specified by the index.
 *
 * PARAMETERS:
 *    int   nItemIndex :
 *    bool  bHighlightFirstItem : true to automatically highlight the first item
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CMenuBar::PopupMenu (int nItemIndex, bool bHighlightFirstItem)
{
    DECLARE_SC(sc, TEXT("CMenuBar::PopupMenu"));

    // get the rectangle that we don't want the popup to overlap
    CRect   rectExclude;
    CPopupTrackContext popupMonitor(this, nItemIndex);

    /*
     * OnIdle updates various member variables such as
     * m_fDecorationsShowing. It must be called before
     * popup menu is created to ensure accurate information
     */
    OnIdle();

    // there is high possibility, that the code in following block
    // adds nothing to the current functionality. It is left as it was
    // in previos implementation, since it isn't obvios if removing it
    // does not break anything.
    // Even if the block is removed, call to EndTracking() at the end of method
    // must still be present to exit tracking if it was put by entering menu
    // via pressing the ALT key
    {
        /*
         * make sure the frame's tracking manager is in tracking mode
         */
        CMainFrame* pFrame = AMCGetMainWnd();
        if (pFrame != NULL)
        {
            CToolbarTracker*    pTracker = pFrame->GetToolbarTracker();
            ASSERT (pTracker != NULL);

            if (!pTracker->IsTracking())
                pTracker->BeginTracking();
        }

        BeginTracking ();
    }

    // following is to indicate that the change in menu (if one does occurr)
    // is because of attempt to switch to another submenu, and should not be
    // treated as dismissing the menu. thus accelerator state should not be changed
    m_bInProgressDisplayingPopup = true;

    // There are two ways the popup menu is dismissed. it either:
    // - request to display the new popup (left & right arrows, mouse on other item, etc)
    // - or request to close the menu ( command is selected, ESC is pressed )
    // following loop will continue displaying menus until request to close the menu is received
    do {

        GetItemRect (nItemIndex, rectExclude);
        MapWindowPoints (NULL, rectExclude);

        // get the information for this button
        TBBUTTON    btn;
        GetButton (nItemIndex, &btn);

        // if the requested button is ignorable, punt
        if (::IsIgnorableButton (btn))
            break;

        // get the popup menu to display
        HMENU   hPopupMenu = (HMENU) btn.dwData;

        // For system menu hPopupMenu will be NULL.
        // If system menu is requested get it now.
        if (ID_MTB_MENU_SYSMENU == btn.idCommand)
        {
            ASSERT (m_fDecorationsShowing);
            ASSERT (m_pMDIFrame != NULL);

            CMDIChildWnd* pwndActive = m_pMDIFrame->MDIGetActive();
            ASSERT (pwndActive != NULL);
            if (pwndActive == NULL)
                break;

            hPopupMenu = pwndActive->GetSystemMenu(FALSE)->GetSafeHmenu();
        }

        // display the button's popup menu
        TPMPARAMS   tpm;
        tpm.cbSize    = sizeof(TPMPARAMS);
        tpm.rcExclude = rectExclude;

        SetHotItem (-1);
        PressButton (btn.idCommand, TRUE);

        // Get the point where the  menu should be popped up.
        bool fLayoutRTL = (GetExStyle() & WS_EX_LAYOUTRTL);
        POINT pt;
        pt.y = rectExclude.bottom;
        pt.x = (fLayoutRTL) ? rectExclude.right : rectExclude.left;

		/*
		 * Bug 17342: TrackPopupMenuEx doesn't place the menu well if the
		 * x-coordinate of its origin is off-screen to the left, so prevent
		 * this from occurring.  TrackPopupMenuEx *does* work fine when the
		 * x-coordinate is off-screen to the right or if the y-coordinate is
		 * off-screen to the bottom, so we don't need to account for those
		 * cases.  (The system prevents placing the window such that the
		 * y-coordinate would be off-screen to the top.)
		 *
		 * Bug 173543: We can't assume that an x-coordinate less than 0 is
		 * off the screen.  For multimon systems with the primary monitor
		 * on the right, the left monitor will have negative x coordinates.
		 * Our left-most position will be the left edge of the monitor nearest
		 * where the menu will be displayed.
		 */
		int xMin = 0;
		HMONITOR hmonMenu = MonitorFromPoint (pt, MONITOR_DEFAULTTONEAREST);

		if (hmonMenu != NULL)
		{
			MONITORINFO mi = { sizeof(mi) };
			
			if (GetMonitorInfo (hmonMenu, &mi))
				xMin = (fLayoutRTL) ? mi.rcWork.right : mi.rcWork.left;
		}

		if ((!fLayoutRTL && (pt.x < xMin)) || (fLayoutRTL && (pt.x > xMin)))
			pt.x = xMin;

        // HACK: post a bogus down arrow so the first menu item will be selected
        if(bHighlightFirstItem)
        {
            CWnd*   pwndFocus = GetFocus();

            if (pwndFocus != NULL)
                pwndFocus->PostMessage (WM_KEYDOWN, VK_DOWN, 1);
        }

        // monitor what's the popup menu fate
        popupMonitor.StartMonitoring();

		// Child window wont exist if there is no views, so check this ptr before using it.
		CChildFrame* pChildFrame = dynamic_cast<CChildFrame*>(m_pMDIFrame->MDIGetActive());

        // hPopupMenu exists only if the sub-menus were added thro resource like File, Window
        // and Help menus. The Action, View, Favorites and any snapin added menu's sub-menus
        // are not added thro resources so for them hPopupmenu is null.
        if (! hPopupMenu)
        {
			sc = ScCheckPointers(pChildFrame, E_UNEXPECTED);
			if (sc)
            {
				sc.TraceAndClear();
                break;
            }

            CAMCView *pAMCView = pChildFrame->GetAMCView();
            sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
            if (sc)
            {
				sc.TraceAndClear();
                break;
            }

            switch(btn.idCommand)
            {
				case ID_MTB_MENU_ACTION:
                    pAMCView->OnActionMenu(pt, rectExclude);
					break;

				case ID_MTB_MENU_VIEW:
                    pAMCView->OnViewMenu(pt, rectExclude);
					break;

				case ID_MTB_MENU_FAVORITES:
                    pAMCView->OnFavoritesMenu(pt, rectExclude);
					break;

                // Assumption if none of the above then it is snapin added menu.
                // We try to forward this to snapin else we get an error.
				default:
                {
                    // If this is one of the MenuButtons inserted by
                    // the CMenuButtonsMgrImpl, notify CMenuButtonsMgrImpl
                    // to do TrackPopupMenu.

                    // Get the CMenuButtonsMgrImpl from the ChildFrame.
                    CMenuButtonsMgrImpl* pMenuBtnsMgr = pChildFrame->GetMenuButtonsMgr();
                    sc = ScCheckPointers(pMenuBtnsMgr, E_UNEXPECTED);
                    if (sc)
                        break;

                    // Notify CMenuButtonsMgr to popup a menu.
                    sc = pMenuBtnsMgr->ScNotifyMenuClick(btn.idCommand, pt);
                    if (sc)
                        break;
                }
                break;
            }

            if (sc)
            {
				sc.TraceAndClear();
                break;
            }

        }
        else
        {
            ASSERT (::IsMenu (hPopupMenu));

            HWND hwndMenuOwner = AfxGetMainWnd()->GetSafeHwnd();

            TrackPopupMenuEx (hPopupMenu,
                              TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL,
                              pt.x, pt.y, hwndMenuOwner, &tpm);
        }

        // Clear the status bar.
        // Execution of some commands may cause the child window to close
        // Check if it still exists  (RAID# 755824)
        if (pChildFrame && IsWindow(pChildFrame->m_hWnd))
        {   
            // Additional check to guard against HWND re-use
            if (m_pMDIFrame && m_pMDIFrame->IsChild(pChildFrame)) 
                sc = pChildFrame->ScSetStatusText(TEXT(""));
        }

        if (sc)
			sc.TraceAndClear();

        PressButton (btn.idCommand, FALSE);
        SetHotItem (-1);

        // the loop will continue if it was requested to display the new popup menu.
        // if it was requested to simply close the menu, execution will exit the loop
    }while ( popupMonitor.WasAnotherPopupRequested(nItemIndex) );

    m_bInProgressDisplayingPopup = false;
    //reset the UI by hiding the accelerators (since we are done)
    SendMessage( WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS));

    EndTracking();
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnAccelPopup
 *
 * Keyboard accelerator handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnAccelPopup (UINT cmd)
{
    PopupMenu (CommandToIndex (cmd), true /*bHighlightFirstItem*/);
}



/*--------------------------------------------------------------------------*
 * void CMenuBar::OnUpdateAllCmdUI
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::OnUpdateAllCmdUI (CCmdUI* pCmdUI)
{
    pCmdUI->Enable ();
}



/*--------------------------------------------------------------------------*
 * CMenuBar::AddString
 *
 * The toolbar control doesn't provide a way to delete strings once they've
 * been added, so we'll check our cache of strings that we've already added
 * to the toolbar so we don't add wasteful duplicate strings.
 *--------------------------------------------------------------------------*/

int CMenuBar::AddString (const CString& strAdd)
{
    DECLARE_SC(sc, TEXT("CMenuBar::AddString"));
    // -1 for empty strings
    if (strAdd.IsEmpty())
        return (-1);

    // check the cache
    ToolbarStringPool::iterator it = std::find (m_ToolbarStringPool.begin(),
                                                m_ToolbarStringPool.end(),
                                                strAdd);

    // if we found a hit in the cache, return the cached index
    if (it != m_ToolbarStringPool.end())
        return (it - m_ToolbarStringPool.begin());


    // new string, add it to the cache...
    m_ToolbarStringPool.push_back (strAdd);


    // ...and to the toolbar, including a double-NULL
    int     cchAdd = strAdd.GetLength() + 1;
    LPTSTR  pszAdd = (LPTSTR) _alloca ((cchAdd + 1) * sizeof (TCHAR));
    sc = StringCchCopy(pszAdd, cchAdd, strAdd);
    if (sc)
        return -1;

    // And the second NULL to terminate strings...
    pszAdd[cchAdd] = 0;
    int nIndex = AddStrings (pszAdd);

    // make sure the toolbar's string index matches the cache's string index
    ASSERT (nIndex == m_ToolbarStringPool.end()-m_ToolbarStringPool.begin()-1);

    return (nIndex);
}



/*--------------------------------------------------------------------------*
 * CMenuBar::GetMenuBandIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMenuBar::GetMenuBandIndex () const
{
    return (m_pRebar->IdToIndex (GetDlgCtrlID ()));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::GetDecorationBandIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMenuBar::GetDecorationBandIndex () const
{
    return (m_pRebar->IdToIndex (ID_MDIDECORATION));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::GetFirstButtonIndex
 *
 *
 *--------------------------------------------------------------------------*/

int CMenuBar::GetFirstButtonIndex ()
{
    // make sure the system menu isn't the first one activated
    return (GetNextButtonIndex (0));
}



/*--------------------------------------------------------------------------*
 * CMenuBar::OnIdle
 *
 * WM_IDLE handler for CMenuBar.
 *--------------------------------------------------------------------------*/

void CMenuBar::OnIdle ()
{
    /*----------------------------------------------------------*/
    /* If there's no MDI frame, that means this menu is serving */
    /* an SDI window.  We don't have to do any special stuff to */
    /* simulate the MDI menu UI, so bail now.                   */
    /*----------------------------------------------------------*/
    if (m_pMDIFrame == NULL)
        return;

    ProgramMode eMode = AMCGetApp()->GetMode();

    // if we're in SDI User mode, bail now as well
    if (eMode == eMode_User_SDI)
    {
#ifdef DBG
        // the decorations should be hidden
        REBARBANDINFO   rbi;
        PrepBandInfo (&rbi, RBBIM_STYLE);
        m_pRebar->GetBandInfo (GetDecorationBandIndex(), &rbi);
        ASSERT (rbi.fStyle & RBBS_HIDDEN);
#endif

        return;
    }

    /*---------------------------------------------------------------*/
    /* We should be able to use MDIGetActive(&fMaximized) to tell    */
    /* whether the active window is maximized, instead of calling    */
    /* pwndActive->IsZoomed().  However, fMaximized doesn't always   */
    /* get initialized correctly in certain low memory/slow machine  */
    /* situations.  This was the cause of Bug 133179, logged by SQL. */
    /*---------------------------------------------------------------*/
    CMDIChildWnd*   pwndActive = m_pMDIFrame->MDIGetActive ();
    bool            fShow      = (pwndActive != NULL) && pwndActive->IsZoomed();

    REBARBANDINFO   rbi;
    PrepBandInfo (&rbi, RBBIM_STYLE);
    m_pRebar->GetBandInfo (GetMenuBandIndex(), &rbi);

    // if the menu bar is hidden, the decorations must be hidden as well
    if (rbi.fStyle & RBBS_HIDDEN)
        fShow = false;

    if (fShow != m_fDecorationsShowing)
    {
        // show/hide the MDI decorations
        m_pRebar->ShowBand (GetDecorationBandIndex(), fShow);

        GetMaxedChildIcon (pwndActive);
        HideButton (ID_MTB_MENU_SYSMENU, !fShow);
        UpdateToolbarSize ();

        // remember the new setting
        m_fDecorationsShowing = fShow;
    }

    // otherwise, see if a window was maximized before but a different one is maxed now
    else if (fShow && (m_pwndLastActive != pwndActive))
    {
        // get the new active window's icon
        GetMaxedChildIcon (pwndActive);

        // repaint the menu and MDI decorations
        InvalidateRect (NULL);
        m_pMDIDec->InvalidateRect (NULL);
    }

    // remember the currently active window
    m_pwndLastActive = pwndActive;

    // insure that it's safe to keep this pointer around
    ASSERT ((m_pwndLastActive == NULL) ||
            (CWnd::FromHandlePermanent (m_pwndLastActive->m_hWnd) != NULL));
}


/*--------------------------------------------------------------------------*
 * CMenuBar::DeleteMaxedChildIcon
 *
 *
 *--------------------------------------------------------------------------*/
void
CMenuBar::DeleteMaxedChildIcon()
{
    // destroy the previous icon, if we need to
    if (m_fDestroyChildIcon)
    {
        ASSERT (m_hMaxedChildIcon != NULL);
        DestroyIcon (m_hMaxedChildIcon);
        m_hMaxedChildIcon   = NULL;
        m_fDestroyChildIcon = false;
    }
}


/*--------------------------------------------------------------------------*
 * CMenuBar::GetMaxedChildIcon
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::GetMaxedChildIcon (CWnd* pwnd)
{
    DeleteMaxedChildIcon();

    // get the small icon for the given window
    if (IsWindow (pwnd->GetSafeHwnd()))
    {
        HICON hOriginalIcon = pwnd->GetIcon (false /*bBigIcon*/);

        m_hMaxedChildIcon = (HICON) CopyImage (
                                        hOriginalIcon, IMAGE_ICON,
                                        GetSystemMetrics (SM_CXSMICON),
                                        GetSystemMetrics (SM_CYSMICON),
                                        LR_COPYFROMRESOURCE | LR_COPYRETURNORG);

        // if the system had to create a new icon, we'll have to destroy it later
        if ((m_hMaxedChildIcon != NULL) && (m_hMaxedChildIcon != hOriginalIcon))
            m_fDestroyChildIcon = true;
    }

    m_fMaxedChildIconIsInvalid = false;
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::GetAccelerators
 *
 *
 *--------------------------------------------------------------------------*/

void CMenuBar::GetAccelerators (int cchBuffer, LPTSTR lpBuffer) const
{
    lstrcpyn (lpBuffer, m_strAccelerators, cchBuffer);
}

//+-------------------------------------------------------------------
//
//  Member:      CMenuBar::IsStandardMenuAllowed
//
//  Synopsis:    Is this standard MMC menu allowed or not.
//
//  Arguments:   uMenuID - The menu ID.
//
//  Returns:     bool
//
//--------------------------------------------------------------------
bool CMenuBar::IsStandardMenuAllowed(UINT uMenuID)
{
    DECLARE_SC(sc, _T("CMenuBar::IsStandardMenuAllowed"));

    /*
     * We add a hidden menu as a marker. Later when snapin
     * calls to insert a menu button we find the position
     * of this menu and add snapin menu before it.
     * So this acts as Std menu which is always allowed.
     */
    if (uMenuID == ID_SNAPIN_MENU_PLACEHOLDER)
        return true;

    // First make sure it is one of the std menus.
    if ( (uMenuID != ID_FAVORITES_MENU) &&
         (uMenuID != ID_ACTION_MENU) &&
         (uMenuID != ID_VIEW_MENU))
         {
             sc = E_INVALIDARG;
             return true;
         }

    // Ask view data if std menus are allowed.

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return false;

    CAMCView *pAMCView = pMainFrame->GetActiveAMCView();
    sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
    if (sc)
        return false;

    SViewData* pViewData = pAMCView->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return false;

    if (! pViewData->IsStandardMenusAllowed())
        return false;

    if (uMenuID != ID_FAVORITES_MENU)
        return true;

    /*
     * Display the Favorites menu button if we are in author mode, or if
     * we're in user mode and we have at least one favorite.  If we're in
     * user mode and no favorites are defined, hide the Favorites button.
     */
    bool fShowFavorites = true;
    CAMCApp* pApp = AMCGetApp();

    if (pApp != NULL)
    {
        /*
         * show favorites in author mode
         */
        fShowFavorites = (pApp->GetMode() == eMode_Author);

        /*
         * not author mode? see if we have any favorites
         */
        if (!fShowFavorites)
        {
            CAMCDoc* pDoc = CAMCDoc::GetDocument ();

            if (pDoc != NULL)
            {
                CFavorites* pFavorites = pDoc->GetFavorites();

                if (pFavorites != NULL)
                    fShowFavorites = !pFavorites->IsEmpty();
            }
        }
    }

    return fShowFavorites;
}


//+-------------------------------------------------------------------
//
//  Member:      CMenuBar::ScShowMMCMenus
//
//  Synopsis:    Show or Hide the MMC menus (Action, View & Favorites).
//               Called from customize view.
//
//  Arguments:
//
//  Returns:     SC
//
//  Note:        As this is called from Customize view no need to look
//               at viewdata::IsStandardMenusAllowed.
//               Also Favorites button is not added in first place
//               if it is not allowed. So no need for Favorites menu
//               special case.
//
//--------------------------------------------------------------------
SC CMenuBar::ScShowMMCMenus (bool bShow)
{
    DECLARE_SC(sc, _T("CMenuBar::ScShowMMCMenus"));

    // Go through the menu buttons & find Action, View & Favorites.

    TBBUTTON    btn;
    int cButtons = GetButtonCount();

    for (int i = 0; i < cButtons; ++i)
    {
        GetButton (i, &btn);

        // Skip if button is not action/view/favs.
        if ( (btn.idCommand != ID_MTB_MENU_FAVORITES) &&
             (btn.idCommand != ID_MTB_MENU_ACTION) &&
             (btn.idCommand != ID_MTB_MENU_VIEW) )
             {
                 continue;
             }

        // For favorites menu see if it is appropriate to un-hide it.
        // In non-author mode if there is no favorites then this menu
        // is hidden.
        if ( bShow &&
             (btn.idCommand == ID_MTB_MENU_FAVORITES) &&
             (! IsStandardMenuAllowed(ID_FAVORITES_MENU)) )
            continue;

        HideButton(btn.idCommand, !bShow);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::ScInsertAccPropIDs
 *
 * Inserts the IDs of the accessibility properties supported by CMenuBar
 * (see ScGetPropValue).
 *--------------------------------------------------------------------------*/

SC CMenuBar::ScInsertAccPropIDs (PropIDCollection& v)
{
	DECLARE_SC (sc, _T("CMenuBar::ScInsertAccPropIDs"));

	/*
	 * let the base class do its thing
	 */
	sc = CMMCToolBarCtrlEx::ScInsertAccPropIDs (v);
	if (sc)
		return (sc);

	/*
	 * add our own properties
	 */
	v.push_back (PROPID_ACC_ROLE);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::ScGetPropValue
 *
 * Returns accessibility properties supported by CMenuBar.
 *
 * If a property is returned, fGotProp is set to true.  If it is not
 * returned, the value of fGotProp is unchanged, since the property might
 * have been provided by a base/derived class.
 *--------------------------------------------------------------------------*/

SC CMenuBar::ScGetPropValue (
	HWND				hwnd,		// I:accessible window
	DWORD				idObject,	// I:accessible object
	DWORD				idChild,	// I:accessible child object
	const MSAAPROPID&	idProp,		// I:property requested
	VARIANT&			varValue,	// O:returned property value
	BOOL&				fGotProp)	// O:was a property returned?
{
	DECLARE_SC (sc, _T("CMenuBar::ScGetPropValue"));

	/*
	 * call the base class
	 */
	sc = CMMCToolBarCtrlEx::ScGetPropValue (hwnd, idObject, idChild, idProp, varValue, fGotProp);
	if (sc)
		return (sc);

	/*
	 * now handle requests for properties we support...role first
	 */
	if (idProp == PROPID_ACC_ROLE)
	{
		/*
		 * don't override the property for child elements,
		 * don't return a property
		 */
		if (idChild != CHILDID_SELF)
		{
			Trace (tagToolbarAccessibility, _T("GetPropValue: no role for child %d"), idChild);
			return (sc);
		}

		/*
		 * the control itself has a role of menubar
		 */
		V_VT(&varValue) = VT_I4;
		V_I4(&varValue) = ROLE_SYSTEM_MENUBAR;
		fGotProp        = true;
		Trace (tagToolbarAccessibility, _T("GetPropValue: Returning 0x%08x"), V_I4(&varValue));
	}
    else if (idProp == PROPID_ACC_STATE)
    {
        /*
         * Bug 148132: if the base class returned a property, append
         * STATE_SYSTEM_HASPOPUP so Narrator et al will announce "has a
         * submenu" when the menu item is highlighted
         */
        if (fGotProp)
        {
            ASSERT (V_VT(&varValue) == VT_I4);
            V_I4(&varValue) |= STATE_SYSTEM_HASPOPUP;
            Trace (tagToolbarAccessibility, _T("GetPropValue: Appending STATE_SYSTEM_HASPOPUP, Returning 0x%08x"), V_I4(&varValue));
        }
        else
        {
            V_VT(&varValue) = VT_I4;
            V_I4(&varValue) = STATE_SYSTEM_FOCUSABLE | STATE_SYSTEM_HASPOPUP;
            fGotProp        = true;

            if (IsTrackingToolBar() && (GetHotItem() == (idChild-1) /*0-based*/))
                V_I4(&varValue) |= STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED;

            Trace (tagToolbarAccessibility, _T("GetPropValue: Returning 0x%08x"), V_I4(&varValue));
        }
    }

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::BeginTracking2
 *
 * Fires EVENT_SYSTEM_MENUSTART event accessibility event, then call base
 * class.
 *--------------------------------------------------------------------------*/

void CMenuBar::BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
	NotifyWinEvent (EVENT_SYSTEM_MENUSTART, m_hWnd, OBJID_CLIENT, CHILDID_SELF);
	CMMCToolBarCtrlEx::BeginTracking2 (pAuxWnd);
}


/*+-------------------------------------------------------------------------*
 * CMenuBar::EndTracking2
 *
 * Fires EVENT_SYSTEM_MENUEND event accessibility event, then call base
 * class.
 *--------------------------------------------------------------------------*/

void CMenuBar::EndTracking2 (CToolbarTrackerAuxWnd* pAuxWnd)
{
	NotifyWinEvent (EVENT_SYSTEM_MENUEND, m_hWnd, OBJID_CLIENT, CHILDID_SELF);
	CMMCToolBarCtrlEx::EndTracking2 (pAuxWnd);
}


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPopupTrackContext



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::CPopupTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CPopupTrackContext::CPopupTrackContext (
    CMenuBar*   pMenuBar,
    int         nCurrentPopupIndex)
    :
    m_pMenuBar          (pMenuBar),
    m_cButtons          (pMenuBar->GetButtonCount()),
    m_ptLastMouseMove   (GetMessagePos()),
    m_ptLButtonDown     (GetMessagePos()),
    m_dwLButtonDownTime (GetMessageTime()),
    m_bPopupMonitorHooksActive(false),
    m_iRequestForNewPopup(-1)
{
    ASSERT_VALID (pMenuBar);
    ASSERT (s_pTrackContext == NULL);

    m_nCurrentPopupIndex    = nCurrentPopupIndex;
    m_fCurrentlyOnPopupItem = false;
    m_cCascadedPopups       = 0;

    ASSERT (m_nCurrentPopupIndex <  m_cButtons);
    ASSERT (m_nCurrentPopupIndex >= 0);

    // build the vector of button boundaries
    m_ButtonBoundaries.resize (m_cButtons + 1, 0);
    ASSERT (m_ButtonBoundaries.size() == m_cButtons + 1);
    ASSERT (m_ButtonBoundaries.size() >= 2);

    CRect   rectButton (0, 0, 0, 0);
    POINT   ptTopLeft = rectButton.TopLeft();

    for (int i = 0; i < m_cButtons; i++)
    {
        // GetItemRect will fail (acceptably) for hidden buttons,
        // but should otherwise succeed.
        VERIFY (pMenuBar->GetItemRect(i, rectButton) ||
                pMenuBar->IsButtonHidden(pMenuBar->IndexToCommand(i)) );

        // Do not map rectButton from Client To Screen.
        // Map a copy of it (in ptTopLeft). So if a hidden
        // button follows, it can use the rectButton.TopLeft()
        // value and map it.
        ptTopLeft = rectButton.TopLeft();
        pMenuBar->ClientToScreen (&ptTopLeft);
        m_ButtonBoundaries[i] = ptTopLeft.x;

		// make m_rectAllButtons as a union of all buttons
		if (i == 0)
			m_rectAllButtons = rectButton;
		else
			m_rectAllButtons |= rectButton;
    }

    ptTopLeft = rectButton.BottomRight();
    pMenuBar->ClientToScreen (&ptTopLeft);
    m_ButtonBoundaries[m_cButtons] = ptTopLeft.x;

	pMenuBar->ClientToScreen (&m_rectAllButtons);
	// decrease m_rectAllButtons slightly
	m_rectAllButtons.left =	m_rectAllButtons.left + 1;
	m_rectAllButtons.right = m_rectAllButtons.right - 1;

#ifdef DBG
    {
        // the button boundaries should naturally fall in ascending(for LTR) order
        for (int j = 0; j < m_ButtonBoundaries.size()-1; j++)
        {
		    if (0 == (m_pMenuBar->GetExStyle() & WS_EX_LAYOUTRTL))
				ASSERT (m_ButtonBoundaries[j] <= m_ButtonBoundaries[j+1]);
			else
				ASSERT (m_ButtonBoundaries[j] >= m_ButtonBoundaries[j+1]);
        }
    }
#endif

    /*--------------------------------------------------------------------*/
    /* see if we might need to simulate a double-click on the system menu */
    /*--------------------------------------------------------------------*/
    m_pMaxedMDIChild = NULL;

    // only deal with the system menu if the MDI decorations are showing
    if (m_pMenuBar->m_fDecorationsShowing)
    {
        ASSERT (m_pMenuBar->m_pMDIFrame != NULL);
        CWnd* pMDIChild = m_pMenuBar->m_pMDIFrame->MDIGetActive();

        // nothing to do if child is already gone
        if ( pMDIChild == NULL )
            return;

        ASSERT (pMDIChild->IsZoomed());

        // if the mouse is over the system menu, remember the maximized child
        // (non-NULL m_pMaxedMDIChild is the key later on in MaybeCloseMDIChild)
        if (HitTest (m_ptLButtonDown) == 0)
            m_pMaxedMDIChild = pMDIChild;
    }

}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::~CPopupTrackContext
 *
 *
 *--------------------------------------------------------------------------*/

CPopupTrackContext::~CPopupTrackContext ()
{
    // release the mouse and keyboard hooks
    RemovePopupMonitorHooks();
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::RemovePopupMonitorHooks
 *
 * Unhooks from the system and stops watching the events
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::RemovePopupMonitorHooks ()
{
    // ignore if not monitoring yet
    if (m_bPopupMonitorHooksActive)
    {
        // we MUST be the active monitor if we came here
        if (s_pTrackContext != this)
        {
            ASSERT(FALSE && "Popup monitor uninstalled from outside");
            return;
        }
        // release the mouse and keyboard hooks
        UnhookWindowsHookEx (m_hhkMouse);
        UnhookWindowsHookEx (m_hhkKeyboard);
        UnhookWindowsHookEx (m_hhkCallWnd);

        m_bPopupMonitorHooksActive = false;
        // uninstall itself as hook monitor
        s_pTrackContext = NULL;
    }
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::SetPopupMonitorHooks
 *
 * Hooks into the system and begins watching the events
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::SetPopupMonitorHooks ()
{
    // ignore if already set
    if (!m_bPopupMonitorHooksActive)
    {
        // there is only one active menu per app. There is no place for anybody else
        if (s_pTrackContext)
        {
            ASSERT(FALSE && "Popup menu overrun");
            return;
        }
        // install itself as hook monitor
        s_pTrackContext = this;

        DWORD   idCurrentThread = ::GetCurrentThreadId();

        // hook the mouse for hot tracking
        m_hhkMouse = SetWindowsHookEx (WH_MOUSE, MouseProc, NULL, idCurrentThread);

        // hook the keyboard for navigation
        m_hhkKeyboard = SetWindowsHookEx (WH_KEYBOARD, KeyboardProc, NULL, idCurrentThread);

        // hook send messages for Menu_Is_Closed detection
        m_hhkCallWnd = SetWindowsHookEx (WH_CALLWNDPROC, CallWndProc, NULL, idCurrentThread);

        m_bPopupMonitorHooksActive = true;
    }
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::StartMonitoring
 *
 * Public method to start popup monitoring
 * Hooks into the system and begins watching the events
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::StartMonitoring()
{
    // reset the request to activate another popup upon finish
    m_iRequestForNewPopup = -1;
    // setup hooks and watch...
    SetPopupMonitorHooks();
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::WasAnotherPopupRequested
 *
 * Used to retrieve the cause the menu was dismissed.
 * If new popupu is requested, button index is returned
 *--------------------------------------------------------------------------*/

bool CPopupTrackContext::WasAnotherPopupRequested(int& iNewIdx)
{
    if (m_iRequestForNewPopup >= 0)
    {
        iNewIdx = m_iRequestForNewPopup;
        return true;
    }
    return false;
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MouseProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CPopupTrackContext::MouseProc (int nCode, WPARAM wParam, LPARAM lParam)
{
    CPopupTrackContext* this_ = s_pTrackContext;
    ASSERT (this_ != NULL);

    if (nCode < 0)
        return (CallNextHookEx (this_->m_hhkMouse, nCode, wParam, lParam));

    return (this_->MouseProc (nCode, wParam, (LPMOUSEHOOKSTRUCT) lParam));
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MouseProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CPopupTrackContext::MouseProc (int nCode, UINT msg, LPMOUSEHOOKSTRUCT pmhs)
{
    // if this is a mouse message within the menu bar...
    if (m_rectAllButtons.PtInRect (pmhs->pt))
    {
        // eat the button down so we don't get into a TBN_DROPDOWN loop
        if (msg == WM_LBUTTONDOWN)
        {
            DismissCurrentPopup (true);
            MaybeCloseMDIChild (pmhs->pt);
            return (1);
        }

        // for (non-duplicate) mouse moves, follow the mouse with the active menu
        if ((msg   == WM_MOUSEMOVE) &&
            (nCode == HC_ACTION) &&
            (m_ptLastMouseMove != pmhs->pt))
        {
            // determine which button is being tracked over
            m_ptLastMouseMove = pmhs->pt;
            int nNewPopupIndex = HitTest (m_ptLastMouseMove);
            ASSERT (nNewPopupIndex != -1);

            // if we're not over the same button we were last
            // time, display the popup for the new button
            if (nNewPopupIndex != m_nCurrentPopupIndex)
                NotifyNewPopup (m_nCurrentPopupIndex = nNewPopupIndex);
        }
    }

    return (CallNextHookEx (m_hhkMouse, nCode, msg, (LPARAM) pmhs));
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::KeyboardProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CPopupTrackContext::KeyboardProc (int nCode, WPARAM wParam, LPARAM lParam)
{
    CPopupTrackContext* this_ = s_pTrackContext;
    ASSERT (this_ != NULL);

    if (nCode < 0)
        return (CallNextHookEx (this_->m_hhkKeyboard, nCode, wParam, lParam));

    int     cRepeat = LOWORD (lParam);
    bool    fDown   = (lParam & (1 << 31)) == 0;

    return (this_->KeyboardProc (nCode, wParam, cRepeat, fDown, lParam));
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::KeyboardProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CPopupTrackContext::KeyboardProc (
    int     nCode,
    int     vkey,
    int     cRepeat,
    bool    fDown,
    LPARAM  lParam)
{
    // if this isn't a real message, ignore it
    if (nCode != HC_ACTION)
        return (CallNextHookEx (m_hhkKeyboard, nCode, vkey, lParam));

    // if this is a left or right message...
    if ((vkey == VK_LEFT) || (vkey == VK_RIGHT))
    {
        // eat the key release, but don't do anything with it
        if (!fDown)
            return (1);

        /*
         * let the menu code handle cascaded popups
         */
		// need to do everything in opposite direction on RTL layout
		// see bug #402620	ntbug9	05/23/2001
		const bool fNext = ( (m_pMenuBar->GetExStyle() & WS_EX_LAYOUTRTL) ? (vkey != VK_RIGHT) : (vkey == VK_RIGHT) ) ;

        if (m_fCurrentlyOnPopupItem && fNext)
            m_cCascadedPopups++;

        else if ((m_cCascadedPopups > 0) && !fNext)
            m_cCascadedPopups--;

        /*
         * not right on a popup item, or left on a popped-up menu
         */
        else
        {
            m_cCascadedPopups = 0;

            // figure out the next button
            int nNewPopupIndex = fNext
                    ? m_pMenuBar->GetNextButtonIndex (m_nCurrentPopupIndex, cRepeat)
                    : m_pMenuBar->GetPrevButtonIndex (m_nCurrentPopupIndex, cRepeat);

            // activate the new button's popup, if it's different from the current one
            if (nNewPopupIndex != m_nCurrentPopupIndex)
                NotifyNewPopup (m_nCurrentPopupIndex = nNewPopupIndex);

            // eat the key press
            return (1);
        }
    }

    return (CallNextHookEx (m_hhkKeyboard, nCode, vkey, lParam));
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::CallWndProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CPopupTrackContext::CallWndProc(
  int nCode,      // hook code
  WPARAM wParam,  // current-process flag
  LPARAM lParam   // address of structure with message data
)
{
    // get the active monitor
    CPopupTrackContext* this_ = s_pTrackContext;
    ASSERT (this_ != NULL);

    // ignore special cases
    if (nCode < 0)
        return (CallNextHookEx (this_->m_hhkCallWnd, nCode, wParam, lParam));

    BOOL bCurrentThread = wParam;
    LPCWPSTRUCT lpCWP = reinterpret_cast<LPCWPSTRUCT>(lParam);

    // forward the request to monitor
    return (this_->CallWndProc (nCode, bCurrentThread, lpCWP));
}


/*--------------------------------------------------------------------------*
 * CPopupTrackContext::CallWndProc
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CPopupTrackContext::CallWndProc  (int nCode, BOOL bCurrentThread, LPCWPSTRUCT lpCWP)
{
    ASSERT(lpCWP != NULL);
    if (lpCWP)
    {
        // watch for message
        if (lpCWP->message == WM_MENUSELECT)
        {
            // decode params
            const UINT fuFlags = (UINT)  HIWORD(lpCWP->wParam);  // menu flags
            const HMENU hmenu =  (HMENU) lpCWP->lParam;          // handle to menu clicked

            if (fuFlags == 0xFFFF && hmenu == NULL)
            {
                // menu is closed! no more hooking needed
                RemovePopupMonitorHooks ();
            }
            else
            {
                // we stepped on the popup (will use the info when arrows are pressed)
                m_fCurrentlyOnPopupItem = (fuFlags & MF_POPUP);
            }
        }
    }
    // done
    return (CallNextHookEx (m_hhkCallWnd, nCode, bCurrentThread, (LPARAM)lpCWP));
}
/*--------------------------------------------------------------------------*
 * CPopupTrackContext::DismissCurrentPopup
 *
 *
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::DismissCurrentPopup (bool fTrackingComplete)
{
    // If the snapin does TrackPopupMenu with a window other than
    // MainFrame as parent then that window should be asked to
    // close the menu by sending WM_CANCELMODE. The window
    // is found by calling GetCapture().
    CWnd* pwndMode = CWnd::GetCapture();

    if (pwndMode == NULL)
        pwndMode = AfxGetMainWnd();

    pwndMode->SendMessage (WM_CANCELMODE);
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::NotifyNewPopup
 *
 * Notify the menu toolbar that it needs to display a new popup menu.
 * Note that this must be accomplished asynchronously so that we can
 * allow CMenuBar::PopupMenu to unwind after the WM_CANCELMODE from
 * DismissCurrentPopup.
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::NotifyNewPopup (int nNewPopupIndex)
{
    // dismiss the existing popup
    DismissCurrentPopup (false);
    // ask to activate the new popup after this one is closed
    m_iRequestForNewPopup = nNewPopupIndex;
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::HitTest
 *
 * Returns the index of the button under the given point, -1 if none.
 *--------------------------------------------------------------------------*/

int CPopupTrackContext::HitTest (CPoint pt) const
{
    /*----------------------------------------------------------------*/
    /* Find the range of "hit" buttons.  The range will span more     */
    /* than one button only if there are hidden buttons in the range, */
    /* and in that case, there will be exactly one non-hidden button  */
    /* in the range.                                                  */
    /*----------------------------------------------------------------*/
    std::pair<BoundConstIt, BoundConstIt> range;

	if ( m_pMenuBar->GetExStyle() & WS_EX_LAYOUTRTL )
	{
		range = std::equal_range (m_ButtonBoundaries.begin(),
								  m_ButtonBoundaries.end(), pt.x,
								  std::greater<BoundaryCollection::value_type>() );
	}
	else
	{
		range = std::equal_range (m_ButtonBoundaries.begin(),
                                  m_ButtonBoundaries.end(), pt.x);
	}

    int nLowerHitIndex = MapBoundaryIteratorToButtonIndex (range.first);
    int nUpperHitIndex = MapBoundaryIteratorToButtonIndex (range.second);

    /*
     * equal_range returns values that are less_than and greater_than
     * given value. The m_ButtonBoundaries has duplicate values (due
     * to hidden buttons). So if the less_than value is one of duplicate
     * values (not unique) then equal_range returns the iterator to
     * last dup item, not first dup item.
     *
     * Below we try to find the first dup item.
     */

    // Find the first item with value m_ButtonBoundaries[nLowerHitIndex].
    for (int iIndex = 0; iIndex < nLowerHitIndex; ++iIndex)
    {
        if (m_ButtonBoundaries[iIndex] == m_ButtonBoundaries[nLowerHitIndex])
        {
            // Found first item.
            nLowerHitIndex = iIndex;
            break;
        }
    }

    ASSERT (nLowerHitIndex <= nUpperHitIndex);

    int nHitIndex;

    // lower equal upper?  no hidden buttons
    if (nLowerHitIndex == nUpperHitIndex)
        nHitIndex = nLowerHitIndex;

    // otherwise we have some hidden buttons, or we are precisely on a button border
    else
    {
        nHitIndex = -1;

        if (nUpperHitIndex == -1)
            nUpperHitIndex = m_cButtons;

        for (int i = nLowerHitIndex;
             i <= nUpperHitIndex; // We should check till we hit nUpperHitIndex? AnandhaG
             ++i)
        {
            // See if this button is not hidden.
            if (!m_pMenuBar->IsButtonHidden (m_pMenuBar->IndexToCommand(i)))
            {
                nHitIndex = i;
                break;
            }
        }

        // we should have found a visible button
        ASSERT (nHitIndex != -1);
    }

    ASSERT (nHitIndex >= -1);
    ASSERT (nHitIndex <  m_cButtons);
    return (nHitIndex);
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MapBoundaryIteratorToButtonIndex
 *
 * Returns the button index corresponding to the input m_ButtonBoundaries
 * index, -1 for not found.
 *--------------------------------------------------------------------------*/

int CPopupTrackContext::MapBoundaryIteratorToButtonIndex (BoundConstIt it) const
{
    return ((it != m_ButtonBoundaries.end())
                ? it - m_ButtonBoundaries.begin() - 1
                : -1);
}



/*--------------------------------------------------------------------------*
 * CPopupTrackContext::MaybeCloseMDIChild
 *
 *
 *--------------------------------------------------------------------------*/

void CPopupTrackContext::MaybeCloseMDIChild (CPoint pt)
{
    // if we didn't find a maxed MDI child when this all started, punt
    if (m_pMaxedMDIChild == NULL)
        return;

    // if the click didn't happen on the system menu toolbar button, punt
    if (HitTest (pt) != 0)
        return;

    /*-------------------------------------------------------------------*/
    /* if the double-click time has elapsed, punt                        */
    /*                                                                   */
    /* Note: this is called from a mouse hook, which means the value     */
    /* returned by GetMessageTime hasn't been updated for this message,  */
    /* so it really reflects the time of the *previous* message (most    */
    /* likely WM_LBUTTONUP).                                             */
    /*                                                                   */
    /* GetTickCount returns a close enough approximation to              */
    /* GetMessageTime, except when we're debugging through this routine, */
    /* in which case the tick count will continue to spin (and this test */
    /* will always fail) but the message time would have remained fixed. */
    /*-------------------------------------------------------------------*/
//  if ((GetMessageTime() - m_dwLButtonDownTime) > GetDoubleClickTime())
    if ((GetTickCount()   - m_dwLButtonDownTime) > GetDoubleClickTime())
        return;

    // if the second click occurred outside the double-click space, punt
    if ((abs (m_ptLButtonDown.x - pt.x) > GetSystemMetrics (SM_CXDOUBLECLK)) ||
        (abs (m_ptLButtonDown.y - pt.y) > GetSystemMetrics (SM_CYDOUBLECLK)))
        return;

    // if the window doesn't have a system menu, or its Close item is disabled, punt
    CMenu* pSysMenu = m_pMaxedMDIChild->GetSystemMenu (FALSE);

    if (pSysMenu == NULL)
        return;

    UINT nCloseState = pSysMenu->GetMenuState (SC_CLOSE, MF_BYCOMMAND);

    if ((nCloseState == 0xFFFFFFFF) ||
        (nCloseState & (MF_GRAYED | MF_DISABLED)))
        return;

    // here: we've identified a double-click on a maximized child's
    //       system menu; close it
    m_pMaxedMDIChild->PostMessage (WM_SYSCOMMAND, SC_CLOSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\menubtns.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      menubtns.cpp
//
//  Contents:  Menu Buttons implementation
//
//  History:   08-27-99 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"
#include "ChildFrm.h"
#include "menubtns.h"
#include "AMCView.h"
#include "mainfrm.h"
#include "menubar.h"
#include "util.h"         // GetTBBtnTextAndStatus()


CMenuButtonsMgrImpl::CMenuButtonsMgrImpl()
 : m_pChildFrame(NULL), m_pMainFrame(NULL),
   m_pMenuBar(NULL)
{
    m_MenuButtons.clear();
    m_AttachedMenuButtons.clear();
}

CMenuButtonsMgrImpl::~CMenuButtonsMgrImpl()
{
    m_MenuButtons.clear();
    m_AttachedMenuButtons.clear();
}

//+-------------------------------------------------------------------
//
//  Member:      ScInit
//
//  Synopsis:    Init the Menubuttons mgr.
//
//  Arguments:   [pMainFrame]     - Ptr to Main Frame window.
//               [pChildFrameWnd] - Ptr to child frame window.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScInit (CMainFrame* pMainFrame, CChildFrame* pChildFrameWnd)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScInit"));

    if ( (NULL == pChildFrameWnd) ||
         (NULL == pMainFrame))
        return (sc = E_INVALIDARG);

    m_pChildFrame = pChildFrameWnd;
    m_pMainFrame  = pMainFrame;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScAddMenuButton
//
//  Synopsis:   Adds a menu button to the data structure
//              and calls ScAddMenuButtonToMenu.
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for button click.
//              [idCommand]          - Button command id.
//              [lpButtonText]       - Button text.
//              [lpStatusText]       - Button status text.
//
//  Returns:    SC
//
//  Note : The status text is not used.
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScAddMenuButton(
                             CMenuButtonNotify* pMenuBtnNotifyClbk,
                             INT idCommand,
                             LPCOLESTR lpButtonText,
                             LPCOLESTR lpStatusText)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScAddMenuButton"));

    // Validate the data
    if ( (NULL == pMenuBtnNotifyClbk) ||
         (NULL == lpButtonText) ||
         (NULL == lpStatusText) )
        return (sc = E_INVALIDARG);

    // Add the data to our data structure
    MMC_MenuButtonCollection::iterator it;
    it = GetMMCMenuButton( pMenuBtnNotifyClbk, idCommand);
    if (it != m_MenuButtons.end())
    {
        // Duplicate Menu button found.
        // The pMenuButtonNofifyClbk represents IMenuButton
        // given to the snapin and we found another button
        // with idCommand already added by this snapin.

        // For compatibility reasons (disk mgmt) this is not an error.
        return (sc = S_OK);
    }

    MMC_MENUBUTTON mmb;
    mmb.pMenuButtonNotifyClbk = pMenuBtnNotifyClbk;
    mmb.idCommand = idCommand;

    USES_CONVERSION;
    mmb.lpButtonText = OLE2CT(lpButtonText);
    mmb.lpStatusText = OLE2CT(lpStatusText);

    // Add the MMC_MENUBUTTON to the our array.
    m_MenuButtons.push_back(mmb);

    // Add the menubuttons to main menu
    sc = ScAddMenuButtonsToMainMenu();
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     ScModifyMenuButton
//
//  Synopsis:   Modify button text or status text for menu button
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for button click.
//              [idCommand]          - Button command id.
//              [lpButtonText]       - Button text.
//              [lpStatusText]       - Button status text.
//
//  Returns:    SC
//
//  Note : The status text is not used.
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScModifyMenuButton(
                             CMenuButtonNotify* pMenuBtnNotifyClbk,
                             INT idCommand,
                             LPCOLESTR lpButtonText,
                             LPCOLESTR lpStatusText)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScModifyMenuButton"));

    // Validate the data
    if ( (NULL == pMenuBtnNotifyClbk) ||
         (NULL == lpButtonText) ||
         (NULL == lpStatusText) )
        return (sc = E_INVALIDARG);

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) )
        return (sc = E_UNEXPECTED);

    // Iterate thro the vector and find the MMC_MENUBUTTON for
    // given CMenuButtonNotify* and Command id of button.
    MMC_MenuButtonCollection::iterator it;
    it = GetMMCMenuButton( pMenuBtnNotifyClbk, idCommand);
    if (it == m_MenuButtons.end())
    {
        // Menu button not found.
        // The pMenuButtonNofifyClbk represents IMenuButton
        // given to the snapin and we could not find a menu button
        // with idCommand already added by this snapin.
        return (sc = E_INVALIDARG);
    }

    it->pMenuButtonNotifyClbk = pMenuBtnNotifyClbk;
    it->idCommand = idCommand;

    USES_CONVERSION;
    it->lpButtonText = OLE2CT(lpButtonText);
    it->lpStatusText = OLE2CT(lpStatusText);

    if (NULL == m_pMenuBar)
        return (sc = E_UNEXPECTED);

    // Change the name of the menu item.
    if (-1 != it->nCommandIDFromMenuBar)
    {
        sc = (m_pMenuBar->SetMenuButton(it->nCommandIDFromMenuBar, it->lpButtonText.data()) == -1)
                        ? E_FAIL : S_OK;
        if (sc)
            return sc;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScModifyMenuButtonState
//
//  Synopsis:   Modify menu button state.
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for button click.
//              [idCommand]          - Button command id.
//              [nState]             - The state to be modified.
//              [bState]             - Set or Reset the state.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScModifyMenuButtonState(
                             CMenuButtonNotify* pMenuBtnNotifyClbk,
                             INT idCommand,
                             MMC_BUTTON_STATE nState,
                             BOOL bState)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScModifyMenuButtonState"));

    // Validate the data
    if (NULL == pMenuBtnNotifyClbk)
        return (sc = E_INVALIDARG);

    if (NULL == m_pChildFrame)
        return (sc = E_UNEXPECTED);

    // If childframe is not active, menus for this viewdoes not exist.
    if (false == m_pChildFrame->IsChildFrameActive())
    {
        switch (nState)
        {
        case ENABLED:
            // Enabling is illegal disabling is Ok (do nothing).
            sc = bState ? E_FAIL : S_OK;
            break;

        case HIDDEN:
            // Hiding is Ok(do nothing), Un-hiding is illegal.
            sc = bState ? S_OK : E_FAIL;
            break;

        case BUTTONPRESSED:
            sc = E_FAIL; // Always fail.
            break;

        default:
            ASSERT(FALSE);
            sc = E_FAIL;
            break;
        }

        return sc;
    }

    // Iterate thro the vector and find the MMC_MENUBUTTON for
    // given CMenuButtonNotify* and Command id of button.
    MMC_MenuButtonCollection::iterator it;
    it = GetMMCMenuButton( pMenuBtnNotifyClbk, idCommand);
    if (it == m_MenuButtons.end())
    {
        // Menu button not found.
        // The pMenuButtonNofifyClbk represents IMenuButton
        // given to the snapin and we could not find a menu button
        // with idCommand already added by this snapin.
        return (sc = E_INVALIDARG);
    }


    // Note the hidden state specified by the snapin.
    if (HIDDEN == nState)
    {
        bool bShow = (FALSE == bState);

        it->SetShowMenu(bShow);

        // If a menu button is to be un-hidden make sure that snapin buttons
        // are allowed in this view. Ask view-data for this information.
        if (bShow)
        {
            CAMCView* pAMCView = m_pChildFrame->GetAMCView();
            if (NULL == pAMCView)
                return (sc = E_UNEXPECTED);

            SViewData* pViewData = pAMCView->GetViewData();
            if (NULL == pViewData)
                return (sc = E_UNEXPECTED);

            // We have noted the hidden state of the button.
            // Return S_OK if menubuttons are disabled for this view.
            // Later when the menus are turned on the hidden state will
            // be properly restored.
            if (! pViewData->IsSnapinMenusAllowed())
                return (sc = S_OK);
        }
    }

    if (NULL == m_pMenuBar)
        return (sc = E_UNEXPECTED);

    BOOL bRet = FALSE;

    switch (nState)
    {
    case ENABLED:
        bRet = m_pMenuBar->EnableButton(it->nCommandIDFromMenuBar , bState);
        break;

    case HIDDEN:
        bRet = m_pMenuBar->HideButton(it->nCommandIDFromMenuBar , bState);
        break;

    case BUTTONPRESSED:
        bRet = m_pMenuBar->PressButton(it->nCommandIDFromMenuBar, bState);
        break;

    default:
        ASSERT(FALSE);
        bRet = FALSE;
        break;
    }

    sc = bRet ? S_OK : E_FAIL;
    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScAddMenuButtonsToMainMenu
//
//  Synopsis:   Add the menu buttons that are not yet added to
//              the main menu.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScAddMenuButtonsToMainMenu ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScAddMenuButtonsToMainMenu"));

    // To add a menu button the following conditions must be true.

    // 1. The child frame window must be active.
    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) )
        return (sc = E_UNEXPECTED);

    CAMCView* pAMCView = m_pChildFrame->GetAMCView();
    if (NULL == pAMCView)
        return (sc = E_UNEXPECTED);

    SViewData* pViewData = pAMCView->GetViewData();
    if (NULL == pViewData)
        return (sc = E_UNEXPECTED);

    if (NULL == m_pMainFrame)
        return (sc = E_UNEXPECTED);

    m_pMenuBar = m_pMainFrame->GetMenuBar();
    if (NULL == m_pMenuBar)
        return (sc = E_FAIL);

    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        // 2. The menu button is attached (IControlbar::Attach was called).
        if (IsAttached(it->pMenuButtonNotifyClbk) == false)
            continue;

        // 3. The button is not already added.
        if (FALSE == m_pMenuBar->IsButtonHidden(it->nCommandIDFromMenuBar))
            continue;

        BOOL bHidden = FALSE;

        if (false == pViewData->IsSnapinMenusAllowed())
            bHidden = TRUE;

        it->nCommandIDFromMenuBar =
            m_pMenuBar->InsertMenuButton((LPCTSTR)it->lpButtonText.data(),
                                                                                 bHidden || !(it->CanShowMenu()) );

        // In user mode there are no menus so this assert is not valid.
        // ASSERT(-1 != it->nCommandIDFromMenuBar);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifyMenuClick
//
//  Synopsis:   A menu button is clicked. Notify appropriate owner
//              to display a menu.
//
//  Arguments:
//              [nCommandID] - Command ID
//              [pt]        - display co-ordinates for popup menu.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScNotifyMenuClick(const INT nCommandID, const POINT& pt)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScNotifyMenuClick"));
    CAMCView* pAMCView = NULL;

    MMC_MenuButtonCollection::iterator it;

    // Get the MenuButton data.
    it = GetMMCMenuButton( nCommandID );
    if (it == m_MenuButtons.end())
        return (sc = E_FAIL);

    pAMCView = m_pChildFrame->GetAMCView();
    if (NULL == pAMCView)
        return (sc = E_FAIL);

    // This is snapin owned menu, so get the
    // selected HNODE, lParam (if result item)
    // MENUBUTTONDATA.
    HNODE hNode;
    bool  bScope;
    LPARAM lParam;
    MENUBUTTONDATA menuButtonData;

    // Get the details about the selected item.
    sc = pAMCView->ScGetFocusedItem (hNode, lParam, bScope);
    if (sc)
        return sc;

    menuButtonData.idCommand = it->idCommand;
    menuButtonData.x = pt.x;
    menuButtonData.y = pt.y;

    // Notify snapin about the click
    if (NULL == it->pMenuButtonNotifyClbk)
        return (sc = E_UNEXPECTED);

    sc = it->pMenuButtonNotifyClbk->ScNotifyMenuBtnClick(hNode, bScope, lParam, menuButtonData);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScAttachMenuButton
//
//  Synopsis:   Attach the menu buttons object (this object corresponds
//                 to the IMenuButton object exposed to the snapin).
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for menu button click.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScAttachMenuButton (CMenuButtonNotify* pMenuBtnNotifyClbk)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScAttachMenuButton"));

    MMC_AttachedMenuButtons::iterator it = m_AttachedMenuButtons.find(pMenuBtnNotifyClbk);
    if (m_AttachedMenuButtons.end() != it)
    {
        // Already attached, nothing wrong calling twice, return S_FALSE.
        return (sc = S_FALSE);
    }

    // Add the button to the set.
    std::pair<MMC_AttachedMenuButtons::iterator, bool> rc =
                       m_AttachedMenuButtons.insert(pMenuBtnNotifyClbk);
    if (false == rc.second)
        return (sc = E_FAIL);

    // The menu buttons may already be added  (without calling
    // IControlbar::Attach)
    // So give a chance for those buttons that are already added
    // but just now attached to get themself added to the main menu.
    sc = ScAddMenuButtonsToMainMenu ();
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetachMenuButton
//
//  Synopsis:   Detach the menu buttons object (this object corresponds
//                 to the IMenuButton object exposed to the snapin).
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback for menu button click.
//
//  Returns:    SC
//
//  Note : Detach removes the menu buttons and destroys the object.
//         So to re-create the menu button the snapin should again
//         do IMenuButton::AddButton and IControlbar::Attach.
//         This is how it is designed in mmc 1.0
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScDetachMenuButton (CMenuButtonNotify* pMenuBtnNotifyClbk)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScDetachMenuButton"));

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()))
        return (sc = S_OK); // When child-frame is deactivated the menus are removed.

    // Make sure the menu is currently attached.
    if (m_AttachedMenuButtons.end() ==
        m_AttachedMenuButtons.find(pMenuBtnNotifyClbk))
        // This Menu Button is not attached.
        return (sc = E_UNEXPECTED);

    if ( (NULL == m_pMainFrame) ||
         (NULL == m_pMenuBar) )
        return (sc = E_UNEXPECTED);

    MMC_MenuButtonCollection::iterator it = m_MenuButtons.begin();
    while ( it != m_MenuButtons.end())
    {
        if (it->pMenuButtonNotifyClbk == pMenuBtnNotifyClbk)
        {
            BOOL bRet = FALSE;

            // Remove the menu button from Main Menu.
            if (-1 != it->nCommandIDFromMenuBar)
                bRet = m_pMenuBar->DeleteMenuButton(it->nCommandIDFromMenuBar);

            // The CMenubar removes all the menus when childframe is de-activated.
            // So DeleteMenuButton will fail if the button does not exist.
            // Therefore we do not check below error.
            // if (FALSE == bRet)
            //    return (sc = E_FAIL);

            // Delete the object in our data structure
            it = m_MenuButtons.erase(it);
        }
        else
            ++it;
    }

    // Delete the IMenuButton ref from the set.
    m_AttachedMenuButtons.erase(pMenuBtnNotifyClbk);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScToggleMenuButton
//
//  Synopsis:   Hide or Show the given menu buttons.
//
//  Arguments:
//              [bShow] - Show or Hide the menu buttons.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScToggleMenuButton(BOOL bShow)
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScToggleMenuButton"));

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) ||
         (NULL == m_pMenuBar) )
        return (sc = E_UNEXPECTED);

    // Go thro all the menu buttons added.
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        BOOL bRetVal = TRUE; // Init to true so that failure (false) can be checked below.

        // Toggle the menu hidden status. If the menu is
        // un-hidden then check if it is allowed.
        bRetVal = m_pMenuBar->HideButton(it->nCommandIDFromMenuBar, bShow ? !(it->CanShowMenu()) : TRUE);

        if (FALSE == bRetVal)
            return (sc = E_FAIL);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScDisableMenuButtons
//
//  Synopsis:   Disable all the menubuttons.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButtonsMgrImpl::ScDisableMenuButtons()
{
    DECLARE_SC(sc, _T("CMenuButtonsMgrImpl::ScDisableMenuButtons"));

    if ( (NULL == m_pChildFrame) ||
         (false == m_pChildFrame->IsChildFrameActive()) ||
         (NULL == m_pMenuBar) )
        return (sc = E_UNEXPECTED);

    // Go thro all the menu buttons added.
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        if (m_pMenuBar->IsButtonEnabled(it->nCommandIDFromMenuBar))
        {
            BOOL bRet = m_pMenuBar->EnableButton(it->nCommandIDFromMenuBar, false);

            if (FALSE == bRet)
                return (sc = E_FAIL);
        }
    }


    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     GetMMCMenuButton
//
//  Synopsis:   Given the Notify callback and button command id get the button
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Callback for Menu click.
//              [idCommand]          - Button command id.
//
//  Returns:    iterator to MMC_MenuButtonCollection
//
//--------------------------------------------------------------------
MMC_MenuButtonCollection::iterator
CMenuButtonsMgrImpl::GetMMCMenuButton( CMenuButtonNotify* pMenuBtnNotifyClbk,
                                       INT idCommand)
{
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        if ( (it->pMenuButtonNotifyClbk == pMenuBtnNotifyClbk) &&
             (it->idCommand == idCommand) )
        {
            return it;
        }
    }

    return m_MenuButtons.end();
}

//+-------------------------------------------------------------------
//
//  Member:     GetMMCMenuButton
//
//  Synopsis:   Given the command id get the button
//
//  Arguments:
//              [nCommandID] - Command ID.
//
//  Returns:    iterator to MMC_MenuButtonCollection
//
//--------------------------------------------------------------------
MMC_MenuButtonCollection::iterator
CMenuButtonsMgrImpl::GetMMCMenuButton( INT nCommandID)
{
    MMC_MenuButtonCollection::iterator it;
    for (it = m_MenuButtons.begin(); it != m_MenuButtons.end(); ++it)
    {
        if ( it->nCommandIDFromMenuBar == nCommandID )
        {
            return it;
        }
    }

    return m_MenuButtons.end();
}


//+-------------------------------------------------------------------
//
//  Member:     IsAttached
//
//  Synopsis:   Given the notify callback, check if the MenuButtons
//              object is attached or not.
//
//  Arguments:
//              [pMenuBtnNotifyClbk] - Notify callback.
//
//  Returns:    bool
//
//--------------------------------------------------------------------
bool CMenuButtonsMgrImpl::IsAttached( CMenuButtonNotify* pMenuBtnNotifyClbk)
{
    MMC_AttachedMenuButtons::iterator it = m_AttachedMenuButtons.find(pMenuBtnNotifyClbk);
    if (m_AttachedMenuButtons.end() != it)
        return true;

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\menubar.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      menubar.h
 *
 *  Contents:  Interface file for CMenuBar
 *
 *  History:   14-Nov-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef MENUBAR_H
#define MENUBAR_H
#pragma once


/////////////////////////////////////////////////////////////////////////////
// CMenuBar class

class CRebarDockWindow;     // forward declaration
class CMDIMenuDecoration;
class CRebarWnd;

#define WM_POPUP_ASYNC      WM_APP

#define MAX_MENU_ITEMS      32    // Maximum # of items in main menu.


class CMenuBar : public CMMCToolBarCtrlEx
{
    friend class CPopupTrackContext;
    typedef std::vector<CString>    ToolbarStringPool;
    typedef std::set<INT>           CommandIDPool;

    std::auto_ptr<CMDIMenuDecoration>   m_pMDIDec;

    ToolbarStringPool       m_ToolbarStringPool;
    CMDIFrameWnd *          m_pMDIFrame;
    CWnd*                   m_pwndLastActive;
    CRebarWnd *             m_pRebar;
    HMENU                   m_hMenuLast;
    CAccel                  m_MenuAccel;        // to handle Alt+<mnemonic>
    CAccel                  m_TrackingAccel;    // to <mnemonic> while in menu mode
    CFont                   m_MenuFont;
    CString                 m_strAccelerators;
    HICON                   m_hMaxedChildIcon;
    bool                    m_fDestroyChildIcon;
    bool                    m_fDecorationsShowing;
    bool                    m_fMaxedChildIconIsInvalid;
    // following member is to indicate that the change in menu is because of attempt
    // to switch to another submenu, and should not be treated as dismissing the menu
    // thus accelerator state should not be changed
    bool                    m_bInProgressDisplayingPopup;
    CommandIDPool           m_CommandIDUnUsed;       // Command IDs pool (to recycle unused ids).

    static const CAccel& GetMenuUISimAccel();

    void    DeleteMaxedChildIcon();
public:
    CMenuBar ();
    virtual ~CMenuBar ();

    virtual void BeginTracking2 (CToolbarTrackerAuxWnd* pAuxWnd);
    virtual void EndTracking2   (CToolbarTrackerAuxWnd* pAuxWnd);

    virtual int GetFirstButtonIndex ();
    BOOL Create (CMDIFrameWnd* pwndFrame, CRebarDockWindow* pParentRebar, DWORD dwStyle, UINT idWindow);
    BOOL Create (CFrameWnd* pwndFrame,    CRebarDockWindow* pParentRebar, DWORD dwStyle, UINT idWindow);
    void SetMenu (CMenu* pMenu);
    int AddString (const CString& strAdd);
    void PopupMenuAsync (int cmd);
    void OnIdle ();
    void GetAccelerators (int cchBuffer, LPTSTR lpBuffer) const;

    // Following methods used by CMenuButtonsMgr
    // to add/delete/modify menu buttons
    LONG InsertMenuButton(LPCTSTR lpszButtonText, BOOL bHidden, int iPreferredPos = -1);
    BOOL DeleteMenuButton(INT nCommandID);
    LONG SetMenuButton(INT nCommandID, LPCTSTR lpszButtonText);

    SC   ScShowMMCMenus(bool bShow);

    CMenu* GetMenu () const
    {
        return (CMenu::FromHandle (m_hMenuLast));
    }

    void InvalidateMaxedChildIcon ()
    {
        if (m_fDecorationsShowing)
        {
            m_fMaxedChildIconIsInvalid = true;
            InvalidateRect (NULL);
        }
    }

    enum
    {
        cMaxTopLevelMenuItems = MAX_MENU_ITEMS,

        // top-level menu item commands
        ID_MTB_MENU_FIRST     = CMMCToolBarCtrlEx::ID_MTBX_LAST + 1,

        // The following menus have fixed command-ids.
        ID_MTB_MENU_SYSMENU   = ID_MTB_MENU_FIRST,
        ID_MTB_MENU_ACTION    = ID_MTB_MENU_SYSMENU + 1,
        ID_MTB_MENU_VIEW      = ID_MTB_MENU_ACTION + 1,
        ID_MTB_MENU_FAVORITES = ID_MTB_MENU_VIEW + 1,
        ID_MTB_MENU_SNAPIN_PLACEHOLDER = ID_MTB_MENU_FAVORITES + 1,

        // The following command ids are free to be assigned.
        // Starts with last fixed command-id.
        ID_MTB_FIRST_COMMANDID = ID_MTB_MENU_SNAPIN_PLACEHOLDER + 1,
        ID_MTB_MENU_LAST    = ID_MTB_MENU_VIEW + cMaxTopLevelMenuItems,

        ID_MTB_ACTIVATE_CURRENT_POPUP,

        ID_MTB_FIRST = ID_MTB_MENU_FIRST,
        ID_MTB_LAST  = ID_MTB_ACTIVATE_CURRENT_POPUP,

        ID_MDIDECORATION = 0x2001
    };


    int IndexToCommand (int nIndex) const
    {
        TBBUTTON tbbi;
        tbbi.idCommand = 0; // We need only idCommand so just init this.

        if (GetButton(nIndex, &tbbi))
            return tbbi.idCommand;

        ASSERT(FALSE);
        return -1;
    }


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMenuBar)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

protected:
    void DestroyAcceleratorTable ();
    void SetMenuFont ();
    void SizeDecoration ();
    int  GetMenuBandIndex () const;
    int  GetDecorationBandIndex () const;
    void GetMaxedChildIcon (CWnd* pwnd);
    BOOL InsertButton (int nIndex, const CString& strText, int idCommand,
                       DWORD_PTR dwMenuData, BYTE fsState, BYTE fsStyle);

	/*
	 * Derived classes can override this to handle properties they support.
	 * The base class should always be called first.
	 */
	virtual SC ScGetPropValue (
		HWND				hwnd,		// I:accessible window
		DWORD				idObject,	// I:accessible object
		DWORD				idChild,	// I:accessible child object
		const MSAAPROPID&	idProp,		// I:property requested
		VARIANT&			varValue,	// O:returned property value
		BOOL&				fGotProp);	// O:was a property returned?

	virtual SC ScInsertAccPropIDs (PropIDCollection& v);

    // Generated message map functions
protected:
    //{{AFX_MSG(CMenuBar)
    afx_msg void OnDropDown(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg LRESULT OnPopupAsync(WPARAM, LPARAM);
    afx_msg void OnHotItemChange(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAccelPopup (UINT cmd);
    afx_msg void OnUpdateAllCmdUI (CCmdUI*  pCmdUI);
    afx_msg void OnActivateCurrentPopup ();

    DECLARE_MESSAGE_MAP()

    void PopupMenu (int nItemIndex, bool bHighlightFirstItem);

    // Accelerators
private:
	typedef std::vector<ACCEL>  AccelVector;
	
	AccelVector  m_vMenuAccels;
	AccelVector  m_vTrackingAccels;

private:
	void LoadAccels();
	bool IsStandardMenuAllowed(UINT uMenuID);
};

/*---------------------------------------------------------*\
| copied from winuser.h since we currently compile
| with _WIN32_WINNT == 0x0400
\*---------------------------------------------------------*/
#if(_WIN32_WINNT < 0x0500)
    #define WM_CHANGEUISTATE                0x0127
    #define WM_UPDATEUISTATE                0x0128
    #define WM_QUERYUISTATE                 0x0129

    #define UIS_SET                         1
    #define UIS_CLEAR                       2
    #define UIS_INITIALIZE                  3

    #define UISF_HIDEFOCUS                  0x1
    #define UISF_HIDEACCEL                  0x2

    #define WM_UNINITMENUPOPUP              0x0125
#endif // (_WIN32_WINNT < 0x0500)

#endif  /* MENUBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mmcaxwin.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 2000
 *
 *  File:      mmcaxwin.cpp
 *
 *  Contents:  functions for CMMCAxWindow
 *
 *  History:   27-Jan-2000 audriusz    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "mshtml.h"

#include "amc.h"
#include "ocxview.h"
#include "amcview.h"
#include "findview.h"

#ifdef DBG
    CTraceTag tagMMCViewBehavior (TEXT("MMCView Behavior"), TEXT("MMCView Behavior"));
#endif

/***************************************************************************\
 *
 * METHOD:  CMMCAxHostWindow::Invoke
 *
 * PURPOSE: ATL 3.0 has a bug in type library so we owerride this method to
 *          take care of properties which will fail othervise
 *
 * PARAMETERS:
 *    DISPID dispIdMember
 *    REFIID riid
 *    LCID lcid
 *    WORD wFlags
 *    DISPPARAMS FAR* pDispParams
 *    VARIANT FAR* pVarResult
 *    EXCEPINFO FAR* pExcepInfo
 *    unsigned int FAR* puArgErr
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCAxHostWindow::Invoke(  DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT FAR* pVarResult, EXCEPINFO FAR* pExcepInfo, unsigned int FAR* puArgErr)
{
    DECLARE_SC(sc, TEXT("CMMCAxHostWindow::Invoke"));

    // This method is here to override IDispatch::Invoke from IDispatchImpl<IAxWinAmbientDispatch,..>
    // to workaround the ATL30 bug - invalid type library entries for disp ids:
    // DISPID_AMBIENT_SHOWHATCHING and DISPID_AMBIENT_SHOWGRABHANDLES

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control

    if (DISPATCH_PROPERTYGET & wFlags)
    {
		if (dispIdMember == DISPID_AMBIENT_SHOWGRABHANDLES)
		{
			if (pVarResult == NULL)
            {
				sc = SC(E_INVALIDARG);
				return sc.ToHr();
            }
			V_VT(pVarResult) = VT_BOOL;
			sc = get_ShowGrabHandles(&(V_BOOL(pVarResult)));
            return sc.ToHr();
		}
		else if (dispIdMember == DISPID_AMBIENT_SHOWHATCHING)
		{
			if (pVarResult == NULL)
            {
				sc = SC(E_INVALIDARG);
				return sc.ToHr();
            }
			V_VT(pVarResult) = VT_BOOL;
			sc = get_ShowHatching(&(V_BOOL(pVarResult)));
            return sc.ToHr();
		}
    }
    // default: forward to base class
    return CAxHostWindow::Invoke( dispIdMember, riid, lcid, wFlags, pDispParams,
                                  pVarResult, pExcepInfo, puArgErr);
}

/***************************************************************************\
 *
 * METHOD:  CMMCAxHostWindow::OnPosRectChange
 *
 * PURPOSE: ATL does not implement this method, but it's needed to size MFC controls
 *
 * PARAMETERS:
 *    LPCRECT lprcPosRect - rectangle to fit in
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCAxHostWindow::OnPosRectChange(LPCRECT lprcPosRect)
{
    DECLARE_SC(sc, TEXT("CMMCAxHostWindow::OnPosRectChange"));

    // give base class a try (use temp sc to prevent tracing here)
    SC sc_temp = CAxHostWindow::OnPosRectChange(lprcPosRect);

    // we only want to come into the game as the last resort
    if (!(sc_temp == SC(E_NOTIMPL)))
        return sc_temp.ToHr();

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control
    // since ATL does not implement it, we have to do it to make MFC controls happy

    // from MSDN:
    // When the in-place object calls IOleInPlaceSite::OnPosRectChange,
    // the container must call IOleInPlaceObject::SetObjectRects to specify
    // the new position of the in-place window and the ClipRect.
    // Only then does the object resize its window.

    // get pointer to control
    IDispatchPtr spExtendedControl;
    sc= GetExtendedControl(&spExtendedControl);
    if (sc)
        return sc.ToHr();

    // get inplace object interface
    IOleInPlaceObjectPtr spInPlaceObject = spExtendedControl;
    if (spInPlaceObject == NULL)
    {
        sc = SC(E_UNEXPECTED);
        return sc.ToHr();
    }

    sc = spInPlaceObject->SetObjectRects(lprcPosRect,lprcPosRect);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCAxHostWindow::OnSetFocus
 *
 * PURPOSE: Simple override of bogus CAxHostWindow::OnSetFocus
 *          Coppied from ATL 3.0, changed m_bInPlaceActive to m_bUIActive
 *          See bug 433228 (MMC2.0 Can not tab in a SQL table)
 *
 * PARAMETERS:
 *    UINT uMsg
 *    WPARAM wParam
 *    LPARAM lParam
 *    BOOL& bHandled
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
LRESULT CMMCAxHostWindow::OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
{
    m_bHaveFocus = TRUE;
    if (!m_bReleaseAll)
    {
        if (m_spOleObject != NULL && !m_bUIActive)
        {
            CComPtr<IOleClientSite> spClientSite;
            GetControllingUnknown()->QueryInterface(IID_IOleClientSite, (void**)&spClientSite);
            if (spClientSite != NULL)
			{
				Trace (tagOCXActivation, _T("Activating in-place object"));
                HRESULT hr = m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
				Trace (tagOCXActivation, _T("UI activation returned 0x%08x"), hr);
			}
        }
        if(!m_bWindowless && !IsChild(::GetFocus()))
		{
			Trace (tagOCXActivation, _T("Manually setting focus to first child"));
            ::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
		}
    }
	else
		Trace (tagOCXActivation, _T("Skipping UI activation"));

	/*
	 * The code above might cause the focus to be sent elsewhere, which
	 * means this window will receive WM_KILLFOCUS.  CAxHostWindow::OnKillFocus
	 * sets m_bHaveFocus to FALSE.
	 *
	 * If we set bHandled = FALSE here, then ATL will call CAxHostWindow::OnSetFocus,
	 * which will set m_bHaveFocus to TRUE again, even though we've already
	 * lost the focus.  We only want to forward on to CAxHostWindow if
	 * we still have the focus after attempting to activate our hosted control.
	 */
	if (m_bHaveFocus)
	{
		Trace (tagOCXActivation, _T("Forwarding to CAxHostWindow::OnSetFocus"));
		bHandled = FALSE;
	}
	else
		Trace (tagOCXActivation, _T("Skipping CAxHostWindow::OnSetFocus"));

    return 0;
}


/*+-------------------------------------------------------------------------*
 * class CMMCViewBehavior
 *
 *
 * PURPOSE: Allows the current snapin view (ie list, web, or OCX) to be
 *          superimposed onto a view extension. The behavior can be attached
 *          to any tag, and will cause the snapin view to display in the area
 *          occupied by the tag.
 *
 *+-------------------------------------------------------------------------*/
class CMMCViewBehavior :
    public CComObjectRoot,
    public IElementBehavior,
    public IDispatch // used as the event sink
{
typedef CMMCViewBehavior ThisClass;
    UINT m_bCausalityCount;
	// fix to the bug #248351 - ntbug9. 6/25/01	"No List" taskpad displays a list when node selection changes from extended view
	// the script should not force the list to be shown more then once, since, due to the asynchronous nature of the
	// script execution, some of code may be executed late, after the MMC hides the listview.
	// In such case showing the listview is harmful
	bool m_bShowShowListView;

public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IElementBehavior)
        COM_INTERFACE_ENTRY(IDispatch) // NEEDED. See note above
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    // constructor
    CMMCViewBehavior() : m_pAMCView(NULL), m_bCausalityCount(0), m_bShowShowListView(true) {}

    // IElementBehavior
    STDMETHODIMP Detach()                                   {return ScDetach().ToHr();}
    STDMETHODIMP Init(IElementBehaviorSite *pBehaviorSite)  {return ScInit(pBehaviorSite).ToHr();}
    STDMETHODIMP Notify(LONG lEvent,VARIANT *pVar)          {return ScNotify(lEvent).ToHr();}

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(unsigned int *  pctinfo)                                                               {return E_NOTIMPL;}
    STDMETHODIMP GetTypeInfo(unsigned int  iTInfo, LCID  lcid, ITypeInfo **  ppTInfo)                                    {return E_NOTIMPL;}
    STDMETHODIMP GetIDsOfNames( REFIID  riid, OLECHAR **rgszNames, unsigned int  cNames, LCID   lcid, DISPID *  rgDispId){return E_NOTIMPL;}
    STDMETHODIMP Invoke(DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult,
                    EXCEPINFO *pExcepInfo, unsigned int *puArgErr)                                                       {return ScUpdateMMCView().ToHr();}


private:

    /*+-------------------------------------------------------------------------*
     *
     * ScNotify
     *
     * PURPOSE: Handles the IElementBehavior::Notify method.
	 *          When we get the document ready notification we can get the document
	 *          and get the CAMCView window which will be cached for future use.
     *
     * PARAMETERS:
     *    LONG  lEvent :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC  ScNotify(LONG lEvent)
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::ScNotify"));

        // When the whole document is loaded access it to get the CAMCView window.
        if (lEvent == BEHAVIOREVENT_DOCUMENTREADY )
        {
            // get the HTML document from the element
            IDispatchPtr spDispatchDoc;
            sc = m_spElement->get_document(&spDispatchDoc);
            if(sc)
                return sc;

            // QI for the IOleWindow interface
            IOleWindowPtr spOleWindow = spDispatchDoc;

            sc = ScCheckPointers(spOleWindow, E_UNEXPECTED);
            if(sc)
                return sc;

            // Get the IE window and find the ancestor AMCView
            HWND hwnd = NULL;

            sc = spOleWindow->GetWindow(&hwnd);
            if(sc)
                return sc;

            hwnd = FindMMCView(hwnd); // find the ancestor mmcview

            if(hwnd==NULL)
                return (sc = E_UNEXPECTED);

            m_pAMCView = dynamic_cast<CAMCView *>(CWnd::FromHandle(hwnd));

            sc = ScCheckPointers(m_pAMCView); // make sure we found a valid view.
			if (sc)
				return sc;
        }

        sc = ScUpdateMMCView(); // this sets up the view initially

        return sc;
    }


    /*+-------------------------------------------------------------------------*
     *
     * ScInit
     *
     * PURPOSE: Initializes the behavior. Connects the behavior to the onresize
	 *          and onreadystatechange events of the element it is attached to.
	 *          We can talk to the element but cannot access document until we
	 *          get document-ready notification in Notify method.
     *
     * PARAMETERS:
     *    IElementBehaviorSite * pBehaviorSite :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC ScInit(IElementBehaviorSite *pBehaviorSite)
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::Init"));

        sc = ScCheckPointers(pBehaviorSite);
        if(sc)
            return sc;

        sc = pBehaviorSite->GetElement(&m_spElement);
        if(sc)
            return sc;

        IDispatchPtr spDispatch = this; // does the addref

        IHTMLElement2Ptr spElement2 = m_spElement;

        sc = ScCheckPointers(spElement2.GetInterfacePtr(), spDispatch.GetInterfacePtr());
        if(sc)
            return sc;

        
        // set the onresize handler
        sc = spElement2->put_onresize(_variant_t(spDispatch.GetInterfacePtr()));
        if(sc)
            return sc;

        
        // set the onreadystatechange handler
        sc = spElement2->put_onreadystatechange(_variant_t(spDispatch.GetInterfacePtr()));
        if(sc)
            return sc;

        return sc;
    }

    /*+-------------------------------------------------------------------------*
     *
     * ScDetach
     *
     * PURPOSE: Detaches the behavior
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC ScDetach()
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::ScDetach"));

        m_spElement = NULL;
        m_pAMCView  = NULL;

        return sc;
    }


    /*+-------------------------------------------------------------------------*
     * class CCausalityCounter
     * 
     *
     * PURPOSE: used to determine whether a function has resulted in a call back to itself on the same stack
     *
     * USAGE: Initialize with a variable that is set to zero.
     *+-------------------------------------------------------------------------*/
    class CCausalityCounter // 
    {
        UINT & m_bCounter;
    public:
        CCausalityCounter(UINT &bCounter) : m_bCounter(bCounter){++m_bCounter;}
        ~CCausalityCounter() {--m_bCounter;}

        bool HasReentered() 
        {
            return (m_bCounter>1);
        }
    };

    /*+-------------------------------------------------------------------------*
     *
     * ScUpdateMMCView
     *
     * PURPOSE: The callback for all events that the behavior is connected to. This
     *          causes the size of the snapin view to be recomputed and displayed
	 *
	 *          This method is also called by IDispatch::Invoke, which is called for mouse-in,
	 *          mouse-out events. So this method may be called after Detach in which case
	 *          m_pAMCView is NULL which is legal.
	 *
     * PARAMETERS: None
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC ScUpdateMMCView()
    {
        DECLARE_SC(sc, TEXT("CMMCViewBehavior::ScUpdateMMCView"));

        CCausalityCounter causalityCounter(m_bCausalityCount);
        if(causalityCounter.HasReentered())
            return sc; // avoid re-entering the function from itself.

        sc = ScCheckPointers(m_spElement);
        if(sc)
            return sc;

		// See the note above.
		if (! m_pAMCView)
			return sc;

        long offsetTop    = 0;
        long offsetLeft   = 0;
        long offsetHeight = 0;
        long offsetWidth  = 0;

        // get the coordinates of the element
        sc = m_spElement->get_offsetTop(&offsetTop);
        if(sc)
            return sc;

        sc = m_spElement->get_offsetLeft(&offsetLeft);
        if(sc)
            return sc;

        sc = m_spElement->get_offsetHeight(&offsetHeight);
        if(sc)
            return sc;

        sc = m_spElement->get_offsetWidth(&offsetWidth);
        if(sc)
            return sc;

        Trace(tagMMCViewBehavior, TEXT("Top: %d Left: %d Height: %d Width: %d"), offsetTop, offsetLeft, offsetHeight, offsetWidth);

        // set the coordinates. NOTE: replace by a single method call
        sc = m_pAMCView->ScSetViewExtensionFrame(m_bShowShowListView, offsetTop, offsetLeft, offsetTop + offsetHeight /*bottom*/, offsetLeft + offsetWidth /*right*/);
		m_bShowShowListView = false;

        return sc;
    }

    // data members
private:
    IHTMLElementPtr m_spElement;
    CAMCView *      m_pAMCView;

};


/*+-------------------------------------------------------------------------*
 * class CElementBehaviorFactory
 *
 *
 * PURPOSE: Creates instances of the MMCView behavior
 *
 *+-------------------------------------------------------------------------*/
class CElementBehaviorFactory :
    public CComObjectRoot,
    public IElementBehaviorFactory,
    public IObjectSafetyImpl<CElementBehaviorFactory, INTERFACESAFE_FOR_UNTRUSTED_CALLER> // required
{
    typedef CElementBehaviorFactory ThisClass;

public:

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

public: // IElementBehaviorFactory

    STDMETHODIMP FindBehavior(BSTR bstrBehavior, BSTR bstrBehaviorUrl,
                              IElementBehaviorSite *pSite, IElementBehavior **ppBehavior)
    {
        DECLARE_SC(sc, TEXT("CElementBehaviorFactory::FindBehavior"));

        sc = ScCheckPointers(ppBehavior);
        if(sc)
            return sc.ToHr();


        // init out parameter
        *ppBehavior = NULL;

        if((bstrBehavior != NULL) && (wcscmp(bstrBehavior, L"mmcview")==0)) // requested the mmcview behavior
        {
            typedef CComObject<CMMCViewBehavior> t_behavior;

            t_behavior *pBehavior = NULL;
            sc = t_behavior::CreateInstance(&pBehavior);
            if(sc)
                return sc.ToHr();

            *ppBehavior = pBehavior;
            if(!*ppBehavior)
            {
                delete pBehavior;
                return (sc = E_UNEXPECTED).ToHr();
            }

            (*ppBehavior)->AddRef(); // addref for client

            return sc.ToHr();
        }
        return E_FAIL;
    }
};


/*+-------------------------------------------------------------------------*
 *
 * CMMCAxHostWindow::QueryService
 *
 * PURPOSE: If called with SID_SElementBehaviorFactory, returns a behavior
 *          factory that implements the mmcview behavior
 *
 * PARAMETERS:
 *    REFGUID  rsid :
 *    REFIID   riid :
 *    void**   ppvObj :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCAxHostWindow::QueryService( REFGUID rsid, REFIID riid, void** ppvObj)
{
    DECLARE_SC(sc, TEXT("CMMCAxHostWindow::QueryService"));
    typedef CAxHostWindow BC;

    if(rsid==SID_SElementBehaviorFactory)
    {
        if(m_spElementBehaviorFactory==NULL)
        {
            // create the object
            typedef CComObject<CElementBehaviorFactory> t_behaviorFactory;
            t_behaviorFactory *pBehaviorFactory = NULL;

            sc = t_behaviorFactory::CreateInstance(&pBehaviorFactory);
            if(sc)
                return sc.ToHr();

            m_spElementBehaviorFactory = pBehaviorFactory; // does the addref
            if(m_spElementBehaviorFactory==NULL)
            {
                delete pBehaviorFactory;
                return (sc = E_UNEXPECTED).ToHr();
            }
        }

        sc = m_spElementBehaviorFactory->QueryInterface(riid, ppvObj);
        return sc.ToHr();

    }

    HRESULT hr = BC::QueryService(rsid, riid, ppvObj);
    return hr; // do not want errors from BC to be traced
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\menubtns.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menubtns.h
//
//              Menu Buttons implementation
//
/////////////////////////////////////////////////////////////////////////////

#ifndef MENUBTNS_H
#define MENUBTNS_H

#include "toolbars.h"       // for CMenuButtonsMgrImpl
#include "tstring.h"

class CMenuBar;

// The (individual) Menu Button.
typedef struct MMC_MENUBUTTON
{
    CMenuButtonNotify* pMenuButtonNotifyClbk; // Represents the IMenuButton object
                                              // exposed to the snapin.
    tstring            lpButtonText;
    tstring            lpStatusText;

    INT                idCommand;            // Unique ID given by the snapin, may not be unique within
                                             // this object as there may be another snapin with same id.
                                             // The pair of (pMenuButtonNotifyClbk, idCommand) is unique.

    INT                nCommandIDFromMenuBar; // The CMenuBar has inserted this button and has
                                              // assigned this command id. CMenuButtonsMgrImpl
                                              // can call CMenuBar methods (other than InsertMenuButton)
                                              // using this id. Also this id will be unique for this button
                                              // in this object.

    bool                m_fShowMenu      : 1; // Represents hidden state set by snapin.

    MMC_MENUBUTTON()
    {
        pMenuButtonNotifyClbk = NULL;
        lpButtonText    = _T("");
        lpStatusText    = _T("");
        m_fShowMenu     = true;
        nCommandIDFromMenuBar = -1;
    }

    void SetShowMenu     (bool b = true)   { m_fShowMenu    = b; }

    bool CanShowMenu     () const          { return (m_fShowMenu); }

} MMC_MENUBUTTON;

// This is the collection of all menu buttons added by snapin
// as well as MMC (Action, View, Favorites).
typedef std::vector<MMC_MENUBUTTON>   MMC_MenuButtonCollection;

// This is the collection of each IMenuButton (objecct) that snapin
// has called Attach on (therefore visible).
typedef std::set<CMenuButtonNotify*>  MMC_AttachedMenuButtons;

class CMenuButtonsMgrImpl : public CMenuButtonsMgr
{
public:
    // CMenuButtonsMgr methods
    virtual SC ScAddMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                               INT idCommand, LPCOLESTR lpButtonText,
                               LPCOLESTR lpStatusText);
    virtual SC ScAttachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk);
    virtual SC ScDetachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk);
    virtual SC ScModifyMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                  INT idCommand, LPCOLESTR lpButtonText,
                                  LPCOLESTR lpStatusText);
    virtual SC ScModifyMenuButtonState(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                       INT idCommand, MMC_BUTTON_STATE nState,
                                       BOOL bState);
    virtual SC ScDisableMenuButtons();
    virtual SC ScToggleMenuButton(BOOL bShow);

public:
    // These methods are used the Child Frame
    SC ScInit(CMainFrame* pMainFrame, CChildFrame* pParentWnd);
    SC ScAddMenuButtonsToMainMenu();

    // Used by CMenuBar to notify a menu button click.
    SC ScNotifyMenuClick(const INT nCommandID, const POINT& pt);

public:
    CMenuButtonsMgrImpl();
    virtual ~CMenuButtonsMgrImpl();

private:
    MMC_MenuButtonCollection::iterator GetMMCMenuButton(
                                 CMenuButtonNotify* pMenuBtnNotifyClbk,
                                 INT idCommand);
    MMC_MenuButtonCollection::iterator GetMMCMenuButton(INT nButtonID);
    bool IsAttached(CMenuButtonNotify* pMenuBtnNotifyClbk);

private:
    // Data members
    CChildFrame*    m_pChildFrame;  // The child frame window.
    CMainFrame*     m_pMainFrame;   // The main frame window.

    // This is the collection of menu buttons.
    MMC_MenuButtonCollection     m_MenuButtons;

    // This is the collection of each IMenuButton seen by the snapin.
    MMC_AttachedMenuButtons      m_AttachedMenuButtons;

    // The Menu Bar object that is the main menu
    CMenuBar*  m_pMenuBar;
};

#endif /* MENUBTNS_H */

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mmcaxwin.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      mmcaxwin.inl
 *
 *  Contents:  Inline functions for CMMCAxWindow
 *
 *  History:   10-Jan-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef MMCAXWIN_INL_INCLUDED
#define MMCAXWIN_INL_INCLUDED

#ifdef HACK_CAN_WINDOWLESS_ACTIVATE

/*+-------------------------------------------------------------------------*
 * MMCAxCreateControlEx
 *
 * Lifted straight from AtlAxCreateControlEx in atl30.h.  The only
 * difference is that it creates a CMMCAxHostWindow rather than a 
 * CAxHostWindow.
 *--------------------------------------------------------------------------*/

inline HRESULT MMCAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream,
        IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
    AtlAxWinInit();
    HRESULT hr;
    CComPtr<IUnknown> spUnkContainer;
    CComPtr<IUnknown> spUnkControl;

//  hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
    hr = CMMCAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
    if (SUCCEEDED(hr))
    {
        CComPtr<IAxWinHostWindow> pAxWindow;
        spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
        CComBSTR bstrName(lpszName);
        hr = pAxWindow->CreateControlEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink);
    }
    if (ppUnkContainer != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *ppUnkContainer = spUnkContainer.p;
            spUnkContainer.p = NULL;
        }
        else
            *ppUnkContainer = NULL;
    }
    if (ppUnkControl != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
            spUnkControl.p = NULL;
        }
        else
            *ppUnkControl = NULL;
    }
    return hr;
}


/*+-------------------------------------------------------------------------*
 * CMMCAxWindow::AxCreateControl2
 *
 * Simple override of CAxWindowImplT::AxCreateControl2 that calls
 * MMCAxCreateControlEx rather than AtlAxCreateControlEx
 *--------------------------------------------------------------------------*/

inline HRESULT CMMCAxWindow::AxCreateControl2(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
    return MMCAxCreateControlEx(lpszName, hWnd, pStream,ppUnkContainer,ppUnkControl,iidSink,punkSink);
}

#endif /* HACK_CAN_WINDOWLESS_ACTIVATE */

/*+-------------------------------------------------------------------------*
 * CMMCAxWindow::SetFocus
 *
 * Simple override of CAxWindow::SetFocus that handles more special cases
 * NOTE: this is not a virtual method. Invoking on base class pointer will
 * endup in executing other method.
 *--------------------------------------------------------------------------*/

inline HWND CMMCAxWindow::SetFocus()
{
    DECLARE_SC(sc, TEXT("CMMCAxWindow::SetFocus"));

    //  A misbehaving OCX may keep a hidden window in our view instead 
    //  of destroying it when it's not in-place active, so make sure 
    //  the window's visible and enabled before trying to give it focus.
    //  (MFC doesn't check before doing a UIActivate call.)
    HWND hwndControl = ::GetWindow(m_hWnd, GW_CHILD);
    if (!hwndControl || !::IsWindowVisible(hwndControl) || !::IsWindowEnabled(hwndControl))
        return (HWND)NULL;  // do not change anything

    // simply set focus on itselt - msg handlers will do the rest
    return ::SetFocus(m_hWnd);
}

#endif /* MMCAXWIN_INL_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mmcres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by amc.rc
//
#define IDR_MMCOBJ_TYPELIB              1
#define IDR_WEBSINK_TYPELIB             4
#define IDD_LIST_SAVE                   102
#define IDR_MAINFRAME                   128
#define IDR_AMCTYPE                     129
#define IDD_URL_INPUT                   131
#define IDD_ADDSNAPIN                   132
#define IDR_AMCTYPE_USER                157
#define IDB_AMC_NODES16                 158
#define IDD_PROPPAGE_CONSOLE            158
#define IDB_AMC_NODES32                 159
#define IDR_SYSMENU_ADDITIONS           162
#define IDB_SORT                        168
#define IDD_ADDFAVORITE                 170
#define IDC_FAVNAME                     171
#define IDC_FAVTREE                     172
#define IDC_ADDFAVFOLDER                173
#define IDD_NEWFAVFOLDER                174
#define IDC_FAVFOLDER                   175
#define IDD_FAVORGANIZE                 176
#define IDC_FAVDELETE                   177
#define IDC_FAVMOVETO                   178
#define IDC_FAVRENAME                   179
#define IDC_FAVINFO                     180
#define IDD_FAVSELECTFOLDER             183
#define IDC_HAND_INTERNAL               186
#define IDR_AMCTYPE_MDI_USER            192
#define IDR_AMCTYPE_SDI_USER            194
#define IDD_DISK_CLEANUP                199
#define IDD_ArchitecturePicker          200
#define IDD_LIST_SAVE_NEW               201
#define IDB_COMMON_16                   202
#define IDB_COMMON_16_RTL				203
#define IDC_LV_SNAP_INS                 1000
#define IDC_URL_EDIT                    1001
#define IDC_SEL                         1002
#define IDC_CONSOLE_MODE                1022
#define IDC_CONSOLE_MODE_DESCRIPTION    1023
#define IDC_DONTSAVECHANGES             1024
#define IDC_CHANGE_ICON                 1025
#define IDC_CUSTOM_TITLE                1027
#define IDC_CONSOLE_ICON                1028
#define IDC_AllowViewCustomization      1029
#define IDC_DELETE_TEMP_FILES           1031
#define IDC_DISKCLEANUP_DESCRIPTION     1032
#define IDC_DISKCLEANUP_OCCUPIED        1033
#define IDC_DISKCLEANUP_TO_DELETE       1034
#define IDC_ConsoleFileName             1035
#define IDC_SnapinCount64               1036
#define IDC_SnapinCount32               1037
#define IDC_SnapinList64                1038
#define IDC_SnapinList32                1039
#define IDC_64Bit                       1040
#define IDC_32Bit                       1041
#define ID_HELP_HELPTOPICS              12804
#define ID_HELP_SNAPINHELP              12817
#define ID_CONSOLE_ADDREMOVESNAPIN      13201
#define ID_MMC_CUT                      13205
#define ID_MMC_COPY                     13206
#define ID_MMC_PASTE                    13207
#define ID_MMC_RENAME                   13208
#define ID_MMC_REFRESH                  13209
#define ID_MMC_PRINT                    13210
#define ID_MMC_MAXIMIZE                 13211
#define ID_MMC_RESTORE                  13212
#define ID_MMC_NEXT_PANE                13213
#define ID_MMC_PREV_PANE                13214
#define ID_MMC_CONTEXTHELP              13215
#define ID_CONSOLE_PROPERTIES           13220
#define ID_CUSTOMIZE_VIEW               13231
#define ID_MMC_TRACE_DIALOG             13235
#define ID_ACTION_MENU                  13238
#define ID_VIEW_MENU                    13239
#define ID_FAVORITES_MENU               13240
#define ID_SNAPIN_MENU_PLACEHOLDER      13241
#define ID_SNAPIN_ABOUT                 13242
#define ID_FILE_NEW_USER_MODE           13243

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         13243
#define _APS_NEXT_CONTROL_VALUE         1045
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\msaastub.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      msaastub.h
 *
 *  Contents:  Provides stub implementations of OLEACC functions that
 * 			   aren't available on backlevel OS's (Win95, NT4 SP3).
 *             These implementations were copied from msaa.h, which
 *             is no longer supported.
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

// UnDefine these names so we can re-define them below.
#undef AccessibleObjectFromWindow
#undef LresultFromObject

//
// Define COMPILE_MSAA_STUBS to compile the stubs;
// otherwise, you get the declarations.
//
// Exactly one source must include this with COMPILE_MSAA_STUBS defined.
//
#ifdef COMPILE_MSAA_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

#ifndef MSAA_FNS_DEFINED
// OLEACC
HRESULT         (WINAPI* g_pfnAccessibleObjectFromWindow)(HWND,DWORD,REFIID,void **) = NULL;
LRESULT         (WINAPI* g_pfnLresultFromObject)(REFIID,WPARAM,LPUNKNOWN) = NULL;
// STATUS
BOOL            g_fMSAAInitDone = FALSE;

#endif

//-----------------------------------------------------------------------------
// This is the function that checks that all the required API's exist, and
// then allows apps that include this file to call the real functions if they
// exist, or the 'stubs' if they do not. This function is only called by the
// stub functions - client code never needs to call this.
//-----------------------------------------------------------------------------
BOOL InitMSAAStubs(void)
{
    HMODULE hOleacc;

    if (g_fMSAAInitDone)
    {
        return g_pfnLresultFromObject != NULL;
    }

    hOleacc = GetModuleHandle(TEXT("OLEACC.DLL"));
    if (!hOleacc)
        hOleacc = LoadLibrary(TEXT("OLEACC.DLL"));

    if ((hOleacc) &&
        (*(FARPROC*)&g_pfnAccessibleObjectFromWindow = GetProcAddress(hOleacc,"AccessibleObjectFromWindow")) &&
        (*(FARPROC*)&g_pfnLresultFromObject          = GetProcAddress(hOleacc,"LresultFromObject")))
    {
        g_fMSAAInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnAccessibleObjectFromWindow = NULL;
        g_pfnLresultFromObject = NULL;

        g_fMSAAInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// Fake implementations of MSAA APIs that return error codes.
// No special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Fake implementation of AccessibleObjectFromWindow. Returns E_NOTIMPL if the
// real API is not present.
//-----------------------------------------------------------------------------
HRESULT WINAPI xAccessibleObjectFromWindow (HWND hWnd,DWORD dwID,REFIID riidInterface,
                                            void ** ppvObject)
{
    if (InitMSAAStubs())
        return g_pfnAccessibleObjectFromWindow (hWnd,dwID,riidInterface,ppvObject);

    return (E_NOTIMPL);
}

//-----------------------------------------------------------------------------
// Fake implementation of LresultFromObject. Returns E_NOTIMPL if the real API
// is not present.
//-----------------------------------------------------------------------------
LRESULT WINAPI xLresultFromObject (REFIID riidInterface,WPARAM wParam,LPUNKNOWN pUnk)
{
    if (InitMSAAStubs())
        return g_pfnLresultFromObject (riidInterface,wParam,pUnk);

    return (E_NOTIMPL);
}

#undef COMPILE_MSAA_STUBS

#else   // COMPILE_MSAA_STUBS

extern HRESULT WINAPI       xAccessibleObjectFromWindow (HWND hWnd,
                                                         DWORD dwID,
                                                         REFIID riidInterface,
                                                         void ** ppvObject);
extern LRESULT WINAPI       xLresultFromObject (REFIID riidInterface,
                                                WPARAM wParam,
                                                LPUNKNOWN pUnk);

#endif  // COMPILE_MSAA_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define AccessibleObjectFromWindow  xAccessibleObjectFromWindow
#define LresultFromObject           xLresultFromObject

#ifdef __cplusplus
}
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mmcaxwin.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      MMCAxWin.h
 *
 *  Contents:  Header file for CMMCAxWindow
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

DEFINE_COM_SMARTPTR(IHTMLElement2);                 // IHTMLElement2Ptr
DEFINE_COM_SMARTPTR(IElementBehaviorFactory);       // IElementBehaviorFactoryPtr

/*+-------------------------------------------------------------------------*
 * HACK_CAN_WINDOWLESS_ACTIVATE
 * 
 * Bug 451918:  By default, the ATL OCX host window supports hosting
 * windowless controls.  This differs from the MMC 1.2 implementation
 * of the OCX host window (which used MFC), which did not.  Some controls
 * (e.g. Disk Defragmenter OCX) claim to support windowless activation
 * but do not.
 * 
 * For compatibility, we must only instantiate result pane OCX's as 
 * windowed controls.  IInPlaceSiteWindowless (implemented by CAxHostWindow) 
 * gives us a nice clean way to do this, by returning S_FALSE from
 * CanWindowlessActivate.  We instruct CAxHostWindow to do this by changing its
 * AllowWindowlessActivation property.
 * 
 * There's a problem with that, however.  ATL21 has a bug where it tests
 * for CanWindowlessActivate returning a FAILED code rather than S_FALSE.
 * This means that even if we use put_AllowWindowlessActivation, ATL21-based
 * controls will still try to activate windowless.
 * 
 * We'll fix this problem by deriving a class, CMMCAxHostWindow, from 
 * CAxHostWindow which will return E_FAIL instead of S_FALSE if windowless
 * activation is not desired.
 *--------------------------------------------------------------------------*/
#define HACK_CAN_WINDOWLESS_ACTIVATE


/*+-------------------------------------------------------------------------*
 * class CMMCAxWindow
 * 
 *
 * PURPOSE: The MMC-specific version of CAxWindow. Contains any fixes and
 *          updates.
 *          Refer to the December 1999 issue of Microsoft Systems Journal
 *          for details, in the article "Extending ATL3.0 Control Containers
 *          to Help you write Real-World Containers."
 *
 *+-------------------------------------------------------------------------*/
class CMMCAxWindow : public CAxWindowImplT<CMMCAxWindow, CAxWindow2>
{
#ifdef HACK_CAN_WINDOWLESS_ACTIVATE
public:
    HRESULT AxCreateControl2(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, IUnknown** ppUnkControl = 0, REFIID iidSink = IID_NULL, IUnknown* punkSink = 0);
#endif
    // Simply override of CAxWindow::SetFocus that handles more special cases
    // NOTE: this is not a virtual method. Invoking on base class pointer will
    // endup in executing other method.
    // this method is added mainly to cope with bug 433228 (MMC2.0 Can not tab in a SQL table)
    HWND SetFocus();
};




/*+-------------------------------------------------------------------------*
 * CMMCAxHostWindow
 *
 * Simple class that overrides IInPlaceSiteWindowless::CanWindowlessActivate
 * to work around an ATL21 bug.  See comments for HACK_CAN_WINDOWLESS_ACTIVATE
 * for details.
 *--------------------------------------------------------------------------*/

class CMMCAxHostWindow : public CAxHostWindow
{
#ifdef HACK_CAN_WINDOWLESS_ACTIVATE

public:
#ifdef _ATL_HOST_NOLOCK
    typedef CComCreator< CComObjectNoLock< CMMCAxHostWindow > > _CreatorClass;
#else
    DECLARE_POLY_AGGREGATABLE(CMMCAxHostWindow)
#endif

    STDMETHOD(CanWindowlessActivate)()
    {
        return m_bCanWindowlessActivate ? S_OK : E_FAIL /*S_FALSE*/;
    }

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control
    // implements workarround for DISPID_AMBIENT_SHOWGRABHANDLES and DISPID_AMBIENT_SHOWHATCHING
    // the actual bug is in ALT 3.0 (atliface.idl)
    STDMETHOD(Invoke)( DISPID dispIdMember, REFIID riid, LCID lcid, 
                       WORD wFlags, DISPPARAMS FAR* pDispParams, 
                       VARIANT FAR* pVarResult, EXCEPINFO FAR* pExcepInfo, 
                       unsigned int FAR* puArgErr);

    // Added to solve bug 453609  MMC2.0: ActiveX container: Painting problems with the device manager control
    // Since ATL 3.0 does not implement it, we have to do it to make MFC controls happy
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

#if _ATL_VER <= 0x0301
    BEGIN_MSG_MAP(CMMCAxHostWindow)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        CHAIN_MSG_MAP(CAxHostWindow)
    END_MSG_MAP()

    //  We handle focus here specifically because of bogus implementation in ATL 3.0
    //  ATL tests m_bInPlaceActive instead of m_bUIActive.
    //  We need to test this rigorously so that we don't break other snapins.
    //  See bug 433228 (MMC2.0 Can not tab in a SQL table)
    LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled);
#else
    #error The code above was added as fix to bug in ATL 3.0; It needs to be revisited
           // since: 
           // a) the bug may be fixed on newer ATL versions;
           // b) it relies on variables defined in ATL, which may change;
#endif

#endif /* HACK_CAN_WINDOWLESS_ACTIVATE */


public:
    STDMETHOD(QueryService)( REFGUID rsid, REFIID riid, void** ppvObj); // used to supply the default behavior factory

private:
    IElementBehaviorFactoryPtr m_spElementBehaviorFactory;
};



#include "mmcaxwin.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mscparser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      mscparser.cpp
//
//  Contents:  Implementation of the code to upgrade legacy (MMC1.0, MMC1.1 and 
//             MMC1.2) .msc files to the new XML format
//
//  History:   04-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include <stdafx.h>
#include "strtable.h"
#include "stgio.h"
#include "comdbg.h"
#include "mmcdata.h"
#include "mscparser.h"

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScUpgrade
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    LPCTSTR  lpszPathName :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleFile::ScUpgrade(LPCTSTR lpszPathName)
{
    SC                      sc;
    IStoragePtr             spStorage;
    TCHAR                   szTempFile[MAX_PATH];
    DWORD                   dwRet                   = 0;
    
    USES_CONVERSION;

    // short circuit
    return sc;
    
    ASSERT(lpszPathName != NULL && *lpszPathName != 0);
    if (lpszPathName == NULL || *lpszPathName == 0)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }

    // Open the specified file
    sc = OpenDebugStorage(T2OLE((LPTSTR)lpszPathName), STGM_READ|STGM_SHARE_DENY_WRITE, &spStorage);
    if(sc.IsError() || spStorage==NULL)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }

    // get the console file's version
    sc = ScGetFileVersion(spStorage);
    if(sc)
        goto Error;

    // Load the string table.
    sc = ScLoadStringTable(spStorage);
    if(sc)
        goto Error;

    // Load column settings.
    sc = ScLoadColumnSettings(spStorage);
    if(sc)
        goto Error;

    // load the view settings
    sc = ScLoadViewSettings(spStorage);
    if(sc)
        goto Error;

    // load the tree
    sc = ScLoadTree(spStorage);
    if(sc)
        goto Error;

    // load the favorites
    sc = ScLoadFavorites(spStorage);
    if(sc)
        goto Error;

    // load custom data (including the icon)
    sc = ScLoadCustomData(spStorage);
    if(sc)
        goto Error;

    // The LoadAppMode, LoadViews and LoadFrame should be called in that order

    // load the app mode
    sc = ScLoadAppMode(spStorage);
    if(sc)
        goto Error;

    // load the views
    sc = ScLoadViews(spStorage);
    if(sc)
        goto Error;

    // load the frame
    sc = ScLoadFrame(spStorage);
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    //TraceError(TEXT("CConsoleFile::ScUpgrade"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScGetFileVersion
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScGetFileVersion(IStorage* pstgRoot)
{
    static const wchar_t*    AMCSignatureStreamName = L"signature";
    static const long double dOldVersion10          = 0.00000015;   // MMC version 1.0
    static const long double dOldVersion11          = 1.1;          // MMC version 1.1
    static const BYTE        byStreamVersionMagic   = 0xFF;


    SC                      sc;
    ConsoleFileVersion      eFileVer    = FileVer_0100;
    IStreamPtr              spStream;
    int                     nVersion    = 0;
    IStoragePtr             spStorage;

    ASSERT (sizeof(eFileVer) == sizeof(int));
    ASSERT(pstgRoot != NULL);

    // check for a valid pointer
    if (pstgRoot == NULL)
    {
        sc = ScFromMMC(IDS_INVALIDFILE); // TODO: add this IDS.
        goto Error;
    }

    // Open the stream containing the signature
    sc = OpenDebugStream(pstgRoot, AMCSignatureStreamName, STGM_SHARE_EXCLUSIVE | STGM_READ, L"\\signature", &spStream);
    if(sc.IsError() || spStream==NULL)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }

    // read the signature (stream extraction operators will throw
    // _com_error's, so we need an exception block here)
    try
    {
        // MMC v1.2 and later write a marker as the first 
        // byte of the signature stream.
        BYTE byMagic;
        *spStream >> byMagic;

        // if this file was written by v1.2, 
        // read the console file version (int)
        if (byMagic == byStreamVersionMagic)
        {
            *spStream >> nVersion;
            ASSERT (nVersion == FileVer_0120);
        }
        // Otherwise, the file was written by v1.0 or v1.1.
        // Back up to re-read the marker byte, and read the old-style 
        // file version (long double), then map it to a new-style version
        else
        {
            LARGE_INTEGER pos = {0, 0};
            spStream->Seek (pos, STREAM_SEEK_SET, NULL);

            long double dVersion;
            *spStream >> dVersion;

            // v1.1?
            if (dVersion == dOldVersion11)
                nVersion = FileVer_0110;

            // v1.0?
            else if (dVersion == dOldVersion10)
            {
                // If we got a v1.0 signature, we still may have a v1.1 file.
                // There was a period of time where MMC v1.1 wrote a v1.0
                // signature, but the file format had in fact changed.  We
                // can determine this by checking the \FrameData stream in 
                // the file.  If the first DWORD in the \FrameData stream is
                // sizeof(WINDOWPLACEMENT), we have a true v1.0 file, otherwise
                // it's a funky v1.1 file.

                IStreamPtr spFrameDataStm;

                sc = OpenDebugStream (pstgRoot, L"FrameData", STGM_SHARE_EXCLUSIVE | STGM_READ,
                                      &spFrameDataStm);
                if(sc)
                    goto Error;

                DWORD dw;
                *spFrameDataStm >> dw;

                if (dw == sizeof (WINDOWPLACEMENT))
                    nVersion = FileVer_0100;
                else
                    nVersion = FileVer_0110;
            }
            // unexpected version
            else
            {
                ASSERT (false && "Unexpected old-style signature");
                sc = E_UNEXPECTED;
                goto Error;
            }
        }
    }
    catch (_com_error& err)
    {
        sc = err.Error();
        goto Error;
    }

    // make sure the version number is valid.
    if(IsValidFileVersion(eFileVer))
    {
        sc = ScFromMMC(IDS_InvalidVersion); // TODO: add this IDS
        goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CConsoleFile::ScGetFileVersion"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScLoadStringTable
 *
 * PURPOSE: Reads in the string table for an .msc file.
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScLoadStringTable(IStorage* pstgRoot)
{
    SC      sc;

    static const wchar_t* AMCStringTableStorageName = L"String Table";

    /*
     * open the string table storage
     */
    IStoragePtr spStringTableStg;
    sc = OpenDebugStorage (pstgRoot, AMCStringTableStorageName,
                                        STGM_SHARE_EXCLUSIVE | STGM_READ, 
                                        &spStringTableStg);


    /*
     * If there's no string table, things are OK.  We allow this so
     * we can continue to open older console files.
     */
    if (sc == SC(STG_E_FILENOTFOUND) )
        return (true);

    if(sc)
        goto Error;

    /*
     * read the string table from the storage
     */
    try
    {
        *spStringTableStg >> *m_pStringTable;
    }
    catch (_com_error& err)
    {
        sc = err.Error();
        ASSERT (false && "Caught _com_error");
        goto Error;
    }


Cleanup:
    return sc;
Error:
    TraceError(TEXT("CConsoleFile::ScLoadStringTable"), sc);
    goto Cleanup;
}


SC  
CConsoleFile::ScLoadFrame(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadViews(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadAppMode(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScLoadColumnSettings
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScLoadColumnSettings(IStorage* pstgRoot)
{
    static const wchar_t* AMCColumnDataStreamName   = L"ColumnData";

    SC      sc;
    
    IPersistStreamPtr spPersistStreamColumnData; // TODO: create this object!

    IStreamPtr spStream;
    sc = OpenDebugStream (pstgRoot, AMCColumnDataStreamName,
                          STGM_SHARE_EXCLUSIVE | STGM_READ, &spStream);
    if (sc)
        goto Error;

    if (NULL == spPersistStreamColumnData)
    {
        sc = E_POINTER;
        goto Error;
    }
        
    sc = spPersistStreamColumnData->Load(spStream); // $CHANGE to use Load(spColumnData, spStream).
    if(sc)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }
    
Cleanup:
    return sc;
Error: 
    TraceError(TEXT("CConsoleFile::ScLoadColumnSettings"), sc);
    goto Cleanup;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleFile::ScLoadViewSettings
 *
 * PURPOSE: 
 *
 * PARAMETERS: 
 *    IStorage* pstgRoot :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CConsoleFile::ScLoadViewSettings(IStorage* pstgRoot)
{
    static const wchar_t* AMCViewSettingDataStreamName = L"ViewSettingData"; // View settings data stream

    SC      sc;
    IPersistStreamPtr spPersistStreamViewSettingData; // TODO: create this object!
    
    IStreamPtr spStream;
    sc = OpenDebugStream (pstgRoot, AMCViewSettingDataStreamName, 
                          STGM_SHARE_EXCLUSIVE | STGM_READ, &spStream);

    if (sc)
        goto Error;

    if (NULL == spPersistStreamViewSettingData)
    {
        sc = E_POINTER;
        goto Error;
    }
        
    sc = spPersistStreamViewSettingData->Load(spStream); // $CHANGE to use Load(spPersistStreamViewSettingData, spStream).
    if(sc)
    {
        sc = ScFromMMC(IDS_UnableToOpenDocumentMessage);
        goto Error;
    }
    
Cleanup:
    return sc;
Error: 
    TraceError(TEXT("CConsoleFile::ScLoadViewSettings"), sc);
    goto Cleanup;
}

SC  
CConsoleFile::ScLoadTree(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadFavorites(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}

SC  
CConsoleFile::ScLoadCustomData(IStorage* pstgRoot)
{
    SC      sc;
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\ocxview.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ocxview.cpp
 *
 *  Contents:  Implementation file for COCXHostView
 *
 *  History:   12-Dec-97 JeffRo     Created
 *
 *  This class is required to host OCX controls to fix focus problems.
 *  The MDI child frame window keeps track of its currently active view.
 *  When we're hosting OCX controls without this view and the OCX get the
 *  focus, the MDI child frame thinks the previously active view, usually
 *  the scope tree, is still the active view.  So if the user Alt-Tabs
 *  away from MMC and back, for instance, the scope tree will get the focus
 *  even though the OCX had the focus before.
 *
 *  We need this view to represent the OCX, which isn't a view, to the MDI
 *  child frame.
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "ocxview.h"
#include "amcview.h"


#ifdef DBG
CTraceTag  tagOCXActivation     (_T("OCX"), _T("Activation"));
CTraceTag  tagOCXTranslateAccel (_T("OCX"), _T("TranslateAccelerator"));
#endif


/*+-------------------------------------------------------------------------*
 * class COCXCtrlWrapper
 *
 *
 * PURPOSE: Maintains a pointer to a CMMCAxWindow as well as to the OCX in
 *          the window.
 *
 *+-------------------------------------------------------------------------*/
class COCXCtrlWrapper : public CComObjectRoot, public IUnknown
{
    typedef COCXCtrlWrapper ThisClass;
public:
    COCXCtrlWrapper() : m_pOCXWindow(NULL)
    {
    }

    ~COCXCtrlWrapper()
    {
        if(m_pOCXWindow && m_pOCXWindow->IsWindow())
            m_pOCXWindow->DestroyWindow();

        delete m_pOCXWindow;
    }

    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IUnknown)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass);

    SC  ScInitialize(CMMCAxWindow *pWindowOCX, IUnknown *pUnkCtrl) // initialize with the window that hosts the control
    {
        DECLARE_SC(sc, TEXT("COCXCtrlWrapper::ScInitialize"));
        sc = ScCheckPointers(pWindowOCX, pUnkCtrl);
        if(sc)
            return sc;

        m_pOCXWindow = pWindowOCX;
        m_spUnkCtrl  = pUnkCtrl;
        return sc;
    }

    SC  ScGetControl(IUnknown **ppUnkCtrl)
    {
        DECLARE_SC(sc, TEXT("COCXCtrlWrapper::ScGetData"));
        sc = ScCheckPointers(ppUnkCtrl);
        if(sc)
            return sc;

        *ppUnkCtrl   = m_spUnkCtrl;
        if(*ppUnkCtrl)
            (*ppUnkCtrl)->AddRef();
        return sc;
    }

   CMMCAxWindow *       GetAxWindow() {return m_pOCXWindow;}

private:
   CMMCAxWindow *       m_pOCXWindow; // handle to the window.
   CComPtr<IUnknown>    m_spUnkCtrl; // the IUnknown of the control
};



/////////////////////////////////////////////////////////////////////////////
// COCXHostView

IMPLEMENT_DYNCREATE(COCXHostView, CView)

COCXHostView::COCXHostView()  : m_pAMCView(NULL)
{
}

COCXHostView::~COCXHostView()
{
    m_pAMCView = NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::PreCreateWindow
 *
 * PURPOSE: Adds the WS_CLIPCHILDREN bit. This prevents the host window
 *          from overwriting the OCX.
 *
 * PARAMETERS:
 *    CREATESTRUCT& cs :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL
COCXHostView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |=  WS_CLIPCHILDREN;
    // give base class a chance to do own job
    BOOL bOK = (CView::PreCreateWindow(cs));

    // register view class
    LPCTSTR pszViewClassName = g_szOCXViewWndClassName;

    // try to register window class which does not cause the repaint
    // on resizing (do it only once)
    static bool bClassRegistered = false;
    if ( !bClassRegistered )
    {
        WNDCLASS wc;
        if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
        {
            // Clear the H and V REDRAW flags
            wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
            wc.lpszClassName = pszViewClassName;
            // Register this new class;
            bClassRegistered = AfxRegisterClass(&wc);
        }
    }

    // change window class to one which does not cause the repaint
    // on resizing if we successfully registered such
    if ( bClassRegistered )
        cs.lpszClass = pszViewClassName;

    return bOK;
}


/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::GetAxWindow
 *
 * PURPOSE: Returns a pointer to the current AxWindow.
 *
 * RETURNS:
 *    CMMCAxWindow *
 *
 *+-------------------------------------------------------------------------*/
CMMCAxWindow *
COCXHostView::GetAxWindow()
{
    COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>(m_spUnkCtrlWrapper.GetInterfacePtr());
    if(!pOCXCtrlWrapper)
        return (NULL);

    return pOCXCtrlWrapper->GetAxWindow();
}

CAMCView *
COCXHostView::GetAMCView()
{
    return m_pAMCView;
}


BEGIN_MESSAGE_MAP(COCXHostView, CView)
    //{{AFX_MSG_MAP(COCXHostView)
    ON_WM_SIZE()
    ON_WM_SETFOCUS()
    ON_WM_MOUSEACTIVATE()
    ON_WM_SETTINGCHANGE()
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COCXHostView drawing

void COCXHostView::OnDraw(CDC* pDC)
{
    // this view should always be totally obscured by the OCX it is hosting
}

/////////////////////////////////////////////////////////////////////////////
// COCXHostView diagnostics

#ifdef _DEBUG
void COCXHostView::AssertValid() const
{
    CView::AssertValid();
}

void COCXHostView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COCXHostView message handlers
void COCXHostView::OnSize(UINT nType, int cx, int cy)
{
    ASSERT_VALID (this);
    CView::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
    {
        if(GetAxWindow() != NULL)
            GetAxWindow()->MoveWindow (0, 0, cx, cy, FALSE /*bRepaint*/);
    }

}

void COCXHostView::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	SetAmbientFont (NULL);

    CView::OnSettingChange(uFlags, lpszSection);

    if(GetAxWindow() != NULL)
        GetAxWindow()->SendMessage (WM_SETTINGCHANGE, uFlags, (LPARAM) lpszSection);
}


void COCXHostView::OnSetFocus(CWnd* pOldWnd)
{
    DECLARE_SC(sc, TEXT("COCXHostView::OnSetFocus"));

    ASSERT_VALID (this);

    // delegate the focus to the control we're hosting, if we have one
    if(GetAxWindow() != NULL)
       GetAxWindow()->SetFocus();

    // check if someone cared to take the focus.
    // default handling else.
    if (this == GetFocus())
    {
        CView::OnSetFocus (pOldWnd);
    }
}

int COCXHostView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
    /*---------------------------------------------------------*/
    /* this code came from CView::OnMouseActivate; we do it    */
    /* here to bypass sending WM_MOUSEACTIVATE on the the      */
    /* parent window, avoiding focus churn in the parent frame */
    /*---------------------------------------------------------*/

    CFrameWnd* pParentFrame = GetParentFrame();
    if (pParentFrame != NULL)
    {
        // eat it if this will cause activation
        ASSERT(pParentFrame == pDesktopWnd || pDesktopWnd->IsChild(pParentFrame));

        // either re-activate the current view, or set this view to be active
        CView* pView = pParentFrame->GetActiveView();
        HWND hWndFocus = ::GetFocus();
        if (pView == this &&
            m_hWnd != hWndFocus && !::IsChild(m_hWnd, hWndFocus))
        {
            // re-activate this view
            OnActivateView(TRUE, this, this);
        }
        else
        {
            // activate this view
            pParentFrame->SetActiveView(this);
        }
    }
    return (MA_ACTIVATE);
}



BOOL COCXHostView::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo )
{
    // Do normal command routing
    if (CView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // if view didn't handle it, give parent view a chance
    CWnd*   pParentView = GetParent ();

    if ((pParentView != NULL) &&
            pParentView->IsKindOf (RUNTIME_CLASS (CAMCView)) &&
            pParentView->OnCmdMsg (nID, nCode, pExtra, pHandlerInfo))
        return (TRUE);

    // not handled
    return FALSE;
}

void COCXHostView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    DECLARE_SC(sc, TEXT("COCXHostView::OnActivateView"));

    CView::OnActivateView(bActivate,pActivateView,pDeactiveView);

    // If pActivateView and pDeactiveView are same then this app has lost
    // or gained focus without changing the active view within the app.
    // So do nothing.
    if (pActivateView == pDeactiveView)
        return;

    if (bActivate)
    {
        sc = ScFireEvent(COCXHostActivationObserver::ScOnOCXHostActivated);
        if (sc)
            sc.TraceAndClear();
    }
    else
    /*
     * If this view's no longer active, then the in-place object should
     * no longer be UI active.  This is important for the WebBrowser control
     * because if you move from one "Link to Web Address" node to another, or
     * from one taskpad to another, it won't allow tabbing to links on the
     * new hosted page if it's not deactivated and reactivated in the
     * appropriate sequence.
     */
    {
        IOleInPlaceObjectPtr spOleIPObj = GetIUnknown();

        /*
         * app hack for SQL snapin. Do not UIDeactivate the DaVinci control.
         * See bugs 175586, 175756, 193673 & 258109.
         */
        CAMCView *pAMCView = GetAMCView();
        sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
        if (sc)
            return;

        SViewData *pViewData = pAMCView->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return;

        // If DaVinci control do not UIDeactivate.
        LPCOLESTR lpszOCXClsid = pViewData->GetOCX();
        if ( (_wcsicmp(lpszOCXClsid, L"{464EE255-FDC7-11D2-9743-00105A994F8D}") == 0) ||
			 (_wcsicmp(lpszOCXClsid, L"{97240642-F896-11D0-B255-006097C68E81}") == 0) )
            return;
        /*
         * app hack for SQL snapin ends here.
         */

        if (spOleIPObj != NULL)
        {
            Trace (tagOCXActivation, _T("Deactivating in-place object"));
            spOleIPObj->UIDeactivate();
        }
        else
            Trace (tagOCXActivation, _T("No in-place object to deactivate"));
    }
}

int COCXHostView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // initialize the AxWin class just once.
    static bool bIsAxWinInitialized = false;
    if(!bIsAxWinInitialized)
    {
        AtlAxWinInit();
        bIsAxWinInitialized = true;
    }

    // get a pointer to the AMCView.
    m_pAMCView = dynamic_cast<CAMCView*>(GetParent());

    return 0;
}

LPUNKNOWN COCXHostView::GetIUnknown(void)
{
    DECLARE_SC(sc, TEXT("COCXHostView::GetIUnknown"));

    COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>((IUnknown *)m_spUnkCtrlWrapper);
    if(!pOCXCtrlWrapper)
    {
        sc = E_UNEXPECTED;
        return NULL;
    }

    IUnknownPtr spUnkCtrl;
    sc = pOCXCtrlWrapper->ScGetControl(&spUnkCtrl);
    if(sc)
        return NULL;

    return (LPUNKNOWN)spUnkCtrl;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScSetControl
 *
 * PURPOSE: Hosts the specified control in the OCX view. Delegates to one of
 *          the two other overloaded versions of this function.
 *
 * PARAMETERS:
 *    HNODE           hNode :           The node that owns the view.
 *    CResultViewType& rvt:             The result view information
 *    INodeCallback * pNodeCallback :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScSetControl(HNODE hNode, CResultViewType& rvt, INodeCallback *pNodeCallback)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScSetControl"));
    USES_CONVERSION;

    // make sure that we're trying to set up the right type of view.
    if(rvt.GetType() != MMC_VIEW_TYPE_OCX)
        return E_UNEXPECTED;

    // either BOTH rvt.IsPersistableViewDescriptionValid() and rvt.GetOCXUnknown() should be valid (the GetResultViewType2 case)
    // or     BOTH should be invalid and just GetOCX() should be valid.

    if(rvt.IsPersistableViewDescriptionValid() && (rvt.GetOCXUnknown() != NULL) )
    {
        // the GetResultViewType2 case
        sc = ScSetControl1(hNode, rvt.GetOCXUnknown(), rvt.GetOCXOptions(), pNodeCallback);
        if(sc)
            return sc;
    }
    else if(rvt.GetOCX() != NULL)
    {
        sc = ScSetControl2(hNode, rvt.GetOCX(),        rvt.GetOCXOptions(), pNodeCallback);
        if(sc)
            return sc;
    }
    else
    {
        // should never happen.
        return (sc = E_UNEXPECTED);
    }


    // must have a legal Ax Window at this point.
    sc = ScCheckPointers(GetAxWindow());
    if(sc)
        return sc;


    // the OCX should fill the entirety of the OCX host view
    CRect   rectHost;
    GetClientRect (rectHost);

    GetAxWindow()->SetWindowPos(HWND_TOP, rectHost.left, rectHost.top, rectHost.Width(), rectHost.Height(), SWP_NOACTIVATE | SWP_SHOWWINDOW);


    return sc;

}


/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScSetControl1
 *
 * PURPOSE: Hosts the control specified by pUnkCtrl in the OCX view. Takes
 *          care of caching the control
 *
 * PARAMETERS:
 *    HNODE           hNode :
 *    LPUNKNOWN       pUnkCtrl :
 *    DWORD           dwOCXOptions :
 *    INodeCallback * pNodeCallback :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScSetControl1(HNODE hNode, LPUNKNOWN pUnkCtrl, DWORD dwOCXOptions, INodeCallback *pNodeCallback)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScSetControl1"));

    // validate parameters.
    sc = ScCheckPointers((void *)hNode, pUnkCtrl, pNodeCallback);
    if(sc)
        return sc;

    CComPtr<IUnknown> spUnkCtrl;

    // 1. Hide existing window, if any.
    sc = ScHideWindow();
    if(sc)
        return sc;

    // 2. Get a cached window if one exists - NOTE that in this overload we do not look at RVTI_OCX_OPTIONS_CACHE_OCX at this point.
    sc = pNodeCallback->GetControl(hNode, pUnkCtrl, &m_spUnkCtrlWrapper);  // the overloaded form of GetControl
    if (sc)
        return sc;

    // 3. if no cached window, create one.
    if(m_spUnkCtrlWrapper == NULL) /*no cached window, create one*/
    {
        CMMCAxWindow * pWndAx = NULL;

        sc = ScCreateAxWindow(pWndAx);
        if(sc)
            return sc;

        CComPtr<IUnknown> spUnkContainer;

        // attach the container to the AxWindow
        sc = pWndAx->AttachControl(pUnkCtrl, &spUnkContainer);
        if(sc)
            return sc;


        // create a wrapper for the control
        CComObject<COCXCtrlWrapper> *pOCXCtrlWrapper = NULL;
        sc = CComObject<COCXCtrlWrapper>::CreateInstance(&pOCXCtrlWrapper);
        if(sc)
            return sc;

        spUnkCtrl = pUnkCtrl;

        // initialize the wrapper.
        // The pointer to the control and the CMMCAxWindow is now owned by the wrapper.
        sc = pOCXCtrlWrapper->ScInitialize(pWndAx, spUnkCtrl);
        if(sc)
            return sc;

        m_spUnkCtrlWrapper = pOCXCtrlWrapper; // does the addref.


        // cache only if the snapin asked us to. NOTE that this logic is different from the other version of SetControl
        if(dwOCXOptions &  RVTI_OCX_OPTIONS_CACHE_OCX)
        {
            // This is cached by the static node and used for all nodes of the snapin.
            sc = pNodeCallback->SetControl(hNode, pUnkCtrl, m_spUnkCtrlWrapper); // this call passes the wrapper
            if(sc)
                return sc;
        }

        // Do not send MMCN_INITOCX, the snapin created this control it should have initialized it.
    }
    else
    {
        // The next call sets m_spUnkCtrlWrapper, which is used to get a pointer to the Ax window.
        COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>((IUnknown *)m_spUnkCtrlWrapper);
        if(!pOCXCtrlWrapper)
            return (sc = E_UNEXPECTED); // this should never happen.

        sc = pOCXCtrlWrapper->ScGetControl(&spUnkCtrl);
        if(sc)
            return sc;

        sc = ScCheckPointers(GetAxWindow(), (LPUNKNOWN)spUnkCtrl);
        if(sc)
            return sc;

        // un-hide the window.
        GetAxWindow()->ShowWindow(SW_SHOWNORMAL);

    }


    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScSetControl2
 *
 * PURPOSE: Hosts the specified control in the OCX view. This is the
 *          OCX returned by GetResultViewType. Also takes care of
 *          caching the control if needed and sending the MMCN_INITOCX
 *          notification to snap-ins. The caching is done by hiding the
 *          OCX window and passing nodemgr a COM object that holds a pointer
 *          to the window as well as the control. The nodemgr side determines
 *          whether or not to cache the control. If the control is not
 *          cached, nodemgr merely releases the object passed to it.
 *
 * PARAMETERS:
 *    HNODE           hNode :
 *    LPCWSTR         szOCXClsid :
 *    DWORD           dwOCXOptions :
 *    INodeCallback * pNodeCallback :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScSetControl2(HNODE hNode, LPCWSTR szOCXClsid, DWORD dwOCXOptions, INodeCallback *pNodeCallback)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScSetControl2"));

    // validate parameters.
    sc = ScCheckPointers((void *)hNode, szOCXClsid, pNodeCallback);
    if(sc)
        return sc;

    // create the OCX if needed
    CLSID clsid;
    sc = CLSIDFromString (const_cast<LPWSTR>(szOCXClsid), &clsid);
    if(sc)
        return sc;

    CComPtr<IUnknown> spUnkCtrl;

    sc = ScHideWindow();
    if(sc)
        return sc;

    // check whether there is a cached control for this node.
    if (dwOCXOptions &  RVTI_OCX_OPTIONS_CACHE_OCX)
    {
        sc = pNodeCallback->GetControl(hNode, clsid, &m_spUnkCtrlWrapper);
        if (sc)
            return sc;
    }

    // nope, create a control and set this control for the node.
    if (m_spUnkCtrlWrapper == NULL)
    {
        CMMCAxWindow * pWndAx = NULL;

        sc = ScCreateAxWindow(pWndAx);
        if(sc)
            return sc;

        sc = pWndAx->CreateControlEx(szOCXClsid, NULL /*pStream*/,
                                            NULL /*ppUnkContainer*/, &spUnkCtrl);
        if(sc)
            return sc;


        // spUnkCtrl should be valid at this point.
        sc = ScCheckPointers(spUnkCtrl);
        if(sc)
            return sc;

        CComObject<COCXCtrlWrapper> *pOCXCtrlWrapper = NULL;
        sc = CComObject<COCXCtrlWrapper>::CreateInstance(&pOCXCtrlWrapper);
        if(sc)
            return sc;

        sc = ScCheckPointers(pOCXCtrlWrapper);
        if(sc)
            return sc;

        // initialize the wrapper.
        // The pointer to the control and the CMMCAxWindow is now owned by the wrapper.
        sc = pOCXCtrlWrapper->ScInitialize(pWndAx, spUnkCtrl);
        if(sc)
            return sc;

        m_spUnkCtrlWrapper = pOCXCtrlWrapper; // does the addref.

        // This is cached by the static node and used for all nodes of the snapin.
        if (dwOCXOptions &  RVTI_OCX_OPTIONS_CACHE_OCX)
        {
            sc = pNodeCallback->SetControl(hNode, clsid, m_spUnkCtrlWrapper); // this call passes the wrapper
            if(sc)
                return sc;
        }

        // send the MMCN_INITOCX notification.
        sc = pNodeCallback->InitOCX(hNode, spUnkCtrl); // this passes the actual IUnknown of the control.
        if(sc)
            return sc;
    }
    else
    {
        // The next call sets m_spUnkCtrlWrapper, which is used to get a pointer to the Ax window.
        COCXCtrlWrapper *pOCXCtrlWrapper = dynamic_cast<COCXCtrlWrapper *>((IUnknown *)m_spUnkCtrlWrapper);
        if(!pOCXCtrlWrapper)
            return (sc = E_UNEXPECTED); // this should never happen.

        sc = pOCXCtrlWrapper->ScGetControl(&spUnkCtrl);
        if(sc)
            return sc;

        sc = ScCheckPointers(GetAxWindow(), (LPUNKNOWN)spUnkCtrl);
        if(sc)
            return sc;

        // un-hide the window.
        GetAxWindow()->ShowWindow(SW_SHOWNORMAL);

    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScHideWindow
 *
 * PURPOSE: Hides the existing window, if any.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScHideWindow()
{
    DECLARE_SC(sc, TEXT("COCXCtrlWrapper::ScHideWindow"));

    // if there is an existing window, hide it.
    if(GetAxWindow())
    {
        GetAxWindow()->ShowWindow(SW_HIDE);
        m_spUnkCtrlWrapper.Release(); // this deletes the unneeded window if the reference count is zero.
    }


    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::ScCreateAxWindow
 *
 * PURPOSE: Creates a new Ax window
 *
 * PARAMETERS:
 *    PMMCAXWINDOW  pWndAx :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
COCXHostView::ScCreateAxWindow(PMMCAXWINDOW &pWndAx)
{
    DECLARE_SC(sc, TEXT("COCXHostView::ScCreateAxWindow"));

    // create a new window
    pWndAx = new CMMCAxWindow;
    if(!pWndAx)
        return (sc = E_OUTOFMEMORY);


    // create the OCX host window
	
	// BUG: 418921 always create the host window with (0,0,0,0) which is what used first time
	// as client rect is not created.
	// This fixes resize problem for some of the OCX (HP ManageX snapin).
    HWND hwndAx = pWndAx->Create(m_hWnd, (RECT&)g_rectEmpty, _T(""), (WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS) );

    if (hwndAx == NULL)
    {
        sc.FromLastError();
        return (sc);
    }

    /*
     * Bug 451981:  By default, the ATL OCX host window supports hosting
     * windowless controls.  This differs from the MMC 1.2 implementation
     * of the OCX host window (which used MFC), which did not.  Some controls
     * (e.g. Disk Defragmenter OCX) claim to support windowless instantiation
     * but do not.
     *
     * For compatibility, we must only instantiate result pane OCX's as
     * windowed controls.
     */
    CComPtr<IAxWinAmbientDispatch> spHostDispatch;
    sc = pWndAx->QueryHost(IID_IAxWinAmbientDispatch, (void**)&spHostDispatch);
    if (sc)
        sc.Clear();     // ignore this failure
    else
	{
        spHostDispatch->put_AllowWindowlessActivation (VARIANT_FALSE);  // disallow windowless activation
		SetAmbientFont (spHostDispatch);
	}

    return sc;
}


void COCXHostView::OnDestroy()
{
    CView::OnDestroy();

    if(GetAxWindow())
        GetAxWindow()->DestroyWindow();
}


/*+-------------------------------------------------------------------------*
 * COCXHostView::SetAmbientFont
 *
 * This function sets the font that any OCX that uses the DISPID_AMBIENT_FONT
 * ambient property will inherit.
 *--------------------------------------------------------------------------*/

void COCXHostView::SetAmbientFont (IAxWinAmbientDispatch* pHostDispatch)
{
	DECLARE_SC (sc, _T("COCXHostView::SetAmbientFont"));
    CComPtr<IAxWinAmbientDispatch> spHostDispatch;

	/*
	 * no host dispatch interface supplied?  get it from the AxWindow
	 */
	if (pHostDispatch == NULL)
	{
		CMMCAxWindow* pWndAx = GetAxWindow();
		if (pWndAx == NULL)
			return;

		sc = pWndAx->QueryHost(IID_IAxWinAmbientDispatch, (void**)&spHostDispatch);
		if (sc)
			return;

		pHostDispatch = spHostDispatch;
		sc = ScCheckPointers (pHostDispatch, E_UNEXPECTED);
		if (sc)
			return;
	}

	/*
	 * get the icon title font
	 */
    LOGFONT lf;
    SystemParametersInfo (SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, false);

	/*
	 * get the desktop resolution
	 */
	CWindowDC dcDesktop (CWnd::GetDesktopWindow());
	int ppi = dcDesktop.GetDeviceCaps (LOGPIXELSY);
	long lfHeight = (lf.lfHeight >= 0) ? lf.lfHeight : -lf.lfHeight;

	/*
	 * create an IFontDisp interface around the icon title font
	 */
	USES_CONVERSION;
	FONTDESC fd;
	fd.cbSizeofstruct = sizeof (fd);
	fd.lpstrName      = T2OLE (lf.lfFaceName);
	fd.sWeight        = (short) lf.lfWeight;
	fd.sCharset       = lf.lfCharSet;
	fd.fItalic        = lf.lfItalic;
	fd.fUnderline     = lf.lfUnderline;
	fd.fStrikethrough = lf.lfStrikeOut;
	fd.cySize.Lo      = lfHeight * 720000 / ppi;
	fd.cySize.Hi      = 0;

	CComPtr<IFontDisp> spFontDisp;
	sc = OleCreateFontIndirect (&fd, IID_IFontDisp, (void**) &spFontDisp);
	if (sc)
		return;

	/*
	 * set the Font property on the AxHostWindow
	 */
    pHostDispatch->put_Font (spFontDisp);
}


/*+-------------------------------------------------------------------------*
 *
 * COCXHostView::PreTranslateMessage
 *
 * PURPOSE: Sends accelerator messages to the OCX.
 *
 * PARAMETERS:
 *    MSG* pMsg :
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL
COCXHostView::PreTranslateMessage(MSG* pMsg)
{
    DECLARE_SC(sc, TEXT("COCXHostView::PreTranslateMessage"));

    if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
    {
        IOleInPlaceActiveObjectPtr spOleIPAObj = GetIUnknown();

#ifdef DBG
        TCHAR szTracePrefix[32];

        sc = StringCchPrintf(szTracePrefix, countof(szTracePrefix), _T("msg=0x%04x, vkey=0x%04x:"), pMsg->message, pMsg->wParam);
        if (sc)
            sc.TraceAndClear(); // Ignore return;
#endif

        if (spOleIPAObj != NULL)
        {
            bool fHandled = (spOleIPAObj->TranslateAccelerator(pMsg) == S_OK);
            Trace (tagOCXTranslateAccel, _T("%s %s handled"), szTracePrefix, fHandled ? _T("   ") : _T("not"));

            if (fHandled)
                return TRUE;
        }
        else
            Trace (tagOCXTranslateAccel, _T("%s not handled (no IOleInPlaceActiveObject*)"), szTracePrefix);
    }

    return BC::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\mscparser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      mscparser.h
//
//  Contents:  Header of the code to upgrade legacy (MMC1.0, MMC1.1 and 
//             MMC1.2) .msc files to the new XML format
//
//  History:   04-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------

class CConsoleFile
{
public:
    SC  ScUpgrade(LPCTSTR lpszPathName);    // upgrade the file to the latest version.

private: // conversion and other routines
    SC  ScGetFileVersion        (IStorage* pstgRoot);
    SC  ScLoadAppMode           (IStorage* pstgRoot);
    SC  ScLoadStringTable       (IStorage* pstgRoot);
    SC  ScLoadColumnSettings    (IStorage* pstgRoot);
    SC  ScLoadViewSettings      (IStorage* pstgRoot);
    SC  ScLoadViews             (IStorage* pstgRoot);
    SC  ScLoadFrame             (IStorage* pstgRoot);
    SC  ScLoadTree              (IStorage* pstgRoot);
    SC  ScLoadFavorites         (IStorage* pstgRoot);
    SC  ScLoadCustomData        (IStorage* pstgRoot);

private:
    CMasterStringTable *m_pStringTable;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\ocxview.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ocxview.h
 *
 *  Contents:  Interface file for COCXHostView
 *
 *  History:   12-Dec-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/
#if !defined(AFX_OCXVIEW_H__B320948E_731E_11D1_8033_0000F875A9CE__INCLUDED_)
#define AFX_OCXVIEW_H__B320948E_731E_11D1_8033_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ocxview.h : header file
//

#ifdef DBG
extern CTraceTag tagOCXActivation;
#endif

/////////////////////////////////////////////////////////////////////////////
// COCXHostView view

class COCXHostView : public CView,
                     public CEventSource<COCXHostActivationObserver>
{
    typedef CView BC;

public:
    COCXHostView();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(COCXHostView)

// Attributes
private:
    CAMCView *          m_pAMCView;
    IUnknownPtr         m_spUnkCtrlWrapper;

protected:
    virtual CMMCAxWindow * GetAxWindow(); // can be overridden.
    CAMCView *          GetAMCView();

// Attributes
public:
    CFont   m_font;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COCXHostView)
    protected:
    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~COCXHostView();

    void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);


    virtual LPUNKNOWN GetIUnknown();
    virtual BOOL PreTranslateMessage(MSG* pMsg);


    SC      ScSetControl(HNODE hNode, CResultViewType& rvt, INodeCallback *pNodeCallback);

private:
    SC      ScSetControl1(HNODE hNode, LPUNKNOWN pUnkCtrl, DWORD dwOCXOptions, INodeCallback *pNodeCallback);
    SC      ScSetControl2(HNODE hNode, LPCWSTR szOCXClsid, DWORD dwOCXOptions, INodeCallback *pNodeCallback);
    typedef CMMCAxWindow *PMMCAXWINDOW;

    SC      ScCreateAxWindow(PMMCAXWINDOW &pWndAx); // creates a new CMMCAxWindow
    SC      ScHideWindow();


protected:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
protected:
    //{{AFX_MSG(COCXHostView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg int  OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetAmbientFont (IAxWinAmbientDispatch* pHostDispatch);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OCXVIEW_H__B320948E_731E_11D1_8033_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\props.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      props.cpp
 *
 *  Contents:  Implementation file for console property sheet and page(s)
 *
 *  History:   05-Dec-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "props.h"
#include "mainfrm.h"
#include "amcdoc.h"
#include "pickicon.h"

//#ifdef _DEBUG
//#define new DEBUG_NEW
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#endif


/////////////////////////////////////////////////////////////////////////////
// CConsolePropSheet

IMPLEMENT_DYNAMIC(CConsolePropSheet, CPropertySheet)

CConsolePropSheet::CConsolePropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    CommonConstruct ();
}

CConsolePropSheet::CConsolePropSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    CommonConstruct ();
}

void CConsolePropSheet::CommonConstruct()
{
    DECLARE_SC(sc, TEXT("CConsolePropSheet::CommonConstruct"));

    CAMCApp *pAMCApp = AMCGetApp();
    sc = ScCheckPointers( pAMCApp, E_UNEXPECTED );
    if (sc)
        sc.TraceAndClear();

    // add the main page only for author mode
    if ( (pAMCApp != NULL) && (pAMCApp->GetMode() == eMode_Author) )
    {
        AddPage (&m_ConsolePage);
    }

    AddPage (&m_diskCleanupPage);
}


BOOL CConsolePropSheet::OnInitDialog()
{
    ModifyStyleEx(0, WS_EX_CONTEXTHELP, SWP_NOSIZE);
    return CPropertySheet::OnInitDialog();
}

CConsolePropSheet::~CConsolePropSheet()
{
}

BEGIN_MESSAGE_MAP(CConsolePropSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CConsolePropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*+-------------------------------------------------------------------------*
 * CConsolePropSheet::DoModal
 *
 *
 *--------------------------------------------------------------------------*/
INT_PTR CConsolePropSheet::DoModal()
{
	CThemeContextActivator activator;
	return CPropertySheet::DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage property page

IMPLEMENT_DYNCREATE(CConsolePropPage, CPropertyPage)

CConsolePropPage::CConsolePropPage()
    :   CPropertyPage(CConsolePropPage::IDD),
        m_pDoc (CAMCDoc::GetDocument())
{
    ASSERT        (m_pDoc != NULL);
    ASSERT_VALID  (m_pDoc);
    ASSERT_KINDOF (CAMCDoc, m_pDoc);

    m_hinstSelf               = AfxGetInstanceHandle ();
    m_fTitleChanged           = false;
    m_fIconChanged            = false;
    m_strTitle                = m_pDoc->GetCustomTitle ();
    m_nConsoleMode            = m_pDoc->GetMode ();
    m_fDontSaveChanges        = m_pDoc->IsLogicalReadOnly ();
    m_fAllowViewCustomization = m_pDoc->AllowViewCustomization ();
}

CConsolePropPage::~CConsolePropPage()
{
}

void CConsolePropPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConsolePropPage)
    DDX_Control(pDX, IDC_DONTSAVECHANGES, m_wndDontSaveChanges);
    DDX_Control(pDX, IDC_AllowViewCustomization, m_wndAllowViewCustomization);
    DDX_Control(pDX, IDC_CONSOLE_MODE_DESCRIPTION, m_wndModeDescription);
    DDX_Control(pDX, IDC_CUSTOM_TITLE, m_wndTitle);
    DDX_CBIndex(pDX, IDC_CONSOLE_MODE, m_nConsoleMode);
    DDX_Check(pDX, IDC_DONTSAVECHANGES, m_fDontSaveChanges);
    DDX_Text(pDX, IDC_CUSTOM_TITLE, m_strTitle);
    DDX_Check(pDX, IDC_AllowViewCustomization, m_fAllowViewCustomization);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConsolePropPage, CPropertyPage)
    //{{AFX_MSG_MAP(CConsolePropPage)
    ON_CBN_SELENDOK(IDC_CONSOLE_MODE, OnSelendokConsoleMode)
    ON_BN_CLICKED(IDC_DONTSAVECHANGES, OnDontSaveChanges)
    ON_BN_CLICKED(IDC_AllowViewCustomization, OnAllowViewCustomization)
    ON_BN_CLICKED(IDC_CHANGE_ICON, OnChangeIcon)
    ON_EN_CHANGE(IDC_CUSTOM_TITLE, OnChangeCustomTitle)
    //}}AFX_MSG_MAP
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage message handlers

void CConsolePropPage::OnOK()
{
    m_pDoc->SetMode (static_cast<ProgramMode>(m_nConsoleMode));
    m_pDoc->SetLogicalReadOnlyFlag (m_fDontSaveChanges);
    m_pDoc->AllowViewCustomization (m_fAllowViewCustomization);

	if (m_fIconChanged)
	{
		m_pDoc->SetCustomIcon (m_strIconFile, m_nIconIndex);
		m_fIconChanged = false;
	}

    if (m_fTitleChanged)
    {
        m_pDoc->SetCustomTitle (m_strTitle);
        m_fTitleChanged = false;
    }

    CPropertyPage::OnOK();
}

void CConsolePropPage::OnSelendokConsoleMode()
{
    SetModified ();
    UpdateData ();
    SetDescriptionText ();
    EnableDontSaveChanges ();
}

void CConsolePropPage::SetDescriptionText ()
{
    // make sure the mode index is within range
    ASSERT (IsValidProgramMode (static_cast<ProgramMode>(m_nConsoleMode)));

    m_wndModeDescription.SetWindowText (m_strDescription[m_nConsoleMode]);
}

BOOL CConsolePropPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    /*
     * make sure the string IDs are as the code expects them
     */
    ASSERT ((IDS_ModeAuthor               + 1) == IDS_ModeUserFull);
    ASSERT ((IDS_ModeUserFull             + 1) == IDS_ModeUserMDI);
    ASSERT ((IDS_ModeUserMDI              + 1) == IDS_ModeUserSDI);
    ASSERT ((IDS_ModeAuthor_Description   + 1) == IDS_ModeUserFull_Description);
    ASSERT ((IDS_ModeUserFull_Description + 1) == IDS_ModeUserMDI_Description);
    ASSERT ((IDS_ModeUserMDI_Description  + 1) == IDS_ModeUserSDI_Description);


    /*
     * load the mode names into the combo box
     */
    int i;
    CString strComboText;
    CComboBox* pCombo = reinterpret_cast<CComboBox*>(GetDlgItem (IDC_CONSOLE_MODE));
    ASSERT (pCombo != NULL);

    for (i = 0; i < eMode_Count; i++)
    {
        VERIFY (LoadString (strComboText, IDS_ModeAuthor + i));
        pCombo->AddString (strComboText);
    }

    pCombo->SetCurSel (m_nConsoleMode - eMode_Author);


    /*
     * load up the description text
     */
    ASSERT (countof (m_strDescription) == eMode_Count);

    for (i = 0; i < countof (m_strDescription); i++)
    {
        VERIFY (LoadString (m_strDescription[i], IDS_ModeAuthor_Description + i));
    }

    SetDescriptionText ();
    EnableDontSaveChanges ();


    /*
     * Get the current icon for this console file
     */
    ASSERT (m_pDoc != NULL);
    HICON hIcon = m_pDoc->GetCustomIcon (true, &m_strIconFile, &m_nIconIndex);
    m_wndIcon.SubclassDlgItem (IDC_CONSOLE_ICON, this);

    /*
     * if we haven't specified a custom icon yet, use MMC.EXE
     */
    if (hIcon == NULL)
    {
        ASSERT (m_strIconFile.IsEmpty());
        const int cchBuffer = MAX_PATH;

        GetModuleFileName (AfxGetInstanceHandle(), m_strIconFile.GetBuffer(cchBuffer), cchBuffer);
        m_strIconFile.ReleaseBuffer();
        m_nIconIndex = 0;
    }
    else
        m_wndIcon.SetIcon (hIcon);

    /*
     * Get the current title for this console file
     */
    m_wndTitle.SetWindowText (m_pDoc->GetCustomTitle());
    m_fTitleChanged = false;

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConsolePropPage::OnDontSaveChanges()
{
    SetModified ();
}

void CConsolePropPage::OnAllowViewCustomization()
{
    SetModified ();
}

void CConsolePropPage::EnableDontSaveChanges()
{
    if (m_nConsoleMode == eMode_Author)
    {
        m_wndDontSaveChanges.       EnableWindow (false);
        m_wndDontSaveChanges.       SetCheck (0);

        m_wndAllowViewCustomization.EnableWindow (false);
        m_wndAllowViewCustomization.SetCheck (1);
    }
    else
    {
        m_wndDontSaveChanges.       EnableWindow (true);
        m_wndAllowViewCustomization.EnableWindow (true);
    }
}


void CConsolePropPage::OnChangeIcon()
{
    DECLARE_SC(sc, TEXT("CConsolePropPage::OnChangeIcon"));

    int nIconIndex = m_nIconIndex;
    TCHAR szIconFile[MAX_PATH];

    sc = StringCchCopy(szIconFile, countof(szIconFile), m_strIconFile);
    if (sc)
        return;

    /*
     * show the pick 'em dialog; if something changed, enable OK/Apply
     */
    if (MMC_PickIconDlg (m_hWnd, szIconFile, countof (szIconFile), &nIconIndex) &&
        ((nIconIndex != m_nIconIndex) || (lstrcmpi (szIconFile, m_strIconFile) != 0)))
    {
        m_icon.Attach (ExtractIcon (m_hinstSelf, szIconFile, nIconIndex));

        if (m_icon != NULL)
        {
			m_fIconChanged = true;
            m_strIconFile  = szIconFile;
            m_nIconIndex   = nIconIndex;
            m_wndIcon.SetIcon (m_icon);
            SetModified();
        }
    }
}

void CConsolePropPage::OnChangeCustomTitle()
{
    m_fTitleChanged = true;
    SetModified();
}

/////////////////////////////////////////////////////////////////////////////
// CDiskCleanupPage property page

IMPLEMENT_DYNCREATE(CDiskCleanupPage, CPropertyPage)


BEGIN_MESSAGE_MAP(CDiskCleanupPage, CPropertyPage)
    ON_MMC_CONTEXT_HELP()
    ON_BN_CLICKED(IDC_DELETE_TEMP_FILES, OnDeleteTemporaryFiles)
END_MESSAGE_MAP()


CDiskCleanupPage::CDiskCleanupPage() :   CPropertyPage(CDiskCleanupPage::IDD)
{
}

CDiskCleanupPage::~CDiskCleanupPage()
{
}


BOOL CDiskCleanupPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    ScRecalculateUsedSpace();

    return TRUE;
}

/***************************************************************************\
 *
 * METHOD:  CDiskCleanupPage::OnDeleteTemporaryFiles
 *
 * PURPOSE: Invoked when "Delete Filed" button is pressed
 *          Removes all files from MMC folder storing the user data
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
void CDiskCleanupPage::OnDeleteTemporaryFiles()
{
    DECLARE_SC(sc, TEXT("CDiskCleanupPage::OnDeleteTemporaryFiles"));

    // ask user if he is sure...
    CString strConfirmMessage;
    CString strConfirmCaption;
    if (!LoadString(strConfirmMessage, IDS_ConfirmDeleteTempFiles) ||
        !LoadString(strConfirmCaption, IDR_MAINFRAME))
    {
        sc = E_UNEXPECTED;
        return;
    }

    int ans = ::MessageBox( m_hWnd, strConfirmMessage, strConfirmCaption, MB_YESNO | MB_ICONWARNING);
    if ( ans != IDYES )
        return;

    // display wait cursor while working
    CWaitCursor cursorWait;

    // get folder
    tstring strFileFolder;
    sc = CConsoleFilePersistor::ScGetUserDataFolder(strFileFolder);
    if (sc)
        return;

    // get file mask
    tstring strFileMask = strFileFolder;
    strFileMask += _T("\\*.*");

    WIN32_FIND_DATA findFileData;
    ZeroMemory( &findFileData, sizeof(findFileData) );

    // start file search
    HANDLE hFindFile = FindFirstFile( strFileMask.c_str(), &findFileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        sc.FromLastError();
        return;
    }

    // loop thru files and delete them
    bool bContinue = true;
    while ( bContinue )
    {
        tstring strFileToDelete = strFileFolder + _T('\\') + findFileData.cFileName;
        DWORD   dwFileAttributes = findFileData.dwFileAttributes;

        // get to the next file first
        bContinue = FindNextFile( hFindFile, &findFileData );

        // delete files, but not directories
        if ( 0 == (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // delete
            if ( !DeleteFile( strFileToDelete.c_str() ) )
            {
                // trace on errors (but do not stop)
                sc.FromLastError().TraceAndClear();
            }
        }
    }

    // Done, release the handle
    FindClose(hFindFile);

    sc = ScRecalculateUsedSpace();
    if (sc)
        sc.TraceAndClear();

}

/***************************************************************************\
 *
 * METHOD:  CDiskCleanupPage::ScRecalculateUsedSpace
 *
 * PURPOSE: Recalculates and displays disk space occupied by user data in this profile
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CDiskCleanupPage::ScRecalculateUsedSpace()
{
    DECLARE_SC(sc, TEXT("CDiskCleanupPage::ScRecalculateUsedSpace"));

    // display wait cursor while working
    CWaitCursor cursorWait;

    // get folder
    tstring strFileFolder;
    sc = CConsoleFilePersistor::ScGetUserDataFolder(strFileFolder);
    if (sc)
        return sc;

    // get file mask
    tstring strFileMask = strFileFolder;
    strFileMask += _T("\\*.*");

    WIN32_FIND_DATA findFileData;
    ZeroMemory( &findFileData, sizeof(findFileData) );

    // start file search
    HANDLE hFindFile = FindFirstFile( strFileMask.c_str(), &findFileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
        return sc.FromLastError();

    // loop thru files and count size
    ULARGE_INTEGER ulgOccupied = {0};
    bool bContinue = true;
    while ( bContinue )
    {
        DWORD   dwFileAttributes = findFileData.dwFileAttributes;
        if ( 0 == (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // add the high and low part separatelly, since findFileData does not have it bundled
            ulgOccupied.HighPart += findFileData.nFileSizeHigh;
            // add lower part to the whole large integer not to lose carry on overflow
            ulgOccupied.QuadPart += findFileData.nFileSizeLow;
        }

        // get to the next file first
        bContinue = FindNextFile( hFindFile, &findFileData );
    }

    // Done, release the handle
    FindClose(hFindFile);

    // now conver the size into string
    UINT nTerraBytes = (UINT)(ulgOccupied.QuadPart >> 40);
    UINT nGigaBytes =  (UINT)(ulgOccupied.QuadPart >> 30) & 0x3ff;
    UINT nMegaBytes =  ((ulgOccupied.LowPart >> 20) & 0x3ff);
    UINT nKiloBytes =  ((ulgOccupied.LowPart >> 10) & 0x3ff);
    UINT nBytes =      ( ulgOccupied.LowPart  & 0x3ff);

    CString strUnit;
    double dSize = 0.0;
    bool   bNonZeroOccupied = (ulgOccupied.QuadPart != 0);

    // display only biggest units, and never more than 999
    // instead of "1001 KB" we display "0.98 MB"
    if ( (nTerraBytes) > 0 || (nGigaBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_TB);
        dSize = (double)nTerraBytes + ((double)nGigaBytes / 1024.);
    }
    else if ( (nGigaBytes) > 0 || (nMegaBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_GB);
        dSize = (double)nGigaBytes + ((double)nMegaBytes / 1024.);
    }
    else if ( (nMegaBytes) > 0 || (nKiloBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_MB);
        dSize = (double)nMegaBytes + ((double)nKiloBytes / 1024.);
    }
    else if ( (nKiloBytes) > 0 || (nBytes > 999) )
    {
        LoadString(strUnit, IDS_FileSize_KB);
        dSize = (double)nKiloBytes + ((double)nBytes / 1024.);
    }
    else
    {
        LoadString(strUnit, IDS_FileSize_bytes);
        dSize = (double)nBytes;
    }

    // format with op to two decimal points
    CString strSize;
    strSize.Format(_T("%.2f"), dSize);

    //truncate trailing zeros
    while (strSize.Right(1) == _T("0"))
        strSize = strSize.Left(strSize.GetLength() - 1);
    //truncate trailing decimal point
    if (strSize.Right(1) == _T("."))
        strSize = strSize.Left(strSize.GetLength() - 1);

    // add units ( in locale independant way )
    strUnit.Replace(_T("%1"), strSize);

    // set to the window
    SetDlgItemText( IDC_DISKCLEANUP_OCCUPIED, strUnit );

    // enable/disable "Delete Files" button
    CWnd *pWndDeleteBtn = GetDlgItem(IDC_DELETE_TEMP_FILES);
    sc = ScCheckPointers( pWndDeleteBtn, E_UNEXPECTED );
    if (sc)
        return sc;

    pWndDeleteBtn->EnableWindow( bNonZeroOccupied );

    // if the focus went away (belonged to the window being disabled)
    // set it to the OK button
    if ( ::GetFocus() == NULL && GetParent())
    {
        GetParent()->SetFocus();
        GetParent()->SendMessage(DM_SETDEFID, IDOK);
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\props.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      props.cpp
 *
 *  Contents:  Interface file for console property sheet and page(s)
 *
 *  History:   05-Dec-97 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_PROPS_H__088693B7_6D93_11D1_802E_0000F875A9CE__INCLUDED_)
#define AFX_PROPS_H__088693B7_6D93_11D1_802E_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// props.h : header file
//

#include "amc.h"    // for CAMCApp::ProgramMode
#include "smarticon.h"

class CMainFrame;
class CAMCDoc;
class CConsolePropSheet;


/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage dialog

class CConsolePropPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CConsolePropPage)

// Construction
public:
    CConsolePropPage();
    ~CConsolePropPage();

// Dialog Data
    //{{AFX_DATA(CConsolePropPage)
	enum { IDD = IDD_PROPPAGE_CONSOLE };
    CButton m_wndDontSaveChanges;
    CButton m_wndAllowViewCustomization;
    CStatic m_wndModeDescription;
    CEdit   m_wndTitle;
    CStatic m_wndIcon;
    int     m_nConsoleMode;
    BOOL    m_fDontSaveChanges;
    CString m_strTitle;
    BOOL    m_fAllowViewCustomization;
	//}}AFX_DATA

private:
    HINSTANCE           m_hinstSelf;
	CSmartIcon			m_icon;
    CString             m_strIconFile;
    int                 m_nIconIndex;
    bool                m_fTitleChanged;
    bool                m_fIconChanged;

    CAMCDoc* const m_pDoc;
    CString m_strDescription[eMode_Count];

    void SetDescriptionText ();
    void EnableDontSaveChanges();

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CConsolePropPage)
    public:
    virtual void OnOK();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CConsolePropPage)
    afx_msg void OnSelendokConsoleMode();
    virtual BOOL OnInitDialog();
    afx_msg void OnDontSaveChanges();
    afx_msg void OnAllowViewCustomization();
    afx_msg void OnChangeIcon();
    afx_msg void OnChangeCustomTitle();
	//}}AFX_MSG

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_PROPPAGE_CONSOLE);

    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CConsolePropPage dialog

class CDiskCleanupPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CDiskCleanupPage)

// Construction
public:
    CDiskCleanupPage();
    ~CDiskCleanupPage();

// Dialog Data
	enum { IDD = IDD_DISK_CLEANUP};

    virtual BOOL OnInitDialog();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_PROPPAGE_DISK_CLEANUP);

    // Generated message map functions
protected:
    //{{AFX_MSG(CDiskCleanupPage)
    afx_msg void OnDeleteTemporaryFiles();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
private:
    SC   ScRecalculateUsedSpace();
};



/////////////////////////////////////////////////////////////////////////////
// CConsolePropSheet

class CConsolePropSheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CConsolePropSheet)

// Construction
public:
    CConsolePropSheet(UINT nIDCaption = IDS_CONSOLE_PROPERTIES, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CConsolePropSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

private:
    void CommonConstruct();

// Attributes
public:
    CConsolePropPage    m_ConsolePage;
    CDiskCleanupPage    m_diskCleanupPage;

// Operations
public:
    void SetTitle (LPCTSTR pszTitle);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConsolePropSheet)
	public:
	virtual INT_PTR DoModal();
	//}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CConsolePropSheet();

    // Generated message map functions
protected:
    //{{AFX_MSG(CConsolePropSheet)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPS_H__088693B7_6D93_11D1_802E_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\scriptevents.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      scriptevents.cpp
//
//  Contents:  Implementation of script events thru connection points
//
//  History:   11-Feb-99 AudriusZ    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "scriptevents.h"

// Traces
#ifdef DBG
    CTraceTag  tagComEvents(_T("Events"), _T("COM events"));
#endif


/***************************************************************************\
 *
 * METHOD:  CEventDispatcherBase::SetContainer
 *
 * PURPOSE: Accesory function. Sets Connection point container 
 *          to be used for getting the sinks
 *
 * PARAMETERS:
 *    LPUNKNOWN pComObject - pointer to COM object - event source (NULL is OK)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CEventDispatcherBase::SetContainer(LPUNKNOWN pComObject)
{
    // It makes difference to us if the object pointer is NULL
    // (that means there are no com object , and that's OK)
    // Or QI for IConnectionPointContainer will fail
    // (that means an error)
    m_bEventSourceExists = !(pComObject == NULL);
    if (!m_bEventSourceExists)
        return;

    // note it's not guaranteed here m_spContainer won't be NULL
    m_spContainer = pComObject;
}

/***************************************************************************\
 *
 * METHOD:  CEventDispatcherBase::ScInvokeOnConnections
 *
 * PURPOSE: This method will iterate thu sinks and invoke
 *          same method on each ot them
 *
 * PARAMETERS:
 *    REFIID riid           - GUID of disp interface
 *    DISPID dispid         - disp id
 *    CComVariant *pVar     - array of parameters (may be NULL)
 *    int count             - count of items in pVar
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventDispatcherBase::ScInvokeOnConnections(REFIID riid, DISPID dispid, CComVariant *pVar, int count, CEventBuffer& buffer) const
{
    DECLARE_SC(sc, TEXT("CEventDispatcherBase::ScInvokeOnConnections"));

    // the pointer to event source passed is NULL,
    // that means there is no event source - and no event sinks connected
    // thus we are done at this point
    if (!m_bEventSourceExists)
        return sc;

    // check if com object supports IConnectionPointContainer;
    // Bad pointer ( or to bad object ) if it does not
    sc = ScCheckPointers(m_spContainer, E_NOINTERFACE);
    if (sc)
        return sc;

    // get connection point
    IConnectionPointPtr spConnectionPoint;
    sc = m_spContainer->FindConnectionPoint(riid, &spConnectionPoint);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spConnectionPoint, E_UNEXPECTED);
    if (sc)
        return sc;

    // get connections
    IEnumConnectionsPtr spEnumConnections;
    sc = spConnectionPoint->EnumConnections(&spEnumConnections);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spEnumConnections, E_UNEXPECTED);
    if (sc)
        return sc;

    // reset iterator
    sc = spEnumConnections->Reset();
    if (sc)
        return sc;

    // iterate thru sinks until Next returns S_FALSE.
    CONNECTDATA connectdata;
    SC sc_last_error;
    while (1) // will use <break> to exit
    {
        // get the next sink
        ZeroMemory(&connectdata, sizeof(connectdata));
        sc = spEnumConnections->Next( 1, &connectdata, NULL );
        if (sc)
            return sc;

        // done if no more sinks
        if (sc == SC(S_FALSE))
            break;

        // recheck the pointer
        sc = ScCheckPointers(connectdata.pUnk, E_UNEXPECTED);
        if (sc)
            return sc;

        // QI for IDispatch
        IDispatchPtr spDispatch = connectdata.pUnk;
        connectdata.pUnk->Release();

        // recheck the pointer
        sc = ScCheckPointers(spDispatch, E_UNEXPECTED);
        if (sc)
            return sc;

        // if events are locked by now, we need to postpone the call
        // else - emit it
        sc = buffer.ScEmitOrPostpone(spDispatch, dispid, pVar, count);
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
        }
    }
    
    // we succeeded, but sinks may not,
    // report the error (if one happened)
    return sc_last_error;
}


/***************************************************************************\
 *
 * METHOD:  CEventDispatcherBase::ScHaveSinksRegisteredForInterface
 *
 * PURPOSE: Checks if there are any sinks registered with interface
 *          Function allows perform early check to skip com object creation
 *          fo event parameters if event will go nowere anyway
 *
 * PARAMETERS:
 *    const REFIID riid - interface id
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventDispatcherBase::ScHaveSinksRegisteredForInterface(const REFIID riid)
{
    DECLARE_SC(sc, TEXT("CEventDispatcherBase::ScHaveSinksRegisteredForInterface"));

    // the pointer to event source passed is NULL,
    // that means there is no event source - and no event sinks connected
    if (!m_bEventSourceExists)
        return sc = S_FALSE;

    // check if com object supports IConnectionPointContainer;
    // Bad pointer ( or to bad object ) if it does not
    sc = ScCheckPointers(m_spContainer, E_NOINTERFACE);
    if (sc)
        return sc;

    // get connection point
    IConnectionPointPtr spConnectionPoint;
    sc = m_spContainer->FindConnectionPoint(riid, &spConnectionPoint);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spConnectionPoint, E_UNEXPECTED);
    if (sc)
        return sc;

    // get connections
    IEnumConnectionsPtr spEnumConnections;
    sc = spConnectionPoint->EnumConnections(&spEnumConnections);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(spEnumConnections, E_UNEXPECTED);
    if (sc)
        return sc;

    // reset iterator
    sc = spEnumConnections->Reset();
    if (sc)
        return sc;

    // get first member. Will return S_FALSE if no items in collection
    CONNECTDATA connectdata;
    ZeroMemory(&connectdata, sizeof(connectdata));
    sc = spEnumConnections->Next( 1, &connectdata, NULL );
    if (sc)
        return sc;

    // release the data
    if (connectdata.pUnk)
        connectdata.pUnk->Release();

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by amc.rc
//
#include "mmcres.h"

#include <ntverp.h>
#include <winver.h>
#include <dlgs.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Microsoft Management Console"
#define VER_INTERNALNAME_STR            "mmc.exe"
#define VER_ORIGINALFILENAME_STR        "mmc.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\scriptevents.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      scriptevents.h
//
//  Contents:  Implementation of script events thru connection points
//
//  History:   11-Feb-99 AudriusZ    Created
//
//--------------------------------------------------------------------------

/*
    This file provides means to implement connection-point based events with 
    the ability to fire them to running scripts. That is an alternative to 
    wizard-based implementation provided by ATL.

IDEA

    The idea behind this implementation is to create the class that 
    implements the methods from the event interface. Each such method will 
    have a string literal equivalent to method name. Whenever such a method 
    is called, it will use that string literal to find the dispatch ID of 
    the interface method and will use it to forward the call to event sinks.

    The special measures need to be taken to assure correct mapping of methods,
    proper parameter types and count. The provided implementation puts these 
    tasks on the compiler, since it's more accurate than the human. Deriving 
    the class from the event interface implemented assures it. To implement 
    method mapping the class uses CComTypeInfoHolder defined in ATL
    to do the actual mapping.

    The benefits come with a price - the event interface needs to be dual 
    (while the scripts require it to be dispinterface only) - that requires 
    defining 2 interfaces in IDL. Mapping also means slightly increased method 
    call time.

REQUIREMENTS / USAGE

    1.	You need to define hidden dual interface (with the name constructed by prepending
        underscore to the name of dispinterface) in the IDL file, like this:

        [ 
            uuid(YYYYYYYYYYY), dual, helpstring("")
        ]
        interface _DocEvents : IDispatch
        {
            [id(1), helpstring("Occurs when a document is initialized")]
            HRESULT OnInitialize( [in] PDOCUMENT pDocument);
            [id(2), helpstring("Occurs when a document is destroyed")]
            HRESULT OnDestroy( [in] PDOCUMENT pDocument);
        };

    2.	You need to define the dispinterface to be used as event source, like 
        this:

        [ 
            uuid(XXXXXXXXXXX) ,   helpstring("DocEvents Interface")
        ]
        dispinterface DocEvents
        {
    	    interface _DocEvents;
        };

    3.	Your com object needs to derive from IConnectionPointContainerImpl and 
        define CONNECTION_POINT_MAP.

    4.	You need to provide the specialization of the event proxy, mapping all 
        the methods from the event interface, like this:

        DISPATCH_CALL_MAP_BEGIN(DocEvents)
            DISPATCH_CALL1( OnInitialize,  PDOCUMENT )
            DISPATCH_CALL1( OnDestroy,     PDOCUMENT )
        DISPATCH_CALL_MAP_END()

        Note: this must be defined at global scope (probably *.h file) and visible
              from wherever ScFireComEvent is executed.

    5.	(optional) If any of the parameters in the event interface refers to 
        coclass in IDL, you need to map (cast) the types to the interface 
        pointer inside the proxy, like this:

        DISPATCH_CALL_MAP_BEGIN(DocEvents)
            DISPATCH_PARAM_CAST ( PDOCUMENT, IDispatch * );
            DISPATCH_CALL1( OnInitialize,  PDOCUMENT )
            DISPATCH_CALL1( OnDestroy,     PDOCUMENT )
        DISPATCH_CALL_MAP_END()

    6.	where needed you may fire the evens like this:

    sc = ScFireComEvent(m_sp_Document, DocEvents , OnDestroy(pDocument));

    7.  to avoid creating com objects (parameters to events) when there is no one
        interested in receiving them use ScHasSinks macro:

    sc = ScHasSinks(m_sp_Document, DocEvents);
    if (sc == SC(S_OK))
    {
        // create com objects and fire the event
    }


COMPARISON                      this                    ATL

    Manual changes              yes                     semi

    Dual interface              required                not required

    Call to method 1st time     Maps the name           direct

    Type library                required at runtime     only to generate

    After method is added       require to add          Require to regenerate
                                the method to proxy     proxy file

    After disp ID is changed    no changes              Require to regen.

    Compiling changed IDL       Won't compile if proxy  Fail on runtime
                                doesn't fit interface

    fire                        from anywhere           from proxy only

    coclass param casting       provides                not support

USED CLASS HIERARCHY

    CEventDispatcherBase                [ type-invariant stuff]
        /\
        ||
    CEventDispatcher<_dual_interface>   [ interface type parametrized stuff]
        /\
        ||
    CEventProxy<_dispinterface>         [ client provided call map defines this]
        /\
        ||
    CScriptEvent<_dispinterface>        [ this one gets instantiated by ScFireComEvent ]

*/

#include "eventlock.h"

/***************************************************************************\
 *
 * CLASS:  CEventDispatcherBase
 *
 * PURPOSE: base class for CEventDispatcher template
 *          implements functionality not dependant on template parameters
 *
\***************************************************************************/
class CEventDispatcherBase
{
protected:
    // c-tor
    CEventDispatcherBase() : m_bEventSourceExists(false) {}

    // Parameter cast template
    // Provided to allow parameter casting for parameters of specified types
    // in proxy using DISPATCH_PARAM_CAST macro.
    // Default (specified here) casts every type to itself
    template <typename _param_type> 
    struct ParamCast 
    { 
        typedef _param_type PT; 
    };
            
    // Parameter cast function (see comment above)
    template <typename _param_type>
    inline typename ParamCast<_param_type>::PT& CastParam(_param_type& arg) const
    { 
        return reinterpret_cast<ParamCast<_param_type>::PT&>(arg); 
    }

    // sets connection point container to be used to forward events
    void SetContainer(LPUNKNOWN pComObject);
    // forward the call using IDispatch of event sinks
    SC   ScInvokeOnConnections(const REFIID riid, DISPID dispid, CComVariant *pVar, int count, CEventBuffer& buffer) const;

    // returns S_FALSE if no sinks are registered with the object.
    SC   ScHaveSinksRegisteredForInterface(const REFIID riid);

private:
    // there are two options: com object does not exist (that's ok)
    // and it does not implement container (error)
    // we have 2 variables to deal with both situations
    bool                         m_bEventSourceExists;
    IConnectionPointContainerPtr m_spContainer;
};


/***************************************************************************\
 *
 * CLASS:  CEventDispatcher
 *
 * PURPOSE: Fully equipped call dispather
 *          Main functionality of it is to implement ScMapMethodToID
 *          and ScInvokeOnConnections - two functions required to call
 *          method by name thru IDispatch::Invoke()
 *          They are use by DISPATCH_CALL# macros
 *
\***************************************************************************/
template <typename _dual_interface>
class CEventDispatcher : public CEventDispatcherBase 
{
protected:
    typedef _dual_interface DualIntf;
    // Maps method name to dispId; Employs CComTypeInfoHolder to do the job
    SC ScMapMethodToID(LPCWSTR strMethod, DISPID& dispid)
    {
        DECLARE_SC(sc, TEXT("ScMapMethodToID"));

        // this cast is needed just because of bad parameter type defined in GetIDsOfNames
        LPOLESTR strName = const_cast<LPOLESTR>(strMethod);
        // rely on CComTypeInfoHolder to do it
        sc = m_TypeInfo.GetIDsOfNames( IID_NULL, &strName, 1, LOCALE_NEUTRAL, &dispid );
        if (sc)
            return sc;
    
        return sc;
    }

private:
    // be aware - this member depents on template parameter
    static CComTypeInfoHolder m_TypeInfo;
};

/***************************************************************************\
 *
 * CEventDispatcher static member initialization
 *
\***************************************************************************/

const WORD wVersionMajor = 1;
const WORD wVersionMinor = 0;

template <typename _dual_interface>
CComTypeInfoHolder CEventDispatcher<_dual_interface>::m_TypeInfo =
{ &__uuidof(_dual_interface), &LIBID_MMC20, wVersionMajor, wVersionMinor, NULL, 0, NULL, 0 };

/***************************************************************************\
 *
 * CLASS:  CEventProxy
 *
 * PURPOSE: Every event interface should have specialization of this class,
 *          describing mapped (dual interface - to - dispinterface) methods.
 *          Here it is just declared - not defined.
 *
\***************************************************************************/
template <typename _dispinterface> class CEventProxy;

/***************************************************************************\
 *
 * CLASS:  CScriptEvent
 *
 * PURPOSE: The object that will be constructed to fire actual event.
 *          It is provided solely to do initialization by constuctor,
 *          coz that allowes us to use single unnamed object in the single
 *          statement to both construct it and invoke a method on it.
 *
\***************************************************************************/
template <typename _dispinterface>
class CScriptEvent: public CEventProxy<_dispinterface>
{
public:
    CScriptEvent(LPUNKNOWN pComObject)
    {
        SetContainer(pComObject);
    }
    // returns S_FALSE if no sinks are registered with the object.
    SC  ScHaveSinksRegistered() 
    { 
        return ScHaveSinksRegisteredForInterface(__uuidof(_dispinterface)); 
    }
};


/***************************************************************************\
 *
 *  MACROS USED TO IMPLEMENT EVENT PROXY
 *
\***************************************************************************/

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_MAP_BEGIN
 *
 * defines the begining of the call map.
 * NOTE : assumes that dual interface has the same name as the dispinterface 
 *        with single '_' prepended
\***************************************************************************/
#define  DISPATCH_CALL_MAP_BEGIN(_dispinterface)        \
    template<> class CEventProxy<_dispinterface> : public CEventDispatcher<_##_dispinterface> {

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_MAP_END
 *
 * defines the end of the call map.
\***************************************************************************/
#define  DISPATCH_CALL_MAP_END()  };

/***************************************************************************\
 *
 * MACRO:  DISPATCH_PARAM_CAST
 *
 * defines type mapping to be used prior to IDispatch::Invoke
 * It is provided to deal with objects defined as coclass
 * in IDL file, which cannot implecitly be converted to any interface.
 * ( if we do not change it CComVariant will treat it as bool type )
 *
\***************************************************************************/
#define DISPATCH_PARAM_CAST(from,to) \
    public: template <> struct CEventDispatcherBase::ParamCast<from> { typedef to PT; }

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_PROLOG
 *
 * used as first part of every DISPATCH_CALL# macro
 *
\***************************************************************************/
#define  DISPATCH_CALL_PROLOG(_method, _param_list)                                     \
    /* Implement pure method to be able to instantiate the class */                     \
    /* it should not be used - so it's declared private          */                     \
    private: STDMETHOD(_method) _param_list                                             \
    {                                                                                   \
    /* retrieving the pointer to base won't compile if method is */                     \
    /* removed from the interface (that's what we want to catch) */                     \
        HRESULT (STDMETHODCALLTYPE DualIntf::*pm)_param_list = DualIntf::_method;       \
        return E_NOTIMPL;                                                               \
    }                                                                                   \
    /* Implement invocation in Sc* method used by SC_FIRE* macro */                     \
    /* _param_list represents parameter list with brackets       */                     \
    public: SC Sc##_method _param_list {                                                \
    DECLARE_SC(sc, TEXT("DISPATCH_CALL::Sc") TEXT(#_method));                           \
    /* following lines gets dispid on the first call only.       */                     \
    /* succeeding calls will reuse it or error from the 1st call */                     \
    static DISPID dispid = 0;                                                           \
    static SC sc_map = ScMapMethodToID(L#_method, dispid);                              \
    if (sc_map) return sc = sc_map; 

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL_EPILOG
 *
 * used as last part of every DISPATCH_CALL# macro
 *
\***************************************************************************/
#define  DISPATCH_CALL_EPILOG(_dispinterface, _pvar, _count)                            \
    /* Get the proper event buffer for locked scenarios         */                      \
    CEventBuffer& buffer = GetEventBuffer();											\
    /* just invoke the method on the sinks                       */                     \
    return sc = ScInvokeOnConnections(__uuidof(_dispinterface), dispid, _pvar, _count, buffer); } 

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL0
 *
 * used to map an event interface method with 0 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL0(_dispinterface, _method)                                        \
    DISPATCH_CALL_PROLOG(_method, ())                                                   \
    DISPATCH_CALL_EPILOG(_dispinterface, NULL, 0)

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL1
 *
 * used to map an event interface method with 1 parameter
 *
\***************************************************************************/
#define  DISPATCH_CALL1(_dispinterface, _method,  P1)                                   \
    DISPATCH_CALL_PROLOG(_method, (P1 param1))                                          \
    CComVariant var[] = { CastParam(param1) };                                          \
    DISPATCH_CALL_EPILOG(_dispinterface, var, countof(var))

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL2
 *
 * used to map an event interface method with 2 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL2(_dispinterface, _method,  P1, P2)                               \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2))                               \
    CComVariant var[] = { CastParam(param2), CastParam(param1) };                       \
    DISPATCH_CALL_EPILOG(_dispinterface, var, countof(var))

/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL3
 *
 * used to map an event interface method with 3 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL3(_dispinterface, _method,  P1, P2, P3)                           \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2, P3 param3))                    \
    CComVariant var[] = { CastParam(param3), CastParam(param2), CastParam(param1) };    \
    DISPATCH_CALL_EPILOG(_dispinterface, var, countof(var))


/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL4
 *
 * used to map an event interface method with 4 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL4(_dispinterface, _method,  P1, P2, P3, P4)                           \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2, P3 param3, P4 param4))             \
    CComVariant var[] = { CastParam(param4), CastParam(param3), CastParam(param2), CastParam(param1) };    \
    DISPATCH_CALL_EPILOG(_dispinterface, var, countof(var))


/***************************************************************************\
 *
 * MACRO:  DISPATCH_CALL5
 *
 * used to map an event interface method with 5 parameters
 *
\***************************************************************************/
#define  DISPATCH_CALL5(_dispinterface, _method,  P1, P2, P3, P4, P5)                                  \
    DISPATCH_CALL_PROLOG(_method, (P1 param1, P2 param2, P3 param3, P4 param4, P5 param5))             \
    CComVariant var[] = { CastParam(param5), CastParam(param4), CastParam(param3), CastParam(param2), CastParam(param1) };    \
    DISPATCH_CALL_EPILOG(_dispinterface, var, countof(var))


/***************************************************************************\
 *
 * MACRO:  ScFireComEvent
 *
 * used to fire script event. Note that _p_com_object may be NULL
 *
\***************************************************************************/
#ifdef DBG
extern CTraceTag  tagComEvents;
#endif

#define ScFireComEvent(_p_com_object, _dispinterface, _function_call)             \
    CScriptEvent<_dispinterface>(_p_com_object).Sc##_function_call;               \
    Trace(tagComEvents, _T(#_function_call));

/***************************************************************************\
 *
 * MACRO:  ScHasSinks
 *
 * used to determine if there are sinks connected 
 * ( to avoid creating com object when ScFireComEvent would result in no calls )
 *
\***************************************************************************/
#define ScHasSinks(_p_com_object, _dispinterface)                                    \
    ((_p_com_object) == NULL) ? SC(S_FALSE) : \
                                CScriptEvent<_dispinterface>(_p_com_object).ScHaveSinksRegistered();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF


MAJORCOMP=MMC
MINORCOMP=conui

TARGETNAME=mmc
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=windows


WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

USE_VCCOM      = 1
USE_STL        = 1
USE_STATIC_ATL = 1
ATL_VER        = 30
USE_WTL        = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
SXS_ASSEMBLY_NAME                 = Microsoft.Windows.MMC
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT = 1
SXS_MANIFEST                      = mmc.manifest
SXS_MANIFEST_IN_RESOURCES         = 1
SXS_NO_BINPLACE                   = 1
SXS_MANIFEST_RESOURCE_ID          = ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID

C_DEFINES = $(C_DEFINES) -DISOLATION_AWARE_ENABLED
C_DEFINES = $(C_DEFINES) -DSXS_MANIFEST_RESOURCE_ID=$(SXS_MANIFEST_RESOURCE_ID)

#
# Shfusion.lib causes linker warnings. Ignore them.
#
LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217

!if $(FREEBUILD)
# on retail builds we don't want to stack fault, so we reserve 80k of stack
LINKER_STACKCOMMITSIZE = 81200
!else
# on chk builds, we default to 80k (we can reduce this to find stack pigs and elimnate them).
LINKER_STACKCOMMITSIZE = 81200
!endif

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
   $(SDK_LIB_PATH)\mmc.lib					\
   ..\..\core\$(CharWidth)\$(O)\uicore.lib	\
   ..\..\base\$(CharWidth)\$(O)\mmcbase.lib

# We need $(SHELL_LIB_PATH)\shlwapip.lib for ualstr*
TARGETLIBS = \
   $(SDK_LIB_PATH)\kernel32.lib 	\
   $(SDK_LIB_PATH)\user32.lib   	\
   $(SDK_LIB_PATH)\oleaut32.lib 	\
   $(SDK_LIB_PATH)\ole32.lib    	\
   $(SDK_LIB_PATH)\oleacc.lib   	\
   $(SDK_LIB_PATH)\advapi32.lib 	\
   $(SDK_LIB_PATH)\uuid.lib     	\
   $(SDK_LIB_PATH)\comdlg32.lib 	\
   $(SDK_LIB_PATH)\HtmlHelp.lib 	\
   $(SDK_LIB_PATH)\shell32.lib		\
   $(SHELL_LIB_PATH)\shlwapip.lib	\
   $(SHELL_LIB_PATH)\shfusion.lib	\


!if exist (..\..\PrivateBranch.inc)
!include   ..\..\PrivateBranch.inc
!endif

!ifndef __PublishedDir
__PublishedDir = mmc
!endif

TLBDir = $(PROJECT_ROOT)\published\$(__PublishedDir)\$(O)

# We need $(SHELL_INC_PATH) for uastrfnc.h
# We need $(BASE_INC_PATH) for wow64t.h
INCLUDES = \
	..\;					\
	..\..\base;				\
	..\..\inc;              \
	..\..\types\idl\$(O);   \
	$(TLBDir);				\
	$(SHELL_INC_PATH);		\
	$(BASE_INC_PATH);		\

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX =     1

# This target is required so $(O)\amc.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$(O)\amc.res: \
	..\..\types\idl\$(O)\websnk.tlb	\
	$(TLBDir)\mmcobj.tlb        	\
	..\html\glyph100.eot        	\
	..\html\glyph110.eot        	\
	..\html\break.htm           	\
	..\html\default.htm         	\
	..\html\error.htm           	\
	..\html\horiz.htm           	\
	..\html\listpad.htm         	\
	..\html\reload.htm          	\
	..\html\reload2.htm         	\
	..\html\reload3.htm         	\
	..\res\commontb.bmp         	\
	..\res\commontb_rtl.bmp        	\
	..\res\hand.cur             	\
	..\res\mmc.ico              	\
	..\res\mmc.ico              	\
	..\res\nodes16.bmp          	\
	..\res\nodes32.bmp          	\
	..\res\sort.bmp					\

SOURCES = \
	..\amc.rc               		\
	..\amc.cpp              		\
	..\amcdoc.cpp           		\
	..\amcdocmg.cpp         		\
	..\amcview.cpp          		\
	..\archpicker.cpp       		\
	..\caption.cpp          		\
	..\cclvctl.cpp          		\
	..\childfrm.cpp         		\
	..\controls.cpp         		\
	..\dd.cpp               		\
	..\docksite.cpp         		\
	..\evtsink.cpp          		\
	..\favorite.cpp         		\
	..\favui.cpp            		\
	..\filedlgex.cpp            	\
	..\fontlink.cpp         		\
	..\ftab.cpp             		\
	..\histlist.cpp         		\
	..\idle.cpp             		\
	..\kbdnav.cpp					\
	..\mainfrm.cpp          		\
	..\mdiclint.cpp         		\
	..\mdiuisim.cpp         		\
	..\menubar.cpp          		\
	..\menubtns.cpp         		\
	..\mmcaxwin.cpp         		\
	..\mscparser.cpp        		\
	..\ocxview.cpp          		\
	..\props.cpp            		\
	..\scripthost.cpp       		\
	..\scriptevents.cpp     		\
	..\statbar.cpp          		\
	..\stdbar.cpp           		\
	..\stringutil.cpp       		\
	..\strtable.cpp         		\
	..\subclass.cpp         		\
	..\svfildlg.cpp         		\
	..\sysmenu.cpp          		\
	..\taskhost.cpp         		\
	..\tbtrack.cpp          		\
	..\toolbar.cpp          		\
	..\treectrl.cpp         		\
	..\trobimpl.cpp         		\
	..\vwtrack.cpp          		\
	..\webctrl.cpp          		\
	..\wrapper.cpp					\




MISCFILES = \
        ..\Microsoft_Management_Console_(MMC)_{386FE156-EDEB-4687-9AF0-7B24E6DE4EA4}.sld
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\scripthost.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ScriptHost.h
//
//              Script Hosting implementation.
//
//--------------------------------------------------------------------------
#ifndef SCRIPTHOST_H
#define SCRIPTHOST_H
#include "activscp.h"
#include "tstring.h"

#define  SCRIPT_ENGINE_KEY   _T("ScriptEngine")
#define  CLSIDSTR            _T("CLSID")

class CScriptHost;

//+-------------------------------------------------------------------
//
//  class:     CScriptHostMgr
//
//  Purpose:   Manages all the script hosts (CScriptHost). Owned by
//             CAMCApp which calls ScExecuteScript.
//
//  History:   11-05-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CScriptHostMgr
{
public:
    CScriptHostMgr(LPDISPATCH pDispatch);
    ~CScriptHostMgr();

public:
    // Accessors.
    SC ScGetMMCObject(LPUNKNOWN *ppunkItem);
    SC ScGetMMCTypeInfo(LPTYPEINFO *ppTypeInfo);

    // Members to run a script.
    SC ScExecuteScript(const tstring& strFileName);
    SC ScExecuteScript(LPOLESTR pszScriptText, const tstring& strExtn);

private:
    SC ScLoadScriptFromFile (const tstring& strFileName, LPOLESTR* pszScriptText);
    SC ScDestroyScriptHosts();
    SC ScGetScriptEngine(const tstring& strFileName, tstring& strScriptEngine, CLSID& rClsidEngine);
    SC ScGetScriptEngineFromExtn(const tstring& strFileExtn, tstring& strScriptEngine, CLSID& rClsidEngine);
    SC ScExecuteScriptHelper(LPCOLESTR pszScriptText, const tstring strScriptEngine, const CLSID& EngineClsid);

private:
    typedef std::map<tstring, tstring> ScriptExtnToScriptEngineNameMap;
    ScriptExtnToScriptEngineNameMap    m_ScriptExtnToScriptEngineNameMap;

    typedef std::map<tstring, CLSID>   ScriptExtnToScriptEngineMap;
    ScriptExtnToScriptEngineMap        m_ScriptExtnToScriptEngineMap;

    typedef std::vector<IUnknownPtr>   ArrayOfScriptHosts;
    ArrayOfScriptHosts                 m_ArrayOfHosts;

    IDispatchPtr                       m_spMMCObjectDispatch;
    ITypeInfoPtr                       m_spMMCObjectTypeInfo;
};

//+-------------------------------------------------------------------
//
//  class:     CScriptHost
//
//  Purpose:   Script Host (executes a single script).
//
//  History:   11-05-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CScriptHost : public CComObjectRoot,
                    public IActiveScriptSite,
                    public IActiveScriptSiteWindow
{
private:
    CScriptHost(const CScriptHost&);

public:
    CScriptHost();
    ~CScriptHost();

public:
// ATL COM map
BEGIN_COM_MAP(CScriptHost)
    COM_INTERFACE_ENTRY(IActiveScriptSite)
    COM_INTERFACE_ENTRY(IActiveScriptSiteWindow)
END_COM_MAP()

    SC ScRunScript(CScriptHostMgr* pMgr, LPCOLESTR pszScriptText,
                   const tstring& strScriptEngine, const CLSID& rEngineClsid);

    SC ScStopScript();

    // IActiveScriptSite methods.
   STDMETHOD(GetLCID)            ( LCID *plcid);
   STDMETHOD(GetItemInfo)        ( LPCOLESTR pstrName, DWORD dwReturnMask,
                                   IUnknown **ppunkItem, ITypeInfo **ppTypeInfo);
   STDMETHOD(GetDocVersionString)( BSTR *pbstrVersionString);
   STDMETHOD(OnScriptTerminate)  ( const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo);
   STDMETHOD(OnStateChange)      (SCRIPTSTATE ssScriptState);
   STDMETHOD(OnScriptError)      (IActiveScriptError *pase);
   STDMETHOD(OnEnterScript)      (void);
   STDMETHOD(OnLeaveScript)      (void);

   // IActiveScriptSiteWindow methods.
   STDMETHOD(GetWindow)          (HWND *phwnd);
   STDMETHOD(EnableModeless)     (BOOL fEnable);

private:
    tstring               m_strScriptEngine;
    CLSID                 m_EngineClsid;
    CScriptHostMgr*       m_pScriptHostMgr;

    IActiveScriptPtr      m_spActiveScriptEngine;
    IActiveScriptParsePtr m_spActiveScriptParser;
};

#endif SCRIPTHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\scripthost.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ScriptHost.cpp
//
//  Contents:   CScriptHostMgr & CScriptHost implementation.
//
//  History:    11/05/1999   AnandhaG   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "scripthost.h"

//+-------------------------------------------------------------------
// MMCObjectName is the name scripts will use to refer to mmc object.
//
// Example:
//
// Dim doc
// Dim snapins
// Set doc     = MMCApplication.Document
// Set snapins = doc.snapins
// snapins.Add "{58221c66-ea27-11cf-adcf-00aa00a80033}" ' the services snap-in
//
//+-------------------------------------------------------------------

const LPOLESTR MMCObjectName = OLESTR("MMCApplication");

//+-------------------------------------------------------------------
//
//  Member:      CScriptHostMgr::ScInitScriptHostMgr
//
//  Synopsis:    Get the ITypeInfo of this instance of mmc.
//
//  Arguments:   [pDispatch]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
CScriptHostMgr::CScriptHostMgr(LPDISPATCH pDispatch)
{
    m_spMMCObjectDispatch = pDispatch;

    // It is ok if below fails. These interfaces (dispatch & typeinfo) are required
    // in CScriptHost::GetItemInfo method, so that this object can be given to engine.
    pDispatch->GetTypeInfo(1, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), &m_spMMCObjectTypeInfo);
}

CScriptHostMgr::~CScriptHostMgr()
{
    DECLARE_SC(sc, _T("CScriptHostMgr::~CScriptHostMgr"));

    // The script manager is going away so ask all the script
    // hosts to finish their scripts & then destroy them.
    sc = ScDestroyScriptHosts();
}

SC CScriptHostMgr::ScGetMMCObject(LPUNKNOWN *ppunkItem)
{
    DECLARE_SC(sc, TEXT("CScriptHostMgr::ScGetMMCObject"));
    sc = ScCheckPointers(ppunkItem);
    if (sc)
        return sc;

    if (m_spMMCObjectDispatch)
    {
        *ppunkItem = m_spMMCObjectDispatch;
        return sc;
    }

    return (sc = E_FAIL);
}

SC CScriptHostMgr::ScGetMMCTypeInfo(LPTYPEINFO *ppTypeInfo)
{
    DECLARE_SC(sc, TEXT("CScriptHostMgr::ScGetMMCObject"));
    sc = ScCheckPointers(ppTypeInfo);
    if (sc)
        return sc;

    if (m_spMMCObjectDispatch)
    {
        *ppTypeInfo = m_spMMCObjectTypeInfo;
        return sc;
    }

    return (sc = E_FAIL);
}


//+-------------------------------------------------------------------
//
//  Member:      ScGetScriptEngineFromExtn
//
//  Synopsis:    Using the file extension get the script engine & Clsid.
//
//  Arguments:   [strFileExtn]     - Script extension.
//               [strScriptEngine] - Type script.
//               [rClsid]          - CLSID of engine.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScGetScriptEngineFromExtn(const tstring& strFileExtn,
                                             tstring& strScriptEngine,
                                             CLSID& rClsid)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScGetScriptEngine"));

    CRegKey regKey;

    // Open the extension.
    LONG lRet = regKey.Open(HKEY_CLASSES_ROOT, strFileExtn.data(), KEY_READ);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }

    TCHAR szTemp[MAX_PATH];
    DWORD dwLen = MAX_PATH;
    tstring strTemp;
    // Read the default value, the location of file association data.
    lRet = regKey.QueryValue(szTemp, NULL, &dwLen);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }
    ASSERT(dwLen > 0);

    // Open the HKCR/FileAssocLoc/ScriptEngine.
    strTemp  = szTemp;
    strTemp += _T("\\");
    strTemp += SCRIPT_ENGINE_KEY;

    lRet = regKey.Open(HKEY_CLASSES_ROOT, strTemp.data(), KEY_READ);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }

    // Now read the ScriptEngine default value.
    dwLen = MAX_PATH;
    lRet = regKey.QueryValue(szTemp, NULL, &dwLen);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }
    ASSERT(dwLen > 0);

    strScriptEngine  = szTemp;

    // Read HKCR/ScriptEngine/CLSID for ScriptEngine clsid.
    strTemp  = strScriptEngine + _T("\\");
    strTemp += CLSIDSTR;

    lRet = regKey.Open(HKEY_CLASSES_ROOT, strTemp.data(), KEY_READ);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }

    // Read the CLSID value.
    dwLen = MAX_PATH;
    lRet = regKey.QueryValue(szTemp, NULL, &dwLen);
    if (ERROR_SUCCESS != lRet)
    {
        sc.FromWin32(lRet);
        return sc;
    }
    ASSERT(dwLen > 0);

    USES_CONVERSION;
    LPOLESTR lpClsid = T2OLE(szTemp);
    sc = CLSIDFromString(lpClsid, &rClsid);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScGetScriptEngine
//
//  Synopsis:    [strFileName] - Script file name.
//               [eScriptType] - Type script.
//               [rClsid]      - CLSID of engine.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScGetScriptEngine(const tstring& strFileName,
                                     tstring& strScriptEngine,
                                     CLSID& rClsid)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScGetScriptEngine"));

    // Is this required, the file is already read.
    // It is a file & it exists.
    DWORD dwAttr = GetFileAttributes(strFileName.data());
    if (-1 == dwAttr)
    {
        // What if lasterror is overwritten?
        sc.FromWin32(::GetLastError());
        return sc;
    }

    // Get the extension (look for . from end).
    int iPos = strFileName.rfind(_T('.'));
    tstring strExtn;
    if (-1 != iPos)
    {
        strExtn = strFileName.substr(iPos, strFileName.length());
    }
    else
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = ScGetScriptEngineFromExtn(strExtn, strScriptEngine, rClsid);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      ScLoadScriptFromFile
//
//  Synopsis:    Allocate memory & Load the script from the given file.
//
//  Arguments:   [strFileName]       - File to be loaded.
//               [pszScriptContents] - Memory buffer containing the script
//                                     contents (See note).
//
//  Note:        The caller should call HeapFree() to free the pszScriptContents.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScLoadScriptFromFile (const tstring& strFileName, LPOLESTR* pszScriptText)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScLoadScriptFromFile"));
    sc = ScCheckPointers(pszScriptText);
    if (sc)
        return sc;
    *pszScriptText = NULL;

    // Open the file.
    HANDLE hFile = ::CreateFile(strFileName.data(),
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        sc.FromWin32(::GetLastError());
        return sc;
    }

    HANDLE hFileMap = NULL;
    LPSTR pszMBCS   = NULL;

    DWORD dwFileSize = ::GetFileSize(hFile, NULL);
    if (dwFileSize == 0xFFFFFFFF)
    {
        sc.FromWin32(::GetLastError());
        goto FileError;
    }

    if (dwFileSize == 0)
    {
        sc = E_UNEXPECTED;
        goto FileError;
    }

    // Create a file mapping object.
    hFileMap = ::CreateFileMapping(hFile,
                                   NULL,
                                   PAGE_READONLY,
                                   0, dwFileSize,
                                   NULL );
    if (hFileMap == NULL)
    {
        sc.FromWin32(::GetLastError());
        goto FileError;
    }

    // Dummy block.
    {
        // Map the file into memory.
        pszMBCS = (LPSTR) ::MapViewOfFile(hFileMap,
                                          FILE_MAP_READ,
                                          0, 0,
                                          0 );

        if (pszMBCS == NULL)
        {
            sc.FromWin32(::GetLastError());
            goto FileMapError;
        }

        // Get the size of buffer needed.
        int n = ::MultiByteToWideChar(CP_ACP,
                                      0,
                                      pszMBCS, dwFileSize,
                                      NULL, 0 );

        //
        // Allocate script text buffer. +1 for EOS.
        //
        LPOLESTR pszText;
        pszText = (LPOLESTR) ::HeapAlloc(::GetProcessHeap(),
                                         0,
                                         (n + 2) * sizeof(wchar_t) );
        if (pszText == NULL)
        {
            sc.FromWin32(::GetLastError());
            goto FileAllocError;
        }


        // Store file as WCHAR inthe buffer.
        ::MultiByteToWideChar(CP_ACP,
                              0,
                              pszMBCS, dwFileSize,
                              pszText, n );
        //
        // Remove legacy EOF character.
        //
        if (pszText[n - 1] == 0x1A)
        {
            pszText[n - 1] = '\n';
        }

        pszText[n] = '\n';
        pszText[n + 1] = '\0';

        *pszScriptText = pszText;
    }


FileAllocError:
    ::UnmapViewOfFile(pszMBCS);

FileMapError:
    ::CloseHandle(hFileMap);

FileError:
    ::CloseHandle(hFile);

//NoError:
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScExecuteScript
//
//  Synopsis:    Execute given script file.
//
//  Arguments:   [strFileName]  - The script file.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScExecuteScript(const tstring& strFileName)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScExecuteScript"));

    CHeapAllocMemPtr<OLECHAR> spszFileContents;
    sc = ScLoadScriptFromFile(strFileName, &spszFileContents);
    if (sc)
        return sc;

    tstring strScriptEngine;
    CLSID EngineClsid;
    // Validate the file, get the script engine and script type.
    sc = ScGetScriptEngine(strFileName, strScriptEngine, EngineClsid);
    if (sc)
        return sc;

    sc = ScExecuteScriptHelper(spszFileContents, strScriptEngine, EngineClsid);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScExecuteScript
//
//  Synopsis:    Execute given script.
//
//  Arguments:   [pszScriptText]   - The script itself.
//               [strExtn]         - The script file extension.
//
//  Note:        The extension is used to determine the script
//               engine (as shell does).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScExecuteScript(LPOLESTR pszScriptText, const tstring& strExtn)
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScExecuteScript"));

    tstring strScriptEngine;
    CLSID EngineClsid;
    // Validate the file, get the script engine and script type.
    sc = ScGetScriptEngineFromExtn(strExtn, strScriptEngine, EngineClsid);
    if (sc)
        return sc;

    sc = ScExecuteScriptHelper(pszScriptText, strScriptEngine, EngineClsid);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScExecuteScriptHelper
//
//  Synopsis:    Helper for ScExecuteScript, Create the Script Host &
//               asks it to run the script.
//
//  Arguments:   [pszScriptText]   - The script contents.
//               [strScriptEngine] - The script engine name.
//               [EngineClsid]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScExecuteScriptHelper (LPCOLESTR pszScriptText,
                                          const tstring strScriptEngine,
                                          const CLSID& EngineClsid)
{
    DECLARE_SC(sc, _T("ScExecuteScriptHelper"));

    // Create CScriptHost and ask it to run the script.
    CComObject<CScriptHost>* pScriptHost = NULL;
    sc = CComObject<CScriptHost>::CreateInstance(&pScriptHost);
    if (sc)
        return sc;

    if (NULL == pScriptHost)
        return (sc = E_FAIL);

    IUnknownPtr spUnknown = pScriptHost;
    if (NULL == spUnknown)
        return (sc = E_UNEXPECTED);

    m_ArrayOfHosts.push_back(spUnknown);

    sc = pScriptHost->ScRunScript(this, pszScriptText, strScriptEngine, EngineClsid);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      ScDestroyScriptHosts
//
//  Synopsis:    Stop all the running scripts and destroy all
//               script hosts.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHostMgr::ScDestroyScriptHosts()
{
    DECLARE_SC(sc, _T("CScriptHostMgr::ScStopAllScripts"));

    // Ask each script host created to stop its script.
    ArrayOfScriptHosts::iterator it = m_ArrayOfHosts.begin();
    for (;it != m_ArrayOfHosts.end(); ++it)
    {
        CScriptHost* pScriptHost = dynamic_cast<CScriptHost*>(it->GetInterfacePtr());
        sc = ScCheckPointers(pScriptHost, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = pScriptHost->ScStopScript();
    }

    // This clear will call release on the IUnknown smart-pointers (that are in this array).
    m_ArrayOfHosts.clear();

    return sc;
}


CScriptHost::CScriptHost() :
    m_pScriptHostMgr(NULL)
{
}

CScriptHost::~CScriptHost()
{
}

//+-------------------------------------------------------------------
//
//  Member:      ScRunScript
//
//  Synopsis:    Run the given script
//
//  Arguments:   [pMgr]           - Object that manages all CScriptHosts.
//               [strScript]      - The script itself.
//               [strEngineName]  - Script engine name.
//               [rEngineClsid]   - The script engine that runs this script.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHost::ScRunScript(CScriptHostMgr* pMgr, LPCOLESTR pszScriptText,
                            const tstring& strEngineName, const CLSID& rEngineClsid)
{
    DECLARE_SC(sc, _T("CScriptHost::ScRunScript"));

    m_pScriptHostMgr = pMgr;
    sc = ScCheckPointers(m_pScriptHostMgr, E_UNEXPECTED);
    if (sc)
        return sc;

    m_strScriptEngine = strEngineName;
    m_EngineClsid = rEngineClsid;

    // Now create the script engine.
    LPUNKNOWN* pUnknown = NULL;
    sc = CoCreateInstance(m_EngineClsid, NULL, CLSCTX_INPROC_SERVER,
                          IID_IActiveScript, (void **)&m_spActiveScriptEngine);
    if (sc)
        return sc;

    m_spActiveScriptParser = m_spActiveScriptEngine;
    if (NULL == m_spActiveScriptParser)
    {
        m_spActiveScriptEngine = NULL; // Release the engine.
        return (sc = E_FAIL);
    }

    sc = m_spActiveScriptEngine->SetScriptSite(this);
    if (sc)
        return sc;

    sc = m_spActiveScriptParser->InitNew();
    if (sc)
        return sc;

    // Add MMC objects to the top-level.
    sc = m_spActiveScriptEngine->AddNamedItem(MMCObjectName,
                                              SCRIPTITEM_ISSOURCE |
                                              SCRIPTITEM_GLOBALMEMBERS |
                                              SCRIPTITEM_ISVISIBLE);
    if (sc)
    {
        m_spActiveScriptEngine = NULL;
        m_spActiveScriptParser = NULL;
        return sc;
    }

    sc = m_spActiveScriptParser->ParseScriptText(pszScriptText, NULL, NULL, NULL,
                                                 0, 0, 0L, NULL, NULL);
    if (sc)
    {
        m_spActiveScriptEngine = NULL;
        m_spActiveScriptParser = NULL;
        return sc;
    }

    sc = m_spActiveScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (sc)
    {
        m_spActiveScriptEngine = NULL;
        m_spActiveScriptParser = NULL;
        return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScStopScript
//
//  Synopsis:    Stop the script engine.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScriptHost::ScStopScript ()
{
    DECLARE_SC(sc, _T("CScriptHost::ScStopScript"));

    sc = ScCheckPointers(m_spActiveScriptEngine, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_spActiveScriptEngine->SetScriptState(SCRIPTSTATE_DISCONNECTED);
    sc = m_spActiveScriptEngine->Close();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      GetLCID
//
//  Synopsis:    Return the Lang Id to Script engine.
//
//  Arguments:   [plcid] - Language Identifier.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetLCID( LCID *plcid)
{
    DECLARE_SC(sc, _T("CScriptHost::GetLCID"));
    sc = ScCheckPointers(plcid);
    if (sc)
        return sc.ToHr();

    *plcid = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      GetItemInfo
//
//  Synopsis:    Return IUnknown or ITypeInfo of the item added using
//               IActiveScript::AddNamedItem. Called by script engine.
//
//  Arguments:   [pstrName]     - The item that was added.
//               [dwReturnMask] - Request (IUnknown or ITypeInfo).
//               [ppunkItem]    - IUnknown returned if requested.
//               [ppTypeInfo]   - ITypeInfo returned if requested.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetItemInfo( LPCOLESTR pstrName, DWORD dwReturnMask,
                                    IUnknown **ppunkItem, ITypeInfo **ppTypeInfo)
{
    DECLARE_SC(sc, _T("CScriptHost::GetItemInfo"));

    // The IUnknown** & ITypeInfo** can be NULL.
    if (ppunkItem)
        *ppunkItem = NULL;

    if (ppTypeInfo)
        *ppTypeInfo = NULL;

    // Make sure it is our object being requested.
    if (_wcsicmp(MMCObjectName, pstrName))
        return (sc = TYPE_E_ELEMENTNOTFOUND).ToHr();

    sc = ScCheckPointers(m_pScriptHostMgr, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (ppunkItem)
        {
            sc = m_pScriptHostMgr->ScGetMMCObject(ppunkItem);
            if (sc)
                return sc.ToHr();

            (*ppunkItem)->AddRef();
        }
        else
            return (sc = E_POINTER).ToHr();
    }


    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (ppTypeInfo)
        {
            sc = m_pScriptHostMgr->ScGetMMCTypeInfo(ppTypeInfo);
            if (sc)
                return sc.ToHr();

            (*ppTypeInfo)->AddRef();
        }
        else
            return  (sc = E_POINTER).ToHr();

    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      GetDocVersionString
//
//  Synopsis:    This retrieves a host-defined string that uniquely
//               identifies the current script (document) version from
//               the host's point of view. Called by script engine.
//
//  Arguments:   [pbstrVersionString] - The doc version string.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetDocVersionString( BSTR *pbstrVersionString)
{
    DECLARE_SC(sc, _T("CScriptHost::GetDocVersionString"));

    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:      OnScriptTerminate
//
//  Synopsis:    Called by engine when the script has completed execution.
//
//  Arguments:   [pvarResult] - Script results.
//               [pexcepinfo] - Any exceptions generated.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnScriptTerminate( const VARIANT *pvarResult,
                                             const EXCEPINFO *pexcepinfo)
{
    DECLARE_SC(sc, _T("CScriptHost::OnScriptTerminate"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnStateChange
//
//  Synopsis:    Called by engine when its state changes.
//
//  Arguments:   [ssScriptState] - New state.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnStateChange(SCRIPTSTATE ssScriptState)
{
    DECLARE_SC(sc, _T("CScriptHost::OnStateChange"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnScriptError
//
//  Synopsis:    Engine informs that an execution error occurred
//               while it was running the script.
//
//  Arguments:   [pase ] - Host can obtain info about execution
//                         error using this interface.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnScriptError(IActiveScriptError *pase)
{
    DECLARE_SC(sc, _T("CScriptHost::OnScriptError"));
    sc = ScCheckPointers(pase);
    if (sc)
        return sc.ToHr();

    // For test purposes. We need to provide much better debug info,
    // We will hookup the ScriptDebugger for this.
    BSTR bstrSourceLine;
    sc = pase->GetSourceLineText(&bstrSourceLine);

    EXCEPINFO exinfo;
    ZeroMemory(&exinfo, sizeof(exinfo));
    sc = pase->GetExceptionInfo(&exinfo);

    DWORD dwSourceContext = 0;
    ULONG ulLineNumber    = -1;
    LONG  lCharPos        = -1;
    sc = pase->GetSourcePosition(&dwSourceContext, &ulLineNumber, &lCharPos);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnEnterScript
//
//  Synopsis:    Engine informs that it has begun executing script.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnEnterScript(void)
{
    DECLARE_SC(sc, _T("CScriptHost::OnEnterScript"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      OnEnterScript
//
//  Synopsis:    Engine informs that it has returned from executing script.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::OnLeaveScript(void)
{
    DECLARE_SC(sc, _T("CScriptHost::OnLeaveScript"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      GetWindow
//
//  Synopsis:    Engine asks for window that can be parent of a popup
//               it can display.
//
//  Arguments:   [phwnd ] - Parent window.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::GetWindow(HWND *phwnd)
{
    DECLARE_SC(sc, _T("CScriptHost::GetWindow"));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      EnableModeless
//
//  Synopsis:    Enables/Disables modelessness of parent window.
//
//  Arguments:   [fEnable ] - Enable/Disable.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CScriptHost::EnableModeless(BOOL fEnable)
{
    DECLARE_SC(sc, _T("CScriptHost::EnableModeless"));

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	AMC.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\statbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statbar.h
//
//--------------------------------------------------------------------------

#ifndef _STATBAR_H
#define _STATBAR_H

#ifndef __DOCKSITE_H__
#include "docksite.h"
#endif

class CAMCProgressCtrl : public CProgressCtrl
{
public:
    CAMCProgressCtrl();

    void SetRange( int nLower, int nUpper );
    void GetRange( int * nLower, int * nUpper );
    int  SetPos  ( int nPos);

private:
    int nLower, nUpper;
};

class CAMCStatusBar : public CStatBar
{
    DECLARE_DYNAMIC (CAMCStatusBar)

    static const TCHAR DELINEATOR[]; 
    static const TCHAR PROGRESSBAR[];

    enum eFieldSize
    {
        eStatusFields = 3  
    };

// Constructor/Destructors
public:
    CAMCStatusBar(); 
    ~CAMCStatusBar();

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCStatusBar)
    //}}AFX_VIRTUAL

// usable only by CAMCStatusBarText
protected:
    //{{AFX_MSG(CAMCStatusBar)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG

    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LPARAM OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg LPARAM OnSBSetText(WPARAM wParam, LPARAM lParam);

public:
    DECLARE_MESSAGE_MAP()

// Progress bar child control
public:
    CAMCProgressCtrl    m_progressControl;
    CStatic             m_staticControl;

// internal
private:
    CTypedPtrList<CPtrList, CString*> m_TextList;
    CCriticalSection m_Critsec;
    DWORD m_iNumStatusText;
    CFont   m_StaticFont;

    void Update();
    void Parse(LPCTSTR strText);
    void SetStatusBarFont();

public:
    CAMCProgressCtrl* GetStatusProgressCtrlHwnd()
        { return (&m_progressControl); }

    CStatic* GetStatusStaticCtrlHwnd()
        { return (&m_staticControl); }
};

#endif  // _STATBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\statbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statbar.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "StatBar.h"
#include "amcmsgid.h"

// CODEWORK message reflection not working yet


// Set the default upper and lower bounds since these are the default values used in CProgressCtrl
CAMCProgressCtrl::CAMCProgressCtrl() : CProgressCtrl()
{
    nLower = 0;
    nUpper = 100;
}

// Set the default upper and lower bounds before setting the range in the base class
void
CAMCProgressCtrl::SetRange( int nNewLower, int nNewUpper )
{
    if ((nLower != nNewLower) || (nUpper != nNewUpper))
    {
        nLower = nNewLower;
        nUpper = nNewUpper;

        /*
         * MFC 4.2 doesn't define SetRange32, so do it the old-fashioned way
         */
        SendMessage (PBM_SETRANGE32, nNewLower, nNewUpper);
    }
}

// Retrieve the range
void
CAMCProgressCtrl::GetRange( int * nGetLower, int * nGetUpper )
{
    *nGetLower = nLower;
    *nGetUpper = nUpper;
}

// Display the progress bar whenever the position is being set
int
CAMCProgressCtrl::SetPos(int nPos)
{
	/*
	 * Theming:  When navigation is concluded, the web browser will set a
	 * 0 position, with a range of (0,0).  This would leave the progress
	 * control visible, but not distiguishable from the status bar because
	 * the status bar and the progress bar had the same background.  When
	 * themes are enabled, the progress bar is distinguishable because the
	 * themed progress bar has a different background from the status bar.
	 * See bug 366817.
	 *
	 * The fix is to only show the progress bar if there's a non-empty range.
	 */
	bool fShow = (nUpper != nLower);
    ShowWindow (fShow ? SW_SHOW : SW_HIDE);

    return CProgressCtrl::SetPos(nPos);
}

IMPLEMENT_DYNAMIC(CAMCStatusBar, CStatBar)

BEGIN_MESSAGE_MAP(CAMCStatusBar, CStatBar)
    //{{AFX_MSG_MAP(CAMCStatusBar)
    ON_WM_CREATE()
    ON_WM_SIZE()
	//}}AFX_MSG_MAP

    ON_WM_SETTINGCHANGE()
    ON_MESSAGE (WM_SETTEXT, OnSetText)
    ON_MESSAGE (SB_SETTEXT, OnSBSetText)
END_MESSAGE_MAP()

const TCHAR CAMCStatusBar::DELINEATOR[] = TEXT("|");
const TCHAR CAMCStatusBar::PROGRESSBAR[] = TEXT("%");

CAMCStatusBar::CAMCStatusBar()
{
}

CAMCStatusBar::~CAMCStatusBar()
{
    CSingleLock lock( &m_Critsec );
    POSITION pos = m_TextList.GetHeadPosition();
    while ( NULL != pos )
    {
        delete m_TextList.GetNext( pos );
    }
    m_TextList.RemoveAll();
}


void CAMCStatusBar::Parse(LPCTSTR strText)
{
    m_progressControl.ShowWindow(SW_HIDE);
    CString str[eStatusFields];
    int i;

    if (strText != NULL)
    {
        str[0] = strText;
        str[0].TrimLeft();
        str[0].TrimRight();
    }

    // If there is no text to display
    if (str[0].IsEmpty())
    {
        // Set the variable to designate this
        m_iNumStatusText = 0;
        // Wipe the rest of the panes
        for (i = 0; i < eStatusFields; i++)
            SetPaneText(i, NULL );
    }
    else
    {
        m_iNumStatusText = 0xffff;
        int iLocationDelin = 0;

        // Dissect the string into parts to be displayed in appropriate windows
        for (i = 0; (i < eStatusFields) &&
            ((iLocationDelin = str[i].FindOneOf(DELINEATOR)) > -1);
            i++)
        {
            if (i < eStatusFields - 1)
            {
                str[i+1] = str[i].Mid(iLocationDelin + 1);

                /*
                 * trim leading whitespace (trailing whitespace
                 * should have been trimmed already)
                 */
                str[i+1].TrimLeft();
                ASSERT (str[i+1].IsEmpty() || !_istspace(str[i+1][str[i+1].GetLength()-1]));
            }

            str[i] = str[i].Left( iLocationDelin );

            /*
             * trim trailing whitespace (leading whitespace
             * should have been trimmed already)
             */
            str[i].TrimRight();
            ASSERT (str[i].IsEmpty() || !_istspace(str[i][0]));
        }

        // If the progress bar is being displayed

        if ((str[1].GetLength() > 1) && (str[1].FindOneOf(PROGRESSBAR) == 0))
        {
            if (str[1][0] == str[1][1])
                str[1] = str[1].Mid(1);
            else
            {
                int val = _ttoi(str[1].Mid(1));
                m_progressControl.SetRange(0, 100);
                m_progressControl.SetPos(val);
                m_iNumStatusText &= ~(0x2);
            }
        }

        // Display the text in the panes (which wipes them if necessary)
        for (i = 0; i < eStatusFields; i++)
            if (m_iNumStatusText & (1 << i))
                SetPaneText(i, str[i]);
    }
}

void CAMCStatusBar::Update()
{
    // keep copy of string to avoid WIN32 operations while holding critsec
    CString str;
    {
        CSingleLock lock( &m_Critsec );
        if ( !m_TextList.IsEmpty() )
        {
            CString* pstr = m_TextList.GetHead();
            ASSERT( pstr != NULL );
            str = *pstr;
        }
    }

    if (str.IsEmpty())
        GetParentFrame()->SendMessage (WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
    else
        Parse(str);
}

int CAMCStatusBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CStatBar::OnCreate(lpCreateStruct) == -1)
        return -1;

    // Create the progres bar control as a child of the status bar
    CRect rect(0,0,0,0);
    m_progressControl.Create(PBS_SMOOTH|WS_CLIPSIBLINGS|WS_CHILD|WS_VISIBLE, rect, this, 0x1000);
    m_staticControl.Create(_T(""), WS_CLIPSIBLINGS|WS_CHILD|WS_VISIBLE|SS_SIMPLE, rect, this, 0x1001);

    // Remove the static edge, hide the window and display a changes frame
    m_progressControl.ModifyStyleEx(WS_EX_STATICEDGE, 0, SWP_HIDEWINDOW | SWP_FRAMECHANGED);

    SetStatusBarFont();

    return 0;
}

void CAMCStatusBar::OnSize(UINT nType, int cx, int cy)
{
    CStatBar::OnSize(nType, cx, cy);

    // Get the width of the first pane for position and get the width of the pane
    // to set the width of the progress bar
    CRect textRect, progressRect, staticRect;
    GetItemRect(0, &textRect);
    GetItemRect(1, &progressRect);
    GetItemRect(2, &staticRect);

    progressRect.InflateRect(-2, -2);
    staticRect.InflateRect(-2, -2);

    int pane1Width = textRect.Width();      // (Text area) add two for the border
    int pane2Width = progressRect.Width();  // (Progress area) add two for the border
    const int BORDER = 4;

    // size the progress bar
    if (IsWindow (m_progressControl))
        m_progressControl.SetWindowPos(NULL, pane1Width + BORDER, BORDER, pane2Width,
                                            progressRect.Height(),
                                            SWP_FRAMECHANGED |
                                            SWP_NOREPOSITION |
                                            SWP_NOZORDER);

    // size the static control
    if (IsWindow (m_staticControl))
        m_staticControl.SetWindowPos(NULL, pane1Width + pane2Width + (2*BORDER), BORDER, staticRect.Width(),
                                            staticRect.Height(),
                                            SWP_FRAMECHANGED |
                                            SWP_NOREPOSITION |
                                            SWP_NOZORDER);
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CAMCStatusBar.
 *--------------------------------------------------------------------------*/

void CAMCStatusBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    Default();

    if (uFlags == SPI_SETNONCLIENTMETRICS)
    {
        // the system status bar font may have changed; update it now
        SetStatusBarFont();
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::OnSetText
 *
 * WM_SETTEXT handler for CAMCStatusBar.
 *--------------------------------------------------------------------------*/

LRESULT CAMCStatusBar::OnSetText (WPARAM, LPARAM lParam)
{
    Parse (reinterpret_cast<LPCTSTR>(lParam));
    return (TRUE);
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::OnSBSetText
 *
 * SB_SETTEXT handler for CAMCStatusBar.
 *--------------------------------------------------------------------------*/

LRESULT CAMCStatusBar::OnSBSetText (WPARAM wParam, LPARAM)
{
    return (Default());
}


/*+-------------------------------------------------------------------------*
 * CAMCStatusBar::SetStatusBarFont
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCStatusBar::SetStatusBarFont ()
{
    /*
     * delete the old font
     */
    m_StaticFont.DeleteObject ();

    /*
     * query the system for the current status bar font
     */
    NONCLIENTMETRICS    ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    /*
     * use it here, too;  we need to set the font for the embedded static
     * control, but the status bar window will take care of itself
     */
    m_StaticFont.CreateFontIndirect (&ncm.lfStatusFont);
    m_staticControl.SetFont (&m_StaticFont, false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      stdafx.h
//
//  Contents:  PCH for AMC
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Added #include for template support
//
//--------------------------------------------------------------------------
#pragma warning(disable: 4786)      // symbol greater than 255 characters
#pragma warning(disable: 4291)      // 'placement new': no matching operator delete found; memory will not be freed if initialization throws an exception

#define VC_EXTRALEAN	    // Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERTMSG
#undef ASSERT

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <mmctempl.h>       // MFC Template classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcview.h>       // MFC CListView & CTreeView classes
#include <afxpriv.h>        // used for OLE2T T2OLE conversions
#include <afxmt.h>          // CCriticalSection
#include <afxole.h>         // MFC OLE classes

#if (_WIN32_WINNT < 0x0500)
#include <multimon.h>       // multiple monitor support
#endif

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <objidl.h>         // OLE interface definitions

/*----------------------------------------------------------*/
/* include the STL headers that define operator new() here, */
/* so we don't run into trouble with DEBUG_NEW below        */
/*----------------------------------------------------------*/
#include <new>
#include <memory>


#define SIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))


#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//############################################################################
//############################################################################
//
// STL and  other classes
//
//############################################################################
//############################################################################

#include <set>
#include <map>
#include <vector>
#include <list>
#include <deque>
#include <queue>
#include <stack>
#include <algorithm>
#include <iterator>


//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include <mmc.h>
#include <ndmgr.h>          // include file built by MIDL from ndmgr.idl
#include <ndmgrpriv.h>


//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "dbg.h"            // Debug helper
#include "cstr.h"
#include "mmcdebug.h"
#include "mmcerror.h"

#pragma warning(disable: 4068)      // unknown pragma
#include "atlconui.h"
#pragma warning(default: 4068)

#include "tiedobj.h"
#include "comerror.h"
#include "events.h"
#include "comobjects.h"
#include "enumerator.h"
#include "autoptr.h"
#include "refcount.h"

//############################################################################
//############################################################################
//
// include common and conui-only strings.
//
//############################################################################
//############################################################################
#include "..\base\basestr.h"
#include "..\base\conuistr.h"

#include "stringutil.h"
//############################################################################
//############################################################################
//
// Debug support for legacy traces.
//
//############################################################################
//############################################################################
#undef TRACE

#ifdef DBG

#define TRACE TraceConuiLegacy

#else // DBG

#define TRACE               ;/##/

#endif DBG

//############################################################################
//############################################################################
//
// Misc functions
//
//############################################################################
//############################################################################
void DrawBitmap(HDC hWnd, int nID, CRect& rc, BOOL bStretch);

// Project specific includes
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "docksite.h"
#include "Controls.h"
#include "mmcptrs.h"
#include "wrapper.h"
#include "countof.h"
#include "cpputil.h"
#include "stlstuff.h"
#include "bookmark.h"
#include "serial.h"
#include "xmlbase.h"
#include "resultview.h"
#include "mmcdata.h"
#include "viewset.h"
#include "memento.h"
#include "objmodelptrs.h"
#include "macros.h"

//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
// multimon.h (which we don't own) uses a deprecated function in ANSI. That's
// why we #define STRSAFE_NO_DEPRECATE below in ANSI only
#ifndef UNICODE
#define STRSAFE_NO_DEPRECATE
#endif // UNICODE

#include <strsafe.h>


//############################################################################
//############################################################################
//
// Headers included from conui
//
//############################################################################
//############################################################################
#include "resource.h"       // main symbols
#include "helparr.h"
#include "idle.h"
#include "conuiobservers.h"
#include "mmcaxwin.h"

//############################################################################
//############################################################################
//
// Miscellaneous
//
//############################################################################
//############################################################################

#include <shfusion.h>

class CThemeContextActivator
{
public:
	CThemeContextActivator() : m_ulActivationCookie(0)
		{ SHActivateContext (&m_ulActivationCookie); }

   ~CThemeContextActivator()
		{ SHDeactivateContext (m_ulActivationCookie); }

private:
	ULONG_PTR	m_ulActivationCookie;
};

// from afxpriv.h
extern void AFXAPI AfxSetWindowText(HWND, LPCTSTR);


inline bool IsKeyPressed (int nVirtKey)
{
    return (GetKeyState (nVirtKey) < 0);
}

template<typename T>
inline T abs (const T& t)
{
    return ((t < 0) ? -t : t);
}


/*
 * Define some handy message map macros that afxmsg_.h doesn't define for us
 */
#define ON_WM_SETTEXT() \
    { WM_SETTEXT, 0, 0, 0, AfxSig_vs, \
        (AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(LPTSTR))&OnSetText },
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\stdbar.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdbar.cpp
//
//  Contents:   Standard toolbar implementation.
//
//  History:    10/22/1999   AnandhaG   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "stdbar.h"
#include "amcview.h"
#include "toolbar.h"
#include "util.h"       // GetTBBtnTextAndStatus()

using namespace std;

/*
 * These are used only to give the separators unique IDs, so automatic
 * separator handling will work (see AssertSeparatorsAreValid).
 */
enum
{
    ID_Separator1 = 1,
    ID_Separator2,
    ID_Separator3,
    ID_Separator4,
    ID_Separator5,
    ID_Separator6,
    ID_Separator7,
    ID_Separator8,
    ID_Separator9,

    // must be last
    ID_SeparatorFirst = ID_Separator1,
    ID_SeparatorLast  = ID_Separator9,
    ID_SeparatorMax   = ID_SeparatorLast,
};

static MMCBUTTON CommonButtons[] =
{
    { 0, IDS_MMC_WEB_BACK         , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    { 1, IDS_MMC_WEB_FORWARD      , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator1            , 0,               TBSTYLE_SEP   , NULL, NULL },
    { 9, IDS_MMC_GENL_UPONELEVEL  , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    {10, IDS_MMC_GENL_SCOPE       , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator2            , 0,               TBSTYLE_SEP   , NULL, NULL },
    { 5, IDS_MMC_VERB_CUT         , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 6, IDS_MMC_VERB_COPY        , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 7, IDS_MMC_VERB_PASTE       , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator3            , 0,               TBSTYLE_SEP   , NULL, NULL },
    {11, IDS_MMC_VERB_DELETE      , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 8, IDS_MMC_VERB_PROPERTIES  , 0,               TBSTYLE_BUTTON, NULL, NULL },
    {12, IDS_MMC_VERB_PRINT       , 0,               TBSTYLE_BUTTON, NULL, NULL },
    {13, IDS_MMC_VERB_REFRESH     , 0,               TBSTYLE_BUTTON, NULL, NULL },
    {16, IDS_SAVE_LIST_BUTTON     , 0,               TBSTYLE_BUTTON, NULL, NULL },
    { 0, ID_Separator4            , 0,               TBSTYLE_SEP   , NULL, NULL },
    {15, IDS_MMC_GENL_CONTEXTHELP , TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL, NULL },
};


CStandardToolbar::CStandardToolbar()
   :m_pToolbarUI(NULL), m_pAMCView(NULL)
{
    /*
     * Map helps in determining string id from verb & vice versa.
     */
    m_MMCVerbCommandIDs[MMC_VERB_CUT]        = IDS_MMC_VERB_CUT;
    m_MMCVerbCommandIDs[MMC_VERB_CUT]        = IDS_MMC_VERB_CUT;
    m_MMCVerbCommandIDs[MMC_VERB_COPY]       = IDS_MMC_VERB_COPY;
    m_MMCVerbCommandIDs[MMC_VERB_PASTE]      = IDS_MMC_VERB_PASTE;
    m_MMCVerbCommandIDs[MMC_VERB_DELETE]     = IDS_MMC_VERB_DELETE;
    m_MMCVerbCommandIDs[MMC_VERB_PROPERTIES] = IDS_MMC_VERB_PROPERTIES;
    m_MMCVerbCommandIDs[MMC_VERB_PRINT]      = IDS_MMC_VERB_PRINT;
    m_MMCVerbCommandIDs[MMC_VERB_REFRESH]    = IDS_MMC_VERB_REFRESH;
}

CStandardToolbar::~CStandardToolbar()
{
    DECLARE_SC(sc, TEXT("CStandardToolbar::~CStandardToolbar"));

    // Ask the toolbar UI object to delete itself.
    if (m_pToolbarUI)
    {
        sc = m_pToolbarUI->ScDelete(this);

        if (sc)
            sc.TraceAndClear();
    }

}


//+-------------------------------------------------------------------
//
//  Member:      ScInitializeStdToolbar
//
//  Synopsis:    Initialize the standard toolbar, add bitmap & buttons.
//
//  Arguments:   [pAMCView]  - The CAMCView (owner) of this stdbar.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScInitializeStdToolbar(CAMCView* pAMCView)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScInitializeStdToolbar"));

    if (NULL == pAMCView)
        return (sc = E_UNEXPECTED);

    m_pAMCView = pAMCView;

    SViewData* pViewData = m_pAMCView->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        return sc;
    }


    // Get the toolbars mgr from CAMCView and create the stdandrd toolbar.
    CAMCViewToolbarsMgr* pAMCViewToolbarsMgr = pViewData->GetAMCViewToolbarsMgr();
    if (NULL == pAMCViewToolbarsMgr)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = pAMCViewToolbarsMgr->ScCreateToolBar(&m_pToolbarUI);
    if (sc)
        return sc;
    ASSERT(NULL != m_pToolbarUI);

    // Add the bitmap
    CBitmap cBmp;
    cBmp.LoadBitmap((pAMCView->GetExStyle() & WS_EX_LAYOUTRTL) ? IDB_COMMON_16_RTL : IDB_COMMON_16);

    BITMAP bm;
    cBmp.GetBitmap (&bm);

    int cBitmaps = (bm.bmWidth / BUTTON_BITMAP_SIZE) /*width*/;

    sc = m_pToolbarUI->ScAddBitmap(this, cBitmaps, cBmp, MMC_TOOLBTN_COLORREF);
    if (sc)
        return sc;

    // Add the buttons to the toolbar and then display toolbar
    sc = ScAddToolbarButtons(countof(CommonButtons), CommonButtons);
    if (sc)
        return sc;

    // See if Std bar is allowed or not.
    bool bShowStdbar = (pViewData->m_dwToolbarsDisplayed & STD_BUTTONS);

    sc = bShowStdbar ? m_pToolbarUI->ScAttach(this) : m_pToolbarUI->ScDetach(this);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScAddToolbarButtons
//
//  Synopsis:    Add buttons to standard toolbar.
//
//  Arguments:   [nCnt]     - Number of buttons to be added.
//               [pButtons] - Array of nCnt MMCBUTTONS.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScAddToolbarButtons(int nCnt, MMCBUTTON* pButtons)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScAddToolbarButtons"));

    // Array to store button text & tooltip text.
    wstring szButtonText[countof(CommonButtons)];
    wstring szTooltipText[countof(CommonButtons)];

    USES_CONVERSION;

    HINSTANCE hInst = GetStringModule();

    // get resource strings for all buttons
    for (int i = 0; i < nCnt; i++)
    {
        // We dont want to get text for separators.
        if (pButtons[i].idCommand > ID_SeparatorMax)
        {
            bool bSuccess = GetTBBtnTextAndStatus(hInst,
                                                  pButtons[i].idCommand,
                                                  szButtonText[i],
                                                  szTooltipText[i]);
            if (false == bSuccess)
            {
                return (sc = E_FAIL);
            }

            pButtons[i].lpButtonText = const_cast<LPOLESTR>(szButtonText[i].data());
            pButtons[i].lpTooltipText = const_cast<LPOLESTR>(szTooltipText[i].data());
        }
    }

    // Got the strings, now add buttons.
    sc = m_pToolbarUI->ScAddButtons(this, nCnt, pButtons);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScNotifyToolBarClick
//
//  Synopsis:    Button click handler.
//
//  Arguments:   [hNode]  - The HNODE owner of the view.
//               [bScope] - Focus on scope or result.
//               [lParam] - if result the lParam of focused result item.
//               [nID]    - Button ID that was clicked.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScNotifyToolBarClick(HNODE hNode, bool bScope, LPARAM lParam, UINT nID)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScNotifyToolBarClick"));

    if (NULL == m_pAMCView)
        return (sc = E_UNEXPECTED);

    switch (nID)
    {
        case IDS_MMC_VERB_CUT:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evCut);
            break;

        case IDS_MMC_VERB_COPY:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evCopy);
            break;

        case IDS_MMC_VERB_PASTE:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evPaste);
            break;

        case IDS_MMC_VERB_DELETE:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evDelete);
            break;

        case IDS_MMC_VERB_PROPERTIES:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evProperties);
            break;

        case IDS_MMC_VERB_PRINT:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evPrint);
            break;

        case IDS_MMC_VERB_REFRESH:
            sc = m_pAMCView->ScProcessConsoleVerb (hNode, bScope, lParam, evRefresh);
            break;

        case IDS_MMC_GENL_CONTEXTHELP:
            sc = m_pAMCView->ScContextHelp ();
            break;

        case IDS_MMC_GENL_UPONELEVEL:
            sc = m_pAMCView->ScUpOneLevel ();
            break;

        case IDS_MMC_GENL_SCOPE:
            sc = m_pAMCView->ScToggleScopePane ();
            break;

        case IDS_MMC_WEB_BACK:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Back);
            break;

        case IDS_MMC_WEB_FORWARD:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Forward);
            break;

        case IDS_MMC_WEB_STOP:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Stop);
            break;

        case IDS_MMC_WEB_REFRESH:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Refresh);
            break;

        case IDS_MMC_WEB_HOME:
            sc = m_pAMCView->ScWebCommand (CConsoleView::eWeb_Home);
            break;

        case IDS_SAVE_LIST_BUTTON:
            sc = m_pAMCView->ScSaveList ();
            break;

        default:
            sc = E_UNEXPECTED;
            TraceError(_T("Unknown Standard bar button ID"), sc);
            break;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CStandardToolbar::ScAMCViewToolbarsBeingDestroyed
//
//  Synopsis:    The CAMCViewToolbars object is going away, do not
//               reference that object anymore.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScAMCViewToolbarsBeingDestroyed ()
{
    DECLARE_SC(sc, _T("CStandardToolbar::ScAMCViewToolbarsBeingDestroyed"));

    m_pToolbarUI = NULL;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableButton
//
//  Synopsis:    Enable/Disable given button.
//
//  Arguments:
//               [nID]  - Button ID that should be enabled/disabled.
//               [bool] - Enable or Disable.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableButton(INT nID, bool bState)
{
    SC sc;

    if (NULL == m_pToolbarUI)
        return (sc = E_UNEXPECTED);

    sc = m_pToolbarUI->ScSetButtonState(this, nID, TBSTATE_ENABLED, bState);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableAndShowButton
//
//  Synopsis:    Enable (and show) or disable (and hide) the given button.
//
//  Arguments:
//               [nID]  - Button ID that should be enabled/disabled.
//               [bool] - If true enable else hide.
//
//  Note:        If the button is being disabled hide it.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableAndShowButton(INT nID, bool bEnableAndShow)
{
    DECLARE_SC(sc, _T("CStandardToolbar::ScEnableAndShowButton"));

    sc = ScCheckPointers(m_pToolbarUI, E_UNEXPECTED);
    if (sc)
        return sc;

    // First hide or show the button.
    sc = m_pToolbarUI->ScSetButtonState(this, nID, TBSTATE_HIDDEN,  !bEnableAndShow);
    if (sc)
        return sc;

    // Now enable or disable the button.
    sc = m_pToolbarUI->ScSetButtonState(this, nID, TBSTATE_ENABLED, bEnableAndShow);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableExportList
//
//  Synopsis:    Enable/Disable export-list button.
//
//  Arguments:   [bEnable] - enable/disable.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableExportList(bool bEnable)
{
    // If there are ANY items on the list, enable the button.
    return ScEnableAndShowButton(IDS_SAVE_LIST_BUTTON, bEnable );
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableUpOneLevel
//
//  Synopsis:    Enable/Disable up-one-level button.
//
//  Arguments:   [bEnable] -
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableUpOneLevel(bool bEnable)
{
    return ScEnableAndShowButton(IDS_MMC_GENL_UPONELEVEL, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableContextHelpBtn
//
//  Synopsis:    Enable/Disable help button.
//
//  Arguments:   [bEnable] -
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableContextHelpBtn(bool bEnable)
{
    return ScEnableAndShowButton(IDS_MMC_GENL_CONTEXTHELP, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:      ScEnableScopePaneBtn
//
//  Synopsis:    Enable/Disable scope-pane button.
//
//  Arguments:   [bEnable] -
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScEnableScopePaneBtn(bool bEnable)
{
    return ScEnableAndShowButton(IDS_MMC_GENL_SCOPE, bEnable);
}

//+-------------------------------------------------------------------
//
//  Member:      ScCheckScopePaneBtn
//
//  Synopsis:    Set scope button in normal or checked state.
//
//  Arguments:   [bChecked] - BOOL
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScCheckScopePaneBtn(bool bChecked)
{
    SC sc;

    if (NULL == m_pToolbarUI)
        return (sc = E_UNEXPECTED);

    sc = m_pToolbarUI->ScSetButtonState(this, IDS_MMC_GENL_SCOPE, TBSTATE_CHECKED, bChecked);
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScShowStdBar
//
//  Synopsis:    Show or Hide std bar.
//
//  Arguments:   [bShow] - BOOL
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScShowStdBar(bool bShow)
{
    SC sc;

    if (NULL == m_pToolbarUI)
        return (sc = E_UNEXPECTED);

    sc = bShow ? m_pToolbarUI->ScAttach(this) : m_pToolbarUI->ScDetach(this);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerbs
//
//  Synopsis:    Update the toolbuttons of std-verbs.
//
//  Arguments:   [pCV] - the IConsoleVerb that has state of the verb.
//
//  Returns:     SC.
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScUpdateStdbarVerbs(IConsoleVerb* pCV)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScUpdateStdbarVerbs"));

    for (int verb = MMC_VERB_FIRST; verb <= MMC_VERB_LAST; verb++)
    {
        // No toolbar buttons for following verbs.
        if ( (MMC_VERB_OPEN == verb) ||
             (MMC_VERB_RENAME == verb))
             continue;

        sc = ScUpdateStdbarVerb (static_cast<MMC_CONSOLE_VERB>(verb), pCV);
        if (sc)
            return sc;
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update the toolbutton of given std-verbs.
//
//  Arguments:   [cVerb] - the verb (ie: toolbutton) to be updated.
//               [pVC]   - the IConsoleVerb that has state of the verb.
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScUpdateStdbarVerb(MMC_CONSOLE_VERB cVerb, IConsoleVerb* pConsoleVerb /*=NULL*/)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScUpdateStdbarVerb"));

    if (NULL == m_pToolbarUI)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    if (pConsoleVerb == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // No toolbuttons for these verbs.
    if ( (MMC_VERB_OPEN == cVerb) ||
         (MMC_VERB_RENAME == cVerb))
         return sc;

    MMCVerbCommandIDs::iterator it = m_MMCVerbCommandIDs.find(cVerb);
    if (m_MMCVerbCommandIDs.end() == it)
    {
        // Could not find the verb in our map.
        sc = E_UNEXPECTED;
        return sc;
    }

    INT nCommandID = it->second;
    BOOL bFlag = 0;
    pConsoleVerb->GetVerbState(cVerb, HIDDEN, &bFlag);
    sc = m_pToolbarUI->ScSetButtonState(this, nCommandID, TBSTATE_HIDDEN, bFlag);
    if (sc)
        return sc;

    if (bFlag == FALSE)
    {
        // If verb is not hidden then enable/disable it.
        pConsoleVerb->GetVerbState(cVerb, ENABLED, &bFlag);
        sc = m_pToolbarUI->ScSetButtonState(this, nCommandID, TBSTATE_ENABLED, bFlag);

        if (sc)
            return sc;
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update the toolbutton of given std-verb.
//
//  Arguments:   [cVerb]   - the verb (ie: toolbutton) to be updated.
//               [nState]  - the button state to be updated.
//               [bFlag]   - State
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScUpdateStdbarVerb"));

    if (NULL == m_pToolbarUI)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    MMCVerbCommandIDs::iterator it = m_MMCVerbCommandIDs.find(cVerb);
    if (m_MMCVerbCommandIDs.end() == it)
    {
        // Could not find the verb in our map.
        sc = E_UNEXPECTED;
        return sc;
    }

    INT nCommandID = it->second;
    sc = m_pToolbarUI->ScSetButtonState(this, nCommandID, byState, bFlag);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      ScShow
//
//  Synopsis:    Show/Hide the toolbar.
//
//  Arguments:   [bShow]   - show/hide.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CStandardToolbar::ScShow (BOOL bShow)
{
    DECLARE_SC (sc, _T("CStandardToolbar::ScShow"));

    if (NULL == m_pToolbarUI)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = m_pToolbarUI->ScShow(this, bShow);
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\stringutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      string.cpp
//
//  Contents:  Utility functions for the CString class
//
//  History:   10-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------


// a function to load strings from the string module, not the AfxModule
BOOL    LoadString(CString &str, UINT nID);
void    FormatStrings(CString& rString, UINT nIDS, LPCTSTR const* rglpsz, int nString);
void    FormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void    FormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1, LPCTSTR lpsz2);

// make sure that the MMC functions replace the MFC ones.
#define AfxFormatString1  FormatString1
#define AfxFormatString2  FormatString2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\stdbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdbar.h
//
//              Standard toolbar implementation.
//
//--------------------------------------------------------------------------
#ifndef STDBAR_H__
#define STDBAR_H__
#include "toolbars.h"

#define  MMC_TOOLBTN_COLORREF RGB(255, 0, 255)

//+-------------------------------------------------------------------
//
//  class:     CStandardToolbar
//
//  Purpose:   Standard toolbar implementation.
//
//  History:    10-25-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CStandardToolbar : public CToolbarNotify,
                         public CStdVerbButtons
{
public:
    CStandardToolbar();
    ~CStandardToolbar();

    SC ScInitializeStdToolbar(CAMCView* pAMCView);

    // The following methods are used by CAMCView.
    SC ScEnableExportList(bool bEnable);
    SC ScEnableUpOneLevel(bool bEnable);
    SC ScEnableContextHelpBtn(bool bEnable);
    SC ScEnableScopePaneBtn(bool bEnable = true);
    SC ScCheckScopePaneBtn(bool bChecked);
    SC ScShowStdBar(bool bShow);
    SC ScEnableButton(INT nID, bool bState);
    SC ScEnableAndShowButton(INT nID, bool bEnableAndShow); // Instead of disabling hide it.

    // CStdVerbButtons implementation (used by nodemgr to update verbs).
    virtual SC ScUpdateStdbarVerbs(IConsoleVerb* pCV);
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, IConsoleVerb* pCV = NULL);
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE nState, BOOL bFlag);
    virtual SC ScShow(BOOL bShow);

public:
    // CToolbarNotify implementation (used by CToolbarsMgr to notify about button click).
    virtual SC ScNotifyToolBarClick(HNODE hNode, bool bScope, LPARAM lParam, UINT nID);
    virtual SC ScAMCViewToolbarsBeingDestroyed();

private:
    CMMCToolbarIntf*  m_pToolbarUI;        // Toolbar UI interface.
    CAMCView*         m_pAMCView;          // View owner.

    typedef std::map<INT, INT> MMCVerbCommandIDs;
    MMCVerbCommandIDs       m_MMCVerbCommandIDs;

    SC ScAddToolbarButtons(int nCnt, MMCBUTTON* pButtons);
};

#endif STDBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\stringutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:      string.cpp
//
//  Contents:  Utility functions for the CString class
//
//  History:   10-Aug-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include <stdafx.h>

/*+-------------------------------------------------------------------------*
 *
 * LoadString
 *
 * PURPOSE: A function to load strings from the string module, not the AfxModule
 *
 * PARAMETERS: 
 *    CString & str :
 *    UINT      nID :
 *
 * RETURNS: 
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL LoadString(CString &str, UINT nID)
{
    const size_t STRING_LEN_INCREMENT = 256;

    str.Empty();

    // try fixed buffer first (to avoid wasting space in the heap)
    static TCHAR szTemp[STRING_LEN_INCREMENT];

    int nLen = ::LoadString(GetStringModule(), nID, szTemp, countof(szTemp));
    if (countof(szTemp) - nLen > 1)
    {
        szTemp[nLen] = 0;
        str = szTemp;
        return nLen > 0;
    }

    // try buffer size of 2*STRING_LEN_INCREMENT, then larger size until entire string is retrieved
    int nSize = STRING_LEN_INCREMENT;
    do
    {
        nSize += STRING_LEN_INCREMENT;
        nLen = ::LoadString(GetStringModule(), nID, str.GetBuffer(nSize-1), nSize);
    } while (nSize - nLen <= 1);

    str.ReleaseBuffer();

    return (nLen > 0);
}

/*+-------------------------------------------------------------------------*
 *
 * FormatStrings
 *
 * PURPOSE: Similar to AfxFormatStrings, but uses GetStringModule() instead of
 *          AfxGetModuleInstance.
 *
 * PARAMETERS: 
 *    CString& rString :
 *    UINT     nIDS :
 *    LPCTSTR  const :
 *    int      nString :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void FormatStrings(CString& rString, UINT nIDS, LPCTSTR const* rglpsz, int nString)
{
    // empty the result (in case we fail)
    rString.Empty();

    // get the format string.
    CString strFormat;
    if (!LoadString(strFormat, nIDS))
    {
        TraceError(_T("FormatStrings"), SC(E_INVALIDARG));
        return; // failed...
    }

    AfxFormatStrings(rString, strFormat, rglpsz, nString);
}

/*+-------------------------------------------------------------------------*
 *
 * FormatString1
 *
 * PURPOSE: Similar to AfxFormatString1, but uses GetStringModule() instead
 *          of AfxGetModuleInstance()
 *
 * PARAMETERS: 
 *    CString& rString :
 *    UINT     nIDS :
 *    LPCTSTR  lpsz1 :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void FormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1)
{
	FormatStrings(rString, nIDS, &lpsz1, 1);
}

/*+-------------------------------------------------------------------------*
 *
 * FormatString2
 *
 * PURPOSE: Similar to AfxFormatString2, but uses GetStringModule() instead 
 *          of AfxGetModuleInstance()                                       
 *
 * PARAMETERS: 
 *    CString& rString :
 *    UINT     nIDS :
 *    LPCTSTR  lpsz1 :
 *    LPCTSTR  lpsz2 :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void FormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1, LPCTSTR lpsz2)
{
	LPCTSTR rglpsz[2];
	rglpsz[0] = lpsz1;
	rglpsz[1] = lpsz2;
	FormatStrings(rString, nIDS, rglpsz, 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\strtable.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      strtable.cpp
 *
 *  Contents:  Implementation file for CStringTable
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "strtable.h"
#include "macros.h"
#include "comdbg.h"
#include "amcdoc.h"


// {71E5B33E-1064-11d2-808F-0000F875A9CE}
const CLSID CLSID_MMC =
{ 0x71e5b33e, 0x1064, 0x11d2, { 0x80, 0x8f, 0x0, 0x0, 0xf8, 0x75, 0xa9, 0xce } };

const WCHAR CMasterStringTable::s_pszIDPoolStream[]  = L"ID Pool";
const WCHAR CMasterStringTable::s_pszStringsStream[] = L"Strings";

#ifdef DBG
CTraceTag tagStringTable (_T("StringTable"), _T("StringTable"));
#endif  // DBG


/*+-------------------------------------------------------------------------*
 * IsBadString
 *
 *
 *--------------------------------------------------------------------------*/

inline static bool IsBadString (LPCWSTR psz)
{
    if (psz == NULL)
        return (true);

    return (::IsBadStringPtrW (psz, -1) != 0);
}


/*+-------------------------------------------------------------------------*
 * TStringFromCLSID
 *
 *
 *--------------------------------------------------------------------------*/

static LPTSTR TStringFromCLSID (LPTSTR pszClsid, const CLSID& clsid)
{
    const int cchClass = 40;

#ifdef UNICODE
    StringFromGUID2 (clsid, pszClsid, cchClass);
#else
    USES_CONVERSION;
    WCHAR wzClsid[cchClass];
    StringFromGUID2 (clsid, wzClsid, cchClass);
    _tcscpy (pszClsid, W2T (wzClsid));
#endif

    return (pszClsid);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 *
 *--------------------------------------------------------------------------*/

inline IStream& operator>> (IStream& stm, CEntry& entry)
{
    return (stm >> entry.m_id >> entry.m_cRefs >> entry.m_str);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CEntry to a stream.  The format is:
 *
 *      DWORD   string ID
 *      DWORD   reference count
 *      DWORD   string length (character count)
 *      WCHAR[] characters in the strings, *not* NULL-terminated
 *
 *--------------------------------------------------------------------------*/

inline IStream& operator<< (IStream& stm, const CEntry& entry)
{
    return (stm << entry.m_id << entry.m_cRefs << entry.m_str);
}

/*+-------------------------------------------------------------------------*
 * CEntry::Persist
 *
 *
 *--------------------------------------------------------------------------*/
void CEntry::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_ID,    m_id);
    persistor.PersistAttribute(XML_ATTR_STRING_TABLE_STR_REFS,  m_cRefs);
    persistor.PersistContents(m_str); 
}

/*+-------------------------------------------------------------------------*
 * CEntry::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CEntry::Dump () const
{
    USES_CONVERSION;
    Trace (tagStringTable, _T("id=%d, refs=%d, string=\"%s\""),
           m_id, m_cRefs, W2CT (m_str.data()));
}

#endif


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::CMasterStringTable
 *
 * Even though a MMC_STRING_ID is a DWORD, we want to make sure the high
 * word is 0, to keep open the possibility that we can use something like
 * MAKEINTRESOURCE in the future.  To do this, set USHRT_MAX as the
 * maximum string ID.
 *--------------------------------------------------------------------------*/

CMasterStringTable::CMasterStringTable ()
    : m_IDPool (1, USHRT_MAX)
{
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::~CMasterStringTable
 *
 *
 *--------------------------------------------------------------------------*/

CMasterStringTable::~CMasterStringTable ()
{
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::AddString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::AddString (
    LPCOLESTR       pszAdd,
    MMC_STRING_ID*  pID,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    /*
     * If this the first string added for this CLSID,
     * we need to create a new string table.
     */
    if (pStringTable == NULL)
    {
        CStringTable    table (&m_IDPool);
        TableMapValue   value (*pclsid, table);

        CLSIDToStringTableMap::_Pairib rc = m_TableMap.insert (value);

        /*
         * we should have actually inserted the new table
         */
        ASSERT (rc.second);

        pStringTable = &(rc.first->second);
        ASSERT (pStringTable != NULL);
    }

    HRESULT hr = pStringTable->AddString (pszAdd, pID);

#ifdef DBG
    if (SUCCEEDED (hr))
    {
        USES_CONVERSION;
        TCHAR szClsid[40];
        Trace (tagStringTable, _T("Added \"%s\" (id=%d) for %s"),
               W2CT(pszAdd), (int) *pID, TStringFromCLSID (szClsid, *pclsid));
        Dump();
    }
#endif

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::GetString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::GetString (
    MMC_STRING_ID   id,
    ULONG           cchBuffer,
    LPOLESTR        lpBuffer,
    ULONG*          pcchOut,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->GetString (id, cchBuffer, lpBuffer, pcchOut));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::GetStringLength
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::GetStringLength (
    MMC_STRING_ID   id,
    ULONG*          pcchString,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->GetStringLength (id, pcchString));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::DeleteString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::DeleteString (
    MMC_STRING_ID   id,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    HRESULT hr = pStringTable->DeleteString (id);

    TCHAR szClsid[40];
    Trace (tagStringTable, _T("Deleted string %d for %s"), (int) id, TStringFromCLSID (szClsid, *pclsid));
    Dump();

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::DeleteAllStrings
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::DeleteAllStrings (
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

#include "pushwarn.h"
#pragma warning(disable: 4553)      // "==" operator has no effect
    VERIFY (pStringTable->DeleteAllStrings () == S_OK);
    VERIFY (m_TableMap.erase (*pclsid) == 1);
#include "popwarn.h"

    TCHAR szClsid[40];
    Trace (tagStringTable, _T("Deleted all strings for %s"), TStringFromCLSID (szClsid, *pclsid));
    Dump();

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::FindString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::FindString (
    LPCOLESTR       pszFind,
    MMC_STRING_ID*  pID,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->FindString (pszFind, pID));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::Enumerate
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMasterStringTable::Enumerate (
    IEnumString**   ppEnum,
    const CLSID*    pclsid)
{
    if (pclsid == NULL)
        pclsid = &CLSID_MMC;

    if (IsBadReadPtr (pclsid, sizeof(*pclsid)))
        return (E_INVALIDARG);

    CStringTable* pStringTable = LookupStringTableByCLSID (pclsid);

    if (pStringTable == NULL)
        return (E_FAIL);

    return (pStringTable->Enumerate (ppEnum));
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::LookupStringTableByCLSID
 *
 * Returns a pointer to the string table for a given CLSID, or NULL if
 * there isn't a corresponding string in the string table.
 *--------------------------------------------------------------------------*/

CStringTable* CMasterStringTable::LookupStringTableByCLSID (const CLSID* pclsid) const
{
    CLSIDToStringTableMap::iterator it = m_TableMap.find (*pclsid);

    if (it == m_TableMap.end())
        return (NULL);

    return (&it->second);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CMasterStringTable from a storage.
 *--------------------------------------------------------------------------*/

IStorage& operator>> (IStorage& stg, CMasterStringTable& mst)
{
    DECLARE_SC (sc, _T("operator>> (IStorage& stg, CMasterStringTable& mst)"));

    HRESULT hr;
    IStreamPtr spStream;

    /*
     * read the available IDs
     */
    hr = OpenDebugStream (&stg, CMasterStringTable::s_pszIDPoolStream,
                         STGM_SHARE_EXCLUSIVE | STGM_READ,
                         &spStream);

    THROW_ON_FAIL (hr);
    spStream >> mst.m_IDPool;

    /*
     * read the CLSIDs and the strings
     */
    hr = OpenDebugStream (&stg, CMasterStringTable::s_pszStringsStream,
                         STGM_SHARE_EXCLUSIVE | STGM_READ, 
                         &spStream);

    THROW_ON_FAIL (hr);

#if 1
    /*
     * clear out the current table
     */
    mst.m_TableMap.clear();

    /*
     * read the CLSID count
     */
    DWORD cClasses;
    *spStream >> cClasses;

    while (cClasses-- > 0)
    {
        /*
         * read the CLSID...
         */
        CLSID clsid;
        spStream >> clsid;

        /*
         * ...and the string table
         */
        CStringTable table (&mst.m_IDPool, spStream);

        /*
         * insert the string table into the CLSID map
         */
        TableMapValue value (clsid, table);
        VERIFY (mst.m_TableMap.insert(value).second);
    }
#else
    /*
     * Can't use this because there's no default ctor for CStringTable
     */
    *spStream >> mst.m_TableMap;
#endif

    /*
     * Generate the list of stale IDs.  
     */

    sc = mst.ScGenerateIDPool ();
    if (sc)
        return (stg);

    mst.Dump();
    return (stg);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::ScGenerateIDPool 
 *
 * Generates the list of stale string IDs for this CMasterStringTable.  
 * The set of stale IDs is the entire set of IDs, minus the available IDs,
 * minus the in-use IDs.
 *--------------------------------------------------------------------------*/

SC CMasterStringTable::ScGenerateIDPool ()
{
    /*
     * Step 1:  build up a RangeList of the in-use IDs
     */
    DECLARE_SC (sc, _T("CMasterStringTable::ScGenerateIDPool"));
    CStringIDPool::RangeList                lInUseIDs;
    CLSIDToStringTableMap::const_iterator   itTable;

    for (itTable = m_TableMap.begin(); itTable != m_TableMap.end(); ++itTable)
    {
        const CStringTable& st = itTable->second;

        sc = st.ScCollectInUseIDs (lInUseIDs);
        if (sc)
            return (sc);
    }

    /*
     * Step 2:  give the in-use IDs to the ID pool so it can merge it 
     * with the available IDs (which it already has) to generate the 
     * list of stale IDs
     */
    sc = m_IDPool.ScGenerate (lInUseIDs);
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CMasterStringTable::Persist
 *
 * PURPOSE: persists the CMasterStringTable object to the specified persistor.
 *
 * PARAMETERS: 
 *    CPersistor & persistor :
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CMasterStringTable::Persist(CPersistor & persistor)
{
    DECLARE_SC(sc, TEXT("CMasterStringTable::Persist"));

    // purge unused snapins not to save what's already gone
    sc = ScPurgeUnusedStrings();
    if (sc)
        sc.Throw();

    persistor.Persist(m_IDPool); 
    m_TableMap.PersistSelf(&m_IDPool, persistor);
    if (persistor.IsLoading())
        ScGenerateIDPool ();
}


/***************************************************************************\
 *
 * METHOD:  CMasterStringTable::ScPurgeUnusedStrings
 *
 * PURPOSE: removes entries for snapins what aren't in use anymore
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMasterStringTable::ScPurgeUnusedStrings()
{
    DECLARE_SC(sc, TEXT("CMasterStringTable::ScPurgeUnusedStrings"));

    // det to the currfent document
    CAMCDoc* pAMCDoc = CAMCDoc::GetDocument();
    sc = ScCheckPointers(pAMCDoc, E_UNEXPECTED);
    if (sc)
        return sc;

    // get the access to scope tree
    IScopeTree *pScopeTree = pAMCDoc->GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // now iterate thru entries removing those belonging
    // to snapins already gone.
    CLSIDToStringTableMap::iterator it = m_TableMap.begin();
    while (it != m_TableMap.end())
    {
        // special case for internal guid
        if (IsEqualGUID(it->first, CLSID_MMC))
        {
            ++it;   // simply skip own stuff
        }
        else
        {
            // ask the scope tree if snapin is in use
            BOOL bInUse = FALSE;
            sc = pScopeTree->IsSnapinInUse(it->first, &bInUse);
            if (sc)
                return sc;

            // act depending on usage
            if (bInUse)
            {
                ++it;   // skip also the stuff currently in use
            }
            else 
            {
                // to the trash can
                sc = it->second.DeleteAllStrings();
                if (sc)
                    return sc;

                it = m_TableMap.erase(it);
            }
        }
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CMasterStringTable to a storage.
 *
 * It is written into two streams: "ID Pool" and "Strings".
 *
 * "ID Pool" contains the list of available string IDs remaining in the
 * string table.  Its format is defined by CIdentifierPool.
 *
 * "Strings" contains the strings.  The format is:
 *
 *      DWORD   count of string tables
 *      [n string tables]
 *
 * The format for each string is defined by operator<<(TableMapValue).
 *--------------------------------------------------------------------------*/

IStorage& operator<< (IStorage& stg, const CMasterStringTable& mst)
{
    HRESULT hr;
    IStreamPtr spStream;

    /*
     * write the available IDs
     */
    hr = CreateDebugStream (&stg, CMasterStringTable::s_pszIDPoolStream,
                           STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_WRITE,
                           &spStream);

    THROW_ON_FAIL (hr);
    spStream << mst.m_IDPool;


    /*
     * write the string tables
     */
    hr = CreateDebugStream (&stg, CMasterStringTable::s_pszStringsStream,
                           STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_WRITE,
                           &spStream);

    THROW_ON_FAIL (hr);
    *spStream << mst.m_TableMap;

    return (stg);
}


/*+-------------------------------------------------------------------------*
 * CMasterStringTable::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CMasterStringTable::Dump () const
{
    Trace (tagStringTable, _T("Contents of CMasterStringTable at 0x08%x"), this);

    m_IDPool.Dump();

    CLSIDToStringTableMap::const_iterator it;

    for (it = m_TableMap.begin(); it != m_TableMap.end(); ++it)
    {
        TCHAR szClsid[40];
        const CLSID&        clsid = it->first;
        const CStringTable& st    = it->second;

        Trace (tagStringTable, _T("%d strings for %s:"),
               st.size(), TStringFromCLSID (szClsid, clsid));
        st.Dump();
    }
}

#endif




/*+-------------------------------------------------------------------------*
 * CStringTable::CStringTable
 *
 *
 *--------------------------------------------------------------------------*/

CStringTable::CStringTable (CStringIDPool* pIDPool)
    : m_pIDPool (pIDPool),
      CStringTable_base(m_Entries, XML_TAG_STRING_TABLE)
{
    ASSERT_VALID_(this);
}

CStringTable::CStringTable (CStringIDPool* pIDPool, IStream& stm)
    : m_pIDPool (pIDPool),
      CStringTable_base(m_Entries, XML_TAG_STRING_TABLE)
{
    stm >> *this;
    ASSERT_VALID_(this);
}

/*+-------------------------------------------------------------------------*
 * CStringTable::~CStringTable
 *
 *
 *--------------------------------------------------------------------------*/

CStringTable::~CStringTable ()
{
}


/*+-------------------------------------------------------------------------*
 * CStringTable::CStringTable
 *
 * Copy constructor
 *--------------------------------------------------------------------------*/

CStringTable::CStringTable (const CStringTable& other)
    :   m_Entries (other.m_Entries),
        m_pIDPool (other.m_pIDPool),
        CStringTable_base(m_Entries, XML_TAG_STRING_TABLE)
{
    ASSERT_VALID_(&other);
    IndexAllEntries ();
    ASSERT_VALID_(this);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::operator=
 *
 * Assignment operator
 *--------------------------------------------------------------------------*/

CStringTable& CStringTable::operator= (const CStringTable& other)
{
    ASSERT_VALID_(&other);

    if (&other != this)
    {
        m_Entries = other.m_Entries;
        m_pIDPool = other.m_pIDPool;
        IndexAllEntries ();
    }

    ASSERT_VALID_(this);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::AddString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::AddString (
    LPCOLESTR       pszAdd,
    MMC_STRING_ID*  pID)
{
    /*
     * validate the parameters
     */
    if (IsBadString (pszAdd))
        return (E_INVALIDARG);

    if (IsBadWritePtr (pID, sizeof (*pID)))
        return (E_INVALIDARG);

    std::wstring strAdd = pszAdd;

    /*
     * check to see if there's already an entry for this string
     */
    EntryList::iterator itEntry = LookupEntryByString (strAdd);


    /*
     * if there's not an entry for this string, add one
     */
    if (itEntry == m_Entries.end())
    {
        /*
         * add the entry to the list
         */
        try
        {
            CEntry EntryToInsert (strAdd, m_pIDPool->Reserve());

            itEntry = m_Entries.insert (FindInsertionPointForEntry (EntryToInsert),
                                        EntryToInsert);
            ASSERT (itEntry->m_cRefs == 0);
        }
        catch (CStringIDPool::pool_exhausted&)
        {
            return (E_OUTOFMEMORY);
        }

        /*
         * add the new entry to the indices
         */
        IndexEntry (itEntry);
    }


    /*
     * Bump the ref count for this string.  The ref count for
     * new strings is 0, so we won't have ref counting problems.
     */
    ASSERT (itEntry != m_Entries.end());
    itEntry->m_cRefs++;

    *pID = itEntry->m_id;

    ASSERT_VALID_(this);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::GetString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::GetString (
    MMC_STRING_ID   id,
    ULONG           cchBuffer,
    LPOLESTR        lpBuffer,
    ULONG*          pcchOut) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (cchBuffer == 0)
        return (E_INVALIDARG);

    if (IsBadWritePtr (lpBuffer, cchBuffer * sizeof (*lpBuffer)))
        return (E_INVALIDARG);

    if ((pcchOut != NULL) && IsBadWritePtr (pcchOut, sizeof (*pcchOut)))
        return (E_INVALIDARG);

    /*
     * find the entry for this string ID
     */
    EntryList::iterator itEntry = LookupEntryByID (id);

    if (itEntry == m_Entries.end())
        return (E_FAIL);

    /*
     * copy to the user's buffer and make sure it's terminated
     */
    wcsncpy (lpBuffer, itEntry->m_str.data(), cchBuffer);
    lpBuffer[cchBuffer-1] = 0;

    /*
     * if the caller wants the write count, give it to him
     */
    if ( pcchOut != NULL)
        *pcchOut = wcslen (lpBuffer);

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::GetStringLength
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::GetStringLength (
    MMC_STRING_ID   id,
    ULONG*          pcchString) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (IsBadWritePtr (pcchString, sizeof (*pcchString)))
        return (E_INVALIDARG);

    /*
     * find the entry for this string ID
     */
    EntryList::iterator itEntry = LookupEntryByID (id);

    if (itEntry == m_Entries.end())
        return (E_FAIL);

    *pcchString = itEntry->m_str.length();

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::DeleteString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::DeleteString (
    MMC_STRING_ID   id)
{
    /*
     * find the entry for this string ID
     */
    EntryList::iterator itEntry = LookupEntryByID (id);

    if (itEntry == m_Entries.end())
        return (E_FAIL);

    /*
     * Decrement the ref count.  If it goes to zero, we can remove the
     * string entirely.
     */
    if (--itEntry->m_cRefs == 0)
    {
        /*
         * remove the string from the indices
         */
        m_StringIndex.erase (itEntry->m_str);
        m_IDIndex.erase     (itEntry->m_id);

        /*
         * return the string ID to the ID pool and remove the entry
         */
        VERIFY (m_pIDPool->Release (itEntry->m_id));
        m_Entries.erase (itEntry);
    }

    ASSERT_VALID_(this);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::DeleteAllStrings
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::DeleteAllStrings ()
{
    /*
     * return all string IDs to the ID pool
     */
    std::for_each (m_Entries.begin(), m_Entries.end(),
                   IdentifierReleaser (*m_pIDPool));

    /*
     * wipe everything clean
     */
    m_Entries.clear ();
    m_StringIndex.clear ();
    m_IDIndex.clear ();

    ASSERT_VALID_(this);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::FindString
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::FindString (
    LPCOLESTR       pszFind,
    MMC_STRING_ID*  pID) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (IsBadString (pszFind))
        return (E_INVALIDARG);

    if (IsBadWritePtr (pID, sizeof (*pID)))
        return (E_INVALIDARG);

    /*
     * look up the string
     */
    EntryList::iterator itEntry = LookupEntryByString (pszFind);

    /*
     * no entry? fail
     */
    if (itEntry == m_Entries.end())
        return (E_FAIL);

    *pID = itEntry->m_id;

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::Enumerate
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringTable::Enumerate (
    IEnumString**   ppEnum) const
{
    ASSERT_VALID_(this);

    /*
     * validate the parameters
     */
    if (IsBadWritePtr (ppEnum, sizeof (*ppEnum)))
        return (E_INVALIDARG);

    /*
     * Create the new CStringEnumerator object
     */
    CComObject<CStringEnumerator>* pEnumerator;
    HRESULT hr = CStringEnumerator::CreateInstanceWrapper(&pEnumerator, ppEnum);

    if (FAILED (hr))
        return (hr);

    /*
     * initialize it
     */
    ASSERT (pEnumerator != NULL);
    pEnumerator->Init (m_Entries);
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::IndexEntry
 *
 * Adds an EntryList entry to the by-string and by-ID indices maintained
 * for the EntryList.
 *--------------------------------------------------------------------------*/

void CStringTable::IndexEntry (EntryList::iterator itEntry)
{
    /*
     * the entry shouldn't be in any of the indices yet
     */
    ASSERT (m_StringIndex.find (itEntry->m_str) == m_StringIndex.end());
    ASSERT (m_IDIndex.find     (itEntry->m_id)  == m_IDIndex.end());

    /*
     * add the entry to the indices
     */
    m_StringIndex[itEntry->m_str] = itEntry;
    m_IDIndex    [itEntry->m_id]  = itEntry;
}


/*+-------------------------------------------------------------------------*
 * CStringTable::LookupEntryByString
 *
 * Returns an iterator to the string table entry for a given string, or
 * m_Entries.end() if there isn't an entry for the ID.
 *--------------------------------------------------------------------------*/

EntryList::iterator
CStringTable::LookupEntryByString (const std::wstring& str) const
{
    StringToEntryMap::iterator it = m_StringIndex.find (str);

    if (it == m_StringIndex.end())
        return (m_Entries.end());

    return (it->second);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::LookupEntryByID
 *
 * Returns an iterator to the string table entry for a given string ID, or
 * m_Entries.end() if there isn't an entry for the ID.
 *--------------------------------------------------------------------------*/

EntryList::iterator
CStringTable::LookupEntryByID (MMC_STRING_ID id) const
{
    IDToEntryMap::iterator it = m_IDIndex.find (id);

    if (it == m_IDIndex.end())
        return (m_Entries.end());

    return (it->second);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CStringTable from a storage.
 *--------------------------------------------------------------------------*/

IStream& operator>> (IStream& stm, CStringTable& table)
{
    stm >> table.m_Entries;

    /*
     * rebuild the by-string and by-ID indices
     */
    EntryList::iterator it;
    table.m_StringIndex.clear();
    table.m_IDIndex.clear();

    for (it = table.m_Entries.begin(); it != table.m_Entries.end(); ++it)
    {
        table.IndexEntry (it);
    }

#ifdef DBG
    CStringTable::AssertValid (&table);
#endif

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CStringTable to a stream.  The format is:
 *
 *      DWORD   count of string entries
 *      [n string entries]
 *
 * The format of each string entry is controled by operator<<(CEntry).
 *--------------------------------------------------------------------------*/

IStream& operator<< (IStream& stm, const CStringTable& table)
{
    return (stm << table.m_Entries);
}

/*+-------------------------------------------------------------------------*
 * CStringTable::FindInsertionPointForEntry
 *
 *
 *--------------------------------------------------------------------------*/

EntryList::iterator CStringTable::FindInsertionPointForEntry (
    const CEntry& entry) const
{
    return (std::lower_bound (m_Entries.begin(), m_Entries.end(),
                              entry, CompareEntriesByID()));
}


/*+-------------------------------------------------------------------------*
 * CStringTable::ScCollectInUseIDs 
 *
 *
 *--------------------------------------------------------------------------*/

SC CStringTable::ScCollectInUseIDs (CStringIDPool::RangeList& rl) const
{
    DECLARE_SC (sc, _T("CStringTable::ScCollectInUseIDs"));
    EntryList::iterator it;

    for (it = m_Entries.begin(); it != m_Entries.end(); ++it)
    {
        if (!CStringIDPool::AddToRangeList (rl, it->m_id))
            return (sc = E_FAIL);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CStringTable::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CStringTable::Dump () const
{
    EntryList::const_iterator it;

    for (it = m_Entries.begin(); it != m_Entries.end(); ++it)
    {
        it->Dump();
    }
}

#endif


/*+-------------------------------------------------------------------------*
 * CStringTable::AssertValid
 *
 * Asserts the validity of a CStringTable object.  It is pretty slow,
 * O(n * logn)
 *--------------------------------------------------------------------------*/

#ifdef DBG

void CStringTable::AssertValid (const CStringTable* pTable)
{
    ASSERT (pTable != NULL);
    ASSERT (pTable->m_pIDPool != NULL);
    ASSERT (pTable->m_Entries.size() == pTable->m_StringIndex.size());
    ASSERT (pTable->m_Entries.size() == pTable->m_IDIndex.size());

    EntryList::iterator it;
    EntryList::iterator itPrev;

    /*
     * for each string in the list, make sure the string index
     * and the ID index point to the string
     */
    for (it = pTable->m_Entries.begin(); it != pTable->m_Entries.end(); ++it)
    {
        /*
         * there should be at least one reference to the string
         */
        ASSERT (it->m_cRefs > 0);

        /*
         * make sure the IDs are in ascending order (to aid debugging)
         */
        if (it != pTable->m_Entries.begin())
            ASSERT (it->m_id > itPrev->m_id);

        /*
         * validate the string index
         */
        ASSERT (pTable->LookupEntryByString (it->m_str) == it);

        /*
         * validate the ID index
         */
        ASSERT (pTable->LookupEntryByID (it->m_id) == it);

        itPrev = it;
    }
}

#endif // DBG



/*+-------------------------------------------------------------------------*
 * CStringEnumerator::CStringEnumerator
 *
 *
 *--------------------------------------------------------------------------*/

CStringEnumerator::CStringEnumerator ()
{
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::~CStringEnumerator
 *
 *
 *--------------------------------------------------------------------------*/

CStringEnumerator::~CStringEnumerator ()
{
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Init
 *
 *
 *--------------------------------------------------------------------------*/

bool CStringEnumerator::Init (const EntryList& entries)
{
    m_cStrings      = entries.size();
    m_nCurrentIndex = 0;

    if (m_cStrings > 0)
    {
        /*
         * pre-set the size of the vector to optimize allocation
         */
        m_Strings.reserve (m_cStrings);

        for (EntryList::iterator it = entries.begin(); it != entries.end(); ++it)
            m_Strings.push_back (it->m_str);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Next
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Next (ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    DECLARE_SC(sc, TEXT("CStringEnumerator::Next"));

    /*
     * validate the parameters
     */
    if ((celt > 0) && IsBadWritePtr (rgelt, celt * sizeof (*rgelt)))
        return (sc = E_INVALIDARG).ToHr();

    if ((pceltFetched != NULL) && IsBadWritePtr (pceltFetched, sizeof (*pceltFetched)))
        return (sc = E_INVALIDARG).ToHr();


    IMallocPtr spMalloc;
    sc = CoGetMalloc (1, &spMalloc);

    if (sc)
        return sc.ToHr();


    /*
     * allocate copies of the next celt strings
     */
    for (int i = 0; (celt > 0) && (m_nCurrentIndex < m_Strings.size()); i++)
    {
        int cchString = m_Strings[m_nCurrentIndex].length();
        int cbAlloc   = (cchString + 1) * sizeof (WCHAR);
        rgelt[i] = (LPOLESTR) spMalloc->Alloc (cbAlloc);

        /*
         * couldn't get the buffer, free the ones we've allocated so far
         */
        if (rgelt[i] == NULL)
        {
            while (--i >= 0)
                spMalloc->Free (rgelt[i]);

            return (sc = E_OUTOFMEMORY).ToHr();
        }

        /*
         * copy this string and bump to the next one
         */
        sc = StringCbCopyW(rgelt[i], cbAlloc, m_Strings[m_nCurrentIndex].data());
        if (sc)
            return sc.ToHr();

        m_nCurrentIndex++;
        celt--;
    }

    if ( pceltFetched != NULL)
        *pceltFetched = i;

    return ((celt == 0) ? S_OK : S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Skip
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Skip (ULONG celt)
{
    ULONG cSkip = min (celt, m_cStrings - m_nCurrentIndex);
    m_nCurrentIndex += cSkip;
    ASSERT (m_nCurrentIndex <= m_cStrings);

    return ((cSkip == celt) ? S_OK : S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Reset
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Reset ()
{
    m_nCurrentIndex = 0;
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::Clone
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CStringEnumerator::Clone (IEnumString **ppEnum)
{
    /*
     * Create the new CStringEnumerator object
     */
    CComObject<CStringEnumerator>* pEnumerator;
    HRESULT hr = CStringEnumerator::CreateInstanceWrapper (&pEnumerator, ppEnum);

    if (FAILED (hr))
        return (hr);

    /*
     * copy to the CStringEnuerator part of the new CComObect from this
     */
    ASSERT (pEnumerator != NULL);
    CStringEnumerator& rEnum = *pEnumerator;

    rEnum.m_cStrings      = m_cStrings;
    rEnum.m_nCurrentIndex = m_nCurrentIndex;
    rEnum.m_Strings       = m_Strings;

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CStringEnumerator::CreateInstance
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CStringEnumerator::CreateInstanceWrapper(
    CComObject<CStringEnumerator>** ppEnumObject,
    IEnumString**                   ppEnumIface)
{
    /*
     * Create the new CStringEnumerator object
     */
    HRESULT hr = CComObject<CStringEnumerator>::CreateInstance(ppEnumObject);

    if (FAILED (hr))
        return (hr);

    /*
     * get the IEnumString interface for the caller
     */
    ASSERT ((*ppEnumObject) != NULL);
    return ((*ppEnumObject)->QueryInterface (IID_IEnumString,
                                             reinterpret_cast<void**>(ppEnumIface)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\strtable.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1998.
 *
 *  File:      strtable.inl
 *
 *  Contents:  Inline functions for strtable.h
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STRTABLE_INL
#define STRTABLE_INL
#pragma once

#include "macros.h"     // for THROW_ON_FAIL
#include "stgio.h"



/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a IdentifierRange<T> from a stream.
 *--------------------------------------------------------------------------*/

template<class T>
inline IStream& operator>> (IStream& stm, IdentifierRange<T>& range)
{
    stm >> range.idMin >> range.idMax;

    if (range.idMin > range.idMax)
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a IdentifierRange<T> to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
inline IStream& operator<< (IStream& stm, const IdentifierRange<T>& range)
{
    return (stm << range.idMin << range.idMax);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::CIdentifierPool
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
inline CIdentifierPool<T>::CIdentifierPool (T idMin_, T idMax_)
    :   m_idAbsoluteMin   (idMin_),
        m_idAbsoluteMax   (idMax_),
        m_idNextAvailable (idMin_)
{
    ASSERT (m_idAbsoluteMin <= m_idAbsoluteMax);
    m_AvailableIDs.push_front (Range (m_idAbsoluteMin, m_idAbsoluteMax));

    ASSERT (m_StaleIDs.empty());
}

template<class T>
inline CIdentifierPool<T>::CIdentifierPool (IStream& stm)
{
    stm >> *this;
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::Reserve
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
T CIdentifierPool<T>::Reserve ()
{
    /*
     * if no more IDs are available, recycle the stale IDs
     */
    if (m_AvailableIDs.empty())
    {
        m_AvailableIDs.splice (m_AvailableIDs.end(), m_StaleIDs);
        ASSERT (m_StaleIDs.empty());
    }

    /*
     * if still no more IDs are available, throw an exception
     */
    if (m_AvailableIDs.empty())
        throw (pool_exhausted());

    /*
     * get the first ID from the first ID range
     */
    Range& FirstRange = m_AvailableIDs.front();
    T idReserved = FirstRange.idMin;

    /*
     * if we get here, we're going to return an ID, make sure it's the one
     * we though it was going to be
     */
    ASSERT (idReserved == m_idNextAvailable);

    /*
     * if the first ID range is now empty, remove it; otherwise,
     * remove the ID we just reserved from the available range
     */
    if (FirstRange.idMin == FirstRange.idMax)
        m_AvailableIDs.pop_front();
    else
        FirstRange.idMin++;

    /*
     * remember the next available ID
     */
    if (!m_AvailableIDs.empty())
        m_idNextAvailable = m_AvailableIDs.front().idMin;
    else if (!m_StaleIDs.empty())
        m_idNextAvailable = m_StaleIDs.front().idMin;
    else
        m_idNextAvailable = m_idAbsoluteMin;

    return (idReserved);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::Release
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::Release (T idRelease)
{
    /*
     * if the ID to be released falls outside
     * the range managed by this pool, fail
     */
    if ((idRelease < m_idAbsoluteMin) || (idRelease > m_idAbsoluteMax))
    {
        ASSERT (false);
        return (false);
    }

    /*
     * put the released ID in the stale pool
     */
    return (AddToRangeList (m_StaleIDs, idRelease));
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::IsValid
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::IsValid () const
{
    if (m_idAbsoluteMin > m_idAbsoluteMax)
        return (false);

    if (!IsRangeListValid (m_AvailableIDs))
        return (false);

    if (!IsRangeListValid (m_StaleIDs))
        return (false);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::IsRangeListValid
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::IsRangeListValid (const RangeList& rl) const
{
    RangeList::const_iterator it;

    for (it = rl.begin(); it != rl.end(); ++it)
    {
        if ((it->idMin < m_idAbsoluteMin) ||
            (it->idMax > m_idAbsoluteMax))
            return (false);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::ScGenerate
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
SC CIdentifierPool<T>::ScGenerate (const RangeList& rlInUseIDs)
{
    DECLARE_SC (sc, _T("CIdentifierPool<T>::ScGenerate"));
    m_AvailableIDs.clear();
    m_StaleIDs.clear();

    /*
     * Invert the in-use IDs.  We'll then have a collection of all the
     * ID's that are not in use.  Note that not all of these ID's are
     * necessarily "available", since some may be stale.
     */
    RangeList rlNotInUseIDs = rlInUseIDs;
    sc = ScInvertRangeList (rlNotInUseIDs);
    if (sc)
        return (sc);

    /*
     * Find the range containing the next available ID.
     */
    RangeList::iterator it;

    for (it = rlNotInUseIDs.begin(); it != rlNotInUseIDs.end(); ++it)
    {
		/*
		 * if this range contains the next available ID, we've found a hit
		 */
		if ((m_idNextAvailable >= it->idMin) && (m_idNextAvailable <= it->idMax))
		{
			/*
			 * if the next available ID is at the beginning of this range,
			 * things are simple; we can just break out of the loop
			 */
			if (m_idNextAvailable == it->idMin)
				break;

			/*
			 * otherwise, we need to split the current range into two
			 * adjacent ranges so the code below that copies to the
			 * stale and available ranges can work; then we can break out
			 * of the loop
			 */
			Range range (m_idNextAvailable, it->idMax);
			it->idMax = m_idNextAvailable - 1;
			it = rlNotInUseIDs.insert (++it, range);
			break;
		}
    }

    /*
     * confirm that we found one
     */
    ASSERT (it != rlNotInUseIDs.end());

    /*
     * everything before the next available ID that's not it use is stale;
     * everything after  the next available ID that's not in use is available;
     */
    std::copy (rlNotInUseIDs.begin(), it, std::back_inserter(m_StaleIDs));
    std::copy (it, rlNotInUseIDs.end(),   std::back_inserter(m_AvailableIDs));

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::AddToRangeList
 *
 * This adds an identifier to the specified range list.
 *
 * This really should be a member function on a RangeList class, like so:
 *
 *      class RangeList : public std::list<Range>
 *      {
 *      public:
 *          bool Add (const Range& rangeToAdd);
 *          bool Add (T tAdd);
 *      };
 *
 * but compiler bugs prevent it.
 *--------------------------------------------------------------------------*/

template<class T>
bool CIdentifierPool<T>::AddToRangeList (RangeList& rl, T idAdd)
{
    return (AddToRangeList (rl, Range (idAdd, idAdd)));
}

template<class T>
bool CIdentifierPool<T>::AddToRangeList (RangeList& l, const Range& rangeToAdd)
{
    RangeList::iterator it;

    for (it = l.begin(); it != l.end(); ++it)
    {
        Range& rangeT = *it;

        /*
         * the range to add shouldn't overlap the existing range in any way
         */
        if (((rangeToAdd.idMin >= rangeT.idMin) && (rangeToAdd.idMin <= rangeT.idMax)) ||
            ((rangeToAdd.idMax >= rangeT.idMin) && (rangeToAdd.idMax <= rangeT.idMax)))
        {
            ASSERT (false);
            return (false);
        }

        /*
         * If the range to add is immediately to the left of the current
         * range (that is, the upper bound of the range to add is immediately
         * adjacent to the lower bound of the current range), it can be
         * absorbed into the current range and we're done.
         *
         * Note that we don't have to worry about coalescing this range
         * with the preceeding range.  That case would have been covered
         * by the next clause, in the preceeding iteration of this loop.
         */
        if (rangeToAdd.idMax == (rangeT.idMin - 1))
        {
            rangeT.idMin = rangeToAdd.idMin;
            return (true);
        }


        /*
         * If the range to add is immediately to the right of the current
         * range (that is, the lower bound of the range to add is immediately
         * adjacent to the upper bound of the current range), it can be
         * absorbed into the current range and we're done.
         */
        else if (rangeToAdd.idMin == (rangeT.idMax + 1))
        {
            rangeT.idMax = rangeToAdd.idMax;

            /*
             * Now check the next available range (if there is one).
             * If it begins where the current range now ends, then
             * the two ranges can be coalesced into a single range.
             */
            if (++it != l.end())
            {
                Range& rangeNext = *it;
                ASSERT (rangeT.idMax < rangeNext.idMin);

                if (rangeT.idMax == (rangeNext.idMin - 1))
                {
                    rangeT.idMax = rangeNext.idMax;
                    l.erase (it);
                }
            }

            return (true);
        }


        /*
         * If the upper bound of the range to insert is less than the
         * lower bound of the current available range, we need to insert
         * the new range here. The insertion is handled outside the loop.
         */
        else if (rangeToAdd.idMax < rangeT.idMin)
            break;

    }

    /*
     * If we get here, then we need to create a new available range
     * to the left of the current iterator, which will address the
     * end of the list if the ID is greater than the current maximum
     * available ID.
     */
    ASSERT ((it == l.end()) || (rangeToAdd.idMax < (it->idMin - 1)));
    l.insert (it, rangeToAdd);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::ScInvertRangeList
 *
 * Changes rlInvert into a range list containing all elements between
 * m_idAbsoluteMin and m_idAbsoluteMax that were not originally in
 * rlInvert.
 *
 * So, if the range looks like this before inversion:
 *
 *                         +----+----+           +----+----+
 *   m_idAbsoluteMin       |  5 | 10 | --------> | 15 | 20 |    m_idAbsoluteMax
 *                         +----+----+           +----+----+
 *
 * it will look like this after inversion:
 *
 * +-----------------+----+           +----+----+           +----+-----------------+
 * | m_idAbsoluteMin |  4 | --------> | 11 | 14 | --------> | 21 | m_idAbsoluteMax |
 * +-----------------+----+           +----+----+           +----+-----------------+
 *--------------------------------------------------------------------------*/

template<class T>
SC CIdentifierPool<T>::ScInvertRangeList (RangeList& rlInvert) const
{
    DECLARE_SC (sc, _T("CIdentifierPool::ScInvertRangeList"));

    /*
     * if there's nothing in the list to invert, the inverted
     * list will contain a single range spanning min to max
     */
    if (rlInvert.empty())
    {
        rlInvert.push_front (Range (m_idAbsoluteMin, m_idAbsoluteMax));
        return (sc);
    }

    /*
     * determine whether we'll need to add ranges on the front or back,
     * and initialize the ranges we'll add if we will
     */
    Range rFirst;
    bool fAddFirstRange = (rlInvert.front().idMin > m_idAbsoluteMin);
    if (fAddFirstRange)
    {
        rFirst.idMin = m_idAbsoluteMin;
        rFirst.idMax = rlInvert.front().idMin - 1;
    }

    Range rLast;
    bool fAddLastRange = (rlInvert.back().idMax < m_idAbsoluteMax);
    if (fAddLastRange)
    {
        rLast.idMin = rlInvert.back().idMax + 1;
        rLast.idMax = m_idAbsoluteMax;
    }

    /*
     * Change rlInvert to contain ranges that represent the gaps
     * between the ranges it currently contains.  The size of rlInvert
     * will be one less than its original size when this process is
     * complete.
     */
    RangeList::iterator it     =   rlInvert.begin();
    RangeList::iterator itNext = ++rlInvert.begin();

    while (itNext != rlInvert.end())
    {
        /*
         * morph this range into the range representing the gap between
         * this range and the next one
         */
        it->idMin = it->idMax + 1;
        it->idMax = itNext->idMin - 1;

        /*
         * advance the iterators
         */
        it = itNext++;
    }

    /*
     * remove the extraneous node at the end of the list
     */
    rlInvert.pop_back();

    /*
     * append to the beginning and/or end, if necessary
     */
    if (fAddFirstRange)
        rlInvert.push_front (rFirst);

    if (fAddLastRange)
        rlInvert.push_back (rLast);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 * Reads a CIdentifierPool<T> from a stream
 *--------------------------------------------------------------------------*/

template<class T>
IStream& operator>> (IStream& stm, CIdentifierPool<T>& pool)
{
    /*
     * read the min and max IDs from the stream
     */
    stm >> pool.m_idAbsoluteMin >> pool.m_idAbsoluteMax;

    /*
     * read the available and stale IDs
     */
    stm >> pool.m_AvailableIDs >> pool.m_StaleIDs;

    /*
     * find out how big the stream is
     */
    STATSTG statstg;
    HRESULT hr = stm.Stat (&statstg, STATFLAG_NONAME);
    if (FAILED (hr))
        _com_issue_error (hr);

    /*
     * get our seek position
     */
    ULARGE_INTEGER  uliSeekPos;
    LARGE_INTEGER   liOffset;
    liOffset.QuadPart = 0;
    hr = stm.Seek (liOffset, STREAM_SEEK_CUR, &uliSeekPos);
    if (FAILED (hr))
        _com_issue_error (hr);

    /*
     * Older files won't have saved the next available ID.  If it's there,
     * read it; if not, use a default value for pool.m_idNextAvailable.
     */
    if (statstg.cbSize.QuadPart > uliSeekPos.QuadPart)
    {
        stm >> pool.m_idNextAvailable;
    }
    else
    {
        if (!pool.m_AvailableIDs.empty())
            pool.m_idNextAvailable = pool.m_AvailableIDs.front().idMin;
        else
            pool.m_idNextAvailable = pool.m_idAbsoluteMin;
    }

    /*
     * validate what we read
     */
    if (!pool.IsValid ())
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 * Writes a CIdentifierPool<T> to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
IStream& operator<< (IStream& stm, const CIdentifierPool<T>& pool)
{
    /*
     * write the min and max IDs to the stream
     */
    stm << pool.m_idAbsoluteMin << pool.m_idAbsoluteMax;

    /*
     * Write an empty collection of available and stale IDs to keep the
     * stream format the same as previous versions.  Beginning with MMC 2.0,
     * the available and stale IDs will be regenerated from the next available
     * ID and in-use IDs after the string table is read in.  This is done to
     * minimize the data that needs to be saved with the new XML file format.
     */
    CIdentifierPool<T>::RangeList rlEmpty;
    stm << rlEmpty;     // available IDs
    stm << rlEmpty;     // stale IDs

    /*
     * write the next available ID
     */
    stm << pool.m_idNextAvailable;

    return (stm);
}

template<class T>
void CIdentifierPool<T>::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_ID_POOL_ABSOLUTE_MIN, m_idAbsoluteMin);
    persistor.PersistAttribute(XML_ATTR_ID_POOL_ABSOLUTE_MAX, m_idAbsoluteMax);
    persistor.PersistAttribute(XML_ATTR_ID_POOL_NEXT_AVAILABLE, m_idNextAvailable);
}

/*+-------------------------------------------------------------------------*
 * CIdentifierPool<T>::Dump
 *
 *
 *--------------------------------------------------------------------------*/

#ifdef DBG

template<class T>
void CIdentifierPool<T>::DumpRangeList (const RangeList& l) const
{
    int cEntries = 0;

    for (RangeList::const_iterator it = l.begin(); it != l.end(); ++it)
    {
        Trace (tagStringTable, _T("Range %d:min=%d, max=%d"),
               ++cEntries, (int) it->idMin, (int) it->idMax);
    }
}

template<class T>
void CIdentifierPool<T>::Dump () const
{
    Trace (tagStringTable, _T("Next available ID: %d"), m_idNextAvailable);

    Trace (tagStringTable, _T("Available IDs:"));
    DumpRangeList (m_AvailableIDs);

    Trace (tagStringTable, _T("Stale IDs:"));
    DumpRangeList (m_StaleIDs);
}

#endif  // DBG


/*+-------------------------------------------------------------------------*
 * operator>>
 *
 *
 *--------------------------------------------------------------------------*/

inline IStorage& operator>> (IStorage& stg, CComObject<CMasterStringTable>& mst)
{
    return (stg >> static_cast<CMasterStringTable&>(mst));
}


/*+-------------------------------------------------------------------------*
 * operator<<
 *
 *
 *--------------------------------------------------------------------------*/

inline IStorage& operator<< (IStorage& stg, const CComObject<CMasterStringTable>& mst)
{
    return (stg << static_cast<const CMasterStringTable&>(mst));
}


#endif /* STRTABLE_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\subclass.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      subclass.cpp
 *
 *  Contents:  Implementation file for the dynamic subclass manager
 *
 *  History:   06-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "subclass.h"


/*
 * Add 0x00080000 to 
 * HKLM\Software\Microsoft\Windows\CurrentVersion\AdminDebug\AMCConUI
 * to enable debug output for this module
 */
#define DEB_SUBCLASS DEB_USER4



/*--------------------------------------------------------------------------*
 * SetWindowProc 
 *
 * Changes the window procedure for a window and returns the previous
 * window procedure.
 *--------------------------------------------------------------------------*/

static WNDPROC SetWindowProc (HWND hwnd, WNDPROC pfnNewWndProc)
{
    return ((WNDPROC) SetWindowLongPtr (hwnd, GWLP_WNDPROC,
                                        (LONG_PTR) pfnNewWndProc));
}



/*--------------------------------------------------------------------------*
 * GetWindowProc 
 *
 * Returns the window procedure for a window.
 *--------------------------------------------------------------------------*/

static WNDPROC GetWindowProc (HWND hwnd)
{
    return ((WNDPROC) GetWindowLongPtr (hwnd, GWLP_WNDPROC));
}



/*--------------------------------------------------------------------------*
 * GetSubclassManager
 *
 * Returns the one-and-only subclass manager for the app.
 *--------------------------------------------------------------------------*/

CSubclassManager& GetSubclassManager()
{
    static CSubclassManager mgr;
    return (mgr);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::SubclassWindow 
 *
 * Subclasses a window.
 *--------------------------------------------------------------------------*/

bool CSubclassManager::SubclassWindow (
    HWND hwnd, 
    CSubclasser* pSubclasser)
{
    /*
     * Set up the data structure that represents this subclass.
     */
    SubclasserData subclasser (pSubclasser, hwnd);

    /*
     * Get the subclass context for this window.  If this is the
     * first time this window is being subclassed, std::map will
     * create a map entry for it.
     */
    WindowContext& ctxt = m_ContextMap[hwnd];

    /*
     * If the subclass context's wndproc pointer is NULL, then this
     * is the first time we've subclassed this window.  We need to
     * physically subclass the window with CSubclassManager's subclass proc.
     */
    if (ctxt.pfnOriginalWndProc == NULL)
    {
        ctxt.pfnOriginalWndProc = SetWindowProc (hwnd, SubclassProc);
        ASSERT (ctxt.Subclassers.empty());
        Dbg (DEB_SUBCLASS, _T("CSubclassManager subclassed window 0x%08x\n"), hwnd);
    }

    /*
     * Otherwise, make sure this isn't a redundant subclass.
     */
    else
    {
        SubclasserList::iterator itEnd   = ctxt.Subclassers.end();
        SubclasserList::iterator itFound = std::find (ctxt.Subclassers.begin(), 
                                                      itEnd, subclasser);

        /*
         * Trying to subclass a window with a given subclasser twice?
         */
        if (itFound != itEnd)
        {
            ASSERT (false);
            return (false);
        }
    }

    /*
     * Add this subclasser to this windows subclasser list.
     */
    ctxt.Insert (subclasser);
    Dbg (DEB_SUBCLASS, _T("CSubclassManager added subclass proc for window 0x%08x\n"), hwnd);

    return (true);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::UnsubclassWindow 
 *
 * Unsubclasses a window.
 *--------------------------------------------------------------------------*/

bool CSubclassManager::UnsubclassWindow (
    HWND hwnd, 
    CSubclasser* pSubclasser)
{
    /*
     * Get the subclass context for this window.  Use map::find
     * instead of map::operator[] to avoid creating a map entry if
     * one doesn't exist already
     */
    ContextMap::iterator itContext = m_ContextMap.find (hwnd);

    /*
     * Trying to unsubclass a window that's not subclassed at all?
     */
    if (itContext == m_ContextMap.end())
        return (false);

    WindowContext& ctxt = itContext->second;

    /*
     * Set up the data structure that represents this subclass.
     */
    SubclasserData subclasser (pSubclasser, hwnd);

    /*
     * Trying to unsubclass a window that's not subclassed
     * by this subclasser?
     */
    SubclasserList::iterator itEnd        = ctxt.Subclassers.end();
    SubclasserList::iterator itSubclasser = std::find (ctxt.Subclassers.begin(), itEnd, subclasser);

    if (itSubclasser == itEnd)
    {
        ASSERT (false);
        return (false);
    }

    /*
     * Remove this subclasser
     */
    UINT cRefs = ctxt.Remove (*itSubclasser);

    if (cRefs == 0)
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager removed subclass proc for window 0x%08x\n"), hwnd);
    }
    else
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager zombied subclass proc for window 0x%08x, (cRefs=%d)\n"),
                            hwnd, cRefs);
    }

    /*
     * If we just removed the last subclasser, unsubclass the window
     * and remove the window's WindowContext from the map.
     */
    if (ctxt.Subclassers.empty() && !PhysicallyUnsubclassWindow (hwnd))
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager zombied window 0x%08x\n"), hwnd);
    }

    return (true);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::PhysicallyUnsubclassWindow 
 *
 * Physically removes CSubclassManager's subclass proc from the given
 * window if it is safe (or forced) to do so.
 *
 * It is safe to remove a subclass procedure A from a window W if no one 
 * has subclassed W after A.  In other words, subclasses have to be removed
 * in a strictly LIFO order, or there's big trouble.  
 *
 * To illustrate, let's say the A subclasses W.  Messages that A doesn't  
 * handle will be passed on to W's original window procedure that was in  
 * place when A subclassed W.  Call this original procedure O.  So        
 * messages flow from A to O:                                             
 *
 *      A -> O
 *
 * Now let's say that B subclasses the W.  B will pass messages on to A, 
 * so the messages now flow like so:                                     
 *
 *      B -> A -> O
 *
 * Now say that A no longer needs to subclass W.  The typical way to
 * unsubclass a window is to put back the original window procedure that
 * was in place at the time of subclassing.  In A's case that was O, so
 * messages destined for W now flow directly to O:
 *
 *      O
 *
 * This is the first problem:  B has been shorted out of the window's
 * message stream.
 *
 * The problem gets worse when B no longer needs to subclass W.  It will
 * put back the window procedure it found when it subclassed, namely A.
 * A's work no longer needs to be done, and there's no telling whether
 * A's conduit to O is still alive.  We don't want to get into this
 * situation.
 *--------------------------------------------------------------------------*/

bool CSubclassManager::PhysicallyUnsubclassWindow (
    HWND    hwnd,                       /* I:window to unsubclass           */
    bool    fForce /* =false */)        /* I:force the unsubclass?          */
{
    ContextMap::iterator itRemove = m_ContextMap.find(hwnd);

    /*
     * If we get here, this window had better be in the map.
     */
    ASSERT (itRemove != m_ContextMap.end());

    /*
     * If no one subclassed after CSubclassManager, it's safe to unsubclass.
     */
    if (GetWindowProc (hwnd) == SubclassProc)
    {
        const WindowContext& ctxt = itRemove->second;
        SetWindowProc (hwnd, ctxt.pfnOriginalWndProc);
        fForce = true;
        Dbg (DEB_SUBCLASS, _T("CSubclassManager unsubclassed window 0x%08x\n"), hwnd);
    }

    /*
     * Remove this window's entry from the context map if appropriate.
     */
    if (fForce)
        m_ContextMap.erase (itRemove);

    return (fForce);
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::SubclassProc 
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CALLBACK CSubclassManager::SubclassProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    return (GetSubclassManager().SubclassProcWorker (hwnd, msg, wParam, lParam));
}



/*--------------------------------------------------------------------------*
 * CSubclassManager::SubclassProcWorker
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CSubclassManager::SubclassProcWorker (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    /*
     * Get the subclass context for this window.  Use map::find
     * instead of map::operator[] to avoid excessive overhead in 
     * map::operator[]
     */
    ContextMap::iterator itContext = m_ContextMap.find (hwnd);

    /*
     * If we get here, this window had better be in the map.
     */
    ASSERT (itContext != m_ContextMap.end());

    WindowContext& ctxt = itContext->second;
    WNDPROC pfnOriginalWndProc = ctxt.pfnOriginalWndProc;

    bool    fPassMessageOn = true;
    LRESULT rc;

    /*
     * If there are subclassers, give each one a crack at this message.
     * If a subclasser indicates it wants to eat the message, bail.
     */
    if (!ctxt.Subclassers.empty())
    {
        SubclasserList::iterator it;

        for (it  = ctxt.Subclassers.begin(); 
             it != ctxt.Subclassers.end() && fPassMessageOn;
             ++it)
        {
            SubclasserData& subclasser = *it;
            subclasser.AddRef();

            ctxt.RemoveZombies ();
    
            /*
             * If this isn't a zombied subclasser, call the callback
             */
            if (!ctxt.IsZombie(subclasser))
            {
                rc = subclasser.pSubclasser->Callback (hwnd, msg, 
                                                       wParam, lParam,
                                                       fPassMessageOn);
            }

            subclasser.Release();
        }

        ctxt.RemoveZombies ();
    }

    /*
     * Otherwise, we have a zombie window (see 
     * PhysicallyUnsubclassWindow). Try to remove the zombie now.
     */
    else if (PhysicallyUnsubclassWindow (hwnd))
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager removed zombied window 0x%08x\n"), hwnd);
    }

    /*
     * remove this window's WindowContext on WM_NCDESTROY
     */
    if ((msg == WM_NCDESTROY) && 
        (m_ContextMap.find(hwnd) != m_ContextMap.end()))
    {
        Dbg (DEB_SUBCLASS, _T("CSubclassManager forced removal of zombied window 0x%08x on WM_NCDESTROY\n"), hwnd);
        PhysicallyUnsubclassWindow (hwnd, true);
    }

    /*
     * If the last subclasser didn't eat the message, 
     * give it to the original window procedure.
     */
    if (fPassMessageOn)
        rc = CallWindowProc (pfnOriginalWndProc, hwnd, msg, wParam, lParam);

    return (rc);
}



/*--------------------------------------------------------------------------*
 * WindowContext::IsZombie 
 *
 *
 *--------------------------------------------------------------------------*/

bool WindowContext::IsZombie (const SubclasserData& subclasser) const
{
    /*
     * If this is a zombie, make sure it's in the zombie list;
     * if it's not, make sure it's not.
     */
    ASSERT (subclasser.fZombie == (Zombies.find(subclasser) != Zombies.end()));

    return (subclasser.fZombie);
}



/*--------------------------------------------------------------------------*
 * WindowContext::Zombie
 *
 * Changes the state fo a subclasser to or from a zombie.
 *--------------------------------------------------------------------------*/

void WindowContext::Zombie (SubclasserData& subclasser, bool fZombie)
{
    // zombie-ing a zombied subclasser?
    ASSERT (IsZombie (subclasser) != fZombie);

    subclasser.fZombie = fZombie;

    if (fZombie)
        Zombies.insert (subclasser);
    else
        Zombies.erase (subclasser);

    ASSERT (IsZombie (subclasser) == fZombie);
}



/*--------------------------------------------------------------------------*
 * WindowContext::Insert 
 *
 *
 *--------------------------------------------------------------------------*/

void WindowContext::Insert (SubclasserData& subclasser)
{
    /*
     * This code can't handle re-subclassing by a subclasser 
     * that's currently a zombie.  If this ever becomes a requirement,
     * we'll need to identify the subclass instance by something other
     * than the CSubclasser pointer, like a unique handle.
     */
    ASSERT (Zombies.find(subclasser) == Zombies.end());

    /*
     * Subclassers get called in LIFO order, put the new 
     * subclasser at the head of the list.
     */
    Subclassers.push_front (subclasser);
}



/*--------------------------------------------------------------------------*
 * WindowContext::Remove 
 *
 * Logically removes a subclasser from the subclass chain.  "Logically"
 * because it's not safe to totally remove a subclasser from the chain if
 * it's currently in use.  If the subclass is in use when we want to remove
 * it, we'll mark it as "zombied" so it won't be used any more, to be 
 * physically removed later.
 *
 * Returns the reference count for the subclasser.
 *--------------------------------------------------------------------------*/

UINT WindowContext::Remove (SubclasserData& subclasser)
{
    // we shouldn't be removing zombies this way
    ASSERT (!IsZombie (subclasser));

    /*
     * If this subclasser has outstanding references, zombie it instead
     * of removing it.
     */
    UINT cRefs = subclasser.cRefs;

    if (cRefs == 0)
    {
        SubclasserList::iterator itRemove = std::find (Subclassers.begin(), 
                                                       Subclassers.end(),
                                                       subclasser);
        ASSERT (itRemove != Subclassers.end());
        Subclassers.erase (itRemove);
    }
    else
    {
        Zombie (subclasser, true);
    }

    return (cRefs);
}



/*--------------------------------------------------------------------------*
 * WindowContext::RemoveZombies 
 *
 *
 *--------------------------------------------------------------------------*/

void WindowContext::RemoveZombies ()
{
    if (Zombies.empty())
        return;

    /*
     * Build up a list of zombies that we can remove.  We have to build
     * the list ahead of time, instead of removing them as we find them,
     * because removing an element from a set invalidates all iterators
     * on the set.
     */
    SubclasserSet   ZombiesToRemove;

    SubclasserSet::iterator itEnd = Zombies.end();
    SubclasserSet::iterator it;

    for (it = Zombies.begin(); it != itEnd; ++it)
    {
        const SubclasserData& ShadowSubclasser = *it;

        /*
         * Find the real subclasser in the Subclassers list.  That's
         * the live one whose ref count will be correct.
         */
        SubclasserList::iterator itReal = std::find (Subclassers.begin(), 
                                                     Subclassers.end(),
                                                     ShadowSubclasser);

        const SubclasserData& RealSubclasser = *itReal;

        if (RealSubclasser.cRefs == 0)
        {
            Dbg (DEB_SUBCLASS, _T("CSubclassManager removed zombied subclass proc for window 0x%08x\n"),
                                RealSubclasser.hwnd);
            ZombiesToRemove.insert (ShadowSubclasser);
            Subclassers.erase (itReal);
        }
    }

    /*
     * Now remove the truly dead zombies.
     */
    itEnd = ZombiesToRemove.end();

    for (it = ZombiesToRemove.begin(); it != itEnd; ++it)
    {
        Zombies.erase (*it);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\subclass.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      subclass.h  
 *
 *  Contents:  Interface file for the dynamic subclass manager
 *
 *  History:   06-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef __SUBCLASS_H__
#define __SUBCLASS_H__
#pragma once


// remove the definition from windowsx.h that conflicts with declarations here
#ifdef SubclassWindow
#undef SubclassWindow
#endif



/*--------------------------------------------------------------------------*
 * CSubclasser
 *
 * Derive a class from this to implement subclassing the subclass manager
 * way.
 *--------------------------------------------------------------------------*/

class CSubclasser
{
public:
    virtual ~CSubclasser() {}

    virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam, 
                              LPARAM& lParam, bool& fPassMessageOn) = 0;
};


/*----------------*/
/* SubclasserData */
/*----------------*/
class SubclasserData
{
public:
    SubclasserData (CSubclasser* pSubclasser_ = NULL, HWND hwnd = NULL)
        :   pSubclasser (pSubclasser_),
            hwnd        (hwnd),
            cRefs       (0),
            fZombie     (false)
        {}

    UINT AddRef ()
        { return (++cRefs); }

    UINT Release ()
        { ASSERT (cRefs > 0); return (--cRefs); }

    bool operator==(const SubclasserData& other) const
        { return (pSubclasser == other.pSubclasser); }

    bool operator<(const SubclasserData& other) const
        { return (pSubclasser < other.pSubclasser); }

    CSubclasser* pSubclasser;

private:
    friend class WindowContext;

    HWND    hwnd;
    UINT    cRefs;
    bool    fZombie;
};

typedef std::list<SubclasserData>   SubclasserList;
typedef std::set< SubclasserData>   SubclasserSet;


/*---------------*/
/* WindowContext */
/*---------------*/
class WindowContext
{
public:
    WindowContext() : pfnOriginalWndProc(NULL) 
        {}

    bool IsZombie(const SubclasserData& subclasser) const;
    void Insert(SubclasserData& subclasser);
    UINT Remove(SubclasserData& subclasser);
    void RemoveZombies();

    SubclasserList  Subclassers;
    WNDPROC         pfnOriginalWndProc;

private:
    void Zombie(SubclasserData& subclasser, bool fZombie);

    SubclasserSet   Zombies;
};


/*------------------*/
/* CSubclassManager */
/*------------------*/
class CSubclassManager
{
public:
    bool SubclassWindow   (HWND hwnd, CSubclasser* pSubclasser);
    bool UnsubclassWindow (HWND hwnd, CSubclasser* pSubclasser);

private:
    typedef std::map<HWND, WindowContext>   ContextMap;
    ContextMap  m_ContextMap;

    bool PhysicallyUnsubclassWindow (HWND hwnd, bool fForce = false);
    LRESULT SubclassProcWorker (HWND, UINT, WPARAM, LPARAM);

    static LRESULT CALLBACK SubclassProc (HWND, UINT, WPARAM, LPARAM);
};

CSubclassManager& GetSubclassManager();


#endif /* __SUBCLASS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\strtable.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      strtable.h
 *
 *  Contents:  Interface file for CStringTable
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STRTABLE_H
#define STRTABLE_H
#pragma once

#include <exception>        // for class exception
#include <string>           // for string relational operators
#include "guidhelp.h"       // for GUID relational operators
#include "stgio.h"
#include "strings.h"


#ifdef DBG
#define DECLARE_DIAGNOSITICS()  \
public: void Dump() const;
#else
#define DECLARE_DIAGNOSITICS()  \
public: void Dump() const {}
#endif


#ifdef DBG
extern CTraceTag tagStringTable;
#endif  // DBG


/*--------------------------------------------------------------------------
 * IdentifierRange should be private to CIdentifierPool, but
 * compiler bugs prevent it.
 */
template<class T>
class IdentifierRange
{
public:
    IdentifierRange(T idMin_ = T(), T idMax_ = T())
        : idMin (idMin_), idMax (idMax_)
        { ASSERT (idMin <= idMax); }

    bool operator== (const IdentifierRange<T>& other) const
        { return ((idMin == other.idMin) && (idMax == other.idMax)); }

    bool operator!= (const IdentifierRange<T>& other) const
        { return (!(*this == other.idMin)); }

    T idMin;
    T idMax;
};


template<class T = int>
class CIdentifierPool : public CXMLObject
{
public:
    typedef IdentifierRange<T>  Range;
    typedef std::list<Range>    RangeList;

private:
#if _MSC_VER > 1300
    template <class U>
    friend IStream& operator>> (IStream& stm,       CIdentifierPool<U>& pool);
    template <class U>
    friend IStream& operator<< (IStream& stm, const CIdentifierPool<U>& pool);
#else
    // VC7 bug - doesn't handle template friends properly.  By luck, this works.
    friend IStream& operator>> (IStream& stm,       CIdentifierPool<T>& pool);
    friend IStream& operator<< (IStream& stm, const CIdentifierPool<T>& pool);
#endif
    virtual void Persist(CPersistor &persistor);
    DEFINE_XML_TYPE(XML_TAG_IDENTIFIER_POOL);

    SC ScInvertRangeList (RangeList& rlInvert) const;

#ifdef DBG
    void DumpRangeList (const RangeList& l) const;
#endif

public:
    DECLARE_DIAGNOSITICS();

    CIdentifierPool (T idMin, T idMax);
    CIdentifierPool (IStream& stm);
    T Reserve();
    bool Release(T idRelease);
    bool IsValid () const;
    bool IsRangeListValid (const RangeList& rl) const;
    SC   ScGenerate (const RangeList& rlUsedIDs);

    static bool AddToRangeList (RangeList& rl, const Range& rangeToAdd);
    static bool AddToRangeList (RangeList& rl, T idAdd);

    class pool_exhausted : public exception
    {
    public:
        pool_exhausted(const char *_S = "pool exhausted") _THROW0()
            : exception(_S) {}
        virtual ~pool_exhausted() _THROW0()
            {}
    };

private:
    RangeList   m_AvailableIDs;
    RangeList   m_StaleIDs;
    T           m_idAbsoluteMin;
    T           m_idAbsoluteMax;
    T           m_idNextAvailable;
};


typedef CIdentifierPool<MMC_STRING_ID>  CStringIDPool;



/*--------------------------------------------------------------------------
 * CEntry and CStoredEntry should be private to CStringTable,
 * but compiler bugs prevent it.
 */

/*
 * represents a string table entry in memory
 */
class CEntry : public CXMLObject
{
    friend class  CStringTable;
    friend class  CStringEnumerator;
    friend struct CompareEntriesByID;
    friend struct CompareEntriesByString;
    friend struct IdentifierReleaser;

    friend IStream& operator>> (IStream& stm,       CEntry& entry);
    friend IStream& operator<< (IStream& stm, const CEntry& entry);

public:
    DECLARE_DIAGNOSITICS();

    CEntry () : m_id(0), m_cRefs(0) {}

    CEntry (const std::wstring& str, MMC_STRING_ID id)
        : m_str(str), m_id(id), m_cRefs(0)
    {}
    virtual LPCTSTR GetXMLType()  {return XML_TAG_STRING_TABLE_STRING;}
    virtual void Persist(CPersistor& persistor);

private:
    /*
     * This ctor is only used by CStringTable when reconstructing
     * the entry from a file.
     */
    CEntry (const std::wstring& str, MMC_STRING_ID id, DWORD cRefs)
        : m_str(str) , m_id(id), m_cRefs(cRefs)
    {}

private:
    bool operator< (const LPCWSTR psz) const
        { return (m_str < psz); }

    bool operator< (const CEntry& other) const
        { return (m_str < other.m_str); }

    bool operator== (const LPCWSTR psz) const
        { return (m_str == psz); }

    bool operator== (const CEntry& other) const
        { return (m_str == other.m_str); }

//private:
public: // temp!
    std::wstring  m_str;
    MMC_STRING_ID m_id;
    DWORD         m_cRefs;
};


struct CompareEntriesByID :
    public std::binary_function<const CEntry&, const CEntry&, bool>
{
    bool operator() (const CEntry& entry1, const CEntry& entry2) const
        { return (entry1.m_id < entry2.m_id); }
};

struct CompareEntriesByString :
    public std::binary_function<const CEntry&, const CEntry&, bool>
{
    bool operator() (const CEntry& entry1, const CEntry& entry2) const
        { return (entry1 < entry2); }
};

struct IdentifierReleaser :
    public std::unary_function<CEntry&, bool>
{
    IdentifierReleaser (CStringIDPool& pool) : m_pool (pool) {}

    bool operator() (CEntry& entry) const
        { return (m_pool.Release (entry.m_id)); }

private:
    CStringIDPool& m_pool;
};


/*
 * Because the string and ID indexes map their keys to CEntry
 * pointers, we must use a collection that doesn't move its
 * elements once they're inserted.  The only STL collection
 * that meets this requirement is a list.
 */
typedef std::list<CEntry>  EntryList;

typedef XMLListCollectionWrap<EntryList> CStringTable_base;
class CStringTable : public CStringTable_base
{
    friend IStream& operator>> (IStream& stm,       CStringTable& entry);
    friend IStream& operator<< (IStream& stm, const CStringTable& entry);

public:
    DECLARE_DIAGNOSITICS();

    CStringTable (CStringIDPool* pIDPool);
    CStringTable (CStringIDPool* pIDPool, IStream& stm);
   ~CStringTable ();

    CStringTable (const CStringTable& other);
    CStringTable& operator= (const CStringTable& other);

    /*
     * IStringTable methods.  Note that object doesn't implement
     * IStringTable, because IUnknown isn't implemented.
     */
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID);
    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut) const;
    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString) const;
    STDMETHOD(DeleteString)     (MMC_STRING_ID id);
    STDMETHOD(DeleteAllStrings) ();
    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID) const;
    STDMETHOD(Enumerate)        (IEnumString** ppEnum) const;

    size_t size() const
        { return (m_Entries.size()); }

    virtual void Persist(CPersistor& persistor)
    {
        CStringTable_base::Persist(persistor);
        if (persistor.IsLoading())
            IndexAllEntries ();
    }

    SC ScCollectInUseIDs (CStringIDPool::RangeList& l) const;


private:

    void IndexAllEntries ()
        { IndexEntries (m_Entries.begin(), m_Entries.end()); }

    void IndexEntries (EntryList::iterator first, EntryList::iterator last)
    {
        for (; first != last; ++first)
            IndexEntry (first);
    }

    void IndexEntry (EntryList::iterator);

    typedef std::map<std::wstring,  EntryList::iterator>    StringToEntryMap;
    typedef std::map<MMC_STRING_ID, EntryList::iterator>    IDToEntryMap;

    EntryList::iterator LookupEntryByString (const std::wstring&)   const;
    EntryList::iterator LookupEntryByID     (MMC_STRING_ID)         const;
    EntryList::iterator FindInsertionPointForEntry (const CEntry& entry) const;


#ifdef DBG
    static void AssertValid (const CStringTable* pTable);
    #define ASSERT_VALID_(p)    do { AssertValid(p); } while(0)
#else
    #define ASSERT_VALID_(p)    ((void) 0)
#endif


private:
    EntryList           m_Entries;
    StringToEntryMap    m_StringIndex;
    IDToEntryMap        m_IDIndex;
    CStringIDPool*      m_pIDPool;
};

extern const CLSID CLSID_MMC;


/*+-------------------------------------------------------------------------*
 * class  CLSIDToStringTableMap
 *
 *
 * PURPOSE:  stl::map derived class that maps snapin_clsid to stringtable
 *           and supports XML persistence of the map collection
 *
 * NOTE: Throws exceptions!
 *+-------------------------------------------------------------------------*/
typedef std::map<CLSID, CStringTable> ST_base;
class  CLSIDToStringTableMap : public XMLMapCollection<ST_base>
{
public:
    // this method is provided as alternative to Persist, whic allows
    // to cache parameter to be used to create new string tables
    void PersistSelf(CStringIDPool *pIDPool, CPersistor& persistor)
    {
        m_pIDPersistPool = pIDPool;
        persistor.Persist(*this, NULL);
    }
protected:
    // XML persistence implementation
    virtual LPCTSTR GetXMLType() {return XML_TAG_STRING_TABLE_MAP;}
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
    {
        CLSID key;
        ZeroMemory(&key,sizeof(key));
        persistKey.Persist(key);

        CStringTable val(m_pIDPersistPool);
        persistVal.Persist(val);
        insert(ST_base::value_type(key,val));
    }
private:
    CStringIDPool *m_pIDPersistPool;
};
typedef CLSIDToStringTableMap::value_type   TableMapValue;

class CMasterStringTable :  public IStringTablePrivate, public CComObjectRoot, public CXMLObject
{
    friend IStorage& operator>> (IStorage& stg,       CMasterStringTable& mst);
    friend IStorage& operator<< (IStorage& stg, const CMasterStringTable& mst);

public:
    DECLARE_DIAGNOSITICS();

    CMasterStringTable ();
    ~CMasterStringTable ();


public:
    DEFINE_XML_TYPE(XML_TAG_MMC_STRING_TABLE);
    virtual void Persist(CPersistor& persistor);

    SC ScPurgeUnusedStrings();

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CMasterStringTable)
        COM_INTERFACE_ENTRY (IStringTablePrivate)
    END_COM_MAP ()

    /*
     * IStringTablePrivate methods
     */
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID, const CLSID* pclsid);
    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut, const CLSID* pclsid);
    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString, const CLSID* pclsid);
    STDMETHOD(DeleteString)     (MMC_STRING_ID id, const CLSID* pclsid);
    STDMETHOD(DeleteAllStrings) (const CLSID* pclsid);
    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID, const CLSID* pclsid);
    STDMETHOD(Enumerate)        (IEnumString** ppEnum, const CLSID* pclsid);

    /*
     * Shorthand into IStringTablePrivate (simulating a default parameter)
     */
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID)
        { return (AddString (pszAdd, pID, &CLSID_MMC)); }

    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut)
        { return (GetString (id, cchBuffer, lpBuffer, pcchOut, &CLSID_MMC)); }

    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString)
        { return (GetStringLength (id, pcchString, &CLSID_MMC)); }

    STDMETHOD(DeleteString)     (MMC_STRING_ID id)
        { return (DeleteString (id, &CLSID_MMC)); }

    STDMETHOD(DeleteAllStrings) ()
        { return (DeleteAllStrings (&CLSID_MMC)); }

    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID)
        { return (FindString (pszFind, pID, &CLSID_MMC)); }

    STDMETHOD(Enumerate)        (IEnumString** ppEnum)
        { return (Enumerate (ppEnum, &CLSID_MMC)); }


private:
    CStringTable* LookupStringTableByCLSID (const CLSID* pclsid) const;
    SC ScGenerateIDPool ();

private:
    CStringIDPool           m_IDPool;
    CLSIDToStringTableMap   m_TableMap;

    static const WCHAR      s_pszIDPoolStream[];
    static const WCHAR      s_pszStringsStream[];
};



class CStringEnumerator : public IEnumString, public CComObjectRoot
{
public:
    CStringEnumerator ();
    ~CStringEnumerator ();

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CStringEnumerator)
        COM_INTERFACE_ENTRY (IEnumString)
    END_COM_MAP ()

    /*
     * IEnumString methods
     */
    STDMETHOD(Next)  (ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)  (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (IEnumString **ppenum);

    static HRESULT CreateInstanceWrapper (
        CComObject<CStringEnumerator>** ppEnumObject,
        IEnumString**                   ppEnumIface);

    bool Init (const EntryList& entries);

private:
    typedef std::vector<std::wstring> StringVector;

    StringVector    m_Strings;
    size_t          m_cStrings;
    size_t          m_nCurrentIndex;
};


IStorage& operator>> (IStorage& stg,       CMasterStringTable& mst);
IStorage& operator<< (IStorage& stg, const CMasterStringTable& mst);
IStorage& operator>> (IStorage& stg,       CComObject<CMasterStringTable>& mst);
IStorage& operator<< (IStorage& stg, const CComObject<CMasterStringTable>& mst);

IStream& operator>> (IStream& stm,       CStringTable& st);
IStream& operator<< (IStream& stm, const CStringTable& st);
IStream& operator>> (IStream& stm,       CEntry& entry);
IStream& operator<< (IStream& stm, const CEntry& entry);

template<class T>
IStream& operator>> (IStream& stm,       CIdentifierPool<T>& pool);
template<class T>
IStream& operator<< (IStream& stm, const CIdentifierPool<T>& pool);


#include "strtable.inl"

#endif /* STRTABLE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\svfildlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       svfildlg.cpp
//
//--------------------------------------------------------------------------

// svfildlg.cpp : implSELECTEDementation file
//
#include "stdafx.h"

#ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)

#include "svfildlg.h"

#include <shlobj.h>
#include "AMC.h"
#include "AMCDoc.h"
#include "Shlwapi.h"
#include <windows.h>
#include "macros.h"

// The following constant is defined in Windows.hlp
// So we need to use windows.hlp for help on this topic.
#define IDH_SAVE_SELECTED_ROWS 29520

/////////////////////////////////////////////////////////////////////////////
// CSaveFileDialog dialog


const TCHAR CSaveFileDialog::strSection[] =    _T("Settings");
const TCHAR CSaveFileDialog::strStringItem[] = _T("List Save Location");


CSaveFileDialog::CSaveFileDialog(BOOL bOpenFileDialog,
        LPCTSTR lpszDefExt, LPCTSTR lpszFileName, DWORD dwFlags,
        LPCTSTR lpszFilter, bool bSomeRowSelected, CWnd* pParentWnd)
    : CFileDialogEx(bOpenFileDialog, lpszDefExt, lpszFileName,
        dwFlags, lpszFilter, pParentWnd), m_bSomeRowSelected(bSomeRowSelected)
{
    //{{AFX_DATA_INIT(CSaveFileDialog)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_ofn.lpstrInitialDir = NULL;

    // Set the initial path

    // 1st choice
    // Try to access the default directory in the registry
    CWinApp* pApp = AfxGetApp();
    m_strRegPath = pApp->GetProfileString (strSection, strStringItem);

    // Check if the directory is valid, if so then it is now the starting directory
    DWORD validdir = GetFileAttributes(m_strRegPath);
    if ((validdir != 0xFFFFFFFF) && (validdir | FILE_ATTRIBUTE_DIRECTORY))
        m_ofn.lpstrInitialDir = m_strRegPath;

    // 2nd choice:
    // Set the initial save directory to the personal directory

    // Get the user's personal directory
    // We'll get it now since we'll ust it in the destructor as well
    LPITEMIDLIST pidl;
    HRESULT hres = SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl) ;

    if (SUCCEEDED(hres))
    {
        SHGetPathFromIDList(pidl, szPath);

        // Free the pidl
        IMallocPtr spMalloc;
        SHGetMalloc(&spMalloc);
        spMalloc->Free(pidl);

        if ((m_ofn.lpstrInitialDir == NULL) && (SUCCEEDED(hres)))
            m_ofn.lpstrInitialDir = szPath;
    }

    // 3rd choice: The current directory (m_ofn.lpstrInitialDir = NULL; was set above)


    // Set additional items about the dialog box

    ZeroMemory(szFileName, sizeof(szFileName));
    m_ofn.lpstrFile = szFileName;
    m_ofn.nMaxFile = countof(szFileName);

    m_ofn.Flags |= (OFN_ENABLETEMPLATE|OFN_EXPLORER|OFN_PATHMUSTEXIST);
    m_ofn.lpTemplateName = MAKEINTRESOURCE(HasModernFileDialog() ? IDD_LIST_SAVE_NEW : IDD_LIST_SAVE);
    m_flags = 0;

    // Set the title of the dialog.
    if (LoadString(m_strTitle, IDS_EXPORT_LIST))
        m_ofn.lpstrTitle = (LPCTSTR)m_strTitle;
}

CSaveFileDialog::~CSaveFileDialog()
{
    // Get the path of the file that was just saved
    if (*m_ofn.lpstrFile == '\0' || m_ofn.nFileOffset < 1)
        return;

    CString strRecentPath(m_ofn.lpstrFile, m_ofn.nFileOffset - 1);

    // If the personal path exists and it is different from the old path, then change or add
    // the registry entry
    if ((szPath != NULL) && (strRecentPath != m_strRegPath))
        AfxGetApp()->WriteProfileString (strSection, strStringItem, strRecentPath);
}

void CSaveFileDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CConsolePropPage)
        //{{AFX_DATA_MAP(CSaveFileDialog)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaveFileDialog, CDialog)
    //{{AFX_MSG_MAP(CSaveFileDialog)
    ON_BN_CLICKED(IDC_SEL,  OnSel)
    //}}AFX_MSG_MAP
	ON_MESSAGE(WM_INITDIALOG, OnInitDialog)
    ON_MMC_CONTEXT_HELP()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaveFileDialog message handlers

void CSaveFileDialog::OnSel()
{
    m_flags ^= SELECTED;    // Toggle the Selected flag
}

LRESULT CSaveFileDialog::OnInitDialog(WPARAM, LPARAM)
{
	DECLARE_SC (sc, _T("CSaveFileDialog::OnInitDialog"));
    CDialog::OnInitDialog();

    HWND hwndSelRowsOnly = ::GetDlgItem(*this, IDC_SEL);
    if (hwndSelRowsOnly)
        ::EnableWindow(hwndSelRowsOnly, m_bSomeRowSelected );

	return TRUE;
}

#endif  // IMPLEMENT_LIST_SAVE        See nodemgr.idl (t-dmarm)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\sysmenu.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      sysmenu.cpp
 *
 *  Contents:  Implementation file for system menu modification functions
 *
 *  History:   04-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "sysmenu.h"
#include "mmcres.h"
#include <list>
#include <algorithm>


typedef std::list<HWND> WindowList;



/*--------------------------------------------------------------------------*
 * GetWindowList
 *
 *
 *--------------------------------------------------------------------------*/

static WindowList& GetWindowList()
{
    static WindowList   List;
    return (List);
}



/*--------------------------------------------------------------------------*
 * WipeWindowList
 *
 * Removes no-longer-valid windows from the Window-to-addition map.
 *--------------------------------------------------------------------------*/

void WipeWindowList ()
{
    WindowList&             List = GetWindowList();
    WindowList::iterator    it   = List.begin();

    while (it != List.end())
    {
        // if the window isn't valid, erase it
        if (!::IsWindow (*it))
        {
            WindowList::iterator itErase = it++;
            List.erase(itErase);
        }

        // this one's OK, check the next one
        else
            ++it;
    }
}



/*--------------------------------------------------------------------------*
 * AppendToSystemMenu
 *
 * Returns number of menu items appended.
 *--------------------------------------------------------------------------*/

int AppendToSystemMenu (CWnd* pwnd, int nSubmenuIndex)
{
    DECLARE_SC(sc, TEXT("AppendToSystemMenu"));

    CMenu   menuSysAdditions;
    sc = menuSysAdditions.LoadMenu (IDR_SYSMENU_ADDITIONS) ? S_OK : E_FAIL;
    if (sc)
        return 0;

    CMenu*  pSubMenu = menuSysAdditions.GetSubMenu (nSubmenuIndex);
    sc = ScCheckPointers(pSubMenu, E_UNEXPECTED);
    if (sc)
        return 0;

    return (AppendToSystemMenu (pwnd, pSubMenu));
}



/*--------------------------------------------------------------------------*
 * AppendToSystemMenu
 *
 * Returns number of menu items appended.
 *
 *--------------------------------------------------------------------------*/

int AppendToSystemMenu (CWnd* pwnd, CMenu* pMenuToAppend, CMenu* pSysMenu)
{
    DECLARE_SC(sc, TEXT("AppendToSystemMenu"));
    sc = ScCheckPointers(pwnd, pMenuToAppend);
    if (sc)
        return 0;

    if ( (!::IsWindow (pwnd->m_hWnd)) ||
         (!::IsMenu (pMenuToAppend->m_hMenu)) )
    {
        sc = E_UNEXPECTED;
        return 0;
    }

    // no system menu?  get one
    if (pSysMenu == NULL)
        pSysMenu = pwnd->GetSystemMenu (FALSE);

    // still no system menu?  bail
    if (pSysMenu == NULL)
        return (0);

    // clean out the map
    WipeWindowList ();

    // if this is the first addition to this window, append a separator
    WindowList& List = GetWindowList();
    WindowList::iterator itEnd = List.end();

    if (std::find (List.begin(), itEnd, pwnd->m_hWnd) == itEnd)
    {
        List.push_back (pwnd->m_hWnd);

        // If this is a child window & the next window item has not yet been added
        if ( (pwnd->GetStyle() & WS_CHILD) &&
            (pSysMenu->GetMenuState (SC_NEXTWINDOW, MF_BYCOMMAND) == 0xFFFFFFFF))
        {
            // Windows exhibits odd behavior by always handing us a non-child system menu
            // The text is currently wrong and diaplays "alt-f4" as the shortcut
            // instead of "ctrl-f4". The following code fixes that.
            CString strClose;
            LoadString(strClose, IDS_CLOSE);
            sc = pSysMenu->ModifyMenu( SC_CLOSE, MF_STRING | MF_BYCOMMAND, SC_CLOSE, strClose ) ? S_OK : E_FAIL;
            sc.TraceAndClear();

            // Add a separator
            sc = pSysMenu->AppendMenu (MF_SEPARATOR) ? S_OK : E_FAIL;
            sc.TraceAndClear();

            // Add the "Next" item
            CString strNext;
            LoadString(strNext, IDS_NEXTWINDOW);
            sc = pSysMenu->AppendMenu( MF_STRING, SC_NEXTWINDOW, strNext ) ? S_OK : E_FAIL;
            sc.TraceAndClear();
        }

        sc = pSysMenu->AppendMenu (MF_SEPARATOR) ? S_OK : E_FAIL;
        sc.TraceAndClear();
    }

    int cAppendedItems = 0;

    int     cItemsToAppend = pMenuToAppend->GetMenuItemCount ();
    TCHAR   szMenuText[64];

    MENUITEMINFO    mii;
    mii.cbSize     = sizeof (mii);
    mii.fMask      = MIIM_ID | MIIM_TYPE | MIIM_SUBMENU;
    mii.dwTypeData = szMenuText;

    for (int i = 0; i < cItemsToAppend; i++)
    {
        ASSERT (mii.dwTypeData == szMenuText);
        mii.cch = countof (szMenuText);
        if (! ::GetMenuItemInfo (pMenuToAppend->m_hMenu, i, TRUE, &mii))
            sc.FromLastError().TraceAndClear();

        // this code can't handle cascaded additions to the system menu
        ASSERT (mii.hSubMenu == NULL);

        // if the menu item is a separator or isn't already there, append it
        if ((mii.fType & MFT_SEPARATOR) ||
            (pSysMenu->GetMenuState (mii.wID, MF_BYCOMMAND) == 0xFFFFFFFF))
        {
            pSysMenu->AppendMenu (mii.fType, mii.wID, szMenuText);
            cAppendedItems++;
        }
    }

    // return the number of items appended
    return (cAppendedItems);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\svfildlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       svfildlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SVFILDLG_H__28CEAD2E_10E1_11D2_BA23_00C04F8141EF__INCLUDED_)
#define AFX_SVFILDLG_H__28CEAD2E_10E1_11D2_BA23_00C04F8141EF__INCLUDED_

#ifdef IMPLEMENT_LIST_SAVE        // See nodemgr.idl (t-dmarm)

#include "filedlgex.h"

// Flags
#define SELECTED       0x0001

// File Types
// Please do not change the order. This order is same
// as the IDS_FILE_TYPE string which contains
// the file types in resource file.
enum eFileTypes
{
    FILE_ANSI_TEXT = 1,
    FILE_ANSI_CSV,
    FILE_UNICODE_TEXT,
    FILE_UNICODE_CSV
};

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// svfildlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaveFileDialog dialog

class CSaveFileDialog : public CFileDialogEx
{
    //DECLARE_DYNCREATE(CSaveFileDialog)
// Construction
public:
    CSaveFileDialog(BOOL bOpenFileDialog,
        LPCTSTR lpszDefExt = NULL,
        LPCTSTR lpszFileName = NULL,
        DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
        LPCTSTR lpszFilter = NULL,
        bool bSomeRowSelected = false,
        CWnd* pParentWnd = NULL);   // standard constructor

    DWORD Getflags()
    {
        return m_flags;
    }

    eFileTypes GetFileType()
    {
        return (eFileTypes)m_ofn.nFilterIndex;
    }

    ~CSaveFileDialog();


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSaveFileDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSaveFileDialog)
    afx_msg void OnSel();
    //}}AFX_MSG

    LRESULT OnInitDialog(WPARAM, LPARAM);
    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_LIST_SAVE);

    DECLARE_MESSAGE_MAP()

private:
    static const TCHAR strSection[];
    static const TCHAR strStringItem[];
    TCHAR   szPath[MAX_PATH];
    TCHAR   szFileName[MAX_PATH];
    CString m_strTitle;
    CString m_strRegPath;
    DWORD   m_flags;
	bool    m_bSomeRowSelected;
};

#endif // IMPLEMENT_LIST_SAVE        See nodemgr.idl (t-dmarm)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVFILDLG_H__28CEAD2E_10E1_11D2_BA23_00C04F8141EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\sysmenu.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      sysmenu.h
 *
 *  Contents:  Interface file for system menu modification functions
 *
 *  History:   04-Feb-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef SYSMENU_H
#define SYSMENU_H


int AppendToSystemMenu (CWnd* pwnd, int nSubmenuIndex);
int AppendToSystemMenu (CWnd* pwnd, CMenu* pMenuToAppend, CMenu* pSysMenu = NULL);


#endif /* SYSMENU.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\taskhost.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       taskhost.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/19/1997   RaviR   Created
//____________________________________________________________________________
//

#ifndef TASKHOST_H__
#define TASKHOST_H__

class CTaskPadHost : public ITaskPadHost,
                     public CComObjectRoot
{
// Constructor & destructor
public:
    CTaskPadHost() : m_pAMCView(NULL)
    {
    }
    void Init(CAMCView* pv)
    {
        ASSERT(pv);
        m_pAMCView = pv;
    }
    ~CTaskPadHost()
    {
        m_pAMCView = NULL;
    }

// ATL COM map
public:
BEGIN_COM_MAP(CTaskPadHost)
    COM_INTERFACE_ENTRY(ITaskPadHost)
END_COM_MAP()

// ITaskPadHost methods
public:

    STDMETHOD(TaskNotify        )(BSTR szClsid, VARIANT * pvArg, VARIANT * pvParam);
    STDMETHOD(GetTaskEnumerator )(BSTR szTaskGroup, IEnumTASK** ppEnumTASK);
    STDMETHOD(GetPrimaryTask    )(IExtendTaskPad** ppExtendTaskPad);
    STDMETHOD(GetTitle          )(BSTR szTaskGroup, BSTR * pbstrTitle);
    STDMETHOD(GetDescriptiveText)(BSTR szTaskGroup, BSTR * pbstrDescriptiveText);
    STDMETHOD(GetBackground     )(BSTR szTaskGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
//  STDMETHOD(GetBranding       )(BSTR szTaskGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
    STDMETHOD(GetListPadInfo    )(BSTR szTaskGroup, MMC_ILISTPAD_INFO * pIListPadInfo);

// Implementation
private:
    CAMCView*           m_pAMCView;
    IExtendTaskPadPtr   m_spExtendTaskPadPrimary;

    INodeCallback* _GetNodeCallback(void)
    {
        return m_pAMCView->GetNodeCallback();
    }

    IExtendTaskPad* _GetPrimaryExtendTaskPad()
    {
        if (m_spExtendTaskPadPrimary == NULL)
        {
            IExtendTaskPadPtr spExtendTaskPad;
            HRESULT hr = GetPrimaryTask(&spExtendTaskPad);
            if (SUCCEEDED(hr))
                m_spExtendTaskPadPrimary.Attach(spExtendTaskPad.Detach());
        }

        ASSERT(m_spExtendTaskPadPrimary != NULL);
        return m_spExtendTaskPadPrimary;
    }

// Ensure that default copy constructor & assignment are not used.
    CTaskPadHost(const CTaskPadHost& rhs);
    CTaskPadHost& operator=(const CTaskPadHost& rhs);

}; // class CTaskPadHost


#endif // TASKHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\taskhost.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       TaskHost.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/17/1997   RaviR   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "amcdoc.h"
#include "amcview.h"
#include "taskhost.h"


STDMETHODIMP
CTaskPadHost::GetTaskEnumerator(
    BSTR bstrTaskGroup,
    IEnumTASK** ppEnumTask)
{
    ASSERT(ppEnumTask != NULL);
    if (!ppEnumTask)
        return E_POINTER;

    ASSERT(m_pAMCView);
    if (!m_pAMCView)
        return E_UNEXPECTED;

    HNODE hNode = m_pAMCView->GetSelectedNode();
    ASSERT(hNode != NULL);
    if (!hNode)
        return E_UNEXPECTED;

    INodeCallback* pNC = _GetNodeCallback();
    ASSERT(pNC != NULL);
    if (!pNC)
        return E_UNEXPECTED;

    // do not pas NULL, pas empty string instead
    LPCOLESTR strTaskGroup = bstrTaskGroup ? bstrTaskGroup : L"";

    return pNC->GetTaskEnumerator(hNode, strTaskGroup, ppEnumTask);
}


STDMETHODIMP
CTaskPadHost::TaskNotify(
    BSTR szClsid,
    VARIANT* pvArg,
    VARIANT* pvParam)
{
    ASSERT(m_pAMCView);
    if (!m_pAMCView)
        return E_UNEXPECTED;

    HNODE hNode = m_pAMCView->GetSelectedNode();
    ASSERT(hNode != NULL);
    if (!hNode)
        return E_UNEXPECTED;

    INodeCallback* pNC = _GetNodeCallback();
    if (!pNC)
        return E_UNEXPECTED;

    VARIANT* ppv[2] = {pvArg, pvParam};

    pNC->Notify(hNode, NCLBK_TASKNOTIFY, reinterpret_cast<LPARAM>(szClsid),
                reinterpret_cast<LPARAM>(ppv));

    return S_OK;
}

STDMETHODIMP
CTaskPadHost::GetPrimaryTask(
    IExtendTaskPad** ppExtendTaskPad)
{
    ASSERT(ppExtendTaskPad != NULL);
    if (!ppExtendTaskPad)
        return E_POINTER;

    if (m_spExtendTaskPadPrimary == NULL)
    {
        HNODE hNode = m_pAMCView->GetSelectedNode();
        ASSERT(hNode != NULL);
        if (!hNode)
            return E_UNEXPECTED;

        INodeCallback* pNC = _GetNodeCallback();
        if (!pNC)
            return E_UNEXPECTED;

        HRESULT hr = pNC->Notify(hNode, NCLBK_GETPRIMARYTASK, NULL,
                                reinterpret_cast<LPARAM>(&m_spExtendTaskPadPrimary));
        if (hr != S_OK)
            return hr;

        ASSERT (m_spExtendTaskPadPrimary != NULL);
        if (m_spExtendTaskPadPrimary == NULL)
            return E_UNEXPECTED;
    }

    *ppExtendTaskPad = m_spExtendTaskPadPrimary;
    (*ppExtendTaskPad)->AddRef ();

    return S_OK;
}

STDMETHODIMP
CTaskPadHost::GetTitle(
    BSTR bstrTaskGroup,
    BSTR* pbstrOut)
{
    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    LPOLESTR szString = NULL;
    HRESULT hr = pExtendTaskPad->GetTitle (bstrTaskGroup, &szString);
    ASSERT ((hr == S_OK) && (szString != NULL));
    if ((hr == S_OK) && (szString != NULL)) {
        *pbstrOut = SysAllocString (szString);
        ASSERT (pbstrOut != NULL);
        CoTaskMemFree (szString);
        if (pbstrOut == NULL)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP
CTaskPadHost::GetDescriptiveText(
    BSTR bstrTaskGroup,
    BSTR* pbstrOut)
{
    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    LPOLESTR szString = NULL;
    HRESULT hr = pExtendTaskPad->GetDescriptiveText (bstrTaskGroup, &szString);
// optional ASSERT ((hr == S_OK) && (szString != NULL));
    if ((hr == S_OK) && (szString != NULL)) {
        *pbstrOut = SysAllocString (szString);
        ASSERT (pbstrOut != NULL);
        CoTaskMemFree (szString);
        if (pbstrOut == NULL)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP
CTaskPadHost::GetBackground(
    BSTR bstrTaskGroup,
    MMC_TASK_DISPLAY_OBJECT * pTDO)
{
    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    LPOLESTR szString = NULL;
    HRESULT hr = pExtendTaskPad->GetBackground (bstrTaskGroup, pTDO);
// optional ASSERT (hr == S_OK);
    return hr;
}

STDMETHODIMP CTaskPadHost::GetListPadInfo(BSTR szTaskGroup, MMC_ILISTPAD_INFO * pIListPadInfo)
{
    ASSERT(pIListPadInfo != NULL);
    ASSERT (!IsBadWritePtr (pIListPadInfo, sizeof(MMC_ILISTPAD_INFO)));

    IExtendTaskPad* pExtendTaskPad = _GetPrimaryExtendTaskPad();
    if (pExtendTaskPad == NULL)
        return E_UNEXPECTED;

    ASSERT(m_pAMCView);
    if (!m_pAMCView)
        return E_UNEXPECTED;

    HNODE hNode = m_pAMCView->GetSelectedNode();
    ASSERT(hNode != NULL);
    if (!hNode)
        return E_UNEXPECTED;

    INodeCallback* pNC = _GetNodeCallback();
    ASSERT(pNC != NULL);
    if (!pNC)
        return E_UNEXPECTED;

    return pNC->GetListPadInfo (hNode, pExtendTaskPad, (LPOLESTR)szTaskGroup, pIListPadInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\tbtrack.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tbtrack.cpp
 *
 *  Contents:  Implementation file for CToolbarTracker
 *
 *  History:   15-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "amc.h"
#include "tbtrack.h"
#include "controls.h"
#include "mainfrm.h"
#include "childfrm.h"


/*+-------------------------------------------------------------------------*
 * GetMainAuxWnd
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTrackerAuxWnd* GetMainAuxWnd()
{
    CMainFrame* pFrame = AMCGetMainWnd();
    if (pFrame == NULL)
        return (NULL);

    CToolbarTracker* pTracker = pFrame->GetToolbarTracker();
    if (pTracker == NULL)
        return (NULL);

    return (pTracker->GetAuxWnd());
}


/*--------------------------------------------------------------------------*
 * IsToolbar
 *
 *
 *--------------------------------------------------------------------------*/

static bool IsToolbar (HWND hwnd)
{
    TCHAR   szClassName[countof (TOOLBARCLASSNAME) + 1];

    GetClassName (hwnd, szClassName, countof (szClassName));
    return (lstrcmpi (szClassName, TOOLBARCLASSNAME) == 0);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CToolbarTracker
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::CToolbarTracker(CWnd* pMainFrame)
    :   m_Subclasser   (this, pMainFrame),
        m_pAuxWnd      (NULL),
        m_fTerminating (false)
{
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::~CToolbarTracker
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::~CToolbarTracker()
{
    if (IsTracking ())
        EndTracking ();

    ASSERT (!IsTracking ());
    ASSERT (m_pAuxWnd == NULL);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::BeginTracking
 *
 *
 *--------------------------------------------------------------------------*/

bool CToolbarTracker::BeginTracking()
{
    ASSERT (!m_fTerminating);
    ASSERT (!IsTracking ());

    /*
     * Allocate a new CToolbarTrackerAuxWnd.  We want to hold it in a
     * temporary instead of assigning directly to m_pAuxWnd so that
     * CMMCToolBarCtrlEx::OnHotItemChange will allow the hot item
     * changes that CToolbarTrackerAuxWnd::EnumerateToolbars will attempt.
     */
    std::auto_ptr<CToolbarTrackerAuxWnd> spAuxWnd(new CToolbarTrackerAuxWnd(this));

    if (!spAuxWnd->BeginTracking ())
        return (false);

    m_pAuxWnd = spAuxWnd.release();
    ASSERT (IsTracking ());

    return (true);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::EndTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTracker::EndTracking()
{
    if (m_fTerminating)
        return;

    ASSERT (IsTracking ());
    m_fTerminating = true;

    m_pAuxWnd->EndTracking ();
    delete m_pAuxWnd;
    m_pAuxWnd = NULL;

    m_fTerminating = false;
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CFrameSubclasser::CFrameSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::CFrameSubclasser::CFrameSubclasser (CToolbarTracker* pTracker, CWnd* pwnd)
    :   m_hwnd     (pwnd->GetSafeHwnd()),
        m_pTracker (pTracker)
{
    GetSubclassManager().SubclassWindow (m_hwnd, this);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CFrameSubclasser::~CFrameSubclasser
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTracker::CFrameSubclasser::~CFrameSubclasser ()
{
    GetSubclassManager().UnsubclassWindow (m_hwnd, this);
}


/*--------------------------------------------------------------------------*
 * CToolbarTracker::CFrameSubclasser::Callback
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CToolbarTracker::CFrameSubclasser::Callback (
    HWND&   hwnd,
    UINT&   msg,
    WPARAM& wParam,
    LPARAM& lParam,
    bool&   fPassMessageOn)
{
    switch (msg)
    {
        case WM_SYSCOMMAND:
            if ((wParam & 0xFFF0) == SC_CLOSE)
            {
                /*
                 * tracking? stop now.
                 * or else close will not go thru,
                 * since we hold the capture
                 */
                if ((m_pTracker != NULL) && (m_pTracker->IsTracking ()))
                    m_pTracker->EndTracking ();
            }
            else if ((wParam & 0xFFF0) == SC_KEYMENU)
            {
                /*
                 * tracking? stop now.
                 */
                if (m_pTracker->IsTracking ())
                    m_pTracker->EndTracking ();

                /*
                 * not tracking and this was a simple Alt,
                 * (not Alt+Space or Alt+-)? start now
                 */
                else if (lParam == 0)
                    m_pTracker->BeginTracking ();

                /*
                 * don't let simple Alt through, regardless of whether
                 * we started or ended tracking
                 */
                if (lParam == 0)
                    fPassMessageOn = false;
            }
            break;

        case WM_ACTIVATE:
        case WM_ACTIVATEAPP:
        case WM_ACTIVATETOPLEVEL:
//      case WM_ENTERMENULOOP:
        case WM_CANCELMODE:
            if (m_pTracker->IsTracking ())
                m_pTracker->EndTracking ();
            break;
    }

    return (0);
}


/////////////////////////////////////////////////////////////////////////////
// CToolbarTrackerAuxWnd

BEGIN_MESSAGE_MAP(CToolbarTrackerAuxWnd, CWnd)
    //{{AFX_MSG_MAP(CToolbarTrackerAuxWnd)
    ON_COMMAND(ID_CMD_NEXT_TOOLBAR, OnNextToolbar)
    ON_COMMAND(ID_CMD_PREV_TOOLBAR, OnPrevToolbar)
    ON_COMMAND(ID_CMD_NOP, OnNop)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::CToolbarTrackerAuxWnd
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTrackerAuxWnd::CToolbarTrackerAuxWnd(CToolbarTracker* pTracker)
    :   m_pTracker        (pTracker),
        m_pTrackedToolbar (NULL),
        m_fMessagesHooked (false)
{
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::~CToolbarTrackerAuxWnd
 *
 *
 *--------------------------------------------------------------------------*/

CToolbarTrackerAuxWnd::~CToolbarTrackerAuxWnd()
{
    /*
     * if any of these fail, EndTracking hasn't been called
     */
    ASSERT (m_pTrackedToolbar == NULL);
    ASSERT (m_hWnd == NULL);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::BeginTracking
 *
 *
 *--------------------------------------------------------------------------*/

bool CToolbarTrackerAuxWnd::BeginTracking ()
{
    CMainFrame* pMainFrame = AMCGetMainWnd();
    if (pMainFrame == NULL)
        return (false);

    /*
     * create a dummy window to be the target of WM_COMMANDs from accelerators
     */
    if (!Create (NULL, NULL, WS_DISABLED, g_rectEmpty, pMainFrame, 0))
        return (false);

    /*
     * enumerate the toolbars for the main frame
     */
    EnumerateToolbars (pMainFrame->GetRebar());

    /*
     * if there aren't any toolbars, don't track
     */
    if (m_vToolbars.empty())
    {
        DestroyWindow ();
        return (false);
    }

    /*
     * track the first toolbar
     */
    TrackToolbar (m_vToolbars[0]);

    /*
     * hook into the translate message chain
     */
    AMCGetApp()->HookPreTranslateMessage (this);
    m_fMessagesHooked = true;

    return (true);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::EndTracking
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::EndTracking ()
{
    /*
     * stop tracking the tracked toolbar, if there is one
     */
    if (m_pTrackedToolbar != NULL)
        m_pTrackedToolbar->EndTracking2 (this);

    /*
     * get out of the translate message chain
     */
    if (m_fMessagesHooked)
    {
        AMCGetApp()->UnhookPreTranslateMessage (this);
        m_fMessagesHooked = false;
    }

    /*
     * destroy the auxilliary window
     */
    DestroyWindow();
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::GetTrackAccel
 *
 * Manages the accelerator table singleton for CToolbarTrackerAuxWnd
 *--------------------------------------------------------------------------*/

const CAccel& CToolbarTrackerAuxWnd::GetTrackAccel ()
{
    static ACCEL aaclTrack[] = {
        { FVIRTKEY | FCONTROL,          VK_TAB,         ID_CMD_NEXT_TOOLBAR },
        { FVIRTKEY | FCONTROL | FSHIFT, VK_TAB,         ID_CMD_PREV_TOOLBAR },

        /*
         * These keys are used by MMC.
         * We need to eat them when we're tracking toolbars.
         */
        { FVIRTKEY | FSHIFT,            VK_F10,         ID_CMD_NOP },
    };

    static const CAccel TrackAccel (aaclTrack, countof (aaclTrack));
    return (TrackAccel);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::PreTranslateMessage
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CToolbarTrackerAuxWnd::PreTranslateMessage(MSG* pMsg)
{
    if (m_pTrackedToolbar != NULL)
    {
        if ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST))
        {
            // give the tracked toolbar a crack
            if (m_pTrackedToolbar->PreTranslateMessage (pMsg))
                return (true);

            const CAccel& TrackAccel = GetTrackAccel();
            ASSERT (TrackAccel != NULL);

            // ...or try to handle it here.
            if (TrackAccel.TranslateAccelerator (m_hWnd, pMsg))
                return (true);

            /*
             * eat keystrokes that might be used by the tree or list controls
             */
            switch (pMsg->wParam)
            {
                case VK_UP:
                case VK_DOWN:
                case VK_LEFT:
                case VK_RIGHT:
                case VK_NEXT:
                case VK_PRIOR:
                case VK_RETURN:
                case VK_BACK:
                case VK_HOME:
                case VK_END:
                case VK_ADD:
                case VK_SUBTRACT:
                case VK_MULTIPLY:
                    return (true);

                default:
                    break;
            }
        }

        // swallow WM_CONTEXTMENU, too
        if (pMsg->message == WM_CONTEXTMENU)
            return (true);
    }

    // bypass the base class
    return (false);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::TrackToolbar
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::TrackToolbar (CMMCToolBarCtrlEx* pwndNewToolbar)
{
    if (pwndNewToolbar == m_pTrackedToolbar)
        return;

    // protect against recursion via EndTracking
    CMMCToolBarCtrlEx*  pwndOldToolbar = m_pTrackedToolbar;
    m_pTrackedToolbar = NULL;

    // if we were tracking one, quit tracking it
    if (pwndOldToolbar != NULL)
    {
        pwndOldToolbar->EndTracking2 (this);

        /*
         * if we're ending tracking entirely, not just tracking a different
         * toolbar, remove this window from the translate message hook chain
         */
        if (pwndNewToolbar == NULL)
        {
            m_pTracker->EndTracking ();

            /*
             * CToolbarTracker::EndTracking will delete this
             * object, so we need to get outta here -- now!
             */
            return;
        }
    }

    // now track the new one (and let it know about it)
    m_pTrackedToolbar = pwndNewToolbar;

    if (m_pTrackedToolbar != NULL)
        m_pTrackedToolbar->BeginTracking2 (this);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::OnNextToolbar
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::OnNextToolbar ()
{
    ASSERT (m_pTrackedToolbar);
    CMMCToolBarCtrlEx*  pwndNextToolbar = GetToolbar (m_pTrackedToolbar, true);

    if (m_pTrackedToolbar != pwndNextToolbar)
        TrackToolbar (pwndNextToolbar);

    ASSERT (m_pTrackedToolbar == pwndNextToolbar);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::OnPrevToolbar
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::OnPrevToolbar ()
{
    ASSERT (m_pTrackedToolbar);
    CMMCToolBarCtrlEx*  pwndPrevToolbar = GetToolbar (m_pTrackedToolbar, false);

    if (m_pTrackedToolbar != pwndPrevToolbar)
        TrackToolbar (pwndPrevToolbar);

    ASSERT (m_pTrackedToolbar == pwndPrevToolbar);
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::OnNop
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::OnNop ()
{
    // do nothing
}



/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::EnumerateToolbars
 *
 *
 *--------------------------------------------------------------------------*/

void CToolbarTrackerAuxWnd::EnumerateToolbars (
    CRebarWnd* pRebar)
{
    int cBands = pRebar->GetBandCount ();

    REBARBANDINFO   rbi;
    ZeroMemory (&rbi, sizeof (rbi));
    rbi.cbSize = sizeof (rbi);
    rbi.fMask  = RBBIM_CHILD;

    /*
     * enumerate children of the rebar looking for toolbars
     */
    for (int i = 0; i < cBands; i++)
    {
        pRebar->GetBandInfo (i, &rbi);

        /*
         * ignore this window if it's hidden or disabled
         */
        DWORD dwStyle = ::GetWindowLong (rbi.hwndChild, GWL_STYLE);

        if (!(dwStyle & WS_VISIBLE) || (dwStyle & WS_DISABLED))
            continue;

        /*
         * get the (permanent) CMMCToolBarCtrlEx pointer for the child
         */
        CMMCToolBarCtrlEx*  pwndToolbar =
                dynamic_cast<CMMCToolBarCtrlEx *> (
                        CWnd::FromHandlePermanent (rbi.hwndChild));

        /*
         * if we got a toolbar, save it in our list of toolbars to track
         */
        if (pwndToolbar != NULL)
        {
            m_vToolbars.push_back (pwndToolbar);

            /*
             * make sure this toolbar doesn't have a hot item
             */
            pwndToolbar->SetHotItem (-1);
        }
    }
}


/*--------------------------------------------------------------------------*
 * CToolbarTrackerAuxWnd::GetToolbar
 *
 *
 *--------------------------------------------------------------------------*/

CMMCToolBarCtrlEx* CToolbarTrackerAuxWnd::GetToolbar (
    CMMCToolBarCtrlEx*  pCurrentToolbar,
    bool                fNext)
{
    CMMCToolBarCtrlEx*  pTargetToolbar = NULL;
    int cToolbars = m_vToolbars.size();

    if (cToolbars > 0)
    {
        // find the current toolbar in the vector
        ToolbarVector::iterator itCurrent =
                std::find (m_vToolbars.begin(), m_vToolbars.end(), pCurrentToolbar);

        ASSERT ( itCurrent != m_vToolbars.end());
        ASSERT (*itCurrent == pCurrentToolbar);

        int nCurrentIndex = itCurrent - m_vToolbars.begin();

        // now find the target toolbar
        ASSERT ((fNext == 0) || (fNext == 1));
        int nTargetIndex = (nCurrentIndex + (fNext * 2 - 1) + cToolbars) % cToolbars;
        ASSERT ((nTargetIndex >= 0) && (nTargetIndex < cToolbars));
        ASSERT ((cToolbars == 1) || (nTargetIndex != nCurrentIndex));

        pTargetToolbar = m_vToolbars[nTargetIndex];
        ASSERT (pTargetToolbar != NULL);
    }

    return (pTargetToolbar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\tbtrack.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tbtrack.h
 *
 *  Contents:  Interface file for CToolbarTracker
 *
 *  History:   15-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#if !defined(AFX_TBTRACK_H__E1BC376B_EAB5_11D1_8080_0000F875A9CE__INCLUDED_)
#define AFX_TBTRACK_H__E1BC376B_EAB5_11D1_8080_0000F875A9CE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "subclass.h"       // for CSubclasser


class CMMCToolBarCtrlEx;
class CRebarWnd;
class CToolbarTracker;


/////////////////////////////////////////////////////////////////////////////
// CToolbarTrackerAuxWnd window

class CToolbarTrackerAuxWnd : public CWnd
{
    friend class CToolbarTracker;
    friend class std::auto_ptr<CToolbarTrackerAuxWnd>;
    typedef std::vector<CMMCToolBarCtrlEx*>     ToolbarVector;

private:
    // only created and destroyed by CToolbarTracker
    CToolbarTrackerAuxWnd(CToolbarTracker* pTracker);
    virtual ~CToolbarTrackerAuxWnd();

    bool BeginTracking();
    void EndTracking();

public:
    enum
    {
        ID_CMD_NEXT_TOOLBAR = 0x5300,   // could be anything
        ID_CMD_PREV_TOOLBAR,
        ID_CMD_NOP,
    };

public:
    void TrackToolbar (CMMCToolBarCtrlEx* pwndNewToolbar);

    CMMCToolBarCtrlEx* GetTrackedToolbar() const
        { return (m_pTrackedToolbar); }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CToolbarTrackerAuxWnd)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Generated message map functions
protected:
    //{{AFX_MSG(CToolbarTrackerAuxWnd)
    //}}AFX_MSG

protected:
    afx_msg void OnNextToolbar ();
    afx_msg void OnPrevToolbar ();
    afx_msg void OnNop ();

    DECLARE_MESSAGE_MAP()

private:
    const CAccel& GetTrackAccel ();
    CMMCToolBarCtrlEx*  GetToolbar (CMMCToolBarCtrlEx* pCurrentToolbar, bool fNext);
    void EnumerateToolbars (CRebarWnd* pRebar);

    CToolbarTracker* const  m_pTracker;
    CMMCToolBarCtrlEx*      m_pTrackedToolbar;
    ToolbarVector           m_vToolbars;
    bool                    m_fMessagesHooked;
};


/////////////////////////////////////////////////////////////////////////////
// CToolbarTracker window

class CToolbarTracker : public CObject
{
public:
    CToolbarTracker(CWnd* pMainFrame);
    virtual ~CToolbarTracker();

    bool BeginTracking();
    void EndTracking();

    bool IsTracking() const
        { return (m_pAuxWnd != NULL); }

    CToolbarTrackerAuxWnd* GetAuxWnd() const
        { return (m_pAuxWnd); }


private:
    /*
     * CFrameSubclasser
     */
    class CFrameSubclasser : public CSubclasser
    {
        HWND                m_hwnd;
        CToolbarTracker*    m_pTracker;

    public:
        CFrameSubclasser(CToolbarTracker*, CWnd*);
        ~CFrameSubclasser();
        virtual LRESULT Callback (HWND& hwnd, UINT& msg, WPARAM& wParam,
                                  LPARAM& lParam, bool& fPassMessageOn);
    };


private:
    CToolbarTrackerAuxWnd*  m_pAuxWnd;
    CFrameSubclasser        m_Subclasser;
    bool                    m_fTerminating;
};


CToolbarTrackerAuxWnd* GetMainAuxWnd();


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TBTRACK_H__E1BC376B_EAB5_11D1_8080_0000F875A9CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\toolbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      toolbar.cpp
//
//  Contents:  ToolBars implementation
//
//  History:   09-30-99 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "ChildFrm.h"
#include "mainfrm.h"
#include "controls.h"
#include "toolbar.h"
#include "bitmap.h"
#include "amcview.h"
#include "util.h"

int CAMCViewToolbars::s_idCommand = MMC_TOOLBUTTON_ID_FIRST;

CAMCViewToolbars::~CAMCViewToolbars()
{
    // Ask the toolbars (on nodemgr side) that reference this object to
    // remove their references.
    TBarToBitmapIndex::iterator itToolbars = m_mapTBarToBitmapIndex.begin();
    for (;itToolbars != m_mapTBarToBitmapIndex.end(); ++itToolbars)
    {
        CToolbarNotify* pNotifyCallbk = itToolbars->first;
        SC sc = ScCheckPointers(pNotifyCallbk, E_UNEXPECTED);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        sc = pNotifyCallbk->ScAMCViewToolbarsBeingDestroyed();
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInit
//
//  Synopsis:    Initialize the object by createing imagelist.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInit (CMMCToolBar *pMainToolbar, CAMCView* pAMCViewOwner)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInit"));

    sc = ScCheckPointers(pMainToolbar, pAMCViewOwner);
    if(sc)
        return sc;

    m_pMainToolbar = pMainToolbar;
    m_pAMCViewOwner = pAMCViewOwner;

    if (m_ImageList.m_hImageList)
        return (sc = E_UNEXPECTED);

    // Create an imagelist.
    BOOL b = m_ImageList.Create(BUTTON_BITMAP_SIZE, BUTTON_BITMAP_SIZE,
                                ILC_COLORDDB|ILC_MASK,
                                20 /*Initial imagelist size*/, 10 /* grow */);


    if (!b)
        return (sc = E_FAIL);

    m_ImageList.SetBkColor(CLR_NONE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScCreateToolBar
//
//  Synopsis:    Create a Toolbar (Just return CMMCToolbarIntf).
//
//  Arguments:
//               [ppToolbarIntf] - corresponds to IToolbar imp.
//                                 call this interface to manipulate toolbar UI.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScCreateToolBar (CMMCToolbarIntf** ppToolbarIntf)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScCreateToolBar"));
    sc = ScCheckPointers(ppToolbarIntf);
    if (sc)
        return sc;

    *ppToolbarIntf = this;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDisableToolbars
//
//  Synopsis:    Disable all the toolbar buttons (reqd during LV multiselect).
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDisableToolbars ()
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDisableToolbars"));

    if (! m_fViewActive)
        return (sc = E_UNEXPECTED);

    // Now iterate thro all toolbuttons & disable them.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        // Set the UI button state.
        sc = ScSetButtonStateInToolbar(pToolButton, TBSTATE_ENABLED, FALSE);
        if (sc)
            return sc;

        // Save the new state.
        BYTE byOldState = pToolButton->GetState();
        pToolButton->SetState(byOldState & ~TBSTATE_ENABLED);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScAddBitmap
//
//  Synopsis:    Add the given bitmap into the view toolbars imagelist.
//               Also store the start index & number of images in an object
//               mapped by the CToolbarNotify (which identifies snapin toolbar
//               or std bar).
//
//  Arguments:   [pNotifyCallbk] - The toolbar identifier (Button click callback interface).
//               [nImages]       - Number of bitmaps.
//               [hbmp]          - Handle to the bitmap.
//               [crMask]        - Color used to generate a mask to overlay
//                                 the images on the toolbar button.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScAddBitmap (CToolbarNotify* pNotifyCallbk, INT nImages,
                               HBITMAP hbmp, COLORREF crMask)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScAddBitmap"));
    sc = ScCheckPointers(pNotifyCallbk, hbmp);
    if (sc)
        return sc;

	/*
	 * make a copy of the input bitmap because ImageList_AddMasked will
	 * modify the input bitmap
	 */
    CBitmap bmpCopy;
    bmpCopy.Attach (CopyBitmap (hbmp));

	if (bmpCopy.GetSafeHandle() == NULL)
		return (sc.FromLastError());

    sc = ScCheckPointers(m_ImageList.m_hImageList, E_UNEXPECTED);
    if (sc)
        return sc;

    MMCToolbarImages imagesNew;

    int cImagesOld = m_ImageList.GetImageCount();

    // First add the bitmap into the imagelist.
    imagesNew.iStart  = m_ImageList.Add (bmpCopy, crMask);

    imagesNew.cCount = m_ImageList.GetImageCount() - cImagesOld;

    if (imagesNew.iStart == -1)
        return (sc = E_FAIL);

    /*
     * Assume a snapin adds 3 bitmaps initialy & then 4 for a toolbar.
     * Then while adding buttons it will specify bitmap index as 5.
     *
     * So this toolbar will have two MMCToolbarImages objects in the multimap.
     *
     * The first  MMCToolbarImages has cCount = 3, iStartWRTSnapin = 0, thus
     * images from 0 (iStartWRTSnapin) to 3 (iStartWRTSnapin + cCount) with respect
     * to snapin.
     * The second MMCToolbarImages has cCount = 4, iStartWRTSnapin = 3, thus
     * images from 3(iStartWRTSnapin) to 7(iStartWRTSnapin + cCount) wrt snapin.
     *
     * The iStartWRTSnapin member is nothing but the largest of iStartWRTSnapin + cCount
     * in all of this toolbars MMCToolbarImages.
     *
     */

    std::pair<TBarToBitmapIndex::iterator, TBarToBitmapIndex::iterator>
                  range =  m_mapTBarToBitmapIndex.equal_range(pNotifyCallbk);

    imagesNew.iStartWRTSnapin = 0;
    while (range.first != range.second)
    {
        // Go thro each item and get the correct start index.
        MMCToolbarImages imagesOld = (range.first)->second;
        int nLastImageIndex = imagesOld.iStartWRTSnapin + imagesOld.cCount;
        if ( imagesNew.iStartWRTSnapin < nLastImageIndex )
            imagesNew.iStartWRTSnapin = nLastImageIndex;

        (range.first)++;
    }

    // Now store the start index, number of bitmaps identified
    // by CToolbarNotify in a multi-map.
    m_mapTBarToBitmapIndex.insert(
                              TBarToBitmapIndex::value_type(pNotifyCallbk, imagesNew) );

    // To be compatible with SysInfo snapin dont return error.
    if ((cImagesOld + nImages) > m_ImageList.GetImageCount())
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("IToolbar::AddBitmap, Number of bitmaps is less than number mentioned"), sc);
        sc.Clear();
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     ScValidateButton
//
//  Synopsis:   Validate the MMCBUTTON data.
//
//  Arguments:
//            [nButtons]  - Number of elements in MMCBUTTON array.
//            [lpButtons] - MMCBUTTON array.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScValidateButton(int nButtons, LPMMCBUTTON lpButtons)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCViewToolbars::ScValidateButton"));

    if ( (lpButtons == NULL) || (nButtons < 1) )
        return (sc = E_INVALIDARG);

    for (int i=0; i < nButtons; i++)
    {
        if (lpButtons[i].nBitmap > GetImageCount())
        {
            sc = E_INVALIDARG;
            return sc;
        }

        // There should be button text if it is not a separator.
        if (((lpButtons[i].fsType & TBSTYLE_SEP) == 0) &&
            ((lpButtons[i].lpButtonText == NULL) ||
             (lpButtons[i].lpTooltipText == NULL)))
        {
            sc = E_INVALIDARG;
            return sc;
        }

        // There should be no bitmap set if it is a separator.
        if ( ((lpButtons[i].fsType & TBSTYLE_SEP) != 0) &&
             (lpButtons[i].nBitmap > 0) )
        {
            sc = E_INVALIDARG;
            return sc;
        }

		// Reset any TBSTATE_WRAP state.
		lpButtons[i].fsState &= (~TBSTATE_WRAP);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInsertButtonToToolbar
//
//  Synopsis:    Inserts the toolbar button into the main toolbar UI.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInsertButtonToToolbar (CMMCToolbarButton* pToolButton)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInsertButtonToToolbar"));
    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    // Button can be added only if view is active, button is not already added
    // to the toolbar & toolbar is attached.
    if (! m_fViewActive)
        return (sc);

    if (pToolButton->IsButtonIsAddedToUI())
        return sc;

    if (! IsToolbarAttached(pToolButton->GetToolbarNotify()))
        return sc;

    // Now get the main toolbar & add the button.
    CMMCToolBar* pToolBarUI = GetMainToolbar();
    sc = ScCheckPointers(pToolBarUI, E_UNEXPECTED);
    if (sc)
        return sc;

    TBBUTTON tbButton;
    ZeroMemory(&tbButton, sizeof(tbButton));
    tbButton.idCommand  = pToolButton->GetUniqueCommandID();
    tbButton.fsStyle    = pToolButton->GetStyle();
    tbButton.iBitmap    = pToolButton->GetBitmap();
    tbButton.fsState    = pToolButton->GetState();

    // The toolbar is hidden by customize view dialog.
    // If so insert the button as hidden. (Do not record
    // the hidden status into the CMMCToolbarButton).
    if (IsToolbarHidden(pToolButton->GetToolbarNotify()))
        tbButton.fsState |= TBSTATE_HIDDEN;

    // Insert the button.
    BOOL bRet = pToolBarUI->InsertButton(-1, &tbButton);
    sc = (bRet ? S_OK : E_FAIL);

    if (sc)
        return sc;

    pToolButton->SetButtonIsAddedToUI(true);

    // Bug 225711:  If the button is supposed to be hidden, hide it now.
    if (tbButton.fsState & TBSTATE_HIDDEN)
        sc = pToolBarUI->ScHideButton(tbButton.idCommand, true);

    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInsertButtonToDataStr
//
//  Synopsis:
//
//  Arguments:   [pNotifyCallbk] - The callbk interface for IToolbar imp.
//               [nIndex]        - Index of the button.
//               [lpButton]      - MMCBUTTON ptr.
//               [pToolButton]   - Return value, the button added (or found
//                                                in case of dup buttons).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInsertButtonToDataStr (CToolbarNotify* pNotifyCallbk,
                                              int nIndex,
                                              LPMMCBUTTON lpButton,
                                              CMMCToolbarButton** ppToolButton)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInsertButtonToDataStr"));

    sc = ScCheckPointers(pNotifyCallbk, ppToolButton);
    if (sc)
        return sc;

    sc = ScValidateButton(1, lpButton);
    if (sc)
        return sc;

    // Make sure snapin does not add duplicate buttons
    // For compatibility (services snapin) this is not a bug.
    *ppToolButton = GetToolbarButton(pNotifyCallbk, lpButton->idCommand);
    if (*ppToolButton)
    {
        // if snapin added the button we already have,
        // we still need to ensure its state (BUG: 439229)
        if ((*ppToolButton)->GetState() != lpButton->fsState)
        {
            // update the object
            (*ppToolButton)->SetState(lpButton->fsState);
            // do we need to update the UI as well?
            if (m_fViewActive && (*ppToolButton)->IsButtonIsAddedToUI())
            {
                INT  iCommandID = (*ppToolButton)->GetUniqueCommandID();
                if (!m_pMainToolbar->SetState(iCommandID, lpButton->fsState))
                    return (sc = E_FAIL);
            }
        }

        return sc;
    }


    // If this button belongs to different toolbar from last button
    // then insert a separator in between.
    if (! m_vToolbarButtons.empty())
    {
        CMMCToolbarButton& lastBtn = m_vToolbarButtons.back();
        if (lastBtn.GetToolbarNotify() != pNotifyCallbk)
        {
            CMMCToolbarButton separatorBtn(-1, GetUniqueCommandID(), -1, -1, 0, TBSTYLE_SEP, pNotifyCallbk);
            m_vToolbarButtons.push_back(separatorBtn);
        }
    }

    /*
     * Assume a snapin adds 3 bitmaps initialy & then 4 for a toolbar.
     * Then while adding buttons it will specify bitmap index as 5.
     *
     * So this toolbar will have two MMCToolbarImages objects in the multimap.
     *
     * The first  MMCToolbarImages has cCount = 3, iStartWRTSnapin = 0, thus
     * images from 0 (iStartWRTSnapin) to 3 (iStartWRTSnapin + cCount) with respect
     * to snapin.
     * The second MMCToolbarImages has cCount = 4, iStartWRTSnapin = 3, thus
     * images from 3(iStartWRTSnapin) to 7(iStartWRTSnapin + cCount) wrt snapin.
     *
     * The iStartWRTSnapin member is nothing but the largest of iStartWRTSnapin + cCount
     * in all of this toolbars MMCToolbarImages.
     *
     * Below we run thro different MMCToolbarImages for this toolbar and see in which
     * one the given index falls under and calculate the real index by adding that
     * object's iStart.
     *
     */

    // Now we need to compute the bitmap index. Find this toolbar in the multimap.
    int iBitmap = -1;

    std::pair<TBarToBitmapIndex::iterator, TBarToBitmapIndex::iterator>
                  range =  m_mapTBarToBitmapIndex.equal_range(pNotifyCallbk);

    while (range.first != range.second)
    {
        MMCToolbarImages images = (range.first)->second;

        // We need to find the bitmap whose start index is greater than or
        // equal to given index and upper index is less than given index.
        int nLastImageIndex = images.iStartWRTSnapin + images.cCount -1;
        if ( (lpButton->nBitmap >= images.iStartWRTSnapin ) &&
             ( lpButton->nBitmap <= nLastImageIndex ) )
        {
            iBitmap = images.iStart + lpButton->nBitmap;
            break;
        }

        (range.first)++;
    }

    // No bitmaps for separators.
    if ( (-1 == iBitmap) && (!(TBSTYLE_SEP & lpButton->fsType)) )
        return (sc = E_UNEXPECTED);


    // Create CMMCToolbarButton for each button, init it with unique command-id, toolbar id.
    // There is only one imagelist per view that contains bitmaps from different toolbars.
    // We use a multimap to identify a particular toolbar's bitmap start indices.
    CMMCToolbarButton newButton(lpButton->idCommand,
                             GetUniqueCommandID(),
                             nIndex,
                             (lpButton->fsType & TBSTYLE_SEP) ? 0 : iBitmap,
                             lpButton->fsState,
                             lpButton->fsType,
                             pNotifyCallbk);

    USES_CONVERSION;
    // First save the button data in CMMCToolButton.
    if (lpButton->lpTooltipText)
        newButton.SetTooltip(OLE2CT(lpButton->lpTooltipText));

    if (lpButton->lpButtonText)
        newButton.SetButtonText(OLE2CT(lpButton->lpButtonText));

    // Add this button to the end of our array.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.insert(m_vToolbarButtons.end(), newButton);
    if (m_vToolbarButtons.end() == itBtn)
        return (sc = E_FAIL);

    *ppToolButton = itBtn;
    sc = ScCheckPointers(*ppToolButton, E_OUTOFMEMORY);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScInsertButton
//
//  Synopsis:    Insert a button in our array & if the our view is active
//               add the button to the UI.
//
//  Arguments:   [pNotifyCallbk] - The callbk interface for IToolbar imp.
//               [nIndex]        - Index of the button.
//               [lpButton]      - MMCBUTTON ptr.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScInsertButton (CToolbarNotify* pNotifyCallbk, int nIndex, LPMMCBUTTON lpButton)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScInsertButton"));

    CMMCToolbarButton *pToolbarButton = NULL;

    sc = ScInsertButtonToDataStr(pNotifyCallbk, nIndex, lpButton, &pToolbarButton);
    if (sc)
        return sc;

    sc = ScInsertButtonToToolbar(pToolbarButton);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScAddButtons
//
//  Synopsis:    Save the buttons in our array and add them to UI if view is active.
//
//  Arguments:   [pNotifyCallbk] - Button click callback interface.
//               [nButtons]      - Number of buttons in lpButtons array.
//               [lpButtons]     - MMCBUTTONs (array) bo be added.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScAddButtons (CToolbarNotify* pNotifyCallbk, int nButtons, LPMMCBUTTON lpButtons)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScAddButtons"));

    for (int i = 0; i < nButtons; i++)
    {
        sc = ScInsertButton(pNotifyCallbk, -1, &(lpButtons[i]));
        if (sc)
            return sc;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDeleteButtonFromToolbar
//
//  Synopsis:    Deletes a button from the toolbar UI if it exists.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDeleteButtonFromToolbar (CMMCToolbarButton* pToolButton)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDeleteButtonFromToolbar"));

    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    if (! m_fViewActive)
        return (sc);

    if (! pToolButton->IsButtonIsAddedToUI())
        return sc;

    CMMCToolBar* pToolBarUI = GetMainToolbar();
    sc = ScCheckPointers(pToolBarUI, E_UNEXPECTED);
    if (sc)
        return sc;

    int nIndexOfBtn = pToolBarUI->CommandToIndex(pToolButton->GetUniqueCommandID());

	// Update the separators before deleting the button.
    pToolBarUI->UpdateSeparators(pToolButton->GetUniqueCommandID(), true);

    // Delete the button.
    BOOL bRet = pToolBarUI->DeleteButton(nIndexOfBtn);
    sc = (bRet ? S_OK : E_FAIL);

    if (sc)
        return sc;

    pToolButton->SetButtonIsAddedToUI(false);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDeleteButton
//
//  Synopsis:    Delete button at given index (index is wrt snapin).
//
//  Arguments:   [pNotifyCallbk]
//               [nIndex[
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDeleteButton (CToolbarNotify* pNotifyCallbk, int nIndex)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDeleteButton"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    // Now iterate thro all toolbuttons & find the one with
    // given toolbar-id & index and if it is added to the
    // toolbar UI then delete it.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if ( (pToolButton->GetToolbarNotify() == pNotifyCallbk) &&
             (pToolButton->GetIndexFromSnapin() == nIndex) )
        {
            sc = ScDeleteButtonFromToolbar(pToolButton);
            if (sc)
                return sc;

			return sc;
        }
    }

    // To be compatible with services snapin on Windows2000 return S_OK.
	sc = S_OK;
    TraceSnapinError(_T("IToolbar::DeleteButton, Snapin called IToolbar::DeleteButton, but the toolbar button is not found. Most likely the button index is wrong (snapin should have called InsertButton with that index)"), sc);
    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScAttach
//
//  Synopsis:    Make the toolbars visible (Add the toolbar buttons
//               to the toolbar UI). First get the CMMCToolbarData
//               and set attached flag. Then add the buttons to toolbar.
//
//  Arguments:   [pNotifyCallbk] - The toolbar identifier (corresponds
//                                 to the IToolbar imp).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScAttach (CToolbarNotify* pNotifyCallbk)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScAttach"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    SetToolbarAttached(pNotifyCallbk, true);

    // Go thro all ToolButtons of this toolbar and add those
    // buttons that are not yet added to the toolbar UI.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pToolButton->GetToolbarNotify() == pNotifyCallbk)
        {
            // Add this button to toolbar UI.
            sc = ScInsertButtonToToolbar(pToolButton);
            if (sc)
                return sc;
        }
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDetach
//
//  Synopsis:    Remove the toolbar buttons from the toolbar UI for
//               given toolbar.
//
//  Arguments:   [pNotifyCallbk] - The given (IToolbar) toolbar.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDetach (CToolbarNotify* pNotifyCallbk)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDetach"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    SetToolbarAttached(pNotifyCallbk, false);

    // Go thro all ToolButtons of this toolbar and delete those
    // buttons that are added to the toolbar UI.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pToolButton->GetToolbarNotify() == pNotifyCallbk)
        {
            // Delete this button from the toolbar UI.
            sc = ScDeleteButtonFromToolbar(pToolButton);
            if (sc)
                return sc;
        }
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScGetButtonStateInToolbar
//
//  Synopsis:    Get the state of given button from toolbar UI.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//               [byState]      - The TBSTATE needed.
//               [pbState]     - The button state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScGetButtonStateInToolbar(CMMCToolbarButton *pToolButton,
                                               BYTE  byState,
                                               BOOL* pbState)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScGetButtonStateInToolbar"));

    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    ASSERT(NULL != m_pMainToolbar);
    int idCommand = pToolButton->GetUniqueCommandID();

    // Make sure button with this command-id exists.
    if (m_pMainToolbar->GetState(idCommand) == -1)
        return (sc = E_INVALIDARG);

    switch (byState)
    {
    case TBSTATE_ENABLED:
        *pbState = m_pMainToolbar->IsButtonEnabled(idCommand);
        break;
    case TBSTATE_CHECKED:
        *pbState = m_pMainToolbar->IsButtonChecked(idCommand);
        break;
    case TBSTATE_HIDDEN:
        *pbState = m_pMainToolbar->IsButtonHidden(idCommand);
        break;
    case TBSTATE_INDETERMINATE:
        *pbState = m_pMainToolbar->IsButtonIndeterminate(idCommand);
        break;
    case TBSTATE_PRESSED:
        *pbState = m_pMainToolbar->IsButtonPressed(idCommand);
        break;
    default:
        sc = E_NOTIMPL;
        ASSERT(FALSE); // Invalid option
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScGetButtonState
//
//  Synopsis:    Get the state of the given button.
//
//  Arguments:   [pNotifyCallbk] - The toolbar (IToolbar).
//               [idCommand]     - Snapin given command-id of button.
//               [byState]       - The state needed.
//               [pbState]       - bool ret val.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScGetButtonState (CToolbarNotify* pNotifyCallbk,
                                      int idCommandFromSnapin, BYTE byState,
                                      BOOL* pbState)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScGetButtonState"));

    sc = ScCheckPointers(pNotifyCallbk, pbState);
    if (sc)
        return sc;

    // Get the toolbutton of given toolbar id & command-id.
    CMMCToolbarButton *pToolButton = GetToolbarButton(pNotifyCallbk, idCommandFromSnapin);
    sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
    if (sc)
        return sc;

    // The toolbutton is not available if view is not active or toolbar is hidden by
    // customize view dialog, then return the state from our data-structure.
    if (m_fViewActive && pToolButton->IsButtonIsAddedToUI() && (!IsToolbarHidden(pNotifyCallbk)) )
        sc = ScGetButtonStateInToolbar(pToolButton, byState, pbState);
    else
        // We cant access the toolbar UI. Return the state we saved.
        *pbState = (pToolButton->GetState() & byState);

    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScSetButtonStateInToolbar
//
//  Synopsis:    Set the state of a button in main toolbar UI.
//
//  Arguments:   [pToolButton] - The CMMCToolbarButton object.
//               [byState]     - The button state to be set.
//               [bState]      - Set or Reset the state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScSetButtonStateInToolbar (CMMCToolbarButton* pToolButton,
                                                BYTE byState,
                                                BOOL bState)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScSetButtonStateInToolbar"));

    sc = ScCheckPointers(pToolButton);
    if (sc)
        return sc;

    if(! m_fViewActive)
        return sc;

    if (! pToolButton->IsButtonIsAddedToUI())
        return sc;

    ASSERT(NULL != m_pMainToolbar);

    int idCommand = pToolButton->GetUniqueCommandID();

    BOOL bRet = FALSE;
    switch (byState)
    {
    case TBSTATE_ENABLED:
        bRet = m_pMainToolbar->EnableButton(idCommand, bState);
        break;

    case TBSTATE_CHECKED:
        bRet = m_pMainToolbar->CheckButton(idCommand, bState);
        break;

    case TBSTATE_HIDDEN:
        {
            int nButtonIndex = m_pMainToolbar->CommandToIndex(idCommand);

            // ignore unknown buttons
            if (nButtonIndex == -1)
                break;

            // ignore ineffectual changes (negate both sides to insure pure bool)
            if (!m_pMainToolbar->IsButtonHidden(idCommand) == !bState)
            {
                bRet = TRUE;
                break;
            }

            sc = m_pMainToolbar->ScHideButton(idCommand, bState);
            return sc;
            break;
        }

    case TBSTATE_INDETERMINATE:
        bRet = m_pMainToolbar->Indeterminate(idCommand, bState);
        break;

    case TBSTATE_PRESSED:
        bRet = m_pMainToolbar->PressButton(idCommand, bState);
        break;

    default:
        sc = E_NOTIMPL;
        ASSERT(FALSE); // Invalid option
        return sc;
    }

    sc = (bRet ? S_OK : E_FAIL);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScSetButtonState
//
//  Synopsis:    Set the state of a button.
//
//  Arguments:   [pNotifyCallbk] - The toolbar (IToolbar).
//               [byState]      - The button state to be set.
//               [bState]      - Set or Reset the state.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScSetButtonState (CToolbarNotify* pNotifyCallbk,
                                       int idCommandFromSnapin,
                                       BYTE byState, BOOL bSetState)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScSetButtonState"));

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

	// Reset any TBSTATE_WRAP state.
	byState &= (~TBSTATE_WRAP);

    // Get the toolbutton of given toolbar id & command-id.
    CMMCToolbarButton *pToolButton = GetToolbarButton(pNotifyCallbk, idCommandFromSnapin);
    sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
    if (sc)
        return (sc = S_OK); // Not an error.

    BYTE byNewState = (bSetState) ? (pToolButton->GetState() | byState) :
                                    (pToolButton->GetState() & (~byState) );

    pToolButton->SetState(byNewState);

    // The toolbar can be hidden by customize view dialog.

    // If the snapin tries to unhide a button in hidden toolbar just return.
    if ( (byState & TBSTATE_HIDDEN) && (!bSetState) && IsToolbarHidden(pNotifyCallbk) )
        return (sc = S_OK);

    sc = ScSetButtonStateInToolbar(pToolButton, byState, bSetState);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScOnActivateView
//
//  Synopsis:    The view of this object is active, add its toolbuttons.
//
//  Arguments:   [pAMCView]         - The AMCView ptr.
//               [bFirstActiveView] - Is this first active view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScOnActivateView (CAMCView *pAMCView,  // We dont care about this arg.
                                       bool bFirstActiveView)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScOnActivateView"));

    // If this is the first active view then insert the toolbar band.
    CMMCToolBar* pMainToolbar = GetMainToolbar();
    sc = ScCheckPointers(pMainToolbar, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScFireEvent(CAMCViewToolbarsObserver::ScOnActivateAMCViewToolbars, this);
	if (sc)
		sc.TraceAndClear();

    m_fViewActive = true;

    pMainToolbar->SetImageList(GetImageList());

    // Go thro all ToolButtons of this toolbar and add them to the UI.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        // Add this button to toolbar UI.
        sc = ScInsertButtonToToolbar(pToolButton);
        if (sc)
            return sc;
    }

    bool bToolbarBandVisible = pMainToolbar->IsBandVisible();
    bool bThereAreVisibleButtons = IsThereAVisibleButton();

    // If there are visible buttons show the band.
    if (bThereAreVisibleButtons)
        pMainToolbar->Show(true, true);
    else if (bToolbarBandVisible)      // Otherwise hide it if it is currently visible.
        pMainToolbar->Show(false);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScOnDeactivateView
//
//  Synopsis:    The view of this object is de-activated. Disable the
//               imagelists & this object should not manipulate the
//               toolbar UI till OnActivateView is fired.
//
//  Arguments:   [pAMCView]        - The view to be de-activated.
//               [bLastActiveView] - Is this the last view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScOnDeactivateView (CAMCView *pAMCView, bool bLastActiveView)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScOnDeactivateView"));

    CMMCToolBar* pMainToolbar = GetMainToolbar();
    sc = ScCheckPointers(pMainToolbar, E_UNEXPECTED);
    if (sc)
        return sc;

    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = ScDeleteButtonFromToolbar(pToolButton);

        if (sc)
            return sc;
    }

    sc = ScFireEvent(CAMCViewToolbarsObserver::ScOnDeactivateAMCViewToolbars);
	if (sc)
		sc.TraceAndClear();

    // If this is last view then delete the band if it is visible.
    if (bLastActiveView && pMainToolbar->IsBandVisible())
        pMainToolbar->Show(FALSE);

    m_bLastActiveView = bLastActiveView;

    m_fViewActive = false;

    return (sc);
}

//***************************************************************************
//
// CAMCViewToolbars::ScOnViewDestroyed
//
// PURPOSE: When the AMCView is destroyed, need to remove our own reference to it.
//
// PARAMETERS: 
//    CAMCView * pAMCView :
//
// RETURNS: 
//    SC
//
//****************************************************************************
SC  CAMCViewToolbars::ScOnViewDestroyed   (CAMCView *pAMCView)
{
    DECLARE_SC(sc, TEXT("CAMCViewToolbars::ScOnViewDestroyed"));

    ASSERT(m_pAMCViewOwner == pAMCView);

    m_pAMCViewOwner = NULL;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScButtonClickedNotify
//
//  Synopsis:    A button of this object is clicked. Get the context
//               and inform the CToolbarNotify object.
//
//  Arguments:   [nID] - command id of the button clicked.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScButtonClickedNotify (UINT nID)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScButtonClickedNotify"));

    CMMCToolbarButton* pButton = GetToolbarButton(nID);
    sc = ScCheckPointers(pButton, m_pAMCViewOwner, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the context, (the currently selected HNODE,
    // lParam (if result item)) etc...
    HNODE hNode;
    bool  bScope;
    LPARAM lParam;

    sc = m_pAMCViewOwner->ScGetFocusedItem (hNode, lParam, bScope);
    if (sc)
        return sc;

    CToolbarNotify* pNotifyCallbk = pButton->GetToolbarNotify();
    sc = ScCheckPointers(pNotifyCallbk, E_UNEXPECTED);
    if (sc)
        return sc;

	// Deactivate if theming (fusion or V6 common-control) context before calling snapins.
	ULONG_PTR ulpCookie;
	if (! MmcDownlevelActivateActCtx(NULL, &ulpCookie)) 
		return E_FAIL;


    // the ScNotifyToolBarClick could cause this object to be deleted. Therefore, this
    // class was changed to be reference counted. The object is locked here and released at the end
    // of the function to avoid an AV in ScFireEvent.
    AddRef();

    do // this while ensures that the release is called.
    {
        sc  = pNotifyCallbk->ScNotifyToolBarClick(hNode, bScope, lParam, pButton->GetCommandIDFromSnapin());

        MmcDownlevelDeactivateActCtx(0, ulpCookie);
        if (sc)
            break;

        // fire event informing about execution
        sc = ScFireEvent(CAMCViewToolbarsObserver::ScOnToolbarButtonClicked);
        if (sc)
            break;
    }
    while(0);

    Release();

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScGetToolTip
//
//  Synopsis:    Tooltip is requested for a button of this object.
//
//  Arguments:   [nCommandID] - Command id of the button.
//               [strTipText] - CString to hold the tooltip.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScGetToolTip (int nCommandID, CString& strTipText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScGetToolTip"));

    // Get the toolbutton.
    CMMCToolbarButton* pButton = GetToolbarButton(nCommandID);
    sc = ScCheckPointers(pButton, E_UNEXPECTED);
    if (sc)
        return sc;

    strTipText = pButton->GetTooltip();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScDelete
//
//  Synopsis:    A toolbar needs to be deleted. First remove the buttons
//               from UI & remove buttons from our data structure,
//               remove the toolbar reference from our data structures.
//
//  Arguments:   [pNotifyCallbk] - The toolbar (IToolbar).
//
//  Returns:     SC
//
//  Note:        This method should remove its reference of CToolbarNotify
//               object when it returns (even if it encounters intermediate errors).
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScDelete (CToolbarNotify* pNotifyCallbk)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScDelete"));
    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    ToolbarButtons::iterator itBtn;
    // Detach the toolbar first.
    sc = ScDetach(pNotifyCallbk);
    if (sc)
        goto Cleanup;

    // Delete the buttons from m_vToolbarButtons.
    itBtn = m_vToolbarButtons.begin();
    while (itBtn != m_vToolbarButtons.end())
    {
        CMMCToolbarButton* pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            goto Cleanup;

        if (pToolButton->GetToolbarNotify() == pNotifyCallbk)
        {
            sc = ScDeleteButtonFromToolbar(pToolButton);
            if (sc)
                goto Cleanup;

            itBtn = m_vToolbarButtons.erase(itBtn);
        }
        else
            ++itBtn;
    }

Cleanup:
    // The toolbar client has asked us to remove our reference
    // to it. So even if there is any error encountered we
    // should remove the reference.
    m_mapTBarToBitmapIndex.erase(pNotifyCallbk);
    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::ScShow
//
//  Synopsis:    Show/Hide buttons of a toolbar.
//
//  Arguments:   [pNotifyCallbk] - Identifies the toolbar
//               [bShow]         - Show/Hide.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCViewToolbars::ScShow (CToolbarNotify* pNotifyCallbk, BOOL bShow)
{
    DECLARE_SC(sc, _T("CAMCViewToolbars::ScShow"));

    if (m_bLastActiveView)
        return sc;

    sc = ScCheckPointers(pNotifyCallbk);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pMainToolbar, E_UNEXPECTED);
    if (sc)
        return sc;

    // Go thro all ToolButtons of this toolbar and hide or show them.
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton *pToolButton = itBtn;
        sc = ScCheckPointers(pToolButton, E_UNEXPECTED);
        if (sc)
            return sc;

        if ( (pToolButton->GetToolbarNotify() == pNotifyCallbk) &&
             (pToolButton->IsButtonIsAddedToUI()) )
        {
            // Do not show the buttons which should be hidden (TBSTATE_HIDDEN).
            BOOL bHide = (bShow == FALSE) || (pToolButton->GetState() & TBSTATE_HIDDEN);

            sc = m_pMainToolbar->ScHideButton(pToolButton->GetUniqueCommandID(), bHide);
            if (sc)
                return sc;
        }
    }

    // The toolbar is hidden/shown by customize view dialog.
    SetToolbarStatusHidden(pNotifyCallbk, (FALSE == bShow) );

    if (bShow)
        m_pMainToolbar->Show(TRUE, true /* insert band in new line*/ );
    else if ( (false == IsThereAVisibleButton()) && // If there is no visible
               (m_pMainToolbar->IsBandVisible()) )   // buttons hide the band.
        m_pMainToolbar->Show(FALSE);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::IsThereAVisibleButton
//
//  Synopsis:    Returns true if there is any visible button. If not
//               the band should be hidden (or removed).
//
//  Returns:     bool
//
//--------------------------------------------------------------------
bool CAMCViewToolbars::IsThereAVisibleButton()
{
    if (! m_pMainToolbar)
        return false;

    int cButtons = m_pMainToolbar->GetButtonCount();

    for (int i = 0; i < cButtons; ++i)
    {
        TBBUTTON tbButton;

        if (m_pMainToolbar->GetButton(i, &tbButton))
        {
            // If the button is not hidden return true to
            // IsThereAVisibleButton question.
            if ( !(tbButton.fsState & TBSTATE_HIDDEN) )
                return true;
        }
    }

    return false;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::GetToolbarButton
//
//  Synopsis:    Given the command ID return the button object.
//
//  Arguments:   [nCommandID] -
//
//  Returns:     CMMCToolbarButton obj.
//
//--------------------------------------------------------------------
CMMCToolbarButton* CAMCViewToolbars::GetToolbarButton(int nUniqueCommandID)
{
    ToolbarButtons::iterator itBtns = m_vToolbarButtons.begin();

    for (; itBtns != m_vToolbarButtons.end(); ++itBtns)
    {
        if ((itBtns)->GetUniqueCommandID() == nUniqueCommandID)
            return (itBtns);
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCViewToolbars::GetToolbarButton
//
//  Synopsis:    Search for the button with given toolbar id & command id.
//
//  Arguments:   [idToolbar] -
//               [idCommand] - Command id given by snapin (therfore may not be unique).
//
//  Returns:     the toolbutton object.
//
//--------------------------------------------------------------------
CMMCToolbarButton* CAMCViewToolbars::GetToolbarButton(CToolbarNotify* pNotifyCallbk, int idCommandIDFromSnapin)
{
    ToolbarButtons::iterator itBtn = m_vToolbarButtons.begin();
    for (;itBtn != m_vToolbarButtons.end(); ++itBtn)
    {
        CMMCToolbarButton* pToolButton = (itBtn);
        if ( (pToolButton->GetToolbarNotify() == pNotifyCallbk) &&
             (pToolButton->GetCommandIDFromSnapin() == idCommandIDFromSnapin) )
        {
            return (pToolButton);
        }
    }

    return NULL;
}



const int CMMCToolBar::s_nUpdateToolbarSizeMsg =
        RegisterWindowMessage (_T("CMMCToolBar::WM_UpdateToolbarSize"));

// Command Ids for buttons must start from 1, since 0 is special case by MFC (BUG:451883)
// For tooltips the child ids of the control is used. This range is 0x0 to 0xFFFF.
BEGIN_MESSAGE_MAP(CMMCToolBar, CMMCToolBarCtrlEx)
    ON_COMMAND_RANGE(MMC_TOOLBUTTON_ID_FIRST, MMC_TOOLBUTTON_ID_LAST, OnButtonClicked)
    ON_UPDATE_COMMAND_UI_RANGE(MMC_TOOLBUTTON_ID_FIRST, MMC_TOOLBUTTON_ID_LAST, OnUpdateAllCmdUI)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xFFFF, OnToolTipText)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xFFFF, OnToolTipText)
    ON_REGISTERED_MESSAGE(s_nUpdateToolbarSizeMsg, OnUpdateToolbarSize)
END_MESSAGE_MAP()


//+-------------------------------------------------------------------
//
//  Member:      ScInit
//
//  Synopsis:    Initialize this toolbar by creating the UI object.
//
//  Arguments:   [pRebar]       - The parent rebar where this toolbar should be added.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScInit(CRebarDockWindow* pRebar)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CMMCToolBar::ScInit"));
    sc = ScCheckPointers(pRebar);
    if (sc)
        return sc;

    // Enable tool-tips for the tool-buttons.
    BOOL bRet = Create (NULL, WS_VISIBLE | TBSTYLE_TOOLTIPS, g_rectEmpty, pRebar, ID_TOOLBAR);
    sc = (bRet ? S_OK : E_FAIL);
    if (sc)
        return sc;

    // Set ComCtrl version as 5 to use multiple imagelists.
    LRESULT lOldVer = SendMessage(CCM_SETVERSION, (WPARAM) 5, 0);
    if (lOldVer == -1)
        return (sc = E_FAIL);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      OnButtonClicked
//
//  Synopsis:    A button of this toolbar is clicked, tell the
//               toolbars manager to notify the client
//               (std toolbar or snapin) about this.
//
//  Arguments:   [nID] - The ID of the button clicked.
//
//  Returns:     None.
//
//--------------------------------------------------------------------
void CMMCToolBar::OnButtonClicked(UINT nID)
{
    DECLARE_SC(sc, _T("CMMCToolBar::OnButtonClicked"));

    sc = ScCheckPointers(m_pActiveAMCViewToolbars, E_UNEXPECTED);
    if (sc)
        return;

    // Inform the active view toolbar object about button click.
    sc = m_pActiveAMCViewToolbars->ScButtonClickedNotify(nID);
    if (sc)
        return;

    return;
}


//+-------------------------------------------------------------------
//
//  Member:      OnToolTipText
//
//  Synopsis:    Tool-tips are requested for a button. (message handler).
//
//  Arguments:
//               [nCID]    - Not used.
//               [pNMHDR]  - Tool-tips for what?
//               [pResult] - tool-tip text.
//
//  Returns:     BOOL.
//
//--------------------------------------------------------------------
BOOL CMMCToolBar::OnToolTipText(UINT nCID, NMHDR* pNMHDR, LRESULT* pResult)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);
    DECLARE_SC(sc, _T("CMMCToolBar::OnToolTipText"));

    CString strTipText = _T("\n");

    // need to handle both ANSI and UNICODE versions of the message
    TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
    TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;

    UINT nID = pNMHDR->idFrom;

    if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
        pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
    {
        // idFrom is actually the HWND of the tool,
        // this cannot be true since we did not set this.
        ASSERT(FALSE);
    }

    if (nID != 0) // will be zero on a separator // this is the command id, not the button index
    {
        // Ask the active view's CViewToolBarData for tooltip
        // corresponding to toolbar with command-id nID.
        sc = ScCheckPointers(m_pActiveAMCViewToolbars, E_UNEXPECTED);
        if (sc)
            return FALSE;

        sc = m_pActiveAMCViewToolbars->ScGetToolTip(nID, strTipText);

        if (sc)
        {
            // No match.
            #ifdef DBG
                strTipText = _T("Unable to get tooltip\nUnable to get tooltip");
            #else
                strTipText = _T("\n");
            #endif
        }
    }

    /*
     * Common control provides either TOOLTIPTEXTA or TOOLTIPTEXTW. So MMC needs to
     * provide wide char string or ansi string as tooltip. So below we have two kind
     * of string buffers.
     *
     * Also common control does not free the given string, but it copies the tooltip
     * as soon as this method returns. So we make the strings as static so that we
     * can reuse them.
     *
     * Also see ID: Q180646.
     */
    static std::string   strToolTipTextBuf;
    static std::wstring wstrToolTipTextBuf;

    USES_CONVERSION;

    if (pNMHDR->code == TTN_NEEDTEXTA)
    {
        wstrToolTipTextBuf = L"\0";
		ASSERT(pTTTA->hinst == NULL);
        strToolTipTextBuf  = T2CA((LPCTSTR)strTipText);
        pTTTA->lpszText    = const_cast<LPSTR>(strToolTipTextBuf.data());
    }
    else
    {
        strToolTipTextBuf = "\0";
	    ASSERT(pTTTW->hinst == NULL);
        wstrToolTipTextBuf = T2CW((LPCTSTR)strTipText);
        pTTTW->lpszText    = const_cast<LPWSTR>(wstrToolTipTextBuf.data());
    }

    *pResult = 0;

    return TRUE;    // message was handled
}


//+-------------------------------------------------------------------
//
//  Member:      CMMCToolBar::ScOnActivateAMCViewToolbars
//
//  Synopsis:    A cAMCViewToolbars object become the active one (since
//               that objects parent view become active). Cache the
//               object to inform it of toolbutton events.
//
//  Arguments:   [pToolbarsOfView] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScOnActivateAMCViewToolbars (CAMCViewToolbars *pAMCViewToolbars)
{
    DECLARE_SC(sc, _T("CMMCToolBar::ScOnActivateAMCViewToolbars"));
    sc = ScCheckPointers(pAMCViewToolbars);
    if (sc)
        return sc;

    m_pActiveAMCViewToolbars = pAMCViewToolbars;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnDeactivateAMCViewToolbars
//
//  Synopsis:    The CAMCViewToolbars object became inactive (as its parent
//               became inactive). Reset the cached active toolbar object.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScOnDeactivateAMCViewToolbars ()
{
    DECLARE_SC(sc, _T("CAMCView::ScOnDeactivateAMCViewToolbars"));

    m_pActiveAMCViewToolbars = NULL;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCToolBar::ScHideButton
//
//  Synopsis:    Hide or Un-hide a button & update the toolbar
//               separators & size.
//
//  Arguments:   [idCommand] - Command ID of the button to [un]hide.
//               [fHiding]   - Hide or Unhide.
//
//  Returns:     SC
//
//  Note:        Do not call this method to hide separators.
//
//--------------------------------------------------------------------
SC CMMCToolBar::ScHideButton (int idCommand, BOOL fHiding)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CMMCToolBar::ScHideButton"));

    int nIndex = CommandToIndex(idCommand);

    TBBUTTON tbButton;
    BOOL bRet = GetButton(nIndex, &tbButton);
    sc = bRet ? S_OK : E_FAIL;
    if (sc)
        return sc;

    // Dont call this method to hide separators.
    if (tbButton.fsStyle & TBSTYLE_SEP)
        return (sc = S_FALSE);

    bRet = HideButton(idCommand, fHiding);
    sc = bRet ? S_OK : E_FAIL;
    if (sc)
        return sc;

    UpdateSeparators (idCommand, fHiding);
    UpdateToolbarSize(true /* Update Asynch'ly*/);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      UpdateToolbarSize
//
//  Synopsis:    Update the toobar, needed to lazy update (not update
//               after adding each button, cache all the buttons) of
//               toolbar size.
//
//  Arguments:   [bAsync] - Asynchronous or Synch update.
//
//  Returns:     void
//
//--------------------------------------------------------------------
void CMMCToolBar::UpdateToolbarSize(bool bAsync)
{
    MSG msg;

    HWND hWnd = m_hWnd;

    if (!bAsync)
        CToolBarCtrlEx::UpdateToolbarSize();
    else if (!PeekMessage (&msg, m_hWnd, s_nUpdateToolbarSizeMsg, s_nUpdateToolbarSizeMsg, PM_NOREMOVE))
        ::PostMessage (m_hWnd, s_nUpdateToolbarSizeMsg, 0, 0);
}

//+-------------------------------------------------------------------
//
//  Member:      OnUpdateToolbarSize
//
//  Synopsis:    Our registered message handler.
//
//  Arguments:   None used.
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CMMCToolBar::OnUpdateToolbarSize(WPARAM , LPARAM)
{
    CToolBarCtrlEx::UpdateToolbarSize();
    return 0;
}

/*--------------------------------------------------------------------------*
 * CMMCToolBar::UpdateSeparators
 *
 * The legend for the comments below is:
 *
 *      L = left edge
 *      R = right edge
 *      * = target button
 *      B = visible non-separator
 *      b = hidden non-separator
 *      S = visible separator
 *      s = hidden separator
 *      h = 0 or more hidden buttons, separator or non-separator
 *--------------------------------------------------------------------------*/
void CMMCToolBar::UpdateSeparators (int idCommand, BOOL fHiding)
{
    int nButtonIndex = CommandToIndex (idCommand);

    if (nButtonIndex == -1)
        return;

    int nLeftVisible;
    int nRightVisible;
    int cButtons = GetButtonCount ();

    /*
     * If the button is being hidden, turn off any separators
     * that are now redundant.  There are three situations where
     * we'll need to turn off a separator (see legend above):
     *
     * 1.  Lh*hS
     * 2.  Sh*hS
     * 3.  Sh*hR
     *
     * These situations are mutually exclusive.
     */
    if (fHiding)
    {
        TBBUTTON btnLeft;
        TBBUTTON btnRight;

        /*
         * look to the left of the button being hidden for the
         * left edge or a visible button
         */
        for (nLeftVisible = nButtonIndex-1; nLeftVisible >= 0; nLeftVisible--)
        {
            GetButton (nLeftVisible, &btnLeft);

            if (!(btnLeft.fsState & TBSTATE_HIDDEN))
                break;
        }
        ASSERT (nLeftVisible <  nButtonIndex);
        ASSERT (nLeftVisible >= -1);


        /*
         * look to the right of the button being hidden for the
         * right edge or a visible separator
         */
        for (nRightVisible = nButtonIndex+1; nRightVisible < cButtons; nRightVisible++)
        {
            GetButton (nRightVisible, &btnRight);

            if (!(btnRight.fsState & TBSTATE_HIDDEN))
                break;
        }
        ASSERT (nRightVisible >  nButtonIndex);
        ASSERT (nRightVisible <= cButtons);


        /*
         * case 1:  Lh*hS
         */
        if ((nLeftVisible == -1) &&
            (nRightVisible != cButtons) &&
            (btnRight.fsStyle & TBSTYLE_SEP))
            HideButton (btnRight.idCommand, true);

        /*
         * case 2:  Sh*hS
         */
        else if ((nLeftVisible != -1) &&
                 (nRightVisible != cButtons) &&
                 (btnLeft.fsStyle  & TBSTYLE_SEP) &&
                 (btnRight.fsStyle & TBSTYLE_SEP))
            HideButton (btnRight.idCommand, true);

        /*
         * case 3:  Sh*hR
         */
        else if ((nLeftVisible != -1) &&
                 (nRightVisible == cButtons) &&
                 (btnLeft.fsStyle & TBSTYLE_SEP))
            HideButton (btnLeft.idCommand, true);
    }

    /*
     * Otherwise, the button is being shown; turn on any separators
     * that are no longer redundant.  There are two situations where
     * we'll need to turn on a separator (see legend above):
     *
     * 1.  Bhsh*
     * 2.  *hshB
     *
     * Both 1 and 2 can occur simultaneously.
     */
    else do // not a loop
        {
            TBBUTTON btn;

            /*
             * look to the left of the button being shown for the
             * left edge or a visible button
             */
            int idLeftSeparatorCommand = -1;
            for (nLeftVisible = nButtonIndex-1; nLeftVisible >= 0; nLeftVisible--)
            {
                GetButton (nLeftVisible, &btn);

                if (btn.fsStyle & TBSTYLE_SEP)
                    idLeftSeparatorCommand = btn.idCommand;

                if (!(btn.fsState & TBSTATE_HIDDEN))
                    break;
            }
            ASSERT (nLeftVisible <  nButtonIndex);
            ASSERT (nLeftVisible >= -1);


            /*
             * look to the right of the button being shown for the
             * right edge or a hidden separator
             */
            int idRightSeparatorCommand = -1;
            for (nRightVisible = nButtonIndex+1; nRightVisible < cButtons; nRightVisible++)
            {
                GetButton (nRightVisible, &btn);

                if (btn.fsStyle & TBSTYLE_SEP)
                    idRightSeparatorCommand = btn.idCommand;

                if (!(btn.fsState & TBSTATE_HIDDEN))
                    break;
            }
            ASSERT (nRightVisible >  nButtonIndex);
            ASSERT (nRightVisible <= cButtons);


            /*
             * case 1:  Bhsh*
             */
            if ((nLeftVisible != -1) && (idLeftSeparatorCommand != -1))
                HideButton (idLeftSeparatorCommand, false);

            /*
             * case 2:  *hshB
             */
            if ((nRightVisible != cButtons) && (idRightSeparatorCommand != -1))
                HideButton (idRightSeparatorCommand, false);

        } while (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\conui\toolbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       toolbar.h
//
//              Toolbars implementation
//
/////////////////////////////////////////////////////////////////////////////

#ifndef TOOLBAR_H
#define TOOLBAR_H

#include "tstring.h"
#include "toolbars.h"

/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include "atlapp.h"
#include "atlctrls.h"

#define  BUTTON_BITMAP_SIZE 16

// Command Ids for buttons.

// we must start from 1, since 0 is special case by MFC (BUG:451883)
#define   MMC_TOOLBUTTON_ID_FIRST  0x0001

// End with 0x5000 as ids from 0x5400 are used for toolbar hot tracking.
// A better soln will be to disable all the toolbar tracking code (in tbtrack.*)
// and use the toolbar tracking provided by the toolbars & rebars implementation.
#define   MMC_TOOLBUTTON_ID_LAST   0x5000

// Forward declarations.
class CMMCToolBar;
class CAMCViewToolbars;

//+-------------------------------------------------------------------
//
//  Class:      CMMCToolbarButton
//
//  Purpose:    The toolbar button data, the CAMCViewToolbars will
//              create this object on request to AddButton/InsertButton
//              call and is destroyed when DeleteButton is called
//              or the IToolbar is destroyed (snapin destroys its
//              toolbar).
//              It knows about its toolbar thro CToolbarNotify.
//
//  History:    12-01-1999   AnandhaG   Created
//
// Note:        The fsState refers only to the state set by snapin
//              and wont be set hidden if toolbar is hidden.
//
//--------------------------------------------------------------------
class CMMCToolbarButton
{
public:
    CMMCToolbarButton(); // Vector of CMMCToolbarButton's requires empty ctor.

    CMMCToolbarButton(int nCommandIDFromSnapin, int nUniqueCommandID,
                      int indexFromSnapin, int iImage,
                      BYTE fsState, BYTE fsStyle, CToolbarNotify* pToolbarNotify)
    : m_nCommandIDFromSnapin(nCommandIDFromSnapin),
      m_nUniqueCommandID(nUniqueCommandID),
      m_indexFromSnapin(indexFromSnapin),
      m_iImage(iImage),
      m_fsState(fsState),
      m_fsStyle(fsStyle),
      m_fAddedToUI(false),
      m_pToolbarNotify(pToolbarNotify)
    {
    }

    // Data accessors.
    LPCTSTR GetTooltip() {return m_strTooltip.data();}
    int     GetCommandIDFromSnapin() const {return m_nCommandIDFromSnapin;}
    int     GetUniqueCommandID() const {return m_nUniqueCommandID;}
    int     GetIndexFromSnapin() const {return m_indexFromSnapin;}
    int     GetBitmap() const {return m_iImage;}
    BYTE    GetStyle() const {return m_fsStyle;}
    BYTE    GetState() const {return m_fsState;}
    CToolbarNotify* GetToolbarNotify() const {return m_pToolbarNotify;}

    void    SetTooltip(LPCTSTR lpszTiptext)
    {
        m_strTooltip = lpszTiptext;
    }
    void    SetButtonText(LPCTSTR lpszBtntext)
    {
        m_strBtnText = lpszBtntext;
    }
    void    SetState(BYTE fsState) {m_fsState = fsState;}

    // Keep track if this button is added to the toolbar UI or not.
    void    SetButtonIsAddedToUI   (bool b = true) { m_fAddedToUI = b; }
    bool    IsButtonIsAddedToUI    () const        { return m_fAddedToUI;}

private:
    int                m_nCommandIDFromSnapin;
    int                m_nUniqueCommandID;
    int                m_iImage;
    int                m_indexFromSnapin;
    int                m_indexUnique;
    BYTE               m_fsState;
    BYTE               m_fsStyle;
    bool               m_fAddedToUI : 1;
    CToolbarNotify*    m_pToolbarNotify;
    tstring            m_strTooltip;
    tstring            m_strBtnText;
};

//+-------------------------------------------------------------------
//
//  Class:      CAMCViewToolbars
//
//  Synopsis:   This object maintains data for the toolbars of a CAMCView.
//              When its view is active it adds the toolbar buttons to the
//              main toolbar UI and handles any of the UI messages.
//
//  Desc:       This object is created and destroyed by the view. It
//              provides following services.
//              1. ability to create/destroy toolbars for this view.
//              2. to manipulate single toolbar. It maintains an array of
//                 toolbuttons from all snapins including std toolbar.
//              3. to observe the view for activation & de-activation.
//                 When the view becomes active it adds the buttons & handles
//                 any button click & tooltip notifications.
//              4. It maintains a single imagelist for all the toolbars for
//                 this object. To get image index for a tool button it maintains
//                 a map of CToolbarNotify* (the snapin toolbar) and imagelist
//                 information like start index & number of images for this CToolbarNotify*
//                 in that imagelist.
//
//              It also provides unique command id for each button (as there is only
//              one toolbar UI which needs unique command id for each button from
//              different snapin).
//
//  History:    12-01-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CAMCViewToolbars : public CAMCViewToolbarsMgr,
                         public CMMCToolbarIntf,
                         public CAMCViewObserver,
                         public CEventSource<CAMCViewToolbarsObserver>
{
public:
    CAMCViewToolbars()
    : m_fViewActive(false), m_pMainToolbar(NULL), m_pAMCViewOwner(NULL), m_bLastActiveView(false)
    {
    }

    virtual ~CAMCViewToolbars();

    // implemented by CRefCountedObject
    virtual     LONG AddRef() = 0;
    virtual     LONG Release() = 0;

public:
    // Creation & manipulation of toolbar/toolbars.
    virtual SC ScCreateToolBar(CMMCToolbarIntf** ppToolbarIntf);
    virtual SC ScDisableToolbars();

    // Manipulate given toolbar.
    virtual SC ScAddButtons(CToolbarNotify* pNotifyCallbk, int nButtons, LPMMCBUTTON lpButtons);
    virtual SC ScAddBitmap (CToolbarNotify* pNotifyCallbk, INT nImages, HBITMAP hbmp, COLORREF crMask);
    virtual SC ScInsertButton(CToolbarNotify* pNotifyCallbk, int nIndex, LPMMCBUTTON lpButton);
    virtual SC ScDeleteButton(CToolbarNotify* pNotifyCallbk, int nIndex);
    virtual SC ScGetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL* pbState);
    virtual SC ScSetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL bState);
    virtual SC ScAttach(CToolbarNotify* pNotifyCallbk);
    virtual SC ScDetach(CToolbarNotify* pNotifyCallbk);
    virtual SC ScDelete(CToolbarNotify* pNotifyCallbk);
    virtual SC ScShow(CToolbarNotify* pNotifyCallbk, BOOL bShow);

    // Observer on view (for activation & de-activation).
    virtual SC  ScOnActivateView    (CAMCView *pAMCView, bool bFirstActiveView);
    virtual SC  ScOnDeactivateView  (CAMCView *pAMCView, bool bLastActiveView);
    virtual SC  ScOnViewDestroyed   (CAMCView *pAMCView);


    // Methods used by toolbar UI (to inform button click & to get tooltip).
    SC ScButtonClickedNotify(UINT nID);
    SC ScGetToolTip(int nCommandID, CString& strTipText);

    // Method used by CAMCView to Init.
    SC ScInit(CMMCToolBar *pMainToolbar, CAMCView* pAMCViewOwner);

private:
    static int GetUniqueCommandID()
    