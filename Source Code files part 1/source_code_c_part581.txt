 performance is reasonable. Low input volume
							// signals are usually detected ok, but dropouts are
							// a bit common. However, noise is sometimes still
							// detected, so making these parameters more sensitive
							// would not be useful.
//#define VA_HIGH_PERCENT 165 // catches occational noise
//#define VA_HIGH_PERCENT 160 // catches too much noise
//#define VA_HIGH_PERCENT 150 // catches most noise
//#define VA_HIGH_PERCENT 140 // catches almost all noise
//#define VA_HIGH_PERCENT 0x00007fff // select this to factor out this VA parameter

// VA_LOW_PERCENT
//
// If the fast envelope signal is more than this percentage
// lower than the slow envelope signal, speech is detected.
//
#define VA_LOW_PERCENT 50 // excellent noise rejection. poor detection of speech.
						  // when used alone, could miss entire phrases. Must evaluate
						  // in conjunction with tuned VA_HIGH_PERCENT
						  //
						  // See note above re: testing in conjunction with VA_HIGH_PERCENT
//#define VA_LOW_PERCENT 55 // still catches too much noise
//#define VA_LOW_PERCENT 60 // catches most noise
//#define VA_LOW_PERCENT 65 // catches most noise
//#define VA_LOW_PERCENT 70 // still catches almost all noise
//#define VA_LOW_PERCENT 75 // catches almost all noise
//#define VA_LOW_PERCENT 80 // catches all noise
//#define VA_LOW_PERCENT 0 // select this to factor out this VA parameter

// VA_HIGH_ENVELOPE
//
// If the 16 bit normalized value of the envelope exceeds
// this number, the signal is considered voice.
//
//#define VA_HIGH_ENVELOPE (15 << 8) // still catches high gain noise, starting to get 
								   // speech dropouts, when "p" sounds lower the gain
#define VA_HIGH_ENVELOPE (14 << 8) // Noise immunity good at "seated" S/N ratio. No speech
								   // dropouts encountered. Still catches noise at full gain.
//#define VA_HIGH_ENVELOPE (13 << 8) // Noise immunity not as good as expected (new day).
//#define VA_HIGH_ENVELOPE (12 << 8) // Good noise immunity. Speech recognition excellent.
								   // Only one dropout occured in the test with a 250ms
								   // hangover. I think the hangover time should be increased
								   // above 250 however, because a comma (properly read) tends 
								   // to cause a dropout. I'm going to tune the hangover time, 
								   // and return to this test.
								   //
								   // Hangover time is now 400ms. No dropouts occur with
								   // "seated" speech.
//#define VA_HIGH_ENVELOPE (11 << 8) // Catches almost no noise at "seated" gain
								   // however, if the gain creeped up a bit, noise would
								   // be detected. I therefore think a slightly higher 
								   // threshold would be a good idea. The speech recognition
								   // based on only this parameter at this level was flawless.
								   // No dropouts at all with a 250 ms hangover time. (commas
								   // excepted).
//#define VA_HIGH_ENVELOPE (10 << 8) // catches some noise at "seated" gain - getting very close
//#define VA_HIGH_ENVELOPE (9 << 8) // catches some noise at "seated" gain - getting close
//#define VA_HIGH_ENVELOPE (8 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (7 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (0x7fffffff) // select this to factor out this VA parameter

// VA_LOW_ENVELOPE
//
// If the 16 bit normalized value of the envelope is below
// this number, the signal will never be considered voice.
// This reduces some false positives on the delta checks
// at very low signal levels
#define VA_LOW_ENVELOPE (3 << 8)
//#define VA_LOW_ENVELOPE (2 << 8) // causes false VA at low input volumes
//#define VA_LOW_ENVELOPE (1 << 8) // causes false VA at low input volumes

// VA_HANGOVER_TIME
//
// The time, in milliseconds, that voice activation sticks in
// the ON position following a voice detection. E.g. a value of 500
// means that voice will always be transmitted in at least 1/2 second
// bursts.
//
// I am trying to tune this so that a properly read comma will not cause
// a dropout. This will give the user a bit of leeway to pause in the
// speech stream without losing the floor when in Echo Suppression mode.
// It will also prevent dropouts even when not in Echo Suppression mode
#define VA_HANGOVER_TIME 400 // this gives satisfying performance
//#define VA_HANGOVER_TIME 375 // almost there, longest commas still goners
//#define VA_HANGOVER_TIME 350 // still drops long commas
//#define VA_HANGOVER_TIME 325 // does not drop fast commas, drops long ones
//#define VA_HANGOVER_TIME 300 // drops almost no commas, quite good
//#define VA_HANGOVER_TIME 275 // drops about half of the commas
//#define VA_HANGOVER_TIME 250 // commas are always dropped

// macros to avoid clib dependencies
#define DV_ABS(a) ((a) < 0 ? -(a) : (a))
#define DV_MAX(a, b) ((a) > (b) ? (a) : (b))
#define DV_MIN(a, b) ((a) < (b) ? (a) : (b))

// A function to lookup the log of n base 1.354 (sort of)
// where 0 <= n <= 127
//
// Why the heck do we care about log n base 1.354???
//
// What we need is a function that maps 0 to 127 down to 0 to 15
// in a nice, smooth non-linear fashion that has more fidelity at
// the low end than at the high end.
//
// The function is actually floor(log(n, 1.354), 1) to keep things
// in the integer realm.
//
// Why 1.354? Because log(128, 1.354) = 16, so we are using the full
// range from 0 to 15.
// 
// This function also cheats and just defines fn(0) = 0 and fn(1) = 1
// for convenience.
BYTE DV_LOG_1_354_lookup_table[95] = 
{
	 0,  1,  2,  3,  4,  5,  5,  6,	//   0..  7
	 6,  7,  7,  7,  8,  8,  8,  8, //   8.. 15
	 9,  9,  9,  9,  9, 10, 10, 10, //  16.. 23
	10, 10, 10, 10, 10, 11, 11, 11,	//  24.. 31
	11, 11, 11, 11, 11, 11, 12, 12, //  32.. 39
	12, 12, 12, 12, 12, 12, 12, 12, //  40.. 47
	12, 12, 12, 12, 13, 13, 13, 13, //  48.. 55
	13, 13, 13, 13, 13, 13, 13, 13, //  56.. 63
	13, 13, 13, 13, 13, 13, 14, 14, //  64.. 71
	14, 14, 14, 14, 14, 14, 14, 14, //  72.. 79
	14, 14, 14, 14, 14, 14, 14, 14, //  80.. 87
	14, 14, 14, 14, 14, 14, 14		//  88.. 94 - stop table at 94 here, everything above is 15
};

BYTE DV_log_1_354(BYTE n)
{
	if (n > 94) return 15;
	return DV_LOG_1_354_lookup_table[n];
}

// function to lookup the base 2 log of (n) where n is 16 bits unsigned
// except that we cheat and say that log_2 of zero is zero
// and we chop of any decimals.
BYTE DV_log_2(WORD n)
{
	if (n & 0x8000)
	{
		return 0x0f;
	}
	if (n & 0x4000)
	{
		return 0x0e;
	}
	if (n & 0x2000)
	{
		return 0x0d;
	}
	if (n & 0x1000)
	{
		return 0x0c;
	}
	if (n & 0x0800)
	{
		return 0x0b;
	}
	if (n & 0x0400)
	{
		return 0x0a;
	}
	if (n & 0x0200)
	{
		return 0x09;
	}
	if (n & 0x0100)
	{
		return 0x08;
	}
	if (n & 0x0080)
	{
		return 0x07;
	}
	if (n & 0x0040)
	{
		return 0x06;
	}
	if (n & 0x0020)
	{
		return 0x05;
	}
	if (n & 0x0010)
	{
		return 0x04;
	}
	if (n & 0x0008)
	{
		return 0x03;
	}
	if (n & 0x0004)
	{
		return 0x02;
	}
	if (n & 0x0002)
	{
		return 0x01;
	}
	return 0x00;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::Init"
//
// Init - initializes the AGC and VA algorithms, including loading saved
// values from registry.
//
// dwFlags - the dwFlags from the dvClientConfig structure
// guidCaptureDevice - the capture device we're performing AGC for
// plInitVolume - the initial volume level is written here
//
HRESULT CAGCVA1::Init(
	const WCHAR *wszBasePath,
	DWORD dwFlags, 
	GUID guidCaptureDevice,
	int iSampleRate,
	int iBitsPerSample,
	LONG* plInitVolume,
	DWORD dwSensitivity)
{
	// Remember the number of bits per sample, if valid
	if (iBitsPerSample != 8 && iBitsPerSample != 16)
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Unexpected number of bits per sample!");
		return DVERR_INVALIDPARAM;
	}
	m_iBitsPerSample = iBitsPerSample;

	// Remember the flags
	m_dwFlags = dwFlags;

	// Remember the sensitivity
	m_dwSensitivity = dwSensitivity;

	// Figure out the shift constants for this sample rate
	m_iShiftConstantFast = (DV_log_2((iSampleRate * 2) / 1000) + 1);

	// This gives the slow filter a cutoff frequency 1/4 of 
	// the fast filter
	m_iShiftConstantSlow = m_iShiftConstantFast + 2;

	// Figure out how often we should sample the envelope signal
	// to measure its change. This of course depends on the sample
	// rate. The cutoff frequency allowed by the calculation
	// above is between 40 and 80 Hz. Therefore we'll sample the 
	// envelope signal at about 100 Hz.
	m_iEnvelopeSampleRate = iSampleRate / 100;

	// Figure out the number of samples in the configured
	// hangover time.
	m_iHangoverSamples = (VA_HANGOVER_TIME * iSampleRate) / 1000;
	m_iCurHangoverSamples = m_iHangoverSamples+1;

	// Figure out the number of samples in the configured dead zone time
	m_iDeadZoneSampleThreshold = (AGC_DEADZONE_TIME * iSampleRate) / 1000;

	// Figure out the number of samples in the configured
	// feedback threshold time.
	m_iFeedbackSamples = (AGC_FEEDBACK_TIME_THRESHOLD * iSampleRate) / 1000;

	// Start the envelope signal at zero
	m_iCurEnvelopeValueFast = 0;
	m_iCurEnvelopeValueSlow = 0;
	m_iPrevEnvelopeSample = 0;
	m_iCurSampleNum = 0;

	// We're not clipping now
	//m_fClipping = 0;
	//m_iClippingCount = 0;

	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:INIT:%i,%i,%i,%i,%i", 
		iSampleRate,
		m_iShiftConstantFast,
		m_iShiftConstantSlow,
		m_iEnvelopeSampleRate, 
		m_iHangoverSamples);
	
	// Save the guid in our local member...
	m_guidCaptureDevice = guidCaptureDevice;

	wcscpy( m_wszRegPath, wszBasePath );
	wcscat( m_wszRegPath, DPVOICE_REGISTRY_AGC );
	
	// if the AGC reset flag is set, reset the AGC parameters,
	// otherwise grab them from the registry
	if (m_dwFlags & DVCLIENTCONFIG_AUTOVOLUMERESET)
	{
		m_lCurVolume = DSBVOLUME_MAX;
	}
	else
	{
		CRegistry cregBase;
		if( !cregBase.Open( HKEY_CURRENT_USER, m_wszRegPath, FALSE, TRUE ) )
		{
			m_lCurVolume = DSBVOLUME_MAX;
		}
		else
		{
			CRegistry cregCapture;
			if (!cregCapture.Open( cregBase.GetHandle(), &m_guidCaptureDevice ), FALSE, TRUE )
			{
				m_lCurVolume = DSBVOLUME_MAX;
			}
			if (!cregCapture.ReadDWORD( DPVOICE_REGISTRY_SAVEDAGCLEVEL, (DWORD*)&m_lCurVolume ))
			{
				m_lCurVolume = DSBVOLUME_MAX;
			}
			else
			{
				// boost the saved volume a bit
				m_lCurVolume += AGC_VOLUME_INITIAL_UPTICK;
				if (m_lCurVolume > DSBVOLUME_MAX)
				{
					m_lCurVolume = DSBVOLUME_MAX;
				}
			}
		}
	}

	/*
	// zero out the historgrams
	memset(m_rgdwPeakHistogram, 0, CAGCVA1_HISTOGRAM_BUCKETS*sizeof(DWORD));
	memset(m_rgdwZeroCrossingsHistogram, 0, CAGCVA1_HISTOGRAM_BUCKETS*sizeof(DWORD));
	*/

	// allocate the memory for the AGC history
	m_rgfAGCHistory = new float[AGC_VOLUME_LEVELS];
	if (m_rgfAGCHistory == NULL)
	{
		return DVERR_OUTOFMEMORY;
	}

	// initialize the history to the ideal value
	for (int iIndex = 0; iIndex < AGC_VOLUME_LEVELS; ++iIndex)
	{
		m_rgfAGCHistory[iIndex] = (float)AGC_IDEAL_CLIPPING_RATIO;
	}

	m_dwHistorySamples = (iSampleRate * AGC_CLIPPING_HISTORY) / 1000;

	// stuff the initial volume into the caller's variable
	*plInitVolume = m_lCurVolume;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::Deinit"
//
// Deinit - saves the current AGC and VA state to the registry for use next session
//
HRESULT CAGCVA1::Deinit()
{
	HRESULT hr = DV_OK;
	CRegistry cregBase;
	if(cregBase.Open( HKEY_CURRENT_USER, m_wszRegPath, FALSE, TRUE ) )
	{
		CRegistry cregDevice;
		if (cregDevice.Open( cregBase.GetHandle(), &m_guidCaptureDevice, FALSE, TRUE))
		{
			if (!cregDevice.WriteDWORD( DPVOICE_REGISTRY_SAVEDAGCLEVEL, (DWORD&)m_lCurVolume ))
			{
				DPFX(DPFPREP,DVF_ERRORLEVEL, "Error writing AGC settings to registry");
				hr = DVERR_WIN32;
			}
		}
		else 
		{
			DPFX(DPFPREP,DVF_ERRORLEVEL, "Error writing AGC settings to registry");
			hr = DVERR_WIN32;
		}
	}
	else
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Error writing AGC settings to registry");
		hr = DVERR_WIN32;
	}

	delete [] m_rgfAGCHistory;
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::SetSensitivity"
HRESULT CAGCVA1::SetSensitivity(DWORD dwFlags, DWORD dwSensitivity)
{
	if (dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED)
	{
		m_dwFlags |= DVCLIENTCONFIG_AUTOVOICEACTIVATED;
	}
	else
	{
		m_dwFlags &= ~DVCLIENTCONFIG_AUTOVOICEACTIVATED;
	}
	m_dwSensitivity = dwSensitivity;
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::GetSensitivity"
HRESULT CAGCVA1::GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity)
{
	if (m_dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME)
	{
		*pdwFlags |= DVCLIENTCONFIG_AUTORECORDVOLUME;
	}
	else
	{
		*pdwFlags &= ~DVCLIENTCONFIG_AUTORECORDVOLUME;
	}
	*pdwSensitivity = m_dwSensitivity;
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::AnalyzeData"
//
// AnaylzeData - performs the AGC & VA calculations on one frame of audio
//
// pbAudioData - pointer to a buffer containing the audio data
// dwAudioDataSize - size, in bytes, of the audio data
//
HRESULT CAGCVA1::AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize /*, DWORD dwFrameTime*/)
{
	int iMaxValue;
	//int iValue;
	int iValueAbs;
	//int iZeroCrossings;
	int iIndex;
	int iMaxPossiblePeak;
	int iNumberOfSamples;
	//BYTE bPeak255;

	//m_dwFrameTime = dwFrameTime;

	if (dwAudioDataSize < 1)
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Error: Audio Data Size < 1");
		return DVERR_INVALIDPARAM;
	}

	// new algorithm...

	// cast the audio data to signed 16 bit integers
	const signed short* psiAudioData = (signed short *)pbAudioData;

	if (m_iBitsPerSample == 16)
	{
		iNumberOfSamples = dwAudioDataSize / 2;
		iMaxPossiblePeak = 0x7fff;
	}
	else
	{
		iNumberOfSamples = dwAudioDataSize;
		iMaxPossiblePeak = 0x7f00;
	}

	m_fDeadZoneDetected = TRUE;
	m_iClippingSampleCount = 0;
	m_iNonClippingSampleCount = 0;
	m_fVoiceDetectedThisFrame = FALSE;
	iMaxValue = 0;
	for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)
	{
		++m_iCurSampleNum;

		// extract a sample
		if (m_iBitsPerSample == 8)
		{
			iValueAbs = DV_ABS((int)pbAudioData[iIndex] - 0x80);
			// promote it to 16 bits
			iValueAbs <<= 8;
		}
		else
		{
			iValueAbs = DV_ABS((int)psiAudioData[iIndex]);
		}

		// see if it is the new peak value
		iMaxValue = DV_MAX(iValueAbs, iMaxValue);

		// do the low pass filtering, but only if we are in autosensitivity mode
		int iNormalizedCurEnvelopeValueFast;
		int iNormalizedCurEnvelopeValueSlow;
		if (m_dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED)
		{
			m_iCurEnvelopeValueFast = 
				iValueAbs + 
				(m_iCurEnvelopeValueFast - (m_iCurEnvelopeValueFast >> m_iShiftConstantFast));
			iNormalizedCurEnvelopeValueFast = m_iCurEnvelopeValueFast >> m_iShiftConstantFast;

			m_iCurEnvelopeValueSlow = 
				iValueAbs + 
				(m_iCurEnvelopeValueSlow - (m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow));
			iNormalizedCurEnvelopeValueSlow = m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow;

			// check to see if we consider this voice
			if (iNormalizedCurEnvelopeValueFast > VA_LOW_ENVELOPE &&
				(iNormalizedCurEnvelopeValueFast > VA_HIGH_ENVELOPE ||
				iNormalizedCurEnvelopeValueFast > (VA_HIGH_PERCENT * iNormalizedCurEnvelopeValueSlow) / 100 || 
				iNormalizedCurEnvelopeValueFast < (VA_LOW_PERCENT * iNormalizedCurEnvelopeValueSlow) / 100 ))
			{
				m_fVoiceDetectedNow = TRUE;
				m_fVoiceDetectedThisFrame = TRUE;
				m_fVoiceHangoverActive = TRUE;
				m_iCurHangoverSamples = 0;
			}
			else
			{
				m_fVoiceDetectedNow = FALSE;
				++m_iCurHangoverSamples;
				if (m_iCurHangoverSamples > m_iHangoverSamples)
				{
					m_fVoiceHangoverActive = FALSE;
				}
				else
				{
					m_fVoiceHangoverActive = TRUE;
					m_fVoiceDetectedThisFrame = TRUE;
				}
			}
		}

		/*
		DPFX(DPFPREP,DVF_WARNINGLEVEL, "AGCVA1:VA,%i,%i,%i,%i,%i,%i", 
			iValueAbs,
			iNormalizedCurEnvelopeValueFast, 
			iNormalizedCurEnvelopeValueSlow,
			m_fVoiceDetectedNow,
			m_fVoiceHangoverActive,
			m_fVoiceDetectedThisFrame);		
		*/

		// check for clipping
		if (iValueAbs > AGC_PEAK_CLIPPING_THRESHOLD)
		{
			++m_iClippingSampleCount;
		}
		else
		{
			++m_iNonClippingSampleCount;
		}
	}

	// Normalize the peak value to the range DVINPUTLEVEL_MIN to DVINPUTLEVEL_MAX
	// This is what is returned for caller's peak meters...
	m_bPeak = (BYTE)(DVINPUTLEVEL_MIN + 
		((iMaxValue * (DVINPUTLEVEL_MAX - DVINPUTLEVEL_MIN)) / iMaxPossiblePeak));

	// if we are in manual VA mode (not autovolume) check the peak against
	// the sensitivity threshold
	if (!(m_dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED))
	{
		if (m_bPeak > m_dwSensitivity)
		{
			m_fVoiceDetectedThisFrame = TRUE;
		}
	}

	// Check if we're in a deadzone
	if (iMaxValue > AGC_DEADZONE_THRESHOLD)
	{
		m_fDeadZoneDetected = FALSE;
	}


	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:ANA,%i,%i,%i,%i,%i,%i", 
		m_bPeak,
		iMaxValue,
		m_fVoiceDetectedThisFrame,
		m_fDeadZoneDetected,
		m_iClippingSampleCount,
		m_iNonClippingSampleCount);
	
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::AGCResults"
//
// AGCResults - returns the AGC results from the previous AnalyzeFrame call
//
// lCurVolume - the current recording volume
// plNewVolume - stuffed with the desired new recording volume
//
HRESULT CAGCVA1::AGCResults(LONG lCurVolume, LONG* plNewVolume, BOOL fTransmitFrame)
{
	// default to keeping the same volume
    *plNewVolume = lCurVolume;

	// Figure out what volume level we're at
	int iVolumeLevel = DV_MIN(DV_ABS(AGC_VOLUME_MAXIMUM - lCurVolume) / AGC_VOLUME_TICKSIZE,
								AGC_VOLUME_LEVELS - 1);

    //DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1:AGC,Cur Volume:%i,%i",lCurVolume, iVolumeLevel);

    // Don't make another adjustment if we have just done one.
    // This ensures that when we start looking at input data
    // again, it will be post-adjustment data.
	if( m_fAGCLastFrameAdjusted )
	{
		m_fAGCLastFrameAdjusted = FALSE;
	}
    	else
	{
    		// check for a dead zone condition
		if (m_fDeadZoneDetected /* || m_rgfAGCHistory[iVolumeLevel] == 0.0 */)
    		{
    				// We may be in the dead zone (volume way too low).
    				// Before we take the drastic action of sweepting the volume
    				// up, make sure we've been here long enough to be sure
    				// we're too low.
    			m_iDeadZoneSamples += (m_iClippingSampleCount + m_iNonClippingSampleCount);
    			if (m_iDeadZoneSamples > m_iDeadZoneSampleThreshold)
    			{
				// The input volume has been lowered too far. We're not
				// getting any input at all. To remedy this situation,
				// we'll boost the volume now, but we'll also mark this
				// volume level as off limits by setting its history to 
				// zero. That will prevent the volume from ever being
				// dropped to this level again during this session.
				if (iVolumeLevel != 0)
				{
					// We also reset the history of the volume level we are going to,
					// so we start with a clean slate.
					m_rgfAGCHistory[iVolumeLevel-1] = (const float)AGC_IDEAL_CLIPPING_RATIO;
					*plNewVolume = DV_MIN(lCurVolume + AGC_VOLUME_TICKSIZE, AGC_VOLUME_MAXIMUM);
					m_fAGCLastFrameAdjusted = TRUE;
				}
    			}
    		}
    		else
    		{
    			m_iDeadZoneSamples = 0;
    		}

		if (fTransmitFrame)
		{
			// Factor this frame's clipping ratio into the appropriate history bucket
			m_rgfAGCHistory[iVolumeLevel] = 
				(m_iClippingSampleCount + (m_rgfAGCHistory[iVolumeLevel] * m_dwHistorySamples))
				/ (m_iClippingSampleCount + m_iNonClippingSampleCount + m_dwHistorySamples);
			
			if (m_rgfAGCHistory[iVolumeLevel] > AGC_IDEAL_CLIPPING_RATIO)
			{
				// Only consider lowering the volume if we clipped on this frame.
				if (m_iClippingSampleCount > 0)
				{
					// we're clipping too much at this level, consider reducing
					// the volume.
					if (iVolumeLevel >= AGC_VOLUME_LEVELS - 1)
					{
						// we're already at the lowest volume level that we have
						// a bucket for. Make sure we're clamped to the minimum
		                if (lCurVolume > AGC_VOLUME_MINIMUM)
		                {
		                	*plNewVolume = AGC_VOLUME_MINIMUM;
		                	m_fAGCLastFrameAdjusted = TRUE;
							//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,too much clipping, clamping volume to min: %i", *plNewVolume);
		                }
					}
					else
					{
						// Choose either this volume level, or the next lower
						// one, depending on which has the history that is 
						// closest to the ideal.
						float fCurDistanceFromIdeal = (float)(m_rgfAGCHistory[iVolumeLevel] / AGC_IDEAL_CLIPPING_RATIO);
						if (fCurDistanceFromIdeal < 1.0)
						{
							fCurDistanceFromIdeal = (float)(1.0 / fCurDistanceFromIdeal);
						}

						float fLowerDistanceFromIdeal = (float)(m_rgfAGCHistory[iVolumeLevel+1] / (float)AGC_IDEAL_CLIPPING_RATIO);
						if (fLowerDistanceFromIdeal < 1.0)
						{
							fLowerDistanceFromIdeal = (float)(1.0 / fLowerDistanceFromIdeal);
						}

						if (fLowerDistanceFromIdeal < fCurDistanceFromIdeal
							&& fCurDistanceFromIdeal > AGC_CHANGE_THRESHOLD)
						{
							// The next lower volume level is closer to the ideal
							// clipping ratio. Take the volume down a tick.
							*plNewVolume = DV_MAX(lCurVolume - AGC_VOLUME_TICKSIZE, AGC_VOLUME_MINIMUM);
							m_fAGCLastFrameAdjusted = TRUE;
							//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,too much clipping, setting volume to: %i", *plNewVolume);
						}
					}
				}
			}
			else
			{
				// we're clipping too little at this level, consider increasing
				// the volume.
				if (iVolumeLevel == 0)
				{
					// We're already at the highest volume level.
					// Make sure we're at the max
					if (lCurVolume != AGC_VOLUME_MAXIMUM)
					{
	                	*plNewVolume = AGC_VOLUME_MAXIMUM;
						m_fAGCLastFrameAdjusted = TRUE;
						//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,too little clipping, clamping volume to max: %i", *plNewVolume);
					}
				}
				else
				{
					// We always increase the volume in this case, and let it push back down if
					// it clips again. This will continue testing the upper volume limit, and
					// help dig us out of "too low" volume holes.
					*plNewVolume = DV_MIN(lCurVolume + AGC_VOLUME_TICKSIZE, AGC_VOLUME_MAXIMUM);
					m_fAGCLastFrameAdjusted = TRUE;
				}
			}
		}
	}

	m_lCurVolume = *plNewVolume;
	
	// dump profiling data, in an easily importable format
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,%i,%i,%i,%i,%i,%i,%i", 
		m_fVoiceDetectedThisFrame,
		m_fDeadZoneDetected,
		iVolumeLevel,
		(int)(m_rgfAGCHistory[iVolumeLevel]*1000000),
		m_iClippingSampleCount,
		m_iNonClippingSampleCount,
		m_lCurVolume);
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::VAResults"
//
// VAResults - returns the VA results from the previous AnalyzeFrame call
//
// pfVoiceDetected - stuffed with TRUE if voice was detected in the data, FALSE otherwise
//
HRESULT CAGCVA1::VAResults(BOOL* pfVoiceDetected)
{
	if (pfVoiceDetected != NULL)
	{
		*pfVoiceDetected = m_fVoiceDetectedThisFrame;
	}
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::PeakResults"
//
// PeakResults - returns the peak sample value from the previous AnalyzeFrame call,
// 				 normalized to the range 0 to 99
//
// pfPeakValue - pointer to a byte where the peak value is written
//
HRESULT CAGCVA1::PeakResults(BYTE* pbPeakValue)
{
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1: peak value: %i" , m_bPeak);
	*pbPeakValue = m_bPeak;
	return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\agcva1.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva1.h
 *  Content:	Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	pnewson Created it
 *  01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/25/2000  pnewson Fix to improve responsiveness of AGC when volume level too low
 *
 ***************************************************************************/

#ifndef _AGCVA1_H_
#define _AGCVA1_H_

#define CAGCVA1_HISTOGRAM_BUCKETS 0x10

#define CAGCVA1_AGCTICKSIZE		250

class CAGCVA1 : public CAGCVA
{
protected:
	DWORD m_dwFlags;
	DWORD m_dwSensitivity;
    GUID m_guidCaptureDevice;
    LONG m_lCurVolume;
	LONG m_lCurStepSize;
	int m_iSampleRate;
	int m_iBitsPerSample;

	int m_iShiftConstantFast;
	int m_iShiftConstantSlow;
	int m_iEnvelopeSampleRate;
	int m_iCurSampleNum;
	int m_iCurEnvelopeValueFast;
	int m_iCurEnvelopeValueSlow;
	int m_iPrevEnvelopeSample;
	int m_iHangoverSamples;
	int m_iCurHangoverSamples;

	BYTE m_bPeak;
	/*
	BYTE m_bPeak127;
	BYTE m_bPeakLog;
	BYTE m_bZeroCrossings127;
	BYTE m_bZeroCrossingsLog;
	*/

	BOOL m_fVoiceDetectedNow;
	BOOL m_fVoiceHangoverActive;
	BOOL m_fVoiceDetectedThisFrame;

	BOOL m_fDeadZoneDetected;
	int m_iFeedbackSamples;
	
	/*
	BOOL m_fClipping;
	int m_iClippingCount;
	*/
	int m_iClippingSampleCount;
	int m_iNonClippingSampleCount;

	int m_iDeadZoneSamples;
	int m_iDeadZoneSampleThreshold;

	BOOL m_fAGCLastFrameAdjusted;
	//DWORD m_dwAGCBelowThresholdTime;
	//DWORD m_dwFrameTime;

	float* m_rgfAGCHistory;
	DWORD m_dwHistorySamples;

	WCHAR m_wszRegPath[_MAX_PATH];

	/*
	DWORD m_rgdwPeakHistogram[CAGCVA1_HISTOGRAM_BUCKETS];
	DWORD m_rgdwZeroCrossingsHistogram[CAGCVA1_HISTOGRAM_BUCKETS];
	*/
   
public:
	CAGCVA1()
		: m_guidCaptureDevice(GUID_NULL)
		, m_lCurVolume(0)
		, m_lCurStepSize(0)
		, m_bPeak(0)
		, m_fVoiceDetectedThisFrame(FALSE)
		, m_fVoiceDetectedNow(FALSE)
		//, m_fVoiceDetectedValid(FALSE)
		//, m_fAGCLastFrameAdjusted(FALSE)
		//, m_dwAGCBelowThresholdTime(0)
		//, m_dwFrameTime(0)
		{};

	virtual ~CAGCVA1() {};
	
	virtual HRESULT Init(
		const WCHAR *wszBasePath,
		DWORD dwFlags, 
		GUID guidCaptureDevice, 
		int iSampleRate, 
		int iBitsPerSample,
		LONG* plInitVolume,
		DWORD dwSensitivity);
	virtual HRESULT Deinit();
	virtual HRESULT SetSensitivity(DWORD dwFlags, DWORD dwSensitivity);
	virtual HRESULT GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity);
	virtual HRESULT AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize/*, DWORD dwFrameTime*/);
	virtual HRESULT AGCResults(LONG lCurVolume, LONG* plNewVolume, BOOL fTransmitFrame);
	virtual HRESULT VAResults(BOOL* pfVoiceDetected);
	virtual HRESULT PeakResults(BYTE* pbPeakValue);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\aplayd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aplayd.h
 *  Content:	Definition of the CAudioPlaybackDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects 
 * 12/01/99		rodtoll	Bug #121815 - Recording/Playback may contain static. 
 *						Added abstract call to adjust conversion quality
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy. 
 *
 ***************************************************************************/

#ifndef __AUDIOPLAYBACKDEVICE_H
#define __AUDIOPLAYBACKDEVICE_H

class CAudioPlaybackDevice
{
public:
    CAudioPlaybackDevice( ) {} ;
    virtual ~CAudioPlaybackDevice() {};

public: // Initialization

    virtual HRESULT Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *primaryFormat, BOOL fPriorityMode ) = 0;
    virtual HRESULT CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lpapBuffer ) = 0;  

    virtual BOOL IsEmulated() = 0;
  
    inline WAVEFORMATEX *GetPrimaryFormat() { return m_primaryFormat; };

    virtual LPDIRECTSOUND GetPlaybackDevice() = 0;

    virtual HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality ) = 0;
    virtual HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality ) = 0;

protected:
    WAVEFORMATEX  *m_primaryFormat;			// Format used by the device's mixer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\bfcsynch.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		bfcsynch.h
 *  Content:	Declaration of synchronization classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __BFCSYNCH_H
#define __BFCSYNCH_H

class BFCSingleLock
{
public:
	BFCSingleLock( DNCRITICAL_SECTION *cs ) 
		{ m_cs = cs; DNEnterCriticalSection( m_cs );  };
	~BFCSingleLock() { DNLeaveCriticalSection( m_cs ); };

	static void Lock() { };
protected:
	DNCRITICAL_SECTION	*m_cs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\arecd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecd.h
 *  Content:	Definition of the CAudioRecordDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 11/12/99		rodtoll	Modified abstraction for new waveIN support.
 *						Now abstracted types look almost like dsoundcap objects 
 * 12/01/99		rodtoll	Bug #121815 - Recording/Playback may contain static. 
 *						Added abstract call to adjust conversion quality 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						Added hwndOwner param for capture focus support
 *
 ***************************************************************************/

#ifndef __AUDIORECORDDEVICE_H
#define __AUDIORECORDDEVICE_H

class CAudioRecordDevice;

// CAudioRecordDevice
//
// This class provides an abstract interface for the recording devices in
// the system.  The various subsystems provide implementations of this class
// specific to the subsystem.  Applications use the interface described by this
// class to work with recording devices.
//
// WARNING:
// In many cases you must initialize the playback before you can initialize
// the recording.  Therefore you must create and initialize your 
// CAudioPlaybackDevice BEFORE you create your CAudioRecordDevice object.
// 
class CAudioRecordDevice
{
public:
    CAudioRecordDevice( ) {} ;
    virtual ~CAudioRecordDevice() {} ;

public: // Initialization

    virtual HRESULT Initialize( const GUID &refguidDevice ) = 0;
    virtual HRESULT CreateBuffer( LPDSCBUFFERDESC lpdscBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lpapBuffer ) = 0;    

    virtual LPDIRECTSOUNDCAPTURE GetCaptureDevice() = 0;

    virtual HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality ) = 0;
    virtual HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality ) = 0;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\bfctypes.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		bfctypes.h
 *  Content:	General utility types, particularly strings
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __BFCTYPES_H
#define __BFCTYPES_H

typedef std::basic_string<TCHAR>		BFC_STRING;
#define BFC_STRING_TOLPSTR( x )	x.c_str()
#define BFC_STRING_LENGTH( x ) x.length()
#define BFC_STRING_GETAT( x, y ) x.at( y )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\arecb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecb.h
 *  Content:	Definition of the CAudioRecordBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/23/99		rodtoll	Added SelectMicrophone call to the interface
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Added new parameter to SelectMicrophone
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						Added lpfLostFocus param to GetCurrentPosition so upper 
 *						layers can detect lost focus.
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 *
 ***************************************************************************/

#ifndef __AUDIORECORDBUFFER_H
#define __AUDIORECORDBUFFER_H

// CAudioRecordBuffer
//
//
class CAudioRecordBuffer
{
public:
    CAudioRecordBuffer(  ) {} ;
    virtual ~CAudioRecordBuffer() {} ;

public: // Initialization
    virtual HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags ) = 0;
    virtual HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 ) = 0;
    virtual HRESULT GetVolume( LPLONG lplVolume ) = 0;
    virtual HRESULT SetVolume( LONG lVolume ) = 0;
    virtual HRESULT GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus ) = 0;
    virtual HRESULT Record( BOOL fLooping ) = 0;
    virtual HRESULT Stop() = 0;    
    virtual HRESULT SelectMicrophone( BOOL fSelect ) = 0;

	virtual LPWAVEFORMATEX GetRecordFormat() = 0;
    virtual DWORD GetStartupLatency() = 0;

    virtual HRESULT YieldFocus() = 0;
    virtual HRESULT ClaimFocus() = 0;
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\decibels.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		decibels.h
 *  Content:	Functions to map from dsound volumes to wave volumes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/29/99		rodtoll	Adapted from dsound team's file.
 ***************************************************************************/

#include "dxvutilspch.h"

// ORIGINAL HEADER: 
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
DWORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    };

;

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
#undef DPF_MODNAME
#define DPF_MODNAME "DBToAmpFactor"

DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    // input lDB is 100ths of decibels

    // REMIND hack to make mixer code work- it only handles 16-bit factors and
    //  cannot amplify
    if (0 <= lDB) return 0x0000FFFF;
    
    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB+5)/10;		    // scaled to 1/10th dB units
    
    if (lDB > -1)   lDB = -1;	    // upper boundary
    if (lDB < -964) lDB = -964;	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index.
    DNASSERT(lDB >= 0);
    DNASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));
    
    dwFactor = tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

// Note, could use DirectSound3D's fyl2x function instead of searching 
// through the table.
#undef DPF_MODNAME
#define DPF_MODNAME "AmpFactorToDB"

LONG AmpFactorToDB( DWORD dwFactor )
{
    LONG    lDB;
    int	    i;
    int	    iMax;

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;
    
    if (dwFactor < 0x0000FFFF) 
    {
        for (i = 0; i <= iMax - 1; i++) {
	         if (dwFactor <= tblDBTenthsToAmpFactor[i]) break;
        }
        lDB = (i - 964) * 10;
    }
    else
    {
        lDB = 0; 
    }


    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\decibels.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		decibels.h
 *  Content:	Functions to map from dsound volumes to wave volumes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/29/99		rodtoll	Adapted from dsound team's file.
 ***************************************************************************/

// ORIGINAL HEADER: 
//
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;

DWORD DBToAmpFactor( LONG lDB );
LONG AmpFactorToDB( DWORD dwFactor );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\devmap.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devmap.cpp
 *  Content:	Maps various default devices GUIDs to real guids. 
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11-24-99  pnewson   Created
 *  12-02-99  rodtoll	Added new functions for mapping device IDs and finding default
 *                      devices. 
 *            rodtoll	Updated mapping function to map default devices to real GUIDs
 *						for non-DX7.1 platforms. 
 *  01/25/2000 pnewson  Added DV_MapWaveIDToGUID
 *  04/14/2000 rodtoll  Bug #32341 GUID_NULL and NULL map to different devices
 *                      Updated so both map to default voice device
 *  04/19/2000	pnewson	    Error handling cleanup  
 *  04/20/2000  rodtoll Bug #32889 - Unable to run on non-admin accounts on Win2k
 *  06/28/2000	rodtoll	Prefix Bug #38022
 *				rodtoll Whistler Bug #128427 - Unable to run voice wizard from multimedia control panel
 *  08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h, added STR_* and strutils.h
 *  01/08/2001	rodtoll WINBUG #256541	Pseudo: Loss of functionality: Voice Wizrd can't be launched. 
 *  04/02/2001	simonpow	Fixes for PREfast bugs #354859
 *  02/28/2002	rodtoll WINBUG #550105 - SECURITY: DPVOICE: Dead code
 *						- Removed old device mapping functions which are no longer used.
 *				rodtoll	Fix for regression caused by TCHAR conversion (Post DirectX 8.1 work)
 *						- Source was updated to retrieve device information from DirectSound w/Unicode
 *						  but routines which wanted the information needed Unicode.  
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define REGSTR_WAVEMAPPER               L"Software\\Microsoft\\Multimedia\\Sound Mapper"
#define REGSTR_PLAYBACK                 L"Playback"
#define REGSTR_RECORD                   L"Record"

// function pointer typedefs
typedef HRESULT (* PFGETDEVICEID)(LPCGUID, LPGUID);

typedef HRESULT (WINAPI *DSENUM)( LPDSENUMCALLBACK lpDSEnumCallback,LPVOID lpContext );

// DV_MapGUIDToWaveID
//
// This function maps the specified GUID to the corresponding waveIN/waveOut device
// ID.  For default devices it looks up the system's default device, for other devices
// it uses the private interface.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapGUIDToWaveID"
HRESULT DV_MapGUIDToWaveID( BOOL fCapture, const GUID &guidDevice, DWORD *pdwDevice )
{
	LPKSPROPERTYSET pPropertySet;
	PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pData;
	GUID tmpGUID;
	HRESULT hr;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Mapping non GUID_NULL to Wave ID" );

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to map GUID." );
		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map GUID to wave.  Defaulting to ID 0 hr=0x%x", hr );
		*pdwDevice = 0;
	}
	else
	{
		tmpGUID = guidDevice;

		hr = PrvGetDeviceDescription( pPropertySet, tmpGUID, &pData );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find GUID.  Defaulting to ID 0 hr=0x%x", hr );
		}
		else
		{
			*pdwDevice = pData->WaveDeviceId;
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Mapped GUID to Wave ID %d", *pdwDevice );
			delete pData;
		}

		pPropertySet->Release();
	}

	return hr;
}

// DV_MapWaveIDToGUID
//
// This function maps the specified waveIN/waveOut device ID to the corresponding DirectSound
// GUID. 
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapWaveIDToGUID"
HRESULT DV_MapWaveIDToGUID( BOOL fCapture, DWORD dwDevice, GUID &guidDevice )
{
	HRESULT hr;

	LPKSPROPERTYSET ppKsPropertySet;
	HMODULE hModule;

	hModule = LoadLibraryA( "dsound.dll " );

	if( hModule == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not load dsound.dll" );
		return DVERR_GENERIC;
	}

	hr = DirectSoundPrivateCreate( &ppKsPropertySet );

	if( FAILED( hr ) )
	{
		FreeLibrary( hModule );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get interface for ID<-->GUID Map hr=0x%x", hr );
		return hr;
	}	

	// CODEWORK: Remove these checks since the builds are separate now.
	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
	{
		WAVEINCAPSW wiCapsW;
		WAVEOUTCAPSW woCapsW;		
		MMRESULT mmr;
		
		if( fCapture )
		{
			mmr = waveInGetDevCapsW( dwDevice, &wiCapsW, sizeof( WAVEINCAPSW ) );
		}
		else
		{
			mmr = waveOutGetDevCapsW( dwDevice, &woCapsW, sizeof( WAVEOUTCAPSW ) );
		}

		if( mmr != MMSYSERR_NOERROR )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified device is invalid hr=0x%x", mmr );
			ppKsPropertySet->Release();
			FreeLibrary( hModule );
			return DVERR_INVALIDPARAM;
		}

		hr = PrvGetWaveDeviceMappingW( ppKsPropertySet, (fCapture) ? wiCapsW.szPname : woCapsW.szPname , fCapture, &guidDevice );
	}
	else
	{
		WAVEINCAPSA wiCapsA;
		WAVEOUTCAPSA woCapsA;		
		MMRESULT mmr;

		if( fCapture )
		{
			mmr = waveInGetDevCapsA( dwDevice, &wiCapsA, sizeof( WAVEINCAPSA ) );
		}
		else
		{
			mmr = waveOutGetDevCapsA( dwDevice, &woCapsA, sizeof( WAVEOUTCAPSA ) );
		}

		if( mmr != MMSYSERR_NOERROR )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified device is invalid hr=0x%x", mmr );
			ppKsPropertySet->Release();
			FreeLibrary( hModule );
			return DVERR_INVALIDPARAM;
		}

		hr = PrvGetWaveDeviceMapping( ppKsPropertySet, (fCapture) ? wiCapsA.szPname : woCapsA.szPname , fCapture, &guidDevice );
	}

	ppKsPropertySet->Release();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map ID-->GUID hr=0x%x", hr );
	}

	FreeLibrary( hModule );
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapCaptureDevice"
HRESULT DV_MapCaptureDevice(const GUID* lpguidCaptureDeviceIn, GUID* lpguidCaptureDeviceOut)
{
	LONG lRet;
	HRESULT hr;
	PFGETDEVICEID pfGetDeviceID;
	
	// attempt to map any default guids to real guids...
	HINSTANCE hDSound = LoadLibraryA("dsound.dll");
	if (hDSound == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to get instance handle to DirectSound dll: dsound.dll");
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadLibrary error code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// attempt to get a pointer to the GetDeviceId function
	pfGetDeviceID = (PFGETDEVICEID)GetProcAddress(hDSound, "GetDeviceID");
	if (pfGetDeviceID == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Unable to get a pointer to GetDeviceID function: GetDeviceID");
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "GetProcAddress error code: %i", lRet);
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Fatal error.");

		*lpguidCaptureDeviceOut = *lpguidCaptureDeviceIn;

		return DVERR_GENERIC;
	}
	else
	{
		// Use the GetDeviceID function to map the devices.
		if (lpguidCaptureDeviceIn == NULL)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping null device pointer to DSDEVID_DefaultCapture");
			lpguidCaptureDeviceIn = &DSDEVID_DefaultCapture;
		}
		else if (*lpguidCaptureDeviceIn == GUID_NULL)
		{
			// GetDeviceID does not accept GUID_NULL, since it does not know
			// if we are asking for a capture or playback device. So we map
			// GUID_NULL to the system default capture device here. Then 
			// GetDeviceID can map it to the real device.
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping GUID_NULL to DSDEVID_DefaultCapture");
			lpguidCaptureDeviceIn = &DSDEVID_DefaultCapture;
		}

		GUID guidTemp;
		hr = pfGetDeviceID(lpguidCaptureDeviceIn, &guidTemp);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "GetDeviceID failed: %i", hr);
			if (hr == DSERR_NODRIVER)
			{
				hr = DVERR_INVALIDDEVICE;
			}
			else
			{
				hr = DVERR_GENERIC;
			}
			goto error_cleanup;
		}
		if (*lpguidCaptureDeviceIn != guidTemp)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: GetDeviceID mapped device GUID");
			*lpguidCaptureDeviceOut = guidTemp;
		}
		else
		{
			*lpguidCaptureDeviceOut = *lpguidCaptureDeviceIn;
		}
	}
	
	if (!FreeLibrary(hDSound))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "FreeLibrary failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	return DV_OK;

error_cleanup:
	if (hDSound != NULL)
	{
		FreeLibrary(hDSound);
	}
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapPlaybackDevice"
HRESULT DV_MapPlaybackDevice(const GUID* lpguidPlaybackDeviceIn, GUID* lpguidPlaybackDeviceOut)
{
	LONG lRet;
	HRESULT hr;
	PFGETDEVICEID pfGetDeviceID;
	
	// attempt to map any default guids to real guids...
	HINSTANCE hDSound = LoadLibraryA("dsound.dll");
	if (hDSound == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to get instance handle to DirectSound dll: dsound.dll");
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadLibrary error code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// attempt to get a pointer to the GetDeviceId function
	pfGetDeviceID = (PFGETDEVICEID)GetProcAddress(hDSound, "GetDeviceID");
	if (pfGetDeviceID == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Unable to get a pointer to GetDeviceID function: GetDeviceID");
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "GetProcAddress error code: %i", lRet);
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Fatal error!");

		*lpguidPlaybackDeviceOut = *lpguidPlaybackDeviceIn;

		return DVERR_GENERIC;
	}
	else
	{
		// Use the GetDeviceID function to map the devices.
		if (lpguidPlaybackDeviceIn == NULL)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping null device pointer to DSDEVID_DefaultPlayback");
			lpguidPlaybackDeviceIn = &DSDEVID_DefaultPlayback;
		} 
		else if (*lpguidPlaybackDeviceIn == GUID_NULL)
		{
			// GetDeviceID does not accept GUID_NULL, since it does not know
			// if we are asking for a capture or playback device. So we map
			// GUID_NULL to the system default playback device here. Then 
			// GetDeviceID can map it to the real device.
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping GUID_NULL to DSDEVID_DefaultPlayback");
			lpguidPlaybackDeviceIn = &DSDEVID_DefaultPlayback;
		}

		GUID guidTemp;
		hr = pfGetDeviceID(lpguidPlaybackDeviceIn, &guidTemp);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "GetDeviceID failed: %i", hr);
			if (hr == DSERR_NODRIVER)
			{
				hr = DVERR_INVALIDDEVICE;
			}
			else
			{
				hr = DVERR_GENERIC;
			}
			goto error_cleanup;
		}
		if (*lpguidPlaybackDeviceIn != guidTemp)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: GetDeviceID mapped device GUID");
			*lpguidPlaybackDeviceOut = guidTemp;
		}
		else
		{
			*lpguidPlaybackDeviceOut = *lpguidPlaybackDeviceIn;
		}
	}
	
	if (!FreeLibrary(hDSound))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "FreeLibrary failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	return DV_OK;

error_cleanup:
	if (hDSound != NULL)
	{
		FreeLibrary(hDSound);
	}
	DPF_EXIT();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\devmap.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devmap.h
 *  Content:	Maps various default devices GUIDs to real guids. 
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11-24-99  pnewson   Created
 *  12-02-99  rodtoll	Added new functions for mapping device IDs and finding default
 *                      devices.
 *  01/25/2000 pnewson  Added DV_MapWaveIDToGUID
 *  02/28/2002	rodtoll WINBUG #550105 - SECURITY: DPVOICE: Dead code
 *						- Removed old device mapping functions which are no longer used.
 *				rodtoll	Fix for regression caused by TCHAR conversion (Post DirectX 8.1 work)
 *						- Source was updated to retrieve device information from DirectSound w/Unicode
 *						  but routines which wanted the information needed Unicode.  
 *
 ***************************************************************************/

#ifndef _DEVMAP_H_
#define _DEVMAP_H_

extern HRESULT DV_MapCaptureDevice(const GUID* lpguidCaptureDeviceIn, GUID* lpguidCaptureDeviceOut);
extern HRESULT DV_MapPlaybackDevice(const GUID* lpguidPlaybackDeviceIn, GUID* lpguidPlaybackDeviceOut);
extern HRESULT DV_MapGUIDToWaveID( BOOL fCapture, const GUID &guidDevice, DWORD *pdwDevice );
extern HRESULT DV_MapWaveIDToGUID( BOOL fCapture, DWORD dwDevice, GUID& guidDevice );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\diagnos.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		diagnos.cpp
 *  Content:	Utility functions to write out diagnostic files when registry key is set.  
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/13/00	rodtoll	Created (Bug #31468 - Add diagnostic spew to logfile to show what is failing
 *  08/22/2000	rodtoll	Bug #43060 - DPVOICE: Diagnostics data which is dumped to memory / debugger contains garbage
 *	02/28/2002	rodtoll	Fix for regression caused by TCHAR conversion (Post DirectX 8.1 work)
 *						- Source was updated to retrieve device information from DirectSound w/Unicode
 *						  but routines which wanted the information needed Unicode.  
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DPLOG_MAX_STRING 256

FILE *g_hOutputFile = NULL;
BOOL g_fDiagnosisEnabled = FALSE;

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_WriteDeviceInfo"
void Diagnostics_WriteDeviceInfo( DWORD dwLevel, const char *szDeviceName, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pData )
{
	Diagnostics_Write(  dwLevel, "%hs Device Information:", szDeviceName );
	Diagnostics_Write(  dwLevel, "Device Name:\n%hs", pData->Description ? pData->Description : "<NULL>");
	Diagnostics_Write(  dwLevel, "Device ID:" );
	Diagnostics_WriteGUID(dwLevel,  pData->DeviceId );

	switch( pData->Type )
	{
	case DIRECTSOUNDDEVICE_TYPE_EMULATED:	Diagnostics_Write(  dwLevel, "Device Type:\nEmulated" );	break;
	case DIRECTSOUNDDEVICE_TYPE_VXD:		Diagnostics_Write(  dwLevel, "Device Type:\nVXD" );		break;
	case DIRECTSOUNDDEVICE_TYPE_WDM:		Diagnostics_Write(  dwLevel, "Device Type:\nWDM" );		break;
	default:								Diagnostics_Write(  dwLevel, "Device Type:\n<UNKNOWN>" );	break;
	}

	Diagnostics_Write(  dwLevel, "Description:\n%hs", pData->Description ? pData->Description : "<NULL>" );
	Diagnostics_Write(  dwLevel, "Module:\n%hs", pData->Module ? pData->Module : "<NULL>" );
	Diagnostics_Write(  dwLevel, "WaveID:\n%d", pData->WaveDeviceId );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_DeviceInfo"
HRESULT Diagnostics_DeviceInfo( const GUID *pguidPlayback, const GUID *pguidCapture )
{
	if( !g_fDiagnosisEnabled )
		return DV_OK;

	LPKSPROPERTYSET lpksProperty = NULL;
	HRESULT hr = DV_OK;
	GUID guidTruePlayback;
	GUID guidTrueCapture;
	PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pPlaybackDesc = NULL;
	PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pCaptureDesc = NULL;

	hr = DV_MapCaptureDevice( pguidPlayback, &guidTruePlayback );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting true playback device hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	hr = DV_MapPlaybackDevice( pguidCapture, &guidTrueCapture );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting true capture device hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	hr = DirectSoundPrivateCreate( &lpksProperty );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting interface to get device name hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	hr = PrvGetDeviceDescription( lpksProperty, guidTruePlayback, &pPlaybackDesc );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting device description hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	Diagnostics_WriteDeviceInfo( DVF_INFOLEVEL, "Playback", pPlaybackDesc );

	hr = PrvGetDeviceDescription( lpksProperty, guidTrueCapture, &pCaptureDesc );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting device description hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	Diagnostics_WriteDeviceInfo( DVF_INFOLEVEL, "Capture", pPlaybackDesc );

DEVICEINFO_EXIT:

	if( pPlaybackDesc )
		delete pPlaybackDesc;

	if( pCaptureDesc )
		delete pCaptureDesc;
		
	if( lpksProperty )
	{
		lpksProperty->Release();
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_Begin"
HRESULT Diagnostics_Begin( BOOL fEnabled, const char *szFileName )
{
	// Prevent double-open
	if( g_fDiagnosisEnabled )
		return DV_OK;

	HRESULT hr = DV_OK;

	g_fDiagnosisEnabled = fEnabled;

	if( !fEnabled )
		return DV_OK;

	g_hOutputFile = fopen( szFileName, "w" );

	if( !g_hOutputFile )
	{
		hr = DVERR_GENERIC;
		DPFX(DPFPREP,  0, "Error opening diagnostics file" );
		goto BEGIN_ERROR;
	}

	return DV_OK;

BEGIN_ERROR:

	Diagnostics_End();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_End"
void Diagnostics_End()
{
	if( g_fDiagnosisEnabled )
	{
		if( g_hOutputFile )
		{
			fclose( g_hOutputFile );
			g_hOutputFile = NULL;
		}
		g_fDiagnosisEnabled = FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_Write"
void Diagnostics_Write( DWORD dwLevel, const char *szFormat, ... )
{
	char szBuffer[DPLOG_MAX_STRING];
	va_list argptr;
	va_start(argptr, szFormat);

	if( g_fDiagnosisEnabled )
	{
		vfprintf( g_hOutputFile, szFormat, argptr );
		fputs( "\n", g_hOutputFile );
	}

	_vsnprintf( szBuffer, DPLOG_MAX_STRING, szFormat, argptr );

	DPFX(DPFPREP,  dwLevel, szBuffer );

	va_end(argptr);

	fflush( g_hOutputFile );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnositcs_WriteWAVEFORMATEX"
void Diagnostics_WriteGUID( DWORD dwLevel, GUID &guid )
{
	Diagnostics_Write( dwLevel, "{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guid.Data1, guid.Data2, guid.Data3, 
               guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
               guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnositcs_WriteWAVEFORMATEX"
void Diagnositcs_WriteWAVEFORMATEX( DWORD dwLevel, PWAVEFORMATEX lpwfxFormat )
{
	Diagnostics_Write( dwLevel, "wFormatTag = %d", lpwfxFormat->wFormatTag );
	Diagnostics_Write( dwLevel, "nSamplesPerSec = %d", lpwfxFormat->nSamplesPerSec );
	Diagnostics_Write( dwLevel, "nChannels = %d", lpwfxFormat->nChannels );
	Diagnostics_Write( dwLevel, "wBitsPerSample = %d", lpwfxFormat->wBitsPerSample );
	Diagnostics_Write( dwLevel, "nAvgBytesPerSec = %d", lpwfxFormat->nAvgBytesPerSec );
	Diagnostics_Write( dwLevel, "nBlockAlign = %d", lpwfxFormat->nBlockAlign );
	Diagnostics_Write( dwLevel, "cbSize = %d", lpwfxFormat->cbSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\diagnos.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		diagnos.h
 *  Content:	Utility functions to write out diagnostic files when registry key is set.  
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/13/00	rodtoll	Created (Bug #31468 - Add diagnostic spew to logfile to show what is failing
 *	02/28/2002	rodtoll	Fix for regression caused by TCHAR conversion (Post DirectX 8.1 work)
 *						- Source was updated to retrieve device information from DirectSound w/Unicode
 *						  but routines which wanted the information needed Unicode.  
 *
 ***************************************************************************/
#ifndef __DIAGNOS_H
#define __DIAGNOS_H

void Diagnostics_WriteDeviceInfo( DWORD dwLevel, const char *szDeviceName, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pData );
HRESULT Diagnostics_DeviceInfo( const GUID *pguidPlayback, const GUID *pguidCapture );
HRESULT Diagnostics_Begin( BOOL fEnabled, const char *szFileName );
void Diagnostics_End();
void Diagnostics_Write( DWORD dwLevel, const char *szFormat, ... );
void Diagnostics_WriteGUID( DWORD dwLevel, GUID &guid );
void Diagnositcs_WriteWAVEFORMATEX( DWORD dwLevel, PWAVEFORMATEX lpwfxFormat );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecb.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundCaptureRecordBuffer.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/22/99		rodtoll	Added code to allow specification of wave device ID
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail 
 *				rodtoll	Updated with new Microphone select member
 * 12/08/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 * 02/10/2000	rodtoll	Removed more capture focus code
 * 04/19/2000   rodtoll Re-enabled capture focus behaviour 
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 04/22/2001	rodtoll	Fixed bug in lockup simulation code (TESTING PURPOSES ONLY)
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#define DSC_STARTUP_LATENCY 1

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::CDirectSoundCaptureRecordBuffer"
CDirectSoundCaptureRecordBuffer::CDirectSoundCaptureRecordBuffer(
	LPDIRECTSOUNDCAPTUREBUFFER lpdscBuffer, HWND hwndOwner, const GUID &guidDevice, UINT uiWaveDeviceID, const DSCBUFFERDESC * lpdsBufferDesc
): CAudioRecordBuffer(), m_lpwfxRecordFormat(NULL), m_lpdscBuffer7(NULL), 
   m_guidDevice(guidDevice), m_uiWaveDeviceID(uiWaveDeviceID), 
#ifdef LOCKUP_SIMULATION   
	m_dwNumSinceLastLockup(0), m_dwLastPosition(0),
#endif
	m_hwndOwner(hwndOwner), m_fUseCaptureFocus( FALSE )
{
	HRESULT hr;
	DWORD dwSize;

	if( lpdsBufferDesc->dwFlags & DSCBCAPS_FOCUSAWARE )
	{
	    DPFX(DPFPREP,  1, "Enabling focus" );
	    m_fUseCaptureFocus = TRUE;
	}
	else
	{
	    DPFX(DPFPREP,  1, "Disabling focus" );
        m_fUseCaptureFocus = FALSE;
	}
	
	hr = lpdscBuffer->QueryInterface( IID_IDirectSoundCaptureBuffer, (void **) &m_lpdscBuffer );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get dsound buffer interface" );
		m_lpdscBuffer = NULL;
		return;
	}

	hr = lpdscBuffer->QueryInterface( IID_IDirectSoundCaptureBuffer7_1, (void **) &m_lpdscBuffer7 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not retrieve new interface hr=0x%x.", hr );

		hr = m_mixerLine.Initialize( m_uiWaveDeviceID );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to acquire volume controls hr=0x%x", hr );
			DNASSERT( FALSE );
		}		
	}  
	else 
	{
	    if( m_fUseCaptureFocus )
	    {
    		hr = m_lpdscBuffer7->SetFocusHWND( hwndOwner );

    		if( FAILED( hr ) )
    		{
    			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to set the focus window hr = 0x%x", hr );
    			DNASSERT( FALSE );
    		}
	    }
	}

	hr = lpdscBuffer->GetFormat( NULL, 0, &dwSize );

	m_lpwfxRecordFormat = (LPWAVEFORMATEX) new BYTE[dwSize];

	if( m_lpwfxRecordFormat == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate space for record format" );
		DNASSERT( FALSE );
	}

	hr = lpdscBuffer->GetFormat( m_lpwfxRecordFormat, dwSize, NULL );

	if( FAILED( hr ) )
	{
		delete [] ((LPBYTE) m_lpwfxRecordFormat);
		m_lpwfxRecordFormat = NULL;
	}

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::~CDirectSoundCaptureRecordBuffer"
CDirectSoundCaptureRecordBuffer::~CDirectSoundCaptureRecordBuffer()
{
	if( m_lpdscBuffer7 != NULL )
	{
		m_lpdscBuffer7->Release();
	}
	
	if( m_lpdscBuffer != NULL )
	{
		m_lpdscBuffer->Release();
	}

	if( m_lpwfxRecordFormat != NULL )
	{
		delete [] ((LPBYTE) m_lpwfxRecordFormat);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::Lock"
HRESULT CDirectSoundCaptureRecordBuffer::Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags )
{
	HRESULT hr;
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	hr = m_lpdscBuffer->Lock( dwWriteCursor, dwWriteBytes, lplpvBuffer1, lpdwSize1, lplpvBuffer2, lpdwSize2, dwFlags );

	DSERTRACK_Update( "DSCB::Lock()", hr );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::UnLock"
HRESULT CDirectSoundCaptureRecordBuffer::UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 )
{
	HRESULT hr;
	
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	hr = m_lpdscBuffer->Unlock( lpvBuffer1, dwSize1, lpvBuffer2, dwSize2 );	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::SetVolume"
HRESULT CDirectSoundCaptureRecordBuffer::SetVolume( LONG lVolume )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	if( m_lpdscBuffer7 != NULL )
	{
		hr = m_lpdscBuffer7->SetVolume( lVolume );
	}
	else
	{
		hr = m_mixerLine.SetMasterRecordVolume( lVolume );
	}

	// This is only a warning condition
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Could not set master volume hr=0x%x", hr );
	}

	
	if( m_lpdscBuffer7 != NULL )
	{
		hr = m_lpdscBuffer7->SetMicVolume( lVolume );
	}
	else
	{
		hr = m_mixerLine.SetMicrophoneVolume( lVolume );
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Unable to set Microphone volume hr=0x%x", hr );
		return hr;
	}
		
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetVolume"
HRESULT CDirectSoundCaptureRecordBuffer::GetVolume( LPLONG lplVolume )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;
	
	if( m_lpdscBuffer7 != NULL )
	{
		hr = m_lpdscBuffer7->GetMicVolume( lplVolume );
	}
	else
	{
		hr = m_mixerLine.GetMicrophoneVolume( lplVolume );
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get Microphone volume hr=0x%x", hr );

		if( m_lpdscBuffer7 != NULL )
		{
			hr = m_lpdscBuffer7->GetVolume( lplVolume );
		}
		else
		{
			hr = m_mixerLine.GetMasterRecordVolume( lplVolume );
		}

		// This is only a warning condition
		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not get master record volume hr=0x%x", hr );
			return hr;
		}		

		return hr;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetCurrentPosition"
HRESULT CDirectSoundCaptureRecordBuffer::GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

#ifdef LOCKUP_SIMULATION	
	m_dwNumSinceLastLockup++;

	if( m_dwNumSinceLastLockup > LOCKUP_NUM_CALLS_BEFORE_LOCKUP )
	{
		*lpdwPosition = m_dwLastPosition;
		*lpfLostFocus = FALSE;
		return DV_OK;
	}
#endif

	HRESULT hr;

	if( m_lpdscBuffer7 != NULL && m_fUseCaptureFocus )
	{
		DWORD dwStatus;
		hr = m_lpdscBuffer7->GetStatus( &dwStatus );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting status hr=0x%x", hr );
			*lpfLostFocus = FALSE;
		}
		else
		{
			*lpfLostFocus = (dwStatus & DSCBSTATUS_LOSTFOCUS) ? TRUE : FALSE;
		}
	}
	else
	{
		*lpfLostFocus = FALSE;
	}

	hr = m_lpdscBuffer->GetCurrentPosition( NULL, lpdwPosition );

#ifdef LOCKUP_SIMULATION	
	m_dwLastPosition = *lpdwPosition;
#endif

	DSERTRACK_Update( "DSCB::GetCurrentPosition()", hr );		

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::Play"
HRESULT CDirectSoundCaptureRecordBuffer::Record( BOOL fLooping )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	hr = m_lpdscBuffer->Start( (fLooping) ? DSCBSTART_LOOPING : 0 );	

#ifdef LOCKUP_SIMULATION	

#ifdef LOCKUP_STOPFAIL		
	if( m_dwNumSinceLastLockup > LOCKUP_NUM_CALLS_BEFORE_LOCKUP )
	{
		hr = DSERR_GENERIC;
	}
#else
	m_dwNumSinceLastLockup = 0;
#endif

#endif

	DSERTRACK_Update( "DSCB::Start()", hr );		

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::Stop"
HRESULT CDirectSoundCaptureRecordBuffer::Stop()
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	hr = m_lpdscBuffer->Stop(  );	

#ifdef LOCKUP_SIMULATION	

#ifdef LOCKUP_STOPFAIL		
	if( m_dwNumSinceLastLockup > LOCKUP_NUM_CALLS_BEFORE_LOCKUP )
	{
		
		hr = DSERR_GENERIC;
	}
#endif 
	
#endif

	DSERTRACK_Update( "DSCB::Stop()", hr );		

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetStartupLatency"
DWORD CDirectSoundCaptureRecordBuffer::GetStartupLatency()
{
	return DSC_STARTUP_LATENCY;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetRecordFormat"
LPWAVEFORMATEX CDirectSoundCaptureRecordBuffer::GetRecordFormat()
{
	return m_lpwfxRecordFormat;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::SelectMicrophone"
HRESULT CDirectSoundCaptureRecordBuffer::SelectMicrophone( BOOL fSelect )
{
	if( m_lpdscBuffer7 != NULL )
	{
		return m_lpdscBuffer7->EnableMic( fSelect );
	}
	else
	{
		return m_mixerLine.EnableMicrophone( fSelect );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::ClaimFocus"
HRESULT CDirectSoundCaptureRecordBuffer::ClaimFocus(  )
{
	if( m_lpdscBuffer7 != NULL && m_fUseCaptureFocus)
	{
		return m_lpdscBuffer7->ClaimFocus();
	}
	else
	{
		return DVERR_NOTSUPPORTED;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::YieldFocus"
HRESULT CDirectSoundCaptureRecordBuffer::YieldFocus(  )
{
	if( m_lpdscBuffer7 != NULL && m_fUseCaptureFocus )
	{
		return m_lpdscBuffer7->YieldFocus();
	}
	else
	{
		return DVERR_NOTSUPPORTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecb.h
 *  Content:	Definition of the CDirectSoundCaptureRecordBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/22/99		rodtoll	Added code to allow specification of wave device ID
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail
 * 		        rodtoll	Added SelectMicrophone call to the interface 
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDCAPTURERECORDBUFFER_H
#define __DIRECTSOUNDCAPTURERECORDBUFFER_H

// Uncomment out to get a lockup of the recording position after LOCKUP_NUM_FRAMES_BEFORE_LOCKUP frames
//#define LOCKUP_SIMULATION						1
#define LOCKUP_NUM_CALLS_BEFORE_LOCKUP			60

// Uncomment to have Stop fail on a reset
//#define LOCKUP_STOPFAIL			

// Uncomment to have Start fail on a reset
//#define LOCKUP_STARTFAIL

// CDirectSoundCaptureRecordBuffer
//
// This class provides an implementation of the CAudioRecordBuffer class
// for directsound.  In the abstract sense, it represents a buffer of audio
// which can be played to the sound hardware which consists of multiple,
// equal length subbuffers.  
//
class CDirectSoundCaptureRecordBuffer: public CAudioRecordBuffer
{
public:
    CDirectSoundCaptureRecordBuffer( LPDIRECTSOUNDCAPTUREBUFFER lpdsBuffer, HWND hwndOwner, const GUID &guidDevice, UINT uiWaveDeviceID, const DSCBUFFERDESC * lpdsBufferDesc );
    virtual ~CDirectSoundCaptureRecordBuffer();

public: 

    HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags );
    HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 );
    HRESULT GetVolume( LPLONG lplVolume );
    HRESULT SetVolume( LONG lVolume );
    HRESULT GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus );
    HRESULT Record( BOOL fLooping );
    HRESULT Stop();  
    HRESULT SelectMicrophone( BOOL fSelect );

    HRESULT YieldFocus();
    HRESULT ClaimFocus();    

	LPWAVEFORMATEX GetRecordFormat();
    DWORD GetStartupLatency();

protected: 

    BOOL                            m_fUseCaptureFocus;
	HWND							m_hwndOwner;
	LPDIRECTSOUNDCAPTUREBUFFER		m_lpdscBuffer;
	LPDIRECTSOUNDCAPTUREBUFFER7_1	m_lpdscBuffer7;
	UINT							m_uiWaveDeviceID;
	LPWAVEFORMATEX					m_lpwfxRecordFormat;
	GUID							m_guidDevice;
	CMixerLine						m_mixerLine;
#ifdef LOCKUP_SIMULATION	
	DWORD							m_dwNumSinceLastLockup;
	DWORD							m_dwLastPosition;
#endif 	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecb.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundPlaybackBuffer.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 08/27/99		rodtoll	Updated CreateBuffer call to remove DX7 dependencies.
 * 09/07/99		rodtoll	Added 3d caps to buffer
 * 09/20/99		rodtoll	Added memory allocation failure checks 
 * 10/05/99		rodtoll	Added DPF_MODNAMEs        
 * 11/02/99		pnewson Fix: Bug #116365 - using wrong DSBUFFERDESC
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects    
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 04/17/2000   rodtoll Fix: Bug #32215 - Session Lost after resuming from hibernation 
 * 07/12/2000	rodtoll	Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 10/04/2000	rodtoll	Bug #43510 - DPVOICE: Apps receive a DVMSGID_SESSIONLOST w/DVERR_LOCKEDBUFFER
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DSOUND_STARTUPLATENCY 1 

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::CDirectSoundPlaybackBuffer"
CDirectSoundPlaybackBuffer::CDirectSoundPlaybackBuffer(
	LPDIRECTSOUNDBUFFER lpdsBuffer 
): CAudioPlaybackBuffer(), m_dwLastPosition(0), m_dwPriority(0),m_dwFlags(0),m_fPlaying(FALSE)
{
	HRESULT hr;
	
	hr = lpdsBuffer->QueryInterface( IID_IDirectSoundBuffer, (void **) &m_lpdsBuffer );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to get dsound buffer interface" );
		m_lpdsBuffer = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::CDirectSoundPlaybackBuffer"
CDirectSoundPlaybackBuffer::~CDirectSoundPlaybackBuffer()
{
	if( m_lpdsBuffer != NULL )
	{
		m_lpdsBuffer->Release();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Lock"
HRESULT CDirectSoundPlaybackBuffer::Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	while( 1 )
	{
        hr = m_lpdsBuffer->Lock( dwWriteCursor, dwWriteBytes, lplpvBuffer1, lpdwSize1, lplpvBuffer2, lpdwSize2, dwFlags );

        if( hr == DSERR_BUFFERLOST ) 
        {
            DPFX(DPFPREP, 0, "Buffer lost while locking buffer" );
            hr = Restore();
        }
        else
        {
			DSERTRACK_Update( "DSB::Lock()", hr );	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
        
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::UnLock"
HRESULT CDirectSoundPlaybackBuffer::UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

    hr = m_lpdsBuffer->Unlock( lpvBuffer1, dwSize1, lpvBuffer2, dwSize2 );	

    if( hr == DSERR_BUFFERLOST )
    {
        hr = DS_OK;
    }
    
	DSERTRACK_Update( "DSB::UnLock()", hr );	        		    	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::SetVolume"
HRESULT CDirectSoundPlaybackBuffer::SetVolume( LONG lVolume )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	while( 1 ) 
	{
        hr = m_lpdsBuffer->SetVolume( lVolume );	

        if( hr == DSERR_BUFFERLOST )
        {
            DPFX(DPFPREP, 0, "Buffer lost while setting volume" );
            hr = Restore();
        }
        else
        {
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
        
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::GetCurrentPosition"
HRESULT CDirectSoundPlaybackBuffer::GetCurrentPosition( LPDWORD lpdwPosition )
{
    HRESULT hr;
    
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	while( 1 )
	{
        hr = m_lpdsBuffer->GetCurrentPosition( NULL, lpdwPosition );	

        if( SUCCEEDED( hr ) )
        {
			DSERTRACK_Update( "DSB::GetCurrentPosition()", hr );	        		    	        	
            m_dwLastPosition = *lpdwPosition;
			break;
        }
        else if( hr == DSERR_BUFFERLOST )
        {
            DPFX(DPFPREP, 0, "Buffer lost while getting current position" );
            hr = Restore();
            DPFX(DPFPREP, 0, "Restore --> 0x%x", hr );
        }
        else
        {
			DSERTRACK_Update( "DSB::GetCurrentPosition()", hr );	        		    	        	        		    	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );


        
	}

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::SetCurrentPosition"
HRESULT CDirectSoundPlaybackBuffer::SetCurrentPosition( DWORD dwPosition )
{
    HRESULT hr;
    
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	while( 1 ) 
	{
    	hr = m_lpdsBuffer->SetCurrentPosition( dwPosition );	

        if( SUCCEEDED( hr ) )
        {
			DSERTRACK_Update( "DSB::SetCurrentPosition()", hr );	        		    	        	        	
            m_dwLastPosition = dwPosition;
			break;
        }
        else if( hr == DSERR_BUFFERLOST ) 
        {
            DPFX(DPFPREP, 0, "Buffer lost while setting position" );
            hr = Restore();
        }
        else
        {
			DSERTRACK_Update( "DSB::SetCurrentPosition()", hr );	        		    	        	        	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
        
	}

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Get3DBuffer"
HRESULT CDirectSoundPlaybackBuffer::Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	return m_lpdsBuffer->QueryInterface( IID_IDirectSound3DBuffer, (void **) lplpds3dBuffer );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Play"
HRESULT CDirectSoundPlaybackBuffer::Play( DWORD dwPriority, DWORD dwFlags )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

    m_dwPriority = dwPriority ;
    m_dwFlags = dwFlags;

	while( 1 )
	{
        hr = m_lpdsBuffer->Play( 0, dwPriority, dwFlags );	

        if( hr == DSERR_BUFFERLOST ) 
        {
            DPFX(DPFPREP, 0, "Error playing buffer" );
            hr = Restore();
        }
        else
        {
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
	}

	m_fPlaying = TRUE;

	return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Stop"
HRESULT CDirectSoundPlaybackBuffer::Stop()
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	while( 1 )
	{
        hr = m_lpdsBuffer->Stop(  );		    

        m_fPlaying = FALSE;

        if( hr == DSERR_BUFFERLOST )
        {
            DPFX(DPFPREP, 0, "Error stopping buffer" );
            hr = Restore();
            // If buffer is lost during restore, no need to stop
            break;
        }
        else
        {
			DSERTRACK_Update( "DSB::Stop()", hr );	        		    	        	        	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
	}

	return hr;

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Restore"
HRESULT CDirectSoundPlaybackBuffer::Restore()
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

    HRESULT hr = m_lpdsBuffer->Restore(  );	

    DPFX(DPFPREP, 0, "Restore result --> 0x%x", hr );

    if( SUCCEEDED( hr ) )
    {
        if( m_fPlaying )
        {
            // Attempt to restore current position as well
            hr = m_lpdsBuffer->SetCurrentPosition( m_dwLastPosition );

            if( FAILED( hr ) )
            {
                DPFX(DPFPREP, 0, "Error setting position after restore hr=0x%x", hr );
                return hr;
            }

            hr = Play(m_dwPriority, m_dwFlags);
        }
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::GetStartupLatency"
DWORD CDirectSoundPlaybackBuffer::GetStartupLatency()
{
	return DSOUND_STARTUPLATENCY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayd.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundPlaybackDevice.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation of object using a pre-created
 *						DirectSound Object.
 * 10/05/99		rodtoll	Added DPF_MODNAMEs         
 * 10/14/99		rodtoll	Added 3d caps to primary buffer created
 * 10/27/99		rodtoll	Bug #115431: Must release primary buffer
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects   
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(For Win2k/Millenium/Systems w/DX7) 
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 02/16/2000	rodtoll	Fixed so primary buffer is not released
 * 02/17/2000	rodtoll	Updated so primary buffer is held instead of released immediately 
 * 04/21/2000   rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                      to allow reads of REG_BINARY when expecting REG_DWORD 
 * 04/24/2000   rodtoll Bug #33203 - Removed workaround for aureal vortex 1 problem -- had 
 *                      problems on Vortex 2.  
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 * 07/12/2000	rodtoll	Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 *  08/28/2000	masonb  Voice Merge: Changed ccomutil.h to comutil.h
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy. 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::CDirectSoundPlaybackDevice"
CDirectSoundPlaybackDevice::CDirectSoundPlaybackDevice(
): CAudioPlaybackDevice(), m_hwndOwner(NULL), m_lpdsDirectSound(NULL), m_guidDevice(GUID_NULL), m_lpdsPrimaryBuffer(NULL), m_fEmulated(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::~CDirectSoundPlaybackDevice"
CDirectSoundPlaybackDevice::~CDirectSoundPlaybackDevice()
{
	if( m_lpdsPrimaryBuffer != NULL )
	{
		m_lpdsPrimaryBuffer->Release();
		m_lpdsPrimaryBuffer = NULL;
	}
	
	if( m_lpdsDirectSound != NULL )	
	{	
		m_lpdsDirectSound->Release();
		m_lpdsDirectSound = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::CheckAndSetEmulated"
HRESULT CDirectSoundPlaybackDevice::CheckAndSetEmulated( )
{
	HRESULT hr;
	DSCAPS dsCaps;

	ZeroMemory( &dsCaps, sizeof( DSCAPS ) );
	dsCaps.dwSize = sizeof( DSCAPS );

	hr = m_lpdsDirectSound->GetCaps( &dsCaps );

	if( FAILED( hr ) )
	{
		m_fEmulated = FALSE;
		Diagnostics_Write(DVF_ERRORLEVEL, "Querying for playback caps failed hr=0x%x", hr );		
		return hr;
	}
	
	m_fEmulated = (dsCaps.dwFlags & DSCAPS_EMULDRIVER);

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::Initialize"
HRESULT CDirectSoundPlaybackDevice::Initialize( LPDIRECTSOUND lpdsDirectSound, const GUID &guidDevice )
{
	HRESULT hr;

	m_guidDevice = guidDevice;

	hr = lpdsDirectSound->QueryInterface( IID_IDirectSound, (void **) &m_lpdsDirectSound );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DirectSound Object passed failed. 0x%x Creating internal", hr );
		m_lpdsDirectSound = NULL;
		return hr;
	}

	hr = CheckAndSetEmulated();

	if( FAILED( hr ) )
	{
		m_lpdsDirectSound->Release();
		m_lpdsDirectSound = NULL;
		return hr;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::Initialize"
HRESULT CDirectSoundPlaybackDevice::Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *lpwfxFormat, BOOL fPriorityMode )
{
	HRESULT hr;
    DSBUFFERDESC dsbdesc;
    DWORD dwPriority;

    m_guidDevice = guidDevice;
		
	if( m_lpdsDirectSound != NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Already initialized" );
		return DVERR_INITIALIZED;
	}

	hr = COM_CoCreateInstance( CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectSound, (void **) &m_lpdsDirectSound, FALSE );

	DSERTRACK_Update( "DSD::CoCreateInstance()", hr );	        		    	        	        	        		

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to load directsound hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	hr = m_lpdsDirectSound->Initialize( &guidDevice );

	DSERTRACK_Update( "DSD::Initialize()", hr );	        		    	        	        	        			

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to initialize directsound hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	if( fPriorityMode )
	{
		dwPriority = DSSCL_PRIORITY;
	}
	else
	{
		dwPriority = DSSCL_NORMAL;
	}

	hr = m_lpdsDirectSound->SetCooperativeLevel( hwndOwner, dwPriority );

	DSERTRACK_Update( "DSD::SetCooperativeLevel()", hr );	

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to set cooperative level hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	if( fPriorityMode && lpwfxFormat != NULL )
	{
        memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); 
        dsbdesc.dwSize = sizeof(DSBUFFERDESC); 
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;
        dsbdesc.dwBufferBytes = 0; 
        dsbdesc.lpwfxFormat = NULL; 

        hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) &dsbdesc, &m_lpdsPrimaryBuffer, NULL );

		DSERTRACK_Update( "DSD::CreateSoundBuffer() (Primary)", hr );	        

        if( FAILED( hr ) )
        {
        	Diagnostics_Write(DVF_ERRORLEVEL, "Create of primary buffer failed.  Trying DX5 dsound hr=0x%x", hr );
        	dsbdesc.dwSize = sizeof( DSBUFFERDESC1 );

	        hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) &dsbdesc, &m_lpdsPrimaryBuffer, NULL );        	
        }

        if( FAILED( hr ) )
        {
        	Diagnostics_Write(DVF_ERRORLEVEL, "Could not create primary sound buffer" );
        	goto INITIALIZE_ERROR;
        }

        hr = m_lpdsPrimaryBuffer->SetFormat( lpwfxFormat );

		DSERTRACK_Update( "DSD::SetFormat() (Primary)", hr );	        
        
        if( FAILED( hr ) )
        {
        	Diagnostics_Write(DVF_ERRORLEVEL, "Could not set the format" );
        	goto INITIALIZE_ERROR;
        }
	}
	
	m_hwndOwner = hwndOwner;

	hr = CheckAndSetEmulated();

    if( FAILED( hr ) )
    {
    	Diagnostics_Write(DVF_ERRORLEVEL, "Could not get emulated state hr=0x%x", hr );
    	goto INITIALIZE_ERROR;
    }	

	return DV_OK;

INITIALIZE_ERROR:

	if( m_lpdsPrimaryBuffer )
	{
		m_lpdsPrimaryBuffer->Release();
		m_lpdsPrimaryBuffer = NULL;
	}

	if( m_lpdsDirectSound != NULL )
	{
		m_lpdsDirectSound->Release();
		m_lpdsDirectSound = NULL;
	}
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::CreateBuffer"
HRESULT CDirectSoundPlaybackDevice::CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lplpapBuffer )
{
	HRESULT hr;

	LPDIRECTSOUNDBUFFER lpdsBuffer;

	hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) lpdsBufferDesc, &lpdsBuffer, NULL );

	DSERTRACK_Update( "DSD::CreateSoundBuffer() ", hr );	        	

	if( FAILED( hr ) )
	{
		lpdsBufferDesc->dwSize = sizeof( DSBUFFERDESC1 );
		
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to create sound buffer under DX7.  Attempting DX5 create hr=0x%x", hr );

		hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) lpdsBufferDesc, &lpdsBuffer, NULL );
	}

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Failed to create the sound buffer hr=0x%x", hr );
		return hr;
	}
/*
    // Freee wave format
	delete dsBufferDesc.lpwfxFormat;

	hr = lpdsBuffer->SetFrequency( 8000 );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  0, "Could not set frequency hr=0x%x", hr );
	    return hr;
	}*/

	*lplpapBuffer = new CDirectSoundPlaybackBuffer( lpdsBuffer );

	lpdsBuffer->Release();

	if( *lplpapBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Out of memory" );
		return DVERR_OUTOFMEMORY;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::GetPlaybackDevice"
LPDIRECTSOUND CDirectSoundPlaybackDevice::GetPlaybackDevice( )
{
	return m_lpdsDirectSound;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::GetMixerQuality"
HRESULT CDirectSoundPlaybackDevice::GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to get mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvGetMixerSrcQuality( pPropertySet, m_guidDevice, psrcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::SetMixerQuality"
HRESULT CDirectSoundPlaybackDevice::SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to set mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvSetMixerSrcQuality( pPropertySet, m_guidDevice, srcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dsprvobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.h
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *  12/16/99	rodtoll	Added support for new funcs from dsound team on private
 *						interface for getting process dsound object list
 *  01/08/2001	rodtoll WINBUG #256541	Pseudo: Loss of functionality: Voice Wizrd can't be launched.
 *  02/28/2002	rodtoll	WINBUG #550105  SECURITY: DPVOICE: Dead code
 *						- Remove unused calls.
 *
 ***************************************************************************/

#ifndef __DSPRVOBJ_H__
#define __DSPRVOBJ_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *   ppKsPropertySet
);

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                 pKsPropertySet,
    REFGUID                         guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *   pSrcQuality
);

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET             pKsPropertySet,
    REFGUID                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY SrcQuality
);


HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET pKsPropertySet,
    LPCSTR          pszWaveDevice,
    BOOL            fCapture,
    LPGUID          pguidDeviceId
);

HRESULT PrvGetWaveDeviceMappingW
(
    LPKSPROPERTYSET pKsPropertySet,
    LPWSTR          pwszWaveDevice,
    BOOL            fCapture,
    LPGUID          pguidDeviceId
);

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA *ppData
);

HRESULT PrvGetDirectSoundObjects
(
	LPKSPROPERTYSET						pKsPropertySet,
	const GUID&							guidDevice,
	DSPROPERTY_DIRECTSOUND_OBJECTS_DATA **ppDSObjects
);

HRESULT PrvGetDirectSoundCaptureObjects
(
	LPKSPROPERTYSET								pKsPropertySet,
	const GUID&									guidDevice,	
	DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA 	**ppDSCObjects
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSPRVOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayb.h
 *  Content:	Definition of the CDirectSoundPlaybackBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume 
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects   
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 04/17/2000   rodtoll Fix: Bug #32215 - Session Lost after resuming from hibernation 
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDPLAYBACKBUFFER_H
#define __DIRECTSOUNDPLAYBACKBUFFER_H

// CDirectSoundPlaybackBuffer
//
// This class provides an implementation of the CAudioPlaybackBuffer class
// for directsound.  In the abstract sense, it represents a buffer of audio
// which can be played to the sound hardware which consists of multiple,
// equal length subbuffers.  
//
class CDirectSoundPlaybackBuffer: public CAudioPlaybackBuffer
{
public:
    CDirectSoundPlaybackBuffer( LPDIRECTSOUNDBUFFER lpdsBuffer );
    virtual ~CDirectSoundPlaybackBuffer();

public: 

    HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags );
    HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 );
    HRESULT SetVolume( LONG lVolume );
    HRESULT GetCurrentPosition( LPDWORD lpdwPosition );
    HRESULT SetCurrentPosition( DWORD dwPosition );
    HRESULT Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer );    
    HRESULT Play( DWORD dwPriority, DWORD dwFlags );
    HRESULT Stop();    
    HRESULT Restore();

    DWORD GetStartupLatency();    

protected: 

	LPDIRECTSOUNDBUFFER	m_lpdsBuffer;
	DWORD m_dwLastPosition;
	DWORD m_dwPriority;
	DWORD m_dwFlags;
	BOOL  m_fPlaying;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecd.h
 *  Content:	Definition of the CDirectSoundCaptureRecordDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation of object using a pre-created
 *						DirectSoundCapture Object.
 * 08/04/99		rodtoll	Added member to retrieve DSC object
 * 11/12/99		rodtoll	Modified abstraction for new waveIN support.
 *						Now abstracted types look almost like dsoundcap objects  
 * 11/22/99		rodtoll	Added code to map from GUID to waveIN device
 *						ID for non-millenium systems.
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail 
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 *				rodtoll	New algorithm to map from GUIDs to device IDs if DSound 7.1 is not
 *						available.  Will map device correctly on DX7, will guess for other
 *						DX versions < 7.  However, default device is assumed to be waveIN ID #0.
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *
 ***************************************************************************/

// DirectSoundCaptureRecordDevice.cpp
//
// This module contains the declaration of the DirectSoundCaptureRecordDevice
// class.  See the class definition below for a description
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
#ifndef __DIRECTSOUNDCAPTURERECORDDEVICE_H
#define __DIRECTSOUNDCAPTURERECORDDEVICE_H

// CDirectSoundCaptureRecordDevice
//
// This class provides an implementation of the CAudioRecordDevice class which
// uses the DirectSoundCapture API to talk to the recording hardware.  
//
class CDirectSoundCaptureRecordDevice: public CAudioRecordDevice
{
public:
	CDirectSoundCaptureRecordDevice();
	
    virtual ~CDirectSoundCaptureRecordDevice();

public: // Initialization

    HRESULT Initialize( const GUID &refguidDevice );
    HRESULT Initialize( LPDIRECTSOUNDCAPTURE lpdsc, const GUID &guidDevice );
    
    HRESULT CreateBuffer( LPDSCBUFFERDESC lpdscBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lpapBuffer ); 

    LPDIRECTSOUNDCAPTURE GetCaptureDevice();

    HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality );
    HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality );    

protected:

	HRESULT	FindDeviceID();

    LPDIRECTSOUNDCAPTURE		m_lpdscDirectSound;		// DirectSoundCapture interface
    GUID						m_guidDevice;
    UINT						m_uiWaveDeviceID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dsprvobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.c
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *  12/16/99	rodtoll	Added support for new funcs from dsound team on private
 *						interface for getting process dsound object list 
 *  01/08/2001	rodtoll WINBUG #256541	Pseudo: Loss of functionality: Voice Wizrd can't be launched. 
 *  02/28/2002	rodtoll	WINBUG #550105  SECURITY: DPVOICE: Dead code
 *						- Remove unused calls.
 *				rodtoll	Fix for regression caused by TCHAR conversion (Post DirectX 8.1 work)
 *						- Source was updated to retrieve device information from DirectSound w/Unicode
 *						  but routines which wanted the information needed Unicode.  
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#define MAX_OBJECTS		20


/***************************************************************************
 *
 *  DirectSoundPrivateCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundPrivate object.
 *
 *  Arguments:
 *      LPKSPROPERTYSET * [out]: receives IKsPropertySet interface to the
 *                               object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *       ppKsPropertySet
)
{
    typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

    HINSTANCE               hLibDsound              = NULL;
    LPFNGETCLASSOBJECT      pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;

    // Get dsound.dll's instance handle.  The dll must already be loaded at this
    // point.
    hLibDsound = 
        GetModuleHandle
        (
            TEXT("dsound.dll")
        );

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
            GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerSrcQuality
 *
 *  Description:
 *      Gets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY * [out]: receives mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *               pSrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pSrcQuality = Data.Quality;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerSrcQuality
 *
 *  Description:
 *      Sets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY                 SrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Quality = SrcQuality;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}

/***************************************************************************
 *
 *  PrvGetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPCSTR [in]: wave device description.
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET                                     pKsPropertySet,
    LPCSTR                                              pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA Data;
    HRESULT                                             hr;

    Data.DeviceName = (LPTSTR)pszWaveDevice;
    Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pguidDeviceId = Data.DeviceId;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetWaveDeviceMappingW (Unicode)
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPWCSTR [in]: wave device description.
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetWaveDeviceMappingW
(
    LPKSPROPERTYSET                                     pKsPropertySet,
    LPWSTR                                              pwszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA Data;
    HRESULT                                               hr;

    Data.DeviceName = (LPWSTR)pwszWaveDevice;
    Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pguidDeviceId = Data.DeviceId;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDeviceDescription
 *
 *  Description:
 *      Gets the extended description for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA [out]: receives
 *                                                            description.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA *ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA  pData   = NULL;
    ULONG                                           cbData;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA   Basic;
    HRESULT                                         hr;

    Basic.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA)new BYTE [cbData];

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = guidDeviceId;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        delete[] pData;
    }

    return hr;
}

/***************************************************************************
 *
 *  PrvGetDirectSoundObjects
 *
 *  Description:
 *      Gets the list of DirectSound objects in the current process
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *		GUID guiDevice [in]: Device to get list for, or GUID_NULL for all.
 *      DSPROPERTY_DIRECTSOUND_OBJECTS_DATA [in/out]: Pointer to place
 *							  newly allocated memory containing list.
 *							  Free the memory with a delete [] 
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDirectSoundObjects
(
	LPKSPROPERTYSET						pKsPropertySet,
	const GUID&							guidDevice,
	DSPROPERTY_DIRECTSOUND_OBJECTS_DATA **pDSObjects
)
{
    HRESULT hr;
    ULONG ulSize;
    DSPROPERTY_DIRECTSOUND_OBJECTS_DATA* pDsObjList;
    DWORD dwNumObjects;

  	*pDSObjects = NULL;    

    pDsObjList = (DSPROPERTY_DIRECTSOUND_OBJECTS_DATA *) new DSPROPERTY_DIRECTSOUND_OBJECTS_DATA;

    if( pDsObjList == NULL )
    {
    	return E_OUTOFMEMORY;
    }

    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUND_OBJECTS_DATA ) );
    pDsObjList->DeviceId = guidDevice;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSound,
            DSPROPERTY_DIRECTSOUND_OBJECTS,
            NULL,
            0,
            pDsObjList,
            sizeof( DSPROPERTY_DIRECTSOUND_OBJECTS_DATA ),
            NULL
        );

	dwNumObjects = pDsObjList->Count;



    if(SUCCEEDED(hr))
    {
    	if( dwNumObjects > 0 )
    	{	
    		delete pDsObjList;
			pDsObjList = NULL;
			
		    ulSize = sizeof(DSPROPERTY_DIRECTSOUND_OBJECTS_DATA) + (dwNumObjects * sizeof(DIRECTSOUND_INFO));

		    pDsObjList = (DSPROPERTY_DIRECTSOUND_OBJECTS_DATA *) new BYTE[ulSize];

		    if( pDsObjList == NULL )
		    {
		    	return E_OUTOFMEMORY;
		    }

		    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUND_OBJECTS_DATA ) );
		    pDsObjList->DeviceId = guidDevice;	    

	    	hr =
		        pKsPropertySet->Get
		        (
		            DSPROPSETID_DirectSound,
		            DSPROPERTY_DIRECTSOUND_OBJECTS,
		            NULL,
		            0,
		            pDsObjList,
		            ulSize,
		            NULL
		        );

		    if( FAILED( hr ) )
		    {
		    	delete [] pDsObjList;
		    	return hr;
		    }
		}

		*pDSObjects = pDsObjList;	    
    }
    else
    {
		delete pDsObjList;
		pDsObjList = NULL;    
    	*pDSObjects = NULL;
    }

    return hr;
}

/***************************************************************************
 *
 *  PrvGetDirectSoundCaptureObjects
 *
 *  Description:
 *      Gets the list of DirectSoundCapture objects in the current process
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *		GUID guiDevice [in]: Device to get list for, or GUID_NULL for all.
 *      DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA [in/out]: Pointer to place
 *							  newly allocated memory containing list.
 *							  Free the memory with a delete [] 
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDirectSoundCaptureObjects
(
	LPKSPROPERTYSET						pKsPropertySet,
	const GUID&							guidDevice,
	DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA **pDSObjects
)
{
    HRESULT hr;
    ULONG ulSize;
    DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA* pDsObjList;
    DWORD dwNumObjects;

  	*pDSObjects = NULL;    

    pDsObjList = (DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA *) new DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA;

    if( pDsObjList == NULL )
    {
    	return E_OUTOFMEMORY;
    }

    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA ) );
    pDsObjList->DeviceId = guidDevice;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSound,
            DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS,
            NULL,
            0,
            pDsObjList,
            sizeof( DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA ),
            NULL
        );

	dwNumObjects = pDsObjList->Count;

    if(SUCCEEDED(hr))
    {
    	if( dwNumObjects > 0 )
    	{

			delete [] pDsObjList;
			pDsObjList = NULL;
    	
		    ulSize = sizeof(DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA) + (dwNumObjects * sizeof(DIRECTSOUNDCAPTURE_INFO));

		    pDsObjList = (DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA *) new BYTE[ulSize];

		    if( pDsObjList == NULL )
		    {
		    	return E_OUTOFMEMORY;
		    }

		    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA ) );
		    pDsObjList->DeviceId = guidDevice;	    

	    	hr =
		        pKsPropertySet->Get
		        (
		            DSPROPSETID_DirectSound,
		            DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS,
		            NULL,
		            0,
		            pDsObjList,
		            ulSize,
		            NULL
		        );

		    if( FAILED( hr ) )
		    {
		    	delete [] pDsObjList;
		    	return hr;
		    }
		}

		*pDSObjects = pDsObjList;	    
    }
    else
    {
		delete pDsObjList;
    	*pDSObjects = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecd.cpp
 *  Content:
 *		This file contains the DirectSoundCapture implementation of the 
 *		CAudioRecordDevice abstraction.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/12/99		rodtoll	Modified abstraction for new waveIN support.
 *						Now abstracted types look almost like dsoundcap objects  
 * 11/22/99		rodtoll	Added code to map from GUID to waveIN device
 *						ID for non-millenium systems.
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail 
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 *				rodtoll	New algorithm to map from GUIDs to device IDs if DSound 7.1 is not
 *						available.  Will map device correctly on DX7, will guess for other
 *						DX versions < 7.  However, default device is assumed to be waveIN ID #0. 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support 
 * 04/21/2000   rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                      to allow reads of REG_BINARY when expecting REG_DWORD 
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 * 06/28/2000	rodtoll	Prefix Bug #38022
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 08/28/2000	masonb  Voice Merge: Changed ccomutil.h to comutil.h
 * 09/13/2000	rodtoll	Bug #44806 - When volume control not avail, dropping to DX7 levels instead of disabling volume control 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// This function is responsible for mapping from the Device's GUID to the
// waveIN ID.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::FindDeviceID"
HRESULT CDirectSoundCaptureRecordDevice::FindDeviceID()
{
	HRESULT hr;

	DWORD dwDeviceID = 0;
	
	hr = DV_MapGUIDToWaveID( TRUE, m_guidDevice, &dwDeviceID );

	// If we were going to use the hack for enum of devices
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find waveIN ID, mapping to ID 0 hr=0x%x", hr );
		m_uiWaveDeviceID = 0;
	}	
	else
	{
		m_uiWaveDeviceID = dwDeviceID;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::CDirectSoundCaptureRecordDevice"
CDirectSoundCaptureRecordDevice::CDirectSoundCaptureRecordDevice(
): CAudioRecordDevice(), m_lpdscDirectSound(NULL), m_uiWaveDeviceID(0), m_guidDevice(GUID_NULL)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::CDirectSoundCaptureRecordDevice"
CDirectSoundCaptureRecordDevice::~CDirectSoundCaptureRecordDevice()
{
	if( m_lpdscDirectSound != NULL )
	{
		m_lpdscDirectSound->Release();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::Initialize"
HRESULT CDirectSoundCaptureRecordDevice::Initialize( LPDIRECTSOUNDCAPTURE lpdscDirectSound, const GUID &guidDevice  )
{
	HRESULT hr;

	if( m_lpdscDirectSound != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already initialized" );
		return DVERR_INITIALIZED;
	}

	hr = lpdscDirectSound->QueryInterface( IID_IDirectSoundCapture, (void **) &m_lpdscDirectSound );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "DirectSoundCapture Object passed failed. 0x%x Creating internal", hr );
		m_lpdscDirectSound = NULL;
		return hr;
	}

	m_guidDevice = guidDevice;

	hr = FindDeviceID();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find waveIn ID for device hr=0x%x", hr );
		m_lpdscDirectSound->Release();
		return hr;
	}	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::Initialize"
HRESULT CDirectSoundCaptureRecordDevice::Initialize( const GUID &guidDevice  )
{
	HRESULT hr;
		
	if( m_lpdscDirectSound != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already initialized" );
		return DVERR_INITIALIZED;
	}

	hr = COM_CoCreateInstance( CLSID_DirectSoundCapture, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectSoundCapture, (void **) &m_lpdscDirectSound, FALSE );

	DSERTRACK_Update( "DSCD:CoCreateInstance()", hr );		

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load directsoundcapture hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	hr = m_lpdscDirectSound->Initialize( &guidDevice );

	DSERTRACK_Update( "DSCD:Initialize()", hr );			

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initialize directsoundcapture hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	m_guidDevice = guidDevice;

	hr = FindDeviceID();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find waveIn ID for device hr=0x%x", hr );
		return hr;
	}

	return DV_OK;

INITIALIZE_ERROR:

	if( m_lpdscDirectSound != NULL )
	{
		m_lpdscDirectSound->Release();
		m_lpdscDirectSound = NULL;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::CreateBuffer"
HRESULT CDirectSoundCaptureRecordDevice::CreateBuffer( LPDSCBUFFERDESC lpdsBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lplpacBuffer )
{
	HRESULT hr;

	LPDIRECTSOUNDCAPTUREBUFFER lpdscBuffer;

	lpdsBufferDesc->dwFlags |= DSCBCAPS_CTRLVOLUME;

	hr = m_lpdscDirectSound->CreateCaptureBuffer( lpdsBufferDesc, &lpdscBuffer, NULL );

	DSERTRACK_Update( "DSCD::CreateCaptureBuffer()", hr );	

	// Ask for volume control, if we can't get it, do the old create
	if( hr == DSERR_INVALIDPARAM || hr == DSERR_CONTROLUNAVAIL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "New caps are not available, attempting old create hr=0x%x", hr );

		// Turn off the new caps -- (for non-Millenium systems).
		lpdsBufferDesc->dwFlags &= ~(DSCBCAPS_CTRLVOLUME);

		hr = m_lpdscDirectSound->CreateCaptureBuffer( lpdsBufferDesc, &lpdscBuffer, NULL );		
				
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create the capture buffer hr=0x%x", hr );
		return hr;
	}

	*lplpacBuffer = new CDirectSoundCaptureRecordBuffer( lpdscBuffer, hwndOwner, m_guidDevice, m_uiWaveDeviceID, lpdsBufferDesc );

	lpdscBuffer->Release();

	if( *lplpacBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return DVERR_OUTOFMEMORY;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::GetCaptureDevice"
LPDIRECTSOUNDCAPTURE CDirectSoundCaptureRecordDevice::GetCaptureDevice()
{
	return m_lpdscDirectSound;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::GetMixerQuality"
HRESULT CDirectSoundCaptureRecordDevice::GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to get mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvGetMixerSrcQuality( pPropertySet, m_guidDevice, psrcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::SetMixerQuality"
HRESULT CDirectSoundCaptureRecordDevice::SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to set mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvSetMixerSrcQuality( pPropertySet, m_guidDevice, srcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayd.h
 *  Content:	Definition of the CDirectSoundPlaybackDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation of object using a pre-created
 *						DirectSound Object.
 * 08/04/99		rodtoll	Added member to retrieve DirectSound object
 * 11/01/99		rodtoll	Updated to conform to new interface
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects    
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(For Win2k/Millenium/Systems w/DX7)
 *				rodtoll	Cleanup of class
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 02/17/2000	rodtoll	Updated so primary buffer is held instead of released immediately
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy. 
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDPLAYBACKDEVICE_H
#define __DIRECTSOUNDPLAYBACKDEVICE_H

class CDirectSoundPlaybackDevice;

// CDirectSoundPlaybackDevice
//
// This class is responsible for providing an implementation of the 
// CAudioPLaybackDevice class for DirectSound.  A single instance
// of this class represents a DirectSound playback device and
// is used to initialize the sound device and act as a class
// factory for CAudioPlaybackBuffers for the DirectSound
// sub-system.
//
class CDirectSoundPlaybackDevice: public CAudioPlaybackDevice
{
public:
    CDirectSoundPlaybackDevice( );

    virtual ~CDirectSoundPlaybackDevice();

public: // Initialization

    HRESULT Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *primaryFormat, BOOL fPriorityMode );
    HRESULT Initialize( LPDIRECTSOUND lpDirectSound, const GUID &guidDevice );

    BOOL IsEmulated() { return m_fEmulated; };
    
    HRESULT CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lpapBuffer );
    LPDIRECTSOUND GetPlaybackDevice();    

    HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality );
    HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality );
    
protected:

	HRESULT CheckAndSetEmulated( );
	
    LPDIRECTSOUND       m_lpdsDirectSound;			// DirectSound object associated w/this object
    LPDIRECTSOUNDBUFFER m_lpdsPrimaryBuffer;
    HWND				m_hwndOwner;
    GUID				m_guidDevice;
    BOOL				m_fEmulated;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dverror.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dverror.h
 *  Content:	Error string handling
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 01/21/2000	pnewson Created
 *
 ***************************************************************************/

#ifndef _DVERROR_H
#define _DVERROR_H

void DV_DisplayErrorBox(HRESULT hr, HWND hwndParent, UINT idsErrorMessage = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dvcdb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvcdb.cpp
 *  Content:	
 *			This module contains the implementation of the compression
 *			subsystem and the associated utility functions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 08/29/99		rodtoll	Created
 * 09/01/99		rodtoll	Updated to add checks for valid read/write pointers
 * 09/07/99		rodtoll	Removed bad assert and added dpf_modnames
 *					    Removed Create flag on registry opens
 * 09/10/99		rodtoll	dwFlags check on call to DVCDB_CopyCompress...
 * 09/14/99		rodtoll	Minor bugfix in compression info copy
 * 09/21/99		rodtoll	Added OSInd and fixed memory leak 
 * 10/07/99		rodtoll	Added stubs for supporting new codecs 
 *				rodtoll	Updated to use Unicode
 * 10/15/99		rodtoll	Plugged some memory leaks 
 * 10/28/99		rodtoll	Updated to use new compression providers
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 11/22/99		rodtoll	Removed false error message when loading compression types
 * 12/16/99		rodtoll	Removed asserts (which were not needed) exposed by compression
 *						provider changes.
 * 02/10/2000	rodtoll	Fixed crash if invalid registry entries are present.
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 03/16/2000   rodtoll   Updated converter create to check and return error code
 * 04/21/2000   rodtoll Bug #32889 - Does not run on Win2k w/o Admin 
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  06/28/2000	rodtoll	Prefix Bug #38022
 *  08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h, added STR_* and strutils.h
 *  08/31/2000	rodtoll	Prefix Bug #171840
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


struct DVCDBProvider
{
	GUID					guidClassID;
	PDVFULLCOMPRESSIONINFO	pInfo;
	DWORD					dwNumElements;
	DVCDBProvider			*pNext;
};

DVCDBProvider *g_dvcdbProviderList = NULL;

#define REGISTRY_CDB_FORMAT					L"Format"
#define REGISTRY_WAVEFORMAT_RATE			L"Rate"
#define REGISTRY_WAVEFORMAT_BITS			L"Bits"
#define REGISTRY_WAVEFORMAT_CHANNELS		L"Channels"
#define REGISTRY_WAVEFORMAT_TAG				L"Tag"
#define REGISTRY_WAVEFORMAT_AVGPERSEC		L"AvgPerSec"
#define REGISTRY_WAVEFORMAT_BLOCKALIGN		L"BlockAlign"
#define REGISTRY_WAVEFORMAT_CBSIZE			L"cbsize"
#define REGISTRY_WAVEFORMAT_CBDATA			L"cbdata"

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CalcUnCompressedFrameSize"
DWORD DVCDB_CalcUnCompressedFrameSize( const DVFULLCOMPRESSIONINFO* lpdvInfo, const WAVEFORMATEX* lpwfxFormat )
{
	DWORD frameSize;

    switch( lpwfxFormat->nSamplesPerSec )
    {
    case 8000:      frameSize = lpdvInfo->dwFrame8Khz;      break;
    case 11025:     frameSize = lpdvInfo->dwFrame11Khz;     break;
    case 22050:     frameSize = lpdvInfo->dwFrame22Khz;     break;
    case 44100:     frameSize = lpdvInfo->dwFrame44Khz;     break;
    default:        return 0;
    }

	if( lpwfxFormat->wBitsPerSample == 16 )
		frameSize *= 2;

	frameSize *= lpwfxFormat->nChannels;

	return frameSize;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CREG_ReadAndAllocWaveFormatEx"
HRESULT CREG_ReadAndAllocWaveFormatEx( HKEY hkeyReg, LPCWSTR path, LPWAVEFORMATEX *lpwfxFormat )
{
	CRegistry waveKey;

	if( !waveKey.Open( hkeyReg, path, TRUE, FALSE ) )
	{
		return E_FAIL; 
	}

	DWORD dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CBSIZE, &dwTmp ) )
	{
		return E_FAIL;
	}

	*lpwfxFormat = (LPWAVEFORMATEX) new BYTE[dwTmp+sizeof(WAVEFORMATEX)];

	LPWAVEFORMATEX tmpFormat = *lpwfxFormat;

	if( tmpFormat == NULL )
	{
		return E_OUTOFMEMORY;
	}

	tmpFormat->cbSize = (BYTE) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_RATE, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->nSamplesPerSec = dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BITS, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->wBitsPerSample = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CHANNELS, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->nChannels = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_TAG, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->wFormatTag = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->nAvgBytesPerSec = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, &dwTmp ) ) 
	{
		goto READ_FAILURE;
	}

	tmpFormat->nBlockAlign = (INT) dwTmp;

	dwTmp = tmpFormat->cbSize;

	if( !waveKey.ReadBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &tmpFormat[1], &dwTmp ) )
	{
		DPFX(DPFPREP,  0, "Error reading waveformat blob" );
		goto READ_FAILURE;
	}

	return S_OK;

READ_FAILURE:

	delete [] *lpwfxFormat;
	*lpwfxFormat = NULL;

	return E_FAIL;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_LoadCompressionInfo"
HRESULT DVCDB_LoadCompressionInfo( const WCHAR *swzBaseRegistryPath )
{
	CRegistry mainKey, subKey;
	LPWSTR keyName = NULL;
	DWORD dwIndex = 0;
	DWORD dwSize = 0;
	HRESULT hr;
	PDPVCOMPRESSIONPROVIDER pCompressionProvider = NULL;	
	DVCDBProvider *pNewProvider = NULL;
	WCHAR wszPath[_MAX_PATH];

	if( swzBaseRegistryPath == NULL )
	{
		DPFX(DPFPREP,  0, "INTERNAL ERROR!" );
		return E_FAIL;
	}

	wcscpy( wszPath, swzBaseRegistryPath );
    wcscat( wszPath, DPVOICE_REGISTRY_CP );
	
	if( !mainKey.Open( HKEY_LOCAL_MACHINE, wszPath, TRUE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Error reading compression providers from the registry.  Path doesn't exist" );
		return E_FAIL;
	}

	dwIndex = 0;
	keyName = NULL;
	dwSize = 0;
	LPSTR lpstrKeyName = NULL;
	GUID guidCP;

	// Enumerate the subkeys at this point in the tree
	while( 1 )
	{
		dwSize = 0;

		if( !mainKey.EnumKeys( keyName, &dwSize, dwIndex ) )
		{
			if( dwSize == 0 )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "End of provider list" );
				break;
			}

			if( keyName != NULL )
			{
				delete [] keyName;
			}

			keyName = new wchar_t[dwSize];
		}

		if( !mainKey.EnumKeys( keyName, &dwSize, dwIndex ) )
		{
			delete [] keyName;
			break;
		}

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
			break;
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Reading provider: %hs", lpstrKeyName );

		if( !subKey.Open( mainKey, keyName, TRUE, FALSE ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading provider: %hs", lpstrKeyName );
			goto SKIP_TO_NEXT;
		}

		delete [] keyName;
		keyName = NULL;
		dwSize = 0;

		// Read the GUID from the default key
		if( !subKey.ReadGUID( L"", &guidCP ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to read the provider's GUID" );
			goto SKIP_TO_NEXT;
		}

		// Attempt to create the provider
		hr = COM_CoCreateInstance( guidCP , NULL, CLSCTX_INPROC_SERVER, IID_IDPVCompressionProvider, (void **) &pCompressionProvider, FALSE );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "FAILED to create 0x%x\n", hr );	
			goto SKIP_TO_NEXT;
		} 

		// Build a record for the provider
		pNewProvider = new DVCDBProvider;

		if( pNewProvider == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
			goto SKIP_TO_NEXT;
		}
		
		pNewProvider->guidClassID = guidCP;
		pNewProvider->pInfo = NULL;
		pNewProvider->dwNumElements = 0;
		dwSize = 0;

		// GetCompression Info for the provider
		hr = pCompressionProvider->EnumCompressionTypes( pNewProvider->pInfo, &dwSize, &pNewProvider->dwNumElements, 0 );

		if( hr != DVERR_BUFFERTOOSMALL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get compression info for provider: %hs", lpstrKeyName );
			goto SKIP_TO_NEXT;
		}

		pNewProvider->pInfo = (DVFULLCOMPRESSIONINFO *) new BYTE[dwSize];

		if( pNewProvider->pInfo == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
			goto SKIP_TO_NEXT;
		}

		hr = pCompressionProvider->EnumCompressionTypes( pNewProvider->pInfo, &dwSize, &pNewProvider->dwNumElements, 0 );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get compression info for %hs hr=0x%x", lpstrKeyName, hr );
			goto SKIP_TO_NEXT;
		}

		// Add it to the list
		pNewProvider->pNext = g_dvcdbProviderList;
		g_dvcdbProviderList = pNewProvider;

		pNewProvider = NULL;
		

	SKIP_TO_NEXT:

		if( pCompressionProvider != NULL )
		{
			pCompressionProvider->Release();
			pCompressionProvider = NULL;
		}

		if( pNewProvider != NULL )
		{
			delete pNewProvider;
			pNewProvider = NULL;
		}

		if( lpstrKeyName != NULL )
			delete [] lpstrKeyName;

		if( keyName != NULL )
			delete [] keyName;	
		lpstrKeyName = NULL;
		keyName = NULL;
		dwSize = 0;

		dwIndex++;

		continue;
	}

	if( lpstrKeyName != NULL )
		delete [] lpstrKeyName;

	if( keyName != NULL )
		delete [] keyName;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_FreeCompressionInfo"
HRESULT DVCDB_FreeCompressionInfo()
{
	DVCDBProvider *pTmpProvider, *pTmpNext;

	if( g_dvcdbProviderList == NULL )
		return DV_OK;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		pTmpNext = pTmpProvider->pNext;

		delete [] pTmpProvider->pInfo;
		delete pTmpProvider;
	
		pTmpProvider = pTmpNext;
	}

	g_dvcdbProviderList = NULL;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_GetCompressionClassID"
HRESULT DVCDB_GetCompressionClassID( const GUID& guidCT, GUID* pguidClass )
{
	DVCDBProvider *pTmpProvider;
	DWORD dwIndex;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		for( dwIndex = 0; dwIndex < pTmpProvider->dwNumElements; dwIndex++ )
		{
			if( pTmpProvider->pInfo[dwIndex].guidType == guidCT )
			{
				*pguidClass = pTmpProvider->guidClassID;
				return DV_OK;
			}
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}

	return DVERR_COMPRESSIONNOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_GetCompressionInfo"
HRESULT DVCDB_GetCompressionInfo( const GUID &guidType, PDVFULLCOMPRESSIONINFO *lpdvfCompressionInfo )
{
	DVCDBProvider *pTmpProvider;
	DWORD dwIndex;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		for( dwIndex = 0; dwIndex < pTmpProvider->dwNumElements; dwIndex++ )
		{
			if( pTmpProvider->pInfo[dwIndex].guidType == guidType )
			{
				*lpdvfCompressionInfo = &pTmpProvider->pInfo[dwIndex];
				return DV_OK;
			}
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}

	return DVERR_COMPRESSIONNOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CreateConverter"
HRESULT DVCDB_CreateConverter( WAVEFORMATEX *pwfxSrcFormat, const GUID &guidTarget, PDPVCOMPRESSOR *pConverter )
{
	HRESULT hr;
	GUID guidProvider;
	PDPVCOMPRESSIONPROVIDER pCompressionProvider = NULL;	

	hr = DVCDB_GetCompressionClassID( guidTarget, &guidProvider );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Requested compression type is not supported, hr=0x%x", hr );
		return hr;
	}
	
	hr = COM_CoCreateInstance( guidProvider , NULL, CLSCTX_INPROC_SERVER, IID_IDPVCompressionProvider, (void **) &pCompressionProvider, FALSE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "FAILED to create 0x%x\n", hr );	
		return DVERR_COMPRESSIONNOTSUPPORTED;
	} 

	hr = pCompressionProvider->CreateCompressor( pwfxSrcFormat, guidTarget, pConverter, 0 );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating compressor hr=0x%x", hr );
	    return hr;
	}

	pCompressionProvider->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CreateConverter"
HRESULT DVCDB_CreateConverter( const GUID &guidSrc, WAVEFORMATEX *pwfxTarget, PDPVCOMPRESSOR *pConverter )
{
	HRESULT hr;
	GUID guidProvider;
	PDPVCOMPRESSIONPROVIDER pCompressionProvider = NULL;	

	hr = DVCDB_GetCompressionClassID( guidSrc, &guidProvider );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Requested compression type is not supported, hr=0x%x", hr );
		return hr;
	}
	
	hr = COM_CoCreateInstance( guidProvider , NULL, CLSCTX_INPROC_SERVER, IID_IDPVCompressionProvider, (void **) &pCompressionProvider, FALSE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "FAILED to create 0x%x\n", hr );	
		return DVERR_COMPRESSIONNOTSUPPORTED;
	} 

	hr = pCompressionProvider->CreateDeCompressor( guidSrc, pwfxTarget, pConverter, 0 );

    if( FAILED( hr ) )
    {
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating compressor hr=0x%x", hr );
	    return hr;
    }
    
	pCompressionProvider->Release();

	return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CopyCompressionArrayToBuffer"
HRESULT DVCDB_CopyCompressionArrayToBuffer( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags )
{
	if( lpdwNumElements == NULL || lpdwSize == NULL ||
	    !DNVALID_READPTR(lpdwNumElements,sizeof(DWORD)) ||
	    !DNVALID_READPTR(lpdwSize,sizeof(DWORD)) )
	{
		return E_POINTER;
	}

	if( dwFlags != 0 )
	{
		return DVERR_INVALIDFLAGS;
	}

	DWORD dwIndex, dwReadIndex;
	DWORD dwRequiredSize = 0;
	DWORD dwTmpSize;

	LPDVCOMPRESSIONINFO lpdvTargetList;

	LPBYTE lpbExtraLoc = (LPBYTE) lpBuffer;

	*lpdwNumElements = 0;

	DVCDBProvider *pTmpProvider;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		for( dwIndex = 0; dwIndex < pTmpProvider->dwNumElements; dwIndex++ )
		{
			dwRequiredSize += DVCDB_GetCompressionInfoSize( (LPDVCOMPRESSIONINFO) &pTmpProvider->pInfo[dwIndex] );
			(*lpdwNumElements)++;
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}

	if( *lpdwSize < dwRequiredSize )
	{
		*lpdwSize = dwRequiredSize;	
		return DVERR_BUFFERTOOSMALL;
	}

	*lpdwSize = dwRequiredSize;	

	if( lpBuffer == NULL || !DNVALID_WRITEPTR(lpBuffer,dwRequiredSize) )
	{
		return E_POINTER;
	}

	lpbExtraLoc += (*lpdwNumElements)*sizeof(DVCOMPRESSIONINFO);
	lpdvTargetList = (LPDVCOMPRESSIONINFO) lpBuffer;

	pTmpProvider = g_dvcdbProviderList;

	dwIndex = 0;

	while( pTmpProvider != NULL )
	{
		for( dwReadIndex = 0; dwReadIndex < pTmpProvider->dwNumElements; dwReadIndex++, dwIndex++ )
		{
			memcpy( &lpdvTargetList[dwIndex], &pTmpProvider->pInfo[dwReadIndex], sizeof(DVCOMPRESSIONINFO) );

			if( pTmpProvider->pInfo[dwReadIndex].lpszDescription != NULL )
			{
				dwTmpSize = (wcslen( pTmpProvider->pInfo[dwReadIndex].lpszDescription )*2)+2;
				memcpy( lpbExtraLoc, pTmpProvider->pInfo[dwReadIndex].lpszDescription, dwTmpSize );
				lpdvTargetList[dwIndex].lpszDescription = (LPWSTR) lpbExtraLoc;
				lpbExtraLoc += dwTmpSize;
			}

			if( pTmpProvider->pInfo[dwReadIndex].lpszName != NULL )
			{
				dwTmpSize = (wcslen( pTmpProvider->pInfo[dwReadIndex].lpszName )*2)+2;
				memcpy( lpbExtraLoc, pTmpProvider->pInfo[dwReadIndex].lpszName, dwTmpSize );
				lpdvTargetList[dwIndex].lpszName = (LPWSTR) lpbExtraLoc;
				lpbExtraLoc += dwTmpSize;
			}
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_GetCompressionInfoSize"
DWORD DVCDB_GetCompressionInfoSize( LPDVCOMPRESSIONINFO lpdvCompressionInfo )
{
	DNASSERT( lpdvCompressionInfo != NULL );

	DWORD dwSize;

	dwSize = sizeof( DVCOMPRESSIONINFO );
	
	if( lpdvCompressionInfo->lpszDescription != NULL )
	{
		dwSize += (wcslen( lpdvCompressionInfo->lpszDescription )*2)+2;
	}

	if( lpdvCompressionInfo->lpszName != NULL )
	{
		dwSize += (wcslen( lpdvCompressionInfo->lpszName)*2)+2;
	}

	return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dverror.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dverror.cpp
 *  Content:	Error string handling
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 01/21/2000	pnewson Created
 *  04/19/2000	pnewson	    Error handling cleanup  
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MESSAGE_STRING_MAX_LEN 256
#define MAX_ERROR_CODE_STRING_LEN 8

static const TCHAR* g_tszDefaultMessage = _T("DirectPlay Voice has encountered an error\r\n(The error code was 0x%x)");
static const TCHAR* g_tszDefaultMessageCaption = _T("Error");

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DisplayDefaultErrorBox"
void DV_DisplayDefaultErrorBox(HRESULT hr, HWND hwndParent)
{
	DPFX(DPFPREP, DVF_ERRORLEVEL, "DV_DisplayDefaultErrorBox called");

	TCHAR tszMsgFmt[MESSAGE_STRING_MAX_LEN];
	
	if (_tcslen(g_tszDefaultMessage) + MAX_ERROR_CODE_STRING_LEN + 1 < MESSAGE_STRING_MAX_LEN)
	{
		_stprintf(tszMsgFmt, g_tszDefaultMessage, hr);
	}
	else
	{	
		// Programmer mess up, DNASSERT if we're in debug, otherwise just
		// copy what we can of the default message over.
		DNASSERT(FALSE);
		_tcsncpy(tszMsgFmt, g_tszDefaultMessage, MESSAGE_STRING_MAX_LEN - 1);
	}
	
	MessageBox(hwndParent, tszMsgFmt, g_tszDefaultMessageCaption, MB_OK|MB_ICONERROR);
	
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DisplayErrorBox"
void DV_DisplayErrorBox(HRESULT hr, HWND hwndParent, UINT idsErrorMessage)
{
	DPFX(DPFPREP, DVF_ERRORLEVEL, "DV_DisplayErrorBox called");

	TCHAR tszMsg[MESSAGE_STRING_MAX_LEN];
	TCHAR tszMsgFmt[MESSAGE_STRING_MAX_LEN];
	TCHAR tszCaption[MESSAGE_STRING_MAX_LEN];
	
#if !defined(DBG) || !defined( DIRECTX_REDIST )
	HINSTANCE hDPVoiceDll = LoadLibrary(_T("dpvoice.dll"));
#else
	// For redist debug builds we append a 'd' to the name to allow both debug and retail to be installed on the system
	HINSTANCE hDPVoiceDll = LoadLibrary(_T("dpvoiced.dll"));
#endif //  !defined(DBG) || !defined( DIRECTX_REDIST )
	if (hDPVoiceDll == NULL)
	{
		// Very weird! go with a default message.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadLibrary(dpvoice.dll) failed - using default hardcoded message");
		DV_DisplayDefaultErrorBox(hr, hwndParent);
		return;
	}
	
	if (!LoadString(hDPVoiceDll, IDS_ERROR_CAPTION, tszCaption, MESSAGE_STRING_MAX_LEN))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadString failed - using default hardcoded message");
		DV_DisplayDefaultErrorBox(hr, hwndParent);
		return;
	}

	if (idsErrorMessage == 0)
	{
		if (!LoadString(hDPVoiceDll, IDS_ERROR_MSG, tszMsg, MESSAGE_STRING_MAX_LEN))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadString failed - using default hardcoded message");
			DV_DisplayDefaultErrorBox(hr, hwndParent);
			return;
		}

		if (_tcslen(tszMsg) + MAX_ERROR_CODE_STRING_LEN + 1 < MESSAGE_STRING_MAX_LEN)
		{
			_stprintf(tszMsgFmt, tszMsg, hr);
		}
		else
		{	
			// Programmer mess up, DNASSERT if we're in debug, otherwise just
			// copy what we can of the default message over.
			DNASSERT(FALSE);
			_tcsncpy(tszMsgFmt, tszMsg, MESSAGE_STRING_MAX_LEN - 1);
		}
	}
	else
	{
			//passed a valid error string identifier. Try and pull string in
		if (!LoadString(hDPVoiceDll, idsErrorMessage, tszMsgFmt, MESSAGE_STRING_MAX_LEN))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadString failed - using default hardcoded message");
			DV_DisplayDefaultErrorBox(hr, hwndParent);
			return;
		}		
	}
	
	if (!IsWindow(hwndParent))
	{
		hwndParent = NULL;
	}
	MessageBox(hwndParent, tszMsgFmt, tszCaption, MB_OK|MB_ICONERROR);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dvcdb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvcdb.h
 *  Content:	structures, data types and functions for the
 *				compression subsystem
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 08/23/99		rodtoll	Created
 * 09/08/99		rodtoll	Moved the dwMaxBitsPerSecond field to the DVCOMPRESSIONINFO struct
 * 10/07/99		rodtoll	Updated to work in Unicode 
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *
 ***************************************************************************/

#ifndef __DVCDB_H
#define __DVCDB_H

HRESULT DVCDB_LoadCompressionInfo(const WCHAR *swzBaseRegistryPath );
HRESULT DVCDB_FreeCompressionInfo();

HRESULT CREG_ReadAndAllocWaveFormatEx( HKEY hkeyReg, LPCWSTR path, LPWAVEFORMATEX *lpwfxFormat );
HRESULT DVCDB_GetCompressionInfo( const GUID &guidType, PDVFULLCOMPRESSIONINFO *lpdvfCompressionInfo );

HRESULT DVCDB_CreateConverter( const GUID &guidSrc, WAVEFORMATEX *pwfxTarget, PDPVCOMPRESSOR *pConverter );
HRESULT DVCDB_CreateConverter( WAVEFORMATEX *pwfxSrcFormat, const GUID &guidTarget, PDPVCOMPRESSOR *pConverter );
DWORD DVCDB_CalcUnCompressedFrameSize( const DVFULLCOMPRESSIONINFO* lpdvInfo, const WAVEFORMATEX* lpwfxFormat );

HRESULT DVCDB_CopyCompressionArrayToBuffer( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags );
DWORD DVCDB_GetCompressionInfoSize( LPDVCOMPRESSIONINFO lpdvCompressionInfo );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dxvutilspch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxvutilspch.h
 *  Content:    DirectPlayVoice DXVUTILS master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *  02/28/2002	rodtoll	WINBUG #550105  SECURITY: DPVOICE: Dead code
 *						- Remove unused files from precompiled header
 *
 ***************************************************************************/

#ifndef __DXVUTILSPCH_H__
#define __DXVUTILSPCH_H__

// 
// Public includes
//
#include <windows.h>
#include <string>
#include <mmsystem.h>
#include <tchar.h>
#include <string>
#include <list>
#include <vector>
#include <math.h>
#include <mmddk.h>

// 
// DirectX public includes
//
#include <dsoundp.h>
#include <dsprv.h>

// 
// DirectPlay public includes
//
#include "dvoice.h"
#include "dpvcp.h"
#include "dplay8.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"

// 
// DirectPlay Voice private includes
//
//#include "fdtcfg.h"

// 
// DirectPlay Voice Utils includes
//

#include "mixline.h"
#include "dvcdb.h"
#include "aplayb.h"
#include "aplayd.h"
#include "arecb.h"
#include "dsplayb.h"
#include "diagnos.h"
#include "sndutils.h"
#include "dsplayd.h"
#include "dsprvobj.h"
#include "inqueue2.h"
#include "innerque.h"
#include "bfcsynch.h"
#include "wiutils.h"
#include "arecd.h"
#include "dscrecd.h"
#include "devmap.h"
#include "dscrecb.h"
#include "decibels.h"
#include "frame.h"
#include "agcva.h"
#include "agcva1.h"
#include "wavformat.h"
#include "dvtimer.h"


#include "resource.h"

#endif // __DXVUTILSPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\frame.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecd.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 08/03/99		pnewson General clean up, updated target to DVID
 * 01/14/2000	rodtoll	Updated to support multiple targets.  Frame will 
 *						automatically allocate memory as needed for targets.
 *				rodtoll	Added SetEqual function to making copying of frame
 *						in Queue easier. 
 *				rodtoll	Added support for "user controlled memory" frames.
 *						When the default constructor is used with the UserOwn_XXXX
 *						functions the frames use user specified buffers.  
 *						(Removes a buffer copy when queueing data). 
 *  01/31/2000	pnewson replace SAssert with DNASSERT
 *  02/17/2000	rodtoll	Updated so sequence/msg numbers are copied when you SetEqual
 *  07/09/2000	rodtoll	Added signature bytes 
 *  02/28/2002	rodtoll	WINBUG #550105  SECURITY: DPVOICE: Dead code
 *						- Remove unused GetTargets() function
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MODULE_ID   FRAME

// SetEqual
//
// This function sets the current frame to match the data in frSourceFrame
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::SetEqual"
HRESULT CFrame::SetEqual( const CFrame &frSourceFrame )
{
	HRESULT hr;
	
	SetClientId( frSourceFrame.GetClientId());
	SetSeqNum(frSourceFrame.GetSeqNum());
	SetMsgNum(frSourceFrame.GetMsgNum());
	CopyData(frSourceFrame);
	SetIsSilence(frSourceFrame.GetIsSilence());

	hr = SetTargets( frSourceFrame.GetTargetList(), frSourceFrame.GetNumTargets() );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error copying frame for queue" );
	}

	return hr;
}

// SetTargets
//
// This program sets the targets for this frame.  It will expand the 
// target list (if required) or use a subset of the current buffer.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::SetTargets"
HRESULT CFrame::SetTargets( PDVID pdvidTargets, DWORD dwNumTargets )
{
	DNASSERT( m_fOwned );
	
	if( dwNumTargets > m_dwMaxTargets )
	{
		if( m_pdvidTargets != NULL )
		{
			delete [] m_pdvidTargets;
		}

		m_pdvidTargets = new DVID[dwNumTargets];

		if( m_pdvidTargets == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}
		
		m_dwMaxTargets = dwNumTargets;
	}

	m_dwNumTargets = dwNumTargets;

	memcpy( m_pdvidTargets, pdvidTargets, sizeof(DVID)*dwNumTargets );

	return DV_OK;
}

// This function is called to return a frame to the frame
// pool that is managing it. If a primary pointer was 
// provided, it will be set to NULL.
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::Return"
void CFrame::Return()
{
	// the CInputQueue2 or CInnerQueue class is supposed to give us 
	// the critical section object. If it does not, these functions 
	// should not be called.
	DNASSERT(m_pCriticalSection != NULL);

	BFCSingleLock csl(m_pCriticalSection);
	csl.Lock();

	// this frame is supposed to be part of a frame pool if
	// this function is called
	DNASSERT(m_pFramePool != NULL);

	// return the frame to the pool, and set the primary
	// frame pointer to null to signal to the caller that
	// this frame is now gone. Note that this pointer update
	// is done within the critical section passed to this
	// class, and so the caller should also use this 
	// critical section to check the pointer value. This
	// is true for CInputQueue, which uses the critical
	// section for Reset, Enqueue and Dequeue.
	m_pFramePool->Return(this);

	if (m_ppfrPrimary != NULL)
	{
		*m_ppfrPrimary = NULL;
	}
}

// CFrame Constructor
//
// This is the primary constructor which is used for creating frames
// that are used by the frame pool.
//
// If you want to create a non-pooled frame then use the default constructor
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::CFrame"
CFrame::CFrame(WORD wFrameSize, 
	WORD wClientNum,
	BYTE wSeqNum,
    BYTE bMsgNum,
	BYTE bIsSilence,
	CFramePool* pFramePool,
	DNCRITICAL_SECTION* pCriticalSection,
	CFrame** ppfrPrimary)
	: m_dwSignature(VSIG_FRAME),
	m_wFrameSize(wFrameSize),
	m_wClientId(wClientNum),
	m_wSeqNum(wSeqNum),
	m_bMsgNum(bMsgNum),
	m_bIsSilence(bIsSilence),
    m_wFrameLength(wFrameSize),
	m_pFramePool(pFramePool),
	m_pCriticalSection(pCriticalSection),
	m_ppfrPrimary(ppfrPrimary),
	m_fIsLost(false),
	m_pdvidTargets(NULL),
	m_dwNumTargets(0),
	m_dwMaxTargets(0),
	m_fOwned(true)
{
	m_pbData = new BYTE[m_wFrameSize];
}

// CFrame Constructor
//
// This is the constructor to use when creating a standalone frame.  This 
// type of frame can take an external buffer to eliminate a buffer copy.
//
// The frame doesn't "own" the buffer memory so it doesn't attempt to 
// free it.
//
// To set the data for the frame use the UserOwn_SetData member.
//
// Target information can be handled the same way by using UserOwn_SetTargets 
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::CFrame"
CFrame::CFrame(
	): 	m_dwSignature(VSIG_FRAME),
		m_wFrameSize(0),
		m_wClientId(0),
		m_wSeqNum(0),
		m_bMsgNum(0),
		m_bIsSilence(true),
	    m_wFrameLength(0),
		m_pFramePool(NULL),
		m_pCriticalSection(NULL),
		m_ppfrPrimary(NULL),
		m_fIsLost(false),
		m_pdvidTargets(NULL),
		m_dwNumTargets(0),
		m_dwMaxTargets(0),
		m_fOwned(false)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::~CFrame"
CFrame::~CFrame() 
{	
	if( m_fOwned )
	{
		delete [] m_pbData; 

		if( m_pdvidTargets != NULL )
		{
			delete [] m_pdvidTargets;
		}
	}

	m_dwSignature = VSIG_FRAME_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::CopyData"
void CFrame::CopyData(const BYTE* pbData, WORD wFrameLength)
{
	DNASSERT(pbData != 0);
	memcpy(m_pbData, pbData, wFrameLength);
    m_wFrameLength = wFrameLength;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::CFramePool"
CFramePool::CFramePool(WORD wFrameSize)
	: m_wFrameSize(wFrameSize), m_fCritSecInited(FALSE)
{
	// Push a couple of frames into the pool to start with
	for (int i = 0; i < 2; ++i)
	{
		m_vpfrPool.push_back(new CFrame(m_wFrameSize));
	}

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::~CFramePool"
CFramePool::~CFramePool()
{
	for (std::vector<CFrame *>::iterator iter1 = m_vpfrPool.begin(); iter1 < m_vpfrPool.end(); ++iter1)
	{
		delete *iter1;
	}

	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_lock);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::Get"
CFrame* CFramePool::Get(DNCRITICAL_SECTION* pCriticalSection, CFrame** ppfrPrimary)
{
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	CFrame* pfr;
	if (m_vpfrPool.empty())
	{
		// the pool is empty, return a new frame
		pfr = new CFrame(m_wFrameSize);

		if( pfr == NULL )
		{
			DPFX(DPFPREP,  0, "Error allocating memory" );
			return NULL;
		}
	}
	else
	{
		// there are some frames in the pool, pop
		// the last one off the back of the vector
		pfr = m_vpfrPool.back();
		m_vpfrPool.pop_back();
	}

	pfr->SetCriticalSection(pCriticalSection);
	pfr->SetPrimaryPointer(ppfrPrimary);
	pfr->SetFramePool(this);

	// clear up the rest of the flags, but don't bother messing
	// with the data.
	pfr->SetIsLost(false);
	pfr->SetMsgNum(0);
	pfr->SetSeqNum(0);
	pfr->SetIsSilence(FALSE);

	return pfr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::Return"
void CFramePool::Return(CFrame* pFrame)
{
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	// drop this frame on the back for reuse
	m_vpfrPool.push_back(pFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dvtimer.h ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvtimer.h
 *  Content:	Defintion of DvTimer class.
 *			This class is a replacement for the original Timer class (by rodtoll) which used multimedia timers
 *			This replaces the multimedia timers with the dplay8 threadpool timers, whilst maintaining
 *			a similar interface to the original Timer class
 *		
 *  History:
 *   Date		By			Reason
 *   ====	==			======
 * 05-06-02	simonpow	Created
 *
 ***************************************************************************/

#ifndef __DVTIMER_H__
#define __DVTIMER_H__

	//number of msec we sleep whilst spinning in our cancel timer loop
static const DWORD DvTimer_SleepPeriodInCancelSpin=5;

	//prototype for the callback user of timer can specify
typedef void (*DvTimerCallback)(void * pvUserData);

class DvTimer
{
public:
		//default c'tor. Establishes timer in uncreated state
	DvTimer(void);

		//default d'tor. If timer has been created this will cancel it and not return until it has
	~DvTimer(void);

		//create timer to fire every 'dwPeriod' msec, calling 'pfnCallback' with 'pvUserData'
		//when it does. Returns TRUE for sucess
	BOOL Create (DWORD dwPeriod, void * pvUserData,  DvTimerCallback pfnCallback);

protected:

	static void WINAPI ThreadpoolTimerCallbackStatic(void * const pvContext, 
											void * const pvTimerData, const UINT uiTimerUnique);


	DvTimerCallback m_pfnUserCallback;
	void * m_pvUserData;
	DWORD m_dwPeriod;
	void * m_pvTimerData;
	volatile UINT m_uiTimerUnique;
	IDirectPlay8ThreadPoolWork * m_pThreadPool;
};

#endif 	// #ifndef __DVTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\dvtimer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvtimer.pp
 *  Content:	Implementation of DvTimer class.
 *		
 *  History:
 *   Date		By			Reason
 *   ====	==			======
 * 05-06-02	simonpow	Created
 *
 ***************************************************************************/

#include "dxvutilspch.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#undef DPF_MODNAME
#define DPF_MODNAME "DvTimer::DvTimer"

DvTimer::DvTimer()
{
	DPFX(DPFPREP,  DVF_TRACELEVEL, "Entry");

	m_pfnUserCallback=NULL;
	m_pvUserData=NULL;
	m_dwPeriod=0;
	m_pvTimerData=NULL;
	m_uiTimerUnique=0;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "DvTimer object create at 0x%p", this);

	DPFX(DPFPREP,  DVF_TRACELEVEL, "Exit");
}


#undef DPF_MODNAME
#define DPF_MODNAME "DvTimer::~DvTimer"

DvTimer::~DvTimer()
{
	DPFX(DPFPREP,  DVF_TRACELEVEL, "Entry");

		//if we've actually created a timer and got a thread pool interface
	if (m_pThreadPool)
	{
		HRESULT hr;
			//If we're in the middle of the callback we'll not be able to cancel the timer
			//hence spin until we do (since its rescheduled at the end of every callback)
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Starting cancel loop");
		DNASSERT(m_pvTimerData);
			//we don't want to be in the situation where the timer keeps getting rescheduled and we keep
			//missing it. i.e. Constantly waking up in the period its active rather than the period its scheduled
			//hence, set the period to a high value to ensure the next time it fires (if at all) it will be 24hrs away
		m_dwPeriod=1000*60*60*24;
		while (1)
		{
			hr=IDirectPlay8ThreadPoolWork_CancelTimer(m_pThreadPool, m_pvTimerData, m_uiTimerUnique, 0);
			if (hr==DPN_OK)
				break;
			DNASSERT(hr==DPNERR_CANNOTCANCEL);
			Sleep(DvTimer_SleepPeriodInCancelSpin);
		}
		IDirectPlay8ThreadPoolWork_Release(m_pThreadPool);
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "DvTimer destroyed at 0x%p", this);
	
	DPFX(DPFPREP,  DVF_TRACELEVEL, "Exit");
}


#undef DPF_MODNAME
#define DPF_MODNAME "DvTimer::Create"

BOOL DvTimer::Create (DWORD dwPeriod, void * pvUserData,  DvTimerCallback pfnCallback)
{
	DPFX(DPFPREP,  DVF_TRACELEVEL, "Entry dwPeriod %u pvUserData 0x%p pfnCallback 0x%p", 
														dwPeriod, pvUserData, pfnCallback);
		//sanity checks
	DNASSERT(pfnCallback);
	DNASSERT(dwPeriod);

		//store state user specifies for timer
	m_pfnUserCallback=pfnCallback;
	m_pvUserData=pvUserData;
	m_dwPeriod=dwPeriod;
	
		//get a thread pool interface. Since the thread pool is a singleton object, this probably won't
		//actually do the creation
	HRESULT hr=CoCreateInstance(CLSID_DirectPlay8ThreadPool, NULL, CLSCTX_INPROC_SERVER,
						IID_IDirectPlay8ThreadPoolWork, (void **) &m_pThreadPool);
	if (FAILED(hr))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to CoCreate CLSID_DirectPlay8ThreadPool hr 0x%x", hr);
		return FALSE;
	}
		//schedule the first timer
	hr=IDirectPlay8ThreadPoolWork_ScheduleTimer(m_pThreadPool, -1,
					dwPeriod, ThreadpoolTimerCallbackStatic, this, &m_pvTimerData, (UINT* ) &m_uiTimerUnique, 0);
	if (FAILED(hr))
	{
			//need to return state to 'uncreated', so we don't do any clean up in the d'tor
		IDirectPlay8ThreadPoolWork_Release(m_pThreadPool);
		m_pThreadPool=NULL;
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to schedule timer hr 0x%x", hr);
		return FALSE;
	}
	DPFX(DPFPREP,  DVF_INFOLEVEL, "DvTimer create success m_pvTimerData 0x%p m_uiTimerUnique 0x%p",
																	m_pvTimerData, m_uiTimerUnique);

		//need to ensure that at least one thread is around to service our timer
	IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(m_pThreadPool, 1, 0);

	DPFX(DPFPREP,  DVF_TRACELEVEL, "Exit");
	return TRUE;	
}


#undef DPF_MODNAME
#define DPF_MODNAME "DvTimer::ThreadpoolTimerCallbackStatic"

void  DvTimer::ThreadpoolTimerCallbackStatic(void * const pvContext, 
											void * const pvTimerData, const UINT uiTimerUnique)
{
	DPFX(DPFPREP,  DVF_TRACELEVEL, "Entry pvContext 0x%p pvTimerData 0x%p uiTimerUnique %u",
																pvContext, pvTimerData, uiTimerUnique);

		//extract the timer object from the context
	DvTimer * pTimer=(DvTimer * ) pvContext;
		//and store the time we started the callback
	DWORD dwStartTime=GETTIMESTAMP();
		//generate the callback to the user
	(*pTimer->m_pfnUserCallback)(pTimer->m_pvUserData);
		//compute the period for the next timer, based on the required period minus
		//the time that elasped doing the actual work
		//This ensures that the user is called at periods as close to m_dwPeriod as possible
	DWORD dwPeriod=pTimer->m_dwPeriod-(GETTIMESTAMP()-dwStartTime);
		//if the new period is in the past (i.e. we spent so long in the callback we are due another one
		//immediately) then set the minimum period for the next callback
	if (((int ) dwPeriod)<0)
		dwPeriod=1;
		//N.B. We don't pass m_dwTimerUnique direct to the Reset timer function, since we could be using
		//the value in a cancel spin. Hence, we wait until the timer has definitely been rescheduled
		//before storing the new unique value for it. 
	UINT uiNextTimerUnique;
	IDirectPlay8ThreadPoolWork_ResetCompletingTimer(pTimer->m_pThreadPool, pvTimerData, dwPeriod, 
										ThreadpoolTimerCallbackStatic, pTimer, &uiNextTimerUnique, 0);
	pTimer->m_uiTimerUnique=uiNextTimerUnique;

	DPFX(DPFPREP,  DVF_TRACELEVEL, "Exit");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\frame.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		frame.h
 *  Content:	declaration of the CFrame and CFramePool classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/22/99		rodtoll	Updated target to be DWORD
 * 08/03/99		pnewson General clean up, updated target to DVID
 * 01/14/2000	rodtoll	Updated to support multiple targets.  Frame will 
 *						automatically allocate memory as needed for targets.
 *				rodtoll	Added SetEqual function to making copying of frame
 *						in Queue easier. 
 *				rodtoll	Added support for "user controlled memory" frames.
 *						When the default constructor is used with the UserOwn_XXXX
 *						functions the frames use user specified buffers.  
 *						(Removes a buffer copy when queueing data).
 *  01/31/2000	pnewson replace SAssert with DNASSERT
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 *  07/09/2000	rodtoll	Added signature bytes 
 *  02/28/2002	rodtoll	WINBUG #550105  SECURITY: DPVOICE: Dead code
 *						- Remove unused GetTargets() function
 *
 ***************************************************************************/

#ifndef _FRAME_H_
#define _FRAME_H_

// forward declaration
class CFramePool;

#define VSIG_FRAME		'MRFV'
#define VSIG_FRAME_FREE	'MRF_'

// This class is designed to manage one frame of sound data.
//
// tag: fr
volatile class CFrame
{
private:

	DWORD				m_dwSignature;
	// The critical section object which is used to protect the 
	// return method. This is passed in by CInputQueue2 and/or CInnerQueue
	// class, so that the return method is serialized with calls to 
	// Reset, Enqueue and Dequeue. If no critical section is passed,
	// the Return member should not be used, and this frame should
	// not be part of a managed pool.
	DNCRITICAL_SECTION	*m_pCriticalSection;

    // Length of the data within the frame.  There may be less then a whole
    // frame worth of data in the buffer due to compression/decompression may
    // result in a slightly different size buffer.
    WORD m_wFrameLength;

	// The size of this frame.  It would be easier to make
	// this a class constant, but we're probably going to want to 
	// toy with the frame sizes while we're optimizing, and
	// we may even get really fancy in the future and have
	// the client and server negotiate the frame size at connection
	// time, all of which will be easier if we bite the bullet now
	// and make this a member variable.  Note this is constant,
	// so once a frame is instantiated, it's size is permanently set.
	WORD m_wFrameSize;

	// The client number this frame is coming from or
	// going to.
	WORD m_wClientId;

	// The frame sequence number.
	BYTE m_wSeqNum;

	// The message number the frame is part of
    BYTE m_bMsgNum;

    // The target of the frame
    PDVID m_pdvidTargets;
    DWORD m_dwNumTargets;
    DWORD m_dwMaxTargets;

    bool m_fOwned;

	// A flag to specify that this frame contains nothing but silence.
	// When this flag is set, the data in the frame buffer should not 
	// be used - it's probably not valid.
	BYTE m_bIsSilence;

	// A pointer to the frame's data
	BYTE* m_pbData;

	// If this frame is part of a managed frame pool, this
	// member will be non-null.
	CFramePool* m_pFramePool;

	// If this frame is part of a managed frame pool, this
	// points to the "primary" pointer to this frame.
	// When the frame is unlocked, and therefore returned
	// to the pool, the pointer this member points to will 
	// be set to null. This action is protected by the
	// critical section passed to the class.
	CFrame** m_ppfrPrimary;

	// A flag to indicate if this frame was "lost". This is
	// used to distinguish the silent frames pulled from the
	// queue between messages from the dead space caused by 
	// a known lost packet.
	bool m_fIsLost;


	// don't allow copy construction or assignment of these
	// structures, as this would kill our performance, and
	// we don't want to do it by accident
	CFrame(const CFrame& fr);
	CFrame& operator=(const CFrame& fr);

public:

	// This constructor sets all the frame's info, and allocates
	// the data buffer, but does not set the data inside the buffer
	// to anything.  Defaults are provided for all the parameters
	// except for the frame size.  Note: no default constructor,
	// since you must specify the frame size.
	CFrame(WORD wFrameSize, 
		WORD wClientNum = 0,
		BYTE wSeqNum = 0,
        BYTE bMsgNum = 0,
		BYTE bIsSilence = 0,
		CFramePool *pFramePool = NULL,
		DNCRITICAL_SECTION* pCriticalSection = NULL,
		CFrame** ppfrPrimary = NULL);

	// A frame which manages user ownded memory
	CFrame();

	// The destructor cleans up the memory allocated by the
	// constructor
	~CFrame();

	inline DWORD GetNumTargets() const { return m_dwNumTargets; };
	inline const PDVID const GetTargetList() const { return m_pdvidTargets; };

    // Length of the data within the buffer
    WORD GetFrameLength() const { return m_wFrameLength; }

	// returns the frame size, (the length of the data buffer)
	WORD GetFrameSize() const { return m_wFrameSize; }

	HRESULT SetEqual( const CFrame &frSourceFrame );

	// These are just a bunch of set and get functions for 
	// the simple parts of the class, the client id, the
	// sequence number, the silence flag, etc.
    HRESULT SetTargets( PDVID pdvidTargets, DWORD dwNumTargets );
    
    BYTE GetMsgNum() const { return m_bMsgNum; }
    void SetMsgNum( BYTE msgNum ) { m_bMsgNum = msgNum; }
	void SetClientId(WORD wClientId) {	m_wClientId = wClientId; }
	WORD GetClientId() const {	return m_wClientId;	}
	void SetSeqNum(BYTE wSeqNum) {	m_wSeqNum = wSeqNum; }
	BYTE GetSeqNum() const { return m_wSeqNum; }
	void SetIsSilence(BYTE bIsSilence) { m_bIsSilence = bIsSilence; }
    void SetFrameLength(const WORD &length) { m_wFrameLength = length; }
	BYTE GetIsSilence() const { return m_bIsSilence; }
	bool GetIsLost() const { return m_fIsLost;	}
	void SetIsLost(bool fIsLost) {	m_fIsLost = fIsLost; }
	
	// Now we have the functions which handle the data.  This
	// class is pretty trusting, because it will give out the
	// pointer to it's data.  This is to avoid all non-required
	// buffer copies.  For example, when you hand a buffer to
	// a wave in function, you can give it the pointer to this
	// buffer, and it will fill in the frame's buffer directly.
	// Between this function and the GetFrameSize() and 
	// GetFrameLength() functions, you can do anything you want 
	// with the buffer.
	BYTE* GetDataPointer() const { return m_pbData; }

	// This copies the data from another frame into this frame
	void CopyData(const CFrame& fr)
	{
		memcpy(m_pbData, fr.GetDataPointer(), fr.GetFrameLength() );
        m_wFrameLength = fr.GetFrameLength();
	}

	void UserOwn_SetData( BYTE *pbData, DWORD dwLength )
	{
		m_pbData = pbData;
		m_wFrameLength = dwLength;
		m_wFrameSize = dwLength;
	}

	void UserOwn_SetTargets( PDVID pdvidTargets, DWORD dwNumTargets )
	{
		m_pdvidTargets = pdvidTargets;
		m_dwNumTargets = dwNumTargets;
		m_dwMaxTargets = dwNumTargets;
	}

	// This copies data from a buffer into this frame's
	// buffer.
	void CopyData(const BYTE* pbData, WORD wFrameLength);

	// If this frame is part of a frame pool managed by a
	// CFramePool object, then call this function when you 
	// are done with the frame and want to return it to the
	// pool.
    void Return();

	void SetCriticalSection(DNCRITICAL_SECTION* pCrit)	{ m_pCriticalSection = pCrit; }
	void SetPrimaryPointer(CFrame** ppfrPrimary) {	m_ppfrPrimary = ppfrPrimary; }
	void SetFramePool(CFramePool* pFramePool) { m_pFramePool = pFramePool;	}
};

// This class manages a pool of frames, to reduce memory requirements.
// Only a few buffers are actually in use at any time by the queue
// class, and yet it may have to allocate hundreds of them unless 
// a class such as this is used to manage their reuse.
volatile class CFramePool
{
private:
	// the pool is simply a vector of frame objects
	std::vector<CFrame *> m_vpfrPool;

	// All the frames in the pool must be the same size,
	// which is stored here.
	WORD m_wFrameSize;

	// This critical section is used to exclude the Get()
	// and return members from each other.
    DNCRITICAL_SECTION m_lock;

	BOOL m_fCritSecInited;

public:
	// Each frame pool manages frames of a certain size,
	// so they can be easily reused. If you need multiple
	// different frame sizes, you'll need more than one 
	// frame pool.
	CFramePool(WORD wFrameSize); 
	~CFramePool();

	BOOL Init() 
	{ 
		if (DNInitializeCriticalSection( &m_lock ))
		{
			m_fCritSecInited = TRUE;
			return TRUE;
		}
		else
		{
			return FALSE; 
		}
	}

	// Use Get to retrieve a frame from the pool. ppfrPrimary
	// is a pointer to a point that you want set to null when
	// this frame is returned to the pool. pCriticalSection 
	// points to a critical section that will be entered before
	// setting the pointer to null, and left after setting the 
	// pointer to null. This is so external classes (such as 
	// CInnerQueue) can pass in a critical section that they also
	// use to before examining the pointer referred to by ppfrPrimary
	CFrame* Get(DNCRITICAL_SECTION* pCriticalSection, CFrame** ppfrPrimary);

	// Call Return to give a frame back to the frame pool. 
	// This may set a pointer to null and enter a critical
	// section, as described in Get() above.
	void Return(CFrame* pFrame);
};


#endif /* _FRAME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\innerque.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		innerque.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method 
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 10/28/99		pnewson Bug #113933 debug spew too verbose
 *						implement inner queue pool code
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs.  Plugged memory leak
 *                      caused as a result of new architecture.
 * 01/14/2000	rodtoll	Updated to use new Frame SetEqual function
 * 01/31/2000	pnewson replace SAssert with DNASSERT
 * 06/28/2000	rodtoll	Prefix Bug #38022
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MODULE_ID   INNERQUEUE

// the number of slots reseved to account for 
// out of order startup frames. For example, if the first
// three frames of a message arrive in the order 3, 2, 1, instead
// of 1, 2, 3, we must reserve 2 slots in front of the "first"
// frame (3) so we'll have a place to put the tardy 1 and 2.
const BYTE c_bNumStartSlots = 2;

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::CInnerQueue"
CInnerQueue::CInnerQueue(
	BYTE bNumSlots,
	WORD wFrameSize,
	CFramePool* pfpFramePool,
	DNCRITICAL_SECTION* pcsQueue,
	BYTE bMsgNum,
	BYTE bHighWaterMark,
	WORD wQueueId
	)
	: m_bNumSlots(bNumSlots)
	, m_eState(CInnerQueue::empty)
	, m_bHighWaterMark(bHighWaterMark)
	, m_bQueueSize(0)
	, m_bHeadSeqNum(0)
	, m_fFirstDequeue(true)
	//, m_rgeSlotStates(NULL)
	, m_rgpfrSlots(NULL)
	, m_bFillingDequeueReqs(0)
	, m_wMissingFrames(0)
	, m_wDuplicateFrames(0)
	, m_wOverflowFrames(0)
	, m_wLateFrames(0)
	, m_wPossibleZeroLengthDequeues(0)
	, m_wKnownZeroLengthDequeues(0)
	, m_dwMsgLen(0)
	, m_wQueueId(wQueueId)
	, m_bMsgNum(bMsgNum)
	, m_pfpFramePool(pfpFramePool)
	, m_pcsQueue(pcsQueue)
	, m_fInited(FALSE)
{
	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::CInnerQueue() CFramePool: %p", m_wQueueId, m_bMsgNum, m_pfpFramePool);
	#endif

	// verify that bNumSlots is at least 8, and is a
	// power of 2.
	DNASSERT(bNumSlots == 0x08 || 
		bNumSlots == 0x10 ||
		bNumSlots == 0x20 ||
		bNumSlots == 0x40 ||
		bNumSlots == 0x80);

	// Check to make sure the watermark is not larger
	// than the number of slots. It should really be 
	// significantly less than bNumSlots, but oh well.
	// 
	DNASSERT(bHighWaterMark < bNumSlots - c_bNumStartSlots);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Init"
HRESULT CInnerQueue::Init()
{
	int i;

	/*
	// allocate the slot state array
	m_rgeSlotStates = new ESlotState[m_bNumSlots];
	if (m_rgeSlotStates == NULL)
	{
		goto error;		
	}
	*/

	// allocate the slot array
	m_rgpfrSlots = new CFrame*[m_bNumSlots];
	if (m_rgpfrSlots == NULL)
	{
		goto error;		
	}

	// Initialize the slot states and the slots
	for (i = 0; i < m_bNumSlots; ++i)
	{
		//m_rgeSlotStates[i] = essEmpty;
		m_rgpfrSlots[i] = NULL;
	}

	m_fInited = TRUE;
	return S_OK;

error:
	/*
	if (m_rgeSlotStates != NULL)
	{
		delete [] m_rgeSlotStates;
		m_rgeSlotStates = NULL;
	}
	*/
	if (m_rgpfrSlots != NULL)
	{
		delete [] m_rgpfrSlots;
		m_rgpfrSlots = NULL;		
	}
	m_fInited = FALSE;
	return E_FAIL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::~CInnerQueue"
CInnerQueue::~CInnerQueue()
{
	if (m_fInited)
	{
		/*
		if (m_rgeSlotStates != NULL)
		{
			delete [] m_rgeSlotStates;
			m_rgeSlotStates = NULL;
		}
		*/
		if (m_rgpfrSlots != NULL)
		{
			// check to ensure that no frames are in use
			for (int i = 0; i < m_bNumSlots; ++i)
			{
				if( m_rgpfrSlots[i] != NULL )
					m_rgpfrSlots[i]->Return();
			}
	
			delete [] m_rgpfrSlots;
			m_rgpfrSlots = NULL;
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Reset"
void CInnerQueue::Reset()
{
	if (!m_fInited)
	{
		return;
	}
	
	// loop through and make sure none of the frames are currently locked and clear the slot states
	for (int i = 0; i < m_bNumSlots; ++i)
	{
		if (m_rgpfrSlots[i] != NULL)
		{
			m_rgpfrSlots[i]->Return();
		}
		//m_rgeSlotStates[i] = essEmpty;
	}

	m_eState = CInnerQueue::empty;
	m_bQueueSize = 0;
	m_bHeadSeqNum = 0;
	m_fFirstDequeue = true;
	m_bFillingDequeueReqs = 0;

	ResetStats();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::ResetStats"
void CInnerQueue::ResetStats()
{
	if (!m_fInited)
	{
		return;
	}

	m_wMissingFrames = 0;
	m_wDuplicateFrames = 0;
	m_wOverflowFrames = 0;
	m_wLateFrames = 0;
	m_dwMsgLen = 0;
	m_wPossibleZeroLengthDequeues = 0;
	m_wKnownZeroLengthDequeues = 0;
}

// This function is not inline because it needs the module id, sigh.
#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::SetHighWaterMark"
void CInnerQueue::SetHighWaterMark(BYTE bHighWaterMark) 
{ 	
	if (!m_fInited)
	{
		return;
	}

	DNASSERT(bHighWaterMark < m_bNumSlots);
	m_bHighWaterMark = bHighWaterMark;
}

// Note: this class does not have it's own critical
// section. The caller must ensure that enqueue and
// dequeue are not called at the same time. It is 
// intended that this class is used only within
// the InputQueue2 class, which does have a critical
// section.
#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Enqueue"
void CInnerQueue::Enqueue(const CFrame& frFrame)
{
	if (!m_fInited)
	{
		return;
	}

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() MsgNum[%i] SeqNum[%i]", m_wQueueId, m_bMsgNum, frFrame.GetMsgNum(), frFrame.GetSeqNum());
	#endif

	DNASSERT(m_eState != finished);

	if (m_eState == empty)
	{
		// This is the first frame, so set the head of the queue.
		// NOTE: It may seem strange to set the head of the
		// queue to 2 frames before the first one we receive,
		// but this covers the case where the first frame
		// we receive is not the first frame of the message.
		// By using this logic, if any of the first, second
		// or third frames arrive first, we will not chop
		// off the start of the message. When the user
		// asks for the first dequeue, it will skip the
		// empty slots at the head of the queue, assuming
		// they haven't been filled in.
		m_bHeadSeqNum = (frFrame.GetSeqNum() - c_bNumStartSlots);
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() new message - m_bHeadSeqNum[%i]", m_wQueueId, m_bMsgNum, m_bHeadSeqNum);
		DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() state changed to filling", m_wQueueId, m_bMsgNum);
		#endif
		m_eState = filling;
	}

	// Check to see if we should put this frame into the queue.
	//
	// NOTE: The logic below implicitly checks for queue overflows.
	// if the sequence number is out of the allowable range, one
	// of two things may have happened.
	// 1) queue overflow
	// 2) frame arrived too late
	//
	// First we need to know if we are dealing with a wraparound 
	// problem.
	bool fKeepFrame = false;
	if ((BYTE)(m_bHeadSeqNum + m_bNumSlots) < m_bHeadSeqNum)
	{
		// we've got a wraparound problem, so use this alternate logic
		if (frFrame.GetSeqNum() >= m_bHeadSeqNum
			|| frFrame.GetSeqNum() < (BYTE)(m_bHeadSeqNum + m_bNumSlots))
		{
			fKeepFrame = true;
		}
	}
	else
	{
		// no wraparound problem, so use the straightforward logic
		if (frFrame.GetSeqNum() >= m_bHeadSeqNum
			&& frFrame.GetSeqNum() < m_bHeadSeqNum + m_bNumSlots)
		{
			fKeepFrame = true;
		}
	}

	// if we're supposed to keep this frame, copy it into the
	// appropriate slot
	if (fKeepFrame)
	{
		BYTE bSlot = frFrame.GetSeqNum() % m_bNumSlots;

		// check to see if this slot is full
		//if (m_rgeSlotStates[bSlot] == essFull)
		if (m_rgpfrSlots[bSlot] != NULL)
		{
			// This is a duplicate frame, so don't do anything
			// with it, but tell the debugger about it, and
			// update our stats.
			//
			// NOTE: We know that this a duplicate frame and
			// not a queue overflow because we have already
			// checked for queue overflow above.
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() Ignoring duplicate frame, sequence number[%i], slot[%i]",
				m_wQueueId, m_bMsgNum, frFrame.GetSeqNum(), bSlot);
			#endif
			m_wDuplicateFrames++;
		}
		else
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() putting frame in slot[%i]", m_wQueueId, m_bMsgNum, bSlot);
			#endif

			// if the frame previously occupying this slot has not
			// yet been released, this slot will not have a null pointer.
			DNASSERT(m_rgpfrSlots[bSlot] == NULL);

			// get a frame from the pool
			//m_rgpfrSlots[bSlot] = m_pfpFramePool->Get(m_pcsQueue, &m_rgpfrSlots[bSlot]);
			m_rgpfrSlots[bSlot] = m_pfpFramePool->Get(m_pcsQueue, NULL);

			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() got frame from pool, Addr:%p", m_wQueueId, m_bMsgNum, m_rgpfrSlots[bSlot]);
			#endif
				
			/* RMT -- Added new func to copy frames directly.

			// the client number is the same
			m_rgpfrSlots[bSlot]->SetClientId(frFrame.GetClientId());

            // copy the target
            m_rgpfrSlots[bSlot]->SetTarget(frFrame.GetTarget());

			// No one but this function should be using
			// the sequence number, so just zero it out.
			m_rgpfrSlots[bSlot]->SetSeqNum(0);

			// copy the frame's data, also sets the frame length
			m_rgpfrSlots[bSlot]->CopyData(frFrame);

			// set the silence flag
			m_rgpfrSlots[bSlot]->SetIsSilence(frFrame.GetIsSilence()); */

			HRESULT hr;

			hr = m_rgpfrSlots[bSlot]->SetEqual(frFrame);

			if( FAILED( hr ) )
			{
				DNASSERT( FALSE );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to copy frame in innerque" );
			}
			
			// this buffer is now full
			//m_rgeSlotStates[bSlot] = essFull;

			// increment the queue size
			++m_bQueueSize;
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() new queue size[%i]", m_wQueueId, m_bMsgNum, m_bQueueSize);
			#endif

			// if the queue is currently filling, check to see if we've
			// passed the high water mark.
			if (m_eState == filling && m_bQueueSize > m_bHighWaterMark)
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() High Water Mark hit, now in ready state", m_wQueueId, m_bMsgNum);
				#endif
				m_bFillingDequeueReqs = 0;
				m_eState = ready;
			}
		}
	}
	else
	{
		// Make a guess as to what caused this: overflow or late frame
		// Sequence numbers are allowed to be in the range 0 to 255.
		// if a sequence number is somewhere in the range 127 prior
		// to the current queue head (accounting for wraparound) then
		// assume it's a late frame. Otherwise, assume it's an overflow frame.
		if ((frFrame.GetSeqNum() < m_bHeadSeqNum
			&& frFrame.GetSeqNum() > (int)m_bHeadSeqNum - 127)
			|| (frFrame.GetSeqNum() > (128 + m_bHeadSeqNum)))
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() Late frame, discarded", m_wQueueId, m_bMsgNum);
			#endif
			m_wLateFrames++;
		}
		else
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() Overflow frame, discarded", m_wQueueId, m_bMsgNum);
			#endif
			m_wOverflowFrames++;
		}
	}

	return;
}

// Note: this class does not have it's own critical
// section. The caller must ensure that enqueue and
// dequeue are not called at the same time. It is 
// intended that this class is used only within
// the InputQueue2 class, which does have a critical
// section.
#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Dequeue"
CFrame* CInnerQueue::Dequeue()
{
	CFrame* pfrReturn;
	
	if (!m_fInited)
	{
		return NULL;
	}

	// make sure that we're in the ready state
	DNASSERT(m_eState == ready);

	// The only class that should be using this one should
	// never call dequeue when there's nothing to get, so assert
	DNASSERT(m_bQueueSize != 0);

	// If we get here, there is at least one frame in the queue, somewhere.

	// increment the length of the message
	++m_dwMsgLen;

	// find the index of the oldest frame, starting with the frame at the 
	// head of the queue.
	BYTE bSlot = m_bHeadSeqNum % m_bNumSlots;
	int i = 0;

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() Checking slot[%i]", m_wQueueId, m_bMsgNum, bSlot);
	#endif
	//while (m_rgeSlotStates[bSlot] != essFull)
	while (m_rgpfrSlots[bSlot] == NULL)
	{
		// if this is the first dequeue, then we want to skip any empty
		// slots to find the first frame in the message. Otherwise, this
		// is a lost frame, and should be treated accordingly.
		if (m_fFirstDequeue == true)
		{
			// The current slot does not have a frame, try the
			// next. Put in a little sanity check for infinite
			// looping.
			DNASSERT(i++ < m_bNumSlots);
			++bSlot;
			bSlot %= m_bNumSlots;
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() slot empty, checking slot[%i]", m_wQueueId, m_bMsgNum, bSlot);
			#endif

			// increment the head sequence number
			++m_bHeadSeqNum;
		}
		else
		{
			// This is a lost frame
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() Frame Missing", m_wQueueId, m_bMsgNum);
			#endif
			++m_wMissingFrames;

			// this missing frame is part of the message too, so 
			// increment the total message size
			++m_dwMsgLen;

			// increment the head sequence number
			++m_bHeadSeqNum;

			// this is no longer the first dequeue
			m_fFirstDequeue = false;

			// return a silent frame marked as lost
			CFrame* pfr = m_pfpFramePool->Get(m_pcsQueue, NULL);
			pfr->SetIsSilence(true);
			pfr->SetIsLost(true);

			return pfr;
		}
	}

	m_fFirstDequeue = false;

	// By now, bSlot points to a valid, useful frame, which
	// we should return.

	// mark the slot we are about to return as empty
	//m_rgeSlotStates[bSlot] = essEmpty;

	// decrement the queue size
	--m_bQueueSize;
	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() Returning frame in slot[%i]; New queue size[%i]", m_wQueueId, m_bMsgNum, bSlot, m_bQueueSize);
	#endif

	// increment the head sequence number
    ++m_bHeadSeqNum;

	// this is not a lost frame
	//m_rgpfrSlots[bSlot]->SetIsLost(false);
	pfrReturn = m_rgpfrSlots[bSlot];
	pfrReturn->SetIsLost(false);
	m_rgpfrSlots[bSlot] = NULL;

	//return(m_rgpfrSlots[bSlot]);
	return(pfrReturn);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::CInnerQueuePool"
CInnerQueuePool::CInnerQueuePool(
	BYTE bNumSlots,
	WORD wFrameSize,
	CFramePool* pfpFramePool,
	DNCRITICAL_SECTION* pcsQueue)
	: m_bNumSlots(bNumSlots)
	, m_wFrameSize(wFrameSize)
	, m_pfpFramePool(pfpFramePool)
	, m_pcsQueue(pcsQueue)
	, m_fCritSecInited(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::~CInnerQueuePool"
CInnerQueuePool::~CInnerQueuePool()
{
	for (std::vector<CInnerQueue *>::iterator iter1 = m_vpiqPool.begin(); iter1 < m_vpiqPool.end(); ++iter1)
	{
		delete *iter1;
	}
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_lock);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::Get"
CInnerQueue* CInnerQueuePool::Get(		
		BYTE bHighWaterMark,
		WORD wQueueId,
		BYTE bMsgNum
)
{
	HRESULT hr;
	
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	CInnerQueue* piq;
	if (m_vpiqPool.empty())
	{
		// the pool is empty, return a new inner queue
		piq = new CInnerQueue(
			m_bNumSlots,
			m_wFrameSize,
			m_pfpFramePool,
			m_pcsQueue,
			bMsgNum,
			bHighWaterMark,
			wQueueId);

		if( piq == NULL )
			return NULL;

		hr = piq->Init();	
		if (FAILED(hr))
		{
			delete piq;
			return NULL;
		}
	}
	else
	{
		// there are some inner queues in the pool, pop
		// the last one off the back of the vector
		piq = m_vpiqPool.back();
		m_vpiqPool.pop_back();
		piq->SetMsgNum(bMsgNum);
		piq->SetQueueId(wQueueId);
		piq->SetHighWaterMark(bHighWaterMark);
		piq->Reset();
	}

	return piq;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::Return"
void CInnerQueuePool::Return(CInnerQueue* piq)
{
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	// drop this inner queue on the back for reuse
	m_vpiqPool.push_back(piq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\inqueue2.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		inqueue2.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method 
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 10/28/99		pnewson Bug #113933 debug spew too verbose 
 * 01/31/2000	pnewson replace SAssert with DNASSERT
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 * 07/09/2000	rodtoll	Added signature bytes 
 * 08/28/2000	masonb  Voice Merge: Change #if DEBUG to #ifdef DEBUG
 * 09/13/2000	rodtoll	Bug #44519 - Fix for fix.  
 * 10/24/2000	rodtoll	Bug #47645 - DPVOICE: Memory corruption - quality array end being overwritten
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MODULE_ID   INPUTQUEUE2

const int c_iHighestQualitySliderValue = 31;
const int c_iHighestRecentBiasSliderValue = 31;
const double c_dHighestPossibleQuality = 0.001;
const double c_dLowestPossibleQuality = 0.05;
const double c_dHighestPossibleAggr = 5000.0;
const double c_dLowestPossibleAggr = 120000.0;
const double c_dMaxDistanceFromOpt = 100.0;
const double c_dQualityTimeFactor = 1000.0; // in ms
const double c_dQualityFactor = 2.0;

const int c_iFinishedQueueLifetime = 2000; // in ms

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::CInputQueue2"
CInputQueue2::CInputQueue2( )
		: m_dwSignature(VSIG_INPUTQUEUE2)
		, m_fFirstDequeue(TRUE)
		, m_fFirstEnqueue(TRUE)
		, m_bCurMsgNum(0)
		, m_vdQualityRatings(0)
		, m_vdFactoredOptQuals(0)
		, m_bCurHighWaterMark(0)
		, m_bMaxHighWaterMark(0)
		, m_bInitHighWaterMark(0)
		, m_wQueueId(0)
		, m_dwTotalFrames(0)
		, m_dwTotalMessages(0)
		, m_dwTotalBadMessages(0)
		, m_dwDiscardedFrames(0)
		, m_dwDuplicateFrames(0)
		, m_dwLostFrames(0)
		, m_dwLateFrames(0)
		, m_dwOverflowFrames(0)
		, m_wMSPerFrame(0)
		, m_pFramePool(NULL)
{
}

HRESULT CInputQueue2::Initialize( PQUEUE_PARAMS pParams )
{
    m_fFirstDequeue = TRUE;
    m_fFirstEnqueue = TRUE;
    m_bCurMsgNum = 0;
    m_vdQualityRatings.resize(pParams->bMaxHighWaterMark);
    m_vdFactoredOptQuals.resize(pParams->bMaxHighWaterMark);
    m_bCurHighWaterMark = pParams->bInitHighWaterMark;
    m_bMaxHighWaterMark = pParams->bMaxHighWaterMark;
    m_bInitHighWaterMark = pParams->bInitHighWaterMark;
    m_wQueueId = pParams->wQueueId;
    m_dwTotalFrames = 0;
    m_dwTotalMessages = 0;
    m_dwTotalBadMessages = 0;
    m_dwDiscardedFrames = 0;
    m_dwDuplicateFrames = 0;
    m_dwLostFrames = 0;
    m_dwLateFrames = 0;
    m_dwOverflowFrames = 0;
    m_wMSPerFrame = pParams->wMSPerFrame;
    m_pFramePool = pParams->pFramePool;

	if (!DNInitializeCriticalSection(&m_csQueue))
	{
		return DVERR_OUTOFMEMORY;
	}

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() bInnerQueueSize: %i"), m_wQueueId, bInnerQueueSize);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() bMaxHighWaterMark: %i"), m_wQueueId, bMaxHighWaterMark);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() bInitHighWaterMark: %i"), m_wQueueId, bInitHighWaterMark);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() pFramePool: %p"), m_wQueueId, m_pFramePool);
	#endif

	//// TODO(pnewson, "use one inner queuepool for all queues")
	m_pInnerQueuePool = 
		new CInnerQueuePool(
			pParams->bInnerQueueSize,
			pParams->wFrameSize,
			m_pFramePool,
			&m_csQueue);

    if( m_pInnerQueuePool == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating innerqueue pool!" );
		DNDeleteCriticalSection(&m_csQueue);
        return DVERR_OUTOFMEMORY;
    }

	if (!m_pInnerQueuePool->Init())
	{
		delete m_pInnerQueuePool;
		DNDeleteCriticalSection(&m_csQueue);
		return DVERR_OUTOFMEMORY;
	}

	// see header for explanation
	// since this is the first time, init the
	// member variables, before we call the set
	// functions. Weird, but it makes the debug
	// messages cleaner. It doesn't acutally 
	// fix a real problem.
	#ifdef DEBUG
	m_iQuality = pParams->iQuality;
	m_iHops = pParams->iHops;
	m_iAggr = pParams->iAggr;
	#endif
	SetQuality(pParams->iQuality, pParams->iHops);
	SetAggr(pParams->iAggr);

	// set the queue to an empty state
	Reset();

    return DV_OK;
}

void CInputQueue2::GetStatistics( PQUEUE_STATISTICS pQueueStats ) const
{
    pQueueStats->dwTotalFrames = GetTotalFrames();
    pQueueStats->dwTotalMessages = GetTotalMessages();
    pQueueStats->dwTotalBadMessages = GetTotalBadMessages();
    pQueueStats->dwDiscardedFrames = GetDiscardedFrames();
    pQueueStats->dwDuplicateFrames = GetDuplicateFrames();
    pQueueStats->dwLostFrames = GetLostFrames();
    pQueueStats->dwLateFrames = GetLateFrames();
    pQueueStats->dwOverflowFrames = GetOverflowFrames();
}

void CInputQueue2::DeInitialize()
{
	// delete anything remaining in the inner queue list
	for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); ++iter)
	{
		delete *iter;
    }

	m_lpiqInnerQueues.clear();

	if( m_pInnerQueuePool )
	{
	    delete m_pInnerQueuePool;
	    m_pInnerQueuePool = NULL;	
	}

	DNDeleteCriticalSection(&m_csQueue);
}

// The destructor. Release all the resources we acquired in the
// constructor
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::~CInputQueue2"
CInputQueue2::~CInputQueue2()
{
    DeInitialize();
	m_dwSignature = VSIG_INPUTQUEUE2_FREE;
}

// This function clears all the input buffers and 
// resets the other class information to an initial
// state. The queue should not be in use when this 
// function is called. i.e. there should not be any
// locked frames.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Reset"
void CInputQueue2::Reset()
{
	// make sure no one is using the queue right now
	BFCSingleLock csl(&m_csQueue);
	csl.Lock();

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Reset()"), m_wQueueId);
	#endif

	// loop through and return all inner queues to the pool
	for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); ++iter)
	{
		m_pInnerQueuePool->Return(*iter);
    }

	// the next frame will be the first one we accept
	m_fFirstEnqueue = TRUE;

	// we have not yet received a dequeue request
	m_fFirstDequeue = TRUE;

	// we don't yet know the first message number, so just use zero
	m_bCurMsgNum = 0;

	// we should reset back to zero for the current high water mark
	m_bCurHighWaterMark = m_bInitHighWaterMark;

	// reset the track record on the various high water marks
	for (int i = 0; i < m_bMaxHighWaterMark; ++i)
	{
		m_vdQualityRatings[i] = m_vdFactoredOptQuals[i];
	}

	// reset all the other stats too
	m_dwDiscardedFrames = 0;
	m_dwDuplicateFrames = 0;
	m_dwLateFrames = 0;
	m_dwLostFrames = 0;
	m_dwOverflowFrames = 0;
	m_dwQueueErrors = 0;
	m_dwTotalBadMessages = 0;
	m_dwTotalFrames = 0;
	m_dwTotalMessages = 0;
}

// Call this function to add a frame to the queue.  I 
// considered returning a reference to a frame which 
// the caller could then stuff, but because the frames
// will not always arrive in order, that would mean I would have
// to copy the frame sometimes anyway.  So, for simplicity, the
// caller has allocated a frame, which it passes a reference
// to, and this function will copy that frame into the
// appropriate place in the queue, according to its
// sequence number.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Enqueue"
void CInputQueue2::Enqueue(const CFrame& fr)
{
	// start the critical section
	BFCSingleLock csl(&m_csQueue);
	csl.Lock();

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** ******************************************"), m_wQueueId);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() MsgNum[%i] SeqNum[%i]"), m_wQueueId, fr.GetMsgNum(), fr.GetSeqNum());
	#endif

	// Only add the frame if a dequeue has been
	// requested. This allows the producer and
	// consumer threads to sync up during their
	// startup, or after a reset.
	if (m_fFirstDequeue == TRUE)
	{
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() First Dequeue Not Yet Received - Frame Discarded"), m_wQueueId);
		#endif
		return;
	}

	// check to see if this is the first enqueue request
	// we've accepted.
	if (m_fFirstEnqueue == TRUE)
	{
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() First Enqueue"), m_wQueueId);
		#endif

		// clear the first frame flag
		m_fFirstEnqueue = FALSE;

		// Since this is the first frame we are accepting, 
		// we can just get a new inner queue without
		// worry that one already exists for this message.
		// Note that there should not be any queues already!
		DNASSERT(m_lpiqInnerQueues.size() == 0);
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() Creating Inner queue for MsgNum %i"), m_wQueueId, fr.GetMsgNum());
		#endif
		m_lpiqInnerQueues.push_back(m_pInnerQueuePool->Get(m_bCurHighWaterMark, m_wQueueId, fr.GetMsgNum()));

		// stuff the frame into the inner queue
		(*m_lpiqInnerQueues.begin())->Enqueue(fr);
	}
	else
	{
		// see if we already have a queue started for this message number
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() Checking for an inner queue to put this frame into"), m_wQueueId);
		#endif
		bool fDone = false;
		for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); ++iter)
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() found inner queue for msg number %i"), m_wQueueId, (*iter)->GetMsgNum());
			#endif
			if ((*iter)->GetMsgNum() == fr.GetMsgNum())
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() this is the one, queue size: %i"), m_wQueueId, (*iter)->GetSize());
				#endif
				// we have found the queue for this frame
				switch ((*iter)->GetState())
				{
				case CInnerQueue::empty:
					// we should not get here, since this state is
					// only valid for the first frame of a message,
					// which is added to the queue below, not in this
					// case statement.
					DNASSERT(false);
					break;

				case CInnerQueue::filling:
					// check to see if the queue was empty
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() inner queue in filling state"), m_wQueueId);
					#endif
					if ((*iter)->GetSize() == 0)
					{
						// the queue was empty. If we have been
						// trying to dequeue from it, we now know
						// that the message was not done, so those
						// dequeues were breaks in the speech.
						// update the stats accordingly
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() - converting possible zero length dequeues to known in MsgNum[%i]"), m_wQueueId, fr.GetMsgNum());
						#endif						
						(*iter)->AddToKnownZeroLengthDequeues(
							(*iter)->GetPossibleZeroLengthDequeues());
					}

					// NOTE: falling through!!!

				case CInnerQueue::ready:
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() inner queue in ready state (unless the previous message said filling)"), m_wQueueId);
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() calling InnerQueue->Enqueue MsgNum[%i]"), m_wQueueId, fr.GetMsgNum());
					#endif
					(*iter)->Enqueue(fr);
					break;

				case CInnerQueue::finished:
					// do nothing, just discard the frame
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() not calling InnerQueue->Enqueue - MsgNum[%i] in finished state, discarding frame"), m_wQueueId, fr.GetMsgNum());
					#endif
					break;
				}

				// done, get out.
				return;
			}
		}

		// If we get here, there is not already a queue active for this 
		// message number, so create one and stuff it with the frame and add
		// it to the list.
		
		//// TODO(pnewson, "Use the message number to insert the new inner queue in the right place")
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() Creating Inner queue for MsgNum %i"), m_wQueueId, fr.GetMsgNum());
		#endif		
		CInnerQueue* piq = m_pInnerQueuePool->Get(m_bCurHighWaterMark, m_wQueueId, fr.GetMsgNum());
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() calling InnerQueue->Enqueue MsgNum[%i]"), m_wQueueId, fr.GetMsgNum());
		#endif
		piq->Enqueue(fr);
		m_lpiqInnerQueues.push_back(piq);
	}
}

// This function retrieves the next frame from the head of
// the queue.  For speed, it does not copy the data out of the
// buffer, but instead returns a pointer to the actual
// frame from the queue.  When the caller is finished with 
// the CFrame object, it should call Return() on it. This will
// return the frame to the frame pool, and update the queue's
// internal pointers to show that the queue slot is now free. 
// If the caller doesn't call Return() in time, when the queue
// attempts to reuse the slot, it will DNASSERT(). The caller
// should always Return frame before it attempts to dequeue 
// another one.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Dequeue"
CFrame* CInputQueue2::Dequeue()
{
	// start the critical section
	BFCSingleLock csl(&m_csQueue);
	csl.Lock();

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** ******************************************"), m_wQueueId);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue()"), m_wQueueId);
	#endif
	
	CFrame* pfrReturn = 0;

	if (m_fFirstDequeue == TRUE)
	{
		#if defined(DPVOICE_QUEUE_DEBUG)
        DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() First Dequeue"), m_wQueueId);
		#endif
		
		// trigger the interlock, so we're free to start enqueueing
		m_fFirstDequeue = FALSE;

		// since we're not allowed to enqueue until after the
		// first dequeue, there will be no inner queues. 
		// So return a silent frame
		pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
	    pfrReturn->SetIsSilence(TRUE);
		pfrReturn->SetIsLost(false);
		return pfrReturn;
	}
	else
	{
		pfrReturn = 0;
		int iDeadTime;
		// cycle through the list of active inner queues
		std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin();
		while (iter != m_lpiqInnerQueues.end())
		{
			std::list<CInnerQueue*>::iterator cur = iter;
			std::list<CInnerQueue*>::iterator next = ++iter;
			switch ((*cur)->GetState())
			{
			case CInnerQueue::finished:
				// We keep these old, dead inner queues around for a while
				// so that any late straggling frames that were part of this
				// message get discarded. We know when to kill them off for 
				// good because we keep incrementing the possible zero length
				// dequeue count. If this finished queue is stale enough,
				// return it to the pool.
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() current queue in finished state"), m_wQueueId);
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() PossibleZeroLengthDequeues: %i"), m_wQueueId, (*cur)->GetPossibleZeroLengthDequeues());
				#endif
				(*cur)->IncPossibleZeroLengthDequeues();
				iDeadTime = (*cur)->GetPossibleZeroLengthDequeues() * m_wMSPerFrame;
				if (iDeadTime > c_iFinishedQueueLifetime)
				{
					// this queue has been dead long enough, kill it off
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP, DVF_INFOLEVEL, "***** RETURNING INNER QUEUE TO POOL *****");
					#endif
					m_pInnerQueuePool->Return(*cur);
					m_lpiqInnerQueues.erase(cur);
				}
				break;

			case CInnerQueue::filling:
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() current queue in filling state"), m_wQueueId);
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() queue size: %i"), m_wQueueId, (*cur)->GetSize());
				#endif
				if ((*cur)->GetSize() > 0)
				{
					// If there is a message after this one, then release this
					// message for playback.
					// OR
					// If we have been spinning trying to release this message
					// for a while, then just let it go... The message may be
					// too short to trip the high water mark.
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() filling dequeue reqs: %i"), m_wQueueId, (*cur)->GetFillingDequeueReqs());
					#endif
					if (next != m_lpiqInnerQueues.end()
						|| (*cur)->GetFillingDequeueReqs() > (*cur)->GetHighWaterMark())
					{
						// set the state to ready, and dequeue
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() setting state to ready and dequeing"), m_wQueueId);
						#endif						
						(*cur)->SetState(CInnerQueue::ready);
						return (*cur)->Dequeue();
					}
				}
				else
				{
					// there is nothing in this queue
					// check to see if another message has begun to arrive
					if (next != m_lpiqInnerQueues.end())
					{
						// there is another message coming in after this
						// one, so flip this queue to the finished state
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() new message arriving, setting state to finished"), m_wQueueId);
						#endif
						(*cur)->SetState(CInnerQueue::finished);

						// harvest the stats from this message, now that it
						// is done
						HarvestStats(*cur);
						
						// Go to the next iteration of this loop, which will
						// either dequeue a frame from the next message, or 
						// return an empty frame
						break;
					}
				}

				// if we get here, there is something in this queue, but we are 
				// not yet ready to release it yet.
				// we should return an extra frame and remember
				// that we've been here...
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() not ready to release message, returning empty frame"), m_wQueueId);
				#endif				
				(*cur)->IncFillingDequeueReqs();
				pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
				pfrReturn->SetIsSilence(TRUE);
				pfrReturn->SetIsLost(false);
				return pfrReturn;

			case CInnerQueue::ready:
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() Queue Size: %i"), m_wQueueId, (*cur)->GetSize());
				#endif
				// check to see if this ready queue is empty
				if ((*cur)->GetSize() == 0)
				{
					// increment the possible zero length dequeue count
					(*cur)->IncPossibleZeroLengthDequeues();

					// check to see if another message has begun to arrive
					if (next != m_lpiqInnerQueues.end())
					{
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() queue is empty, new message arriving, setting state to finished"), m_wQueueId);
						#endif
						
						// there is another message coming in after this
						// one, so flip this queue to the finished state
						(*cur)->SetState(CInnerQueue::finished);

						// harvest the stats from this message, now that it
						// is done
						HarvestStats(*cur);

						// Go to the next iteration of this loop, which will
						// either dequeue a frame from the next message, or 
						// return an empty frame
						break;
					}

					// there is nothing in this queue, and there are no more 
					// messages arriving after this one, so boot this inner 
					// queue into the filling state so if this is just a long
					// pause in the message, it will fill to the high water mark
					// again before it begins to play again.
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() queue is empty, setting state to filling, returning empty frame"), m_wQueueId);
					#endif
					(*cur)->SetState(CInnerQueue::filling);

					// return an extra frame
					pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
					pfrReturn->SetIsSilence(TRUE);
					pfrReturn->SetIsLost(false);
					return pfrReturn;
				}
				else
				{
					// there's something to return, so do it
					return (*cur)->Dequeue();
				}
			}
		}

		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() nothing available in inner queues, returning empty frame"), m_wQueueId);
		#endif
		// if we get here, there was nothing suitable in the queues
		// (if there were any queues) so return an extra frame
		pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
		pfrReturn->SetIsSilence(TRUE);
		pfrReturn->SetIsLost(false);
		return pfrReturn;
	}
}
		
// This function should be called each time a queue is moved to the finished
// state. That's when we have officially declared that the message is finished,
// so it's a good time to see how we handled it. This will also reset the 
// stats so the next message starts fresh.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::HarvestStats"
void CInputQueue2::HarvestStats(CInnerQueue* piq)
{
	m_dwDuplicateFrames += piq->GetDuplicateFrames();

	// now that the message is actually complete, we're in a better
	// position to decide accurately how many frames were late
	// vs. how many were actually lost. When something isn't
	// there when it's needed, we increment the missing frames
	// count. If it subsequently arrives, it's counted as late.
	// Therefore the true count of lost frames is the difference
	// between the missing and late counts. Ditto if a frame,
	// overflows. We discard it so it's not there when we need it,
	// it will then get reported as missing. So subtract that too.
	m_dwLostFrames += piq->GetMissingFrames() 
		- piq->GetLateFrames() - piq->GetOverflowFrames();

	m_dwLateFrames += piq->GetLateFrames();
	m_dwOverflowFrames += piq->GetOverflowFrames();

	// What to do with the zero length dequeue stat? From a 
	// certain point of view, only one frame was late. From
	// another point of view, all the subsequent frames were
	// late. Hmmm.... Lets take the middle road and say that
	// for each failed zero length dequeue we'll count it as
	// equivalent to a late frame
	m_dwLateFrames += piq->GetKnownZeroLengthDequeues();

	m_dwTotalFrames += piq->GetMsgLen();

	m_dwTotalMessages++;

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::HarvestStats() DuplicateFrames:%i; MissingFrames:%i; LateFrames:%i; OverflowFrames:%i; KnownZeroLengthDequeues:%i; MsgLen:%i;"),
		m_wQueueId, piq->GetDuplicateFrames(), piq->GetMissingFrames(), piq->GetLateFrames(), piq->GetOverflowFrames(), piq->GetKnownZeroLengthDequeues(), piq->GetMsgLen());
	#endif		

	// Build a carefully formatted debug string that will give me some data,
	// but not give away all of our wonderful queue secrets.

	// dump the string to the debug log
	// Note!!! If you change the format of this debug string,
	// please roll the version number, i.e. HVT1A -> HVT2A so
	// we can decode any logs!
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("HVT1A:%i:%i:%i:%i:%i:%i"),
		m_wQueueId, 
		m_bCurHighWaterMark,
		(int)(m_vdQualityRatings[m_bCurHighWaterMark] * 10000),
		piq->GetMsgLen(), 
		piq->GetKnownZeroLengthDequeues() + piq->GetLateFrames(), 
		piq->GetMissingFrames());

	// The idea:
	// The quality quotient is a number between 0 and 1 that indicates
	// the quality of the current connection. 0 means perfect - no bad
	// stuff, ever. 1 means awful -  100% bad stuff. The number
	// is really a weighted average of the number of good frames vs the number
	// of bad frames, biased towards the recent frames. The message
	// we just received makes up 'm_wFrameStrength * m_wMsgLen' percent of the 
	// total value. The past history is deweighted by (1 - m_wFrameStrength*m_wMsgLen)
	// so the significance of a message decays as time goes by 
	// and according to the size of the message (number of frames).
	//
	// Another idea:
	// Keep a vector that tracks how good the quality is at each
	// high water mark.
	// That way, when we want to make a jump up or down in the
	// water mark, we can consider it carefully first. This 
	// gives the adaptive algorithm some memory of what life
	// was like at each queue level.
	// We choose an optimum level, like .02, that we are 
	// shooting for. We keep searching the space of high water 
	// marks until we find the one that's closest to the 
	// optimum. This optimum is configurable.
	//
	// The initial quality of each of the high water marks
	// is set to the optimum. This quality will then
	// vary as that high water mark gains experience.
	// If it dips below a certain threshold, then 
	// we'll jump to the next level up. If that one
	// is too good, it will go above a threshold, at
	// which point we can consider going back down.
	//
	// The problem with this is the sudden things that games
	// dish out (like when Q2 starts up) when they don't
	// lets us have the CPU for a while. These could 
	// unduly punish a particular high water mark,
	// there's really not much we can do about it. 
	// Oh, well. We'll give it a shot.

	// Adjust the quality rating of this watermark.
	// The algorithm is requires the results from the last
	// message, contained in the inner queue, along with the
	// current quality rating.
	DNASSERT( m_bCurHighWaterMark < m_bMaxHighWaterMark );
	m_vdQualityRatings[m_bCurHighWaterMark] = 
		AdjustQuality(piq, m_vdQualityRatings[m_bCurHighWaterMark]);

	// see if this put us above the highest acceptable quality rating
	// we asserted that m_dOptimumQuality != 0.0 in SetQuality, so we
	// don't need to check for division by zero
	if (m_vdQualityRatings[m_bCurHighWaterMark] / m_vdFactoredOptQuals[m_bCurHighWaterMark] > m_dQualityThreshold)
	{
		// Check to see which is closer
		// the the optimum quality - the current high water
		// mark or the one above it. Only do this test if
		// we're not already at the maximum high water mark
		if (m_bCurHighWaterMark < (m_bMaxHighWaterMark-1) )
		{
			// To check the "distance" from the optimum, use the 
			// inverse of the qualities. That normalizes it to 
			// our perception of quality

			// calculate how far the current high water mark
			// is from optimum
			double dCurDistFromOpt = m_vdQualityRatings[m_bCurHighWaterMark] / m_vdFactoredOptQuals[m_bCurHighWaterMark];
			if (dCurDistFromOpt < 1)
			{
				// quality ratings can never go to zero (enforced in 
				// AdjustQuality() so this division will never by by zero
				dCurDistFromOpt = 1.0 / dCurDistFromOpt;
			}

			// calculate how far the next high water mark is from
			// optimum
			//
			// quality ratings can never go to zero (enforced in 
			// AdjustQuality() so this division will never by by zero
			double dNextDistFromOpt = m_vdFactoredOptQuals[m_bCurHighWaterMark + 1] / m_vdQualityRatings[m_bCurHighWaterMark + 1];
			if (dNextDistFromOpt < 1)
			{
				dNextDistFromOpt = 1.0 / dNextDistFromOpt;
			}

			// if the next high water mark is closer to the 
			// optimum than this one, switch to it.
			if (dNextDistFromOpt < dCurDistFromOpt)
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::HarvestStats() Raising High Water Mark to %i"), m_wQueueId, m_bCurHighWaterMark + 1); 
				#endif
				SetNewHighWaterMark(m_bCurHighWaterMark + 1);
			}
		}
	}

	// see if this put us below the low threshold
	//
	// quality ratings can never go to zero (enforced in 
	// AdjustQuality() so this division will never by by zero
	if (m_vdFactoredOptQuals[m_bCurHighWaterMark] / m_vdQualityRatings[m_bCurHighWaterMark] > m_dQualityThreshold)
	{
		// The quality has moved below the high quality threshold
		// Check to see what is closer to the optimum quality -
		// the current high water mark or the one below this one.
		// Only do this test if we're not already at a zero
		// high water mark.
		if (m_bCurHighWaterMark > 0)
		{
			// To check the "distance" from the optimum, use the 
			// inverse of the qualities. That normalizes it to 
			// our perception of quality

			// calculate how far the current high water mark
			// is from optimum
			double dCurDistFromOpt = m_vdQualityRatings[m_bCurHighWaterMark] / m_vdFactoredOptQuals[m_bCurHighWaterMark];
			if (dCurDistFromOpt < 1)
			{
				dCurDistFromOpt = 1.0 / dCurDistFromOpt;
			}

			// calculate how far the previous (lower) high water mark is from
			// optimum
			double dPrevDistFromOpt = m_vdFactoredOptQuals[m_bCurHighWaterMark - 1] / m_vdQualityRatings[m_bCurHighWaterMark - 1];
			if (dPrevDistFromOpt < 1)
			{
				dPrevDistFromOpt = 1.0 / dPrevDistFromOpt;
			}

			// if the prev high water mark is closer to the 
			// optimum than this one, switch to it.
			if (dPrevDistFromOpt < dCurDistFromOpt)
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::HarvestStats() Lowering High Water Mark to %i"), m_wQueueId, m_bCurHighWaterMark - 1); 
				#endif
				SetNewHighWaterMark(m_bCurHighWaterMark - 1);
			}
		}
	}

	// clear the stats on the inner queue
	piq->ResetStats();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::AdjustQuality"
double CInputQueue2::AdjustQuality(const CInnerQueue* piq, double dCurrentQuality) const
{
	// if the message is zero length, no adjustment is made
	// to the queue...
	if (piq->GetMsgLen() == 0)
	{
		return dCurrentQuality;
	}

	// The longer a message, the stronger its effect on the
	// current quality rating.
	double dWeighting = min(piq->GetMsgLen() * m_dFrameStrength, 1.0);

	// The message quality is the quotient of bad
	// stuff that happened (zero length dequeues
	// and late frames) to the total number of 
	// frames in the message. Note that we do not
	// count lost frames against the message since
	// moving to a higher water mark wouldn't help.
	// Note that we impose a "worst case" of 1.0
	double dMsgQuality = min(((double)(piq->GetKnownZeroLengthDequeues() + piq->GetLateFrames()) / (double)piq->GetMsgLen()), 1.0);

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::AdjustQuality() dWeighting: %g; dMsgQuality: %g; dCurrentQuality %g;"), 
		m_wQueueId, dWeighting, dMsgQuality, dCurrentQuality); 
	#endif

	// The new quality rating is a combination of the
	// current quality rating, and the quality of the 
	// most recent message, weighted by the message length.
	double dNewQuality = (dCurrentQuality * (1.0 - dWeighting)) + (dMsgQuality * dWeighting);

	// We don't want to allow extremes of quality, or else they will set up 
	// barriers in the queue statistics that can never be overcome (especially
	// a "perfect" quality of zero). So we check here to make sure that the
	// new quality is within reason.
	double dCurDistFromOpt = dNewQuality / m_dOptimumQuality;
	if (dCurDistFromOpt < 1.0 / c_dMaxDistanceFromOpt)
	{
		dNewQuality = m_dOptimumQuality / c_dMaxDistanceFromOpt;
	}
	else if (dCurDistFromOpt > c_dMaxDistanceFromOpt)
	{
		dNewQuality = m_dOptimumQuality * c_dMaxDistanceFromOpt;
	}
	return dNewQuality;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::SetNewHighWaterMark"
void CInputQueue2::SetNewHighWaterMark(BYTE bNewHighWaterMark)
{
	DNASSERT( bNewHighWaterMark < m_bMaxHighWaterMark );

	if( bNewHighWaterMark >= m_bMaxHighWaterMark )
	{
		DNASSERT( FALSE );
		return;
	}
		
	m_bCurHighWaterMark = bNewHighWaterMark;

	for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); iter++)
	{
		(*iter)->SetHighWaterMark(bNewHighWaterMark);
	}

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::SetQuality"
void CInputQueue2::SetQuality(int iQuality, int iHops)
{
	m_iQuality = iQuality;
	m_iHops = iHops;
	double dQualityRatio = c_dHighestPossibleQuality / c_dLowestPossibleQuality;
	double dInputRatio = (double) iQuality / (double) c_iHighestQualitySliderValue;
	m_dOptimumQuality = pow(dQualityRatio, dInputRatio) * c_dLowestPossibleQuality;
	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::SetQuality(%i, %i): m_dOptimumQuality: %f" ), m_wQueueId, iQuality, iHops, m_dOptimumQuality);
	#endif

	// The quality that the user has requested should be considered
	// over the number of hops involved. At the end of each hop is
	// a queue who's watermark will be set according to this rating,
	// To get an end to end quality that reflects the user's choice,
	// this queue's quality rating must be better if it is not the
	// only queue in the path. The total number of on time packets is
	// the product (as in multiple) of on time packets for each hop.
	// Therefore we need to take the Nth root of 1-m_dOptimumQuality
	// where N is the number of hops, and subtract that value from 1
	// to get the appropriate quality rating for this queue. (get that?)
	if (m_iHops > 1)
	{
		m_dOptimumQuality = (1 - pow((1.0 - m_dOptimumQuality), 1.0 / (double)m_iHops));
	}

	// the optimum quality should never be zero, or completely perfect,
	// or the algorithm will not work.
	DNASSERT(m_dOptimumQuality != 0.0);

	// update the vector of factored qualities
	// We don't just use the raw optimum as provided by the
	// caller. We "factor" it such that as the high watermark
	// gets larger (and the latency therefore longer) we are
	// willing to accept a lower quality.
	for (int i = 0; i < m_bMaxHighWaterMark; ++i)
	{
		m_vdFactoredOptQuals[i] = m_dOptimumQuality *
			pow(c_dQualityFactor, (double)(i * m_wMSPerFrame) / c_dQualityTimeFactor);
	}

	// Build a carefully formatted debug string that will give me some data,
	// but not give away all of our wonderful queue secrets.

	// dump the string to the debug log
	// Note!!! If you change the format of this debug string,
	// please roll the version number, i.e. HVT1B -> HVT2B so
	// we can decode any logs!
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("HVT1B:%i:%i:%i:%i"), m_wQueueId, m_iQuality, m_iHops, m_iAggr);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::SetAggr"
void CInputQueue2::SetAggr(int iAggr)
{
	m_iAggr = iAggr;
	double dAggrRatio = c_dHighestPossibleAggr / c_dLowestPossibleAggr;
	double dInputRatio = (double) iAggr / (double) c_iHighestQualitySliderValue;
	double dAggr = pow(dAggrRatio, dInputRatio) * c_dLowestPossibleAggr;

	// The aggressiveness is the number of milliseconds of "memory" the queue
	// has for each watermark. To find the frame strength, divide the 
	// number of milliseconds per frame by the "memory".
	m_dFrameStrength = (double)m_wMSPerFrame / dAggr;
		
	// We are using a fixed 1% threshold now - the aggressiveness is now set
	// through the frame strength. This low threshold will make the queue
	// adapt very quickly at first, while it is learning something about
	// the various watermarks, but will settle down more after that.
	m_dQualityThreshold = 1.01;

	#if defined (DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::SetAggr(%i): dAggr: %f, m_dFrameStrength: %f, m_dQualityThreshold %f"), m_wQueueId, m_iAggr, dAggr, m_dFrameStrength, m_dQualityThreshold);
	#endif

	// Build a carefully formatted debug string that will give me some data,
	// but not give away all of our wonderful queue secrets.

	// dump the string to the debug log
	// Note!!! If you change the format of this debug string,
	// please roll the version number, i.e. HVT1C -> HVT2C so
	// we can decode any logs!
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("HVT1C:%i:%i:%i:%i"), m_wQueueId, m_iQuality, m_iHops, m_iAggr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\inqueue2.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		inqueue2.h
 *  Content:	Definition of the CInputQueue2 class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method 
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 01/31/2000	pnewson replace SAssert with DNASSERT
 * 03/26/2000   rodtoll Modified queue to be more FPM friendly
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 *  07/09/2000	rodtoll	Added signature bytes 
 *
 ***************************************************************************/

#ifndef _INPUTQUEUE2_H_
#define _INPUTQUEUE2_H_

class CFrame;
class CFramePool;
class CInnerQueue;
class CInnerQueuePool;

typedef struct _QUEUE_PARAMS
{
    WORD wFrameSize;
	BYTE bInnerQueueSize;
	BYTE bMaxHighWaterMark;
	int iQuality;
	int iHops;
	int iAggr;
	BYTE bInitHighWaterMark;
	WORD wQueueId;
	WORD wMSPerFrame;
	CFramePool* pFramePool;
} QUEUE_PARAMS, *PQUEUE_PARAMS;

typedef struct _QUEUE_STATISTICS
{
    DWORD dwTotalFrames;
    DWORD dwTotalMessages;
    DWORD dwTotalBadMessages;
    DWORD dwDiscardedFrames;
    DWORD dwDuplicateFrames;
    DWORD dwLostFrames;
    DWORD dwLateFrames;
    DWORD dwOverflowFrames;
} QUEUE_STATISTICS, *PQUEUE_STATISTICS;

// This class manages a queue of frames. It is designed
// to allow a client class to remove frames from the queue
// at regular intervals, and to hide any out of order
// frame reception, or dropped frames from the caller.
// If for whatever reason there is no frame available
// to give a client, this class will still provide a
// frame marked as silent.  This allows the client to
// simply call the dequeue function once per period, and
// consume the data at the agreed rate.  So for example,
// the client to this class could be a thread which
// is consuming input data and passing it to DirectSound
// for playback. It can simply get a frame every 1/10 of
// a second (or however long a frame is), and play it.
//
// This is the second generation of input queue. It 
// manages a set of inner queues, each of which is used
// for a "message". The stream of speech is divided into
// a series of messages, using silence as the divider.
// This class will not function well if the audio stream
// is not divided into separate messages.
//
#define VSIG_INPUTQUEUE2		'QNIV'
#define VSIG_INPUTQUEUE2_FREE	'QNI_'
//
volatile class CInputQueue2
{
private:
	DWORD m_dwSignature; // Debug signature

	// A list of pointers to InnerQueue objects. This is where
	// the frames get stored. InnerQueues are retrieved from
	// a pool of InnerQueues and added to this list as new 
	// messages arrive. When a message is finished, the InnerQueue
	// is removed from this list and returned to the pool.
	std::list<CInnerQueue*> m_lpiqInnerQueues;

	// The queue will not enqueue any input frames until at least
	// one dequeue has been requested. This will function as an interlock
	// to ensure that the queue does not fill with data until the
	// consumer thread is ready to take it.
	BOOL m_fFirstDequeue;

	// This flag remembers if it's the first time a frame
	// has been accepted for enqueue. We need this so we
	// know what the first message number is.
	BOOL m_fFirstEnqueue;

	// The message number currently at the head of the queue
	BYTE m_bCurMsgNum;

	// A critical section used to exclude the enqueue, dequeue and reset
	// functions from one another. Also passed to the frame class so 
	// Return calls can be synchronized. These two classes need to share
	// a critical section because the CFramePool class updates the
	// CFrame pointers in the inner queues when a frame is returned to 
	// the frame pool.
	DNCRITICAL_SECTION m_csQueue;

	// a vector of the quality ratings of each high water mark
	std::vector<double> m_vdQualityRatings;

	// A vector that contains the factored optimum quality for
	// each high water mark. As the high water mark gets larger
	// we become more tolerant of lost packets. While you may 
	// want to have a 0.5% late packet rate at 0.1 or 0.2 second
	// long queues, you probably don't want to strive for that
	// when the queue size reaches 2 seconds!
	std::vector<double> m_vdFactoredOptQuals;

	// the quality parameters

	// Quality is measured by a floating point number.
	// This number represents the ratio of "bad stuff" that occurs
	// relative to the amount of "stuff" going on.
	//
	// In intuitive terms, if one of the last 100 frames was bad
	// (bad meaning late) the quality rating would be 0.01. (Note
	// that we don't count lost frames against the queue, since
	// increasing the queue size won't do anything to help lost
	// frames.)
	//
	// However, the measurement isn't quite that simple, because we 
	// bias it towards the more recent frames. That's what the frame
	// strength parameter is for. It represents the "weight" given to
	// the most recent frames. A frame strength of 0.01 would mean that 
	// the most recent frame counts for 1% of the quality of the queue,
	// either good or bad.
	//
	// Note that when we want to compare the "distance" between two
	// quality ratings, we'll use the inverse of the value, not the value
	// itself. That should match our perception of quality a bit
	// more (kind of like our hearing).
	// 
	// For example, the perceived difference in quality between 0.01 
	// and 0.02 is about 2 - twice as many errors occur on 0.02 than
	// 0.01 so the "distance" between 0.01 and 0.02 should be calculated
	// like 0.02/0.01 = 2. And the distance between 0.02 and 0.04 should
	// be calculated like 0.04/0.02 = 2. So the 'point' 0.04 is the same
	// 'distance' from 0.02 as the 'point' 0.01.
	//
	// Note the wording is weird - bad (low) quality has a higher numerical 
	// value, oh well
	//
	// The threshold value is the distance the quality value must wander
	// from the optimum in order to warrant considering a change of
	// high water mark. For example, a value of 2 would mean that 
	// for an optimum value of 0.02, the value would have to wander to
	// 0.01 or 0.04 before we'd consider a change. This is currently set
	// very low so the algorithm will quickly hunt out the best watermarks.
	double m_dOptimumQuality;
	double m_dQualityThreshold;
	double m_dFrameStrength;

	// the number of milliseconds in a frame. This is used to normalize
	// the frame strength to time, so a particular input aggressiveness
	// will provide the same results regardless of the current frame size.
	WORD m_wMSPerFrame;

	// We are interfacing to the outside world via 
	// two parameters, Quality and Aggressiveness.
	// these members are integers in the range
	// defined by the constants above, and are used
	// to set the double values above appropriately.
	// We need to provide the hop count for reasons 
	// discussed in the SetQuality() function.
	int m_iQuality;
	int m_iHops;
	int m_iAggr;

	// the current high water mark
	BYTE m_bCurHighWaterMark;

	// the cap on the high water mark
	BYTE m_bMaxHighWaterMark;

	// the initial high water mark on a new or reset queue
	BYTE m_bInitHighWaterMark;

	// Some statistics to track.
	DWORD m_dwTotalFrames;
	DWORD m_dwTotalMessages;
	DWORD m_dwTotalBadMessages;
	DWORD m_dwDiscardedFrames;
	DWORD m_dwDuplicateFrames;
	DWORD m_dwLostFrames;
	DWORD m_dwLateFrames;
	DWORD m_dwOverflowFrames;
	DWORD m_dwQueueErrors;

	// An abritrary queue ID, provided to the constructor, 
	// used to identify which queue an instrumentation message
	// is coming from. It serves no other purpose, and can be
	// ignored except for debug purposes.
	WORD m_wQueueId;

	// the frame pool to manage the frames so we don't have to
	// allocate a huge number of them when only a few are 
	// actually in use.
	CFramePool* m_pFramePool;

	// the inner queue pool to manage innner queues. Same idea
	// as the frame pool
	CInnerQueuePool* m_pInnerQueuePool;

public:

	// The constructor. 
	CInputQueue2();
    
    HRESULT Initialize( PQUEUE_PARAMS pQueueParams );
    void DeInitialize();

    void GetStatistics( PQUEUE_STATISTICS pStats ) const;

	// The destructor. Release all the resources we acquired in the
	// constructor
	~CInputQueue2();

	// This function clears all buffers and resets the other class 
	// information to an initial state. DO NOT CALL THIS FUNCTION
	// IF THE QUEUE IS IN USE! i.e. do not call it if you have
	// not called Return() on every frame that you have
	// taken from this queue.
	void Reset();

	// Call this function to add a frame to the queue.  I 
	// considered returning a reference to a frame which 
	// the caller could then stuff, but because the frames
	// will not always arrive in order, that would mean I would have
	// to copy the frame sometimes anyway.  So, for simplicity, the
	// caller has allocated a frame, which it passes a reference
	// to, and this function will copy that frame into the
	// appropriate place in the queue, according to its
	// message number and sequence number.
	void Enqueue(const CFrame& fr);

	// This function retrieves the next frame from the head of
	// the queue. For speed, it does not copy the data out of the
	// buffer, but instead returns a pointer to the actual
	// frame from the queue. Of course, there is the danger
	// that the CInputQueue2 object which returns a reference to the
	// frame may try to reuse that frame before the caller is 
	// finished with it. The CFrame's lock and unlock member functions
	// are used to ensure this does not happen.  When the caller
	// is finished with the CFrame object, it should call vUnlock()
	// on it. If the caller doesn't unlock the frame, bad things
	// will happen when the input queue tries lock it again when 
	// it wants to reuse that frame. In any case, the caller
	// should always unlock the returned frame before it attempts
	// to dequeue another frame.
	CFrame* Dequeue();

	// get and set the quality parameters
	int GetQuality() const { return m_iQuality; }
	void SetQuality(int iQuality, int iHops = 1);
	int GetAggr() const { return m_iAggr; }
	void SetAggr(int iAggr);

	// get and set the default high watermark
	BYTE GetInitHighWaterMark() const { return m_bInitHighWaterMark; }
	void SetInitHighWaterMark(BYTE bInitHighWaterMark) { m_bInitHighWaterMark = bInitHighWaterMark; }

	// get stats
	DWORD GetDiscardedFrames() const { return m_dwDiscardedFrames; }
	DWORD GetDuplicateFrames() const { return m_dwDuplicateFrames; }
	DWORD GetLateFrames() const { return m_dwLateFrames; }
	DWORD GetLostFrames() const { return m_dwLostFrames; }
	DWORD GetOverflowFrames() const { return m_dwOverflowFrames; }
	DWORD GetQueueErrors() const { return m_dwQueueErrors; }
	DWORD GetTotalBadMessages() const { return m_dwTotalBadMessages; }
	DWORD GetTotalFrames() const { return m_dwTotalFrames; }
	DWORD GetTotalMessages() const { return m_dwTotalMessages; }
	BYTE GetHighWaterMark() const { return m_bCurHighWaterMark; }

private:
	// a function to collect the stats from an input queue after a 
	// message is complete, and perform the queue adaptation
	void HarvestStats(CInnerQueue* piq);

	// a function which looks at a finished inner queue and decides
	// if the message was 'good' or 'bad'.
	double AdjustQuality(const CInnerQueue* piq, double dCurQuality) const;

	// set a new high water mark
	void SetNewHighWaterMark(BYTE bNewHighWaterMark);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\innerque.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		innerque.h
 *  Content:	declaration of the CInnerQueue class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 10/28/99		pnewson Bug #113933 debug spew too verbose
 *						implement inner queue pool code
 *
 ***************************************************************************/

#ifndef _INNERQUEUE_H_
#define _INNERQUEUE_H_

// The inner queue class is used to queue up a single voice message.
// A 'message' in this context means a series of frames that have the
// same message number and are part of the same stream of speech.

// an enum to specify the allowed states of the frame slots
// I appear to have to declare this out here, instead of inside
// the class, otherwise the vector declaration gets confused.
enum ESlotState
{
	essEmpty = 1,
	essFull,
};

volatile class CInnerQueue
{
public:
	// The constructor. bNumSlots must be at least 8, and must be
	// a power of 2.
	CInnerQueue(BYTE bNumSlots, 
		WORD wFrameSize, 
		CFramePool* pfpFramePool,
		DNCRITICAL_SECTION* pcsQueue,
		BYTE bMsgNum,
		BYTE bHighWaterMark = 0,
		WORD wQueueId = 0);
		
	HRESULT Init();

	// The destructor
	~CInnerQueue();
	
	// An enum used to describe the possible queue states.
	enum EState
	{
		empty = 1,	// The queue is currently empty, awaiting the first frame
					// Enqueue allowed, Dequeue not allowed.
		filling,	// The queue is currently filling to the high water mark
					// Enqueue allowed. Dequeue not allowed.
		ready,		// The queue has filled to the high water mark
					// Enqueue allowed, Dequeue allowed
		finished	// The queue has emptied. No new frames accepted
					// Enqueue not allowed, Dequeue not allowed.
	};

	// Get the current state of the queue.
	EState GetState() const { return m_eState; }

	// Set the current state of the queue.
	void SetState(EState eState) { m_eState = eState; }

	// Get the current size of the queue
	BYTE GetSize() const { return m_bQueueSize; }

	// Get the current high water mark
	BYTE GetHighWaterMark() const { return m_bHighWaterMark; }

	// Set the current high water mark
	void SetHighWaterMark(BYTE bHighWaterMark);

	// Get, set, and increment the filling dequeue count
	BYTE GetFillingDequeueReqs() const { return m_bFillingDequeueReqs; }
	void SetFillingDequeueReqs(BYTE bFillingDequeueReqs) { m_bFillingDequeueReqs = bFillingDequeueReqs; }
	void IncFillingDequeueReqs() { m_bFillingDequeueReqs++; }

	// Get the stats for the current message
	WORD GetMissingFrames() const { return m_wMissingFrames; }
	WORD GetDuplicateFrames() const { return m_wDuplicateFrames; }
	WORD GetOverflowFrames() const { return m_wOverflowFrames; }
	WORD GetLateFrames() const { return m_wLateFrames; }
	DWORD GetMsgLen() const { return m_dwMsgLen; }

	// More stats stuff
	void AddToKnownZeroLengthDequeues(WORD w) { m_wKnownZeroLengthDequeues += w; }
	WORD GetKnownZeroLengthDequeues() const { return m_wKnownZeroLengthDequeues; }
	void IncPossibleZeroLengthDequeues() { m_wPossibleZeroLengthDequeues++; } 
	void SetPossibleZeroLengthDequeues(WORD w) { m_wPossibleZeroLengthDequeues = w; }
	WORD GetPossibleZeroLengthDequeues() const { return m_wPossibleZeroLengthDequeues; }
	
	// Add a frame to the Queue
	void Enqueue(const CFrame& frFrame);

	// Get a frame from the Queue
	CFrame* Dequeue();

	// reset the queue to its initial empty state
	void Reset();

	// reset all the class' stats
	void ResetStats();

	// get the message number this queue holds
	BYTE GetMsgNum() const { return m_bMsgNum; }
	void SetMsgNum(BYTE bMsgNum) { m_bMsgNum = bMsgNum; }
	void SetQueueId(WORD wQueueId) { m_wQueueId = wQueueId; }

private:
	// Has the init function completed successfully?
	BOOL m_fInited;

	// The current state of the inner queue.
	EState m_eState;

	// The number of frame slots in the queue. must be a power
	// of two, or else things will get bad if the sequence number
	// rolls over.
	BYTE m_bNumSlots;

	// The number of frames required before the queue moves from
	// 'filling' to 'ready' state.
	BYTE m_bHighWaterMark;

	// The current 'size' of the queue. The size of the queue is
	// considered to be the number of filled slots, which may not
	// be the same as the distance between the first filled slot
	// and the last filled slot.
	BYTE m_bQueueSize;

	// The sequence number of the frame at the head of the queue.
	BYTE m_bHeadSeqNum;

	// A flag to track the first dequeue action.
	bool m_fFirstDequeue;

	// an array of slot states
	//ESlotState* m_rgeSlotStates;

	// An array of pointers to frames. This has to be pointers
	// to frames, because CFrame has no default constructor.
	CFrame** m_rgpfrSlots;

	// This is a little stat that will help us to detect
	// when a short message is getting hung up in a queue
	// because it's not long enough to trigger the high
	// water mark. It counts the number of times an outer dequeue
	// operation has been declined because this inner queue
	// is in the filling state. This gets reset to 0 when the
	// high water mark is hit
	BYTE m_bFillingDequeueReqs;

	// These vars keep stats on the current message, presumably so
	// we can intelligently adjust the high water mark

	// A frame is considered missing if it has not arrived by the time
	// it is required, but some frames following it have arrived.
	WORD m_wMissingFrames;

	// This one is pretty obvious. If we get the same frame twice, it's a duplicate
	// aarono will bet his car that this can never happen, so if you every see this
	// variable above one, call him up and make that bet!
	WORD m_wDuplicateFrames;

	// Overflow and late frames. If you look at where these are incremented
	// you'll see that it is pretty much a judgement call if we're throwing
	// away a frame due to an overflow or it being late, so take them with
	// a grain of salt. The sum of the two stats is however an accurate count
	// of how many frames arrived that we chucked.
	WORD m_wOverflowFrames;
	WORD m_wLateFrames;

	// These are used by the outer queue to remember if it
	// needed a frame from this queue when it's size was zero.
	WORD m_wPossibleZeroLengthDequeues;
	WORD m_wKnownZeroLengthDequeues;

	// This is the number of frames that make up the current message
	DWORD m_dwMsgLen; // make a dword in case of no voice detection

	// The Queue ID is just used for debug messages
	WORD m_wQueueId;

	// The message number this queue is for
	BYTE m_bMsgNum;

	// frame pool stuff
	CFramePool* m_pfpFramePool;
	DNCRITICAL_SECTION* m_pcsQueue;
};

// Inner queues are requested as needed by the CInputQueue2 class.
// This class manages a pool of inner queues so that actual memory
// allocations are few and far between.
class CInnerQueuePool
{
private:
	BYTE m_bNumSlots;
	WORD m_wFrameSize;
	CFramePool* m_pfpFramePool;
	DNCRITICAL_SECTION* m_pcsQueue;
	std::vector<CInnerQueue *> m_vpiqPool;
    DNCRITICAL_SECTION m_lock; // to exclude Get and Return from each other
	BOOL m_fCritSecInited;

public:
	CInnerQueuePool(
		BYTE bNumSlots,
		WORD wFrameSize,
		CFramePool* pfpFramePool,
		DNCRITICAL_SECTION* pcsQueue);

	~CInnerQueuePool();

	BOOL Init() 
	{
		if (DNInitializeCriticalSection(&m_lock) )
		{
			m_fCritSecInited = TRUE;
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	CInnerQueue* Get(
		BYTE bHighWaterMark = 0,
		WORD wQueueId = 0,
		BYTE bMsgNum = 0);

	void Return(CInnerQueue* piq);
};

#endif // _INNERQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\mixline.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		MixLine.h
 *  Content:	Class for managing the mixerLine API.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/30/99		rodtoll	Created based on source from dsound
 * 01/24/2000	rodtoll	Mirroring changes from dsound bug #128264
 *
 ***************************************************************************/
#ifndef __MIXLINE_H
#define __MIXLINE_H

class CMixerLine
{
public:
	CMixerLine();
	~CMixerLine();

	HRESULT Initialize( UINT uiDeviceID );

	HRESULT SetMicrophoneVolume( LONG lMicrophoneVolume );
	HRESULT GetMicrophoneVolume( LPLONG plMicrophoneVolume );

	HRESULT SetMasterRecordVolume( LONG lRecordVolume );
	HRESULT GetMasterRecordVolume( LPLONG plRecordVolume );

	HRESULT EnableMicrophone( BOOL fEnable );

	static HRESULT MMRESULTtoHRESULT( MMRESULT mmr );	
	
private:
	BOOL m_fMasterMuxIsMux;
    BOOL m_fAcquiredVolCtrl;
    
    MIXERCONTROLDETAILS m_mxcdMasterVol;
    MIXERCONTROLDETAILS m_mxcdMasterMute;
    MIXERCONTROLDETAILS m_mxcdMasterMux;
    MIXERCONTROLDETAILS m_mxcdMicVol;
    MIXERCONTROLDETAILS m_mxcdMicMute;
    MIXERCONTROLDETAILS_UNSIGNED m_mxVolume;
    MIXERCONTROLDETAILS_BOOLEAN m_mxMute;
    MIXERCONTROLDETAILS_BOOLEAN* m_pmxMuxFlags;
    LONG *m_pfMicValue;
    DWORD m_dwRangeMin;
    DWORD m_dwRangeSize;    
    UINT m_uWaveDeviceId;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\mixline.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		MixLine.cpp
 *  Content:	Class for managing the mixerLine API.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/30/99		rodtoll	Created based on source from dsound
 * 01/24/2000	rodtoll	Mirroring changes from dsound bug #128264
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DVF_MIXERLINE_PROCEDURE_DEBUG_LEVEL			DVF_INFOLEVEL

#define DPFLVL_INFO	5
#define DPF_MIXER		DPFX

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::CMixerLine"
CMixerLine::CMixerLine(
	): 	m_fAcquiredVolCtrl(FALSE), 
		m_pmxMuxFlags(NULL), 
		m_dwRangeMin(0), 
		m_dwRangeSize(0xFFFF),
		m_uWaveDeviceId(0),
		m_pfMicValue(NULL)
{
	ZeroMemory( &m_mxcdMasterVol, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMasterMute, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMasterMux, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMicVol, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMicMute, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxVolume, sizeof( MIXERCONTROLDETAILS_UNSIGNED ) );
	ZeroMemory( &m_mxMute, sizeof( MIXERCONTROLDETAILS_BOOLEAN ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::~CMixerLine"
CMixerLine::~CMixerLine()
{
	if( m_pmxMuxFlags != NULL )
	{
		delete [] m_pmxMuxFlags;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::Initialize"
HRESULT CMixerLine::Initialize( UINT uiDeviceID )
{
	if( m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_INITIALIZED;
	}
		
	m_uWaveDeviceId = uiDeviceID;
	
    // Set up the master waveIn destination mixer line
    MIXERLINE mxMastLine;
    ZeroMemory(&mxMastLine, sizeof mxMastLine);
    mxMastLine.cbStruct = sizeof mxMastLine;
    mxMastLine.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    // Set up the microphone source line
    MIXERLINE mxMicLine;
    ZeroMemory(&mxMicLine, sizeof mxMicLine);

    // Set up the mixer-line control structure
    MIXERCONTROL mxCtrl;
    ZeroMemory(&mxCtrl, sizeof mxCtrl);
    mxCtrl.cbStruct = sizeof mxCtrl;

    // Set up the 1-element array of controls
    MIXERLINECONTROLS mxLineCtrls;
    ZeroMemory(&mxLineCtrls, sizeof mxLineCtrls);
    mxLineCtrls.cbStruct = sizeof mxLineCtrls;
    mxLineCtrls.cControls = 1;
    mxLineCtrls.cbmxctrl = sizeof mxCtrl;
    mxLineCtrls.pamxctrl = &mxCtrl;

    // Set up the control details structures
    m_mxcdMasterVol.cbDetails = sizeof m_mxVolume;
    m_mxcdMasterVol.paDetails = &m_mxVolume;
    m_mxcdMasterVol.cChannels = 1;
    m_mxcdMasterMute.cbDetails = sizeof m_mxMute;
    m_mxcdMasterMute.paDetails = &m_mxMute;
    m_mxcdMasterMute.cChannels = 1;
    m_mxcdMicVol.cbDetails = sizeof m_mxVolume;
    m_mxcdMicVol.paDetails = &m_mxVolume;
    m_mxcdMicVol.cChannels = 1;
    m_mxcdMicMute.cbDetails = sizeof m_mxMute;
    m_mxcdMicMute.paDetails = &m_mxMute;
    m_mxcdMicMute.cChannels = 1;

    // We use the waveIn device ID instead of a "real" mixer device below
    HMIXEROBJ   hMixObj;
    MMRESULT mmr = mixerGetID((HMIXEROBJ) ((UINT_PTR)m_uWaveDeviceId), (LPUINT)&hMixObj, MIXER_OBJECTF_WAVEIN);

    if (MMSYSERR_NOERROR == mmr)
    {
        DPF_MIXER(DPFPREP, DPFLVL_INFO, "mixerGetID failed.");
    }

    // Find the master recording destination line
    mmr = mixerGetLineInfo(hMixObj, &mxMastLine, MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found the master recording mixer line");
        // Look for a volume fader control on the master line
        mxLineCtrls.dwLineID = mxMastLine.dwLineID;
        mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
        if (mmr == MMSYSERR_NOERROR)
        {
            // Found it - use the cbStruct field to flag success
            DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a volume fader on the master line");
            m_mxcdMasterVol.cbStruct = sizeof m_mxcdMasterVol;
            m_mxcdMasterVol.dwControlID = mxCtrl.dwControlID;
            m_dwRangeMin = mxCtrl.Bounds.dwMinimum;
            m_dwRangeSize = mxCtrl.Bounds.dwMaximum - mxCtrl.Bounds.dwMinimum;
            mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterVol, MIXER_GETCONTROLDETAILSF_VALUE);
        }
        if (mmr != MMSYSERR_NOERROR)
            m_mxcdMasterVol.cbStruct = 0;

        // Look for a mute control on the master line
        mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
        mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a mute control on the master line");
            m_mxcdMasterMute.cbStruct = sizeof m_mxcdMasterMute;
            m_mxcdMasterMute.dwControlID = mxCtrl.dwControlID;
            mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterMute, MIXER_GETCONTROLDETAILSF_VALUE);
        }
        if (mmr != MMSYSERR_NOERROR)
            m_mxcdMasterMute.cbStruct = 0;

        // Look for the microphone source line
        mxMicLine.cbStruct = sizeof mxMicLine;
        mxMicLine.dwDestination = mxMastLine.dwDestination;
        for (UINT i=0; i < mxMastLine.cConnections; ++i)
        {
            mxMicLine.dwSource = i;
            // Note: for some mysterious reason, I had to remove MIXER_OBJECTF_WAVEIN
            // from this call to mixerGetLineInfo() to make it work.
            mmr = mixerGetLineInfo(hMixObj, &mxMicLine, MIXER_GETLINEINFOF_SOURCE);
            if (mmr != MMSYSERR_NOERROR || mxMicLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
                break;
        }
        if (mxMicLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
        {
            DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a microphone mixer line");
            // Look for a volume fader control on the mic line
            mxLineCtrls.dwLineID = mxMicLine.dwLineID;
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
            mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a volume fader on the mic line");
                m_mxcdMicVol.cbStruct = sizeof m_mxcdMicVol;
                m_mxcdMicVol.dwControlID = mxCtrl.dwControlID;
                m_dwRangeMin = mxCtrl.Bounds.dwMinimum;
                m_dwRangeSize = mxCtrl.Bounds.dwMaximum - mxCtrl.Bounds.dwMinimum;
                mmr = mixerGetControlDetails(hMixObj, &m_mxcdMicVol, MIXER_GETCONTROLDETAILSF_VALUE);
            }
            if (mmr != MMSYSERR_NOERROR)
                m_mxcdMicVol.cbStruct = 0;

            // Look for a mute control on the mic line
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
            mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a mute control on the mic line");
                m_mxcdMicMute.cbStruct = sizeof m_mxcdMicMute;
                m_mxcdMicMute.dwControlID = mxCtrl.dwControlID;
                mmr = mixerGetControlDetails(hMixObj, &m_mxcdMicMute, MIXER_GETCONTROLDETAILSF_VALUE);
            }
            if (mmr != MMSYSERR_NOERROR)
                m_mxcdMicMute.cbStruct = 0;

            // Look for a MUX or MIXER control on the master line
            mxLineCtrls.dwLineID = mxMastLine.dwLineID;
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUX;
            m_fMasterMuxIsMux = TRUE;
            mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr != MMSYSERR_NOERROR)
            {
                mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MIXER;
                m_fMasterMuxIsMux = FALSE;
                mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            }
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found an item list control on the master line");
                m_mxcdMasterMux.cbStruct = sizeof m_mxcdMasterMux;
                m_mxcdMasterMux.dwControlID = mxCtrl.dwControlID;
                m_mxcdMasterMux.cMultipleItems = mxCtrl.cMultipleItems;
                
                // We save the cChannels value, because some evil VxD drivers (read: Aureal
                // Vortex) will set it to 0 in the call to mixerGetControlDetails() below
                int nChannels = (mxCtrl.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) ? 1 : mxMastLine.cChannels;
                m_mxcdMasterMux.cChannels = nChannels;

                // Get the MUX or MIXER list items
                m_mxcdMasterMux.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
                MIXERCONTROLDETAILS_LISTTEXT *pList = new MIXERCONTROLDETAILS_LISTTEXT [ m_mxcdMasterMux.cbDetails * m_mxcdMasterMux.cChannels * mxCtrl.cMultipleItems ];
                if (pList != NULL)
                {
                    m_mxcdMasterMux.paDetails = pList;
                    mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_GETCONTROLDETAILSF_LISTTEXT);
                    if (mmr == MMSYSERR_NOERROR)
                    {
                        DPF_MIXER(DPFPREP, DPFLVL_INFO, "Got the list controls's LISTTEXT details");
                        // Get the MUX or MIXER list values
                        m_mxcdMasterMux.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                        m_mxcdMasterMux.cChannels = nChannels;
                        m_pmxMuxFlags = new MIXERCONTROLDETAILS_BOOLEAN [ m_mxcdMasterMux.cbDetails * m_mxcdMasterMux.cChannels * mxCtrl.cMultipleItems ];
                        if (m_pmxMuxFlags != NULL)
                        {
                            m_mxcdMasterMux.paDetails = m_pmxMuxFlags;
                            mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_GETCONTROLDETAILSF_VALUE);
                            if (mmr == MMSYSERR_NOERROR)  // Enable the item corresponding to the mic line
                            {
                                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Got the list controls's VALUE details");
                                for (UINT i=0; i < mxCtrl.cMultipleItems; ++i)
                                {
                                    if (pList[i].dwParam1 == mxMicLine.dwLineID)
                                        m_pfMicValue = &m_pmxMuxFlags[i].fValue;
                                    else if (mxLineCtrls.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
                                        m_pmxMuxFlags[i].fValue = FALSE;
                                    DPF_MIXER(DPFPREP, DPFLVL_INFO, "Set list item %d to %d", i, pList[i].dwParam1 == mxMicLine.dwLineID);
                                }
                            }
                        }
                    }
                    delete[] pList;
					pList = NULL;
                }
                if (!m_pmxMuxFlags || !m_pfMicValue || mmr != MMSYSERR_NOERROR)
                    m_mxcdMasterMux.cbStruct = 0;
            }
        }
    }
  
    // To be able to control the recording level, we minimally require
    // a volume fader on the master line or one on the microphone line:
    m_fAcquiredVolCtrl = m_mxcdMasterVol.cbStruct || m_mxcdMicVol.cbStruct;
    
    HRESULT hr = m_fAcquiredVolCtrl ? DS_OK : DSERR_CONTROLUNAVAIL;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::SetMicrophoneVolume"
HRESULT CMixerLine::SetMicrophoneVolume( LONG lMicrophoneVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    // Set the microphone recording level control if available
    if (m_mxcdMicVol.cbStruct)
    {
        // Convert the DSBVOLUME level to an amplification factor from 0 to 0xFFFF
        m_mxVolume.dwValue = DBToAmpFactor(lMicrophoneVolume);

        // Adjust range if necessary
        if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
            m_mxVolume.dwValue = DWORD(m_dwRangeMin + m_dwRangeSize*double(m_mxVolume.dwValue)/0xFFFF);

        mmr = mixerSetControlDetails((HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMicVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
    }                             

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::GetMicrophoneVolume"
HRESULT CMixerLine::GetMicrophoneVolume( LPLONG plMicrophoneVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    DNASSERT(plMicrophoneVolume != NULL);

    // Get the microphone recording level if available
    if (m_mxcdMicVol.cbStruct != 0)
    {
        mmr = mixerGetControlDetails( (HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMicVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DNASSERT(m_mxVolume.dwValue >= m_dwRangeMin && m_mxVolume.dwValue <= m_dwRangeMin + m_dwRangeSize);

            // Adjust range if necessary
            if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
                m_mxVolume.dwValue = DWORD(double(m_mxVolume.dwValue-m_dwRangeMin) / m_dwRangeSize * 0xFFFF);

            // Convert the amplification factor to a DSBVOLUME level
            *plMicrophoneVolume = AmpFactorToDB(m_mxVolume.dwValue);
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::SetMasterRecordVolume"
HRESULT CMixerLine::SetMasterRecordVolume( LONG lRecordVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}
	
    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    // Set the master recording level control if available
    if (m_mxcdMasterVol.cbStruct)
    {
        // Convert the DSBVOLUME level to an amplification factor from 0 to 0xFFFF
        m_mxVolume.dwValue = DBToAmpFactor(lRecordVolume);

        // Adjust range if necessary
        if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
            m_mxVolume.dwValue = DWORD(m_dwRangeMin + m_dwRangeSize*double(m_mxVolume.dwValue)/0xFFFF);

        mmr = mixerSetControlDetails((HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMasterVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::GetMasterRecordVolume"
HRESULT CMixerLine::GetMasterRecordVolume( LPLONG plRecordVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    DNASSERT(plRecordVolume != NULL);

    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    // Get the master recording level if available
    if (m_mxcdMasterVol.cbStruct != 0)
    {
        mmr = mixerGetControlDetails((HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMasterVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DNASSERT(m_mxVolume.dwValue >= m_dwRangeMin && m_mxVolume.dwValue <= m_dwRangeMin + m_dwRangeSize);

            // Adjust range if necessary
            if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
                m_mxVolume.dwValue = DWORD(double(m_mxVolume.dwValue-m_dwRangeMin) / m_dwRangeSize * 0xFFFF);

            // Convert the amplification factor to a DSBVOLUME level
            *plRecordVolume = AmpFactorToDB(m_mxVolume.dwValue);
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    return hr;	

}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::SelectMicrophone"
HRESULT CMixerLine::EnableMicrophone( BOOL fEnable )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    HMIXEROBJ hMixObj = (HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId);
    MMRESULT mmr = MMSYSERR_NOERROR;
    HRESULT hr;

    // Check for presence of microphone controls
    if (!m_mxcdMasterMux.cbStruct && !m_mxcdMasterMute.cbStruct && !m_mxcdMicMute.cbStruct)
    {
        // We cannot do anything to enable the microphone line
        hr = DSERR_UNSUPPORTED;
    }
    else
    {
        // Select the mic on the Mux control, if available
        //
        if (m_mxcdMasterMux.cbStruct && !(m_fMasterMuxIsMux && !fEnable))
        {
            *m_pfMicValue = fEnable;
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        }

        // Mute/unmute the lines, if mute controls are available
        m_mxMute.fValue = !fEnable;
        if (m_mxcdMasterMute.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterMute, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        if (m_mxcdMicMute.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMicMute, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);

        hr = MMRESULTtoHRESULT(mmr);
    }

    return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::MMRESULTtoHRESULT"
HRESULT CMixerLine::MMRESULTtoHRESULT( MMRESULT mmr )
{
    HRESULT                 hr;
    
    switch(mmr)
    {
        case MMSYSERR_NOERROR:
            hr = DS_OK;
            break;

        case MMSYSERR_BADDEVICEID:
        case MMSYSERR_NODRIVER:
            hr = DSERR_NODRIVER;
            break;
        
        case MMSYSERR_ALLOCATED:
            hr = DSERR_ALLOCATED;
            break;

        case MMSYSERR_NOMEM:
            hr = DSERR_OUTOFMEMORY;
            break;

        case MMSYSERR_NOTSUPPORTED:
            hr = DSERR_UNSUPPORTED;
            break;
        
        case WAVERR_BADFORMAT:
            hr = DSERR_BADFORMAT;
            break;

        default:
            hr = DSERR_GENERIC;
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\sndutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		sndutils.cpp
 *  Content:
 *		This module contains the implementation of sound related utility
 *		functions.  Functions in this module manipulate WAVEFORMATEX
 *		structures and provide full duplex initialization / testing
 *		facilities.
 *
 *		This module also contains the routines used to measure peak
 *		of an audio buffer and for voice activation.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated util functions to take GUIDs and allow for 
 *                      users to pre-create capture/playback devices and
 *						pass them into InitXXXXDuplex
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 08/30/99		rodtoll	Added new playback format param to sound init 
 * 09/03/99		rodtoll	Fixed return codes on InitFullDuplex
 * 09/20/99		rodtoll	Now checks for invalid GUIDs for playback/record
 * 10/05/99		rodtoll	Added DPF_MODNAMEs
 * 10/29/99		rodtoll	Bug #113726 - Fixed memory leak when full duplex
 *						fails caused by architecture update.
 * 11/12/99		rodtoll	Updated full duplex test to use new abstracted recording
 *						and playback systems.  
 *				rodtoll	Updated to allow passing of sounddeviceconfig flags in dwflags
 *						parameter to init is effected by the flags specified by user
 *				rodtoll	Sound buffers (rec and playback) are now set to silence before
 *						recording/playback is started.
 * 11/22/99		rodtoll	Removed unnessessary set of recording buffer to silence.
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Updated for new parameters added by above bug.
 * 12/08/99		rodtoll	Bug #121054 - Support for capture focus and removed flags
 *						from buffer, allow dsound to manage buffer location.
 * 01/21/2000	pnewson	Fixed error cleanup code in InitHalfDuplex
 * 01/27/2000	rodtoll	Updated tests to accept buffer descriptions and play flags/priority  
 * 02/10/2000	rodtoll	Removed more capture focus
 * 02/23/2000	rodtoll	Fix to allow to run on dsound7.  
 * 05/19/2000   rodtoll Bug #35395 - Unable to run two copies of DPVHELP on same system without 
 *                      DirectX 8 installed.
 * 06/21/2000	rodtoll Bug #35767 - Must implement ability to use effects processing on voice buffers
 *						Updated sound initialization routines to handle buffers being passed in.
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 10/04/2000	rodtoll	Bug #43510 - DPVOICE: Apps receive a DVMSGID_SESSIONLOST w/DVERR_LOCKEDBUFFER 
 * 01/04/2001	rodtoll	WinBug #94200 - Remove stray comments 
 * 01/26/2001	rodtoll	WINBUG #293197 - DPVOICE: [STRESS} Stress applications cannot tell difference between out of memory and internal errors.
 *						Remap DSERR_OUTOFMEMORY to DVERR_OUTOFMEMORY instead of DVERR_SOUNDINITFAILURE.
 *						Remap DSERR_ALLOCATED to DVERR_PLAYBACKSYSTEMERROR instead of DVERR_SOUNDINITFAILURE. 
 * 04/12/2001	kareemc	WINBUG #360971 - Wizard Memory Leaks
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#define DSERRBREAK_NAME				"DSASSERT"

DNCRITICAL_SECTION	g_csDSDebug;

CHAR g_szLastDirectSoundAPI[100] = "";
HRESULT g_hrLastDirectSoundResult = DS_OK;
BOOL g_fDSErrorBreak = FALSE;

void DSERTRACK_Update( const char *szAPICall, HRESULT hrResult )
{
	DNEnterCriticalSection( &g_csDSDebug );		
	if( SUCCEEDED( g_hrLastDirectSoundResult ) )
	{
		g_hrLastDirectSoundResult = hrResult;
		strcpy( g_szLastDirectSoundAPI , szAPICall );
	}
	DNLeaveCriticalSection( &g_csDSDebug );			
}

void DSERRTRACK_Reset()
{
	DNEnterCriticalSection( &g_csDSDebug );			
	g_hrLastDirectSoundResult = DS_OK;
	g_szLastDirectSoundAPI[0] = 0;
	DNLeaveCriticalSection( &g_csDSDebug );			
}

BOOL DSERRTRACK_Init()
{
	if (!DNInitializeCriticalSection( &g_csDSDebug ))
	{
		return FALSE;
	}

	// Load the setting for the directsound assert  
	g_fDSErrorBreak = GetProfileIntA( "DirectPlay8", DSERRBREAK_NAME, FALSE );

	return TRUE;
}

void DSERRTRACK_UnInit()
{
	DNDeleteCriticalSection( &g_csDSDebug );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_SetupBufferDesc"
void DV_SetupBufferDesc( LPDSBUFFERDESC lpdsBufferDesc, LPDSBUFFERDESC lpdsBufferSource, LPWAVEFORMATEX lpwfxFormat, DWORD dwBufferSize )
{
	// Confirm specified buffer description is valid
	if( lpdsBufferSource != NULL )
	{
		if( lpdsBufferSource->dwSize == sizeof( DSBUFFERDESC1 ) )
		{
			memcpy( lpdsBufferDesc, lpdsBufferSource, sizeof( DSBUFFERDESC1 ) );
		}
		else
		{
			memcpy( lpdsBufferDesc, lpdsBufferSource, sizeof( DSBUFFERDESC ) );
		}

		// We require the following flags, at a minimum so they should always be set
		lpdsBufferDesc->dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2;
	}
	// User did not specify a buffer description, let's use our own!
	else
	{
		lpdsBufferDesc->dwSize = sizeof( DSBUFFERDESC );
		lpdsBufferDesc->dwFlags = DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;
		lpdsBufferDesc->dwBufferBytes = 0;
		lpdsBufferDesc->dwReserved = 0;
		lpdsBufferDesc->lpwfxFormat = NULL;
		lpdsBufferDesc->guid3DAlgorithm = DS3DALG_DEFAULT;
	}

	lpdsBufferDesc->lpwfxFormat = lpwfxFormat;
	lpdsBufferDesc->dwBufferBytes = dwBufferSize;

}


#undef DPF_MODNAME
#define DPF_MODNAME "SetRecordBufferToSilence"
HRESULT SetPlaybackBufferToSilence( CAudioPlaybackBuffer *pRecBuffer, const WAVEFORMATEX* lpwfxFormat )
{
	HRESULT hr;
	LPVOID pBufferPtr1, pBufferPtr2;
	DWORD dwBufferSize1, dwBufferSize2;

	hr = pRecBuffer->Lock( 0, 0, &pBufferPtr1, &dwBufferSize1, &pBufferPtr2, &dwBufferSize2, DSBLOCK_ENTIREBUFFER );

	DSERTRACK_Update( "Lock", hr );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Lock() failed during silence write hr=0x%x", hr );
		return hr;
	}

	memset( pBufferPtr1, (lpwfxFormat->wBitsPerSample==8) ? 0x80 : 0x00, dwBufferSize1 );	

	hr = pRecBuffer->UnLock( pBufferPtr1, dwBufferSize1, pBufferPtr2, dwBufferSize2 );

	DSERTRACK_Update( "UnLock", hr );	

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Unlock() failed uffer unlock failed hr=0x%x", hr );
		return hr;
	}

	return DV_OK;
}




#undef DPF_MODNAME
#define DPF_MODNAME "InitHalfDuplex"
// InitHalfDuplex
//
// This function initializes the playback system for the 
// specified compression type and the specified playback
// format.  This function is used to initialize
// the AudioPlaybackDevice and AudioPlaybackBuffer.
//
// It also starts the audio buffer which is used for voice
// output playing.  (In looping mode).
//
// Parameters:
// HWND hwnd - 
//		Window handle for the window where the output will
//      be associated
// ARDID playbackDeviceID -
//		The deviceID for the device which will be used for
//		playback
// CAudioPlaybackDevice ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybackDevice which will 
//      represent the playback device on success.
// CAudioPlaybackBuffer ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybacKbuffer which will
//		be used for voice audio output on success.
// CompressionType ct -
//		The type of compression which will be in use.  Used
//		to determine buffer sizes etc.
// WAVEFORMATEX *primaryFormat -
//		Pointer to a WAVEFORMATEX structure describing the
//      format of the voice output.  (This will also be used
//		to set the primary format of the output device if
//      normal is set to false).
// bool normal - 
//		Specifies if normal mode should be used or not.  
//      (Only used when using the DirectSound playback
//      system.  Set to true for normal cooperative mode, 
//      false for priority mode).
//
// Returns:
// bool -
//		Returns true if playback was initializes succesfully, 
//      false if initialization fails.
// 
HRESULT InitHalfDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,    
    CAudioPlaybackBuffer **audioPlaybackBuffer,
	const GUID &guidCT,
    WAVEFORMATEX *primaryFormat,
	WAVEFORMATEX *lpwfxPlayFormat,    
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
    )
{
    DWORD frameSize;
    HRESULT hr;
	DWORD dwBufferSize;
	BOOL fPriorityMode;
	DSBUFFERDESC dsBufferDesc;
	BOOL fPlaybackDeviceAllocated = FALSE;
	BOOL fPlaybackBufferAllocated = FALSE;

	fPriorityMode = !( dwFlags & DVSOUNDCONFIG_NORMALMODE );

//    *audioPlaybackBuffer = NULL;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "HALFDUPLEX INIT: Begin ==========" );

	LPDVFULLCOMPRESSIONINFO lpdvfInfo;

	hr = DVCDB_GetCompressionInfo( guidCT, &lpdvfInfo );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Error loading compression type: hr = 0x%x", hr );
		goto INIT_EXIT_ERROR2;
	}

	if( (*audioPlaybackDevice) == NULL )
	{
#ifdef __WAVESUBSYSTEM
		if( !(dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT) )
		{
#endif
			// Create the object to represent the device using the playback subsystem's
			// CreateDevice function
			(*audioPlaybackDevice) = new CDirectSoundPlaybackDevice();
			fPlaybackDeviceAllocated = TRUE;
			
			if( *audioPlaybackDevice == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;
				goto INIT_EXIT_ERROR2;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

#ifndef __WAVESUBSYSTEM
			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
				goto INIT_EXIT_ERROR2;
			}
#endif

#ifdef __WAVESUBSYSTEM
		}

		if( dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT || 
		    ((dwFlags & DVSOUNDCONFIG_ALLOWWAVEOUT) && FAILED( hr )) 
		  )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Could not initialize directsound, defaulting to waveout hr=0x%x", hr );
			delete (*audioPlaybackDevice);

			(*audioPlaybackDevice) = new CWaveOutPlaybackDevice( );
			fPlaybackDeviceAllocated = TRUE;
			
			if( (*audioPlaybackDevice) == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;				
				goto INIT_EXIT_ERROR2;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Could not initalize waveOut.  Init failed hr=0x%x", hr );
				goto INIT_EXIT_ERROR2;
			}
		}
		else if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
			goto INIT_EXIT_ERROR2;
		}
#endif
		// At this point we should have a valid device, waveOut or DirectSound
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init" );

	// Create a buffer if the user didn't specify one
	if( !(*audioPlaybackBuffer) )
	{
		frameSize = DVCDB_CalcUnCompressedFrameSize( lpdvfInfo, lpwfxPlayFormat ); 
		dwBufferSize = lpdvfInfo->dwFramesPerBuffer * frameSize;

		DV_SetupBufferDesc( &dsBufferDesc, lpdsBufferDesc, lpwfxPlayFormat, dwBufferSize );

		// Create the audio buffer which will be used for output 
		hr = (*audioPlaybackDevice)->CreateBuffer( &dsBufferDesc, frameSize, audioPlaybackBuffer);
		fPlaybackBufferAllocated = TRUE;

		if( FAILED( hr ) )
		{
    		Diagnostics_Write( DVF_ERRORLEVEL, "Unable to create sound buffer. hr=0x%x", hr );
			goto INIT_EXIT_ERROR2;
		}
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play  init 2" );

	hr = SetPlaybackBufferToSilence( *audioPlaybackBuffer, lpwfxPlayFormat );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "> Unable to set playback to silence" );
		goto INIT_EXIT_ERROR2;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init 3" );

	// Start the audio playback buffer playing
    hr = (*audioPlaybackBuffer)->Play( dwPlayPriority, dwPlayFlags );

	if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "> Can't play" );
        goto INIT_EXIT_ERROR2;
    }

	Diagnostics_Write( DVF_INFOLEVEL, "Half Duplex Init Result = DV_OK " );

    return DV_OK;

// Handle errors
INIT_EXIT_ERROR2:

    if( fPlaybackBufferAllocated && *audioPlaybackBuffer != NULL )
    {
        delete *audioPlaybackBuffer;
        *audioPlaybackBuffer = NULL;
    }

    if( fPlaybackDeviceAllocated && *audioPlaybackDevice != NULL )
    {
        delete *audioPlaybackDevice;
        *audioPlaybackDevice = NULL;
    }

	Diagnostics_Write( DVF_ERRORLEVEL, "Half Duplex Init Result = 0x%x", hr );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitializeRecordBuffer"
HRESULT InitializeRecordBuffer( HWND hwnd, const DVFULLCOMPRESSIONINFO* lpdvfInfo, CAudioRecordDevice *parecDevice, CAudioRecordBuffer **pparecBuffer, DWORD dwFlags )
{
	WAVEFORMATEX *lpwfxRecordFormat;
	DSCBUFFERDESC1 dscdesc;
	DWORD dwFrameSize;
	HRESULT hr;
	
	for( DWORD dwIndex = 0; dwIndex < GetNumRecordFormats(); dwIndex++ )
	{
		lpwfxRecordFormat = GetRecordFormat( dwIndex );
		
		dwFrameSize = DVCDB_CalcUnCompressedFrameSize( lpdvfInfo, lpwfxRecordFormat );			

		memset( &dscdesc, 0x00, sizeof( DSCBUFFERDESC1 ) );
		dscdesc.dwSize = sizeof( DSCBUFFERDESC1 );
		dscdesc.dwFlags = 0;
		dscdesc.lpwfxFormat = lpwfxRecordFormat;
		dscdesc.dwBufferBytes = dwFrameSize*lpdvfInfo->dwFramesPerBuffer;

		if( !(dwFlags & DVSOUNDCONFIG_NOFOCUS) )
		{
			dscdesc.dwFlags |= DSCBCAPS_FOCUSAWARE;

			if( dwFlags & DVSOUNDCONFIG_STRICTFOCUS )
			{
				dscdesc.dwFlags |= DSCBCAPS_STRICTFOCUS;
			}
		}

		hr = parecDevice->CreateBuffer( (DSCBUFFERDESC *) &dscdesc, hwnd, dwFrameSize, pparecBuffer );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not initialize %d hz, %d bits, %s (hr=0x%x)", lpwfxRecordFormat->nSamplesPerSec, 
			                       lpwfxRecordFormat->wBitsPerSample, (lpwfxRecordFormat->nChannels==1) ? _T("Mono") : _T("Stereo"), hr );
			continue;
			
		}
		else
		{
			Diagnostics_Write( DVF_INFOLEVEL, "Recording Initialized.  Format=" );
			Diagnositcs_WriteWAVEFORMATEX( DVF_INFOLEVEL, lpwfxRecordFormat );
		}

		hr = (*pparecBuffer)->Record(TRUE);			

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not start rec at %d hz, %d bits, %s (hr=0x%x)", lpwfxRecordFormat->nSamplesPerSec, 
			                       lpwfxRecordFormat->wBitsPerSample, (lpwfxRecordFormat->nChannels==1) ? _T("Mono") : _T("Stereo"), hr );
			delete (*pparecBuffer);
			(*pparecBuffer) = NULL;
			continue;
		}
		else
		{
			Diagnostics_Write( DVF_INFOLEVEL, "Recording Started.  Format=" );
			Diagnositcs_WriteWAVEFORMATEX( DVF_INFOLEVEL, lpwfxRecordFormat );
			// Reset the directsound erros as we expect errors in this part and if we suceed we handled
			// them.
			return DV_OK;
		}
		
	}

	return DVERR_RECORDSYSTEMERROR;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitFullDuplex"
// InitFullDuplex
//
// The tricky part.
//
// This function is responsible for initializing the system into full duplex
// mode using the specified parameters.  This function will create and
// initialize the playback and record devices as well as start the 
// playback device playing and the recording device recording.  (On success).
// This is neccessary because the order of Play and Record and device
// creation is important.
//
// Parameters:
// HWND hwnd - 
//		Window handle for the window where the output will
//      be associated
// ARDID playbackDeviceID -
//		The deviceID for the device which will be used for
//		playback
// CAudioPlaybackDevice ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybackDevice which will 
//      represent the playback device on success.
// CAudioPlaybackBuffer ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybacKbuffer which will
//		be used for voice audio output on success.
// ARDID recordDeviceID -
//		The ARDID for the device which will be used for recording.
// CAudioRecordSubSystem *recordSubSystem - 
//		This parameter is a pointer to the object representing
//      the subsystem which will be used for recording.
// CAudioRecordDevice ** - 
//		A pointer to a pointer which will contain a newly 
//		create CAudioRecordDevice for voice recording on 
//		success.  
// CompressionType ct -
//		The type of compression which will be in use.  Used
//		to determine buffer sizes etc.
// WAVEFORMATEX *primaryFormat -
//		Pointer to a WAVEFORMATEX structure describing the
//      format of the voice output.  (This will also be used
//		to set the primary format of the output device if
//      normal is set to false).
// bool aso -
//		This parameter controls the ASO option.  The ASO
//		option controls the "Startup Order".  Enabling 
//      this option allows full duplex to be initialized
//      on some troublesome cards.  
// bool normal - 
//		Specifies if normal mode should be used or not.  
//      (Only used when using the DirectSound playback
//      system.  Set to true for normal cooperative mode, 
//      false for priority mode).
//
// Returns:
// bool - true on successful full duplex initialization,
//        false on failure.
//
HRESULT InitFullDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,    
    CAudioPlaybackBuffer **audioPlaybackBuffer,
    const GUID &guidRecord,
    CAudioRecordDevice **audioRecordDevice,
    CAudioRecordBuffer **audioRecordBuffer,
    const GUID &guidCT,
    WAVEFORMATEX *primaryFormat,
	WAVEFORMATEX *lpwfxPlayFormat,
    BOOL aso,
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
)
{
    DWORD frameSize;
    DWORD dwBufferSize;
	HRESULT hr;
	DSBUFFERDESC dsbdesc;
	BOOL fPriorityMode;
	BOOL fPlaybackDeviceAllocated = FALSE;
	BOOL fPlaybackBufferAllocated = FALSE;
	BOOL fRecordDeviceAllocated = FALSE;

	fPriorityMode = !(dwFlags & DVSOUNDCONFIG_NORMALMODE);

//    *audioPlaybackBuffer = NULL;
    *audioRecordBuffer = NULL;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "FULLDUPLEX INIT: Begin ==========" );

	LPDVFULLCOMPRESSIONINFO lpdvfInfo;

	hr = DVCDB_GetCompressionInfo( guidCT, &lpdvfInfo );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Error loading compression type: hr = 0x%x", hr );
		goto INIT_EXIT_ERROR;
	}

	if( (*audioPlaybackDevice) == NULL )
	{
#ifdef __WAVESUBSYSTEM
		if( !(dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT) )	
		{
#endif
			// Create the object to represent the device using the playback subsystem's
			// CreateDevice function
			(*audioPlaybackDevice) = new CDirectSoundPlaybackDevice();
			fPlaybackDeviceAllocated = TRUE;
			
			if( *audioPlaybackDevice == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

#ifndef __WAVESUBSYSTEM
			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}
#endif

#ifdef __WAVESUBSYSTEM
		}

		if( dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT || 
		    ((dwFlags & DVSOUNDCONFIG_ALLOWWAVEOUT) && FAILED( hr )) ) 
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Could not initialize directsound, defaulting to waveout hr=0x%x", hr );
			delete (*audioPlaybackDevice);

			(*audioPlaybackDevice) = new CWaveOutPlaybackDevice();
			fPlaybackDeviceAllocated = TRUE;

			if( (*audioPlaybackDevice) == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;				
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Could not initalize waveOut.  Init failed hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}
		}
		else if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
#endif	
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init" );

	frameSize = DVCDB_CalcUnCompressedFrameSize( lpdvfInfo, lpwfxPlayFormat );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init" );

    dwBufferSize = lpdvfInfo->dwFramesPerBuffer * frameSize;

	if( !(*audioPlaybackBuffer) )
	{
		DV_SetupBufferDesc( &dsbdesc, lpdsBufferDesc, lpwfxPlayFormat, dwBufferSize );

		// Create the audio buffer which will be used for output 
		hr = (*audioPlaybackDevice)->CreateBuffer( &dsbdesc, frameSize, audioPlaybackBuffer);
		fPlaybackBufferAllocated = TRUE;
	
		if( FAILED( hr ) )
		{
    		Diagnostics_Write( DVF_ERRORLEVEL, "Unable to create sound buffer. hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play  init 2" );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Initing Recording" );

	// We're creating the device..
	if( (*audioRecordDevice) == NULL )
	{
#ifdef __WAVESUBSYSTEM
		if( !(dwFlags & DVSOUNDCONFIG_FORCEWAVEIN) )	
		{
#endif
			(*audioRecordDevice) = new CDirectSoundCaptureRecordDevice();
			fRecordDeviceAllocated = TRUE;
			
			if( *audioRecordDevice == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioRecordDevice)->Initialize( guidRecord );

			// DSC Init passed, try getting a buffer
			if( SUCCEEDED( hr ) )
			{
				hr = InitializeRecordBuffer( hwnd, lpdvfInfo, *audioRecordDevice, audioRecordBuffer, dwFlags );
				if( FAILED( hr ) )
				{
					Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize dsc buffer hr=0x%x", hr );
#ifndef __WAVESUBSYSTEM
					Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize record.  hr=0x%x", hr );
					goto INIT_EXIT_ERROR;
#endif
				}
				else
				{
					// Need to reset because we expect errors during initialization.  
					DSERRTRACK_Reset();					
				}
			}
#ifndef __WAVESUBSYSTEM			
			else
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize record.  hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}
#endif			
#ifdef __WAVESUBSYSTEM
		}

		// DSC Init failed, try and get a waveIn device
		if( dwFlags & DVSOUNDCONFIG_FORCEWAVEIN || 
		    ((dwFlags & DVSOUNDCONFIG_ALLOWWAVEIN) && FAILED( hr ))) 
		{
		
			Diagnostics_Write( DVF_ERRORLEVEL, "Could not initialize directsoundcapture, defaulting to wavein hr=0x%x", hr );
			delete (*audioRecordDevice);

			(*audioRecordDevice) = new CWaveInRecordDevice();
			fRecordDeviceAllocated = TRUE;
			
			if( (*audioRecordDevice) == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;				
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioRecordDevice)->Initialize( guidPlayback );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Could not initalize waveIn.  Init failed hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}

			hr = InitializeRecordBuffer( hwnd, lpdvfInfo, *audioRecordDevice, audioRecordBuffer, dwFlags );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize waveIn buffer hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}			
		}
		else if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize record.  hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
#endif
	}
	// Use specified device, just try and create the buffer
	else
	{
		hr = InitializeRecordBuffer( hwnd, lpdvfInfo, *audioRecordDevice, audioRecordBuffer, dwFlags );

		if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize dsc buffer hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Rec Init 2" );

	hr = SetPlaybackBufferToSilence( *audioPlaybackBuffer, lpwfxPlayFormat );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "> Unable to set playback to silence" );
		goto INIT_EXIT_ERROR;
	}
	
    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Rec Init 3" );

	// Depending on the ASO parameter start the playback buffer
	// playing and the recording buffer recording.
    if( aso )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "> ASO " );

        hr = (*audioPlaybackBuffer)->Play( dwPlayPriority, dwPlayFlags );

        if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't play" );
            goto INIT_EXIT_ERROR;
        }

        hr = (*audioRecordBuffer)->Record(TRUE);

		if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't start recording" );
            goto INIT_EXIT_ERROR;
        }
    }
    else
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "> !ASO " );

/*        hr = (*audioRecordBuffer)->Record(TRUE);

		if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't start recording" );
            goto INIT_EXIT_ERROR;
        }  */

        hr = (*audioPlaybackBuffer)->Play( dwPlayPriority, dwPlayFlags );

        if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't play" );
            goto INIT_EXIT_ERROR;
        }
    }
   
    DPFX(DPFPREP,  DVF_INFOLEVEL, "FULL DUPLEX INIT: End ==========" );

	Diagnostics_Write( DVF_INFOLEVEL, "Full Duplex Init Result = DV_OK" );

    return DV_OK;

INIT_EXIT_ERROR:

	if( *audioRecordBuffer != NULL )
	{
		delete *audioRecordBuffer;
		*audioRecordBuffer = NULL;
	}

	// Only delete on error if we allocated
    if( fRecordDeviceAllocated && *audioRecordDevice != NULL )
    {
        delete *audioRecordDevice;
        *audioRecordDevice = NULL;
    }

	// Only delete on error if we allocated
    if( fPlaybackBufferAllocated && *audioPlaybackBuffer != NULL )
    {
        delete *audioPlaybackBuffer;
        *audioPlaybackBuffer = NULL;
    }

	// Only delete on error if we allocated
    if( fPlaybackDeviceAllocated && *audioPlaybackDevice != NULL )
    {
        delete *audioPlaybackDevice;
        *audioPlaybackDevice = NULL;
    }

	Diagnostics_Write( DVF_ERRORLEVEL, "Full Duplex Init Result = 0x%x", hr );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak8Bit"
// FindPeak8Bit
//
// This function determines what the peak for a buffer
// of 8 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak8Bit( const BYTE *data, DWORD frameSize )
{
    BYTE peak = 0;
    int tmpData;

    for( int index = 0; index < frameSize; index++ )
    {
        tmpData = data[index];

        tmpData -= 0x80;

        if( tmpData < 0 )
            tmpData *= -1;

        if( tmpData > peak )
        {
            peak = (unsigned char) tmpData;
        }
    }

    tmpData = peak * 100 / 0x7F;

    return (BYTE) tmpData;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak16Bit"
// FindPeak16Bit
//
// This function determines what the peak for a buffer
// of 16 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak16Bit( const short *data, DWORD frameSize )
{
    int peak,       
        tmpData;

    frameSize /= 2;
    peak = 0;
    
    for( int index = 0; index < frameSize; index++ )
    {
        tmpData = data[index];

        if( tmpData < 0 )
        {
            tmpData *= -1;
        }

        if( tmpData > peak )
        {
            peak = tmpData;
        }
    }

    tmpData = (peak * 100) / 0x7FFF;

    return (BYTE) tmpData;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak"
// FindPeak
//
// This function determines what the peak for a buffer
// of 8 or 16 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
// BOOL eightBit -
//		Determins if the buffer is 8 bit or not.  Set to 
//      TRUE for 8 bit data, FALSE for 16 bit data.  
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak( BYTE *data, DWORD frameSize, BOOL eightBit )
{
    if( eightBit )
    {
        return FindPeak8Bit( data, frameSize );
    }
    else
    {
        return FindPeak16Bit( (signed short *) data, frameSize );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\wavformat.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wavformat.cpp
 *  Content:
 *		This module contains the CWaveFormat class which is used to work with
 *		WAVEFORMATEX structures.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/00		rodtoll	Created
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define REGISTRY_WAVEFORMAT_RATE			L"Rate"
#define REGISTRY_WAVEFORMAT_BITS			L"Bits"
#define REGISTRY_WAVEFORMAT_CHANNELS		L"Channels"
#define REGISTRY_WAVEFORMAT_TAG				L"Tag"
#define REGISTRY_WAVEFORMAT_AVGPERSEC		L"AvgPerSec"
#define REGISTRY_WAVEFORMAT_BLOCKALIGN		L"BlockAlign"
#define REGISTRY_WAVEFORMAT_CBSIZE			L"cbsize"
#define REGISTRY_WAVEFORMAT_CBDATA			L"cbdata"

// Cleanup -- Frees memory 
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::Cleanup"

void CWaveFormat::Cleanup()
{
	if( m_pwfxFormat )
	{
		if( m_fOwned )
		{
			delete m_pwfxFormat;
			m_fOwned = FALSE;
			m_pwfxFormat = NULL;
		}
	}
}

// Initialize with full parameters
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::Initialize"

HRESULT CWaveFormat::Initialize( WORD wFormatTag, DWORD nSamplesPerSec, WORD nChannels, WORD wBitsPerSample, 
			  	                 WORD nBlockAlign, DWORD nAvgBytesPerSec, WORD cbSize, void *pvExtra )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) (new BYTE[sizeof(WAVEFORMATEX)+cbSize]);

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->wFormatTag = wFormatTag;
	m_pwfxFormat->nSamplesPerSec = nSamplesPerSec;
	m_pwfxFormat->nChannels = nChannels;
	m_pwfxFormat->wBitsPerSample = wBitsPerSample;
	m_pwfxFormat->nBlockAlign = nBlockAlign;
	m_pwfxFormat->nAvgBytesPerSec = nAvgBytesPerSec;
	m_pwfxFormat->cbSize = cbSize;

	if( m_pwfxFormat->cbSize )
	{
		memcpy( &m_pwfxFormat[1], pvExtra, m_pwfxFormat->cbSize );
	}

	return DV_OK;
}

// Initialize and copy the specified format
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeCPY"

HRESULT CWaveFormat::InitializeCPY( LPWAVEFORMATEX pwfxFormat, void *pvExtra )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) (new BYTE[sizeof( WAVEFORMATEX ) + pwfxFormat->cbSize] );

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	memcpy( m_pwfxFormat, pwfxFormat, sizeof( WAVEFORMATEX ) );
	memcpy( &m_pwfxFormat[1], pvExtra, pwfxFormat->cbSize );

	return DV_OK;
}

// Build a standard PCM format
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializePCM"

HRESULT CWaveFormat::InitializePCM( WORD wHZ, BOOL fStereo, BYTE bBitsPerSample )
{
	Cleanup();

	m_pwfxFormat = new WAVEFORMATEX;

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->wFormatTag		= WAVE_FORMAT_PCM;
	m_pwfxFormat->nSamplesPerSec	= (WORD) wHZ;
	m_pwfxFormat->nChannels			= (fStereo) ? 2 : 1;
	m_pwfxFormat->wBitsPerSample	= (WORD) bBitsPerSample;
	m_pwfxFormat->nBlockAlign		= (bBitsPerSample * m_pwfxFormat->nChannels / 8);
	m_pwfxFormat->nAvgBytesPerSec	= m_pwfxFormat->nSamplesPerSec * m_pwfxFormat->nBlockAlign;
	m_pwfxFormat->cbSize			= 0;

	return DV_OK;
}

// Create a WAVEFORMAT that is of size dwSize
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeMEM"

HRESULT CWaveFormat::InitializeMEM( DWORD dwSize )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwSize];

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	return DV_OK;
}

// Initialize but unowned
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeUSE"

HRESULT CWaveFormat::InitializeUSE( WAVEFORMATEX *pwfxFormat )
{
	Cleanup();

	m_pwfxFormat = pwfxFormat;

	m_fOwned = FALSE;

	return DV_OK;
}

// Set this object equal to the parameter
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::SetEqual"

HRESULT CWaveFormat::SetEqual( CWaveFormat *pwfxFormat )
{
	Cleanup();

	if( pwfxFormat )
	{
		LPWAVEFORMATEX pwfxTmp = pwfxFormat->GetFormat();

		DNASSERT( pwfxFormat->GetFormat() );
	
		return Initialize( pwfxTmp->wFormatTag, pwfxTmp->nSamplesPerSec, 
						   pwfxTmp->nChannels, pwfxTmp->wBitsPerSample,
						   pwfxTmp->nBlockAlign, pwfxTmp->nAvgBytesPerSec,
						   pwfxTmp->cbSize, (pwfxTmp->cbSize) ? &pwfxTmp[1] : NULL );
	}

	return DV_OK;
}

// Are these two types equal?
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::IsEqual"

BOOL CWaveFormat::IsEqual( CWaveFormat *pwfxFormat )
{
	if( !pwfxFormat )
		return FALSE;

	DNASSERT( pwfxFormat->GetFormat() );

	if( pwfxFormat->GetFormat()->cbSize != m_pwfxFormat->cbSize )
		return FALSE;

	if( memcmp( pwfxFormat->GetFormat(), m_pwfxFormat, sizeof( WAVEFORMATEX ) ) != 0 )
		return FALSE;

	if( memcmp( &(pwfxFormat->GetFormat())[1], &m_pwfxFormat[1], m_pwfxFormat->cbSize ) != 0 )
		return FALSE;

	return TRUE;
}

// Write the contained value to the registry
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::WriteREG"

HRESULT CWaveFormat::WriteREG( HKEY hKeyRoot, const WCHAR *wszPath )
{
	CRegistry waveKey;
	HRESULT hr;

	if( !waveKey.Open( hKeyRoot, wszPath, FALSE, TRUE ) )
	{
		return E_FAIL; 
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_CBSIZE, m_pwfxFormat->cbSize ) )
	{
		return E_FAIL;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_RATE, m_pwfxFormat->nSamplesPerSec ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_BITS, m_pwfxFormat->wBitsPerSample ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_CHANNELS, m_pwfxFormat->nChannels ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_TAG, m_pwfxFormat->wFormatTag ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, m_pwfxFormat->nAvgBytesPerSec ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, m_pwfxFormat->nBlockAlign ) ) 
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &m_pwfxFormat[1], m_pwfxFormat->cbSize ) )
	{
		goto WRITE_FAILURE;
	}

	return S_OK;

WRITE_FAILURE:

	DPFX(DPFPREP,  0, "Error writing waveformat" );

	return E_FAIL;
}


// Initialize from registry 
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeREG"

HRESULT CWaveFormat::InitializeREG( HKEY hKeyRoot, const WCHAR *wszPath )
{
	CRegistry waveKey;
	HRESULT hr;

	if( !waveKey.Open( hKeyRoot, wszPath, TRUE, FALSE ) )
	{
		return E_FAIL; 
	}

	DWORD dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CBSIZE, &dwTmp ) )
	{
		return E_FAIL;
	}

	m_pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwTmp+sizeof(WAVEFORMATEX)];

	if( m_pwfxFormat == NULL )
	{
		return E_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->cbSize = (BYTE) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_RATE, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nSamplesPerSec = dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BITS, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->wBitsPerSample = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CHANNELS, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nChannels = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_TAG, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->wFormatTag = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, &dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nAvgBytesPerSec = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, &dwTmp ) ) 
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nBlockAlign = (INT) dwTmp;

	dwTmp = m_pwfxFormat->cbSize;

	if( !waveKey.ReadBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &m_pwfxFormat[1], &dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading waveformat blob" );
		goto READ_FAILURE;
	}

	return S_OK;

READ_FAILURE:

	Cleanup();

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dxvutils


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=LIBRARY
USE_STL=1
!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dxvutilspch.h
PRECOMPILED_PCH=dxvutilspch.pch
PRECOMPILED_OBJ=dxvutilspch.obj
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#
 

INCLUDES=..\..\common;..\..\inc;..\..\dxvoice;..\..\..\dplay8\inc\;$(SDXROOT)\public\internal\multimedia\inc;..\..\dxvtlib;..\

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG /DDBG
!endif

#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= dvcdb.cpp \
	dsplayb.cpp \
	dsplayd.cpp \
	inqueue2.cpp \
	sndutils.cpp \
	dscrecd.cpp \
	innerque.cpp \
	wiutils.cpp \
	Frame.cpp \
	winutil.cpp \
        dscrecd.cpp \
        dsprvobj.cpp \
        dscrecb.cpp \
        devmap.cpp \
        decibels.cpp \
        agcva1.cpp \
	wavformat.cpp \
	diagnos.cpp \
	dvtimer.cpp\
	mixline.cpp\
        dverror.cpp

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /D_DLL /DDIRECTSOUND_VERSION=0x0800

!if "$(VOICE_TARGET)" == "gamevoice" 
C_DEFINES= $(C_DEFINES) /DVOICE_BUILD_GAMEVOICE
!endif

!if "$(VOICE_TARGET)" == "allegiance" 
C_DEFINES= $(C_DEFINES) /DVOICE_BUILD_ALLEGIANCE
!endif


USE_NATIVE_EH=1
USE_STL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\sndutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		sndutils.h
 *  Content:	Declares sound related untility functions
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated util functions to take GUIDs and allow for 
 *                      users to pre-create capture/playback devices and
 *						pass them into InitXXXXDuplex
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 08/30/99		rodtoll	Added new playback format param to sound init
 * 11/12/99		rodtoll	Updated full duplex test to use new abstracted recording
 *						and playback systems.  
 *				rodtoll	Updated to allow passing of sounddeviceconfig flags in dwflags
 *						parameter to init is effected by the flags specified by user
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Updated to eliminate pointer to GUIDs.
 * 01/27/2000	rodtoll	Updated tests to accept buffer descriptions and play flags/priority 
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 08/29/2000	rodtoll Bug #43553 and Bug #43620 - Buffer lockup handling.
 * 11/16/2000	rodtoll	Bug #47783 - DPVOICE: Improve debugging of failures caused by DirectSound errors. 
 *
 ***************************************************************************/

class CAudioPlaybackBuffer;
class CAudioPlaybackDevice;
class CAudioRecordDevice;
class CAudioRecordBuffer;

//
// This module contains the definition of sound relatedt utility
// functions.  Functions in this module manipulate WAVEFORMATEX
// structures and provide full duplex initialization / testing
// facilities.
//
// This module also contains the routines used to measure peak
// of an audio buffer and for voice activation.
//
//
#ifndef __SOUNDUTILS_H
#define __SOUNDUTILS_H


void DV_SetupBufferDesc( LPDSBUFFERDESC lpdsBufferDesc, LPDSBUFFERDESC lpdsBufferSource, LPWAVEFORMATEX lpwfxFormat, DWORD dwBufferSize );

HRESULT InitFullDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,        
    CAudioPlaybackBuffer **audioPlaybackBuffer,
    const GUID &guidRecord,
    CAudioRecordDevice **audioRecordDevice,
    CAudioRecordBuffer **audioRecordBuffer,
    const GUID &guidCT,
    WAVEFORMATEX *primaryFormat,
    WAVEFORMATEX *lpwfxPlayFormat,
    BOOL aso,
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
);

HRESULT InitHalfDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,        
    CAudioPlaybackBuffer **audioPlaybackBuffer,
    const GUID &guidCT,
    WAVEFORMATEX *primaryFormat,
    WAVEFORMATEX *lpwfxPlayFormat,
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
    );

HRESULT InitializeRecordBuffer( HWND hwnd, const DVFULLCOMPRESSIONINFO* lpdvfInfo, CAudioRecordDevice *parecDevice, CAudioRecordBuffer **pparecBuffer, DWORD dwFlags );

BYTE FindPeak( BYTE *data, DWORD frameSize, BOOL eightBit );    

void DSERTRACK_Update( const char *szAPICall, HRESULT hrResult );
void DSERRTRACK_Reset();
BOOL DSERRTRACK_Init();
void DSERRTRACK_UnInit();

extern BOOL g_fDSErrorBreak;

#if defined(DEBUG) || defined(DBG) || defined(_DEBUG)
#define DSASSERT(condition) if( g_fDSErrorBreak ) { DNASSERT( condition ); }
#else
#define DSASSERT(condition)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\winutil.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		winutil.h
 *  Content:	Windows GUI utility functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/21/99		pnewson	Created
 ***************************************************************************/

#ifndef _WINUTIL_H_
#define _WINUTIL_H_

HRESULT CenterWindowOnWorkspace(HWND hWnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\winutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		winutil.cpp
 *  Content:	Windows GUI utility functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/21/99		pnewson	Created
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#undef DPF_MODNAME
#define DPF_MODNAME "CenterWindowOnWorkspace"
HRESULT CenterWindowOnWorkspace(HWND hWnd)
{
	DPF_ENTER();
	
	// Center the dialog on the desktop
	RECT rtWnd;
	RECT rtWorkArea;
	
	// First get the current dimensions of the dialog
	if (!GetWindowRect(hWnd, &rtWnd))
	{
		// Get window rect failed. Log it to the debugger, don't move
		// the window.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetWindowRect() failed, code: %i", GetLastError());
		DPF_EXIT();
		return E_FAIL;
	}

	// Now get the dimensions of the work area
	if (!SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&rtWorkArea, 0))
	{
		// Weird.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "SystemParametersInfo() failed, code: %i", GetLastError());
		DPF_EXIT();
		return E_FAIL;
	}

	if (!MoveWindow(
		hWnd, 
		rtWorkArea.left + (rtWorkArea.right - rtWorkArea.left)/2 - (rtWnd.right - rtWnd.left)/2, 
		rtWorkArea.top + (rtWorkArea.bottom - rtWorkArea.top)/2 - (rtWnd.bottom - rtWnd.top)/2, 
		rtWnd.right - rtWnd.left, 
		rtWnd.bottom - rtWnd.top,
		FALSE))
	{
		// Move window failed. Log it to the debugger.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "MoveWindow() failed, code: %i", GetLastError());
		DPF_EXIT();
		return E_FAIL;
	}
	DPF_EXIT();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\wavformat.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wavformat.h
 *  Content:
 *		This module contains the CWaveFormat class which is used to work with
 *		WAVEFORMATEX structures.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/00		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __WAVFORMAT_H
#define __WAVFORMAT_H

/////////////////////////////////////////////////////////////////////
//
// CWaveFormat
//
// Used to store and manipulate WAVEFORMATEX structures.
//
class CWaveFormat
{
public:

	CWaveFormat(): m_pwfxFormat(NULL), m_fOwned(FALSE) {};
	~CWaveFormat() { Cleanup(); };

	// Initialize with full parameters
	HRESULT Initialize( WORD wFormatTag, DWORD nSamplesPerSec, WORD nChannels, WORD wBitsPerSample, 
		                WORD nBlockAlign, DWORD nAvgBytesPerSec, WORD cbSize, void *pvExtra );

	// Initialize and copy the specified format
	HRESULT InitializeCPY( LPWAVEFORMATEX pwfxFormat, void *pvExtra );

	// Build a standard PCM format
	HRESULT InitializePCM( WORD wHZ, BOOL fStereo, BYTE bBitsPerSample );

	// Create a WAVEFORMAT that is of size dwSize
	HRESULT InitializeMEM( DWORD dwSize );

	// Initialize but unowned
	HRESULT InitializeUSE( WAVEFORMATEX *pwfxFormat );

	// Initialize from registry 
	HRESULT InitializeREG( HKEY hKeyRoot, const WCHAR *wszPath );

	// Set this object equal to the parameter
	HRESULT SetEqual( CWaveFormat *pwfxFormat );

	// Are these two types equal?
	BOOL IsEqual( CWaveFormat *pwfxFormat );

	// Return a pointer to the format
	inline WAVEFORMATEX *GetFormat() { return m_pwfxFormat; };

	inline WAVEFORMATEX *Disconnect() { m_fOwned = FALSE; return GetFormat(); };

	// Is this an eight bit waveformat?
	inline BOOL IsEightBit() const { return (m_pwfxFormat->wBitsPerSample==8); };

	// Write the contained value to the registry
	HRESULT WriteREG( HKEY hKeyRoot, const WCHAR *wszPath );

protected:

	void Cleanup();

	WAVEFORMATEX	*m_pwfxFormat;
	BOOL			m_fOwned;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\wiutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecs.cpp
 *  Content:
 *		This module contains the implementation of the WaveInException class
 *		the recording format db.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 09/03/99		rodtoll	Fixed WaveFormatToString
 * 09/20/99		rodtoll	Updated to check for memory allocation failures
 * 10/05/99		rodtoll	Added DPF_MODNAMES
 * 03/28/2000   rodtoll Removed code which was no longer used 
 * 04/14/2000   rodtoll Fix: Bug #32498 - Updating format list to ensure that 8Khz formats are
 *                      tried first to reduce compression overhead / quality loss
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define __VOXWARE

// NUM_RECORD_FORMATS
//
// This define determines the number of recording formats which
// will be present in the recording db.  (Since they are currently
// hard-coded.
#define NUM_RECORD_FORMATS  16

#define MODULE_ID   WAVEINUTILS

// g_waveInDBInitialized
//
// This flag is used to report when the recording db has been initialized.  
BOOL g_waveInDBInitialized = FALSE;

// g_pwfRecordFormats
//
// This is the actual record format db.  It contains a list of the formats
// that are tried when attempting to find a format which will allow 
// full duplex operation.  They are listed in the order in which they 
// should be tried.
WAVEFORMATEX **g_pwfRecordFormats;

#undef DPF_MODNAME
#define DPF_MODNAME "GetRecordFormat"
// GetRecordFormat
//
// This function returns the recording format at the index specified
// by index in the recording format DB.  
// 
// The recording format db must be initialized before this can be called.
//
// Parameters:
// UINT index -
//		The 0-based index into the recording format db that the user
//		wishes to retrieve.  
//
// Returns:
// WAVEFORMATEX * -
//		A pointer to a WAVEFORMATEX structure describing the format
//      at the given index in the recording db.  This will be NULL
//      if index >= NUM_RECORD_FORMATS or if the recording db has
//      not been initialized.
//
// WARNING:
// The pointer returned is to the actual entry in the recording db and
// is owned by it.  Therefore the caller should not modify or free
// the memory returned by the pointer.  
//
WAVEFORMATEX *GetRecordFormat( UINT index )
{
	if( !g_waveInDBInitialized )
		return NULL;

    if( index >= NUM_RECORD_FORMATS )
    {
        return NULL;
    }
    else
    {
        return g_pwfRecordFormats[index];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetNumRecordFormats"
// GetNumRecordFormats
//
// This function returns the number of recording formats stored
// in the recording format db.  
//
// Parameters:
// N/A
//
// Returns:
// UINT - 
//		The number of formats in the recording format db.
//
UINT GetNumRecordFormats()
{
	if( !g_waveInDBInitialized )
		return 0;

    return NUM_RECORD_FORMATS;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitRecordFormats"
// InitRecordFormats
//
// This function initializes the recording format db with the formats which 
// should be tried when initializing recording.  This should be the first
// function called from the recording format db.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void InitRecordFormats()
{
	if( g_waveInDBInitialized )
		return;

    DPFX(DPFPREP,  DVF_ENTRYLEVEL, "- WDB: Init End" );

    g_pwfRecordFormats = new WAVEFORMATEX*[NUM_RECORD_FORMATS];

    if( g_pwfRecordFormats == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to init recordb, memory alloc failure" );
    	return;
    }

    g_pwfRecordFormats[0] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 16 );
    g_pwfRecordFormats[1] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 8 );
    
    g_pwfRecordFormats[2] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 16 );
    g_pwfRecordFormats[3] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 16 );
    g_pwfRecordFormats[4] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 16 );

    g_pwfRecordFormats[5] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 8 );
    g_pwfRecordFormats[6] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 8 );
    g_pwfRecordFormats[7] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 8 );
     
    g_pwfRecordFormats[8] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 16 );
    g_pwfRecordFormats[9] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 8 ); 

    g_pwfRecordFormats[10] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 16 );    
    g_pwfRecordFormats[11] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 16 );  
    g_pwfRecordFormats[12] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 16 );   
    
    g_pwfRecordFormats[13] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 8 );    
    g_pwfRecordFormats[14] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 8 );
    g_pwfRecordFormats[15] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 8 );    
 
/*
    g_pwfRecordFormats[0] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 8 );
    g_pwfRecordFormats[1] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 8 );
    g_pwfRecordFormats[2] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 16 );
    g_pwfRecordFormats[3] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 16 );  

    g_pwfRecordFormats[4] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 8 );
    g_pwfRecordFormats[5] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 8 );
    g_pwfRecordFormats[6] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 16 );
    g_pwfRecordFormats[7] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 16 );

    g_pwfRecordFormats[8] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 8 );
    g_pwfRecordFormats[9] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 8 );
    g_pwfRecordFormats[10] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 16 );
    g_pwfRecordFormats[11] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 16 );   

    g_pwfRecordFormats[12] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 16 );
    g_pwfRecordFormats[13] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 8 );
    g_pwfRecordFormats[14] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 16 );       
    g_pwfRecordFormats[15] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 8 );
    */

    g_waveInDBInitialized = TRUE;

    DPFX(DPFPREP,  DVF_ENTRYLEVEL, "- WDB: Init End" );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DeInitRecordFormats"
// DeInitRecordFormats
//
// This function releases the memory associated with the  recording
// format DB.  
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void DeInitRecordFormats()
{
    if( g_waveInDBInitialized )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "- WDB: DeInit Begin" );

        for( int index = 0; index < NUM_RECORD_FORMATS; index++ )
        {
            delete g_pwfRecordFormats[index];
        }

        delete [] g_pwfRecordFormats;

        DPFX(DPFPREP,  DVF_INFOLEVEL, "- WDB: DeInit End" );

        g_waveInDBInitialized = FALSE;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CreateWaveFormat"
// CreateWaveFormat
//
// This utility function is used to allocate and fill WAVEFORMATEX 
// structures for the various formats used. This function
// currently supports the following formats:
//
// WAVE_FORMAT_ADPCM
// WAVE_FORMAT_DSPGROUP_TRUESPEECH
// WAVE_FORMAT_GSM610
// WAVE_FORMAT_LH_CODEC
// WAVE_FORMAT_PCM
//
// The function will allocate the required memory for the sturcture
// (including extra bytes) as required by the format and will fill
// in all the members of the sturcture.  The structure which is 
// returned belongs to the caller and must be deallocated by the
// caller.
//
// Parameters:
// short formatTag -
//		The format tag for the wav format.
//
// BOOL stereo -
//		Specify TRUE for stereo, FALSE for mono
//
// int hz - 
//		Specify the sampling rate of the format.  E.g. 22050
//
// int bits - 
//		Specify the number of bits / sample.  E.g. 8 or 16
//
// Returns:
// WAVEFORMATEX * - 
//		A pointer to a newly allocated WAVEFORMATEX structure 
//      for the specified format, or NULL if format is not supported
//
WAVEFORMATEX *CreateWaveFormat( short formatTag, BOOL stereo, int hz, int bits ) {

	switch( formatTag ) {
	case WAVE_FORMAT_PCM:
		{
			WAVEFORMATEX *format		= new WAVEFORMATEX;

            if( format == NULL )
            {
				goto EXIT_MEMALLOC_CREATEWAV;            
			}
			
			format->wFormatTag			= WAVE_FORMAT_PCM;
			format->nSamplesPerSec		= hz;
			format->nChannels			= (stereo) ? 2 : 1;
			format->wBitsPerSample		= (WORD) bits;
			format->nBlockAlign			= (bits * format->nChannels / 8);
			format->nAvgBytesPerSec		= format->nSamplesPerSec * format->nBlockAlign;
			format->cbSize				= 0;
			return format;
		}
		break;
    default:
        DNASSERT( TRUE );
	}

EXIT_MEMALLOC_CREATEWAV:

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc buffer for waveformat, or invalid format" );
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\dxvutils\wiutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayd.h
 *  Content:	general wave in utilty functions and classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 03/28/2000   rodtoll Removed code which was no longer used
 *
 ***************************************************************************/

#ifndef __WAVEINUTILS_H
#define __WAVEINUTILS_H

// Recording Format DB
//
// The Recording Format DB contains a list of the formats that should
// be used when attempting to initialize a recording device in full 
// duplex mode.  They are listed in the database in the order in which 
// they should be tried.

WAVEFORMATEX *GetRecordFormat( UINT index );
UINT GetNumRecordFormats();

void InitRecordFormats();
void DeInitRecordFormats();
BOOL IsValidRecordDevice( UINT deviceID );


WAVEFORMATEX *CreateWaveFormat( short formatTag, BOOL stereo, int hz, int bits );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\guids\guids.cpp ===
#include <initguid.h>
#include <wtypes.h>
#include <mmsystem.h>
#include "dsoundp.h"
#include "dsprv.h"
#include "dplay8.h"
#include "dvoice.h"
#include "dpvcp.h"
#include "dplay.h"
#include "dplobby.h"
#include "..\codecs\dpvvox\dpvvox.h"
#include "..\codecs\dpvacm\dpvacm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\guids\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=guids


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=LIBRARY

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#


INCLUDES=..\..\..\dplay8\inc\;..\..\..\dvoice\inc;$(DXROOT)\inc;

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG /DDBG
!endif


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES=..\guids.cpp

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /D_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\inc\dpvcp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  12/16/99	rodtoll		Padding for compression structure
 ***************************************************************************/

#ifndef __DPVCP_H
#define __DPVCP_H

#include "dvoice.h"

/////////////////////////////////////////////////////////////////////////////////////
// GUIDS
//

// {B8485451-07C4-4973-A278-C69890D8CF8D}
DEFINE_GUID(IID_IDPVCompressionProvider, 
0xb8485451, 0x7c4, 0x4973, 0xa2, 0x78, 0xc6, 0x98, 0x90, 0xd8, 0xcf, 0x8d);

// {AAA56B61-3B8D-4906-AE58-29C26B8F47B8}
DEFINE_GUID(IID_IDPVConverter, 
0xaaa56b61, 0x3b8d, 0x4906, 0xae, 0x58, 0x29, 0xc2, 0x6b, 0x8f, 0x47, 0xb8);

/////////////////////////////////////////////////////////////////////////////////////
// Interface types
//
typedef struct IDPVCompressionProvider FAR *LPDPVCOMPRESSIONPROVIDER, *PDPVCOMPRESSIONPROVIDER;
typedef struct IDPVCompressor FAR *LPDPVCOMPRESSOR, *PDPVCOMPRESSOR;

/////////////////////////////////////////////////////////////////////////////////////
// Data Types
//

typedef struct 
{
	// DVCOMPRESSIONINFO Structure
	//
    DWORD       	dwSize; 
	GUID			guidType;
   	LPWSTR       	lpszName;
   	LPWSTR     		lpszDescription;
	DWORD			dwFlags;
    DWORD           dwMaxBitsPerSecond;		
    WAVEFORMATEX    *lpwfxFormat;			 
    //
    // DVCOMPRESSIONINFO Structure End
    // Above this point must match the DVCOMPRESSIONINFO structure.
    // 
    DWORD           dwFramesPerBuffer;	
    DWORD           dwTrailFrames;		
    DWORD           dwTimeout;			
    DWORD           dwFrameLength;		 
    DWORD           dwFrame8Khz;		  
    DWORD           dwFrame11Khz;		
    DWORD           dwFrame22Khz;		 
    DWORD           dwFrame44Khz;		
    WORD            wInnerQueueSize;	
    WORD            wMaxHighWaterMark;
    BYTE            bMaxQueueSize;
    BYTE			bMinConnectType;	
    BYTE			bPadding1;	// For alignment
    BYTE			bPadding2;	// For alignment
} DVFULLCOMPRESSIONINFO, *LPDVFULLCOMPRESSIONINFO, *PDVFULLCOMPRESSIONINFO;

/////////////////////////////////////////////////////////////////////////////////////
// Interface definitions
//

#undef INTERFACE
#define INTERFACE IDPVCompressionProvider
//
// IDPVCompressionProvider
//
// This interface is exported by each DLL which provides compression services.
// It is used to enumerate the compression types available with a DLL and/or
// create a compressor/decompressor for a specified type.
//
// I propose there will be two providers:
//
// DPVACM.DLL - Provides these services for ACM based drivers.  It will read
//              the types it supports from the registry and can therefore be
// 				extended with new types as ACM drivers become available
//				CLSID_DPVACM
// 
// DPVVOX.DLL - Provides these services for Voxware. 
//
DECLARE_INTERFACE_( IDPVCompressionProvider, IUnknown )
{
    
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDPVCompressionProvider methods ***/
    
    // EnumCompressionTypes
    //
    // Enumerates compression types supported by this DLL.  Returns an array
    // of DVFULLCOMPRESSIONINFO structures describing the supported types.
    //
    STDMETHOD_(HRESULT, EnumCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;

    // IsCompressionSupported
    //
    // Quick query function for determing if the DLL supports a specified
    // compression type.
    //
    STDMETHOD_(HRESULT, IsCompressionSupported)( THIS_ GUID ) PURE;

    // CreateCompressor
    //
    // Create a IDPVConverter object which converts from the specified uncompressed
    // format to the specified compression format.
    //
    STDMETHOD_(HRESULT, CreateCompressor)( THIS_ LPWAVEFORMATEX, GUID, PDPVCOMPRESSOR *, DWORD ) PURE;

    // CreateDeCompressor
    //
    // Creates a IDPVConveter object which converts from the specified format to 
    // the specified uncompressed format.
    //
    STDMETHOD_(HRESULT, CreateDeCompressor)( THIS_ GUID, LPWAVEFORMATEX, PDPVCOMPRESSOR *, DWORD ) PURE;    

    // GetCompressionInfo
    //
    // Retrieves the DVFULLCOMPRESSIONINFO structure for the specified compression
    // type.
    //
    STDMETHOD_(HRESULT, GetCompressionInfo)( THIS_ GUID, PVOID, PDWORD ) PURE;
};

#undef INTERFACE
#define INTERFACE IDPVCompressor
//
// IDPVCompressor
//
// This interface does the actual work of performing conversions for 
// DirectPlayVoice.  This can be instantiated on it's own and Initialized,
// ot created using the CreateCompressor/CreateDecompressor above.
//
DECLARE_INTERFACE_( IDPVCompressor, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDPVCompressor methods ***/
	// Initialize
	//
	// Initialize this object as a decompressor.
	//
    STDMETHOD_(HRESULT, InitDeCompress)( THIS_ GUID, LPWAVEFORMATEX ) PURE;

	// Initialize
	//
	// Initialize this object as a compressor
    STDMETHOD_(HRESULT, InitCompress)( THIS_ LPWAVEFORMATEX, GUID ) PURE;    

	// IsValid
	//
	// Returns TRUE in the LPBOOL param if this compression type is
	// available.
    STDMETHOD_(HRESULT, IsValid)( THIS_ LPBOOL ) PURE;

	// GetXXXXXX
	//
	// Functions used by the engine for sizing.
    STDMETHOD_(HRESULT, GetUnCompressedFrameSize)( THIS_ LPDWORD ) PURE;
    STDMETHOD_(HRESULT, GetCompressedFrameSize)( THIS_ LPDWORD ) PURE;
    STDMETHOD_(HRESULT, GetNumFramesPerBuffer)( THIS_ LPDWORD ) PURE;

	// Convert
	//
	// Perform actual conversion
	STDMETHOD_(HRESULT, Convert)( THIS_ LPVOID, DWORD, LPVOID, LPDWORD, BOOL ) PURE;  
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dvoice\inc\dvoice.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
//@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By          Reason
 *  =====       =======     ==================================================
 *  07/01/99    rodtoll     created
 *  07/22/99    rodtoll     Added new error messages for server object
 *  08/25/99    rodtoll     Updated to use new GUID based compression selection
 *  08/26/99    rodtoll     Updated C/C++ macros.
 *  08/30/99    rodtoll     Added timeout error code
 *                          Added host migration message ID
 *  09/02/99    pnewson     Added IDirectPlayVoiceSetup interface
 *  09/07/99    rodtoll     Fixed C macros and added IDirectPlayVoicePlugin interface
 *              rodtoll     Moved settarget message id to public header, added
 *                          new 3d-related error codes.
 *  09/08/99    rodtoll     Updated for new compression structure
 *  09/10/99    rodtoll     Redefined hosting error codes to be unique
 *  09/13/99    rodtoll     Added GUIDs for default capture/playback devices
 *  09/20/99    rodtoll     New error messages, DVNOTIFYPERIOD_MAXPERIOD
 *  09/29/99    rodtoll     Added new flags/members for voice suppression
 *  10/15/99    rodtoll     Mapped default system devices to NULL
 *  10/19/99    rodtoll     Renamed to dpvoice.h
 *  10/20/99    rodtoll     Fix: Bug #114218 : Added new error code
 *  10/25/99    rodtoll     Fix: Bug #114682 : Removing password member of session desc
 *              rodtoll     Start of move from LPs to Ps for pointers
 *  10/27/99    pnewson     Added DVCLIENTCONFIG_AUTOVOLUMERESET flag for Bug #113936
 *              rodtoll     Fix: Bug #113745: Updated facility code
 *  10/28/99    pnewson     Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/12/99    rodtoll     Added new flags for echo suppression and waveIN/waveOut
 *                          usage control.
 *  11/17/99    rodtoll     Fix: Bug #116440 - Remove unused flags
 *              rodtoll     Fix: Bug #119584 - Rename FACDN to FACDPV
 *  11/23/99    rodtoll     Updated w/better error codes for transport errors
 *  12/06/99    rodtoll     Fix: Bug #121054 Integration of new dsound 7.1 bits
 *                          Added flags to control capture focus behaviour
 *  12/16/99    rodtoll     Removed voice suppression code
 *              rodtoll     Fix: Bug #119584 Renamed run setup error
 *              rodtoll     Fix: Bug #117405 3D Sound APIs misleading
 *              rodtoll     Fix: Bug #122629 Added flag to control host migration
 *  12/01/99    pnewson     removed our default device guids, since dsound now has them
 *                          added DVINPUTLEVEL_MIN, DVINPUTLEVEL_MAX
 *  01/13/00    aarono      added SendSpeechEx to IDirectPlayVoiceTransport
 *  01/14/2000  rodtoll     Removed DVID_NOTARGET
 *              rodtoll     Removed DVMSGID_STARTSESSIONRESULT / DVMSGID_STOPSESSIONRESULT
 *                          (Collapsed other message IDs)
 *              rodtoll     Updated callback function prototype for new callback format
 *              rodtoll     Renamed Get/SetTransmitTarget --> Get/SetTransmitTargets and
 *                          updated parameter list to match new format
 *              rodtoll     Added GetSoundDeviceConfig function to client interface
 *              rodtoll     Added DVMSG_ structures for callback messages.
 *  01/20/2000  rodtoll     Removed dplay.h from header
 *              rodtoll     Added new members to the Transport interface
 *  01/21/2000  pnewson     Added DVSOUNDCONFIG_TESTMODE
 *                          Added DVRECORDVOLUME_LAST
 *                          Fixed conflicted error code for DVERR_CHILDPROCESSFAILED
 *  01/25/2000  pnewson     Added DVFLAGS_WAVEIDS
 *                          Fixed IDirectPlayVoiceSetup_CheckAudioSetup macro
 *  01/25/2000  rodtoll     Exposed DVCLIENTCONFIG_ECHOSUPPRESSION
 *              rodtoll     Fixed C macros for member calls
 *              rodtoll     Fixed NotifyEvent call to add LPVOID to call
 *  01/27/2000  rodtoll     Bug #129934 - Added DSBUFFERDESCs to calls
 *  01/31/2000  pnewson     changed sensitivity range to match input level range
 *  02/08/2000  rodtoll     Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *                          never being detected
 *  03/29/2000	rodtoll		Bug #30957 - Added new flag to control conv quality -- DVSOUNDCONFIG_SETCONVERSIONQUALITY
 *				rodtoll		Bug #30819 - Restored DX8 CLSID to match DX7.1's, but changed IIDs for Client/Server.
 *				rodtoll		Bug #31000 - Fixed incorrect # of params to C macros for interface
 *  03/29/2000	pnewson		Added DVFLAGS_ALLOWBACK
 *  04/05/2000  rodtoll     Updated to allow pointers through notify.
 *              rodtoll     Added DVEVENT_BUFFERRETURN event type for notification interface
 *              rodtoll     Updated Advise to have interface specify if it's a client or server when advising/unadvising
 *                          Bug #32179 - Registering more then one server/and/or/client
 *  04/11/2000  rodtoll     Moved DPVCTGUID_DEFAULT out of msinternal
 *  05/03/2000  rodtoll     Bug #33640 - CheckAudioSetup takes GUID * instead of const GUID * 
 *  06/07/2000	rodtoll		Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  06/15/2000  rodtoll     Bug #36590 - Renamed macros to match new interface name
 *  06/21/2000	rodtoll		Bug #35767 - Implemented ability to use effects on voice buffers
 *							Replaced DSBUFFERDESC with DIRECTSOUNDBUFFERS
 *							Added DVERR_INVALIDBUFFER return code.
 *  06/23/2000	rodtoll		Bug #37556 - Hexify the DPVERR codes
 *  08/21/2000	rodtoll		Bug #42786 - Obsolete interface names in dvoice.h
 *  08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets 
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions  
 * 	04/06/2001	kareemc	Added Voice Defense
 *
 //@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DVOICE__
#define __DVOICE__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dsound.h"

#ifdef __cplusplus
extern "C" {
#endif

//@@BEGIN_MSINTERNAL
#define DPVOICE_REGISTRY_BASE           L"SOFTWARE\\MICROSOFT\\DIRECTPLAY\\VOICE"
#define DPVOICE_REGISTRY_CP             L"\\Compression Providers"
#define DPVOICE_REGISTRY_DPVACM         L"\\DPVACM"
#define DPVOICE_REGISTRY_DPVVOX         L"\\DPVVOX"
#define DPVOICE_REGISTRY_AGC            L"\\AGC"
#define DPVOICE_REGISTRY_AUDIOCONFIG   L"\\AudioConfig"
 //@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice CLSIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
// Provided for compatibility with stand-alone and Millenium.
//
// Only VoiceClient/VoiceSetup and VoiceServer can be created from this CLSID.
// {948CE83B-C4A2-44b3-99BF-279ED8DA7DF5}
DEFINE_GUID(CLSID_DirectPlayVoice, 
0x948ce83b, 0xc4a2, 0x44b3, 0x99, 0xbf, 0x27, 0x9e, 0xd8, 0xda, 0x7d, 0xf5);

#define CLSID_DIRECTPLAYVOICE           CLSID_DirectPlayVoice
 //@@END_MSINTERNAL

// {B9F3EB85-B781-4ac1-8D90-93A05EE37D7D}
DEFINE_GUID(CLSID_DirectPlayVoiceClient, 
0xb9f3eb85, 0xb781, 0x4ac1, 0x8d, 0x90, 0x93, 0xa0, 0x5e, 0xe3, 0x7d, 0x7d);

// {D3F5B8E6-9B78-4a4c-94EA-CA2397B663D3}
DEFINE_GUID(CLSID_DirectPlayVoiceServer, 
0xd3f5b8e6, 0x9b78, 0x4a4c, 0x94, 0xea, 0xca, 0x23, 0x97, 0xb6, 0x63, 0xd3);

// {0F0F094B-B01C-4091-A14D-DD0CD807711A}
DEFINE_GUID(CLSID_DirectPlayVoiceTest, 
0xf0f094b, 0xb01c, 0x4091, 0xa1, 0x4d, 0xdd, 0xc, 0xd8, 0x7, 0x71, 0x1a);

/****************************************************************************
 *
 * DirectPlayVoice Interface IIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL

// {660CECA7-1A48-42f1-BAF3-04C183DF87DB}
DEFINE_GUID(IID_IDirectPlayVoiceNotify, 
0x660ceca7, 0x1a48, 0x42f1, 0xba, 0xf3, 0x4, 0xc1, 0x83, 0xdf, 0x87, 0xdb);

// {D7852974-BBB9-49cb-9162-6A66CDED8EC7}
DEFINE_GUID(IID_IDirectPlayVoiceTransport, 
0xd7852974, 0xbbb9, 0x49cb, 0x91, 0x62, 0x6a, 0x66, 0xcd, 0xed, 0x8e, 0xc7);

//@@END_MSINTERNAL

// {1DFDC8EA-BCF7-41d6-B295-AB64B3B23306}
DEFINE_GUID(IID_IDirectPlayVoiceClient, 
0x1dfdc8ea, 0xbcf7, 0x41d6, 0xb2, 0x95, 0xab, 0x64, 0xb3, 0xb2, 0x33, 0x6);

// {FAA1C173-0468-43b6-8A2A-EA8A4F2076C9}
DEFINE_GUID(IID_IDirectPlayVoiceServer, 
0xfaa1c173, 0x468, 0x43b6, 0x8a, 0x2a, 0xea, 0x8a, 0x4f, 0x20, 0x76, 0xc9);

// {D26AF734-208B-41da-8224-E0CE79810BE1}
DEFINE_GUID(IID_IDirectPlayVoiceTest,
0xd26af734, 0x208b, 0x41da, 0x82, 0x24, 0xe0, 0xce, 0x79, 0x81, 0xb, 0xe1);

/****************************************************************************
 *
 * DirectPlayVoice Compression Type GUIDs
 *
 ****************************************************************************/

// MS-ADPCM 32.8 kbit/s
//
// {699B52C1-A885-46a8-A308-97172419ADC7}
DEFINE_GUID(DPVCTGUID_ADPCM,
0x699b52c1, 0xa885, 0x46a8, 0xa3, 0x8, 0x97, 0x17, 0x24, 0x19, 0xad, 0xc7);

// Microsoft GSM 6.10 13 kbit/s
//
// {24768C60-5A0D-11d3-9BE4-525400D985E7}
DEFINE_GUID(DPVCTGUID_GSM,
0x24768c60, 0x5a0d, 0x11d3, 0x9b, 0xe4, 0x52, 0x54, 0x0, 0xd9, 0x85, 0xe7);

// MS-PCM 64 kbit/s
// 
// {8DE12FD4-7CB3-48ce-A7E8-9C47A22E8AC5}
DEFINE_GUID(DPVCTGUID_NONE,
0x8de12fd4, 0x7cb3, 0x48ce, 0xa7, 0xe8, 0x9c, 0x47, 0xa2, 0x2e, 0x8a, 0xc5);

// Voxware SC03 3.2kbit/s
//
// {7D82A29B-2242-4f82-8F39-5D1153DF3E41}
DEFINE_GUID(DPVCTGUID_SC03,
0x7d82a29b, 0x2242, 0x4f82, 0x8f, 0x39, 0x5d, 0x11, 0x53, 0xdf, 0x3e, 0x41);

// Voxware SC06 6.4kbit/s
//
// {53DEF900-7168-4633-B47F-D143916A13C7}
DEFINE_GUID(DPVCTGUID_SC06,
0x53def900, 0x7168, 0x4633, 0xb4, 0x7f, 0xd1, 0x43, 0x91, 0x6a, 0x13, 0xc7);

// TrueSpeech(TM) 8.6 kbit/s
//
// {D7954361-5A0B-11d3-9BE4-525400D985E7}
DEFINE_GUID(DPVCTGUID_TRUESPEECH,
0xd7954361, 0x5a0b, 0x11d3, 0x9b, 0xe4, 0x52, 0x54, 0x0, 0xd9, 0x85, 0xe7);

// Voxware VR12 1.4kbit/s
//
// {FE44A9FE-8ED4-48bf-9D66-1B1ADFF9FF6D}
DEFINE_GUID(DPVCTGUID_VR12,
0xfe44a9fe, 0x8ed4, 0x48bf, 0x9d, 0x66, 0x1b, 0x1a, 0xdf, 0xf9, 0xff, 0x6d);

// Define the default compression type
#define DPVCTGUID_DEFAULT	DPVCTGUID_SC03

/****************************************************************************
 *
 * DirectPlayVoice Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlayVoiceClient FAR *LPDIRECTPLAYVOICECLIENT, *PDIRECTPLAYVOICECLIENT;
typedef struct IDirectPlayVoiceServer FAR *LPDIRECTPLAYVOICESERVER, *PDIRECTPLAYVOICESERVER;
typedef struct IDirectPlayVoiceTest FAR *LPDIRECTPLAYVOICETEST, *PDIRECTPLAYVOICETEST;
//@@BEGIN_MSINTERNAL
typedef struct IDirectPlayVoiceNotify FAR *LPDIRECTPLAYVOICENOTIFY, *PDIRECTPLAYVOICENOTIFY;
typedef struct IDirectPlayVoiceTransport FAR *LPDIRECTPLAYVOICETRANSPORT, *PDIRECTPLAYVOICETRANSPORT;
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Callback Functions
 *
 ****************************************************************************/
typedef HRESULT (FAR PASCAL *PDVMESSAGEHANDLER)(
    PVOID   pvUserContext,
    DWORD   dwMessageType,
    LPVOID  lpMessage
);

typedef PDVMESSAGEHANDLER LPDVMESSAGEHANDLER;

/****************************************************************************
 *
 * DirectPlayVoice Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

typedef DWORD DVID, *LPDVID, *PDVID;

/****************************************************************************
 *
 * DirectPlayVoice Message Types
 *
 ****************************************************************************/

#define DVMSGID_BASE                        0x0000

#define DVMSGID_MINBASE                     (DVMSGID_CREATEVOICEPLAYER)
#define DVMSGID_CREATEVOICEPLAYER           (DVMSGID_BASE+0x0001)
#define DVMSGID_DELETEVOICEPLAYER           (DVMSGID_BASE+0x0002)
#define DVMSGID_SESSIONLOST                 (DVMSGID_BASE+0x0003)
#define DVMSGID_PLAYERVOICESTART            (DVMSGID_BASE+0x0004)
#define DVMSGID_PLAYERVOICESTOP             (DVMSGID_BASE+0x0005)
#define DVMSGID_RECORDSTART                 (DVMSGID_BASE+0x0006)
#define DVMSGID_RECORDSTOP                  (DVMSGID_BASE+0x0007)
#define DVMSGID_CONNECTRESULT               (DVMSGID_BASE+0x0008)
#define DVMSGID_DISCONNECTRESULT            (DVMSGID_BASE+0x0009)
#define DVMSGID_INPUTLEVEL                  (DVMSGID_BASE+0x000A)
#define DVMSGID_OUTPUTLEVEL                 (DVMSGID_BASE+0x000B)
#define DVMSGID_HOSTMIGRATED                (DVMSGID_BASE+0x000C)
#define DVMSGID_SETTARGETS                  (DVMSGID_BASE+0x000D)
#define DVMSGID_PLAYEROUTPUTLEVEL           (DVMSGID_BASE+0x000E)
#define DVMSGID_LOSTFOCUS                   (DVMSGID_BASE+0x0010)
#define DVMSGID_GAINFOCUS                   (DVMSGID_BASE+0x0011)
#define DVMSGID_LOCALHOSTSETUP				(DVMSGID_BASE+0x0012)
#define DVMSGID_MAXBASE                     (DVMSGID_LOCALHOSTSETUP)

/****************************************************************************
 *
 * DirectPlayVoice Constants
 *
 ****************************************************************************/

//
// Buffer Aggresiveness Value Ranges
//
#define DVBUFFERAGGRESSIVENESS_MIN          0x00000001
#define DVBUFFERAGGRESSIVENESS_MAX          0x00000064
#define DVBUFFERAGGRESSIVENESS_DEFAULT      0x00000000

// 
// Buffer Quality Value Ranges
//
#define DVBUFFERQUALITY_MIN                 0x00000001
#define DVBUFFERQUALITY_MAX                 0x00000064
#define DVBUFFERQUALITY_DEFAULT             0x00000000

#define DVID_SYS                0

//
// Used to identify the session host in client/server
//
#define DVID_SERVERPLAYER       1

//
// Used to target all players
//
#define DVID_ALLPLAYERS         0

//
// Used to identify the main buffer
//
#define DVID_REMAINING          0xFFFFFFFF

// 
// Input level range
//
#define DVINPUTLEVEL_MIN                    0x00000000
#define DVINPUTLEVEL_MAX                    0x00000063	// 99 decimal

#define DVNOTIFYPERIOD_MINPERIOD            20


#define DVPLAYBACKVOLUME_DEFAULT            DSBVOLUME_MAX

#define DVRECORDVOLUME_LAST                 0x00000001


//
// Use the default value
//
#define DVTHRESHOLD_DEFAULT               0xFFFFFFFF

//
// Threshold Ranges
//
#define DVTHRESHOLD_MIN                   0x00000000
#define DVTHRESHOLD_MAX                   0x00000063	// 99 decimal

//
// Threshold field is not used 
//
#define DVTHRESHOLD_UNUSED                0xFFFFFFFE

//
// Session Types
//
#define DVSESSIONTYPE_PEER                  0x00000001
#define DVSESSIONTYPE_MIXING                0x00000002
#define DVSESSIONTYPE_FORWARDING            0x00000003
#define DVSESSIONTYPE_ECHO                  0x00000004
//@@BEGIN_MSINTERNAL
#define DVSESSIONTYPE_MAX						0x00000005
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Flags
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
// The flag to disable the config check in Connect
// -- required by the setup program!
#define DVFLAGS_NOQUERY                     0x00000004
#define DVCLIENTCONFIG_AUTOVOLUMERESET      0x00000080
// Used to indicate that waveids are being passed
// to CheckAudioSetup instead of guids. Used by the
// control panel's Voice Test button.
#define DVFLAGS_WAVEIDS                     0x80000000
// The flag to put the recording subsystem into
// test mode. Used by the setup/test program.
#define DVSOUNDCONFIG_TESTMODE              0x80000000
//@@END_MSINTERNAL

// 
// Enable automatic adjustment of the recording volume
//
#define DVCLIENTCONFIG_AUTORECORDVOLUME     0x00000008

//
// Enable automatic voice activation
//
#define DVCLIENTCONFIG_AUTOVOICEACTIVATED   0x00000020

// 
// Enable echo suppression
//
#define DVCLIENTCONFIG_ECHOSUPPRESSION      0x08000000

// 
// Voice Activation manual mode
//
#define DVCLIENTCONFIG_MANUALVOICEACTIVATED 0x00000004

// 
// Only playback voices that have buffers created for them
//
#define DVCLIENTCONFIG_MUTEGLOBAL           0x00000010

// 
// Mute the playback
//
#define DVCLIENTCONFIG_PLAYBACKMUTE         0x00000002

//
// Mute the recording 
//
#define DVCLIENTCONFIG_RECORDMUTE           0x00000001

// 
// Complete the operation before returning
//
#define DVFLAGS_SYNC                        0x00000001

// 
// Just check to see if wizard has been run, and if so what it's results were
//
#define DVFLAGS_QUERYONLY                   0x00000002

//
// Shutdown the voice session without migrating the host
//
#define DVFLAGS_NOHOSTMIGRATE               0x00000008

// 
// Allow the back button to be enabled in the wizard
//
#define DVFLAGS_ALLOWBACK                   0x00000010

//
// Disable host migration in the voice session
//
#define DVSESSION_NOHOSTMIGRATION           0x00000001

// 
// Server controlled targetting
//
#define DVSESSION_SERVERCONTROLTARGET       0x00000002
//@@BEGIN_MSINTERNAL
#define DVSESSION_MAX							0x00000004
//@@END_MSINTERNAL

//
// Use DirectSound Normal Mode instead of priority 
//
#define DVSOUNDCONFIG_NORMALMODE            0x00000001

//
// Automatically select the microphone
//
#define DVSOUNDCONFIG_AUTOSELECT            0x00000002

// 
// Run in half duplex mode
//
#define DVSOUNDCONFIG_HALFDUPLEX            0x00000004

// 
// No volume controls are available for the recording device
//
#define DVSOUNDCONFIG_NORECVOLAVAILABLE     0x00000010

// 
// Disable capture sharing
//
#define DVSOUNDCONFIG_NOFOCUS               0x20000000

// 
// Set system conversion quality to high
//
#define DVSOUNDCONFIG_SETCONVERSIONQUALITY	0x00000008

//
// Enable strict focus mode
// 
#define DVSOUNDCONFIG_STRICTFOCUS           0x40000000

//
// Player is in half duplex mode
//
#define DVPLAYERCAPS_HALFDUPLEX             0x00000001

// 
// Specifies that player is the local player
//
#define DVPLAYERCAPS_LOCAL                  0x00000002
//@@BEGIN_MSINTERNAL
#define DVPLAYERCAPS_MAX                    0x00000004
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlayVoice Structures (Non-Message)
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL

// DVTRANSPORTINFO
//
typedef struct
{
    // = sizeof( DVTRANSPORTINFO )
    DWORD			dwSize;			
    // Combination of following flags:
    // DVTRANSPORT_MIGRATEHOST, DVTRANSPORT_MULTICAST
    // DVTRANSPORT_LOCALHOST
	DWORD			dwFlags;		
	// Session Type the transport is running.  One of:
	// DVTRANSPORT_SESSION_PEERTOPEER
	// DVTRANSPORT_SESSION_CLIENTSERVER
	DWORD			dwSessionType;	
	// ID of the player (Regular ID, not system) that
	// is the sesion host.
	DVID			dvidSessionHost;
	// ID of the local player (Regular ID, not system)
	DVID			dvidLocalID;	
	// Maximum # of players allowed in the session,
	// 0 = unlimited.
	DWORD			dwMaxPlayers;	
} DVTRANSPORTINFO, *LPDVTRANSPORTINFO, *PDVTRANSPORTINFO;
//@@END_MSINTERNAL

//
// DirectPlayVoice Caps
// (GetCaps / SetCaps)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Caps flags
} DVCAPS, *LPDVCAPS, *PDVCAPS;

//
// DirectPlayVoice Client Configuration
// (Connect / GetClientConfig)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Flags for client config (DVCLIENTCONFIG_...)
    LONG    lRecordVolume;          // Recording volume 
    LONG    lPlaybackVolume;        // Playback volume
    DWORD   dwThreshold;          // Voice Activation Threshold
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggressiveness
    DWORD   dwNotifyPeriod;         // Period of notification messages (ms)
} DVCLIENTCONFIG, *LPDVCLIENTCONFIG, *PDVCLIENTCONFIG;

//
// DirectPlayVoice Compression Type Information
// (GetCompressionTypes)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    GUID    guidType;               // GUID that identifies this compression type
    LPWSTR  lpszName;               // String name of this compression type
    LPWSTR  lpszDescription;        // Description for this compression type
    DWORD   dwFlags;                // Flags for this compression type
    DWORD   dwMaxBitsPerSecond;		// Maximum # of bit/s this compression type uses
} DVCOMPRESSIONINFO, *LPDVCOMPRESSIONINFO, *PDVCOMPRESSIONINFO;

//
// DirectPlayVoice Session Description
// (Host / GetSessionDesc)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Session flags (DVSESSION_...)
    DWORD   dwSessionType;          // Session type (DVSESSIONTYPE_...)
    GUID    guidCT;                 // Compression Type to use
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggresiveness
} DVSESSIONDESC, *LPDVSESSIONDESC, *PDVSESSIONDESC;

// 
// DirectPlayVoice Client Sound Device Configuration
// (Connect / GetSoundDeviceConfig)
//
typedef struct
{
    DWORD                   dwSize;                 // Size of this structure
    DWORD                   dwFlags;                // Flags for sound config (DVSOUNDCONFIG_...)
    GUID                    guidPlaybackDevice;     // GUID of the playback device to use
    LPDIRECTSOUND           lpdsPlaybackDevice;     // DirectSound Object to use (optional)
    GUID                    guidCaptureDevice;      // GUID of the capture device to use
    LPDIRECTSOUNDCAPTURE    lpdsCaptureDevice;      // DirectSoundCapture Object to use (optional)
    HWND                    hwndAppWindow;          // HWND of your application's top-level window
    LPDIRECTSOUNDBUFFER     lpdsMainBuffer;         // DirectSoundBuffer to use for playback (optional)
    DWORD                   dwMainBufferFlags;      // Flags to pass to Play() on the main buffer
    DWORD                   dwMainBufferPriority;   // Priority to set when calling Play() on the main buffer
} DVSOUNDDEVICECONFIG, *LPDVSOUNDDEVICECONFIG, *PDVSOUNDDEVICECONFIG;

/****************************************************************************
 *
 * DirectPlayVoice message handler call back structures
 *
 ****************************************************************************/

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Connect() call
} DVMSG_CONNECTRESULT, *LPDVMSG_CONNECTRESULT, *PDVMSG_CONNECTRESULT;

//
// A new player has entered the voice session
// (DVMSGID_CREATEVOICEPLAYER)
// 
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who joined
    DWORD   dwFlags;                        // Player flags (DVPLAYERCAPS_...)
    PVOID	pvPlayerContext;                // Context value for this player (user set)
} DVMSG_CREATEVOICEPLAYER, *LPDVMSG_CREATEVOICEPLAYER, *PDVMSG_CREATEVOICEPLAYER;

//
// A player has left the voice session
// (DVMSGID_DELETEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who left
    PVOID	pvPlayerContext;                // Context value for the player
} DVMSG_DELETEVOICEPLAYER, *LPDVMSG_DELETEVOICEPLAYER, *PDVMSG_DELETEVOICEPLAYER;

//
// Result of the Disconnect() call.  (If it wasn't called Async)
// (DVMSGID_DISCONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Disconnect() call
} DVMSG_DISCONNECTRESULT, *LPDVMSG_DISCONNECTRESULT, *PDVMSG_DISCONNECTRESULT;

// 
// The voice session host has migrated.
// (DVMSGID_HOSTMIGRATED) 
//
typedef struct
{
    DWORD                   dwSize;         // Size of this structure
    DVID                    dvidNewHostID;  // DVID of the player who is now the host
    LPDIRECTPLAYVOICESERVER pdvServerInterface;
                                            // Pointer to the new host object (if local player is now host)
} DVMSG_HOSTMIGRATED, *LPDVMSG_HOSTMIGRATED, *PDVMSG_HOSTMIGRATED;

//
// The current input level / recording volume on the local machine
// (DVMSGID_INPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the audio
    LONG    lRecordVolume;                  // Current recording volume
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_INPUTLEVEL, *LPDVMSG_INPUTLEVEL, *PDVMSG_INPUTLEVEL;

//
// The local client is about to become the new host
// (DVMSGID_LOCALHOSTSETUP)
//
typedef struct
{
	DWORD				dwSize;             // Size of this structure
	PVOID				pvContext;			// Context value to be passed to Initialize() of new host object
	PDVMESSAGEHANDLER	pMessageHandler;	// Message handler to be used by new host object
} DVMSG_LOCALHOSTSETUP, *LPDVMSG_LOCALHOSTSETUP, *PDVMSG_LOCALHOSTSETUP;

//
// The current output level for the combined output of all incoming streams.
// (DVMSGID_OUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the output
    LONG    lOutputVolume;                  // Current playback volume
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_OUTPUTLEVEL, *LPDVMSG_OUTPUTLEVEL, *PDVMSG_OUTPUTLEVEL;

//
// The current peak level of an individual player's incoming audio stream as it is
// being played back.
// (DVMSGID_PLAYEROUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;                   // DVID of the player
    DWORD   dwPeakLevel;                    // Peak level of the player's stream
    PVOID	pvPlayerContext;                // Context value for the player
} DVMSG_PLAYEROUTPUTLEVEL, *LPDVMSG_PLAYEROUTPUTLEVEL, *PDVMSG_PLAYEROUTPUTLEVEL;

// 
// An audio stream from the specified player has started playing back on the local client.
// (DVMSGID_PLAYERVOICESTART).
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the Player 
    PVOID	pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTART, *LPDVMSG_PLAYERVOICESTART, *PDVMSG_PLAYERVOICESTART;

//
// The audio stream from the specified player has stopped playing back on the local client.
// (DVMSGID_PLAYERVOICESTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the player
    PVOID	pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTOP, *LPDVMSG_PLAYERVOICESTOP, *PDVMSG_PLAYERVOICESTOP;

// 
// Transmission has started on the local machine
// (DVMSGID_RECORDSTART)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to start
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTART, *LPDVMSG_RECORDSTART, *PDVMSG_RECORDSTART;

// 
// Transmission has stopped on the local machine
// (DVMSGID_RECORDSTOP)
// 
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to stop
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTOP, *LPDVMSG_RECORDSTOP, *PDVMSG_RECORDSTOP;

// 
// The voice session has been lost
// (DVMSGID_SESSIONLOST)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;	                    // Reason the session was disconnected
} DVMSG_SESSIONLOST, *LPDVMSG_SESSIONLOST, *PDVMSG_SESSIONLOST;

//
// The target list has been updated for the local client
// (DVMSGID_SETTARGETS)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwNumTargets;                   // # of targets 
    PDVID   pdvidTargets;                   // An array of DVIDs specifying the current targets
} DVMSG_SETTARGETS, *LPDVMSG_SETTARGETS, *PDVMSG_SETTARGETS;
 
//@@BEGIN_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Transport Defines / Types / Constants -- MS INTERNAL
 *
 ****************************************************************************/

// Use waveOUT instead of DS
#define DVSOUNDCONFIG_FORCEWAVEOUT          0x10000000
#define DVSOUNDCONFIG_ALLOWWAVEOUT	 	    0x20000000

// Use waveIN instead of DSC
#define DVSOUNDCONFIG_FORCEWAVEIN		    0x40000000
#define DVSOUNDCONFIG_ALLOWWAVEIN		    0x80000000

// Transport session is peer-to-peer
#define DVTRANSPORT_SESSION_PEERTOPEER	    0x00000001

// Transport session is client/server
#define DVTRANSPORT_SESSION_CLIENTSERVER    0x00000002

// Host can migrate
#define DVTRANSPORT_MIGRATEHOST				0x00000001

// Multicast optimizations are enabled
#define DVTRANSPORT_MULTICAST				0x00000002

// The local player is the host of the session
#define DVTRANSPORT_LOCALHOST				0x00000004

// Send the message guaranteed
#define DVTRANSPORT_SEND_GUARANTEED			0x00000001
#define DVTRANSPORT_SEND_SYNC				0x00000002

#define DVPEFLAGS_FIRSTPLAYER				0x00000001

#define DVTRANSPORT_OBJECTTYPE_SERVER       0x00000001
#define DVTRANSPORT_OBJECTTYPE_CLIENT       0x00000002
#define DVTRANSPORT_OBJECTTYPE_BOTH         (DVTRANSPORT_OBJECTTYPE_SERVER | DVTRANSPORT_OBJECTTYPE_CLIENT)

typedef struct _DVTRANSPORT_BUFFERDESC
{
    DWORD   dwBufferSize;
    PBYTE   pBufferData;
    LONG    lRefCount;
    PVOID   pvContext;
    DWORD   dwObjectType;
    DWORD   dwFlags;
} DVTRANSPORT_BUFFERDESC, *PDVTRANSPORT_BUFFERDESC;

/*
 * DIRECTVOICENOTIFY DEFINES
 *
 * Used to identify the type of notification in calls
 * to IDirectPlayVoiceNotify::NotifyEvent
 */

// No longer used
#define DVEVENT_STARTSESSION				0x00000001

// If the transport session is lost or shutdown
#define DVEVENT_STOPSESSION					0x00000002

// A player was added to the system, 
// Param1 = DVID of new player
// Param2 = Player context (set by handler and then returned)
#define DVEVENT_ADDPLAYER					0x00000003

// A player disconnected.  
// Param1 = DVID of disconnected player
// Param1 = Player context
#define DVEVENT_REMOVEPLAYER				0x00000004

// A group was created.  Param1 = DVID of created group
#define DVEVENT_CREATEGROUP					0x00000005

// A group was deleted.  Param1 = DVID of deleted group
#define DVEVENT_DELETEGROUP					0x00000006

// Player was added to a group.
// Param1 = DVID of group    Param2 = DVID of player
#define DVEVENT_ADDPLAYERTOGROUP			0x00000007

// Player was removed from the group
// Param1 = DVID of group    Param2 = DVID of player
#define DVEVENT_REMOVEPLAYERFROMGROUP		0x00000008

// Called when the host migrates
// Param1 = DVID of new host (player ID, not system ID)
#define DVEVENT_MIGRATEHOST					0x00000009

// Called when a buffer the voice layer has given
// the transport is completed.  
// Param1 = pointer to DVEVENTMSG_SENDCOMPLETE structure
// 
#define DVEVENT_SENDCOMPLETE                0x0000000A

typedef struct _DVEVENTMSG_SENDCOMPLETE
{
    LPVOID                  pvUserContext;
    HRESULT                 hrSendResult;
} DVEVENTMSG_SENDCOMPLETE, *PDVEVENTMSG_SENDCOMPLETE;

//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlayVoice Functions
 *
 ****************************************************************************/

/*
 * 
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay voice objects.  
 *
 * extern HRESULT WINAPI DirectPlayVoiceCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown); 
 *
 */

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceClient
DECLARE_INTERFACE_( IDirectPlayVoiceClient, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    /*** IDirectPlayVoiceClient methods ***/
    STDMETHOD_(HRESULT, Initialize)   (THIS_ LPUNKNOWN, PDVMESSAGEHANDLER, PVOID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, Connect)      (THIS_ PDVSOUNDDEVICECONFIG, PDVCLIENTCONFIG, DWORD ) PURE;
    STDMETHOD_(HRESULT, Disconnect)   (THIS_ DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, GetClientConfig)(THIS_ PDVCLIENTCONFIG ) PURE;
    STDMETHOD_(HRESULT, SetClientConfig)(THIS_ PDVCLIENTCONFIG ) PURE;
    STDMETHOD_(HRESULT, GetCaps) 		(THIS_ PDVCAPS ) PURE;
    STDMETHOD_(HRESULT, GetCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetTransmitTargets)( THIS_ PDVID, DWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetTransmitTargets)( THIS_ PDVID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, Create3DSoundBuffer)( THIS_ DVID, LPDIRECTSOUNDBUFFER, DWORD, DWORD, LPDIRECTSOUND3DBUFFER * ) PURE;
    STDMETHOD_(HRESULT, Delete3DSoundBuffer)( THIS_ DVID, LPDIRECTSOUND3DBUFFER * ) PURE;
    STDMETHOD_(HRESULT, SetNotifyMask)( THIS_ PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSoundDeviceConfig)( THIS_ PDVSOUNDDEVICECONFIG, PDWORD ) PURE;
};

//@@BEGIN_MSINTERNAL
#undef INTERFACE
#define INTERFACE IDirectPlayVoiceNotify
DECLARE_INTERFACE_( IDirectPlayVoiceNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceNotify methods ***/

    // Initialize
    //
    // Initializes the DirectPlayVoice interface associated with this
    // interface.  During this call DirectPlayVoice will call
    // GetSessionInfo on the associated Transport interface.
    //
	STDMETHOD_(HRESULT,Initialize)(THIS ) PURE;

	// NotifyEvent
	//
	// Called when an event occurs that DirectPlayVoice needs to be informed
	// of.  See descriptions of DVEVENT_XXXXX for how the parameters are
	// used for each message.
	//
	// DWORD - Type of message (DVEVENT_XXXXXX)
	// DWORD - Param1
	// DWORD - Param2
	//
	STDMETHOD_(HRESULT,NotifyEvent)(THIS_ DWORD, DWORD_PTR, DWORD_PTR) PURE;

	// ReceiveSpeechMessage
	//
	// Called when a message is received by DirectPlay that is for
	// DirectPlayVoice.
	//
	// DVID - Source of the message
	// LPVOID - Pointer to message buffer
	// DWORD - Size of the received message
	//
	STDMETHOD_(HRESULT,ReceiveSpeechMessage)(THIS_ DVID, DVID, PVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceTransport
DECLARE_INTERFACE_( IDirectPlayVoiceTransport, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
	/*** IDirectPlayVoiceTransport methods ***/

	// Advise
	//
	// Advises the transport to call us back via the interface passed in the
	// LLPUNKNOWN parameter.  QueryInterface on the LPUNKNOWN for a
	// IDirectPlayVoiceNotify.  Must call IDirectPlayVoiceNotify::INitialize
	// on the interface before returning.
	//
	// LPUNKNOWN - IUnknown interface for the IDirectPlayVoiceNotify to
	// 			   make notifications on.
	// DWORD - Voice Object Type (DVTRANSPORT_OBJECTTYPE_XXXX)
	//
	STDMETHOD_(HRESULT, Advise)		(THIS_ LPUNKNOWN, DWORD) PURE;

	// UnAdvise
	//
	// Tells the transport that we no longer need to be called back on our
	// notify interface.  The transport should Release the instance of the
	// notify interface that they have.
	//
	// DWORD - Voice Object Type (DVTRANSPORT_OBJECTTYPE_XXXX)
	//
	STDMETHOD_(HRESULT, UnAdvise)		(THIS_ DWORD) PURE;

	// IsGroupMember
	//
	// This function returns DP_OK if the specified user is a member of
	// the specified group.
	//
	// DVID - DVID of the group to check
	// DVID - DVID of the player
	//
	STDMETHOD_(HRESULT, IsGroupMember)(THIS_ DVID, DVID ) PURE;

	// SendSpeech
	//
	// Transmits a message from the specified user ID to the specified user ID.
	// (Speech specific).  Messages sent through this interface are always
	// sent ASYNC and if the DVTRANSPORT_SEND_GUARANTEED flag is specified
	// then the message MUST be sent guaranteed.
	//
	// DVID - ID of the player this will be from.
	// DVID - ID of the player this will be sent to.
	// LPVOID - Pointer to the data to send
	// DWORD - Size of the data to send, in bytes
	// LPVOID - User context for send
	// DWORD - FLags (Combination of DVTRANSPORT_SEND_GUARANTEED).
	//
	STDMETHOD_(HRESULT, SendSpeech)(THIS_ DVID, DVID, PDVTRANSPORT_BUFFERDESC, LPVOID, DWORD ) PURE;

	// GetSessionInfo
	//
	// Fills the passed structure with details on the session that is running
	// on the transport object.  See description of DVTRANSPORTINFO for details.
	//
	STDMETHOD_(HRESULT, GetSessionInfo)(THIS_ PDVTRANSPORTINFO ) PURE;

	// IsValidEntity
	//
	// Checks to see if specified user is valid player or group in session
	// DVID = ID of the entity to check
	// LPBOOL = Pointer to BOOL to place result.  TRUE for Valid Player/
	//          Group, FALSE if it is not.
	//
	// Not needed in Client/Server Mode
	STDMETHOD_(HRESULT, IsValidEntity)(THIS_ DVID, PBOOL ) PURE;

	// SendSpeechEx
	//
	// Transmits a message from the specified user ID to the specified user ID.
	// (Speech specific).  Messages sent through this interface are always
	// sent ASYNC and if the DVTRANSPORT_SEND_GUARANTEED flag is specified
	// then the message MUST be sent guaranteed.
	//
	// DVID - ID of the player this will be from.
	// DWORD - count on entries in (DVID *)[] array
	// LPDVID - Array of send targets
	// LPVOID - Pointer to the data to send
	// DWORD - Size of the data to send, in bytes
	// LPVOID - User context for send
	// DWORD - Flags (Combination of DVTRANSPORT_SEND_GUARANTEED).
	//
	STDMETHOD_(HRESULT, SendSpeechEx)(THIS_ DVID, DWORD, UNALIGNED DVID *, PDVTRANSPORT_BUFFERDESC, LPVOID, DWORD ) PURE;	

	// IsValidGroup
	//
	// Checks to see if the specified ID is a valid Group ID
	//
	// DVID = ID of the entity to check
	//
	STDMETHOD_(HRESULT, IsValidGroup)(THIS_ DVID, PBOOL ) PURE;

	// IsValidPlayer
	//
	// Checks to see if the specified ID is a valid Player ID
	//
	// DVID = ID of the entity to check
	//
	STDMETHOD_(HRESULT, IsValidPlayer)(THIS_ DVID, PBOOL ) PURE;	

};


//@@END_MSINTERNAL

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceServer
DECLARE_INTERFACE_( IDirectPlayVoiceServer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceServer methods ***/
    STDMETHOD_(HRESULT, Initialize)   (THIS_ LPUNKNOWN, PDVMESSAGEHANDLER, PVOID, LPDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, StartSession)  (THIS_ PDVSESSIONDESC, DWORD ) PURE;
    STDMETHOD_(HRESULT, StopSession)   (THIS_ DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, SetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, GetCaps) 		(THIS_ PDVCAPS ) PURE;
    STDMETHOD_(HRESULT, GetCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetTransmitTargets)( THIS_ DVID, PDVID, DWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetTransmitTargets)( THIS_ DVID, PDVID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetNotifyMask)( THIS_ PDWORD, DWORD ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceTest
DECLARE_INTERFACE_( IDirectPlayVoiceTest, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceTest methods ***/
    STDMETHOD_(HRESULT, CheckAudioSetup) (THIS_ const GUID *,  const GUID * , HWND, DWORD ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayVoiceClient_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceClient_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceClient_Release(p)                   (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceClient_Initialize(p,a,b,c,d,e)      (p)->lpVtbl->Initialize(p,a,b,c,d,e)
#define IDirectPlayVoiceClient_Connect(p,a,b,c)             (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayVoiceClient_Disconnect(p,a)              (p)->lpVtbl->Disconnect(p,a)
#define IDirectPlayVoiceClient_GetSessionDesc(p,a)          (p)->lpVtbl->GetSessionDesc(p,a)
#define IDirectPlayVoiceClient_GetClientConfig(p,a)         (p)->lpVtbl->GetClientConfig(p,a)
#define IDirectPlayVoiceClient_SetClientConfig(p,a)         (p)->lpVtbl->SetClientConfig(p,a)
#define IDirectPlayVoiceClient_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlayVoiceClient_GetCompressionTypes(p,a,b,c,d) (p)->lpVtbl->GetCompressionTypes(p,a,b,c,d)
#define IDirectPlayVoiceClient_SetTransmitTargets(p,a,b,c)  (p)->lpVtbl->SetTransmitTargets(p,a,b,c)
#define IDirectPlayVoiceClient_GetTransmitTargets(p,a,b,c)  (p)->lpVtbl->GetTransmitTargets(p,a,b,c)
#define IDirectPlayVoiceClient_Create3DSoundBuffer(p,a,b,c,d,e)   (p)->lpVtbl->Create3DSoundBuffer(p,a,b,c,d,e)
#define IDirectPlayVoiceClient_Delete3DSoundBuffer(p,a,b)   (p)->lpVtbl->Delete3DSoundBuffer(p,a,b)
#define IDirectPlayVoiceClient_SetNotifyMask(p,a,b)         (p)->lpVtbl->SetNotifyMask(p,a,b)
#define IDirectPlayVoiceClient_GetSoundDeviceConfig(p,a,b)  (p)->lpVtbl->GetSoundDeviceConfig(p,a,b)

#define IDirectPlayVoiceServer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceServer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceServer_Release(p)                   (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceServer_Initialize(p,a,b,c,d,e)      (p)->lpVtbl->Initialize(p,a,b,c,d,e)
#define IDirectPlayVoiceServer_StartSession(p,a,b)          (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayVoiceServer_StopSession(p,a)             (p)->lpVtbl->StopSession(p,a)
#define IDirectPlayVoiceServer_GetSessionDesc(p,a)          (p)->lpVtbl->GetSessionDesc(p,a)
#define IDirectPlayVoiceServer_SetSessionDesc(p,a)          (p)->lpVtbl->SetSessionDesc(p,a)
#define IDirectPlayVoiceServer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlayVoiceServer_GetCompressionTypes(p,a,b,c,d) (p)->lpVtbl->GetCompressionTypes(p,a,b,c,d)
#define IDirectPlayVoiceServer_SetTransmitTargets(p,a,b,c,d)	(p)->lpVtbl->SetTransmitTargets(p,a,b,c,d)
#define IDirectPlayVoiceServer_GetTransmitTargets(p,a,b,c,d)	(p)->lpVtbl->GetTransmitTargets(p,a,b,c,d)
#define IDirectPlayVoiceServer_SetNotifyMask(p,a,b)         (p)->lpVtbl->SetNotifyMask(p,a,b)
#define IDirectPlayVoiceTest_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceTest_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceTest_Release(p)                	    (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceTest_CheckAudioSetup(p,a,b,c,d)     (p)->lpVtbl->CheckAudioSetup(p,a,b,c,d)

//@@BEGIN_MSINTERNAL
#define IDirectPlayVoiceNotify_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceNotify_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceNotify_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceNotify_Initialize(p)                (p)->lpVtbl->Initialize(p)
#define IDirectPlayVoiceNotify_NotifyEvent(p,a,b,c)         (p)->lpVtbl->NotifyEvent(p,a,b,c)
#define IDirectPlayVoiceNotify_ReceiveSpeechMessage(p,a,b,c,d) (p)->lpVtbl->ReceiveSpeechMessage(p,a,b,c,d)

#define IDirectPlayVoiceTransport_QueryInterface(p,a,b)     (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceTransport_AddRef(p)                 (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceTransport_Release(p)                (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceTransport_Advise(p,a,b)             (p)->lpVtbl->Advise(p,a,b)
#define IDirectPlayVoiceTransport_UnAdvise(p,a)             (p)->lpVtbl->UnAdvise(p,a)
#define IDirectPlayVoiceTransport_IsGroupMember(p,a,b)      (p)->lpVtbl->IsGroupMember(p,a,b)
#define IDirectPlayVoiceTransport_SendSpeech(p,a,b,c,d,e)   (p)->lpVtbl->SendSpeech(p,a,b,c,d,e)
#define IDirectPlayVoiceTransport_GetSessionInfo(p,a)       (p)->lpVtbl->GetSessionInfo(p,a)
#define IDirectPlayVoiceTransport_IsValidEntity(p,a,b)      (p)->lpVtbl->IsValidEntity(p,a,b)
#define IDirectPlayVoiceTransport_SendSpeechEx(p,a,b,c,d,e,f) (p)->lpVtbl->SendSpeechEx(p,a,b,c,d,e,f)
#define IDirectPlayVoiceTransport_IsValidGroup(p,a,b)       (p)->lpVtbl->IsValidGroup(p,a,b)
#define IDirectPlayVoiceTransport_IsValidPlayer(p,a,b)      (p)->lpVtbl->IsValidPlayer(p,a,b)
#define IDirectPlayVoiceTransport_GetPlayerContext(p,a,b,c) (p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define IDirectPlayVoiceTransport_SetPlayerContext(p,a,b,c) (p)->lpVtbl->SetPlayerContext(p,a,b,c)
//@@END_MSINTERNAL

#else /* C++ */

#define IDirectPlayVoiceClient_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectPlayVoiceClient_AddRef(p)                    (p)->AddRef()
#define IDirectPlayVoiceClient_Release(p)               	(p)->Release()

#define IDirectPlayVoiceClient_Initialize(p,a,b,c,d,e)      (p)->Initialize(a,b,c,d,e)
#define IDirectPlayVoiceClient_Connect(p,a,b,c)             (p)->Connect(a,b,c)
#define IDirectPlayVoiceClient_Disconnect(p,a)              (p)->Disconnect(a)
#define IDirectPlayVoiceClient_GetSessionDesc(p,a)          (p)->GetSessionDesc(a)
#define IDirectPlayVoiceClient_GetClientConfig(p,a)         (p)->GetClientConfig(a)
#define IDirectPlayVoiceClient_SetClientConfig(p,a)         (p)->SetClientConfig(a)
#define IDirectPlayVoiceClient_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectPlayVoiceClient_GetCompressionTypes(p,a,b,c,d) (p)->GetCompressionTypes(a,b,c,d)
#define IDirectPlayVoiceClient_SetTransmitTargets(p,a,b,c)  (p)->SetTransmitTargets(a,b,c)
#define IDirectPlayVoiceClient_GetTransmitTargets(p,a,b,c)  (p)->GetTransmitTargets(a,b,c)
#define IDirectPlayVoiceClient_Create3DSoundBuffer(p,a,b,c,d,e)   (p)->Create3DSoundBuffer(a,b,c,d,e)
#define IDirectPlayVoiceClient_Delete3DSoundBuffer(p,a,b)   (p)->Delete3DSoundBuffer(a,b)
#define IDirectPlayVoiceClient_SetNotifyMask(p,a,b)         (p)->SetNotifyMask(a,b)
#define IDirectPlayVoiceClient_GetSoundDeviceConfig(p,a,b)    (p)->GetSoundDeviceConfig(a,b)

#define IDirectPlayVoiceServer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectPlayVoiceServer_AddRef(p)                    (p)->AddRef()
#define IDirectPlayVoiceServer_Release(p)                   (p)->Release()

#define IDirectPlayVoiceServer_Initialize(p,a,b,c,d,e)      (p)->Initialize(a,b,c,d,e)
#define IDirectPlayVoiceServer_StartSession(p,a,b)          (p)->StartSession(a,b)
#define IDirectPlayVoiceServer_StopSession(p,a)             (p)->StopSession(a)
#define IDirectPlayVoiceServer_GetSessionDesc(p,a)            (p)->GetSessionDesc(a)
#define IDirectPlayVoiceServer_SetSessionDesc(p,a)            (p)->SetSessionDesc(a)
#define IDirectPlayVoiceServer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectPlayVoiceServer_GetCompressionTypes(p,a,b,c,d) (p)->GetCompressionTypes(a,b,c,d)
#define IDirectPlayVoiceServer_SetTransmitTargets(p,a,b,c,d) (p)->SetTransmitTargets(a,b,c,d)
#define IDirectPlayVoiceServer_GetTransmitTargets(p,a,b,c,d) (p)->GetTransmitTargets(a,b,c,d)
#define IDirectPlayVoiceServer_SetNotifyMask(p,a,b)         (p)->SetNotifyMask(a,b)

#define IDirectPlayVoiceTest_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayVoiceTest_AddRef(p)                      (p)->AddRef()
#define IDirectPlayVoiceTest_Release(p)                     (p)->Release()
#define IDirectPlayVoiceTest_CheckAudioSetup(p,a,b,c,d)     (p)->CheckAudioSetup(a,b,c,d)

//@@BEGIN_MSINTERNAL
#define IDirectPlayVoiceNotify_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDirectPlayVoiceNotify_AddRef(p)               		(p)->AddRef()
#define IDirectPlayVoiceNotify_Release(p)              		(p)->Release()
#define IDirectPlayVoiceNotify_Initialize(p)				(p)->Initialize()
#define IDirectPlayVoiceNotify_NotifyEvent(p,a,b,c)			(p)->NotifyEvent(a,b,c)
#define IDirectPlayVoiceNotify_ReceiveSpeechMessage(p,a,b,c,d) (p)->ReceiveSpeechMessage(a,b,c,d)

#define IDirectPlayVoiceTransport_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDirectPlayVoiceTransport_AddRef(p)					(p)->AddRef()
#define IDirectPlayVoiceTransport_Release(p)				(p)->Release()
#define IDirectPlayVoiceTransport_Advise(p,a,b)				(p)->Advise(a,b)
#define IDirectPlayVoiceTransport_UnAdvise(p,a)				(p)->UnAdvise(a)
#define IDirectPlayVoiceTransport_IsGroupMember(p,a,b) 		(p)->IsGroupMember(a,b)
#define IDirectPlayVoiceTransport_SendSpeech(p,a,b,c,d,e) 	(p)->SendSpeech(a,b,c,d,e)
#define IDirectPlayVoiceTransport_GetSessionInfo(p,a)  		(p)->GetSessionInfo(a)
#define IDirectPlayVoiceTransport_IsValidEntity(p,a,b)		(p)->IsValidEntity(a,b)
#define IDirectPlayVoiceTransport_SendSpeechEx(p,a,b,c,d,e,f) (p)->SendSpeechEx(a,b,c,d,e,f)
#define IDirectPlayVoiceTransport_IsValidGroup(p,a,b)		(p)->IsValidGroup(a,b)
#define IDirectPlayVoiceTransport_IsValidPlayer(p,a,b)		(p)->IsValidPlayer(a,b)
#define IDirectPlayVoiceTransport_GetPlayerContext(p,a,b,c) (p)->GetPlayerContext(a,b,c)
#define IDirectPlayVoiceTransport_SetPlayerContext(p,a,b,c) (p)->SetPlayerContext(a,b,c)

//@@END_MSINTERNAL

#endif


/****************************************************************************
 *
 * DIRECTPLAYVOICE ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )          MAKE_HRESULT( 1, _FACDPV, code )

#define DV_OK                           S_OK
#define DV_FULLDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x0005 )
#define DV_HALFDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x000A )
#define DV_PENDING						MAKE_HRESULT( 0, _FACDPV,  0x0010 )

#define DVERR_BUFFERTOOSMALL            MAKE_DVHRESULT(  0x001E )
#define DVERR_EXCEPTION                 MAKE_DVHRESULT(  0x004A )
#define DVERR_GENERIC                   E_FAIL
#define DVERR_INVALIDFLAGS              MAKE_DVHRESULT( 0x0078 )
#define DVERR_INVALIDOBJECT             MAKE_DVHRESULT( 0x0082 )
#define DVERR_INVALIDPARAM              E_INVALIDARG
#define DVERR_INVALIDPLAYER             MAKE_DVHRESULT( 0x0087 )
#define DVERR_INVALIDGROUP              MAKE_DVHRESULT( 0x0091 )
#define DVERR_INVALIDHANDLE             MAKE_DVHRESULT( 0x0096 )
#define DVERR_OUTOFMEMORY               E_OUTOFMEMORY
#define DVERR_PENDING                   DV_PENDING
#define DVERR_NOTSUPPORTED              E_NOTIMPL
#define DVERR_NOINTERFACE               E_NOINTERFACE
#define DVERR_SESSIONLOST               MAKE_DVHRESULT( 0x012C )
#define DVERR_NOVOICESESSION            MAKE_DVHRESULT( 0x012E )
#define DVERR_CONNECTIONLOST            MAKE_DVHRESULT( 0x0168 )
#define DVERR_NOTINITIALIZED            MAKE_DVHRESULT( 0x0169 )
#define DVERR_CONNECTED                 MAKE_DVHRESULT( 0x016A )
#define DVERR_NOTCONNECTED              MAKE_DVHRESULT( 0x016B )
#define DVERR_CONNECTABORTING           MAKE_DVHRESULT( 0x016E )
#define DVERR_NOTALLOWED                MAKE_DVHRESULT( 0x016F )
#define DVERR_INVALIDTARGET             MAKE_DVHRESULT( 0x0170 )
#define DVERR_TRANSPORTNOTHOST          MAKE_DVHRESULT( 0x0171 )
#define DVERR_COMPRESSIONNOTSUPPORTED   MAKE_DVHRESULT( 0x0172 )
#define DVERR_ALREADYPENDING            MAKE_DVHRESULT( 0x0173 )
#define DVERR_SOUNDINITFAILURE          MAKE_DVHRESULT( 0x0174 )
#define DVERR_TIMEOUT                   MAKE_DVHRESULT( 0x0175 )
#define DVERR_CONNECTABORTED            MAKE_DVHRESULT( 0x0176 )
#define DVERR_NO3DSOUND                 MAKE_DVHRESULT( 0x0177 )
#define DVERR_ALREADYBUFFERED	        MAKE_DVHRESULT( 0x0178 )
#define DVERR_NOTBUFFERED               MAKE_DVHRESULT( 0x0179 )
#define DVERR_HOSTING                   MAKE_DVHRESULT( 0x017A )
#define DVERR_NOTHOSTING                MAKE_DVHRESULT( 0x017B )
#define DVERR_INVALIDDEVICE             MAKE_DVHRESULT( 0x017C )
#define DVERR_RECORDSYSTEMERROR         MAKE_DVHRESULT( 0x017D )
#define DVERR_PLAYBACKSYSTEMERROR       MAKE_DVHRESULT( 0x017E )
#define DVERR_SENDERROR                 MAKE_DVHRESULT( 0x017F )
#define DVERR_USERCANCEL                MAKE_DVHRESULT( 0x0180 )
#define DVERR_RUNSETUP                  MAKE_DVHRESULT( 0x0183 )
#define DVERR_INCOMPATIBLEVERSION       MAKE_DVHRESULT( 0x0184 )
#define DVERR_INITIALIZED               MAKE_DVHRESULT( 0x0187 )
#define DVERR_INVALIDPOINTER            E_POINTER
#define DVERR_NOTRANSPORT               MAKE_DVHRESULT( 0x0188 )
#define DVERR_NOCALLBACK                MAKE_DVHRESULT( 0x0189 )
#define DVERR_TRANSPORTNOTINIT          MAKE_DVHRESULT( 0x018A )
#define DVERR_TRANSPORTNOSESSION        MAKE_DVHRESULT( 0x018B )
#define DVERR_TRANSPORTNOPLAYER         MAKE_DVHRESULT( 0x018C )
#define DVERR_USERBACK                  MAKE_DVHRESULT( 0x018D )
#define DVERR_NORECVOLAVAILABLE         MAKE_DVHRESULT( 0x018E )
#define DVERR_INVALIDBUFFER				MAKE_DVHRESULT( 0x018F )
#define DVERR_LOCKEDBUFFER				MAKE_DVHRESULT( 0x0190 )
//@@BEGIN_MSINTERNAL
#define DVERR_CHILDPROCESSFAILED		DVERR_GENERIC
#define DV_EXIT							MAKE_HRESULT( 0, _FACDPV,  0x000F )
#define DVERR_UNKNOWN					DVERR_GENERIC
#define DVERR_PREVIOUSCRASH				MAKE_DVHRESULT( 0x0185 )
#define DVERR_WIN32						DVERR_GENERIC
//@@END_MSINTERNAL


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\aecdbgprop.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       aecdbgprop.h
 *  Content:    AEC Debug stuff
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  dandinu Created.
 *
 ***************************************************************************/
 
#ifdef AEC_DEBUG_SUPPORT

#ifndef _AECDMODBGPROP_
#define _AECDMODBGPROP_

#include <objbase.h>

//
// IDirectSoundCaptureFXMsAecPrivate
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMsAecPrivate, 0x2cf79924, 0x9ceb, 0x4482, 0x9b, 0x45, 0x1c, 0xdc, 0x23, 0x88, 0xb1, 0xf3);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMsAecPrivate

DECLARE_INTERFACE_(IDirectSoundCaptureFXMsAecPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMsAecPrivate methods
    //STDMETHOD(SetAllParameters)   (THIS_ LPCDSCFXMsAecPrivate pDscFxMsAecPrivate) PURE;
    STDMETHOD(GetSynchStreamFlag)   (THIS_ PBOOL) PURE;
    STDMETHOD(GetNoiseMagnitude)    (THIS_ PVOID, ULONG, PULONG) PURE;
};

#define IDirectSoundCaptureFXMsAecPrivate_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMsAecPrivate_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMsAecPrivate_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
//#define IDirectSoundCaptureFXMsAecPrivate_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMsAecPrivate_GetSynchStreamFlag(p,a,)    (p)->lpVtbl->GetSynchStreamFlag(p,a)
#define IDirectSoundCaptureFXMsAecPrivate_GetNoiseMagnitude(p,a,b,c)  (p)->lpVtbl->GetNoiseMagnitude(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
//#define IDirectSoundCaptureFXMsAecPrivate_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMsAecPrivate_GetSynchStreamFlag(p,a)     (p)->GetSynchStreamFlag(a)
#define IDirectSoundCaptureFXMsAecPrivate_GetNoiseMagnituge(p,a,b,c)  (p)->GetNoiseMagnitude(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // !defined(_AECDMODBGPROP_)
#endif // AEC_DEBUG_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\aec.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       aec.cpp
 *  Content:    Acoustic Echo Cancellation DMO implementation.
 *
 ***************************************************************************/

#include <windows.h>
#include "aecp.h"
#include "kshlp.h"
#include "clone.h"
#include "ksdbgprop.h"

STD_CAPTURE_CREATE(Aec)


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::NDQueryInterface
//
STDMETHODIMP CDirectSoundCaptureAecDMO::NDQueryInterface
(
    REFIID riid,
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid, ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXAec)
    {
        return GetInterface((IDirectSoundCaptureFXAec*)this, ppv);
    }
#ifdef AEC_DEBUG_SUPPORT
    else if (riid == IID_IDirectSoundCaptureFXMsAecPrivate)
    {
        return GetInterface((IDirectSoundCaptureFXMsAecPrivate*)this, ppv);
    }
#endif // AEC_DEBUG_SUPPORT
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
    {
        return CComBase::NDQueryInterface(riid, ppv);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO constructor
//
CDirectSoundCaptureAecDMO::CDirectSoundCaptureAecDMO(IUnknown *pUnk, HRESULT *phr) :
    CComBase(pUnk, phr),
    m_bInitialized(FALSE),
    m_fEnable(TRUE),
    m_fNfEnable(FALSE),
    m_dwMode(DSCFX_AEC_MODE_FULL_DUPLEX),
    m_fDirty(FALSE)
{
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO destructor
//
CDirectSoundCaptureAecDMO::~CDirectSoundCaptureAecDMO()
{
}


const MP_CAPS g_AecCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps            min,    max,    neutral,    unit text,  label,  pwchText??
    AECP_Enable,    MPT_BOOL,   g_AecCapsAll,   0,      1,      1,          L"",        L"",    L"",
    AECP_NoiseFill, MPT_BOOL,   g_AecCapsAll,   0,      1,      0,          L"",        L"",    L"",
    AECP_Mode,      MPT_INT,    g_AecCapsAll,   0,      1,      0,          L"",        L"",    L"",
};


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::InitOnCreation
//
HRESULT CDirectSoundCaptureAecDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof g_params / sizeof *g_params, g_params);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Init
//
HRESULT CDirectSoundCaptureAecDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureAecDMO::Clone(IMediaObjectInPlace **pp)
{
    return StandardDMOClone<CDirectSoundCaptureAecDMO, DSCFXAec>(this, pp);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Discontinuity
//
HRESULT CDirectSoundCaptureAecDMO::Discontinuity()
{
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::FBRProcess
//
HRESULT CDirectSoundCaptureAecDMO::FBRProcess
(
    DWORD cSamples,
    BYTE *pIn,
    BYTE *pOut
)
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}


// ==============Implementation of the private IAec interface ==========
// ==================== needed to support the property page ===============


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAecDMO::SetAllParameters(LPCDSCFXAec pParm)
{
    if (pParm == NULL)
    {
        Trace(1, "ERROR: pParm is NULL\n");
        return E_POINTER;
    }

    HRESULT hr = SetParam(AECP_Enable, static_cast<MP_DATA>(pParm->fEnable));
    if (SUCCEEDED(hr))
    {
        m_fDirty = true;
        hr = SetParam(AECP_NoiseFill, static_cast<MP_DATA>(pParm->fNoiseFill));
    }
    if (SUCCEEDED(hr))
    {
        hr = SetParam(AECP_Mode, static_cast<MP_DATA>(pParm->dwMode));
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAecDMO::GetAllParameters(LPDSCFXAec pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    MP_DATA var;

    HRESULT hr = GetParam(AECP_Enable, &var);
    if (SUCCEEDED(hr))
    {
        pParm->fEnable = (BOOL)var;
        hr = GetParam(AECP_NoiseFill, &var);
    }
    if (SUCCEEDED(hr))
    {
        pParm->fNoiseFill = (BOOL)var;
        hr = GetParam(AECP_Mode, &var);
    }
    if (SUCCEEDED(hr))
    {
        pParm->dwMode = (DWORD)var;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetStatus
//
STDMETHODIMP CDirectSoundCaptureAecDMO::GetStatus(PDWORD pdwStatus)
{
    DWORD dwStatus;
    ULONG cBytes;
    HRESULT hr;

    if (pdwStatus == NULL)
    {
        return E_POINTER;
    }

    hr = KsGetNodeProperty
         (
             m_hPin,
             KSPROPSETID_Acoustic_Echo_Cancel,
             KSPROPERTY_AEC_STATUS,
             m_ulNodeId,
             &dwStatus,
             sizeof dwStatus,
             &cBytes
         );

    if (SUCCEEDED(hr))
    {
        *pdwStatus = dwStatus;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Reset
//
STDMETHODIMP CDirectSoundCaptureAecDMO::Reset()
{
    return KsTopologyNodeReset(m_hPin, m_ulNodeId, true);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureAecDMO::SetParam
(
    DWORD dwParamIndex,
    MP_DATA value,
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;

    switch (dwParamIndex)
    {
        case AECP_Enable:
            if ((BOOL)value != m_fEnable)
            {
                hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, (BOOL)value);
                if (SUCCEEDED(hr)) m_fEnable = (BOOL)value;
            }
            break;

        case AECP_NoiseFill:
            if ((BOOL)value != m_fNfEnable)
            {
                hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_NOISE_FILL_ENABLE, m_ulNodeId, &value, sizeof value);
                if (SUCCEEDED(hr)) m_fNfEnable = (BOOL)value;
            }
            break;

        case AECP_Mode:
            if ((DWORD)value != m_dwMode)
            {
                hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_MODE, m_ulNodeId, &value, sizeof value);
                if (SUCCEEDED(hr)) m_dwMode = (DWORD)value;
            }
            break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }

    // Let the base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're
    // calling the function internally using values that came from the base class --
    // thus there's no need to tell it values it already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureAecDMO::GetParam
(
    DWORD dwParamIndex,
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;
    DWORD dwTemp;
    ULONG cBytes;

    switch (dwParamIndex)
    {
        case AECP_Enable:
            hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
            if (SUCCEEDED(hr))
            {
                m_fEnable = fTemp;
                *value = (MP_DATA)fTemp;
            }
            break;

        case AECP_NoiseFill:
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_NOISE_FILL_ENABLE, m_ulNodeId, &fTemp, sizeof fTemp, &cBytes);
            if (SUCCEEDED(hr))
            {
                m_fNfEnable = fTemp;
                *value = (MP_DATA)fTemp;
            }
            break;

        case AECP_Mode:
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_MODE, m_ulNodeId, &dwTemp, sizeof dwTemp, &cBytes);
            if (SUCCEEDED(hr))
            {
                m_dwMode = dwTemp;
                *value = (MP_DATA)dwTemp;
            }
            break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureAecDMO::ProcessInPlace
(
    ULONG ulQuanta,
    LPBYTE pcbData,
    REFERENCE_TIME rtStart,
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}


#ifdef AEC_DEBUG_SUPPORT

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetSynchStreamFlag
//
STDMETHODIMP
CDirectSoundCaptureAecDMO::GetSynchStreamFlag
(
    PBOOL pfSynchStreamFlag
)
{
    HRESULT hr = DS_OK;
    ULONG   cbDataReturned = 0;


    if (!pfSynchStreamFlag)
        return E_INVALIDARG;

    *pfSynchStreamFlag = 0;

    hr = KsGetNodeProperty
         (
             m_hPin,
             KSPROPSETID_DebugAecValue,
             KSPROPERTY_DEBUGAECVALUE_SYNCHSTREAM,
             m_ulNodeId,
             pfSynchStreamFlag,
             sizeof BOOL,
             &cbDataReturned
         );

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetNoiseMagnitude
//
STDMETHODIMP
CDirectSoundCaptureAecDMO::GetNoiseMagnitude
(
    PVOID   pvData,
    ULONG   cbData,
    PULONG  pcbDataReturned
)
{
    HRESULT hr = DS_OK;

    if ((cbData && !pvData) || !pcbDataReturned || (cbData % sizeof FLOAT))
        return E_INVALIDARG;

    *pcbDataReturned = 0;

    hr = KsGetNodeProperty
         (
             m_hPin,
             KSPROPSETID_DebugAecValue,
             KSPROPERTY_DEBUGAECARRAY_NOISEMAGNITUDE,
             m_ulNodeId,
             pvData,
             cbData,
             pcbDataReturned
         );

    return hr;
}

#endif // AEC_DEBUG_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\buildmode.inc ===
# buildmode.inc: included by several makefiles in the dsound directory tree
# to get the BuildMode variable.  This variable only affects debug builds;
# retail builds are identical in both modes.  BuildMode can take two values:
#
# internal:
#   DEBUG (and RDEBUG) preprocessor constants are #defined
#   DPF (and RPF) debug output messages are enabled
#   Debug messages contain file, function and line number info
#   ASSERT and BREAK macros are enabled
#   Internal heap consistency checks in dsound.dll are enabled
#
# external:
#   Only the RDEBUG preprocessor constant is #defined
#   Only RPF debug output messages are enabled
#   ASSERTs and BREAKs are enabled

# The default build mode is "external", and we only change it
# to "internal" if we determine that we're in pre-release mode.

BuildMode = external

#!if (NT build)

# FIXME: We should !include some VBL6-specific file here
# that defines PRERELEASE properly for us (bug 344974).

# In NT builds, we can key off the PRERELEASE flag:
!if defined(PRERELEASE)
!if $(PRERELEASE)
BuildMode = internal
!endif
!endif

#!else (DX build)

# In DX builds, some combination of DX_FINAL_RELEASE, FINAL and OFFICIAL
# could be used, but being careful about weekly Web releases and the like.

#!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\agcp.h ===
//
//
//
#ifndef _Agcp_
#define _Agcp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundCaptureAgcDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXAgc,
    public CComBase
{
public:
    CDirectSoundCaptureAgcDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundCaptureAgcDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);

    /* IFilter */
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc);

    // IMediaParams overrides
    STDMETHOD(SetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA* value);
    
    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
    BOOL m_fDirty;

private:
    BOOL m_fEnable;
    BOOL m_fReset;
    BOOL m_bInitialized;
};

EXT_STD_CAPTURE_CREATE(Agc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\aecp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       aecp.h
 *  Content:    Acoustic Echo Cancellation DMO declarations.
 *
 ***************************************************************************/

#ifndef _Aecp_
#define _Aecp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"
#include "aecdbgprop.h"

class CDirectSoundCaptureAecDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXAec,
#ifdef AEC_DEBUG_SUPPORT
    public IDirectSoundCaptureFXMsAecPrivate,
#endif // AEC_DEBUG_SUPPORT
    public CComBase
{
public:
    CDirectSoundCaptureAecDMO(IUnknown *pUnk, HRESULT *phr);
    ~CDirectSoundCaptureAecDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                        (THIS_ IMediaObjectInPlace **);

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSCFXAec);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSCFXAec);
    STDMETHOD(GetStatus)                    (THIS_ PDWORD pdwStatus);
    STDMETHOD(Reset)                        (THIS);

    // IMediaParams methods
    STDMETHOD(SetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA* value);

    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);

#ifdef AEC_DEBUG_SUPPORT
    // IDirectSoundCaptureFXMsAecPrivate methods
    //STDMETHOD(SetAllParameters)             (THIS_ LPCDSCFXMsAecPrivate);
    STDMETHOD(GetSynchStreamFlag)           (THIS_ PBOOL);
    STDMETHOD(GetNoiseMagnitude)            (THIS_ PVOID, ULONG, PULONG);
#endif // AEC_DEBUG_SUPPORT

private:
    BOOL m_fDirty;
    BOOL m_bInitialized;
    BOOL m_fEnable;
    BOOL m_fNfEnable;
    DWORD m_dwMode;
};

EXT_STD_CAPTURE_CREATE(Aec);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\agc.cpp ===
#include <windows.h>
#include "agcp.h"
#include "kshlp.h"
#include "clone.h"

STD_CAPTURE_CREATE(Agc)

STDMETHODIMP CDirectSoundCaptureAgcDMO::NDQueryInterface
(
    REFIID riid, 
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXAgc)
    {
        return GetInterface((IDirectSoundCaptureFXAgc*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

CDirectSoundCaptureAgcDMO::CDirectSoundCaptureAgcDMO( IUnknown *pUnk, HRESULT *phr ) :
    CComBase( pUnk, phr ),
    m_fEnable(FALSE),
    m_fReset(FALSE),
    m_fDirty(FALSE),
    m_bInitialized(FALSE)
{
}

CDirectSoundCaptureAgcDMO::~CDirectSoundCaptureAgcDMO()
{
}

const MP_CAPS g_AgcCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps           min,                        max,                        neutral,                    unit text,  label,          pwchText??
    AGCP_Enable,    MPT_BOOL,    g_AgcCapsAll,  0,                          1,                          0,                          L"",        L"",            L"",
    AGCP_Reset,     MPT_BOOL,    g_AgcCapsAll,  0,                          1,                          0,                          L"",        L"",            L""
};

HRESULT CDirectSoundCaptureAgcDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundCaptureAgcDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundCaptureAgcDMO, DSCFXAgc>(this, pp);
}

HRESULT CDirectSoundCaptureAgcDMO::Discontinuity() {
   return NOERROR;
}

HRESULT CDirectSoundCaptureAgcDMO::FBRProcess
(
    DWORD cSamples, 
    BYTE *pIn, 
    BYTE *pOut
) 
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}

// ==============Implementation of the private IAgc interface ==========
// ==================== needed to support the property page ===============

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::SetAllParameters(LPCDSCFXAgc pParm)
{
    HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pParm == NULL)
    {
        Trace(1,"ERROR: pParm is NULL\n");
        hr = E_POINTER;
    }
    

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(AGCP_Enable, static_cast<MP_DATA>(pParm->fEnable));
	if (SUCCEEDED(hr)) hr = SetParam(AGCP_Reset, static_cast<MP_DATA>(pParm->fReset));
            
    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::GetAllParameters(LPDSCFXAgc pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    MP_DATA var;

    GetParam(AGCP_Enable, &var);
    pParm->fEnable = (BOOL)var;
    
    GetParam(AGCP_Reset, &var);
    pParm->fReset = (BOOL)var;
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::SetParam
(
    DWORD dwParamIndex, 
    MP_DATA value, 
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;
    BOOL fEnable = (BOOL)value;
    BOOL fReset = (BOOL)value;

    switch (dwParamIndex)
    {
    case AGCP_Enable:
        if (fEnable != m_fEnable)
        {
            hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, fEnable);
            if(SUCCEEDED(hr)) m_fEnable = fEnable;        
        }
        break;
    case AGCP_Reset:
        if (fReset)
        {
            hr = KsTopologyNodeReset(m_hPin, m_ulNodeId, fReset);
            if(SUCCEEDED(hr)) m_fReset = fReset;
        }
        break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }


    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::GetParam
(
    DWORD dwParamIndex, 
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;

    switch (dwParamIndex)
    {
    case AGCP_Enable:
        hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
        if(SUCCEEDED(hr)) 
        {
            m_fEnable = fTemp;
            *value = (MP_DATA)fTemp;
        }
        break;
    case AGCP_Reset:
        *value = (MP_DATA)m_fReset;
        break;
    }

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureAgcDMO::ProcessInPlace
(
    ULONG ulQuanta, 
    LPBYTE pcbData, 
    REFERENCE_TIME rtStart, 
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include <windows.h>
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

//////////////////////////////////////////////////////////////////////
// AListItem::Remove

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
    if (pItem==NULL) 
        return this;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}


void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}


void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    Cat(Temp.GetHead());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

private:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(AListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
//            li->SetNext(NULL);
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\chorus.cpp ===
#include <windows.h>
#include "chorusp.h"
#include "Debug.h"
#include "clone.h"

STD_CREATE(Chorus)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::QueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
HRESULT CDirectSoundChorusDMO::NDQueryInterface(REFIID riid, void **ppv) {

    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXChorus)
    {
        return GetInterface((IDirectSoundFXChorus*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::CDirectSoundChorusDMO
//
CDirectSoundChorusDMO::CDirectSoundChorusDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
    m_EaxSamplesPerSec = 22050;
    m_DelayLine.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::Init()
//
HRESULT CDirectSoundChorusDMO::Init()
{
    DSFXChorus chorus;
    HRESULT hr;

    // Force recalc of all internal parameters
    //
    hr = GetAllParameters(&chorus);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&chorus);
    
    if (SUCCEEDED(hr)) hr = m_DelayLine.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = Discontinuity();
    return hr;
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    CFP_Wetdrymix,  MPT_FLOAT,  g_capsAll,  DSFXCHORUS_WETDRYMIX_MIN,   DSFXCHORUS_WETDRYMIX_MAX,   50,                     L"%",       L"WetDryMix",   L"",
    CFP_Depth,      MPT_FLOAT,  g_capsAll,  DSFXCHORUS_DEPTH_MIN,       DSFXCHORUS_DEPTH_MAX,       10,                     L"",        L"Depth",       L"",
    CFP_Frequency,  MPT_FLOAT,  g_capsAll,  DSFXCHORUS_FREQUENCY_MIN,   DSFXCHORUS_FREQUENCY_MAX,   (float)1.1,             L"Hz",      L"Frequency",   L"",
    CFP_Waveform,   MPT_ENUM,   g_capsAll,  DSFXCHORUS_WAVE_TRIANGLE,   DSFXCHORUS_WAVE_SIN,        DSFXCHORUS_WAVE_SIN,    L"",        L"WaveShape",   L"Triangle,Sine",
    CFP_Phase,      MPT_INT,    g_capsAll,  DSFXCHORUS_PHASE_MIN,       DSFXCHORUS_PHASE_MAX,       3,                      L"",        L"Phase",       L"",
    CFP_Feedback,   MPT_FLOAT,  g_capsAll,  DSFXCHORUS_FEEDBACK_MIN,    DSFXCHORUS_FEEDBACK_MAX,    25,                     L"",        L"Feedback",    L"",
    CFP_Delay,      MPT_FLOAT,  g_capsAll,  DSFXCHORUS_DELAY_MIN,       DSFXCHORUS_DELAY_MAX,       16,                     L"",        L"Delay",       L"",
};

HRESULT CDirectSoundChorusDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::~CDirectSoundChorusDMO
//
CDirectSoundChorusDMO::~CDirectSoundChorusDMO() 
{
    m_DelayLine.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::Clone
//
STDMETHODIMP CDirectSoundChorusDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundChorusDMO, DSFXChorus>(this, pp);
}

HRESULT CDirectSoundChorusDMO::Discontinuity() 
{
    if (!m_EaxWaveform) {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.5;
    }
    else {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.99999999999;
    }

    m_DelayLine.ZeroBuffer();

    m_DelayFixedPtr = (int)m_EaxDelayCoef;
    m_DelayL        = m_DelayFixedPtr;
    m_DelayL1       = m_DelayFixedPtr;
    m_DelayR        = m_DelayFixedPtr;
    m_DelayR1       = m_DelayFixedPtr;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

static int   LMul  [5] = {  1,  1, 1, 1, -1};
static int   RMul  [5] = { -1, -1, 1, 1,  1};
static int   RPhase[5] = {  0,  1, 0, 1,  0};

__forceinline void CDirectSoundChorusDMO::DoOneSample(int *l, int *r)
{
    float inPortL, inPortR;
    float TempVar;
    float XWave[2];
//    float sinwave, coswave;
#define sinwave XWave[0]
#define coswave XWave[1]

    int    Pos0, Pos1;
    int DelayFixedPtr = m_DelayLine.Pos(m_DelayFixedPtr);

    Pos0 = m_DelayLine.Pos(0);

    TempVar  = m_DelayLine[DelayFixedPtr] * m_EaxFbCoef;

    inPortL = (float)*l;
    inPortR = (float)*r;

    m_DelayLine[Pos0] = TempVar + (inPortL + inPortR) / 2;

    if (!m_EaxWaveform) {

        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef;

        if (m_LfoState[0] > 1) m_LfoState[0] -= 2;

        m_LfoState[1] = m_LfoState[1] + m_EaxLfoCoef;

        if (m_LfoState[1] > 1) m_LfoState[1] -= 2;

        sinwave       = (float)fabs(m_LfoState[0]);
        coswave       = (float)fabs(m_LfoState[1]);
        sinwave       = -1 + 2 * sinwave;
        coswave       = -1 + 2 * coswave;
    }
    else {
        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef * m_LfoState[1];
        m_LfoState[1] = m_LfoState[1] - m_EaxLfoCoef * m_LfoState[0];
        sinwave       = m_LfoState[0];
        coswave       = m_LfoState[1];
    }

    Pos0 = m_DelayLine.Pos(m_DelayL);
    Pos1 = m_DelayLine.Pos(m_DelayL1);

    TempVar  = (float)(m_DelayL & FractMask);
    TempVar /= (float)FractMultiplier;

    TempVar = Interpolate(m_DelayLine[Pos0], m_DelayLine[Pos1], TempVar);
    inPortL = Interpolate(inPortL, TempVar, m_EaxWetLevel);

//    m_DelayL  = m_DelayFixedPtr + (int)(sinwave * m_EaxDepthCoef);
#if 0
    switch (m_EaxPhase) {
        case 0: 
        case 1: 
        case 2:
        case 3: m_DelayL =   (int)(sinwave * m_EaxDepthCoef); break;
        case 4: m_DelayL = - (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
#ifdef DONTUSEi386
    {
    int x;
    float f = (sinwave * m_EaxDepthCoef);

    _asm {
        fld f
        fistp x
    }
    
    m_DelayL  = LMul[m_EaxPhase] * x;
    }
#else
    m_DelayL  = LMul[m_EaxPhase] * (int)(sinwave * m_EaxDepthCoef);
#endif
#endif
    m_DelayL += m_DelayFixedPtr;
    m_DelayL1 = m_DelayL + FractMultiplier;

    *l = Saturate(inPortL);

    Pos0 = m_DelayLine.Pos(m_DelayR);
    Pos1 = m_DelayLine.Pos(m_DelayR1);

    TempVar  = (float)(m_DelayR & FractMask);
    TempVar /= (float)FractMultiplier;

    TempVar = Interpolate(m_DelayLine[Pos0], m_DelayLine[Pos1], TempVar);
    inPortR = Interpolate(inPortR, TempVar, m_EaxWetLevel);

//    m_DelayR  = m_DelayFixedPtr + (int)(coswave * m_EaxDepthCoef);
#if 0
    switch (m_EaxPhase) {
        case 0: m_DelayR = - (int)(sinwave * m_EaxDepthCoef); break;
        case 1: m_DelayR = - (int)(coswave * m_EaxDepthCoef); break;
        case 3: m_DelayR =   (int)(coswave * m_EaxDepthCoef); break;
        case 2:
        case 4: m_DelayR =   (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
    Pos0      = RPhase[m_EaxPhase];
#ifdef DONTUSEi386
    {
    int x;
    float f = (XWave[Pos0] * m_EaxDepthCoef);

    _asm {
        fld f
        fistp x
    }
    m_DelayR  = RMul  [m_EaxPhase] * x;
    }
#else
    m_DelayR  = RMul  [m_EaxPhase] * (int)(XWave[Pos0] * m_EaxDepthCoef);
#endif
#endif
    m_DelayR += m_DelayFixedPtr;
    m_DelayR1 = m_DelayR + FractMultiplier;

    *r = Saturate(inPortR);

    m_DelayLine.Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::FBRProcess
//
HRESULT CDirectSoundChorusDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
#define cb cSamples
#define pin pIn
#define pout pOut

    if (m_cChannels == 1) {
        if (m_b8bit) {
            for (;cb > 0; --cb) {
                int i, j;

                i = *(pin+0)-128;
                i *=256;
                j  = i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                i /= 256;

                *(pout+0) = (unsigned char)(i + 128);
            
                pin  += sizeof(unsigned char);
                pout += sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *psi;
                j =  i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                   *pso = (short)i;
            
                pin  += sizeof(short);
                pout += sizeof(short);
            }
        }
    }
    else if (m_cChannels == 2) {
        if (m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
                int i, j;

                i = *(pin+0)-128;
                j = *(pin+1)-128;

                i *=256; j *=256;

                DoOneSample(&i, &j);
                
                i /= 256; j /= 256;
                
                *(pout+0) = (unsigned char)(i + 128);
                *(pout+1) = (unsigned char)(j + 128);
            
                pin  += 2 * sizeof(unsigned char);
                pout += 2 * sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *(psi+0);
                j = *(psi+1);

                DoOneSample(&i, &j);
                
                   *(pso+0) = (short)i;
                   *(pso+1) = (short)j;
            
                pin  += 2 * sizeof(short);
                pout += 2 * sizeof(short);
            }
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::ProcessInPlace
//
HRESULT CDirectSoundChorusDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::SetParamInternal
//
HRESULT CDirectSoundChorusDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    long l;

    if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;    // NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
    case CFP_Wetdrymix :
        CHECK_PARAM(DSFXCHORUS_WETDRYMIX_MIN, DSFXCHORUS_WETDRYMIX_MAX);

        PUT_EAX_VALUE(WetLevel, value / 100);

        break;

    case CFP_Depth : {
        CHECK_PARAM(DSFXCHORUS_DEPTH_MIN, DSFXCHORUS_DEPTH_MAX);

        PUT_EAX_VALUE(Depth, value / 100);

        double midpoint = m_EaxDelay * m_EaxSamplesPerSec/1000;

        INTERPOLATE(DepthCoef, (float)((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        break;
    }
    case CFP_Delay : {
        CHECK_PARAM(DSFXCHORUS_DELAY_MIN, DSFXCHORUS_DELAY_MAX);
    
        PUT_EAX_VALUE(Delay, value);

        double midpoint    = m_EaxDelay * m_EaxSamplesPerSec/1000;

        m_EaxDepthCoef = (float)(((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        m_EaxDelayCoef = (float)((midpoint + 2) * FractMultiplier);

        break;
    }
    case CFP_Frequency : {
        CHECK_PARAM(DSFXCHORUS_FREQUENCY_MIN, DSFXCHORUS_FREQUENCY_MAX);

        PUT_EAX_VALUE(Frequency, value);
x:
        if (!m_EaxWaveform) {
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0 * (m_EaxFrequency/m_EaxSamplesPerSec) * 1.0)
                );
        }
        else
        {
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0*sin(PI*m_EaxFrequency/m_EaxSamplesPerSec))
                );
        }
        break;
    }
    case CFP_Waveform :
        CHECK_PARAM(DSFXCHORUS_WAVE_TRIANGLE, DSFXCHORUS_WAVE_SIN);

        l = m_EaxWaveform;

        PUT_EAX_VALUE(Waveform, (long)value);

        if (l != m_EaxWaveform) {
            if (!m_EaxWaveform) {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.5;
            }
            else {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.99999999999;
            }
        }
        goto x;

    case CFP_Phase :
        CHECK_PARAM(DSFXCHORUS_PHASE_MIN, DSFXCHORUS_PHASE_MAX);

        PUT_EAX_VALUE(Phase, (long)value);
        break;

    case CFP_Feedback :
        CHECK_PARAM(DSFXCHORUS_FEEDBACK_MIN,  DSFXCHORUS_FEEDBACK_MAX);

        PUT_EAX_VALUE(FbCoef, value / 100);

//        m_EaxFbCoef = TOFRACTION(m_EaxFbCoef);
        break;

// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundChorusDMO::SetAllParameters(LPCDSFXChorus pChorus)
{
    HRESULT hr = S_OK;
    
    // Check that the pointer is not NULL
    if (pChorus == NULL)
    {
        Trace(1,"ERROR: pChorus is NULL\n");
        hr = E_POINTER;
    }

    // Set the parameters
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Wetdrymix, pChorus->fWetDryMix);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Depth, pChorus->fDepth);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Frequency, pChorus->fFrequency);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Waveform, (float)pChorus->lWaveform);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Phase, (float)pChorus->lPhase);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Feedback, pChorus->fFeedback);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Delay, pChorus->fDelay);

    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundChorusDMO::GetAllParameters(LPDSFXChorus pChorus)
{
    HRESULT hr = S_OK;
    MP_DATA mpd;
    
    if (pChorus == NULL)
    {
        return E_POINTER;
    }
    
#define GET_PARAM(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pChorus->y = mpd; \
    }

#define GET_PARAM_LONG(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pChorus->y = (long)mpd; \
    }
    GET_PARAM(CFP_Wetdrymix, fWetDryMix);
    GET_PARAM(CFP_Delay, fDelay);
    GET_PARAM(CFP_Depth, fDepth);
    GET_PARAM(CFP_Frequency, fFrequency);
    GET_PARAM_LONG(CFP_Waveform, lWaveform);
    GET_PARAM_LONG(CFP_Phase, lPhase);
    GET_PARAM(CFP_Feedback, fFeedback);

    return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundChorusDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_CHORUS;
    return NOERROR;

} // GetClassID

HRESULT CDirectSoundChorusDMO::CheckInputType(const DMO_MEDIA_TYPE *pmt) 
{
    HRESULT hr = CPCMDMO::CheckInputType(pmt);
    if (FAILED(hr)) return hr;

    WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
    if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
        (pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
        (pWave->nChannels      != 1 && pWave->nChannels != 2)) {
        return DMO_E_TYPE_NOT_ACCEPTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\chorusp.h ===
//
//
//
#ifndef _CHORUSP_
#define _CHORUSP_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS
#define DelayLineSize		(DefineDelayLineSize(40))

class CDirectSoundChorusDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXChorus,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundChorusDMO( IUnknown * pUnk, HRESULT *phr );
    ~CDirectSoundChorusDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);

    /* IFilter */
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus);

    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropChorus, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );


    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXChorus(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXChorus(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXChorus); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);
    
    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();

    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
	
private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(float, Depth);

	DECLARE_EAX_VARS(float, WetLevel);			// Ratio of original and mixed.
	DECLARE_EAX_VARS(float, DepthCoef);		// Delay distance.
	DECLARE_EAX_VARS(float, LfoCoef);
	DECLARE_EAX_VARS(float, FbCoef);		// User-set feed-back coef.
	DECLARE_EAX_VARS(float, Frequency);		// User-set.
	DECLARE_EAX_VARS(float, Delay);
	DECLARE_EAX_VARS(float, DelayCoef);		// User-set chorus delay.
	DECLARE_EAX_VARS(long,  Waveform);
	DECLARE_EAX_VARS(long,  Phase);
#define m_EaxSamplesPerSec m_ulSamplingRate

	DelayBuffer2<float, DelayLineSize, 3>	m_DelayLine;

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	float			m_LfoState[2];

	DWORD			m_DelayFixedPtr;
	DWORD			m_DelayL;
	DWORD			m_DelayL1;
	DWORD			m_DelayR;
	DWORD			m_DelayR1;

// } EAX
};

EXT_STD_CREATE(Chorus);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\clone.cpp ===
#include "clone.h"

HRESULT StandardDMOClone_Ending(IMediaObject *pThis, IMediaObject *pCloned, IMediaObjectInPlace **ppCloned)
{
	HRESULT hr = S_OK;

	// Copy the input and output types
	DMO_MEDIA_TYPE mt;
	DWORD cInputStreams = 0;
	DWORD cOutputStreams = 0;
	pThis->GetStreamCount(&cInputStreams, &cOutputStreams);

	for (DWORD i = 0; i < cInputStreams && SUCCEEDED(hr); ++i)
	{
		hr = pThis->GetInputCurrentType(i, &mt);
		if (hr == DMO_E_TYPE_NOT_SET)
		{
			hr = S_OK; // great, don't need to set the cloned DMO
		}
		else if (SUCCEEDED(hr))
		{
			hr = pCloned->SetInputType(i, &mt, 0);
		}
	}

	for (i = 0; i < cOutputStreams && SUCCEEDED(hr); ++i)
	{
		hr = pThis->GetOutputCurrentType(i, &mt);
		if (hr == DMO_E_TYPE_NOT_SET)
		{
			hr = S_OK; // great, don't need to set the cloned DMO
		}
		else if (SUCCEEDED(hr))
		{
			hr = pCloned->SetOutputType(i, &mt, 0);
		}
	}

	if (SUCCEEDED(hr))
		hr = pCloned->QueryInterface(IID_IMediaObjectInPlace, (void**)ppCloned);

	// Release the object's original ref.  If clone succeeded (made it through QI) then returned pointer
	// has one ref.  If we failed, refs drop to zero, freeing the object.
	pCloned->Release();
    return hr;                               
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\compress.cpp ===
#include <windows.h>

#include "compressp.h"
#include "clone.h"

STD_CREATE(Compressor)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::QueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundCompressorDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXCompressor)
    {
        return GetInterface((IDirectSoundFXCompressor*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::CDirectSoundCompressorDMO
//
CDirectSoundCompressorDMO::CDirectSoundCompressorDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 22050;
	m_LeftDelay. Init(0);
	m_RightDelay.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::Init()
//
HRESULT CDirectSoundCompressorDMO::Init()
{
    DSFXCompressor compress;
    HRESULT hr;

    // Force recalc of all internal parameters
    //
    hr = GetAllParameters(&compress);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&compress);

    if (SUCCEEDED(hr)) hr = m_LeftDelay. Init(m_EaxSamplesPerSec);
	if (SUCCEEDED(hr) && m_cChannels == 2) {
		hr = m_RightDelay.Init(m_EaxSamplesPerSec);
	}

    if (SUCCEEDED(hr)) hr = Discontinuity();
    return hr;
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index                   type        caps        min,                                max,                                neutral,                unit text,  label,              pwchText
    CPFP_Gain,              MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_GAIN_MIN,            DSFXCOMPRESSOR_GAIN_MAX,            0,                      L"",        L"Gain",            L"",
    CPFP_Attack,            MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_ATTACK_MIN,          DSFXCOMPRESSOR_ATTACK_MAX,          10,                     L"",        L"Attack",          L"",
    CPFP_Release,           MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_RELEASE_MIN,         DSFXCOMPRESSOR_RELEASE_MAX,         200,                    L"",        L"Release",         L"",
    CPFP_Threshold,         MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_THRESHOLD_MIN,       DSFXCOMPRESSOR_THRESHOLD_MAX,       -20,                    L"",        L"Threshold",       L"",
    CPFP_Ratio,             MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_RATIO_MIN,           DSFXCOMPRESSOR_RATIO_MAX,           3,                      L"",        L"Ratio",           L"",
    CPFP_Predelay,          MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_PREDELAY_MIN,        DSFXCOMPRESSOR_PREDELAY_MAX,        4,                      L"",        L"Predelay",        L"",
    };

HRESULT CDirectSoundCompressorDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::~CDirectSoundCompressorDMO
//
CDirectSoundCompressorDMO::~CDirectSoundCompressorDMO() 
{
	m_LeftDelay. Init(-1);
	m_RightDelay.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::Clone
//
STDMETHODIMP CDirectSoundCompressorDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundCompressorDMO, DSFXCompressor>(this, pp);
}

//
//	Bump - bump the delay pointers.
//
void CDirectSoundCompressorDMO::Bump(void)
{
// EAX {
	m_LeftDelay.Bump();
	m_RightDelay.Bump();
// }
}


HRESULT CDirectSoundCompressorDMO::Discontinuity() 
{
// { EAX

	m_LeftDelay.ZeroBuffer();
	if (m_cChannels == 2) {
		m_RightDelay.ZeroBuffer();
	}

	m_Envelope = m_CompGain = 0;

// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


float myexp( float finput, unsigned long maxexponent)
{
	
	unsigned long mantissa, exponent, exponentwidth ;
	long sign;
	long input;
	

#ifdef DONTUSEi386
	_asm {
		fld finput
		fistp input
	}
#else
	input    = (int)(finput);
#endif
	mantissa = input & 0x7FFFFFFFL ;
	sign     = input & 0x80000000L ; /* Preserve sign */            
	
	exponentwidth = 5;

	if ((0x80000000L & input) != 0) { /* Take absolute value of input */
		input = -input ;
	}
	
	/* Left-justify the mantissa and right-justify the exponent to separate */

	mantissa = input <<      exponentwidth ;
	exponent = input >> ( 31-exponentwidth ) ;
	
	/* 
	* Insert the implied '1' at the mantissa MSB if not a zero exponent and
	* adjust it.
	*/
	if( exponent != 0 ) {
		mantissa = mantissa | 0x80000000L ;
		exponent-- ;
	}
	
	mantissa = mantissa >> ( maxexponent-exponent ) ; 
	
	if( sign != 0  ) 
		  mantissa = ~mantissa ;
	
	float x = (float)mantissa;

	return(x);
} 

__forceinline void CDirectSoundCompressorDMO::DoOneSampleMono(int *l)
{
	int		Pos0, PosX;
	float	inPortL = (float)*l;
	float	outPortL;
	float	temp1, temp2;

	temp1			= inPortL;

//	left_delay[]	= temp1;

	Pos0 = m_LeftDelay.Pos(0);
	m_LeftDelay[Pos0] = temp1;

	temp1			= (float)fabs(temp1);

	// Take the log
#define LOG(x,y) mylog(x,y)
	temp1			= (float)fabs(LOG(temp1 * 0x8000,31));
	temp1                  /= 0x80000000;
	// Sidechain level meter
#ifndef MAX
#define MAX(x,y)	((x > y) ? x : y)
#endif

	m_EaxCompInputPeak	= MAX(temp1, m_EaxCompInputPeak);

	// Envelope follower

	temp2			= temp1 >= m_Envelope ? m_EaxAttackCoef : -m_EaxAttackCoef;
	temp2			= temp2 <= 0 ? m_EaxReleaseCoef : temp2;

//	m_Envelope		= temp2 : temp1 < m_Envelope;

	m_Envelope      = Interpolate(temp1, m_Envelope, temp2);

	m_CompGain		= MAX(m_Envelope, m_EaxCompThresh);

	// Log Difference between signal level and threshold level

	m_CompGain		= m_EaxCompThresh - m_CompGain;

#define cPOSFSCALE (float)0.9999999
	m_CompGain		= cPOSFSCALE + m_CompGain * m_EaxCompressionRatio;

	// Compressor gain reduction meter

#ifndef MIN
#define MIN(x,y)	((x < y) ? x : y)
#endif

#define EXP(x,y)	myexp(x,y)
	m_EaxCompGainMin= MIN(m_CompGain, m_EaxCompGainMin);
	m_CompGain		= (float)EXP(m_CompGain * 0x80000000, 31);
	m_CompGain	       /= 0x80000000;

//	outPortL		= left_point[@] * compGain;

	PosX     = m_LeftDelay.LastPos((int)m_EaxLeftPoint);
	outPortL = m_LeftDelay[PosX] * m_CompGain;

	temp1			= outPortL * m_EaxGainBiasIP;
	outPortL		= temp1 + outPortL * m_EaxGainBiasFP;

	*l = Saturate(outPortL);

	//Bump();
	m_LeftDelay.Bump();
}
__forceinline void CDirectSoundCompressorDMO::DoOneSample(int *l, int *r)
{
	int		Pos0, PosX;
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;
	float	outPortL, outPortR;
	float	temp1, temp2;

	temp1			= inPortL;
	temp2			= inPortR;

//	left_delay[]	= temp1;

	Pos0 = m_LeftDelay.Pos(0);
	m_LeftDelay[Pos0] = temp1;

//	right_delay[]	= temp2;

	Pos0 = m_RightDelay.Pos(0);
	m_RightDelay[Pos0] = temp2;

	//Take the magnitude

	temp1			= (float)fabs(temp1);
	temp2			= (float)fabs(temp2);

	// Take the average 

//	temp1			= 0.5 : temp1 < temp2;

	temp1			= (temp1 + temp2) / 2;

	// Take the log
#define LOG(x,y) mylog(x,y)
	temp1			= (float)fabs(LOG(temp1 * 0x8000,31));
	temp1                  /= 0x80000000;
	// Sidechain level meter
#ifndef MAX
#define MAX(x,y)	((x > y) ? x : y)
#endif

	m_EaxCompInputPeak	= MAX(temp1, m_EaxCompInputPeak);

	// Envelope follower

	temp2			= temp1 >= m_Envelope ? m_EaxAttackCoef : -m_EaxAttackCoef;
	temp2			= temp2 <= 0 ? m_EaxReleaseCoef : temp2;

//	m_Envelope		= temp2 : temp1 < m_Envelope;

	m_Envelope      = Interpolate(temp1, m_Envelope, temp2);

	m_CompGain		= MAX(m_Envelope, m_EaxCompThresh);

	// Log Difference between signal level and threshold level

	m_CompGain		= m_EaxCompThresh - m_CompGain;

#define cPOSFSCALE (float)0.9999999
	m_CompGain		= cPOSFSCALE + m_CompGain * m_EaxCompressionRatio;

	// Compressor gain reduction meter

#ifndef MIN
#define MIN(x,y)	((x < y) ? x : y)
#endif

#define EXP(x,y)	myexp(x,y)
	m_EaxCompGainMin= MIN(m_CompGain, m_EaxCompGainMin);
	m_CompGain		= (float)EXP(m_CompGain * 0x80000000, 31);
	m_CompGain	       /= 0x80000000;

//	outPortL		= left_point[@] * compGain;

	PosX     = m_LeftDelay.LastPos((int)m_EaxLeftPoint);
	outPortL = m_LeftDelay[PosX] * m_CompGain;

//	outPortR		= right_point[@] * compGain;

	PosX     = m_RightDelay.LastPos((int)m_EaxRightPoint);
	outPortR = m_RightDelay[PosX] * m_CompGain;

	temp1			= outPortL * m_EaxGainBiasIP;
	outPortL		= temp1 + outPortL * m_EaxGainBiasFP;

	temp1			= outPortR * m_EaxGainBiasIP;
	outPortR		= temp1 + outPortR * m_EaxGainBiasFP;

	*l = Saturate(outPortL);
	*r = Saturate(outPortR);

	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::FBRProcess
//
HRESULT CDirectSoundCompressorDMO::FBRProcess(DWORD cCompressors, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cCompressors
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
//				j  = i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
//				j =  i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::ProcessInPlace
//
HRESULT CDirectSoundCompressorDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::SetParam
//
// { EAX
// }

HRESULT CDirectSoundCompressorDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
	float	fVal;

	if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;	// NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
	case CPFP_Gain : {
		CHECK_PARAM(DSFXCOMPRESSOR_GAIN_MIN, DSFXCOMPRESSOR_GAIN_MAX);

		fVal = (float)pow(10, value/20);	//Convert from dB to linear

		float _gainBiasIP, _gainBiasFP;
		double d;

		_gainBiasFP = (float)modf((double)fVal, &d);
		_gainBiasIP = (float)d;

		INTERPOLATE (GainBiasFP, TOFRACTION(_gainBiasFP));
		PUT_EAX_FVAL(GainBiasIP, TOFRACTION(_gainBiasIP));
		break;
	}
	case CPFP_Attack :
		CHECK_PARAM(DSFXCOMPRESSOR_ATTACK_MIN, DSFXCOMPRESSOR_ATTACK_MAX);

		m_EaxAttackCoef = (float)pow(10, -1/(value*m_EaxSamplesPerSec/1000));

		PUT_EAX_FVAL(AttackCoef, TOFRACTION(m_EaxAttackCoef));
		break;

	case CPFP_Release :
		CHECK_PARAM(DSFXCOMPRESSOR_RELEASE_MIN, DSFXCOMPRESSOR_RELEASE_MAX);

		m_EaxReleaseCoef = (float)pow(10, -1/(value*m_EaxSamplesPerSec/1000));
		break;

	case CPFP_Threshold : {
		CHECK_PARAM(DSFXCOMPRESSOR_THRESHOLD_MIN, DSFXCOMPRESSOR_THRESHOLD_MAX);

		fVal = (float)pow(10, value/20);	//Convert from dB to linear

		float _compThresh;
		float a, b;

		a = (float)(pow(2, 26) * log(fVal * pow(2, 31))/log(2) + pow(2, 26));
		b = (float)(pow(2, 31) - 1.0);
		_compThresh = a < b ? a : b;

		_compThresh /= (float)0x80000000;

		PUT_EAX_FVAL(CompThresh, _compThresh);
		break;
	}
	case CPFP_Ratio :
		CHECK_PARAM(DSFXCOMPRESSOR_RATIO_MIN, DSFXCOMPRESSOR_RATIO_MAX);

		m_EaxCompressionRatio = (float)(1.0 - 1.0/value);

		PUT_EAX_FVAL(CompressionRatio, TOFRACTION(m_EaxCompressionRatio));
		break;

	case CPFP_Predelay : {
		CHECK_PARAM(DSFXCOMPRESSOR_PREDELAY_MIN, DSFXCOMPRESSOR_PREDELAY_MAX);

		float _length = (float)(value * m_EaxSamplesPerSec/1000.0);

		PUT_EAX_LVAL(LeftPoint,  _length + 2);
		PUT_EAX_LVAL(RightPoint, _length + 2);
		break;
	}
	/*
	** Removed from PropertySet, Processing code left behind so we can resurrect later
	**
	case CPFP_CompMeterReset : {
		CHECK_PARAM(DSFXCOMPRESSOR_COMPMETERRESET_MIN, DSFXCOMPRESSOR_COMPMETERRESET_MAX);

		if(!value)
			break; // return E_FAIL;


		float InputPeak = m_EaxCompInputPeak;
		float GainMin   = m_EaxCompGainMin;

		PUT_EAX_FVAL(CompInputPeak, 0);
		PUT_EAX_FVAL(CompGainMin,   0.999999999);

		InputPeak =   (float)(186.0 * (InputPeak - 0.999999999)/0.999999999);
		GainMin   = - (float)(186.0 * (GainMin   - 0.999999999)/0.999999999);

		CParamsManager::SetParam(CPFP_CompMeterReset , 0);

		if (!fSkipPasssingToParamManager)
			CParamsManager::SetParam(CPFP_CompInputMeter , InputPeak);

		if (!fSkipPasssingToParamManager)
			CParamsManager::SetParam(CPFP_CompGainMeter , GainMin);

		break;
	}
	*/
	
	/*	These values can't be set, only queried.
	 */

	/*
	case CPFP_CompInputMeter :
		CHECK_PARAM(DSFXCOMPRESSOR_COMPINPUTMETER_MIN, DSFXCOMPRESSOR_COMPINPUTMETER_MAX);
		return E_FAIL;

	case CPFP_CompGainMeter :
		CHECK_PARAM(DSFXCOMPRESSOR_COMPGAINMETER_MIN, DSFXCOMPRESSOR_COMPGAINMETER_MAX);
		return E_FAIL;
// } EAX
    */
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCompressorDMO::SetAllParameters(LPCDSFXCompressor pComp)
{
    HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pComp == NULL)
    {
        Trace(1,"ERROR: pComp is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Gain, pComp->fGain);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Attack, pComp->fAttack);   
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Release, pComp->fRelease);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Threshold, pComp->fThreshold);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Ratio, pComp->fRatio);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Predelay, pComp->fPredelay);
    
	/*	These values can only be queried, not set.  CPFP_CompMeterReset fills
	 *	the values.
	 */
//	if (SUCCEEDED(hr)) hr = SetParam(CPFP_CompInputMeter, pComp->fCompInputMeter);
//	if (SUCCEEDED(hr)) hr = SetParam(CPFP_CompGainMeter, pComp->fCompGainMeter);

    m_fDirty = true;
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCompressorDMO::GetAllParameters(LPDSFXCompressor pCompressor)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (pCompressor == NULL) return E_POINTER;
	
#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pCompressor->y = mpd; \
	}

    GET_PARAM(CPFP_Attack, fAttack);   
    GET_PARAM(CPFP_Release, fRelease);
    GET_PARAM(CPFP_Threshold, fThreshold);
    GET_PARAM(CPFP_Ratio, fRatio);
    GET_PARAM(CPFP_Gain, fGain);
    GET_PARAM(CPFP_Predelay, fPredelay);
    
	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundCompressorDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_COMPRESSOR;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\common.cpp ===
#include <windows.h>
#include "dsdmo.h"

double LogNorm[32] =
{
	1, 1, 1.5, 1, 1.75, 1.4, 1.17, 1, 1.88, 1.76, 1.5, 1.36, 1.25, 1.15, 1.07,
	1, 1.94, 1.82, 1.72, 1.63, 1.55, 1.48, 1.41, 1.35, 1.29, 1.24, 1.19, 1.15,
	1.11, 1.07, 1.03, 1
};

float mylog( float finput, unsigned long maxexponent)
{
	
	unsigned long mantissa, exponent, exponentwidth ;
	long input, output, sign;

#ifdef DONTUSEi386
	_asm {
		fld finput
		fistp input
	}
#else
	input = (int)finput;
#endif

	/*
	* Separate the sign bit
	*/
	sign = input & 0x80000000L ; /* Preserve sign */            
	
	/* 
	* Separate mantissa bits from the sign and
	* complement them if original input was negative
	*/
	mantissa = sign ? -input : input;
	
	/*
	* Attempt to normalize the input to form the mantissa and
	* thereby calculate the actual exponent.
	*/
	exponent = maxexponent ;
	while( (mantissa < 0x80000000) && (exponent > 0) ) {
	   mantissa = mantissa << 1 ;
	   exponent-- ;
	}
	
	/*
	* If normalization was successful, mask off the MSB (since it
	* will be implied by a non-zero exponent) and adjust the exponent value
	*/
	if( mantissa >= 0x80000000 ) {
		mantissa = mantissa & 0x7FFFFFFF ;
	   exponent++ ;
	}
	
	/*
	* Find the width of the exponent field required to represent
	* maxeponent and assemble the sign, exponent and mantissa fields
	* based on that width.
	*/
	if( maxexponent > 15 )
	   exponentwidth = 5 ;
	else if( maxexponent > 7 )
	   exponentwidth = 4 ;
	else if( maxexponent > 3 )
	   exponentwidth = 3 ;
	else 
	   exponentwidth = 2 ;
	
if (sign == 0x80000000L) 
	output = sign  |  ~((exponent << (31-exponentwidth)) | (mantissa >> exponentwidth)) ;
else
	output = sign  |  ((exponent << (31-exponentwidth)) | (mantissa >> exponentwidth)) ;

	float	x = (float)output;

	return(x);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DSDMO"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);

    // Nepotism at its finest
    DebugTrace(1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    StringCbVPrintfA(sz,sizeof(sz),pstrFormat,va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\clone.h ===
// helper function for implementing the Clone method on DMOs

#pragma once

#include "dsdmobse.h"

template<class TypeOf_CDirectSoundDMO, class TypeOf_ParamsStruct>
HRESULT StandardDMOClone(TypeOf_CDirectSoundDMO *pThis, IMediaObjectInPlace **ppCloned);

// implementation...

// The end of StandardDMOClone is the same for all types.  Implement it outside the template
// so that the code isn't duplicated.  Copies the input and output types, does the QI for IMediaObjectInPlace,
// and returns with the correct ref count.
HRESULT StandardDMOClone_Ending(IMediaObject *pThis, IMediaObject *pCloned, IMediaObjectInPlace **ppCloned);

template<class TypeOf_CDirectSoundDMO, class TypeOf_ParamsStruct>
HRESULT StandardDMOClone(TypeOf_CDirectSoundDMO *pThis, IMediaObjectInPlace **ppCloned)
{
	if (!ppCloned)
		return E_POINTER;

    HRESULT hr = S_OK;
    TypeOf_CDirectSoundDMO *pCloned = NULL;
    IUnknown *pUnk = NULL;
    IMediaObject * pClonedMediaObject = NULL;

	try 
	{
		pCloned = new TypeOf_CDirectSoundDMO( NULL, &hr );
        if( SUCCEEDED( hr ) )
       {
            hr = pCloned->NDQueryInterface( IID_IUnknown, (void **) &pUnk );
            if( SUCCEEDED(hr ) )
            {
                hr = pUnk->QueryInterface( IID_IMediaObject, (void **) &pClonedMediaObject );
                pUnk->Release();
            }
        }
	} catch(...) {}

	if (pCloned == NULL) 
	{
		return hr;
	}

	// Copy parameter control information
	if (SUCCEEDED(hr))
		hr = pCloned->CopyParamsFromSource(pThis);

	// Copy current parameter values
	TypeOf_ParamsStruct params;
	if (SUCCEEDED(hr))
		hr = pThis->GetAllParameters(&params);
	if (SUCCEEDED(hr))
		hr = pCloned->SetAllParameters(&params);

	if (SUCCEEDED(hr))
		hr = StandardDMOClone_Ending(pThis, pClonedMediaObject, ppCloned);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>
#include <strsafe.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\distort.cpp ===
#include <windows.h>

#include "distortp.h"
#include "debug.h"
#include "clone.h"

STD_CREATE(Distortion)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundDistortionDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXDistortion)
    {
        return GetInterface((IDirectSoundFXDistortion*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::CDirectSoundDistortionDMO
//
CDirectSoundDistortionDMO::CDirectSoundDistortionDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 44010;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::Init()
//
HRESULT CDirectSoundDistortionDMO::Init()
{
    DSFXDistortion distort;

    // Force recalc of all internal parameters
    //
    GetAllParameters(&distort);
    SetAllParameters(&distort);

    return Discontinuity();
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                                        max,                                        neutral,    unit text,  label,                      pwchText
    DFP_Gain,       MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_GAIN_MIN,                    DSFXDISTORTION_GAIN_MAX,                    -18,        L"",        L"Gain",                    L"",
    DFP_Edge,       MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_EDGE_MIN,                    DSFXDISTORTION_EDGE_MAX,                    15,         L"",        L"Edge",                    L"",
    DFP_LpCutoff,   MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_PRELOWPASSCUTOFF_MIN,        DSFXDISTORTION_PRELOWPASSCUTOFF_MAX,        8000,       L"",        L"PreLowpassCutoff",        L"",
    DFP_EqCenter,   MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN,   DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX,   2400,       L"",        L"PostEQCenterFrequency",   L"",
    DFP_EqWidth,    MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_POSTEQBANDWIDTH_MIN,         DSFXDISTORTION_POSTEQBANDWIDTH_MAX,         2400,       L"",        L"PostEQBandwidth",         L"",
};

HRESULT CDirectSoundDistortionDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::~CDirectSoundDistortionDMO
//
CDirectSoundDistortionDMO::~CDirectSoundDistortionDMO() 
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::Clone
//
STDMETHODIMP CDirectSoundDistortionDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundDistortionDMO, DSFXDistortion>(this, pp);
}

//
//	Bump - bump the delay pointers.
//
void CDirectSoundDistortionDMO::Bump(void)
{
// EAX {
// }
}


HRESULT CDirectSoundDistortionDMO::Discontinuity() 
{
// { EAX

	m_delayL1 = m_delayL2 = m_delayR1 = m_delayR2 = 0;
	m_ls0     = m_rs0     = 0.0;


// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

__forceinline void CDirectSoundDistortionDMO::DoOneSampleMono(int *l)
{
	float	inPortL = (float)*l;
	
	float	outPortL, tempvar;

	// One-pole lowpass filter
	outPortL	= inPortL * m_EaxLpff;
	m_ls0		= outPortL + m_ls0 * m_EaxLpfb;
	////////////////////////////////////////

	////////////////////////////////////////
	// Non-linear gain
#define LOG(x,y)	mylog(x,y)
	outPortL	= (float)LOG(m_ls0 * 0x8000, m_EaxExp_range);

	outPortL 	/= 0x8000;

	////////////////////////////////////////

	////////////////////////////////////////
	// Bandpass
	outPortL	= outPortL * m_EaxInScale;
	tempvar		= outPortL - m_delayL1 * m_EaxK2;
	tempvar		= tempvar - m_delayL2 * m_EaxK1;
	m_delayL1	= m_delayL2 + tempvar * m_EaxK1;
	m_delayL2	= tempvar;
	outPortL	= tempvar;

	////////////////////////////////////////

#ifdef GOOD_CODE_GEN
	*l = Saturate(outPortL);
#else
	int i;

#ifdef i386
	_asm {
		fld outPortL
		fistp i
	}
#else
	i = (int)outPortL;
#endif 
	if (i > 32767)
		i =  32767;
	else if ( i < -32768)
		i = -32768;

	*l = i;
#endif

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////

__forceinline void CDirectSoundDistortionDMO::DoOneSample(int *l, int *r)
{
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;
	
	float	outPortL, outPortR, tempvar;

	// One-pole lowpass filter
	outPortL	= inPortL * m_EaxLpff;
	outPortR	= inPortR * m_EaxLpff;
	m_ls0		= outPortL + m_ls0 * m_EaxLpfb;
	m_rs0		= outPortR + m_rs0 * m_EaxLpfb;
	////////////////////////////////////////

	////////////////////////////////////////
	// Non-linear gain
#define LOG(x,y)	mylog(x,y)
	outPortL	= (float)LOG(m_ls0 * 0x8000, m_EaxExp_range);
	outPortR	= (float)LOG(m_rs0 * 0x8000, m_EaxExp_range);

	outPortL 	/= 0x8000;
	outPortR 	/= 0x8000;

	////////////////////////////////////////

	////////////////////////////////////////
	// Bandpass
	outPortL	= outPortL * m_EaxInScale;
	tempvar		= outPortL - m_delayL1 * m_EaxK2;
	tempvar		= tempvar - m_delayL2 * m_EaxK1;
	m_delayL1	= m_delayL2 + tempvar * m_EaxK1;
	m_delayL2	= tempvar;
	outPortL	= tempvar;

	outPortR	= outPortR * m_EaxInScale;
	tempvar		= outPortR - m_delayR1 * m_EaxK2;
	tempvar		= tempvar - m_delayR2 * m_EaxK1;
	m_delayR1	= m_delayR2 + tempvar * m_EaxK1;
	m_delayR2	= tempvar;
	outPortR	= tempvar;
	////////////////////////////////////////

	*l = Saturate(outPortL);
	*r = Saturate(outPortR);

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::FBRProcess
//
HRESULT CDirectSoundDistortionDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
//				j  = i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
//				j =  i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::ProcessInPlace
//
HRESULT CDirectSoundDistortionDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::SetParam
//
// { EAX
// }

HRESULT CDirectSoundDistortionDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

	//if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;	// NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
	case DFP_Gain : {
		CHECK_PARAM(DSFXDISTORTION_GAIN_MIN, DSFXDISTORTION_GAIN_MAX);

		PUT_EAX_VALUE(Gain, value);

		m_EaxGain = (float)pow(10, m_EaxGain/20);

		INTERPOLATE(InScale, TOFRACTION(m_EaxScale*m_EaxGain));
		break;

	case DFP_Edge:
		CHECK_PARAM(DSFXDISTORTION_EDGE_MIN, DSFXDISTORTION_EDGE_MAX);

		PUT_EAX_VALUE(Edge, value);

		m_EaxEdge = (m_EaxEdge/100 * 29) + 2;

		PUT_EAX_VALUE(Exp_range, (DWORD) m_EaxEdge);

		SetParamInternal(DFP_EqCenter, m_EaxCenter, true);
		SetParamInternal(DFP_EqWidth,  m_EaxBandwidth, true);
		break;

	case DFP_LpCutoff:
		CHECK_PARAM(DSFXDISTORTION_PRELOWPASSCUTOFF_MIN, DSFXDISTORTION_PRELOWPASSCUTOFF_MAX);

		//Clamp at Fs/3;
        if (value > (MP_DATA)(m_EaxSamplesPerSec / 3))
        {
            value = (MP_DATA)(m_EaxSamplesPerSec / 3);
            hr = S_FALSE;
        }

		m_EaxLpfb = (float)sqrt((2*cos(2*PI*value/m_EaxSamplesPerSec)+3)/5);
		m_EaxLpff = (float)sqrt(1-m_EaxLpfb*m_EaxLpfb);
		break;

	case DFP_EqCenter: {
		CHECK_PARAM(DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN, DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX);

        //Clamp at Fs/3;
        if (value > (MP_DATA)(m_EaxSamplesPerSec / 3))
        {
            value = (MP_DATA)(m_EaxSamplesPerSec / 3);
            hr = S_FALSE;
        }

        PUT_EAX_VALUE(Center, value);

       

		double _k1, _k2, _omega;

		_omega = 2*PI*m_EaxBandwidth/m_EaxSamplesPerSec;
		_k1 = -cos(2*PI*value/m_EaxSamplesPerSec);
		_k2 = (1 - tan(_omega/2)) / (1 + tan(_omega/2));

		m_EaxScale = (float)(sqrt(1 - _k1*_k1) * sqrt(1 - _k2*_k2));
		m_EaxScale = (float)(m_EaxScale * LogNorm[(int)m_EaxEdge]);

		INTERPOLATE(K1,      TOFRACTION(_k1));
		INTERPOLATE(InScale, TOFRACTION(m_EaxScale*m_EaxGain));
		break;
	}
	case DFP_EqWidth: {
		CHECK_PARAM(DSFXDISTORTION_POSTEQBANDWIDTH_MIN, DSFXDISTORTION_POSTEQBANDWIDTH_MAX);

		//Clamp at Fs/3;
        if (value > (MP_DATA)(m_EaxSamplesPerSec / 3))
        {
            value = (MP_DATA)(m_EaxSamplesPerSec / 3);
            hr = S_FALSE;
        }

        PUT_EAX_VALUE(Bandwidth, value);

		double _k1, _k2, _omega;

		_omega = 2*PI*value/m_EaxSamplesPerSec;
		_k1 = (float)(-cos(2*PI*m_EaxCenter/m_EaxSamplesPerSec));
		_k2 = (float)((1 - tan(_omega/2)) / (1 + tan(_omega/2)));

		m_EaxScale = (float)(sqrt(1 - _k1*_k1) * sqrt(1 - _k2*_k2));
		m_EaxScale = (float)(m_EaxScale * LogNorm[(int)m_EaxEdge]);

		INTERPOLATE(K2,      TOFRACTION(_k2));
		INTERPOLATE(InScale, TOFRACTION(m_EaxScale*m_EaxGain));
		break;
	}
	}
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.

    hr2 = fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);

    //Preserve the S_FALSE if there is one
    if (FAILED(hr2))
        hr = hr2;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundDistortionDMO::SetAllParameters(LPCDSFXDistortion pDistort)
{
    HRESULT hr = S_OK;
    HRESULT hr2[5];

    ZeroMemory(hr2,sizeof(hr2));
	
	// Check that the pointer is not NULL
    if (pDistort == NULL)
    {
        Trace(1,"ERROR: pDistort is NULL\n");
        hr = E_POINTER;
    }

    // Set the parameters
    if (SUCCEEDED(hr)) hr = hr2[0] = SetParam(DFP_Gain, pDistort->fGain);
    if (SUCCEEDED(hr)) hr = hr2[1] = SetParam(DFP_Edge, pDistort->fEdge);   
    if (SUCCEEDED(hr)) hr = hr2[2] = SetParam(DFP_LpCutoff, pDistort->fPreLowpassCutoff);
    if (SUCCEEDED(hr)) hr = hr2[3] = SetParam(DFP_EqCenter, pDistort->fPostEQCenterFrequency);
    if (SUCCEEDED(hr)) hr = hr2[4] = SetParam(DFP_EqWidth, pDistort->fPostEQBandwidth);

    m_fDirty = true;

    // if we have any alternate success codes, grab the first one and return it.
    if(SUCCEEDED(hr))
    {
        for (int i = 0;i < 5; i++)
        {
            if (hr2[i] != S_OK)
            {
                hr = hr2[i];
                break;
            }
        }
    }
    
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundDistortionDMO::GetAllParameters(LPDSFXDistortion pDistort)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (pDistort == NULL)
	{
		return E_POINTER;
	}
			
#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pDistort->y = mpd; \
	}

    GET_PARAM(DFP_Edge, fEdge);
    GET_PARAM(DFP_Gain, fGain);
    GET_PARAM(DFP_LpCutoff, fPreLowpassCutoff);
    GET_PARAM(DFP_EqCenter, fPostEQCenterFrequency);
    GET_PARAM(DFP_EqWidth, fPostEQBandwidth);

	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundDistortionDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_DISTORTION;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\compressp.h ===
//
//
//
#ifndef _COMPRESSP_
#define _COMPRESSP_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS    ((float).61803398875)    // 1-x^2=x.
#define RVB_LP_COEF ((float).1)
#define MAXALLPASS  cALLPASS
#define Delay_len   DefineDelayLineSize(8)

class CDirectSoundCompressorDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXCompressor,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundCompressorDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundCompressorDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    HRESULT Init();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXCompressor);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXCompressor);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropCompressor, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXCompressor(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXCompressor(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXCompressor); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
        HRESULT hr = CPCMDMO::CheckInputType(pmt);
        if (FAILED(hr)) return hr;

        WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
        if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
            (pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
            (pWave->nChannels      != 1 && pWave->nChannels != 2)) {
            return DMO_E_TYPE_NOT_ACCEPTED;
        }

        return S_OK;
       }

private:
// { EAX
    __forceinline void DoOneSample(int *l, int *r);
    __forceinline void DoOneSampleMono(int *l);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
    type m_Eax ## var;


    DECLARE_EAX_VARS(float, AttackCoef);
    DECLARE_EAX_VARS(float, ReleaseCoef);
    DECLARE_EAX_VARS(float, CompThresh);
    DECLARE_EAX_VARS(float, CompressionRatio);
    DECLARE_EAX_VARS(float, GainBiasIP);
    DECLARE_EAX_VARS(float, GainBiasFP);
    DECLARE_EAX_VARS(float, CompInputPeak);
    DECLARE_EAX_VARS(float, CompGainMin);
    DECLARE_EAX_VARS(long , LeftPoint);
    DECLARE_EAX_VARS(long , RightPoint);
//    DECLARE_EAX_VARS(SamplesPerSec);

    float    m_Envelope;
    float    m_CompGain;

#define m_EaxSamplesPerSec m_ulSamplingRate

    __forceinline int Saturate(float f) {
                                int i;
#ifdef DONTUSEi386
                                _asm {
                                    fld f
                                    fistp i
                                }
#else
                                i = (int)f;
#endif 
                                if (i > 32767)
                                    i =  32767;
                                else if ( i < -32768)
                                    i = -32768;
                                return(i);
                            }


    __forceinline float Interpolate(float a, float b, float percent)
    {
        percent = a + (b - a) * percent;

        return(percent);
    }

    void Bump(void);

    DelayBuffer2<float, 200, 0> m_LeftDelay;
    DelayBuffer2<float, 200, 0> m_RightDelay;

// } EAX
};

EXT_STD_CREATE(Compressor);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\dllmain.cpp ===
//
// dllmain.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation
//

#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "oledll.h"
#include "dsdmo.h"
#include "chorusp.h"
#include "compressp.h"
#include "distortp.h"
#include "echop.h"
#include "flangerp.h"
#include "parameqp.h"
#include "garglep.h"
#include "sverbp.h"
#include "map.h"
#include "aecp.h"
#include "nsp.h"
#include "agcp.h"
#include "reghlp.h"


// These are linked in
class CDirectSoundI3DL2ReverbDMO;
EXT_STD_CREATE(I3DL2Reverb);
//class CDirectSoundI3DL2SourceDMO;
//EXT_STD_CREATE(I3DL2Source);

DWORD g_amPlatform;
int g_cActiveObjects = 0;

//
// this is a temporary place holder only! the dmocom.cpp base class requires this global to be defined
// so we're putting something in it for now. Class factory templates aren't used currently, but eventually
// we should use the template structure to create all dmo objects.
//
struct CComClassTemplate g_ComClassTemplates[] =
{
    {&GUID_DSFX_STANDARD_GARGLE, CreateCDirectSoundGargleDMO}
};

int g_cComClassTemplates = 0;


#define DefineClassFactory(x)                                               \
class x ## Factory : public IClassFactory                                   \
{                                                                           \
public:                                                                     \
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);        \
    virtual STDMETHODIMP_(ULONG) AddRef();                                  \
    virtual STDMETHODIMP_(ULONG) Release();                                 \
                                                                            \
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter,            \
        const IID& iid, void** ppv);                                        \
    virtual STDMETHODIMP LockServer(BOOL bLock);                            \
                                                                            \
     x ## Factory() : m_cRef(1) {}                                          \
                                                                            \
    ~ x ## Factory() {}                                                     \
                                                                            \
private:                                                                    \
    long m_cRef;                                                            \
};                                                                          \
STDMETHODIMP x ## Factory::QueryInterface(                                  \
    const IID &iid, void **ppv)                                             \
{                                                                           \
    if(iid == IID_IUnknown || iid == IID_IClassFactory)                     \
    {                                                                       \
        *ppv = static_cast<IClassFactory*>(this);                           \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *ppv = NULL;                                                        \
        return E_NOINTERFACE;                                               \
    }                                                                       \
                                                                            \
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();                            \
                                                                            \
    return S_OK;                                                            \
}                                                                           \
STDMETHODIMP_(ULONG) x ## Factory::AddRef()                                 \
{                                                                           \
    return InterlockedIncrement(&m_cRef);                                   \
}                                                                           \
                                                                            \
STDMETHODIMP_(ULONG) x ## Factory::Release()                                \
{                                                                           \
    if(!InterlockedDecrement(&m_cRef))                                      \
    {                                                                       \
        delete this;                                                        \
        return 0;                                                           \
    }                                                                       \
                                                                            \
    return m_cRef;                                                          \
}                                                                           \
                                                                            \
STDMETHODIMP x ## Factory::CreateInstance(                                  \
    IUnknown* pUnknownOuter,  const IID& riid, void** ppv)                  \
{                                                                           \
    Trace(DM_DEBUG_STATUS, "Create " #x "\n");                              \
    if (ppv == NULL)                                                        \
    {                                                                       \
        return E_POINTER;                                                   \
    }                                                                       \
                                                                            \
    if (pUnknownOuter != NULL) {                                            \
        if (IsEqualIID(riid,IID_IUnknown) == FALSE) {                       \
            return ResultFromScode(E_NOINTERFACE);                          \
        }                                                                   \
    }                                                                       \
                                                                            \
    HRESULT hr = S_OK;                                                      \
    CComBase *p = Create ## x(pUnknownOuter, &hr);                          \
    if (SUCCEEDED(hr))                                                      \
    {                                                                       \
        p->NDAddRef();                                                      \
        hr = p->NDQueryInterface(riid, ppv);                                \
        p->NDRelease();                                                     \
    }                                                                       \
                                                                            \
    return hr;                                                              \
}                                                                           \
STDMETHODIMP x ## Factory::LockServer(BOOL bLock)                           \
{                                                                           \
    if(bLock)                                                               \
    {                                                                       \
        InterlockedIncrement(&g_cLock);                                     \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        InterlockedDecrement(&g_cLock);                                     \
    }                                                                       \
                                                                            \
    return S_OK;                                                            \
}


#define DefineDMOClassFactory(x) DefineClassFactory(CDirectSound ## x ## DMO)
#define DefineDMOCaptureClassFactory(x) DefineClassFactory(CDirectSoundCapture ## x ## DMO)

//////////////////////////////////////////////////////////////////////
// Globals
//

// Registry Info
//
#define DefineNames(x)                                                              \
TCHAR g_sz## x ##FriendlyName[]    = TEXT("DirectSound" #x "DMO");                  \
TCHAR g_sz## x ##VerIndProgID[]    = TEXT("Microsoft.DirectSound" #x "DMO");        \
TCHAR g_sz## x ##ProgID[]          = TEXT("Microsoft.DirectSound" #x "DMO.1");      \

#define DefineCaptureNames(x)                                                              \
TCHAR g_sz## x ##FriendlyName[]    = TEXT("DirectSoundCapture" #x "DMO");                  \
TCHAR g_sz## x ##VerIndProgID[]    = TEXT("Microsoft.DirectSoundCapture" #x "DMO");        \
TCHAR g_sz## x ##ProgID[]          = TEXT("Microsoft.DirectSoundCapture" #x "DMO.1");      \

DefineNames(Chorus)
DefineNames(Compressor)
DefineNames(Distortion)
DefineNames(Echo)
DefineNames(Flanger)
DefineNames(ParamEq)
DefineNames(Gargle)
DefineNames(WavesReverb)
DefineNames(I3DL2Reverb)
//DefineNames(I3DL2Source)
//DefineCaptureNames(MicArray)
DefineCaptureNames(Aec)
DefineCaptureNames(NoiseSuppress)
DefineCaptureNames(Agc)

// Dll's hModule
HMODULE g_hModule = NULL;

// Count of class factory server locks
long g_cLock = 0;

DefineDMOClassFactory(Chorus)
DefineDMOClassFactory(Compressor)
DefineDMOClassFactory(Distortion)
DefineDMOClassFactory(Echo)
DefineDMOClassFactory(Flanger)
DefineDMOClassFactory(ParamEq)
DefineDMOClassFactory(I3DL2Reverb)
//DefineDMOClassFactory(I3DL2Source)
DefineDMOClassFactory(Gargle)
DefineDMOClassFactory(WavesReverb)

// Capture FXs
//DefineDMOCaptureClassFactory(MicArray)
DefineDMOCaptureClassFactory(Aec)
DefineDMOCaptureClassFactory(NoiseSuppress)
DefineDMOCaptureClassFactory(Agc)

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cActiveObjects || g_cLock)
    {
        return S_FALSE;
    }
    return S_OK;
}

// Hack to make these macros continue to work:
#define GUID_DSFX_STANDARD_Chorus       GUID_DSFX_STANDARD_CHORUS
#define GUID_DSFX_STANDARD_Compressor   GUID_DSFX_STANDARD_COMPRESSOR
#define GUID_DSFX_STANDARD_Distortion   GUID_DSFX_STANDARD_DISTORTION
#define GUID_DSFX_STANDARD_Echo         GUID_DSFX_STANDARD_ECHO
#define GUID_DSFX_STANDARD_Flanger      GUID_DSFX_STANDARD_FLANGER
#define GUID_DSFX_STANDARD_ParamEq      GUID_DSFX_STANDARD_PARAMEQ
#define GUID_DSFX_STANDARD_Gargle       GUID_DSFX_STANDARD_GARGLE
#define GUID_DSFX_STANDARD_WavesReverb  GUID_DSFX_WAVES_REVERB
#define GUID_DSFX_STANDARD_I3DL2Reverb  GUID_DSFX_STANDARD_I3DL2REVERB
#define GUID_DSFX_STANDARD_I3DL2Source  GUID_DSFX_STANDARD_I3DL2SOURCE

// Capture
#define GUID_DSCFX_MS_Aec               GUID_DSCFX_MS_AEC
#define GUID_DSCFX_MS_NoiseSuppress     GUID_DSCFX_MS_NS
#define GUID_DSCFX_MS_Agc               GUID_DSCFX_MS_AGC

#define GUID_DSCFX_SYSTEM_MicArray      GUID_DSCFX_SYSTEM_MA
#define GUID_DSCFX_SYSTEM_Aec           GUID_DSCFX_SYSTEM_AEC
#define GUID_DSCFX_SYSTEM_NoiseSuppress GUID_DSCFX_SYSTEM_NS
#define GUID_DSCFX_SYSTEM_Agc           GUID_DSCFX_SYSTEM_AGC

#define GetClassObjectCase(x,t) \
    if (clsid == x) { \
        p = static_cast<IUnknown*> ((IClassFactory*) (new t)); \
    } else

#define GetClassObjectCaseEnd \
    { return CLASS_E_CLASSNOTAVAILABLE; }

#define GetClassObjectCaseFX(x) \
    GetClassObjectCase(GUID_DSFX_STANDARD_ ## x, CDirectSound ## x ## DMOFactory)

#define GetClassObjectCaseCaptureFX(w,x) \
    GetClassObjectCase(GUID_DSCFX_## w ##_ ## x, CDirectSoundCapture ## x ## DMOFactory)

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    if (ppv == NULL)
    {
        return E_POINTER;
    }

    IUnknown* p = NULL;

    // Render FX
    GetClassObjectCaseFX(Chorus)
    GetClassObjectCaseFX(Compressor)
    GetClassObjectCaseFX(Distortion)
    GetClassObjectCaseFX(Echo)
    GetClassObjectCaseFX(Flanger)
    GetClassObjectCaseFX(ParamEq)
    GetClassObjectCaseFX(I3DL2Reverb)
//    GetClassObjectCaseFX(I3DL2Source)
    GetClassObjectCaseFX(Gargle)
    GetClassObjectCaseFX(WavesReverb)

    // Capture FX
    GetClassObjectCaseCaptureFX(MS, Aec)
    GetClassObjectCaseCaptureFX(MS, NoiseSuppress)
    GetClassObjectCaseCaptureFX(MS, Agc)

//    GetClassObjectCaseCaptureFX(SYSTEM, MicArray)
    GetClassObjectCaseCaptureFX(SYSTEM, Aec)
    GetClassObjectCaseCaptureFX(SYSTEM, NoiseSuppress)
    GetClassObjectCaseCaptureFX(SYSTEM, Agc)


    GetClassObjectCaseEnd

    if(!p)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = p->QueryInterface(iid, ppv);
    p->Release();

    return hr;
}

#define DoUnregister(x)                                                 \
         UnregisterServer(GUID_DSFX_STANDARD_ ## x,                     \
                          g_sz ## x ## FriendlyName,                    \
                          g_sz ## x ## VerIndProgID,                    \
                          g_sz ## x ## ProgID)

#define DoRegister(x)                                                   \
         RegisterServer(g_hModule,                                      \
                        GUID_DSFX_STANDARD_ ## x,                       \
                        g_sz ## x ## FriendlyName,                      \
                        g_sz ## x ## VerIndProgID,                      \
                        g_sz ## x ## ProgID)

#define DoDMORegister(x)                                                \
         DMORegister(L#x,                                               \
         GUID_DSFX_STANDARD_ ## x,                                      \
         DMOCATEGORY_AUDIO_EFFECT,                                      \
         0, 1, &mt, 1, &mt)

#define DoDMOUnregister(x)                                              \
         DMOUnregister(GUID_DSFX_STANDARD_ ## x,                        \
         DMOCATEGORY_AUDIO_EFFECT)

#define Unregister(x)                                                   \
    if (SUCCEEDED(hr)) hr = DoDMOUnregister(x);                         \
    if (SUCCEEDED(hr)) hr = DoUnregister(x);

#define Register(x)                                                     \
    if (SUCCEEDED(hr)) hr = DoRegister(x);                              \
    if (SUCCEEDED(hr)) hr = DoDMORegister(x);

// Capture Defines
#define DoCaptureUnregister(w,x)                                        \
         UnregisterServer(GUID_DSCFX_## w ##_ ## x,                     \
                          g_sz ## x ## FriendlyName,                    \
                          g_sz ## x ## VerIndProgID,                    \
                          g_sz ## x ## ProgID)

#define DoCaptureRegister(w,x)                                          \
         RegisterServer(g_hModule,                                      \
                        GUID_DSCFX_## w ##_ ## x,                       \
                        g_sz ## x ## FriendlyName,                      \
                        g_sz ## x ## VerIndProgID,                      \
                        g_sz ## x ## ProgID)

#define DoDMOCaptureRegister(t,w,x,y)                                       \
         DMORegister(L#t,                                               \
         GUID_DSCFX_## w ##_ ## x,                                      \
         y,                                      \
         0, 1, &mt, 1, &mt)

#define DoDMOCaptureRegisterCpuResources(w,x,z)                       \
         DMORegisterCpuResources(                                              \
         GUID_DSCFX_## w ##_ ## x,                                      \
         z)

#define DoDMOCaptureUnregister(w,x,y)                                     \
         DMOUnregister(GUID_DSCFX_## w ##_ ## x,                        \
         y)

#define CaptureUnregister(w,x,y)                                          \
    if (SUCCEEDED(hr)) hr = DoDMOCaptureUnregister(w,x,y);                \
    if (SUCCEEDED(hr)) hr = DoCaptureUnregister(w,x);

#define CaptureRegister(t,w,x,y,z)                                            \
    if (SUCCEEDED(hr)) hr = DoCaptureRegister(w,x);                     \
    if (SUCCEEDED(hr)) hr = DoDMOCaptureRegister(t,w,x,y);              \
    if (SUCCEEDED(hr)) hr = DoDMOCaptureRegisterCpuResources(w,x,z);


//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;

    Unregister(Chorus);
    Unregister(Compressor);
    Unregister(Distortion);
    Unregister(Echo);
    Unregister(Flanger);
    Unregister(ParamEq);
    Unregister(I3DL2Reverb);
//    Unregister(I3DL2Source);
    Unregister(Gargle);
    Unregister(WavesReverb);

    // Capture FXs
    CaptureUnregister(MS,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL);
    CaptureUnregister(MS,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS);
    CaptureUnregister(MS,Agc,DMOCATEGORY_AGC);

//    CaptureUnregister(SYSTEM,MicArray,DMOCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
    CaptureUnregister(SYSTEM,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL);
    CaptureUnregister(SYSTEM,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS);
    CaptureUnregister(SYSTEM,Agc,DMOCATEGORY_AGC);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;

    DMO_PARTIAL_MEDIATYPE mt;
    mt.type = MEDIATYPE_Audio;
    mt.subtype = MEDIASUBTYPE_PCM;

    Register(Chorus);
    Register(Compressor);
    Register(Distortion);
    Register(Echo);
    Register(Flanger);
    Register(ParamEq);
    Register(I3DL2Reverb);
//    Register(I3DL2Source);
    Register(Gargle);
    Register(WavesReverb);

    // Capture FXs
    CaptureRegister(Microsoft AEC,MS,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL,DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES);
    CaptureRegister(Microsoft Noise Suppression,MS,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS,DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES);
    CaptureRegister(Microsoft AGC,MS,Agc,DMOCATEGORY_AGC,DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES);

//    CaptureRegister(System Microphone Array,SYSTEM,MicArray,DMOCATEGORY_MICROPHONE_ARRAY_PROCESSOR,DS_SYSTEM_RESOURCES_UNDEFINED);
    CaptureRegister(System AEC,SYSTEM,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL,DS_SYSTEM_RESOURCES_UNDEFINED);
    CaptureRegister(System Noise Suppression,SYSTEM,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS,DS_SYSTEM_RESOURCES_UNDEFINED);
    CaptureRegister(System AGC,SYSTEM,Agc,DMOCATEGORY_AGC,DS_SYSTEM_RESOURCES_UNDEFINED);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
#ifdef DBG
    if(dwReason < nReasons)
    {
        Trace(DM_DEBUG_STATUS, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(DM_DEBUG_STATUS, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if(++g_cActiveObjects == 1)
            {
            #ifdef DBG
                DebugInit();
            #endif

                if(!DisableThreadLibraryCalls(hModule))
                {
                    Trace(DM_DEBUG_STATUS, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

                g_amPlatform = VER_PLATFORM_WIN32_WINDOWS; // win95 assumed in case GetVersionEx fails

                OSVERSIONINFO osInfo;
                osInfo.dwOSVersionInfoSize = sizeof(osInfo);
                if (GetVersionEx(&osInfo))
                {
                    g_amPlatform = osInfo.dwPlatformId;
                }
            }
            break;

        case DLL_PROCESS_DETACH:
            if(--g_cActiveObjects == 0)
            {
                Trace(DM_DEBUG_STATUS, "Unloading\n");
            }
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\distortp.h ===
//
//
//
#ifndef _DirectSoundSampleDMO_p_
#define _DirectSoundSampleDMO_p_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS

class CDirectSoundDistortionDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXDistortion,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundDistortionDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundDistortionDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);
    
    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    
    // Init is called by the DMO base class when both input and output media
    // types have been set up.
    //
    HRESULT Init();  
  

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    /* IFilter */
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion);

    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropDistortion, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );


    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXDistortion(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXDistortion(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXDistortion); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    DWORD ParamCount();

    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);
	__forceinline void DoOneSampleMono(int *l);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(long,  Exp_range);
	DECLARE_EAX_VARS(float, InScale);
	DECLARE_EAX_VARS(float, Lpfb);
	DECLARE_EAX_VARS(float, Lpff);
	DECLARE_EAX_VARS(float, K1);
	DECLARE_EAX_VARS(float, K2);
	DECLARE_EAX_VARS(float, Edge);
	DECLARE_EAX_VARS(float, Gain);
	DECLARE_EAX_VARS(float, Scale);
	DECLARE_EAX_VARS(float, Center);
	DECLARE_EAX_VARS(float, Bandwidth);

//	DECLARE_EAX_VARS(float, SamplesPerSec);
#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	void Bump(void);

	float			m_ls0;
	float			m_rs0;
	float			m_delayL1;
	float			m_delayL2;
	float			m_delayR1;
	float			m_delayR2;

// } EAX
};

EXT_STD_CREATE(Distortion);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\dsdmo.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsdmo.h
 *  Content:    Global declarations for dsdmo.dll.
 *
 ***************************************************************************/

#ifndef _DSDMO_H_
#define _DSDMO_H_

#include <mmsystem.h>
#include <dsoundp.h>  // For effect IID and ClassID declarations
#include "debug.h"

extern double LogNorm[32];
extern float mylog( float finput, unsigned long maxexponent);
extern DWORD g_amPlatform;
extern long g_cComponent;
extern HMODULE g_hModule;

#define EXT_STD_CREATE(x) \
    extern CComBase * WINAPI CreateCDirectSound ## x ## DMO(IUnknown *punkOuter, HRESULT *phr);

#define EXT_STD_CAPTURE_CREATE(x) \
    extern CComBase * WINAPI CreateCDirectSoundCapture ## x ## DMO(IUnknown *punkOuter, HRESULT *phr);

// Disable exception warnings
#pragma warning(disable:4530)

#define STD_CREATE(x) \
CComBase* WINAPI CreateCDirectSound ## x ## DMO(IUnknown *punkOuter, HRESULT *phr) \
    {                                                                   \
        *phr = E_OUTOFMEMORY;                                           \
        CDirectSound ## x ## DMO *p = NULL;                             \
        try {                                                           \
            p = new CDirectSound ## x ## DMO(punkOuter, phr);           \
        } catch (...) {};                                               \
        if (p) {                                                        \
            *phr = p->InitOnCreation();                                 \
            if (FAILED(*phr))                                           \
            {                                                           \
                p->Release();                                           \
                p = NULL;                                               \
            }                                                           \
        }                                                               \
        else                                                            \
        {                                                               \
            Trace(1,"ERROR: Out of memory\n");                          \
        }                                                               \
        return p;                                                       \
    }

#define STD_CAPTURE_CREATE(x) \
CComBase* WINAPI CreateCDirectSoundCapture ## x ## DMO(IUnknown *punkOuter, HRESULT *phr) \
    {                                                                   \
        HRESULT hr = E_OUTOFMEMORY;                                     \
        CDirectSoundCapture ## x ## DMO *p = NULL;                      \
        try {                                                           \
            p = new CDirectSoundCapture ## x ## DMO(punkOuter, phr);    \
        } catch (...) {};                                               \
        if (p) {                                                        \
            *phr = p->InitOnCreation();                                 \
            if (FAILED(*phr))                                           \
            {                                                           \
                p->Release();                                           \
                p = NULL;                                               \
            }                                                           \
        }                                                               \
        else                                                            \
        {                                                               \
            Trace(1,"ERROR: Out of memory\n");                          \
        }                                                               \
        return p;                                                       \
    }


// Common #define's and templates for all filters
//
#define MaxSamplesPerSec        96000
#define PI                      3.1415926535
#define DefineMsecSize(y, x)    ((int)(((x) * (y)) / 1000))
#define DefineDelayLineSize(x)  DefineMsecSize(MaxSamplesPerSec, x)
//#define GetMsecPos(x)         (DefineDelayLineSize(x))
#define GetMsecPos(x)           (DefineMsecSize(m_EaxSamplesPerSec, x))
#define FractMask               0xfff
#define FractMultiplier         0x1000

template <int BufferSize> class DelayBuffer
{
#define DYNAMIC_ARRAYS 1
#if DYNAMIC_ARRAYS
    int *Buffer;
#else
    int Buffer[BufferSize];
#endif
    int BufferPos;

public:
    inline void Init(int SamplesPerSec)
    {
#if DYNAMIC_ARRAYS
        if (SamplesPerSec <= 0) {
            if (!SamplesPerSec) Buffer = 0;
            else if (Buffer) delete Buffer;

            return;
        }

        if (Buffer) delete Buffer;

        Buffer = new int[BufferSize];
#else
        if (SamplesPerSec <= 0) return;
#endif
        BufferPos = 0;
        memset(Buffer, 0, BufferSize * sizeof(int));
    }

    __forceinline int Pos(int x)
    {
        x += BufferPos;
        while (x < 0)
            x += BufferSize * FractMultiplier;
        x /= FractMultiplier;
        while (x >= BufferSize)
            x -= BufferSize;

        return(x);
    }

    __forceinline void Bump(void)
    {
        if (BufferPos == 0)
            BufferPos += BufferSize * FractMultiplier;
        if (BufferPos < 0)
            BufferPos += BufferSize * FractMultiplier;
        BufferPos -= FractMultiplier;
    }

    __forceinline int& operator[] (int i)
    {
        return (Buffer[i]);
    }
};

template <class type, int Msec, int AdditionalPositions> class DelayBuffer2
{
#if DYNAMIC_ARRAYS
    type *Buffer;
#else
    union {
        type Buffer[DefineDelayLineSize(Msec) + AdditionalPositions];
        type BufferDisplay[DefineDelayLineSize(Msec/10) + AdditionalPositions];
    };
#endif
    int BufferPos;
    int BufferSize;

public:
    inline HRESULT Init(int SamplesPerSec)
    {
        HRESULT hr = S_OK;
        BufferSize = DefineMsecSize(Msec, SamplesPerSec) + AdditionalPositions;
#if DYNAMIC_ARRAYS
        if (SamplesPerSec <= 0) {
            if (!SamplesPerSec) Buffer = 0;
            else if (Buffer) delete Buffer;

            return hr;
        }

        if (Buffer) delete Buffer;

        Buffer = new type[BufferSize];
#else
        if (SamplesPerSec <= 0) return;
#endif

        BufferPos = 0;

        if (Buffer != NULL)
        {
            memset(Buffer, 0, BufferSize * sizeof(type));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        return hr;
    }


    __forceinline int FractPos(int x)
    {
        x *= FractMultiplier;
        x += BufferPos;
        while (x < 0)
            x += BufferSize * FractMultiplier;
        x /= FractMultiplier;
        while (x >= BufferSize)
            x -= BufferSize;

        return(x);
    }

    __forceinline int Pos(int x)
    {
        x += BufferPos;
        while (x < 0)
            x += BufferSize * FractMultiplier;
        x /= FractMultiplier;
        while (x >= BufferSize)
            x -= BufferSize;

        return(x);
    }

    __forceinline int LastPos(int x)
    {
        x = Pos(x + BufferSize - 1);

        return(x);
    }

    __forceinline void Bump(void)
    {
        if (BufferPos == 0)
            BufferPos += BufferSize * FractMultiplier;
        if (BufferPos < 0)
            BufferPos += BufferSize * FractMultiplier;
        BufferPos -= FractMultiplier;
    }

    __forceinline type& operator[] (int i)
    {
        return (Buffer[i]);
    }

    __forceinline void ZeroBuffer(void)
    {
        if (Buffer != NULL)
            ZeroMemory(Buffer,BufferSize * sizeof(type));
    }

};

//
//
//
// { EAX
#ifndef _EAXDMO_
#define _EAXDMO_

#define CHECK_PARAM(lo, hi) \
    if (value < lo || value > hi) {return DSERR_INVALIDPARAM;} else;

#define PUT_EAX_VALUE(var, val) \
    m_Eax ## var = val

#define PUT_EAX_FVAL(var, val) \
    m_Eax ## var = (float)(val)

#define PUT_EAX_LVAL(var, val) \
    m_Eax ## var = (long)(val)

#define TOFRACTION(x)       ((float)x)
#define INTERPOLATE(x, y)   PUT_EAX_FVAL(x, (y))    // ??? Smooth it out...

#define SET_MPV_FLOAT(var) \
    MP_DATA mpv; \
    mpv = (MP_DATA)var;

#define SET_MPV_LONG SET_MPV_FLOAT

enum ChorusFilterParams
{
    CFP_Wetdrymix = 0,
    CFP_Depth,
    CFP_Frequency,
    CFP_Waveform,
    CFP_Phase,
    CFP_Feedback,
    CFP_Delay,
    CFP_MAX
};

enum CompressorFilterParams
{
    CPFP_Gain = 0,
    CPFP_Attack,
    CPFP_Release,
    CPFP_Threshold,
    CPFP_Ratio,
    CPFP_Predelay,
    CPFP_MAX
};

enum DistortionFilterParams
{
    DFP_Gain = 0,
    DFP_Edge,
    DFP_LpCutoff,
    DFP_EqCenter,
    DFP_EqWidth,
    DFP_MAX
};

enum EchoFilterParams
{
    EFP_Wetdrymix = 0,
    EFP_Feedback,
    EFP_DelayLeft,
    EFP_DelayRight,
    EFP_PanDelay,
    EFP_MAX
};

enum FilterParams
{
    FFP_Wetdrymix = 0,
    FFP_Waveform,
    FFP_Frequency,
    FFP_Depth,
    FFP_Phase,
    FFP_Feedback,
    FFP_Delay,
    FFP_MAX
};

enum ParamEqFilterParams
{
    PFP_Center = 0,
    PFP_Bandwidth,
    PFP_Gain,
    PFP_MAX
};

enum GargleFilterParams
{
    GFP_Rate = 0,
    GFP_Shape,
    GFP_MAX
};

enum SVerbParams
{
    SVP_Gain = 0,
    SVP_Mix,
    SVP_ReverbTime,
    SVP_Ratio,
    SVP_MAX
};

enum MicArrayParams
{
    MAP_Enable = 0,
    MAP_Reset,
    MAP_MAX
};

enum AecParams
{
    AECP_Enable = 0,
    AECP_NoiseFill,
    AECP_Mode,
    AECP_MAX
};

enum NoiseSuppressParams
{
    NSP_Enable = 0,
    NSP_MAX
};

enum AgcParams
{
    AGCP_Enable = 0,
    AGCP_Reset,
    AGCP_MAX
};

#define GET_PUT(x, type) \
    STDMETHOD(get_Eax ## x) \
        ( THIS_ \
        type *Eax ## x \
        ) PURE; \
    STDMETHOD(put_Eax ## x) \
        ( THIS_ \
        type Eax ## x \
        ) PURE

interface IChorus : public IUnknown
{
public:
    GET_PUT(Wetdrymix,  float);
    GET_PUT(Depth,      float);
    GET_PUT(Frequency,  float);
    GET_PUT(Waveform,   long);
    GET_PUT(Phase,      long);
    GET_PUT(Feedback,   float);
    GET_PUT(Delay,      float);

};

interface ICompressor : public IUnknown
{
public:
    GET_PUT(Gain,       float);
    GET_PUT(Attack,     float);
    GET_PUT(Release,    float);
    GET_PUT(Threshold,  float);
    GET_PUT(Ratio,      float);
    GET_PUT(Predelay,   float);
};

interface IDistortion : public IUnknown
{
public:
    GET_PUT(Gain,       float);
    GET_PUT(Edge,       float);
    GET_PUT(LpCutoff,   float);
    GET_PUT(EqCenter,   float);
    GET_PUT(EqWidth,    float);
};

interface IEcho : public IUnknown
{
public:
    GET_PUT(Wetdrymix,  float);
    GET_PUT(Feedback,   float);
    GET_PUT(DelayLeft,  float);
    GET_PUT(DelayRight, float);
    GET_PUT(PanDelay,   long);
};

interface IFlanger : public IUnknown
{
public:
    GET_PUT(Wetdrymix,  float);
    GET_PUT(Waveform,   long);
    GET_PUT(Frequency,  float);
    GET_PUT(Depth,      float);
    GET_PUT(Phase,      long);
    GET_PUT(Feedback,   float);
    GET_PUT(Delay,      float);
};

interface IParamEq : public IUnknown
{
public:
    GET_PUT(Center,     float);
    GET_PUT(Bandwidth,  float);
    GET_PUT(Gain,       float);
};

#undef GET_PUT

DEFINE_GUID(CLSID_DirectSoundPropGargle,0x794885CC,0x5EB7,0x46E3,0xA9,0x37,0xAD,0x89,0x0A,0x6C,0x66,0x77);
DEFINE_GUID(CLSID_DirectSoundPropChorus,0x60129CFD,0x2E9B,0x4098,0xAA,0x4B,0xD6,0xCF,0xAD,0xA2,0x65,0xC3);
DEFINE_GUID(CLSID_DirectSoundPropFlanger,0x22AF00DF,0x46B4,0x4F51,0xA3,0x63,0x68,0x54,0xD5,0x2E,0x13,0xA0);
DEFINE_GUID(CLSID_DirectSoundPropDistortion,0x5858107D,0x11EA,0x47B1,0x96,0x94,0x3F,0x29,0xF7,0x68,0x0F,0xB8);
DEFINE_GUID(CLSID_DirectSoundPropEcho,0xD45CF2C7,0x48CF,0x4234,0x86,0xE2,0x45,0x59,0xC3,0x2F,0xAD,0x1A);
DEFINE_GUID(CLSID_DirectSoundPropCompressor,0xED3DC730,0x31E5,0x4108,0xAD,0x8A,0x39,0x62,0xC9,0x30,0x42,0x5E);
DEFINE_GUID(CLSID_DirectSoundPropParamEq,0xAE86C36D,0x808E,0x4B07,0xB7,0x99,0x56,0xD7,0x36,0x1C,0x38,0x35);
DEFINE_GUID(CLSID_DirectSoundPropWavesReverb,0x6A879859,0x3858,0x4322,0x97,0x1A,0xB7,0x05,0xF3,0x49,0xF1,0x24);
DEFINE_GUID(CLSID_DirectSoundPropI3DL2Reverb,0xD3952B77,0x2D22,0x4B72,0x8D,0xF4,0xBA,0x26,0x7A,0x9C,0x12,0xD0);
DEFINE_GUID(CLSID_DirectSoundPropI3DL2Source,0x3DC26D0C,0xBEFF,0x406C,0x89,0xB0,0xCA,0x13,0xE2,0xBD,0x91,0x72);

// } EAX

#endif

#endif // _DSDMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\dsdmobse.h ===
/*
 * DirectSound DirectMediaObject base classes 
 *
 * Copyright (c) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.  
 */
#ifndef _DsDmoBase_
#define _DsDmoBase_

#define DMO_NOATL

#include <objbase.h>
#include <dmobase.h>
#include <medparam.h>
#include <mmsystem.h>
#include <dsoundp.h>

#ifndef RELEASE
#define RELEASE(x) { if (x) (x)->Release(); x = NULL; }
#endif

// Macro to handle QueryInterface in the derived class for interfaces
// implemented by this base class.
//
#define IMP_DSDMO_QI(iid, ppv)      \
{                                                   \
    *ppv = NULL;                                    \
         if (iid == IID_IPersistStream)       *ppv = (void**)static_cast<IPersistStream*>(this); \
    else if (iid == IID_IMediaObjectInPlace)  *ppv = (void**)static_cast<IMediaObjectInPlace*>(this); \
    else if (iid == IID_IDirectSoundDMOProxy) *ppv = (void**)static_cast<IDirectSoundDMOProxy*>(this); \
    if (*ppv) \
    { \
        AddRef(); \
        return S_OK; \
    } \
}

class CDirectSoundDMO :
      public CPCMDMO,
      public IPersistStream,
      public IMediaObjectInPlace,
      public IDirectSoundDMOProxy
{
public:
    CDirectSoundDMO();
    virtual ~CDirectSoundDMO();

    /* IPersist */
    STDMETHODIMP GetClassID                 (THIS_ CLSID *pClassID);
    
    /* IPersistStream */
    STDMETHODIMP IsDirty                    (THIS);
    STDMETHODIMP Load                       (THIS_ IStream *pStm); 
    STDMETHODIMP Save                       (THIS_ IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax                 (THIS_ ULARGE_INTEGER *pcbSize);

    /* IMediaObjectInPlace */
    STDMETHODIMP Process                    (THIS_ ULONG ulSize, BYTE *pData, REFERENCE_TIME rtStart, DWORD dwFlags);
    STDMETHODIMP GetLatency                 (THIS_ REFERENCE_TIME *prt);

    /* IDirectSoundDMOProxy */
    STDMETHODIMP AcquireResources           (THIS_ IKsPropertySet *pKsPropertySet);
    STDMETHODIMP ReleaseResources           (THIS);
    STDMETHODIMP InitializeNode             (THIS_ HANDLE hPin, ULONG ulNodeId);

protected:
    // Information about each parameter. This is only needed by the
    // author time object.
    //

    // Process in place
    //
    virtual HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags) = 0;

    // Send a parameter to the hardware. Called by the base class on SetParam if
    // hardware is connected. This is virtual so a DMO can use the base class but
    // override the way it talks to hardware.
    //
    virtual HRESULT ProxySetParam(DWORD dwParamIndex, MP_DATA value);

    // Derived class can use this to determine if hardware is turned on.
    //
    inline bool IsInHardware()
    { return m_fInHardware; }

protected:
    HANDLE                  m_hPin;
    ULONG                   m_ulNodeId;

private:
    MP_DATA                *m_mpvCache;
    IKsPropertySet         *m_pKsPropertySet;
    bool                    m_fInHardware;

};  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\dmocom.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CComBase

b. Make a static CreateInstance function that takes an IUnknown* and an
   HRESULT*. The IUnknown* defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

c. Have a constructor for your object that passes the IUnknown* and HRESULT*
   to the CComBase constructor. You can set the HRESULT if you have an error,
   or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a CComClassTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CComBase
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use \() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CComBase constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NDQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NDQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

#include <windows.h>
#include <basetyps.h>
#include <unknwn.h>

extern int g_cActiveObjects;

STDAPI CreateCLSIDRegKey(REFCLSID clsid, const char *szName);

STDAPI RemoveCLSIDRegKey(REFCLSID clsid);

#ifdef DEBUG
    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DebugAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif
    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DebugBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DebugBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}
#else
    #ifndef ASSERT
       #define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
#endif

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INDUNKNOWN_DEFINED
DECLARE_INTERFACE(INDUnknown)
{
    STDMETHOD(NDQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NDAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NDRelease)(THIS) PURE;
};
#define INDUNKNOWN_DEFINED
#endif

class CBaseObject {
public:
   CBaseObject() {g_cActiveObjects++;}
   ~CBaseObject() {g_cActiveObjects--;}
};

/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class CComBase : public INDUnknown,
                 CBaseObject
{
private:
    IUnknown* m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NDRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CComBase(IUnknown* pUnk);
    virtual ~CComBase() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CComBase(IUnknown* pUnk,HRESULT *phr);

    /* Return the owner of this object */

    IUnknown* GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CComBase *CreateInstance(IUnknown*, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NDQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NDAddRef();
    STDMETHODIMP_(ULONG) NDRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CComBase *(CALLBACK *LPFNNewCOMObject)(IUnknown* pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

struct CComClassTemplate {
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
};


/* You must override the (pure virtual) NDQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\echo.cpp ===
#include <windows.h>

#include "echop.h"
#include "clone.h"

STD_CREATE(Echo)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundEchoDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXEcho)
    {
        return GetInterface((IDirectSoundFXEcho*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::CDirectSoundEchoDMO
//
CDirectSoundEchoDMO::CDirectSoundEchoDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr) ,
    m_fDirty(true)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 22050;

	m_DelayL.Init(0);
	m_DelayR.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::Init()
//
HRESULT CDirectSoundEchoDMO::Init()
{
    DSFXEcho echo;
    HRESULT hr;

    // Force recalc of all internal parameters
    hr = GetAllParameters(&echo);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&echo);

    if (SUCCEEDED(hr)) hr = m_DelayL.Init(m_EaxSamplesPerSec);
	if (SUCCEEDED(hr)) hr = m_DelayR.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = Discontinuity();
    return hr;
}


const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    EFP_Wetdrymix,  MPT_FLOAT,  g_capsAll,  DSFXECHO_WETDRYMIX_MIN,     DSFXECHO_WETDRYMIX_MAX,     50,                     L"",        L"WetDryMix",   L"",
    EFP_Feedback,   MPT_FLOAT,  g_capsAll,  DSFXECHO_FEEDBACK_MIN,      DSFXECHO_FEEDBACK_MAX,      50,                     L"",        L"Feedback",    L"",
    EFP_DelayLeft,  MPT_FLOAT,  g_capsAll,  DSFXECHO_LEFTDELAY_MIN,     DSFXECHO_LEFTDELAY_MAX,     500,                    L"",        L"LeftDelay",   L"",
    EFP_DelayRight, MPT_FLOAT,  g_capsAll,  DSFXECHO_RIGHTDELAY_MIN,    DSFXECHO_RIGHTDELAY_MAX,    500,                    L"",        L"RightDelay",  L"",
    EFP_PanDelay,   MPT_BOOL,   g_capsAll,  DSFXECHO_PANDELAY_MIN,      DSFXECHO_PANDELAY_MAX,      0,                      L"",        L"PanDelay",    L"",
};

HRESULT CDirectSoundEchoDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::~CDirectSoundEchoDMO
//
CDirectSoundEchoDMO::~CDirectSoundEchoDMO() 
{
	m_DelayL.Init(-1);
	m_DelayR.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::Clone
//
STDMETHODIMP CDirectSoundEchoDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundEchoDMO, DSFXEcho>(this, pp);
}

//
//	Bump - bump the delay pointers.
//
void CDirectSoundEchoDMO::Bump(void)
{
// EAX {

	m_DelayL.Bump();		// Bump delay array pointers.
	m_DelayR.Bump();		// Bump delay array pointers.
// }
}


HRESULT CDirectSoundEchoDMO::Discontinuity() 
{
// { EAX

	m_EaxPan = 0;

	m_StateL = m_StateR = 0;

	m_DelayL.ZeroBuffer();
	m_DelayR.ZeroBuffer();

//	These values are set to be the defaults when the property page is activated.

//	m_EaxDelayLRead = m_DelayL.LastPos(-16);
//	m_EaxDelayRRead = m_DelayR.LastPos(-16);

	// These values have defined initial values.
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


__forceinline void CDirectSoundEchoDMO::DoOneSample(int *l, int *r)
{
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;

	float	outPortL, outPortR;
	
	int		pos;
	float	tempvar, temp2;

//LeftDelayRead:
//	tempvar = delayL[@-16] + 0 * 0;
//	tempvar = delayRread + 0 * 0;

	if (m_EaxPan) {
		pos     = m_DelayR.Pos((int)m_EaxDelayRRead);
		tempvar = m_DelayR[pos];
	}
	else {
		pos     = m_DelayL.Pos((int)m_EaxDelayLRead);
		tempvar = m_DelayL[pos];
	}

	temp2	= m_StateL + tempvar * m_EaxLpfb;

//	delayL[] = ACC + inPortL[0] * lpff;

	pos           = m_DelayL.Pos(0);
	m_DelayL[pos] = temp2 + inPortL * m_EaxLpff;

	m_StateL	  = tempvar * m_EaxLpfb;

//	outPortL = wetlevel : inPortL[1] < tempvar;

	outPortL = Interpolate(inPortL, tempvar, m_EaxWetlevel);

//RightDelayRead:
//	tempvar = delayR[@-16] + 0 * 0;
//	tempvar = delayRread + 0 * 0;

	if (m_EaxPan) {
		pos     = m_DelayL.Pos((int)m_EaxDelayLRead);
		tempvar = m_DelayL[pos];
	}
	else {
		pos     = m_DelayR.Pos((int)m_EaxDelayRRead);
		tempvar = m_DelayR[pos];
	}

	temp2	= m_StateR + tempvar * m_EaxLpfb;

//	delayR[]= ACC + inPortR[0] * lpff;

	pos           = m_DelayR.Pos(0);
	m_DelayR[pos] = temp2 + inPortR * m_EaxLpff;

	m_StateR = tempvar * m_EaxLpfb;

//	outPortR = wetlevel : inPortR[1] < tempvar;

	outPortR = Interpolate(inPortR, tempvar, m_EaxWetlevel);

	*l = Saturate(outPortL);
	*r = Saturate(outPortR);

	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::FBRProcess
//
HRESULT CDirectSoundEchoDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
				j  = i;

				DoOneSample(&i, &j);
				
				i += j;
				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
				j =  i;

				DoOneSample(&i, &j);
				
				i += j;
				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::ProcessInPlace
//
HRESULT CDirectSoundEchoDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::SetParam
//

HRESULT CDirectSoundEchoDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
	if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;	// NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
	case EFP_Wetdrymix :
		CHECK_PARAM(DSFXECHO_WETDRYMIX_MIN, DSFXECHO_WETDRYMIX_MAX);

		PUT_EAX_VALUE(Wetlevel, value / 100);
		break;

	case EFP_Feedback : {
		CHECK_PARAM(DSFXECHO_FEEDBACK_MIN,  DSFXECHO_FEEDBACK_MAX);

		MP_DATA valueFeedbackFactor = value / 100; // ratio out of one instead of 100

		PUT_EAX_VALUE(Lpfb, TOFRACTION(valueFeedbackFactor/2));
		PUT_EAX_VALUE(Lpff, TOFRACTION(sqrt(1.0 - valueFeedbackFactor*valueFeedbackFactor)));
		break;
	}
	case EFP_DelayLeft : {
		CHECK_PARAM(DSFXECHO_LEFTDELAY_MIN, DSFXECHO_LEFTDELAY_MAX);

		PUT_EAX_LVAL(DelayLRead, (value * FractMultiplier) /1000 * m_EaxSamplesPerSec);
		break;
	}
	case EFP_DelayRight : {
		CHECK_PARAM(DSFXECHO_RIGHTDELAY_MIN, DSFXECHO_RIGHTDELAY_MAX);

		PUT_EAX_LVAL(DelayRRead, (value * FractMultiplier) /1000 * m_EaxSamplesPerSec);
		break;

	case EFP_PanDelay : {

		CHECK_PARAM(DSFXECHO_PANDELAY_MIN, DSFXECHO_PANDELAY_MAX);
		
		PUT_EAX_LVAL(Pan, value);
#if 0
		if(value)
		{
			//Panned Delay
			float fval      = m_EaxDelayRRead;
			m_EaxDelayRRead = m_EaxDelayLRead;
			m_EaxDelayLRead = fval;
		}
		else
		{
			//Unpanned Delay
		}
#endif
		break;
	}
	}
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundEchoDMO::SetAllParameters(LPCDSFXEcho pEcho)
{
	HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pEcho == NULL)
    {
        Trace(1,"ERROR: pEcho is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(EFP_Wetdrymix, pEcho->fWetDryMix);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_Feedback, pEcho->fFeedback);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_DelayLeft, pEcho->fLeftDelay);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_DelayRight, pEcho->fRightDelay);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_PanDelay, (float)pEcho->lPanDelay);

    m_fDirty = true;
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundEchoDMO::GetAllParameters(LPDSFXEcho pEcho)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (pEcho == NULL)
	{
		return E_POINTER;
	}
	
#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pEcho->y = mpd; \
	}

#define GET_PARAM_LONG(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pEcho->y = (long)mpd; \
	}
    GET_PARAM(EFP_Wetdrymix, fWetDryMix);
    GET_PARAM(EFP_Feedback, fFeedback);
    GET_PARAM(EFP_DelayLeft, fLeftDelay);
    GET_PARAM(EFP_DelayRight, fRightDelay);
    GET_PARAM_LONG(EFP_PanDelay, lPanDelay);

	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundEchoDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_ECHO;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\dmocom.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

#include "dmocom.h"
#include <crtdbg.h>


#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions



/* Constructor */

// We know we use "this" in the initialization list, we also know we don't modify *phr.
#pragma warning( disable : 4355 4100 )
CComBase::CComBase(IUnknown* pUnk)
: 
/* Start the object with a reference count of zero - when the      */
/* object is queried for it's first interface this may be          */
/* incremented depending on whether or not this object is          */
/* currently being aggregated upon                                 */
  m_cRef(0)
/* Set our pointer to our IUnknown interface.                      */
/* If we have an outer, use its, otherwise use ours.               */
/* This pointer effectivly points to the owner of                  */
/* this object and can be accessed by the GetOwner() method.       */
, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
 /* Why the double cast?  Well, the inner cast is a type-safe cast */
 /* to pointer to a type from which we inherit.  The second is     */
 /* type-unsafe but works because INDUnknown "behaves   */
 /* like" IUnknown. (Only the names on the methods change.)        */
{
    // Everything we need to do has been done in the initializer list
}

// This does the same as above except it has a useless HRESULT argument
// use the previous constructor, this is just left for compatibility...
CComBase::CComBase(IUnknown* pUnk,HRESULT *phr) :
    m_cRef(0),
    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
{
}

#pragma warning( default : 4355 4100 )

/* QueryInterface */

STDMETHODIMP CComBase::NDQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    //ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown) {
        GetInterface((IUnknown*) (INDUnknown*) this, ppv);
        return NOERROR;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

/* We have to ensure that we DON'T use a max macro, since these will typically   */
/* lead to one of the parameters being evaluated twice.  Since we are worried    */
/* about concurrency, we can't afford to access the m_cRef twice since we can't  */
/* afford to run the risk that its value having changed between accesses.        */
#ifdef max
    #undef max
#endif

template<class T> inline static T max( const T & a, const T & b )
{
    return a > b ? a : b;
}

/* AddRef */

STDMETHODIMP_(ULONG) CComBase::NDAddRef()
{
    LONG lRef = InterlockedIncrement( &m_cRef );
    _ASSERTE(lRef > 0);
/*
    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"),
           m_dwCookie, m_cRef));
*/
    return max(ULONG(m_cRef), 1ul);
}


/* Release */

STDMETHODIMP_(ULONG) CComBase::NDRelease()
{
    /* If the reference count drops to zero delete ourselves */

    LONG lRef = InterlockedDecrement( &m_cRef );
    _ASSERTE(lRef >= 0);

/*
    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"),
	    m_dwCookie, m_cRef));
*/
    if (lRef == 0) {

        // COM rules say we must protect against re-entrancy.
        // If we are an aggregator and we hold our own interfaces
        // on the aggregatee, the QI for these interfaces will
        // addref ourselves. So after doing the QI we must release
        // a ref count on ourselves. Then, before releasing the
        // private interface, we must addref ourselves. When we do
        // this from the destructor here it will result in the ref
        // count going to 1 and then back to 0 causing us to
        // re-enter the destructor. Hence we add an extra refcount here
        // once we know we will delete the object.
        // for an example aggregator see filgraph\distrib.cpp.

        m_cRef++;

        delete this;
        return ULONG(0);
    } else {
        return max(ULONG(m_cRef), 1ul);
    }
}


/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv)
{
    CheckPointer(ppv, E_POINTER);
    *ppv = pUnk;
    pUnk->AddRef();
    return NOERROR;
}


/* Compares two interfaces and returns TRUE if they are on the same object */

BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    IUnknown* pUnknown1;     // Retrieve the IUnknown interface
    IUnknown* pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    _ASSERTE(pFirst);
    _ASSERTE(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\dsdmobse.cpp ===
/*
 * DirectSound DirectMediaObject base classes 
 *
 * Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.  
 */

#include "DsDmoBse.h"
#include "debug.h"

#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>

struct KSMEDIAPARAM
{
    KSNODEPROPERTY  ksnp;
    ULONG           ulIndex;            // Instance data is index of parameter
};

static BOOL SyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned);

// XXX C1in1out calls InitializeCriticalSection in a constructor with
// no handler.
//

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::CDirectSoundDMO
//
CDirectSoundDMO::CDirectSoundDMO()
{
    m_mpvCache = NULL;
    m_fInHardware = false;
    m_pKsPropertySet = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::~CDirectSoundDMO
//
CDirectSoundDMO::~CDirectSoundDMO() 
{
    delete[] m_mpvCache;
    m_mpvCache = NULL;
    m_fInHardware = false;
    RELEASE(m_pKsPropertySet);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetClassID
//
// This should always return E_NOTIMPL
//
STDMETHODIMP CDirectSoundDMO::GetClassID(THIS_ CLSID *pClassID)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::IsDirty
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::IsDirty(THIS)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Load
//
// Override if doing something other than just standard load.
//
STDMETHODIMP CDirectSoundDMO::Load(THIS_ IStream *pStm) 
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Save
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::Save(THIS_ IStream *pStm, BOOL fClearDirty)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetSizeMax
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::GetSizeMax(THIS_ ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Process
//
STDMETHODIMP CDirectSoundDMO::Process(THIS_ ULONG ulSize, BYTE *pData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    DMO_MEDIA_TYPE *pmt = InputType();
    if (pmt == NULL)
        return E_FAIL;

    assert(pmt->formattype == FORMAT_WaveFormatEx);
    ulSize /= LPWAVEFORMATEX(pmt->pbFormat)->nBlockAlign;
    return ProcessInPlace(ulSize, pData, rtStart, dwFlags);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetLatency
//
STDMETHODIMP CDirectSoundDMO::GetLatency(THIS_ REFERENCE_TIME *prt)
{
    *prt = 0;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::AcquireResources
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::AcquireResources(THIS_ IKsPropertySet *pKsPropertySet)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::ReleaseResources
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::ReleaseResources(THIS_)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::InitializeNode
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::InitializeNode(THIS_ HANDLE hPin, ULONG ulNodeId)
{
    m_hPin = hPin;
    m_ulNodeId = ulNodeId;
    return S_OK;
}





#if 0
// FIXME: no longer in medparam.idl

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetParams
//
STDMETHODIMP CDirectSoundDMO::GetParams(THIS_ DWORD dwParamIndexStart, DWORD *pdwNumParams, MP_DATA **ppValues)
{
    HRESULT hr;

    if (dwParamIndexStart >= ParamCount())
    {
        // XXX Real error code
        //
        return E_FAIL;
    }

    DWORD dw;
    DWORD dwParamIndexEnd = dwParamIndexStart + *pdwNumParams;
   
    for (dw = dwParamIndexStart; dw < dwParamIndexEnd; dw++) 
    {
        if (dw >= ParamCount())
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return S_FALSE;
        }

        hr = GetParam(dw, ppValues[dw]);
        if (FAILED(hr))
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return hr;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::SetParams
//
STDMETHODIMP CDirectSoundDMO::SetParams(THIS_ DWORD dwParamIndexStart, DWORD *pdwNumParams, MP_DATA __RPC_FAR *pValues)
{
    HRESULT hr;

    if (dwParamIndexStart >= ParamCount())
    {
        // XXX Real error code
        //
        return E_FAIL;
    }

    DWORD dw;
    DWORD dwParamIndexEnd = dwParamIndexStart + *pdwNumParams;
   
    for (dw = dwParamIndexStart; dw < dwParamIndexEnd; dw++) 
    {
        if (dw >= ParamCount())
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return S_FALSE;
        }

        hr = SetParam(dw, pValues[dw]);
        if (FAILED(hr))
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return hr;
        }
    }

    return S_OK;
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::ProxySetParam
//
HRESULT CDirectSoundDMO::ProxySetParam(DWORD dwParamIndex, MP_DATA value)
{
    assert(m_pKsPropertySet);

    return m_pKsPropertySet->Set(
        IID_IMediaParams, 0,                    // Set, item
        &dwParamIndex, sizeof(dwParamIndex),    // Instance data
        &value, sizeof(value));                 // Property data
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\flanger.cpp ===
#include <windows.h>

#include "flangerp.h"
#include "clone.h"

STD_CREATE(Flanger)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundFlangerDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXFlanger)
    {
        return GetInterface((IDirectSoundFXFlanger*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::CDirectSoundFlangerDMO
//
CDirectSoundFlangerDMO::CDirectSoundFlangerDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
    m_EaxSamplesPerSec = 22050;

    m_DelayL   .Init(0);
    m_DelayR   .Init(0);
    m_DryDelayL.Init(0);
    m_DryDelayR.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::Init()
//
HRESULT CDirectSoundFlangerDMO::Init()
{
    DSFXFlanger flanger;
    HRESULT hr; 
    // Force recalc of all internal parameters
    //
    hr = GetAllParameters(&flanger);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&flanger);

    if (SUCCEEDED(hr)) hr = m_DelayL   .Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = m_DelayR   .Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = m_DryDelayL.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = m_DryDelayR.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = Discontinuity();

    return hr;
}

//  bugbug on dsdmo.h: FilterParams should be FlangerFilterParams and need DSFXFLANGER_WAVE_TRIANGLE/DSFXFLANGER_WAVE_SIN
const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    FFP_Wetdrymix,  MPT_FLOAT,  g_capsAll,  DSFXFLANGER_WETDRYMIX_MIN,  DSFXFLANGER_WETDRYMIX_MAX,  50,                     L"%",       L"WetDryMix",   L"",
    FFP_Depth,      MPT_FLOAT,  g_capsAll,  DSFXFLANGER_DEPTH_MIN,      DSFXFLANGER_DEPTH_MAX,      100,                    L"",        L"Depth",       L"",
    FFP_Frequency,  MPT_FLOAT,  g_capsAll,  DSFXFLANGER_FREQUENCY_MIN,  DSFXFLANGER_FREQUENCY_MAX,  (float).25,             L"Hz",      L"Frequency",   L"",
    FFP_Waveform,   MPT_ENUM,   g_capsAll,  DSFXCHORUS_WAVE_TRIANGLE,   DSFXCHORUS_WAVE_SIN,        DSFXCHORUS_WAVE_SIN,    L"",        L"WaveShape",   L"Triangle,Sine",
    FFP_Phase,      MPT_INT,    g_capsAll,  DSFXFLANGER_PHASE_MIN,      DSFXFLANGER_PHASE_MAX,      2,                      L"",        L"Phase",       L"",
    FFP_Feedback,   MPT_FLOAT,  g_capsAll,  DSFXFLANGER_FEEDBACK_MIN,   DSFXFLANGER_FEEDBACK_MAX,   -50,                    L"",        L"Feedback",    L"",
    FFP_Delay,      MPT_FLOAT,  g_capsAll,  DSFXFLANGER_DELAY_MIN,      DSFXFLANGER_DELAY_MAX,      2,                      L"",        L"Delay",       L"",
};

HRESULT CDirectSoundFlangerDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);

    m_ModdelayL = m_ModdelayR = 0;
    m_ModdelayL1 = m_ModdelayR1 = 0x800;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::~CDirectSoundFlangerDMO
//
CDirectSoundFlangerDMO::~CDirectSoundFlangerDMO() 
{
    m_DelayL   .Init(-1);
    m_DelayR   .Init(-1);
    m_DryDelayL.Init(-1);
    m_DryDelayR.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::Clone
//
STDMETHODIMP CDirectSoundFlangerDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundFlangerDMO, DSFXFlanger>(this, pp);
}

//
//    Bump - bump the delay pointers.
//
void CDirectSoundFlangerDMO::Bump(void)
{
// EAX {
    m_DelayL.Bump();
    m_DelayR.Bump();
    m_DryDelayL.Bump();
    m_DryDelayR.Bump();
// }
}


HRESULT CDirectSoundFlangerDMO::Discontinuity() 
{
// { EAX


    m_DelayL   .ZeroBuffer();
    m_DelayR   .ZeroBuffer();
    m_DryDelayL.ZeroBuffer();
    m_DryDelayR.ZeroBuffer();

    // These values have defined initial values.

//    m_FixedptrL = m_DelayL.LastPos(0) * FractMultiplier;
    m_DelayptrL = m_ModdelayL1 = m_ModdelayL = (int)m_EaxFixedptrL;

//    m_FixedptrR = m_DelayR.LastPos(0) * FractMultiplier;
    m_DelayptrR = m_ModdelayR1 = m_ModdelayR = (int)m_EaxFixedptrR;

    if (!m_EaxWaveform) {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.5;
    }
    else {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.99999999999;
    }

// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

static int   LMul  [5] = {  1,  1, 1, 1, -1};
static int   RMul  [5] = { -1, -1, 1, 1,  1};
static int   RPhase[5] = {  0,  1, 0, 1,  0};


__forceinline void CDirectSoundFlangerDMO::DoOneSample(int *l, int *r)
{
    float    inPortL = (float)*l;
    float    inPortR = (float)*r;
    float    XWave[2];
#define sinwave    XWave[0]
#define coswave    XWave[1]

    int Pos0, PosX, tempvar;
    float val;

//     dryDelayL[]    = inPortL;

    Pos0              = m_DryDelayL.Pos(0);
    m_DryDelayL[Pos0] = inPortL;

    
//    delayL[] = ACC + delayL[fixedptrL] * fbcoef;

    Pos0           = m_DelayL.Pos(0);
    PosX           = m_DelayL.Pos(m_EaxFixedptrL);
    m_DelayL[Pos0] = inPortL + m_DelayL[PosX] * m_EaxFbCoef;
    
//    dryDelayR[]    = inPortR;

    Pos0              = m_DryDelayR.Pos(0);
    m_DryDelayR[Pos0] = inPortR;

//    delayR[]    = ACC + delayR[fixedptrR] * fbcoef;

    Pos0           = m_DelayR.Pos(0);
    PosX           = m_DelayR.Pos(m_EaxFixedptrR);
    m_DelayR[Pos0] = inPortR + m_DelayR[PosX] * m_EaxFbCoef;
    
// Sinusoid : lfocoef = 2*sin(PI*f/FS)    // ??? Update this when form changes.

    if (!m_EaxWaveform) {

        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef;

        if (m_LfoState[0] > 1) m_LfoState[0] -= 2;

        m_LfoState[1] = m_LfoState[1] + m_EaxLfoCoef;

        if (m_LfoState[1] > 1) m_LfoState[1] -= 2;

        sinwave       = (float)fabs(m_LfoState[0]);
        coswave       = (float)fabs(m_LfoState[1]);
        sinwave       = -1 + 2 * sinwave;
        coswave       = -1 + 2 * coswave;
    }
    else {

        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef * m_LfoState[1];
        m_LfoState[1] = m_LfoState[1] - m_EaxLfoCoef * m_LfoState[0];

        sinwave       = m_LfoState[0];
        coswave       = m_LfoState[1];
    }

//     Left Out
//    tempvar            ^= delayptrL << 20;

    tempvar = m_DelayptrL & FractMask;

//    tempvar        = tempvar : delayL[moddelayL] < delayL[moddelayL1];

    Pos0 = m_DelayL.Pos(m_ModdelayL);
    PosX = m_DelayL.Pos(m_ModdelayL1);

    val = ((float)tempvar) / FractMultiplier;
    val = Interpolate(m_DelayL[Pos0], m_DelayL[PosX], val);
    
//    outPortL    = wetlevel : dryDelayL[2] < tempvar;
    
    Pos0 = m_DryDelayL.FractPos(2);
    val  = Interpolate(m_DryDelayL[Pos0], val, m_EaxWetlevel);

    *l = Saturate(val);

//     Right Out
//    tempvar            ^= delayptrR << 20;

    tempvar = m_DelayptrR & FractMask;

//    tempvar        = tempvar : delayR[moddelayR] < delayR[moddelayR1];

    Pos0 = m_DelayR.Pos(m_ModdelayR);
    PosX = m_DelayR.Pos(m_ModdelayR1);

    val = ((float)tempvar) / FractMultiplier;
    val = Interpolate(m_DelayR[Pos0], m_DelayR[PosX], val);
    
//    outPortR    = wetlevel : dryDelayR[2] < tempvar;
    
    Pos0 = m_DryDelayR.FractPos(2);
    val  = Interpolate(m_DryDelayR[Pos0], val, m_EaxWetlevel);

    *r = Saturate(val);

//    Left Delay Address Calculation
//     Same as efx...

//    m_DelayptrL     = (int)(m_EaxFixedptrL + (sinwave * m_EaxDepthCoef));
#if 0
    switch (m_EaxPhase) {
        case 0: 
        case 1: 
        case 2:
        case 3: m_DelayptrL =   (int)(sinwave * m_EaxDepthCoef); break;
        case 4: m_DelayptrL = - (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
#ifdef DONTUSEi386
    {
    int x;
    float f = (sinwave * m_EaxDepthCoef);

    _asm { 
        fld f
        fistp x
    }
    m_DelayptrL  = LMul[m_EaxPhase] * x;
    }
#else
    m_DelayptrL  = LMul[m_EaxPhase] * (int)(sinwave * m_EaxDepthCoef);
#endif
#endif

    m_DelayptrL += m_EaxFixedptrL;
    m_ModdelayL     = m_DelayptrL;
    m_ModdelayL1 = m_DelayptrL + FractMultiplier;

//    Right Delay Address Calculation

//    m_DelayptrR     = (int)(m_EaxFixedptrR + (coswave * m_EaxDepthCoef));
#if 0
    switch (m_EaxPhase) {
        case 0: m_DelayptrR = - (int)(sinwave * m_EaxDepthCoef); break;
        case 1: m_DelayptrR = - (int)(coswave * m_EaxDepthCoef); break;
        case 3: m_DelayptrR =   (int)(coswave * m_EaxDepthCoef); break;
        case 2:
        case 4: m_DelayptrR =   (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
    Pos0        = RPhase[m_EaxPhase];
#ifdef DONTUSEi386
    {
    int x;
    float f = (XWave[Pos0] * m_EaxDepthCoef);

    _asm { 
        fld f
        fistp x
    }
    m_DelayptrR = RMul  [m_EaxPhase] * x;
    }
#else
    m_DelayptrR = RMul  [m_EaxPhase] * (int)(XWave[Pos0] * m_EaxDepthCoef);
#endif
#endif
    m_DelayptrR += m_EaxFixedptrR;
    m_ModdelayR     = m_DelayptrR;
    m_ModdelayR1 = m_DelayptrR + FractMultiplier;

    Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::FBRProcess
//
HRESULT CDirectSoundFlangerDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

    if (m_cChannels == 1) {
        if (m_b8bit) {
            for (;cb > 0; --cb) {
                int i, j;

                i = *(pin+0)-128;
                i *=256;
                j  = i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                i /= 256;

                *(pout+0) = (unsigned char)(i + 128);
            
                pin  += sizeof(unsigned char);
                pout += sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *psi;
                j =  i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                   *pso = (short)i;
            
                pin  += sizeof(short);
                pout += sizeof(short);
            }
        }
    }
    else if (m_cChannels == 2) {
        if (m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
                int i, j;

                i = *(pin+0)-128;
                j = *(pin+1)-128;

                i *=256; j *=256;

                DoOneSample(&i, &j);
                
                i /= 256; j /= 256;
                
                *(pout+0) = (unsigned char)(i + 128);
                *(pout+1) = (unsigned char)(j + 128);
            
                pin  += 2 * sizeof(unsigned char);
                pout += 2 * sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *(psi+0);
                j = *(psi+1);

                DoOneSample(&i, &j);
                
                   *(pso+0) = (short)i;
                   *(pso+1) = (short)j;
            
                pin  += 2 * sizeof(short);
                pout += 2 * sizeof(short);
            }
        }
    }
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::ProcessInPlace
//
HRESULT CDirectSoundFlangerDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::SetParam
//
// { EAX
// }

HRESULT CDirectSoundFlangerDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    long l;

    if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;    // NO TYPE!

    switch (dwParamIndex)
    {
    case FFP_Wetdrymix :
        CHECK_PARAM(DSFXFLANGER_WETDRYMIX_MIN, DSFXFLANGER_WETDRYMIX_MAX);

        PUT_EAX_VALUE(Wetlevel, value / 100);
        break;
    
    case FFP_Waveform :
        CHECK_PARAM(DSFXFLANGER_WAVE_TRIANGLE, DSFXFLANGER_WAVE_SIN);

        l = m_EaxWaveform;

        PUT_EAX_VALUE(Waveform, (long)value);

        if (l != m_EaxWaveform) {
            if (!m_EaxWaveform) {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.5;
            }
            else {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.99999999999;
            }
        }
        goto x;
//        break;

    case FFP_Frequency :
        CHECK_PARAM(DSFXFLANGER_FREQUENCY_MIN, DSFXFLANGER_FREQUENCY_MAX);

        PUT_EAX_VALUE(Frequency, value);
x:
        if (!m_EaxWaveform) {                // Triangle.
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0 * (m_EaxFrequency/m_EaxSamplesPerSec) * 1.0)
                );
        }
        else                                 // Sine/Cosine.
        {
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0*sin(PI*m_EaxFrequency/m_EaxSamplesPerSec))
                );
        }
        break;

    case FFP_Depth : {
        CHECK_PARAM(DSFXFLANGER_DEPTH_MIN, DSFXFLANGER_DEPTH_MAX);

        PUT_EAX_VALUE(Depth, value / 100);

        double midpoint    = m_EaxDelay * m_EaxSamplesPerSec/1000;

        INTERPOLATE(DepthCoef, ((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        break;
    }
    case FFP_Phase :
        CHECK_PARAM(DSFXFLANGER_PHASE_MIN, DSFXFLANGER_PHASE_MAX);

        PUT_EAX_VALUE(Phase, (long)value);
        break;

    case FFP_Feedback :
        CHECK_PARAM(DSFXFLANGER_FEEDBACK_MIN, DSFXFLANGER_FEEDBACK_MAX);

        PUT_EAX_FVAL(FbCoef, TOFRACTION(value/100));
        break;

    case FFP_Delay : {
        CHECK_PARAM(DSFXFLANGER_DELAY_MIN, DSFXFLANGER_DELAY_MAX);

        PUT_EAX_VALUE(Delay, value);

        double midpoint    = m_EaxDelay * m_EaxSamplesPerSec/1000;

        PUT_EAX_FVAL(DepthCoef, ((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        PUT_EAX_LVAL(FixedptrL, (midpoint + 2) * FractMultiplier);
        PUT_EAX_LVAL(FixedptrR, (midpoint + 2) * FractMultiplier);
        break;
    }
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundFlangerDMO::SetAllParameters(LPCDSFXFlanger pFlanger)
{
    HRESULT hr = S_OK;
    
    // Check that the pointer is not NULL
    if (pFlanger == NULL)
    {
        Trace(1,"ERROR: pFlanger is NULL\n");
        hr = E_POINTER;
    }
    // Set the parameters
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Wetdrymix, pFlanger->fWetDryMix);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Waveform, (float)pFlanger->lWaveform);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Frequency, pFlanger->fFrequency);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Depth, pFlanger->fDepth);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Phase, (float)pFlanger->lPhase);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Feedback, pFlanger->fFeedback);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Delay, pFlanger->fDelay);

    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundFlangerDMO::GetAllParameters(LPDSFXFlanger pFlanger)
{
    HRESULT hr = S_OK;
    MP_DATA mpd;

    if (pFlanger == NULL) return E_POINTER;
    
#define GET_PARAM(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd);    \
        if (SUCCEEDED(hr)) pFlanger->y = mpd; \
    }

#define GET_PARAM_LONG(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd);    \
        if (SUCCEEDED(hr)) pFlanger->y = (long)mpd; \
    }
    GET_PARAM(FFP_Wetdrymix, fWetDryMix);
    GET_PARAM(FFP_Delay, fDelay);
    GET_PARAM(FFP_Depth, fDepth);
    GET_PARAM(FFP_Frequency, fFrequency);
    GET_PARAM_LONG(FFP_Waveform, lWaveform);
    GET_PARAM_LONG(FFP_Phase, lPhase);
    GET_PARAM(FFP_Feedback, fFeedback);

    return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundFlangerDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_FLANGER;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\guid.cpp ===
#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include "dsdmo.h"
#include <medparam.h>
#include <uuids.h>
#include "aecdbgprop.h"

// FIXME: this includes a lot more GUIDs than it needs to (do "strings dsdmo.dll")
//        Maybe it shouldn't need to include medparam.h.  Should that come from dmoguids.lib?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\echop.h ===
//
//
//
#ifndef _Echop_
#define _Echop_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS

class CDirectSoundEchoDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXEcho,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundEchoDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundEchoDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
    
	HRESULT Init();

    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXEcho);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXEcho);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropEcho, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXEcho(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXEcho(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXEcho); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(long, DelayLRead);
	DECLARE_EAX_VARS(long, DelayRRead);


#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	float		m_StateL, m_StateR;

	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}


	DECLARE_EAX_VARS(float, Lpfb);
	DECLARE_EAX_VARS(float, Lpff);
	DECLARE_EAX_VARS(float, Wetlevel);
	DECLARE_EAX_VARS(long,  Pan);

	void Bump(void);

	DelayBuffer2<float, 2000, 16> m_DelayL;
	DelayBuffer2<float, 2000, 16> m_DelayR;

// } EAX
};

EXT_STD_CREATE(Echo);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\ksdbgprop.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksdbgprop.h
 *  Content:    AEC KS Debug stuff
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  dandinu Created.
 *
 ***************************************************************************/

/*
#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before DBGPROP.H
#endif // !defined(_KS_)
*/
#if !defined(_KSDBGPROP_)
#define _KSDBGPROP_
/*
typedef struct {
    KSNODEPROPERTY  NodeProperty;
    ULONG           DebugId;
    ULONG           Reserved;
} KSDEBUGNODEPROPERTY, *PKSDEBUGNODEPROPERTY;
*/

//===========================================================================
//===========================================================================

// KSPROPSETID_DebugAecValue : {24366808-DB14-40c8-883E-5B45DD597774}

#define STATIC_KSPROPSETID_DebugAecValue\
    0x24366808, 0xdb14, 0x40c8, 0x88, 0x3e, 0x5b, 0x45, 0xdd, 0x59, 0x77, 0x74
DEFINE_GUIDSTRUCT("24366808-DB14-40c8-883E-5B45DD597774",KSPROPSETID_DebugAecValue);
#define KSPROPSETID_DebugAecValue DEFINE_GUIDNAMED(KSPROPSETID_DebugAecValue)

typedef enum {
    KSPROPERTY_DEBUGAECVALUE_ALL,
    KSPROPERTY_DEBUGAECVALUE_SYNCHSTREAM,
    KSPROPERTY_DEBUGAECVALUE_NUMBANDS,
    KSPROPERTY_DEBUGAECARRAY_NOISEMAGNITUDE
} KSPROPERTY_DEBUGAECVALUE;


//===========================================================================
//===========================================================================

// KSPROPSETID_DebugAecArray: {CF8A9F7D-950E-46d5-93E5-C04C77DC866B}

#define STATIC_KSPROPSETID_DebugAecArray\
    0xcf8a9f7d, 0x950e, 0x46d5, 0x93, 0xe5, 0xc0, 0x4c, 0x77, 0xdc, 0x86, 0x6b
DEFINE_GUIDSTRUCT("CF8A9F7D-950E-46d5-93E5-C04C77DC866B",KSPROPSETID_DebugAecArray);
#define KSPROPSETID_DebugAecArray DEFINE_GUIDNAMED(KSPROPSETID_DebugAecArray)



#endif // !defined(_KSDBGPROP_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\flangerp.h ===
//
//
//
#ifndef _Flangerp_
#define _Flangerp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS
#define Delay_len       DefineDelayLineSize(8)

class CDirectSoundFlangerDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXFlanger,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundFlangerDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundFlangerDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    HRESULT Init();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXFlanger);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXFlanger);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropFlanger, pPages); }

	// IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXFlanger(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXFlanger(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXFlanger); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(float, LfoCoef);
	DECLARE_EAX_VARS(float, Wetlevel);
	DECLARE_EAX_VARS(float, FbCoef);
	DECLARE_EAX_VARS(float, DepthCoef);
	DECLARE_EAX_VARS(long,  FixedptrL);
	DECLARE_EAX_VARS(long,  FixedptrR);
	DECLARE_EAX_VARS(float, Depth);
	DECLARE_EAX_VARS(long,  Phase);
	DECLARE_EAX_VARS(float, Delay);
	DECLARE_EAX_VARS(float, Frequency);
	DECLARE_EAX_VARS(long,  Waveform);
//	DECLARE_EAX_VARS(SamplesPerSec);
#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	float		m_StateL, m_StateR;

	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	void Bump(void);

	DWORD			m_ModdelayL1;
	DWORD			m_ModdelayL;
	DWORD			m_DelayptrL;

	DWORD			m_ModdelayR1;
	DWORD			m_ModdelayR;
	DWORD			m_DelayptrR;

	float			m_LfoState[2];

	DelayBuffer2<float, Delay_len, 3> m_DelayL;
	DelayBuffer2<float, Delay_len, 3> m_DelayR;
	DelayBuffer2<float, 0, 3> m_DryDelayL;
	DelayBuffer2<float, 0, 3> m_DryDelayR;

// } EAX
};

EXT_STD_CREATE(Flanger);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\gargle.cpp ===
#include <windows.h>
#include "garglep.h"
#include "clone.h"

STD_CREATE(Gargle)

#define DEFAULT_GARGLE_RATE 20

CDirectSoundGargleDMO::CDirectSoundGargleDMO( IUnknown *pUnk, HRESULT *phr ) 
    :CComBase( pUnk,  phr ),
    m_ulShape(0),
    m_ulGargleFreqHz(DEFAULT_GARGLE_RATE),
    m_fDirty(true),
    m_bInitialized(FALSE)
{
    
}

HRESULT CDirectSoundGargleDMO::NDQueryInterface(REFIID riid, void **ppv) {

    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXGargle)
    {
        return GetInterface((IDirectSoundFXGargle*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

CDirectSoundGargleDMO::~CDirectSoundGargleDMO()
{
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                    unit text,  label,          pwchText??
    GFP_Rate,       MPT_INT,    g_capsAll,  DSFXGARGLE_RATEHZ_MIN,      DSFXGARGLE_RATEHZ_MAX,      20,                         L"Hz",      L"Rate",        L"",
    GFP_Shape,      MPT_ENUM,   g_capsAll,  DSFXCHORUS_WAVE_TRIANGLE,   DSFXGARGLE_WAVE_SQUARE,     DSFXGARGLE_WAVE_TRIANGLE,   L"",        L"WaveShape",   L"Triangle,Square",
};

HRESULT CDirectSoundGargleDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundGargleDMO::Init()
{
    // compute the period
    m_ulPeriod = m_ulSamplingRate / m_ulGargleFreqHz;
    m_bInitialized = TRUE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::Clone
//
STDMETHODIMP CDirectSoundGargleDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundGargleDMO, DSFXGargle>(this, pp);
}

HRESULT CDirectSoundGargleDMO::Discontinuity() {
   m_ulPhase = 0;
   return NOERROR;
}

HRESULT CDirectSoundGargleDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut) {
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;
   
   // test code
   //memcpy(pOut, pIn, cSamples * m_cChannels * (m_b8bit ? 1 : 2));
   //return NOERROR;

   DWORD cSample, cChannel;
   for (cSample = 0; cSample < cSamples; cSample++) {
      // If m_Shape is 0 (triangle) then we multiply by a triangular waveform
      // that runs 0..Period/2..0..Period/2..0... else by a square one that
      // is either 0 or Period/2 (same maximum as the triangle) or zero.
      //
      // m_Phase is the number of samples from the start of the period.
      // We keep this running from one call to the next,
      // but if the period changes so as to make this more
      // than Period then we reset to 0 with a bang.  This may cause
      // an audible click or pop (but, hey! it's only a sample!)
      //
      ++m_ulPhase;
      if (m_ulPhase > m_ulPeriod)
         m_ulPhase = 0;

      ULONG ulM = m_ulPhase;      // m is what we modulate with

      if (m_ulShape == 0) {   // Triangle
          if (ulM > m_ulPeriod / 2)
              ulM = m_ulPeriod - ulM;  // handle downslope
      } else {             // Square wave
          if (ulM <= m_ulPeriod / 2)
             ulM = m_ulPeriod / 2;
          else
             ulM = 0;
      }

      for (cChannel = 0; cChannel < m_cChannels; cChannel++) {
         if (m_b8bit) {
             // sound sample, zero based
             int i = pIn[cSample * m_cChannels + cChannel] - 128;
             // modulate
             i = (i * (signed)ulM * 2) / (signed)m_ulPeriod;
             // 8 bit sound uses 0..255 representing -128..127
             // Any overflow, even by 1, would sound very bad.
             // so we clip paranoically after modulating.
             // I think it should never clip by more than 1
             //
             if (i > 127)
                i = 127;
             if (i < -128)
                i = -128;
             // reset zero offset to 128
             pOut[cSample * m_cChannels + cChannel] = (unsigned char)(i + 128);
   
         } else {
             // 16 bit sound uses 16 bits properly (0 means 0)
             // We still clip paranoically
             //
             int i = ((short*)pIn)[cSample * m_cChannels + cChannel];
             // modulate
             i = (i * (signed)ulM * 2) / (signed)m_ulPeriod;
             // clip
             if (i > 32767)
                i = 32767;
             if (i < -32768)
                i = -32768;
             ((short*)pOut)[cSample * m_cChannels + cChannel] = (short)i;
         }
      }
   }
   return NOERROR;
}


// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// a gargle in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundGargleDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_GARGLE;
    return NOERROR;

} // GetClassID


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundGargleDMO::SetAllParameters(THIS_ LPCDSFXGargle pParm)
{
	HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pParm == NULL)
    {
        Trace(1,"ERROR: pParm is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(GFP_Rate, static_cast<MP_DATA>(pParm->dwRateHz));
    if (SUCCEEDED(hr)) hr = SetParam(GFP_Shape, static_cast<MP_DATA>(pParm->dwWaveShape));
            
    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundGargleDMO::GetAllParameters(THIS_ LPDSFXGargle pParm)
{	
    HRESULT hr = S_OK;
    MP_DATA var;

    if (pParm == NULL)
    {
    	return E_POINTER;
    }

#define GET_PARAM_DWORD(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &var);	\
		if (SUCCEEDED(hr)) pParm->y = (DWORD)var; \
	}

	
    GET_PARAM_DWORD(GFP_Rate, dwRateHz);
    GET_PARAM_DWORD(GFP_Shape, dwWaveShape);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::SetParam
//
HRESULT CDirectSoundGargleDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    switch (dwParamIndex)
    {
    case GFP_Rate:
        CHECK_PARAM(DSFXGARGLE_RATEHZ_MIN,DSFXGARGLE_RATEHZ_MAX);
        m_ulGargleFreqHz = (unsigned)value;
        if (m_ulGargleFreqHz < 1) m_ulGargleFreqHz = 1;
        if (m_ulGargleFreqHz > 1000) m_ulGargleFreqHz = 1000;
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
        break;

    case GFP_Shape:
        CHECK_PARAM(DSFXGARGLE_WAVE_TRIANGLE,DSFXGARGLE_WAVE_SQUARE);
        m_ulShape = (unsigned)value;
        break;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::ProcessInPlace
//
HRESULT CDirectSoundGargleDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\kshlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.cpp
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  jstokes Created.
 *  03/09/2001  duganp  Fixed return code mistranslation.
 *
 ***************************************************************************/

#include <windows.h>
#include <ks.h>
#include <ksmedia.h>
#include "ksdbgprop.h"
#include "kshlp.h"

#include <devioctl.h>
#include "runtime.h"


/***************************************************************************
 *
 * SyncIoctl
 *
 ***************************************************************************/

static BOOL SyncIoctl
(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned
)
{
    OVERLAPPED overlapped;
    memset(&overlapped, 0, sizeof overlapped);
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!overlapped.hEvent)
    {
        return FALSE;
    }

    BOOL fResult = DeviceIoControl(handle,
                                   ulIoctl,
                                   pvInBuffer,
                                   ulInSize,
                                   pvOutBuffer,
                                   ulOutSize,
                                   pulBytesReturned,
                                   &overlapped);

    DWORD dwError = GetLastError();

    if (!fResult && dwError == ERROR_IO_PENDING)
    {
        if (WaitForSingleObject(overlapped.hEvent, INFINITE) != WAIT_FAILED)
        {
            fResult = TRUE;
        }
    }
    else if (!fResult)
    {
        if  (   (ulIoctl == IOCTL_KS_PROPERTY)
            &&  (ulOutSize == 0)
            &&  (dwError == ERROR_MORE_DATA)
            )
        {
            fResult = TRUE;
        }
        else
        {
            *pulBytesReturned = 0;
        }
    }

    CloseHandle(overlapped.hEvent);

    return fResult;
}


/***************************************************************************
 *
 *  KsGetProperty
 *
 *  Description:
 *      Retrieves a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetProperty"

HRESULT
KsGetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_GET;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof Property, pvData, cbData, pcbDataReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsSetProperty
 *
 *  Description:
 *      Sets a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetProperty"

HRESULT
KsSetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_SET;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof Property, pvData, cbData, &ulBytesReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsGetPinProperty
 *
 *  Description:
 *      Retrieves a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinProperty"

HRESULT
KsGetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof Pin, pvData, cbData, pcbDataReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsSetPinProperty
 *
 *  Description:
 *      Sets a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetPinProperty"

HRESULT
KsSetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_SET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof Pin, pvData, cbData, &ulBytesReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsGetNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetNodeProperty"

HRESULT
KsGetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pvData, cbData, pcbDataReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsSetNodeProperty
 *
 *  Description:
 *      Sets a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetNodeProperty"

HRESULT
KsSetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof NodeProperty, pvData, cbData, &ulBytesReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsGetDebugNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/
/*
#undef DPF_FNAME
#define DPF_FNAME "KsGetDebugNodeProperty"

HRESULT
KsGetDebugNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulDebugId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSDEBUGNODEPROPERTY     DebugNodeProperty;
    HRESULT                 hr;

    DebugNodeProperty.NodeProperty.Property.Set = guidPropertySet;
    DebugNodeProperty.NodeProperty.Property.Id = ulPropertyId;
    DebugNodeProperty.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    DebugNodeProperty.NodeProperty.NodeId = ulNodeId;
    DebugNodeProperty.NodeProperty.Reserved = 0;

    DebugNodeProperty.DebugId = ulDebugId;
    DebugNodeProperty.Reserved = 0;

    hr = SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &DebugNodeProperty, sizeof DebugNodeProperty, pvData, cbData, pcbDataReturned);

    return hr;
}
*/

/***************************************************************************
 *
 *  KsSetDebugNodeProperty
 *
 *  Description:
 *      Sets a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/
/*
#undef DPF_FNAME
#define DPF_FNAME "KsSetDebugNodeProperty"

HRESULT
KsSetDebugNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulDebugId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSDEBUGNODEPROPERTY     DebugNodeProperty;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    DebugNodeProperty.NodeProperty.Property.Set = guidPropertySet;
    DebugNodeProperty.NodeProperty.Property.Id = ulPropertyId;
    DebugNodeProperty.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    DebugNodeProperty.NodeProperty.NodeId = ulNodeId;
    DebugNodeProperty.NodeProperty.Reserved = 0;

    DebugNodeProperty.DebugId = ulDebugId;
    DebugNodeProperty.Reserved = 0;

    hr = SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &DebugNodeProperty, sizeof DebugNodeProperty, pvData, cbData, &ulBytesReturned);

    return hr;
}
*/

/***************************************************************************
 *
 *  KsSetTopologyNodeEnable
 *
 *  Description:
 *      Enables or disables a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      BOOL [in]: enable value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetTopologyNodeEnable"

HRESULT
KsSetTopologyNodeEnable
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
)
{
    return KsSetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_ENABLE, ulNodeId, &fEnable, sizeof fEnable);
}


/***************************************************************************
 *
 *  KsGetTopologyNodeEnable
 *
 *  Description:
 *      Gets the value for the topology node's enable flag.
 *
 *  Arguments:
 *      HANDLE [in]: pin id.
 *      ULONG [in]: node id.
 *      PBOOL [out]: receives enable flag.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetTopologyNodeEnable"

HRESULT
KsGetTopologyNodeEnable
(
    HANDLE                      hDevice,
    ULONG                       ulNodeId,
    PBOOL                       pEnable
)
{
    return KsGetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_ENABLE, ulNodeId, pEnable, sizeof BOOL);
}


/***************************************************************************
 *
 *  KsTopologyNodeReset
 *
 *  Description:
 *      Resets a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      BOOL [in]: enable value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsTopologyNodeReset"

HRESULT
KsTopologyNodeReset
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fReset
)
{
    return KsSetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_RESET, ulNodeId, &fReset, sizeof fReset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\garglep.h ===
//
//
//
#ifndef _Garglep_
#define _Garglep_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundGargleDMO : 
    public CDirectSoundDMO,
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXGargle,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundGargleDMO( IUnknown *pUnk, HRESULT *phr);
    ~CDirectSoundGargleDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the  CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropGargle, pPages); }

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXGargle(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXGargle(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXGargle); return S_OK; }

    // IDirectSoundFXGargle
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle);
    
    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
    bool m_fDirty;

private:
   // gargle params
   ULONG m_ulShape;
   ULONG m_ulGargleFreqHz;

   // gargle state
   ULONG m_ulPeriod;
   ULONG m_ulPhase;

   BOOL m_bInitialized;
};

EXT_STD_CREATE(Gargle);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\oledll.h ===
//
// OleDLL.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\kshlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.h
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  jstokes Created.
 *
 ***************************************************************************/

#ifndef __KSHLP_H__
#define __KSHLP_H__

#include <windows.h>
#include <ks.h>
#include <ksmedia.h>

#define KSPIN_DATAFLOW_CAPTURE  KSPIN_DATAFLOW_OUT
#define KSPIN_DATAFLOW_RENDER   KSPIN_DATAFLOW_IN

// Device-specific DirectSound property sets
typedef struct tagKSDSPROPERTY
{
    GUID    PropertySet;
    ULONG   PropertyId;
    ULONG   NodeId;
    ULONG   AccessFlags;
} KSDSPROPERTY, *PKSDSPROPERTY;

// KS stream data
typedef struct tagKSSTREAMIO
{
    KSSTREAM_HEADER Header;
    OVERLAPPED      Overlapped;
    BOOL            fPendingIrp;
} KSSTREAMIO, *PKSSTREAMIO;

// System audio device properties
typedef struct tagKSSADPROPERTY
{
    KSPROPERTY  Property;
    ULONG       DeviceId;
    ULONG       Reserved;
} KSSADPROPERTY, *PKSSADPROPERTY;

// Topology node information
typedef struct tagKSNODE
{
    ULONG   NodeId;
    ULONG   CpuResources;
} KSNODE, *PKSNODE;

typedef struct tagKSVOLUMENODE
{
    KSNODE                      Node;
    KSPROPERTY_STEPPING_LONG    VolumeRange;
} KSVOLUMENODE, *PKSVOLUMENODE;

// Our own version of NTSTATUS
typedef LONG NTSTATUS;

#define NT_SUCCESS(s)       ((NTSTATUS)(s) >= 0)
#define NT_INFORMATION(s)   ((ULONG)(s) >> 30 == 1)
#define NT_WARNING(s)       ((ULONG)(s) >> 30 == 2)
#define NT_ERROR(s)         ((ULONG)(s) >> 30 == 3)

// Reserved node identifiers
#define NODE_UNINITIALIZED  0xFFFFFFFF
#define NODE_WILDCARD       0xFFFFFFFE

#define NODE_PIN_UNINITIALIZED  0xFFFFFFFF

#define IS_VALID_NODE(nodeid) \
            (NODE_UNINITIALIZED != (nodeid))

// Node implementation
#define KSAUDIO_CPU_RESOURCES_UNINITIALIZED 'ENON'

#define IS_HARDWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU == (impl))

#define IS_SOFTWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_HOST_CPU == (impl))

#ifdef __cplusplus

HRESULT 
PostDevIoctl
(
    HANDLE                  hDevice, 
    DWORD                   dwControlCode, 
    LPVOID                  pvIn            = NULL,
    DWORD                   cbIn            = 0,
    LPVOID                  pvOut           = NULL,
    DWORD                   cbOut           = 0,
    LPDWORD                 pcbReturned     = NULL,
    LPOVERLAPPED            pOverlapped     = NULL
);

HRESULT 
KsGetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetMultiplePinProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);

HRESULT 
KsGetMultipleTopologyProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);


HRESULT
KsSetTopologyNodeEnable
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
);

HRESULT
KsGetTopologyNodeEnable
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PBOOL                   pfEnable
);

HRESULT
KsTopologyNodeReset
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fReset
);

#endif // __cplusplus

#endif // __KSHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\ns.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ns.cpp
 *  Content:    Noise Suppression DMO implementation.
 *
 ***************************************************************************/

#include <windows.h>
#include "nsp.h"
#include "kshlp.h"
#include "clone.h"

STD_CAPTURE_CREATE(NoiseSuppress)


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::NDQueryInterface
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::NDQueryInterface
(
    REFIID riid,
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid, ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXNoiseSuppress)
    {
        return GetInterface((IDirectSoundCaptureFXNoiseSuppress*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
    {
        return CComBase::NDQueryInterface(riid, ppv);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO constructor
//
CDirectSoundCaptureNoiseSuppressDMO::CDirectSoundCaptureNoiseSuppressDMO(IUnknown *pUnk, HRESULT *phr)
    : CComBase(pUnk, phr),
    m_fEnable(FALSE),
    m_fDirty(FALSE),
    m_bInitialized(FALSE)
{
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO destructor
//
CDirectSoundCaptureNoiseSuppressDMO::~CDirectSoundCaptureNoiseSuppressDMO()
{
}


const MP_CAPS g_NsCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps            min,    max,    neutral,    unit text,  label,  pwchText??
    NSP_Enable,     MPT_BOOL,   g_NsCapsAll,    0,      1,      0,          L"",        L"",    L"",
};


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::InitOnCreation
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof g_params / sizeof *g_params, g_params);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Init
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::Clone(IMediaObjectInPlace **pp)
{
    return StandardDMOClone<CDirectSoundCaptureNoiseSuppressDMO, DSCFXNoiseSuppress>(this, pp);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Discontinuity
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::Discontinuity()
{
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::FBRProcess
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::FBRProcess
(
    DWORD cSamples,
    BYTE *pIn,
    BYTE *pOut
)
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}


// ==============Implementation of the private INoiseSuppress interface ==========
// ==================== needed to support the property page ===============


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::SetAllParameters(LPCDSCFXNoiseSuppress pParm)
{
    if (pParm == NULL)
    {
        Trace(1, "ERROR: pParm is NULL\n");
        return E_POINTER;
    }

    HRESULT hr = SetParam(NSP_Enable, static_cast<MP_DATA>(pParm->fEnable));
    if (SUCCEEDED(hr))
    {
        m_fDirty = true;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::GetAllParameters(LPDSCFXNoiseSuppress pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    MP_DATA var;
    HRESULT hr = GetParam(NSP_Enable, &var);
    if (SUCCEEDED(hr))
    {
        pParm->fEnable = (BOOL)var;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Reset
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::Reset()
{
    return KsTopologyNodeReset(m_hPin, m_ulNodeId, true);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::SetParam
(
    DWORD dwParamIndex,
    MP_DATA value,
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;

    switch (dwParamIndex)
    {
        case NSP_Enable:
            if ((BOOL)value != m_fEnable)
            {
                hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, (BOOL)value);
                if (SUCCEEDED(hr)) m_fEnable = (BOOL)value;
            }
            break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }

    // Let the base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're
    // calling the function internally using values that came from the base class --
    // thus there's no need to tell it values it already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::GetParam
(
    DWORD dwParamIndex,
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;

    switch (dwParamIndex)
    {
    case NSP_Enable:
        hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
        if (SUCCEEDED(hr))
        {
            m_fEnable = fTemp;
            *value = (MP_DATA)fTemp;
        }
        break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::ProcessInPlace
(
    ULONG ulQuanta,
    LPBYTE pcbData,
    REFERENCE_TIME rtStart,
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\map.h ===
//
//
//
#ifndef _MicArrayp_
#define _MicArrayp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundCaptureMicArrayDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXMicArray,
    public CComBase
{
public:
    CDirectSoundCaptureMicArrayDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundCaptureMicArrayDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);
   
    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                        (THIS_ IMediaObjectInPlace **);

    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSCFXMicArray);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSCFXMicArray);

    // IMediaParams overrides
    STDMETHOD(SetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA* value);
   
    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
    BOOL m_fDirty;

private:
    BOOL m_fEnable;
    BOOL m_fReset;
    BOOL m_bInitialized;
};

EXT_STD_CAPTURE_CREATE(MicArray);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\ma.cpp ===
#include <windows.h>
#include "map.h"
#include "kshlp.h"
#include "clone.h"

STD_CAPTURE_CREATE(MicArray)

STDMETHODIMP CDirectSoundCaptureMicArrayDMO::NDQueryInterface
(
    REFIID riid, 
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXMicArray)
    {
        return GetInterface((IDirectSoundCaptureFXMicArray*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

CDirectSoundCaptureMicArrayDMO::CDirectSoundCaptureMicArrayDMO( IUnknown *pUnk, HRESULT *phr ) :
    CComBase( pUnk, phr ),
    m_fEnable(FALSE),
    m_fReset(FALSE),
    m_fDirty(FALSE),
    m_bInitialized(FALSE)
{
}

CDirectSoundCaptureMicArrayDMO::~CDirectSoundCaptureMicArrayDMO()
{
}

const MP_CAPS g_MicArrayCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps           min,                        max,                        neutral,                    unit text,  label,          pwchText??
    MAP_Enable,    MPT_BOOL,   g_MicArrayCapsAll,  0,                          1,                          0,                          L"",        L"",            L"",
    MAP_Reset,     MPT_BOOL,   g_MicArrayCapsAll,  0,                          1,                          0,                          L"",        L"",            L""
};

HRESULT CDirectSoundCaptureMicArrayDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundCaptureMicArrayDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundCaptureMicArrayDMO, DSCFXMicArray>(this, pp);
}

HRESULT CDirectSoundCaptureMicArrayDMO::Discontinuity() {
   return NOERROR;
}

HRESULT CDirectSoundCaptureMicArrayDMO::FBRProcess
(
    DWORD cSamples, 
    BYTE *pIn, 
    BYTE *pOut
) 
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}

// ==============Implementation of the private IMicArray interface ==========
// ==================== needed to support the property page ===============

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::SetAllParameters(LPCDSCFXMicArray pParm)
{
    HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pParm == NULL)
    {
        Trace(1,"ERROR: pParm is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(MAP_Enable, static_cast<MP_DATA>(pParm->fEnable));
	if (SUCCEEDED(hr)) hr = SetParam(MAP_Reset, static_cast<MP_DATA>(pParm->fReset));
            
    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::GetAllParameters(LPDSCFXMicArray pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    MP_DATA var;

    GetParam(MAP_Enable, &var);
    pParm->fEnable = (BOOL)var;
    
    GetParam(MAP_Reset, &var);
    pParm->fReset = (BOOL)var;
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::SetParam
(
    DWORD dwParamIndex, 
    MP_DATA value, 
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;
    BOOL fEnable = (BOOL)value;
    BOOL fReset = (BOOL)value;

    switch (dwParamIndex)
    {
    case MAP_Enable:
        if (fEnable)
        {
            hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, fEnable);
            if(SUCCEEDED(hr)) m_fEnable = fEnable;
        }
        break;
    case MAP_Reset:
        if (fReset)
        {
            hr = KsTopologyNodeReset(m_hPin, m_ulNodeId, fReset);
            if(SUCCEEDED(hr)) m_fReset = fReset;
        }
        break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);

}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::GetParam
(
    DWORD dwParamIndex, 
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;

    switch (dwParamIndex)
    {
    case MAP_Enable:
        hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
        if(SUCCEEDED(hr)) 
        {
            m_fEnable = fTemp;
            *value = (MP_DATA)fTemp;
        }
        break;
    case MAP_Reset:
        *value = (MP_DATA)m_fReset;
        break;
    }

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureMicArrayDMO::ProcessInPlace
(
    ULONG ulQuanta, 
    LPBYTE pcbData, 
    REFERENCE_TIME rtStart, 
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\param.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParams.
//

#include "dmerror.h"
#include "param.h"
#include "math.h"
#include "validate.h"
#include "debug.h"

#pragma warning(disable:4296)       

CCurveList::~CCurveList()
{
    while(this->GetHead())
    {
        delete this->RemoveHead();
    }
}

CParamsManager::CParamsManager()
  
{
    m_fDirty = FALSE;
	m_cTimeFormats = 0;
	m_pguidTimeFormats = NULL;
	m_guidCurrentTimeFormat = GUID_NULL;
	m_cParams = 0;
	m_pCurveLists = NULL;
    m_pParamInfos = NULL;
	m_dwActiveBits = 0;
	InitializeCriticalSection(&m_ParamsCriticalSection);
}

CParamsManager::~CParamsManager()
{
	delete[] m_pguidTimeFormats;
	delete[] m_pCurveLists;
	delete[] m_pParamInfos;
	DeleteCriticalSection(&m_ParamsCriticalSection);
}

HRESULT CParamsManager::InitParams(DWORD cTimeFormats, const GUID *pguidTimeFormats, DWORD dwFormatIndex, MP_TIMEDATA mptdTimeData, DWORD cParams, ParamInfo *pParamInfo)
{
    //check that the index is in a valid range
    if (0 > dwFormatIndex || dwFormatIndex >= cTimeFormats || cParams > sizeof(DWORD) * 8)
        return E_INVALIDARG;
        
    m_pCurveLists = new CCurveList[cParams];
    if (!m_pCurveLists)
        return E_OUTOFMEMORY;

    // save the time formats
    m_pguidTimeFormats = new GUID[cTimeFormats];
    if (!m_pguidTimeFormats)
        return E_OUTOFMEMORY;
        
    for (DWORD dwIndex = 0; dwIndex < cTimeFormats; dwIndex++)
    {
        memcpy(&m_pguidTimeFormats[dwIndex], &pguidTimeFormats[dwIndex], sizeof(*pguidTimeFormats));
    }

    // save the count of formats
    m_cTimeFormats = cTimeFormats;

    // save the current time format
    m_guidCurrentTimeFormat = m_pguidTimeFormats[dwFormatIndex];

    // save the TimeData
    m_mptdCurrentTimeData = mptdTimeData;

    // save the parameter info
    m_pParamInfos
    = new ParamInfo[cParams];
    if (!m_pParamInfos)
        return E_OUTOFMEMORY;
    for (dwIndex = 0; dwIndex < cParams; dwIndex++)
    {
        if (pParamInfo[dwIndex].dwIndex < cParams)
        {
            memcpy(&m_pParamInfos[pParamInfo[dwIndex].dwIndex],&pParamInfo[dwIndex],sizeof(ParamInfo));
        }
    }
    m_cParams = cParams;

    return S_OK;
}

HRESULT CParamsManager::GetParamCount(DWORD *pdwParams)

{
    if (pdwParams == NULL)
        return E_POINTER;
    
    *pdwParams = m_cParams;
    return S_OK;
}

HRESULT CParamsManager::GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo)

{
    if (!pInfo)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        *pInfo = m_pParamInfos[dwParamIndex].MParamInfo;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetParamText(DWORD dwParamIndex,WCHAR **ppwchText)

{
    if (!ppwchText)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        // write string of format: "Label\0Unit\0Enums1\0Enum2\0...EnumN\0\0"
        ParamInfo &pinfo = m_pParamInfos[dwParamIndex];
        int iUnit = wcslen(pinfo.MParamInfo.szLabel) + 1; // begin writing unit text here
        int iEnums = iUnit + wcslen(pinfo.MParamInfo.szUnitText) + 1; // begin writing enum text here
        int iEnd = iEnums + wcslen(pinfo.pwchText) + 1; // write the final (second) null terminator here
        WCHAR *pwsz = static_cast<WCHAR *>(CoTaskMemAlloc((iEnd + 1) * sizeof(WCHAR)));

        if (!pwsz)
            return E_OUTOFMEMORY;

        // StringCchPrintfW will write into various points of the string, neatly terminating each with a null
        StringCchPrintfW(pwsz,iEnd+1,L"%ls%lc%ls%lc%s%lc",pinfo.MParamInfo.szLabel,L'\0', pinfo.MParamInfo.szUnitText,L'\0', pinfo.pwchText,L'\0');

        // The text field was defined with commas to separate the enum values.
        // Replace them with NULL characters now.
        for (WCHAR *pwch = pwsz + iEnums; *pwch; ++pwch)
        {
            if (*pwch == L',')
                *pwch = L'\0';
        }

        pwsz[iEnd] = L'\0';
        
        *ppwchText = pwsz;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetNumTimeFormats(DWORD *pdwNumTimeFormats)

{
    if (!pdwNumTimeFormats)
    {
        return E_POINTER;
    }
    *pdwNumTimeFormats = m_cTimeFormats;
    return S_OK;
}

HRESULT CParamsManager::GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat)

{
    if (!pguidTimeFormat)
    {
        return E_POINTER;
    }
    if (dwFormatIndex >= m_cTimeFormats)
    {
        return E_INVALIDARG;
    }
    *pguidTimeFormat = m_pguidTimeFormats[dwFormatIndex];
    return S_OK;
}

HRESULT CParamsManager::GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData)

{
    HRESULT hr=S_OK;
    
    // Parameter Validation
    if ((pguidTimeFormat == NULL) || (pTimeData == NULL))
    {
        hr = E_POINTER;
        Trace(1,"ERROR: pGuidTimeFormat or pTimeData is NULL\n");
    }

    // Return the values
    if (SUCCEEDED(hr))
    {
        *pguidTimeFormat = m_guidCurrentTimeFormat;
        *pTimeData = m_mptdCurrentTimeData;
    }
    
    return hr;
}


HRESULT CParamsManager::CopyParamsFromSource( CParamsManager * pSource)

{
    HRESULT hr = S_OK;
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
    {
        if (pSource->m_guidCurrentTimeFormat == m_pguidTimeFormats[dwIndex])
        {
            break;
        }
    }
    
    
    hr = InitParams(pSource->m_cTimeFormats, pSource->m_pguidTimeFormats, dwIndex, pSource->m_mptdCurrentTimeData, pSource->m_cParams,pSource->m_pParamInfos);
    if (SUCCEEDED(hr))
    {
        for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
        {
            CCurveItem *pCurve = pSource->m_pCurveLists[dwIndex].GetHead();
            for (;pCurve;pCurve = pCurve->GetNext())
            {
	            CCurveItem *pNew = new CCurveItem;
                if (!pNew) 
                {
                    return E_OUTOFMEMORY;
                }
                pNew->m_Envelope = pCurve->m_Envelope;
                m_pCurveLists[dwIndex].AddTail(pNew);
            }
        }
    }
    return hr;
}

void
CParamsManager ::UpdateActiveParams(REFERENCE_TIME rtTime, UpdateCallback &rThis)
{
    if (!m_dwActiveBits)
        return; // nothing to recalc

    DWORD dwBit = 1;
    for (DWORD dwIndex = 0; dwIndex < m_cParams; dwIndex++, dwBit = dwBit << 1)
    {
        if (m_dwActiveBits & dwBit)
        {
            float fVal = 0;
            HRESULT hr = GetParamFloat(dwIndex, rtTime, &fVal);
            rThis.SetParamUpdate(dwIndex, fVal);
            if (hr == S_FALSE)
                m_dwActiveBits &= ~dwBit; // we're beyond the last curve, don't need to recalc next time

            TraceI(6, "DMO value: time %I64d, param #%d, current value %hf\n", rtTime, dwIndex, fVal);
        }
    }
}

inline float ValRange(float valToClip, float valMin, float valMax)
{
	return valToClip < valMin
				? valMin
				: (valToClip > valMax ? valMax : valToClip);
}

HRESULT CParamsManager::GetParamFloat(DWORD dwParamIndex,REFERENCE_TIME rtTime,float *pval)
{
	HRESULT hr = S_OK;

	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

	// if no points, then neutral value
	CCurveItem *pCurveHead = pList->GetHead();
	if (!pCurveHead)
	{
		*pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_FALSE;
	}

	// Find the curve during or before the requested time
    // If the time is during a curve, we will use that.
    // If not, we need the end value of the previous curve.
    // Our list keeps these in backwards order, so we are scanning from the 
    // highest point in time backwards.

	for (CCurveItem *pCurve = pCurveHead; pCurve && pCurve->m_Envelope.rtStart > rtTime;pCurve = pCurve->GetNext());

    // If there is no pCurve, there was no curve prior to or during rtTime. Give up.
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
    }
    // Now, if pCurve ends before the requested time,
    // return the final value of pCurve, since that will hold until the start of the next curve.
    if (pCurve->m_Envelope.rtEnd < rtTime)
    {
		*pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		if (pCurve == pCurveHead)
			return S_FALSE; // past last curve
		else
			return S_OK; // there are more curves ahead
	}

    // If we get this far, the curve must bound rtTime.

	if (pCurve->m_Envelope.iCurve & MP_CURVE_JUMP)
	{
		*pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
	}

	REFERENCE_TIME rtTimeChange = pCurve->m_Envelope.rtEnd - pCurve->m_Envelope.rtStart;
	REFERENCE_TIME rtTimeIntermediate = rtTime - pCurve->m_Envelope.rtStart; 

	float fltScalingX = static_cast<float>(rtTimeIntermediate) / rtTimeChange; // horizontal distance along curve between 0 and 1
	float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
    switch (pCurve->m_Envelope.iCurve)
    {
    case MP_CURVE_SQUARE:
		fltScalingY = fltScalingX * fltScalingX;
        break;
    case MP_CURVE_INVSQUARE:
		fltScalingY = (float) sqrt(fltScalingX);
        break;
    case MP_CURVE_SINE:
        //  Maybe we should have a lookup table here?
        fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
        break;
    case MP_CURVE_LINEAR:
    default:
		fltScalingY = fltScalingX;
    }

    // Find out if we need to pull the start point from the previous curve,
    // the default neutral value, or the current curve.
    float fStartVal = pCurve->m_Envelope.valStart;
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_NEUTRALVAL)
    {
        fStartVal = pInfo->MParamInfo.mpdNeutralValue;
    }
    // Currentval, if it exists, will override neutralval.
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_CURRENTVAL)
    {
        // Take advantage of the fact that these are inserted in backwards order.
        // Scan for the previous curve that ends before this time.
        CCurveItem *pPrevious = pCurve->GetNext();
       	for (;pPrevious && pPrevious->m_Envelope.rtEnd > rtTime;pPrevious = pPrevious->GetNext());
        if (pPrevious)
        {
            fStartVal = pPrevious->m_Envelope.valEnd;
        }
    }
    
    // Apply that scaling to the range of the actual points
    *pval = (pCurve->m_Envelope.valEnd - fStartVal) * fltScalingY + fStartVal;

    LeaveCriticalSection(&m_ParamsCriticalSection);
    return hr;
}

HRESULT CParamsManager::GetParamInt(DWORD dwParamIndex,REFERENCE_TIME rt,long *pval)

{
    HRESULT hr = E_POINTER;
    if (pval)
    {
        float fVal;
        hr = GetParamFloat(dwParamIndex,rt,&fVal);
        if (SUCCEEDED(hr))
        {
            *pval = (long) (fVal + 1/2);    // Round.
        }
    }
    else
    {
        Trace(1,"ERROR: pval is NULL\n");
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IMediaParams

HRESULT CParamsManager::GetParam(DWORD dwParamIndex,MP_DATA *pValue)
{
    V_INAME(CParams::GetParam);
    V_PTR_WRITE(pValue, MP_DATA);
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);

	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// if no points, then neutral value
	CCurveItem *pCurve = pList->GetHead();
	if (pCurve)
	{
		*pValue = pCurve->m_Envelope.valEnd;
	}
    else
    {
        *pValue = pInfo->MParamInfo.mpdNeutralValue;
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return S_OK;
}

HRESULT CParamsManager::SetParam(DWORD dwParamIndex,MP_DATA value)
{
	V_INAME(CParams::SetParam);
    
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// If we've already got a list, just force the most recent curve item to this value.
    // Otherwise, create a node and add it.
	CCurveItem *pCurve = pList->GetHead();
	if (!pCurve)
	{
        pCurve = new CCurveItem;
        if (pCurve)
        {
            pCurve->m_Envelope.rtStart =    0x8000000000000000; // Max negative.
            pCurve->m_Envelope.rtEnd =      0x7FFFFFFFFFFFFFFF; // Max positive.
            pCurve->m_Envelope.flags = 0;
            pList->AddHead(pCurve);
        }
		else 
        {
            LeaveCriticalSection(&m_ParamsCriticalSection);
            return E_OUTOFMEMORY;
        }
	}
    pCurve->m_Envelope.valStart = value;
    pCurve->m_Envelope.valEnd = value;
    pCurve->m_Envelope.iCurve = MP_CURVE_JUMP;
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::AddEnvelope(
		DWORD dwParamIndex,
		DWORD cPoints,
		MP_ENVELOPE_SEGMENT *ppEnvelope)
{
	V_INAME(CParams::AddEnvelope);
	V_PTR_READ(ppEnvelope, *ppEnvelope);

	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

	if (!m_pParamInfos)
		return DMUS_E_NOT_INIT;

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;

	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

    DWORD dwCount;
    for (dwCount = 0; dwCount < cPoints; dwCount++)
    {
        CCurveItem *pCurve = new CCurveItem;
        if (!pCurve) 
        {
            hr = E_OUTOFMEMORY;
            Trace(1,"ERROR: Out of memory\n");
            break;
        }
        pCurve->m_Envelope = ppEnvelope[dwCount];
        pCurve->m_Envelope.valEnd = ValRange(pCurve->m_Envelope.valEnd, 
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pCurve->m_Envelope.valStart = ValRange(pCurve->m_Envelope.valStart, 
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pList->AddHead(pCurve);
        m_dwActiveBits |= 1 << dwParamIndex; // next call to UpdateActiveParams will ensure the parameter's value is recalculated

	    TraceI(6, "DMO envelope: time %I64d-%I64d, param #%d, value %hf-%hf\n",
				pCurve->m_Envelope.rtStart, pCurve->m_Envelope.rtEnd,
				dwParamIndex, pCurve->m_Envelope.valStart, pCurve->m_Envelope.valEnd);
    }

    LeaveCriticalSection(&m_ParamsCriticalSection);

	return hr;
}

HRESULT CParamsManager::FlushEnvelope(
		DWORD dwParamIndex,
		REFERENCE_TIME refTimeStart,
		REFERENCE_TIME refTimeEnd)
{
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

	if (!m_pParamInfos)
		return DMUS_E_NOT_INIT;

	if (refTimeStart >= refTimeEnd)
	    return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    CCurveList TempList;
    CCurveItem *pCurve;
    while (pCurve = pList->RemoveHead())
    {
        if ((pCurve->m_Envelope.rtStart >= refTimeStart) && 
            (pCurve->m_Envelope.rtEnd <= refTimeEnd))
        {
            delete pCurve;
        }
        else 
        {
            TempList.AddHead(pCurve);
        }
    }
    while (pCurve = TempList.RemoveHead())
    {
        pList->AddHead(pCurve);
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);

	return S_OK;
}

HRESULT CParamsManager::SetTimeFormat(
		GUID guidTimeFormat,
		MP_TIMEDATA mpTimeData)
{
    for (DWORD dwIndex = 0; dwIndex < m_cTimeFormats; dwIndex++)
    {
        if (guidTimeFormat == m_pguidTimeFormats[dwIndex])
        {
            m_guidCurrentTimeFormat = m_pguidTimeFormats[dwIndex];
            return S_OK;
        }
    }

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\nsp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nsp.h
 *  Content:    Noise Suppression DMO declarations.
 *
 ***************************************************************************/

#ifndef _NoiseSuppressp_
#define _NoiseSuppressp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundCaptureNoiseSuppressDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXNoiseSuppress,
    public CComBase
{
public:
    CDirectSoundCaptureNoiseSuppressDMO(IUnknown *pUnk, HRESULT *phr);
    ~CDirectSoundCaptureNoiseSuppressDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress);
    STDMETHOD(Reset)                (THIS);

    // IMediaParams methods
    STDMETHOD(SetParam)             (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)             (THIS_ DWORD dwParamIndex, MP_DATA* value);

    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);

private:
    BOOL m_fDirty;
    BOOL m_fEnable;
    BOOL m_bInitialized;
};

EXT_STD_CAPTURE_CREATE(NoiseSuppress);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\oledll.cpp ===
// oledll.cpp
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	 = TEXT("ThreadingModel");
static const TCHAR g_szBoth[]            = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    StringCchCopy(szClsKey, sizeof(szClsKey)/sizeof(TCHAR), g_szCLSIDSlash);
    StringCchCat(szClsKey,sizeof(szClsKey)/sizeof(TCHAR) ,szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    StringCchCopy(szClsKey, sizeof(szClsKey)/sizeof(TCHAR),g_szCLSIDSlash);
    StringCchCat(szClsKey, sizeof(szClsKey)/sizeof(TCHAR),szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    StringCchCopy(szClsKey,sizeof(szClsKey)/sizeof(TCHAR),g_szCLSIDSlash);
    StringCchCat(szClsKey,sizeof(szClsKey)/sizeof(TCHAR),szCLSID);
    StringCchCat(szClsKey,sizeof(szClsKey)/sizeof(TCHAR),TEXT("\\"));
    if (szKey)
    {
	    StringCchCat(szClsKey, sizeof(szClsKey)/sizeof(TCHAR), szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    StringCbCopy(szStr, cbStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
                LPCTSTR pstrSubkey,
                LPCTSTR pstrValueName,
                LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        StringCchCopy(sz,sizeof(sz)/sizeof(TCHAR),pstrKey);
        StringCchCat(sz, sizeof(sz)/sizeof(TCHAR), TEXT("\\"));
        StringCchCat(sz, sizeof(sz)/sizeof(TCHAR), pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\param.h ===
#ifndef __TOOLPARAM_H__
#define __TOOLPARAM_H__



#include "medparam.h"
#include "alist.h"

typedef struct _ParamInfo
{
    DWORD dwIndex;                      // Which parameter.
    MP_PARAMINFO    MParamInfo;         // Standard MediaParams structure.
    WCHAR *         pwchText;           // Array of text names for enumerated types.
} ParamInfo;

class CCurveItem : public AListItem
{
public:
    CCurveItem* GetNext() { return (CCurveItem*)AListItem::GetNext();}
    MP_ENVELOPE_SEGMENT m_Envelope;     // Envelope segment.
};

class CCurveList : public AList
{
public:
//    void Clear();
    void AddHead(CCurveItem* pCurveItem) { AList::AddHead((AListItem*)pCurveItem);}
//    void Insert(CCurveItem* pCurveItem);
    CCurveItem* GetHead(){return (CCurveItem*)AList::GetHead();}
//    CCurveItem* GetItem(LONG lIndex){return (CCurveItem*)AList::GetItem(lIndex);}
    CCurveItem* RemoveHead(){ return (CCurveItem*)AList::RemoveHead();}
//    void Remove(CCurveItem* pCurveItem){AList::Remove((AListItem*)pCurveItem);}
//    void AddTail(CCurveItem* pCurveItem){AList::AddTail((AListItem*)pCurveItem);}
//    CCurveItem* GetTail(){ return (CCurveItem*)AList::GetTail();}
	~CCurveList();
};

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF
#define MP_CAPS_ALL     MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE

class CParamsManager :  public IMediaParams, public IMediaParamInfo
{
public:
    CParamsManager();
    ~CParamsManager();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IMediaParams
    STDMETHODIMP GetParam(DWORD dwParamIndex, MP_DATA *pValue);
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value);
    STDMETHODIMP AddEnvelope(DWORD dwParamIndex,DWORD cPoints,MP_ENVELOPE_SEGMENT *ppEnvelope);
    STDMETHODIMP FlushEnvelope( DWORD dwParamIndex,REFERENCE_TIME refTimeStart,REFERENCE_TIME refTimeEnd);
    STDMETHODIMP SetTimeFormat( GUID guidTimeFormat,MP_TIMEDATA mpTimeData);

    // IMediaParamInfo
    STDMETHODIMP GetParamCount(DWORD *pdwParams);
    STDMETHODIMP GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo);
    STDMETHODIMP GetParamText(DWORD dwParamIndex,WCHAR **ppwchText);
    STDMETHODIMP GetNumTimeFormats(DWORD *pdwNumTimeFormats);
    STDMETHODIMP GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat);        
    STDMETHODIMP GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData);

    // other (non-COM) functions
    HRESULT InitParams(DWORD cTimeFormats, const GUID *pguidTimeFormats, DWORD dwFormatIndex, MP_TIMEDATA mptdTimeData, DWORD cParams, ParamInfo *pParamInfos);
    HRESULT GetParamFloat(DWORD dwParamIndex,REFERENCE_TIME rtTime,float *pval); // returns S_FALSE if rtTime is after the end time of the last curve
    HRESULT GetParamInt (DWORD dwParamIndex,REFERENCE_TIME rt,long *pval); // returns S_FALSE if rtTime is after the end time of the last curve
    HRESULT CopyParamsFromSource(CParamsManager * pSource);

    // parameter control curve handling
    class UpdateCallback
    {
    public:
        // Define this in derived classes if you are going to use UpdateActiveParams.
        //  Called by CParamsManager inside UpdateActiveParams to update the effect's internal state variables.
        //  SetParamUpdate should be the same as SetParam, except that DMO defer the call to the base class
        //  (CParamsManager::SetParam) in SetParam but should not do so in SetParamUpdate.
        virtual HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) = 0;
    };
    // function that calls SetParam to adjust the value of all parameters that may have changed to their
    // new values at time rtTime
    void UpdateActiveParams(REFERENCE_TIME rtTime, UpdateCallback &rThis); // rThis should be the derived class (*this)
    DWORD GetActiveParamBits() { return m_dwActiveBits; }

protected:
    // data

    CRITICAL_SECTION m_ParamsCriticalSection;
    BOOL            m_fDirty;					// Has data changed since last file load or save?
    DWORD           m_cTimeFormats;             // Number of supported time formats.
    GUID            *m_pguidTimeFormats;        // Array of supported time formats.
    GUID            m_guidCurrentTimeFormat;    // The time format we're set to.
    MP_TIMEDATA     m_mptdCurrentTimeData;		// The unit of measure for the current time format.
    DWORD           m_cParams;                  // Number of parameters.
    ParamInfo       *m_pParamInfos;             // Array of ParamInfo structures, one for each parameter.
    CCurveList      *m_pCurveLists;             // Array of Curve lists, one for each parameter.
    DWORD           m_dwActiveBits;             // Tracks the params that currently have curves active.
};

#endif // __TOOLPARAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\parameq.cpp ===
#include <windows.h>

#include "parameqp.h"
#include "clone.h"

STD_CREATE(ParamEq)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::QueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundParamEqDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXParamEq)
    {
        return GetInterface((IDirectSoundFXParamEq*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::CDirectSoundParamEqDMO
//
CDirectSoundParamEqDMO::CDirectSoundParamEqDMO( IUnknown * pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(TRUE)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 48000;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::Init()
//
HRESULT CDirectSoundParamEqDMO::Init()
{
    DSFXParamEq param;

    // Force recalc of all internal parameters
    //
    GetAllParameters(&param);
    SetAllParameters(&param);

    return Discontinuity();
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    PFP_Center,     MPT_FLOAT,  g_capsAll,  DSFXPARAMEQ_CENTER_MIN,     DSFXPARAMEQ_CENTER_MAX,     8000,                   L"",        L"Center",      L"",
    PFP_Bandwidth,  MPT_FLOAT,  g_capsAll,  DSFXPARAMEQ_BANDWIDTH_MIN,  DSFXPARAMEQ_BANDWIDTH_MAX,  12,                     L"",        L"Bandwidth",   L"",
    PFP_Gain,       MPT_FLOAT,  g_capsAll,  DSFXPARAMEQ_GAIN_MIN,       DSFXPARAMEQ_GAIN_MAX,       0,                      L"",        L"Gain",        L"",
};

HRESULT CDirectSoundParamEqDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::~CDirectSoundParamEqDMO
//
CDirectSoundParamEqDMO::~CDirectSoundParamEqDMO() 
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::Clone
//
STDMETHODIMP CDirectSoundParamEqDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundParamEqDMO, DSFXParamEq>(this, pp);
}
//
//	Bump - bump the delay pointers.
//
void CDirectSoundParamEqDMO::Bump(void)
{
// EAX {
// }
}


HRESULT CDirectSoundParamEqDMO::Discontinuity() 
{
// { EAX

	m_delayL1 = m_delayL2 = m_delayR1 = m_delayR2 = 0;

// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


__forceinline void CDirectSoundParamEqDMO::DoOneSampleMono(int *l)
{
	float	inPortL = (float)*l;
	
	float	outPortL, temp1, temp2, temp3;

	temp1     = inPortL / 4;

	// 2nd Order Ladder All Pass: Zeros first version
	temp3     = m_delayL2 + temp1 * m_EaxApA;
	temp2     = temp1 - temp3 * m_EaxApA;
	m_delayL2 = m_delayL1 + temp2 * m_EaxApB;
	m_delayL1 = temp2 - m_delayL2 * m_EaxApB;

	// Regalia Mitra Structure
	temp3     = temp3 * m_EaxGainCoefA;
	temp3     = temp3 + temp1 * m_EaxGainCoefB;
	outPortL  = m_EaxScale * temp3;

	*l = Saturate(outPortL);

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////


__forceinline void CDirectSoundParamEqDMO::DoOneSample(int *l, int *r)
{
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;
	
	float	outPortL, outPortR, temp1, temp2, temp3;

	temp1     = inPortL / 4;

	// 2nd Order Ladder All Pass: Zeros first version
	temp3     = m_delayL2 + temp1 * m_EaxApA;
	temp2     = temp1 - temp3 * m_EaxApA;
	m_delayL2 = m_delayL1 + temp2 * m_EaxApB;
	m_delayL1 = temp2 - m_delayL2 * m_EaxApB;

	// Regalia Mitra Structure
	temp3     = temp3 * m_EaxGainCoefA;
	temp3     = temp3 + temp1 * m_EaxGainCoefB;
	outPortL  = m_EaxScale * temp3;

	*l = Saturate(outPortL);

	temp1     = inPortR / 4;

	// 2nd Order Ladder All Pass: Zeros first version
	temp3     = m_delayR2 + temp1 * m_EaxApA;
	temp2     = temp1 - temp3 * m_EaxApA;
	m_delayR2 = m_delayR1 + temp2 * m_EaxApB;
	m_delayR1 = temp2 - m_delayR2 * m_EaxApB;

	// Regalia Mitra Structure
	temp3     = temp3 * m_EaxGainCoefA;
	temp3     = temp3 + temp1 * m_EaxGainCoefB;
	outPortR  = m_EaxScale * temp3;

	*r = Saturate(outPortR);

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::FBRProcess
//
HRESULT CDirectSoundParamEqDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
//				j  = i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
//				j =  i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::ProcessInPlace
//
HRESULT CDirectSoundParamEqDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    hr = FBRProcess(ulQuanta, pcbData, pcbData);
        
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::SetParam
//
// { EAX
// }

void CDirectSoundParamEqDMO::UpdateCoefficients(void)
{
	float _gain, _omega, _lambda, _sinX;


	//Calculate linear gain coefficient
	_gain = (float)pow(10, m_EaxGain/20);

	if (!_gain) _gain = (float).00001;

	m_EaxGainCoefA = (1 - _gain)/2;
	m_EaxGainCoefB = (1 + _gain)/2;
	
	//Calculate scaling coefficient
	m_EaxScale = (float)((fabs(m_EaxGainCoefA) > fabs(m_EaxGainCoefB)) ? fabs(m_EaxGainCoefA) : fabs(m_EaxGainCoefB));
	m_EaxScale = (float)(m_EaxScale > 1 ? ceil(m_EaxScale) : 1);

	m_EaxGainCoefA /= m_EaxScale;
	m_EaxGainCoefB /= m_EaxScale;

	m_EaxScale = m_EaxScale * 4;

	//Calculate allpass coefficients

	_omega  = (float)(2*PI*m_EaxCenter/m_EaxSamplesPerSec);

	_sinX   = (float)sin(_omega);

//	if (!_sinX) _sinX = (float).000001;

	_lambda = (float)(sinh(.5 * log(2) * m_EaxBandwidth/12 * _omega/_sinX) * sin(_omega));
	m_EaxApA = (float)((1 - (_lambda/sqrt(_gain))) / (1 + (_lambda/sqrt(_gain))));
	m_EaxApB = (float)(-cos(_omega));
}

HRESULT CDirectSoundParamEqDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

    switch (dwParamIndex)
    {
// { EAX
	case PFP_Center :
		CHECK_PARAM(DSFXPARAMEQ_CENTER_MIN, DSFXPARAMEQ_CENTER_MAX);

        //if we are greater than 1/3rd the samplig rate then we need to S_FALSE;
		if (value > (m_EaxSamplesPerSec/3))
		{
		    hr = S_FALSE;
		    value = static_cast<MP_DATA>(m_EaxSamplesPerSec/3);
		}

		PUT_EAX_VALUE(Center, value);
		
		UpdateCoefficients();
		break;
	
	case PFP_Bandwidth :
		CHECK_PARAM(DSFXPARAMEQ_BANDWIDTH_MIN, DSFXPARAMEQ_BANDWIDTH_MAX);

		PUT_EAX_VALUE(Bandwidth, value);

		UpdateCoefficients();
		break;

	case PFP_Gain : {
		CHECK_PARAM(DSFXPARAMEQ_GAIN_MIN, DSFXPARAMEQ_GAIN_MAX);

		PUT_EAX_VALUE(Gain, value);

		UpdateCoefficients();
		break;
	}
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    hr2 = fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);

    if(FAILED(hr2))
    {
        hr = hr2;
    }
        
    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundParamEqDMO::SetAllParameters(LPCDSFXParamEq peq)
{
    HRESULT hr = S_OK;
    HRESULT hr2[3];

    ZeroMemory(hr2,sizeof(hr2));
	
	// Check that the pointer is not NULL
    if (peq == NULL)
    {
        Trace(1,"ERROR: peq is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = hr2[0] = SetParam(PFP_Center, peq->fCenter);
	if (SUCCEEDED(hr)) hr = hr2[1] = SetParam(PFP_Bandwidth, peq->fBandwidth);
    if (SUCCEEDED(hr)) hr = hr2[2] = SetParam(PFP_Gain, peq->fGain);

    // if we have any alternate success codes, grab the first one and return it.
    if(SUCCEEDED(hr))
    {
        for (int i = 0;i < 3; i++)
        {
            if (hr2[i] != S_OK)
            {
                hr = hr2[i];
                break;
            }
        }
    }

    m_fDirty = true;
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundParamEqDMO::GetAllParameters(LPDSFXParamEq peq)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (peq ==NULL) return E_POINTER;

#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) peq->y = mpd; \
	}

	GET_PARAM(PFP_Center, fCenter);
	GET_PARAM(PFP_Bandwidth, fBandwidth);
	GET_PARAM(PFP_Gain, fGain);

	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundParamEqDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_PARAMEQ;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\propertyhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Helpers for implementation of ISpecifyPropertyPages and IPersistStream
//

#include "PropertyHelp.h"

HRESULT PropertyHelp::GetPages(const CLSID &rclsidPropertyPage, CAUUID * pPages)
{
    pPages->cElems = 1;
    pPages->pElems = static_cast<GUID *>(CoTaskMemAlloc(sizeof(GUID)));
    if (pPages->pElems == NULL)
        return E_OUTOFMEMORY;

    *(pPages->pElems) = rclsidPropertyPage;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\propertyhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Helpers for implementation of ISpecifyPropertyPages and IPersistStream
//

#pragma once
#include "ocidl.h"

// Paste these declarations into your class methods to implement the interfaces.  Replace DSFXZZZ with the name of your struct.
// These assume that you implement GetAllParameters/SetAllParameters interfaces with a struct and that you have a public m_fDirty
// member variable that you use to hold the dirty state of your object for persistence.

/*
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropZZZ, pPages); }

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXZZZ(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXZZZ(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXZZZ); return S_OK; }
*/

// Load, Save, and GetPages are actually implemented in the following functions.

namespace PropertyHelp
{
    HRESULT GetPages(const CLSID &rclsidPropertyPage, CAUUID * pPages);

    template<class O, class S> HRESULT Load(O *pt_object, S &t_struct, IStream *pStm)
    {
        ULONG cbRead;
        HRESULT hr;

        if (pStm==NULL)
        	return E_POINTER;

        hr = pStm->Read(&t_struct, sizeof(t_struct), &cbRead);
        if (hr != S_OK || cbRead < sizeof(t_struct))
            return E_FAIL;

        hr = pt_object->SetAllParameters(&t_struct);
        pt_object->m_fDirty = false;
        return hr;
    }

    template<class O, class S> HRESULT Save(O *pt_object, S &t_struct, IStream *pStm, BOOL fClearDirty)
    {
        HRESULT hr; 

        if (pStm==NULL)
        	return E_POINTER;

        hr = pt_object->GetAllParameters(&t_struct);
        if (FAILED(hr))
            return hr;

        ULONG cbWritten;
        hr = pStm->Write(&t_struct, sizeof(t_struct), &cbWritten);
        if (hr != S_OK || cbWritten < sizeof(t_struct))
            return E_FAIL;

        if (fClearDirty)
            pt_object->m_fDirty = false;
        return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\parameqp.h ===
//
//
//
#ifndef _ParamEqp_
#define _ParamEqp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS
#define Delay_len  DefineDelayLineSize(8)

class CDirectSoundParamEqDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXParamEq,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundParamEqDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundParamEqDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    HRESULT Init();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
    
    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXParamEq);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXParamEq);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropParamEq, pPages); }

	// IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXParamEq(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXParamEq(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXParamEq); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);
	__forceinline void DoOneSampleMono(int *l);
	void UpdateCoefficients(void);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(float, GainCoefA);
	DECLARE_EAX_VARS(float, GainCoefB);
	DECLARE_EAX_VARS(float, ApA);
	DECLARE_EAX_VARS(float, ApB);
	DECLARE_EAX_VARS(float, Scale);
	DECLARE_EAX_VARS(float, Gain);
	DECLARE_EAX_VARS(float, Center);
	DECLARE_EAX_VARS(float, Bandwidth);
//	DECLARE_EAX_VARS(float, SamplesPerSec);
#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	float		m_StateL, m_StateR;

	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	void Bump(void);

	float			m_delayL1;
	float			m_delayL2;
	float			m_delayR1;
	float			m_delayR2;

// } EAX
};

EXT_STD_CREATE(ParamEq);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\reghlp.h ===
//
//
//
#ifndef _REGHLP_
#define _REGHLP_

STDAPI DMORegisterCpuResources
(
   REFCLSID clsidDMO,
   unsigned long ulCpuResources
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\reghlp.cpp ===
// Copyright (c) 2000 - 2000  Microsoft Corporation.  All Rights Reserved.
//
// reghlp.cpp - registration/enumeration part of DMO runtime
//
#include <windows.h>
#include <tchar.h>
#include <guiddef.h>
#include <ks.h>
#include <strsafe.h>

#define DMO_REGISTRY_HIVE HKEY_CLASSES_ROOT
#define DMO_REGISTRY_PATH TEXT("DirectShow\\MediaObjects")

#define CPU_RESOURCES_STR "SystemResources"

// Automatically calls RegCloseKey when leaving scope
class CAutoCreateHKey {
public:
   CAutoCreateHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey) {
      if (RegCreateKeyEx(hKey,
                         szSubKey,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         MAXIMUM_ALLOWED,
                         NULL,
                         phKey,
                         NULL) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoCreateHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};

class CAutoOpenHKey {
public:
   CAutoOpenHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey, REGSAM samDesired = MAXIMUM_ALLOWED) {
      if (RegOpenKeyEx(hKey,
                       szSubKey,
                       0,
                       samDesired,
                       phKey) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoOpenHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};




/////////////////////////////////////////////////////////////////////////////
//
// DMO Registration code
//

//
// Public entry point
//
STDAPI DMORegisterCpuResources
(
   REFCLSID clsidDMO,
   unsigned long ulCpuResources
) 
{
   TCHAR szSubkeyName[80];
   if (clsidDMO == GUID_NULL)
      return E_INVALIDARG;

   // open the main DMO key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the object specific key underneath the main key
   //DMOGuidToStr(szSubkeyName, clsidDMO); // BUGBUG: redundant
   StringCchPrintf(szSubkeyName,sizeof(szSubkeyName)/sizeof(TCHAR),TEXT("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"),
           clsidDMO.Data1, clsidDMO.Data2, clsidDMO.Data3, clsidDMO.Data4[0], clsidDMO.Data4[1],
           clsidDMO.Data4[2], clsidDMO.Data4[3], clsidDMO.Data4[4], clsidDMO.Data4[5],
           clsidDMO.Data4[6], clsidDMO.Data4[7]);
   
   HKEY hObjectKey;
   CAutoOpenHKey kObject(hMainKey, szSubkeyName, &hObjectKey);
   if (hObjectKey == NULL)
      return E_FAIL;

   // set the default value of the CPU Resources key to the value
   if (RegSetValueEx(hObjectKey, TEXT(CPU_RESOURCES_STR), (DWORD)0, REG_DWORD, (CONST BYTE *)&ulCpuResources, sizeof(DWORD))
        != ERROR_SUCCESS)
      return E_FAIL;
 

   return NOERROR;
}

//
// End registry helper code
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\sources.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!ifndef DXROOT
DXROOT = $(PROJECT_ROOT)\directx
!endif

!include $(DXROOT)\project.mk
!include ..\..\buildmode.inc
	
MAJORCOMP  = windows
MINORCOMP  = directx

TARGETNAME = dsdmo
TARGETPATH = $(_OBJ_DIR)
TARGETTYPE = DYNLINK
UMTYPE     = windows
DLLDEF     = ..\dsdmo.def
DLLENTRY   = _DllMainCRTStartup

USE_MSVCRT = 1
USE_IOSTREAM=1
USE_MAPSYM = 1

!if $(386)
!if !$(FREEBUILD)
MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Od /QIfist
!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif
!else
MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Ox /Ob2 /QIfist
!endif
!endif


# 04/11/2000 - allows for addition of BoundsChecker, etc 
# libs specified in the OS environment

TARGETLIBS = $(TARGETLIBS) \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\dmoguids.lib    \
    $(SDK_LIB_PATH)\shlwapi.lib     \
    $(SDK_LIB_PATH)\msdmo.lib       \
    $(PROJECT_ROOT)\oem\binary_release\creative\I3DL2\*\eaxreverb.lib

# Make sure we pick up the right verinfo.h etc.

INCLUDES = $(PROJECT_INC_PATH);\
           $(DXROOT)\inc;

SOURCES =\
    oledll.cpp      \
    guid.cpp        \
    dsdmobse.cpp    \
    aec.cpp         \
    agc.cpp         \
    chorus.cpp      \
    clone.cpp       \
    compress.cpp    \
    distort.cpp     \
    ns.cpp          \
    parameq.cpp     \
    echo.cpp        \
    flanger.cpp     \
    gargle.cpp      \
    sverbdmo.cpp	\
    sverb.c			\
    dllmain.cpp     \
    common.cpp      \
    propertyhelp.cpp\
    debug.cpp       \
    dsdmo.rc        \
    alist.cpp       \
    kshlp.cpp       \
    reghlp.cpp		\
    param.cpp		\
    dmocom.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\runtime.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       runtime.h
 *  Content:    New versions of C runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  jstokes  Created
 *
 ***************************************************************************/

#ifndef __RUNTIME_H__
#define __RUNTIME_H__


// We have BYTE, WORD and DWORD, but no QWORD?
typedef unsigned __int64 QWORD, *LPQWORD;

// Bounderies of numeric types
#define MAX_CHAR        ((CHAR)0x7F)
#define MIN_CHAR        ((CHAR)-0x7F)

#define MAX_UCHAR       ((UCHAR)0xFF)
#define MIN_UCHAR       ((UCHAR)0)

#define MAX_SHORT       ((SHORT)0x7FFF)
#define MIN_SHORT       ((SHORT)-0x7FFF)

#define MAX_USHORT      ((USHORT)0xFFFF)
#define MIN_USHORT      ((USHORT)0)

#define MAX_INT         ((INT)0x7FFFFFFF)
#define MIN_INT         ((INT)-0x7FFFFFFF)

#define MAX_UINT        ((UINT)0xFFFFFFFF)
#define MIN_UINT        ((UINT)0)

#define MAX_LONG        MAX_INT
#define MIN_LONG        MIN_INT

#define MAX_ULONG       MAX_UINT
#define MIN_ULONG       MIN_UINT

#define MAX_INT64       ((INT64)0x7FFFFFFFFFFFFFFF)
#define MIN_INT64       ((INT64)-0x7FFFFFFFFFFFFFFF)

#define MAX_UINT64      ((UINT64)0xFFFFFFFFFFFFFFFF)
#define MIN_UINT64      ((UINT64)0)

#define MAX_LONGLONG    MAX_INT64
#define MIN_LONGLONG    MIN_INT64

#define MAX_ULONGLONG   MAX_UINT64
#define MIN_ULONGLONG   MIN_UINT64

#define MAX_BYTE        MAX_UCHAR
#define MIN_BYTE        MIN_UCHAR

#define MAX_WORD        MAX_USHORT
#define MIN_WORD        MIN_USHORT

#define MAX_DWORD       MAX_ULONG
#define MIN_DWORD       MIN_ULONG

#define MAX_QWORD       MAX_UINT64
#define MIN_QWORD       MIN_UINT64

#define NUMERIC_CAST(val, type) \
            ((type)min(MAX_##type, max(MIN_##type, val)))

// Sundown
#ifdef WIN64

#pragma warning(disable:4311)   // type cast truncation

#ifndef __midl

__inline unsigned long PtrDiffToUlong(__int64 n64)
{
    return((unsigned long)n64);
}

__inline long PtrDiffToLong(__int64 n64)
{
    return((long)n64);
}

__inline int PtrDiffToInt(__int64 n64)
{
    return((int)n64);
}

#endif // __midl

#pragma warning(3:4311)   // type cast truncation

#else // WIN64

#define PtrDiffToUlong(n64) \
            ((unsigned long)(n64))

#define PtrDiffToLong(n64) \
            ((long)(n64))

#define PtrDiffToInt(n64) \
            ((int)(n64))

#endif // WIN64


#endif // __RUNTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\sverb.h ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/****************************************************************************
Const defines :
*****************************************************************************/
#define FPU_DENORM_OFFS (float)1.0E-30

#define BASE_REV_DELAY  0x4000
#define BASE_DSPS_DELAY 0x800

#define DSPS_MASK   0x7ff
#define REV_MASK    0x3fff

/****************************************************************************
Coefs Struct :
*****************************************************************************/
typedef struct
{

	long mySize;
	long myVersion;
	float SampleRate;

	float directGain; 
	long  l_directGain; 
	float revGain; 
	long l_revGain; 

	long lDelay1;
	long lDelay2;
	long lDelay3;
	long lDelay4;

	long lDDly1; 
	long lDDly2; 

	float dDsps;
	long l_dDsps;

	float dDG1;
	long l_dDG1;

	float dDG2; 
	long l_dDG2; 

	float dFB11;
	long l_dFB11;
	float dFB12;
	long l_dFB12;
	float dFB21;
	long l_dFB21;
	float dFB22;
	long l_dFB22;
	float dFB31;
	long l_dFB31;
	float dFB32;
	long l_dFB32;
	float dFB41;
	long l_dFB41;
	float dFB42;
	long l_dFB42;

	float dDamp;
	long l_dDamp;


} sCoefsStruct;

/****************************************************************************
Initialization and control functions :
*****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_16 (float)((unsigned long)0x00008000)

void InitSVerbStates( long *pStates );
long DToF32( float dbl  );
void ConvertCoefsToFix( void *pC );
void InitSVerb( float SampleRate, void  *pCoefs);
void SetSVerb( float InGain, float dRevMix,  float dRevTime, 
			    float dHighFreqRTRatio, void  *pCoefs );



long GetCoefsSize(void);
long GetStatesSize(void);
long GetSVerbVersion(void);

float VerifySampleRate(void  *pCoefs);
long VerifyVersion(void  *pCoefs);
long VerifySize(void  *pCoefs);


#define CLIP_SHORT_TO_SHORT(x)\
			if (x>32767)\
				x = 32767;\
			else if (x<-32768)\
				x = -32768;

/****************************************************************************
//Process Functions :
*****************************************************************************/

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR );
__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR );

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\sverb.c ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/***********************************************************
General description :

The functions in this file provides for any apoplication to process audio data
with the SVerb algorithm.

In order to do so the application should :

1. Allocate two chunks of memory for 'Coefs' and 'States' with sizes as returned 
   by the functions 'GetCoefsSize' and 'GetStatesSize' accordingly.
   
2. Initialize these memory chunks using the functions : 'InitSVerb' and 'InitSVerbStates' 
   accordingly.

3. Change the settings of the SVerb sound using the function 'SetSVerb'.

4. Call one of the process functions according to the input/output data format:

   SVerbMonoToMonoShort 
   SVerbMonoToStereoShort
   SVerbStereoToStereoShort 
   SVerbMonoToMonoFloat
   SVerbMonoToStereoFloat
   SVerbStereoToStereoFloat

   The input/output are always the same data type (i.e. both input and output are short integer
   or both are 32bits floats).

   Stereo data format is always'interlaced' left,right samples.

   The 'coefs' and 'states' memory should be passed to the process functions.
   
5. Many coefs structures can be initialized each for different SVerb settings. Passing a different
   coefs structure will cause a real time change of sound quality.

   As long as sound continuity should be maintained the states structure should not be changes or
   re-initialized. Only when a completly new audio sequence is desired should the states be re-initialized.

6. Note that the coefs are valid per sampling rate.

7. Althaugh provisions for coefs compatibility for future versions are provided, it should be avoided to save coefs
   structures to files as-is and re-use them later. Rather the application should save the 'real-world'
   settings of the reverb - namely the parameters passed to 'SetSVerb'. These 'real-world' settings 
   will always be valid for future versions, as well as if other sampling rates are used. The coefs 
   structur(es) should be re-initialized in run time using the real-world settings and call to 
   'SetSverb'.


************************************************************/

#include <windows.h>
#include <String.h>
#include <math.h>
#include "SVerb.h"

#pragma optimize( "ty", on )

/****************************************************************************

Function Name	: GetCoefsSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold coefficients.

Description		:  

This function must be called before any calls to other functions that uses the coefs structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerb()'
and 'SetSVerb()'.

The caller should not be botherred by the internals of the coefs structure, rather only konw it's size 
and than allocate enough memory to hold it.

The structure allocated can be used in a very flexible way in order to allow for real-time, pre-computed
changes in Reverb Sound. 

*****************************************************************************/

long GetCoefsSize(void) 
{
	return sizeof(sCoefsStruct); 
};

/****************************************************************************

Function Name	: GetStatesSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold states.

Description		:  

This function must be called before any calls to other functions that uses the states structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerbStates()'.

The states allocated are valid in run-time only, and sould be re-initialized only when a complete
new input is to be processed by the SVerb. 

When changing the settings of revevreb in real time while audio is playing, the states should not 
be re-initialized, rather the same passed states must be passed to the process functions in order 
to maintain sound continuity.

*****************************************************************************/

long GetStatesSize(void) 
{
	return sizeof(long)*(BASE_REV_DELAY+2*BASE_DSPS_DELAY+2); 
};

/****************************************************************************

Function Name	: GetSVerbVersion

Input Arguments : None

Return Value    : Version of SVerb implementation - for future compatibility.

Description		:  

Since the caller do not know about the internals of the coefs structure, this function,
together with 'VerifyVersion' function provides a way to verify if a coefs structure
match the version of the reverb used.

This should be needed only if one is using a coefs structure that was saved to file, and 
being used later.

NOTE : In normal operation, this way of usage should be avoided... and only real-world reverb
settings should be saved to files, and re-initialize the coefs in run time.

*****************************************************************************/

long GetSVerbVersion(void) 
{
	return 0x1; 
};

/****************************************************************************

Function Name	: VerifySampleRate

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The sample rate for which this coefs are valid.

Description		:  

When an application uses different sampling rates, and re-uses same coefs structures, 
it should verify that the coefs match the audio sampling rate.

*****************************************************************************/

float VerifySampleRate(void *pC) {
	return ((sCoefsStruct *)pC)->SampleRate; 
};

/****************************************************************************

Function Name	: VerifyVersion

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The version of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's version.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifyVersion(void *pC) {
	return ((sCoefsStruct *)pC)->myVersion; 
};

/****************************************************************************

Function Name	: VerifySize

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The size of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's size.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifySize(void *pC) {
	return ((sCoefsStruct *)pC)->mySize; 
};


/****************************************************************************

Function Name	: InitSVerbStates

Input Arguments : 

 float *pStates	: The pointer to the states memory.

Return Value    : none.

Description		:  

After allocating memory for the states, according to thge size returned by 'GetStatesSize'
The application MUST initialize the states using this function. 
Note : in future versions this may be more complex than simply memset to 0...
*****************************************************************************/

void InitSVerbStates( long *pStates )
{
    memset( pStates, 0, GetStatesSize() ) ;
}

/****************************************************************************

Function Name	: DToF16

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

Converts a float number between -1.0 .. 1.0 to a 16bits integer 
fixed point representation.
This allows for fix point arithmetics, where two 16bits integers are multiplied to 
a 32bits integer, and we than take the upper 16 bits of the result.

*****************************************************************************/

long DToF16( float dbl  )
{
	dbl *= MAX_16;
	dbl = max(-MAX_16,min(MAX_16-(float)1.0,dbl+(float)0.5));
	return (long)(dbl);
}

/****************************************************************************

Function Name	: ConvertCoefsToFix

Input Arguments : 

 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  converts coefficients to longs, as fixed point numbers

*****************************************************************************/


void ConvertCoefsToFix( void *pC )
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

//		float directGain; 

	pCoefs->l_directGain =  DToF16(pCoefs->directGain);

//		float revGain; 
	pCoefs->l_revGain =  DToF16(pCoefs->revGain);
//		float dDsps;
	pCoefs->l_dDsps =  DToF16(pCoefs->dDsps);
//		float dDG1;
	pCoefs->l_dDG1 =  DToF16(pCoefs->dDG1);
//		float dDG2; 
	pCoefs->l_dDG2 =  DToF16(pCoefs->dDG2);
//	float dFB11;
	pCoefs->l_dFB11 =  DToF16(pCoefs->dFB11);
//		float dFB12;
	pCoefs->l_dFB12 =  DToF16(pCoefs->dFB12);
//		float dFB21;
	pCoefs->l_dFB21 =  DToF16(pCoefs->dFB21);
//		float dFB22;
	pCoefs->l_dFB22 =  DToF16(pCoefs->dFB22);
//		float dFB31;
	pCoefs->l_dFB31 =  DToF16(pCoefs->dFB31);
//		float dFB32;
	pCoefs->l_dFB32 =  DToF16(pCoefs->dFB32);
//		float dFB41;
	pCoefs->l_dFB41 =  DToF16(pCoefs->dFB41);
//		float dFB42;
	pCoefs->l_dFB42 =  DToF16(pCoefs->dFB42);
//		float dDamp;
	pCoefs->l_dDamp =  DToF16(pCoefs->dDamp);



}

/****************************************************************************

Function Name	: InitSVerb

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

After allocating memory for the coefs, according to thge size returned by 'GetCoefsSize'
The application MUST initialize the coefs using this function. 
The initialization takes the sampling rate as an argument, ans thus is valid per this
sampling rate only.

It is possible to find out what is the sampling rate a coefs structure is valid for by calling 
the function 'VerifySampleRate'.

This function initialises the SVerb to so reasonable default setting by calling 'SetSVerb' with
the following real-world settings :

InGain				= -3.0dB   (to avoid output overflows)
dRevMix				= -6.0dB   (a reasonable reverb mix)
dRevTime			= 1000.0ms (one second global reverb time)
dHighFreqRTRatio	= 0.001    (the ratio of the high frequencies to the global reverb time) 

*****************************************************************************/

void InitSVerb( float SampleRate, void *pC)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
 	//Magic numbers ...
    long lRefD;
	
	float dRatio =  (float)1.189207115003;
	
	float dD2MRatio = (float)0.2309333333;

	pCoefs->mySize = sizeof(sCoefsStruct);
	pCoefs->myVersion = 0x1;

	pCoefs->dDsps =  (float)0.6180339887499;

	pCoefs->SampleRate = SampleRate;

    lRefD = (long)( 0.5 + 0.045 * pCoefs->SampleRate ) ;

	pCoefs->lDelay1 = lRefD;
	pCoefs->lDelay3 = (long)(0.5 + dRatio * (float)pCoefs->lDelay1);
	pCoefs->lDelay2 = (long)(0.5 + dRatio * (float)pCoefs->lDelay3);
	pCoefs->lDelay4 = (long)(0.5 + dRatio * (float)pCoefs->lDelay2);
  
    pCoefs->lDDly1 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay1+pCoefs->lDelay2));
	pCoefs->lDDly2 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay3+pCoefs->lDelay4));

    pCoefs->lDelay1 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay2 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay3 -= pCoefs->lDDly2 ;    
    pCoefs->lDelay4 -= pCoefs->lDDly2 ;        

    pCoefs->lDelay1 <<= 2;    
    pCoefs->lDelay2 <<= 2;    
    pCoefs->lDelay3 <<= 2;    
    pCoefs->lDelay4 <<= 2;        

	pCoefs->lDDly1 <<= 1;
	pCoefs->lDDly2 <<= 1;

	SetSVerb( (float)0.0, (float)-10.0, (float)1000.0, (float)0.001, pC );

}

/****************************************************************************

Function Name	: SetSVerb

Input Arguments : 

InGain				: input gain in dB (to avoid output overflows)

dRevMix				: Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                      Negative values gives less wet signal.
					  The coeficients are calculated so that the overall output level stays 
					  (approximately) constant regardless of the ammount of reverb mix.
dRevTime			: The global reverb time (decay time) in milliseconds.

dHighFreqRTRatio	: The ratio of the high frequencies to the global reverb time. 
					  Unless very 'splashy-bright' reverbs are wanted, this should be set to 
					  a value < 1.0.
					  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
					  decay time for high frequencies will be 100ms.

void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

This function accepts the 'real world' settings or SVerb and computes the corresponding 
coefs structure.

The coefs pointer passed to it MUST have been initialized first by InitSVerb.

In normal uses one coefs structure is allocated, initialized, and than as the user changes 
SVerb settings this function should be called repeatedly with the same coefs pointer and the 
new 'real world' settings. 

And the coefs structure passed to the process function in the next buffer to process.

Also few coefs structures can be pre allocated, and initialized, and than different 'presets' 
can be pre-computed into each of them, and switched in real time. 

The coefs structures should not be saved to files by the application for future uses, rather 
the 'real world' settings them selvs. This way future compatibility is guaranteed.

*****************************************************************************/

void SetSVerb( float InGain, float dRevMix, 
			   float dRevTime, float dHighFreqRTRatio, void *pC )
{


	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

    float dD,dTmp,dInGain,dRevGain;

	float dHfR;
    float dAPS;

    if (dHighFreqRTRatio > (float) 0.999)
    {
        dHighFreqRTRatio = (float) 0.999;
    }
    if (dHighFreqRTRatio <= (float) 0.0)
    {
        dHighFreqRTRatio = (float) 0.001;
    }
    dHfR = ( (float)1.0/dHighFreqRTRatio - (float)1.0);

    if (dRevTime < (float) 0.001) 
    {
        dRevTime = (float) 0.001;
    }

    if (InGain > (float) 0.0)
    {
        InGain = (float) 0.0;
    }

    if (dRevMix > (float) 0.0)
    {
        dRevMix = (float) 0.0;
    }

    if (pCoefs->SampleRate < (float) 1.0) 
    {
        pCoefs->SampleRate = (float) 22050.0;
    }

    dAPS = (float)(-3000.0) / (pCoefs->SampleRate * dRevTime);


    pCoefs->dDamp = 0.0;

 	pCoefs->dDG1 = (float)pow((float)10.0,(float)(pCoefs->lDDly1>>1)*dAPS);
 	pCoefs->dDG2 = (float)pow((float)10.0,(float)(pCoefs->lDDly2>>1)*dAPS);

	//////////////////////////////

		pCoefs->dFB11 = (float)pow((float)10.0,(float)(pCoefs->lDelay1>>2)*dAPS);
        
		dD = pCoefs->dFB11 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay1>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB12 = pCoefs->dFB11 * dTmp;
		pCoefs->dFB11 *= ((float)1.0-dTmp);

	///////////////////////////////

		pCoefs->dFB21 = (float)pow((float)10.0,(float)(pCoefs->lDelay2>>2)*dAPS);
        
		dD = pCoefs->dFB21 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay2>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB22 = pCoefs->dFB21 * dTmp;
		pCoefs->dFB21 *= ((float)1.0-dTmp);

	////////////////////////////////

		pCoefs->dFB31 = (float)pow((float)10.0,(float)(pCoefs->lDelay3>>2)*dAPS);
        
		dD = pCoefs->dFB31 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
		    pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay3>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB32 = pCoefs->dFB31 * dTmp;
		pCoefs->dFB31 *= ((float)1.0-dTmp);


	//////////////////////////////

		pCoefs->dFB41 = (float)pow((float)10.0,(float)(pCoefs->lDelay4>>2)*dAPS);

        dD = pCoefs->dFB41 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay4>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB42 = pCoefs->dFB41 * dTmp;
		pCoefs->dFB41 *= ((float)1.0-dTmp);


    pCoefs->dDamp = (float)sqrt(pCoefs->dDamp);

 	dInGain = (float)pow((float)10.0, (float)0.05*InGain ) ;
	dRevMix = (float)pow((float)10.0,(float)0.1*dRevMix);

	dRevGain = (float)4.0 / pCoefs->dDamp * dInGain;

	//in the DSP we used -  	 
	

	pCoefs->directGain = dInGain * (float)sqrt((float)1.0-dRevMix);
	pCoefs->revGain = dRevGain * (float)sqrt(dRevMix);

	ConvertCoefsToFix( pC );

}

///////////////////////////////////////////////////////////////////////////////////////
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/* Process functions */
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/

/**********************************************************************************

Bellow are 6 different process functions.
The difference between the functions is only in the input/output data formats.

3 functions support short samples input/output.
3 other functions support float samples input/output.

Per each of the data types there are 3 functions :

  Mono-Mono
  Mono-Stereo
  Stereo-Stereo

The names of the functions are clear to which format they apply.

Stereo data is always interlaced left,right samples.

All process functions have basically the same format namely :

  SVerbXXXXXX(long NumInFrames, short *pInShort, short *pOutShort, 
			  void *pC, float *pStates)

Input arguments :

long NumInFrames	: Number of input frames
short *pInXXX		: Pointer to input buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.
short *pOutXXX		: Pointer to output buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.

void *pC			: The coefs structure allocated and initialized as explained above.
float *pStates		: The states structure allocated and initialized as explained above.

*******************************************************************************************/

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						  void *pC, long *pStates)
{

	sCoefsStruct *pCoefs =  ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (long)(*pInShort++)>>1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			Out1 += Out2;
			CLIP_SHORT_TO_SHORT(Out1)

			*pOutShort++ = (short)(Out1);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS
void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						    void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In1 += (In1>>1) - (In1>>2);
			In2 = In1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}
#endif

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						      void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In2 = (long)(*pInShort++);

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						  void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.5 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1+Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						    void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.7071 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						      void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (*pInFloat++) + FPU_DENORM_OFFS;
			In2 = (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR )
{
	float outL, outR;
	float *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = dDG1 * (*pDlyOut++) + *inR * dDsps;
	outR = dDG1 * (*pDlyOut) - *inL * dDsps ;

    // here we feed back the output.
	*pDly++ = *inL + dDsps * outR ;
	*pDly = *inR - dDsps * outL ;

	*inL = outL;
	*inR = outR;

}
#endif

__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR )
{
	long outL, outR;
	long *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = (dDG1 * (*pDlyOut++) + *inR * dDsps)>>15;

	outR = (dDG1 * (*pDlyOut) - *inL * dDsps)>>15;

    // here we feed back the output.
	*pDly++ = *inL + ((dDsps * outR)>>15) ;

	*pDly = *inR - ((dDsps * outL)>>15) ;

	*inL = outL;
	*inR = outR;

}
#pragma optimize( "ty", off )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\sverbdmo.cpp ===
#include <windows.h>

#include "sverb.h"
#include "sverbp.h"
#include "clone.h"

STD_CREATE(WavesReverb)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundWavesReverbDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXWavesReverb)
    {
        return GetInterface((IDirectSoundFXWavesReverb*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::Clone
//
STDMETHODIMP CDirectSoundWavesReverbDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundWavesReverbDMO, DSFXWavesReverb>(this, pp);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::CDirectSoundWavesReverbDMO
//
CDirectSoundWavesReverbDMO::CDirectSoundWavesReverbDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ), 
    m_fDirty(TRUE),
    m_pbCoeffs(NULL),
    m_plStates(NULL),
    m_fInitCPCMDMO(false),
    m_pfnSVerbProcess(NULL),
    m_fGain(DSFX_WAVESREVERB_INGAIN_DEFAULT),
    m_fMix(DSFX_WAVESREVERB_REVERBMIX_DEFAULT),
    m_fTime(DSFX_WAVESREVERB_REVERBTIME_DEFAULT),
    m_fRatio(DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT)
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::~CDirectSoundWavesReverbDMO
//
CDirectSoundWavesReverbDMO::~CDirectSoundWavesReverbDMO() 
{
    delete[] m_pbCoeffs;
    delete[] m_plStates;

}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                                    max,                                    neutral,                                    unit text,  label,              pwchText
    SVP_Gain,       MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_INGAIN_MIN,            DSFX_WAVESREVERB_INGAIN_MAX,            DSFX_WAVESREVERB_INGAIN_DEFAULT,            L"dB",      L"InGain",          L"",
    SVP_Mix,        MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_REVERBMIX_MIN,         DSFX_WAVESREVERB_REVERBMIX_MAX,         DSFX_WAVESREVERB_REVERBMIX_DEFAULT,         L"dB",      L"ReverbMix",       L"",
    SVP_ReverbTime, MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_REVERBTIME_MIN,        DSFX_WAVESREVERB_REVERBTIME_MAX,        DSFX_WAVESREVERB_REVERBTIME_DEFAULT,        L"ms",      L"ReverbTime",      L"",
    SVP_Ratio,      MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN,   DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX,   DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT,   L"",        L"HighFreqRTRatio", L"",
};

HRESULT CDirectSoundWavesReverbDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundWavesReverbDMO::Init()
{
    HRESULT hr = S_OK;
    

    DMO_MEDIA_TYPE *pmt = InputType();
    
    if (pmt->majortype != MEDIATYPE_Audio || 
        pmt->subtype != MEDIASUBTYPE_PCM ||
        pmt->formattype != FORMAT_WaveFormatEx)
    {
        hr = E_INVALIDARG;
        TraceI(1,"ERROR: Invalid Format specified during SetInputType()\n");
    }

    WAVEFORMATEX *pwfex = (WAVEFORMATEX*)pmt->pbFormat;

    if (SUCCEEDED(hr))
    {
        if (pwfex->wFormatTag != WAVE_FORMAT_PCM ||
            pwfex->wBitsPerSample != 16)
        {
            hr = E_INVALIDARG;
            TraceI(1,"ERROR: Invalid Format specified during SetInputType()\n");
        }
    }

    if (SUCCEEDED(hr))
    {
        switch (pwfex->nChannels)
        {
            case 1:
                m_pfnSVerbProcess = SVerbMonoToMonoShort;
                break;

            case 2:
                m_pfnSVerbProcess = SVerbStereoToStereoShort;
                break;

            default:
                hr = E_FAIL;
                TraceI(1,"ERROR: Waves Reverb only supports mono or stereo\n");
        }
    }

    // Formats have been set. Initialize the reverb.
    //
    m_pbCoeffs = new BYTE[GetCoefsSize()];
    m_plStates = new long[(GetStatesSize() + sizeof(long) - 1)/ sizeof(long)];

    if (m_pbCoeffs == NULL || m_plStates == NULL)
    {
        hr = E_OUTOFMEMORY;
        TraceI(1,"ERROR: Out of memory\n");
    }

    if (SUCCEEDED(hr))
    {
        memset(m_plStates, 0, GetStatesSize());
        InitSVerb((float)m_ulSamplingRate, m_pbCoeffs);
        InitSVerbStates(m_plStates);
        m_fInitCPCMDMO = true;
    }

    Discontinuity();
    return hr;
}

HRESULT CDirectSoundWavesReverbDMO::Discontinuity() 
{
    HRESULT hr;
    DSFXWavesReverb wavesreverb;
    
    if (m_pbCoeffs && m_plStates)
    {
        memset(m_plStates, 0, GetStatesSize());
        InitSVerb((float)m_ulSamplingRate, m_pbCoeffs);
        InitSVerbStates(m_plStates);
    }

    hr = GetAllParameters(&wavesreverb);

    if (SUCCEEDED(hr)) 
    {   
        hr = SetAllParameters(&wavesreverb);
    }

    if (SUCCEEDED(hr)) 
    {
        UpdateCoefficients();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::FBRProcess
//
HRESULT CDirectSoundWavesReverbDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
    assert(m_pfnSVerbProcess);
    
    (*m_pfnSVerbProcess)(
        cSamples, 
        (short*)pIn, 
        (short*)pOut,    
        m_pbCoeffs,
        m_plStates);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::ProcessInPlace
//
HRESULT CDirectSoundWavesReverbDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    if (this->GetActiveParamBits())
    {
        this->UpdateActiveParams(rtStart, *this);
        this->UpdateCoefficients();
    }

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::SetParam
//
STDMETHODIMP CDirectSoundWavesReverbDMO::SetParam(DWORD dwParamIndex,MP_DATA value)
{
    HRESULT hr = SetParamInternal(dwParamIndex, value, false);
    if (SUCCEEDED(hr))
        this->UpdateCoefficients();
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::SetParamInternal
//
HRESULT CDirectSoundWavesReverbDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    switch (dwParamIndex)
    {
    case SVP_Gain:
        CHECK_PARAM(DSFX_WAVESREVERB_INGAIN_MIN, DSFX_WAVESREVERB_INGAIN_MAX);
        m_fGain = value;
        break;

    case SVP_Mix:
        CHECK_PARAM(DSFX_WAVESREVERB_REVERBMIX_MIN,DSFX_WAVESREVERB_REVERBMIX_MAX);
        m_fMix = value;
        break;

    case SVP_ReverbTime:
        CHECK_PARAM(DSFX_WAVESREVERB_REVERBTIME_MIN,DSFX_WAVESREVERB_REVERBTIME_MAX);
        m_fTime = value;
        break;
    
    case SVP_Ratio:
        CHECK_PARAM(DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN,DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX);
        m_fRatio = value;
        break;

    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls
    //
    HRESULT hr = fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
    return hr;
}

void CDirectSoundWavesReverbDMO::UpdateCoefficients()
{
    // Waves Reverb has a single SetSVerb call that updates all parameters simultaneously instead of internal
    // state variables that are updated incrementally by changes to individual parameters as the other DMOs do.
    if (m_fInitCPCMDMO)
    {
        SetSVerb(
            m_fGain,
            m_fMix,
            m_fTime,
            m_fRatio,
            m_pbCoeffs);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundWavesReverbDMO::SetAllParameters(THIS_ LPCDSFXWavesReverb pwr)
{
    HRESULT hr = S_OK;
    
    // Check that the pointer is not NULL
    if (pwr == NULL)
    {
        TraceI(1,"ERROR: pwr is NULL\n");
        hr = E_POINTER;
    }

    // Set the parameters
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_Gain, pwr->fInGain, false);
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_Mix, pwr->fReverbMix, false);
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_ReverbTime, pwr->fReverbTime, false);
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_Ratio, pwr->fHighFreqRTRatio, false);
    this->UpdateCoefficients();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::GetAllParameters
//
HRESULT CDirectSoundWavesReverbDMO::GetAllParameters(THIS_ LPDSFXWavesReverb pwr)
{
    HRESULT hr = S_OK;
    MP_DATA mpd;

    if (pwr == NULL) return E_POINTER;
    
#define GET_PARAM(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pwr->y = mpd; \
    }

#define GET_PARAM_LONG(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pwr->y = (long)mpd; \
    }
    
    GET_PARAM(SVP_Gain, fInGain);
    GET_PARAM(SVP_Mix, fReverbMix);
    GET_PARAM(SVP_ReverbTime, fReverbTime);
    GET_PARAM(SVP_Ratio, fHighFreqRTRatio);

    return S_OK;
}

HRESULT CDirectSoundWavesReverbDMO::CheckInputType(const DMO_MEDIA_TYPE *pmt)
{
   if (NULL == pmt) {
      return E_POINTER;
   }

   // Verify that this is PCM with a WAVEFORMATEX format specifier
   if ((pmt->majortype  != MEDIATYPE_Audio) ||
       (pmt->subtype    != MEDIASUBTYPE_PCM) ||
       (pmt->formattype != FORMAT_WaveFormatEx) ||
       (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
       (pmt->pbFormat == NULL))
      return DMO_E_TYPE_NOT_ACCEPTED;

   // Verify the wave format
   WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
   if (pWave->wFormatTag != WAVE_FORMAT_PCM ||
       pWave->wBitsPerSample != 16 ||
       pWave->nChannels != 1 && pWave->nChannels != 2)
   {
       return DMO_E_TYPE_NOT_ACCEPTED;
   }
   return NOERROR;
 }

 // GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundWavesReverbDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_WAVES_REVERB;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\sverbp.h ===
//
//
//
#ifndef _DirectSoundSVerb_p_
#define _DirectSoundSVerb_p_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundWavesReverbDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXWavesReverb,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundWavesReverbDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundWavesReverbDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the  CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
    
        
    STDMETHOD(SetAllParameters)          (THIS_ LPCDSFXWavesReverb p);        
    STDMETHOD(GetAllParameters)          (THIS_ LPDSFXWavesReverb p);        
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropWavesReverb, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) 
    { return m_fDirty ? S_OK : S_FALSE; }
    
    STDMETHOD(Load)(IStream *pStm) 
    { return PropertyHelp::Load(this, DSFXWavesReverb(), pStm); }
    
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) 
    { return PropertyHelp::Save(this, DSFXWavesReverb(), pStm, fClearDirty); }
    
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) 
    { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXWavesReverb); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value);
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();

    // Called whenever a parameter has changed to recalculate the effect coefficients based on the cached parameter values.
    void UpdateCoefficients();

    bool                m_fDirty;

private:
    bool                m_fInitCPCMDMO;
    
    // cached parameter values
    MP_DATA m_fGain;
    MP_DATA m_fMix;
    MP_DATA m_fTime;
    MP_DATA m_fRatio;

    void (*m_pfnSVerbProcess)(long, short*, short*, void*, long*);
    
    // Internal SVerb state
    //
    BYTE               *m_pbCoeffs;
    long               *m_plStates;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
};

EXT_STD_CREATE(WavesReverb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmo\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;                       

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//
#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}



#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\controlhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSliderValue.
//

#pragma once

class Handler
{
public:
    virtual LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) = 0;
};

class CSliderValue
  : public Handler
{
public:
    CSliderValue();
    void Init(HWND hwndSlider, HWND hwndEdit, float fMin, float fMax, bool fDiscrete);

    void SetValue(float fPos);
    float GetValue();

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    bool                m_fInit;
    HWND                m_hwndSlider;
    HWND                m_hwndEdit;
    float               m_fMin;
    float               m_fMax;
    bool                m_fDiscrete;

private:
    float GetSliderValue();
    void UpdateEditBox(float fPos);
    void UpdateSlider();
};

class CRadioChoice
  : public Handler
{
public:
    struct ButtonEntry
    {
        int nIDDlgItem;
        LONG lValue;
    };

    // Create passing a ButtonEntry array terminated by an entry with nIDDlgItem of 0.
    CRadioChoice(const ButtonEntry *pButtonInfo);

    void SetChoice(HWND hDlg, LONG lValue);
    LONG GetChoice(HWND hDlg);

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    const ButtonEntry *m_pButtonInfo;
};

// MessageHandlerChain is a helper for implementing the property page message handler.
// It takes a NULL-terminated array of Message pointers (could be CSliderValue or CRadioChoice)
// and calls them in order until one of them sets bHandled.

LRESULT MessageHandlerChain(Handler **ppHandlers, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxchoruspage.cpp ===
// DirectSoundFXChorusPage.cpp : Implementation of CDirectSoundFXChorusPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXChorusPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXChorusPage

const CRadioChoice::ButtonEntry g_rgWaveButtons[] =
    {
        IDC_RADIO_TRIANGLE, DSFXCHORUS_WAVE_TRIANGLE,
        IDC_RADIO_SIN, DSFXCHORUS_WAVE_SIN,
        0
    };

CDirectSoundFXChorusPage::CDirectSoundFXChorusPage()
  : m_radioWaveform(g_rgWaveButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXChorusPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXChorusPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXChorusPage;

    m_rgpHandlers[0] = &m_sliderWetDryMix;
    m_rgpHandlers[1] = &m_sliderDepth;
    m_rgpHandlers[2] = &m_sliderFeedback;
    m_rgpHandlers[3] = &m_sliderFrequency;
    m_rgpHandlers[4] = &m_sliderDelay;
    m_rgpHandlers[5] = &m_sliderPhase;
    m_rgpHandlers[6] = &m_radioWaveform;
    m_rgpHandlers[7] = NULL;
}

STDMETHODIMP CDirectSoundFXChorusPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXChorus, reinterpret_cast<void**>(&m_IDSFXChorus));
    return hr;
}

STDMETHODIMP CDirectSoundFXChorusPage::Apply(void)
{
    if (!m_IDSFXChorus)
        return E_UNEXPECTED;

    DSFXChorus dsfxchorus;
    ZeroMemory(&dsfxchorus, sizeof(DSFXChorus));

    dsfxchorus.fWetDryMix = m_sliderWetDryMix.GetValue();
    dsfxchorus.fDepth = m_sliderDepth.GetValue();
    dsfxchorus.fFeedback = m_sliderFeedback.GetValue();
    dsfxchorus.fFrequency = m_sliderFrequency.GetValue();
    dsfxchorus.fDelay = m_sliderDelay.GetValue();
    dsfxchorus.lPhase = static_cast<short>(m_sliderPhase.GetValue());
    dsfxchorus.lWaveform = m_radioWaveform.GetChoice(*this);

    HRESULT hr = m_IDSFXChorus->SetAllParameters(&dsfxchorus);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXChorusPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXChorus)
        return 1;

    DSFXChorus dsfxchorus;
    ZeroMemory(&dsfxchorus, sizeof(DSFXChorus));
    m_IDSFXChorus->GetAllParameters(&dsfxchorus);

    m_sliderWetDryMix.Init(GetDlgItem(IDC_SLIDER_WetDryMix), GetDlgItem(IDC_EDIT_WetDryMix), 0, 100, false);
    m_sliderWetDryMix.SetValue(dsfxchorus.fWetDryMix);

    m_sliderDepth.Init(GetDlgItem(IDC_SLIDER_Depth), GetDlgItem(IDC_EDIT_Depth), 0, 100, false);
    m_sliderDepth.SetValue(dsfxchorus.fDepth);

    m_sliderFeedback.Init(GetDlgItem(IDC_SLIDER_Feedback), GetDlgItem(IDC_EDIT_Feedback), -99, 99, false);
    m_sliderFeedback.SetValue(dsfxchorus.fFeedback);

    m_sliderFrequency.Init(GetDlgItem(IDC_SLIDER_Frequency), GetDlgItem(IDC_EDIT_Frequency), 0, 10, false);
    m_sliderFrequency.SetValue(dsfxchorus.fFrequency);

    m_sliderDelay.Init(GetDlgItem(IDC_SLIDER_Delay), GetDlgItem(IDC_EDIT_Delay), 0, 20, false);
    m_sliderDelay.SetValue(dsfxchorus.fDelay);

    m_sliderPhase.Init(GetDlgItem(IDC_SLIDER_Phase), GetDlgItem(IDC_EDIT_Phase), 0, 4, true);
    m_sliderPhase.SetValue(static_cast<float>(dsfxchorus.lPhase));

    m_radioWaveform.SetChoice(*this, dsfxchorus.lWaveform);

    return 1;
}

LRESULT CDirectSoundFXChorusPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxchoruspage.h ===
// DirectSoundFXChorusPage.h : Declaration of the CDirectSoundFXChorusPage

#ifndef __DIRECTSOUNDFXCHORUSPAGE_H_
#define __DIRECTSOUNDFXCHORUSPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXChorusPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXChorusPage
class ATL_NO_VTABLE CDirectSoundFXChorusPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXChorusPage, &CLSID_DirectSoundFXChorusPage>,
    public IPropertyPageImpl<CDirectSoundFXChorusPage>,
    public CDialogImpl<CDirectSoundFXChorusPage>
{
public:
    CDirectSoundFXChorusPage();

    enum {IDD = IDD_DIRECTSOUNDFXCHORUSPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXCHORUSPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXChorusPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXChorusPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXChorusPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXChorus> m_IDSFXChorus;
    CSliderValue m_sliderWetDryMix;
    CSliderValue m_sliderDepth;
    CSliderValue m_sliderFeedback;
    CSliderValue m_sliderFrequency;
    CSliderValue m_sliderDelay;
    CSliderValue m_sliderPhase;
    CRadioChoice m_radioWaveform;
    Handler *m_rgpHandlers[8];
};

#endif //__DIRECTSOUNDFXCHORUSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\controlhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSliderValue.
//

#include "stdafx.h"
#include "ControlHelp.h"
#include <commctrl.h>
#include <stdio.h>
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

const short g_sMaxContinuousTicks = 100;
const int g_iMaxCharBuffer = 50; // # characters big enough to hold -FLT_MAX with room to spare

CSliderValue::CSliderValue()
  : m_fInit(false)
{
}

void CSliderValue::Init(
        HWND        hwndSlider,
        HWND        hwndEdit,
        float       fMin, 
        float       fMax, 
        bool        fDiscrete)
{
    m_hwndSlider = hwndSlider;
    m_hwndEdit = hwndEdit;
    m_fMin = fMin;
    m_fMax = fMax;
    m_fDiscrete = fDiscrete;

    short sMin;
    short sMax;
    short sTicks = 4; // Lots of ticks become less useful as guides.  Use quarters for fine-grained sliders.
    if (m_fDiscrete) 
    {
        sMin = static_cast<short>(fMin);
        sMax = static_cast<short>(fMax);
        if (sMax - sMin <= 10)
            sTicks = sMax - sMin;
    }
    else
    {
        sMin = 0;
        sMax = g_sMaxContinuousTicks;
    }
    
    SendMessage(m_hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(sMin, sMax));
    SendMessage(m_hwndSlider, TBM_SETTICFREQ, (sMax - sMin) / sTicks, 0);
    m_fInit = true;
}

void CSliderValue::SetValue(float fPos)
{
    if (!m_fInit)
        return;

    UpdateEditBox(fPos);
    UpdateSlider();
}

float CSliderValue::GetValue()
{
    if (!m_fInit)
        return 0;

    LRESULT lrLen = SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    if (lrLen >= g_iMaxCharBuffer)
        return 0;

    TCHAR szText[g_iMaxCharBuffer] = "";
    SendMessage(m_hwndEdit, WM_GETTEXT, g_iMaxCharBuffer, reinterpret_cast<LPARAM>(szText));

    float fVal = static_cast<float>(m_fDiscrete ? _tstoi(szText) : _tstof(szText));

    if (fVal < m_fMin) fVal = m_fMin;
    if (fVal > m_fMax) fVal = m_fMax;
    return fVal;
}

float CSliderValue::GetSliderValue()
{
    short sPos = static_cast<short>(SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0));
    if (m_fDiscrete)
    {
        return sPos;
    }

    float fRet = (m_fMax - m_fMin) * sPos / g_sMaxContinuousTicks + m_fMin;
    return fRet;
}

LRESULT CSliderValue::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    bHandled = FALSE;

    switch (uMsg)
    {
    case WM_HSCROLL:
        if (reinterpret_cast<HWND>(lParam) == m_hwndSlider && LOWORD(wParam) >= TB_LINEUP && LOWORD(wParam) <= TB_ENDTRACK)
        {
            UpdateEditBox(GetSliderValue());
            bHandled = TRUE;
        }
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_KILLFOCUS && reinterpret_cast<HWND>(lParam) == m_hwndEdit)
        {
            UpdateSlider();
            bHandled = TRUE;
        }
        break;
    }

    return 0;
}

void CSliderValue::UpdateEditBox(float fPos)
{
    TCHAR szText[g_iMaxCharBuffer] = "";

    if (m_fDiscrete)
    {
        short sPos = static_cast<short>(fPos);
        StringCchPrintf(szText, g_iMaxCharBuffer, "%hd", sPos);
    }
    else
    {
        StringCchPrintf(szText, g_iMaxCharBuffer, "%.3hf", fPos);
    }

    SendMessage(m_hwndEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(szText));
}

void CSliderValue::UpdateSlider()
{
    float fVal = GetValue();
    short sPos = static_cast<short>(m_fDiscrete ? fVal : g_sMaxContinuousTicks * ((fVal - m_fMin) / (m_fMax - m_fMin)));
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, sPos);
    UpdateEditBox(fVal); // this resets the input box back to the set float value in case the input was invalid
}

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

CRadioChoice::CRadioChoice(const ButtonEntry *pButtonInfo)
  : m_pButtonInfo(pButtonInfo)
{
}

void CRadioChoice::SetChoice(HWND hDlg, LONG lValue)
{
    for (const ButtonEntry *p = m_pButtonInfo; p->nIDDlgItem; ++p)
    {
        if (p->lValue == lValue)
        {
            CheckDlgButton(hDlg, p->nIDDlgItem, BST_CHECKED);
            return;
        }
    }
}

LONG CRadioChoice::GetChoice(HWND hDlg)
{
    for (const ButtonEntry *p = m_pButtonInfo; p->nIDDlgItem; ++p)
    {
        if (BST_CHECKED == IsDlgButtonChecked(hDlg, p->nIDDlgItem))
        {
            return p->lValue;
        }
    }

    return 0;
}

LRESULT CRadioChoice::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = FALSE;

    if (uMsg == WM_COMMAND && HIWORD(wParam) == BN_CLICKED)
    {
        for (const ButtonEntry *p = m_pButtonInfo; p->nIDDlgItem; ++p)
        {
            if (p->nIDDlgItem == LOWORD(wParam))
            {
                bHandled = TRUE;
                return 0;
            }
        }
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// MessageHandlerChain

LRESULT MessageHandlerChain(Handler **ppHandlers, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = 0;
    bHandled = FALSE;

    for (Handler **pp = ppHandlers; *pp && !bHandled; ++pp)
    {
        lr = (*pp)->MessageHandler(uMsg, wParam, lParam, bHandled);
    }
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxcompressorpage.cpp ===
// DirectSoundFXCompressorPage.cpp : Implementation of CDirectSoundFXCompressorPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXCompressorPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXCompressorPage

CDirectSoundFXCompressorPage::CDirectSoundFXCompressorPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXCompressorPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXCompressorPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXCompressorPage;

    m_rgpHandlers[0] = &m_sliderGain;
    m_rgpHandlers[1] = &m_sliderAttack;
    m_rgpHandlers[2] = &m_sliderRelease;
    m_rgpHandlers[3] = &m_sliderThreshold;
    m_rgpHandlers[4] = &m_sliderRatio;
    m_rgpHandlers[5] = &m_sliderPredelay;
    m_rgpHandlers[6] = NULL;
}

STDMETHODIMP CDirectSoundFXCompressorPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXCompressor, reinterpret_cast<void**>(&m_IDSFXCompressor));
    return hr;
}

STDMETHODIMP CDirectSoundFXCompressorPage::Apply(void)
{
    if (!m_IDSFXCompressor)
        return E_UNEXPECTED;

    DSFXCompressor dsfxcompressor;
    ZeroMemory(&dsfxcompressor, sizeof(DSFXCompressor));

    dsfxcompressor.fGain = m_sliderGain.GetValue();
    dsfxcompressor.fAttack = m_sliderAttack.GetValue();
    dsfxcompressor.fRelease = m_sliderRelease.GetValue();
    dsfxcompressor.fThreshold = m_sliderThreshold.GetValue();
    dsfxcompressor.fRatio = m_sliderRatio.GetValue();
    dsfxcompressor.fPredelay = m_sliderPredelay.GetValue();

    HRESULT hr = m_IDSFXCompressor->SetAllParameters(&dsfxcompressor);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXCompressorPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXCompressor)
        return 1;

    DSFXCompressor dsfxcompressor;
    ZeroMemory(&dsfxcompressor, sizeof(DSFXCompressor));
    m_IDSFXCompressor->GetAllParameters(&dsfxcompressor);

    m_sliderGain.Init(GetDlgItem(IDC_SLIDER_Gain), GetDlgItem(IDC_EDIT_Gain), -60, 60, false);
    m_sliderGain.SetValue(dsfxcompressor.fGain);

    m_sliderAttack.Init(GetDlgItem(IDC_SLIDER_Attack), GetDlgItem(IDC_EDIT_Attack), static_cast<float>(.01), 500, false);
    m_sliderAttack.SetValue(dsfxcompressor.fAttack);

    m_sliderRelease.Init(GetDlgItem(IDC_SLIDER_Release), GetDlgItem(IDC_EDIT_Release), 50, 3000, false);
    m_sliderRelease.SetValue(dsfxcompressor.fRelease);

    m_sliderThreshold.Init(GetDlgItem(IDC_SLIDER_Threshold), GetDlgItem(IDC_EDIT_Threshold), -60, 0, false);
    m_sliderThreshold.SetValue(dsfxcompressor.fThreshold);

    m_sliderRatio.Init(GetDlgItem(IDC_SLIDER_Ratio), GetDlgItem(IDC_EDIT_Ratio), 1, 100, false);
    m_sliderRatio.SetValue(dsfxcompressor.fRatio);

    m_sliderPredelay.Init(GetDlgItem(IDC_SLIDER_Predelay), GetDlgItem(IDC_EDIT_Predelay), 0, 4, false);
    m_sliderPredelay.SetValue(dsfxcompressor.fPredelay);
    
    return 1;
}

LRESULT CDirectSoundFXCompressorPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxflangerpage.cpp ===
// DirectSoundFXFlangerPage.cpp : Implementation of CDirectSoundFXFlangerPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXFlangerPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXFlangerPage

const CRadioChoice::ButtonEntry g_rgWaveButtons[] =
    {
        IDC_RADIO_TRIANGLE, DSFXCHORUS_WAVE_TRIANGLE, //  chorus/flanger
        IDC_RADIO_SIN, DSFXCHORUS_WAVE_SIN, //  chorus/flanger
        0
    };

CDirectSoundFXFlangerPage::CDirectSoundFXFlangerPage()
  : m_radioWaveform(g_rgWaveButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXFlangerPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXFlangerPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXFlangerPage;

    m_rgpHandlers[0] = &m_sliderWetDryMix;
    m_rgpHandlers[1] = &m_sliderDepth;
    m_rgpHandlers[2] = &m_sliderFeedback;
    m_rgpHandlers[3] = &m_sliderFrequency;
    m_rgpHandlers[4] = &m_sliderDelay;
    m_rgpHandlers[5] = &m_sliderPhase;
    m_rgpHandlers[6] = &m_radioWaveform;
    m_rgpHandlers[7] = NULL;
}

STDMETHODIMP CDirectSoundFXFlangerPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXFlanger, reinterpret_cast<void**>(&m_IDSFXFlanger));
    return hr;
}

STDMETHODIMP CDirectSoundFXFlangerPage::Apply(void)
{
    if (!m_IDSFXFlanger)
        return E_UNEXPECTED;

    DSFXFlanger dsfxflanger;
    ZeroMemory(&dsfxflanger, sizeof(DSFXFlanger));

    dsfxflanger.fWetDryMix = m_sliderWetDryMix.GetValue();
    dsfxflanger.fDepth = m_sliderDepth.GetValue();
    dsfxflanger.fFeedback = m_sliderFeedback.GetValue();
    dsfxflanger.fFrequency = m_sliderFrequency.GetValue();
    dsfxflanger.fDelay = m_sliderDelay.GetValue();
    dsfxflanger.lPhase = static_cast<short>(m_sliderPhase.GetValue());
    dsfxflanger.lWaveform = m_radioWaveform.GetChoice(*this);

    HRESULT hr = m_IDSFXFlanger->SetAllParameters(&dsfxflanger);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXFlangerPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXFlanger)
        return 1;

    DSFXFlanger dsfxflanger;
    ZeroMemory(&dsfxflanger, sizeof(DSFXFlanger));
    m_IDSFXFlanger->GetAllParameters(&dsfxflanger);

    m_sliderWetDryMix.Init(GetDlgItem(IDC_SLIDER_WetDryMix), GetDlgItem(IDC_EDIT_WetDryMix), 0, 100, false);
    m_sliderWetDryMix.SetValue(dsfxflanger.fWetDryMix);

    m_sliderDepth.Init(GetDlgItem(IDC_SLIDER_Depth), GetDlgItem(IDC_EDIT_Depth), 0, 100, false);
    m_sliderDepth.SetValue(dsfxflanger.fDepth);

    m_sliderFeedback.Init(GetDlgItem(IDC_SLIDER_Feedback), GetDlgItem(IDC_EDIT_Feedback), -99, 99, false);
    m_sliderFeedback.SetValue(dsfxflanger.fFeedback);

    m_sliderFrequency.Init(GetDlgItem(IDC_SLIDER_Frequency), GetDlgItem(IDC_EDIT_Frequency), 0, 10, false);
    m_sliderFrequency.SetValue(dsfxflanger.fFrequency);

    m_sliderDelay.Init(GetDlgItem(IDC_SLIDER_Delay), GetDlgItem(IDC_EDIT_Delay), 0, 4, false);
    m_sliderDelay.SetValue(dsfxflanger.fDelay);

    m_sliderPhase.Init(GetDlgItem(IDC_SLIDER_Phase), GetDlgItem(IDC_EDIT_Phase), 0, 4, true);
    m_sliderPhase.SetValue(static_cast<float>(dsfxflanger.lPhase));

    m_radioWaveform.SetChoice(*this, dsfxflanger.lWaveform);

    return 1;
}

LRESULT CDirectSoundFXFlangerPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxechopage.cpp ===
// DirectSoundFXEchoPage.cpp : Implementation of CDirectSoundFXEchoPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXEchoPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXEchoPage

const CRadioChoice::ButtonEntry g_rgPanDelayButtons[] =
    {
        IDC_RADIO_PANNED, 1,
        IDC_RADIO_NOTPANNED, 0,
        0
    };

CDirectSoundFXEchoPage::CDirectSoundFXEchoPage()
  : m_radioPanDelay(g_rgPanDelayButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXEchoPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXEchoPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXEchoPage;

    m_rgpHandlers[0] = &m_sliderWetDryMix;
    m_rgpHandlers[1] = &m_sliderFeedback;
    m_rgpHandlers[2] = &m_sliderLeftDelay;
    m_rgpHandlers[3] = &m_sliderRightDelay;
    m_rgpHandlers[4] = &m_radioPanDelay;
    m_rgpHandlers[5] = NULL;
}

STDMETHODIMP CDirectSoundFXEchoPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXEcho, reinterpret_cast<void**>(&m_IDSFXEcho));
    return hr;
}

STDMETHODIMP CDirectSoundFXEchoPage::Apply(void)
{
    if (!m_IDSFXEcho)
        return E_UNEXPECTED;

    DSFXEcho dsfxecho;
    ZeroMemory(&dsfxecho, sizeof(DSFXEcho));

    dsfxecho.fWetDryMix = m_sliderWetDryMix.GetValue();
    dsfxecho.fFeedback = m_sliderFeedback.GetValue();
    dsfxecho.fLeftDelay = m_sliderLeftDelay.GetValue();
    dsfxecho.fRightDelay = m_sliderRightDelay.GetValue();
    dsfxecho.lPanDelay = m_radioPanDelay.GetChoice(*this);

    HRESULT hr = m_IDSFXEcho->SetAllParameters(&dsfxecho);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXEchoPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXEcho)
        return 1;

    DSFXEcho dsfxecho;
    ZeroMemory(&dsfxecho, sizeof(DSFXEcho));
    m_IDSFXEcho->GetAllParameters(&dsfxecho);

    m_sliderWetDryMix.Init(GetDlgItem(IDC_SLIDER_WetDryMix), GetDlgItem(IDC_EDIT_WetDryMix), 0, 100, false);
    m_sliderWetDryMix.SetValue(dsfxecho.fWetDryMix);

    m_sliderFeedback.Init(GetDlgItem(IDC_SLIDER_Feedback), GetDlgItem(IDC_EDIT_Feedback), 0, 100, false);
    m_sliderFeedback.SetValue(dsfxecho.fFeedback);

    m_sliderLeftDelay.Init(GetDlgItem(IDC_SLIDER_LeftDelay), GetDlgItem(IDC_EDIT_LeftDelay), 1, 2000, false);
    m_sliderLeftDelay.SetValue(dsfxecho.fLeftDelay);

    m_sliderRightDelay.Init(GetDlgItem(IDC_SLIDER_RightDelay), GetDlgItem(IDC_EDIT_RightDelay), 1, 2000, false);
    m_sliderRightDelay.SetValue(dsfxecho.fRightDelay);

    m_radioPanDelay.SetChoice(*this, dsfxecho.lPanDelay);

    return 1;
}

LRESULT CDirectSoundFXEchoPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxcompressorpage.h ===
// DirectSoundFXCompressorPage.h : Declaration of the CDirectSoundFXCompressorPage

#ifndef __DIRECTSOUNDFXCOMPRESSORPAGE_H_
#define __DIRECTSOUNDFXCOMPRESSORPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXCompressorPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXCompressorPage
class ATL_NO_VTABLE CDirectSoundFXCompressorPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXCompressorPage, &CLSID_DirectSoundFXCompressorPage>,
    public IPropertyPageImpl<CDirectSoundFXCompressorPage>,
    public CDialogImpl<CDirectSoundFXCompressorPage>
{
public:
    CDirectSoundFXCompressorPage();

    enum {IDD = IDD_DIRECTSOUNDFXCOMPRESSORPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXCOMPRESSORPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXCompressorPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXCompressorPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXCompressorPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXCompressor> m_IDSFXCompressor;
    CSliderValue m_sliderGain;
    CSliderValue m_sliderAttack;
    CSliderValue m_sliderRelease;
    CSliderValue m_sliderThreshold;
    CSliderValue m_sliderRatio;
    CSliderValue m_sliderPredelay;
    CSliderValue m_sliderCompMeterReset;
    CSliderValue m_sliderCompInputMeter;
    CSliderValue m_sliderCompGainMeter;
    Handler *m_rgpHandlers[7];
};

#endif //__DIRECTSOUNDFXCOMPRESSORPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxdistortionpage.h ===
// DirectSoundFXDistortionPage.h : Declaration of the CDirectSoundFXDistortionPage

#ifndef __DIRECTSOUNDFXDISTORTIONPAGE_H_
#define __DIRECTSOUNDFXDISTORTIONPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXDistortionPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXDistortionPage
class ATL_NO_VTABLE CDirectSoundFXDistortionPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXDistortionPage, &CLSID_DirectSoundFXDistortionPage>,
    public IPropertyPageImpl<CDirectSoundFXDistortionPage>,
    public CDialogImpl<CDirectSoundFXDistortionPage>
{
public:
    CDirectSoundFXDistortionPage();

    enum {IDD = IDD_DIRECTSOUNDFXDISTORTIONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXDISTORTIONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXDistortionPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXDistortionPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXDistortionPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXDistortion> m_IDSFXDistortion;
    CSliderValue m_sliderGain;
    CSliderValue m_sliderEdge;
    CSliderValue m_sliderPostEQCenterFrequency;
    CSliderValue m_sliderPostEQBandwidth;
    CSliderValue m_sliderPreLowpassCutoff;
    Handler *m_rgpHandlers[6];
};

#endif //__DIRECTSOUNDFXDISTORTIONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxdistortionpage.cpp ===
// DirectSoundFXDistortionPage.cpp : Implementation of CDirectSoundFXDistortionPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXDistortionPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXDistortionPage

CDirectSoundFXDistortionPage::CDirectSoundFXDistortionPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXDistortionPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXDistortionPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXDistortionPage;

    m_rgpHandlers[0] = &m_sliderGain;
    m_rgpHandlers[1] = &m_sliderEdge;
    m_rgpHandlers[2] = &m_sliderPostEQCenterFrequency;
    m_rgpHandlers[3] = &m_sliderPostEQBandwidth;
    m_rgpHandlers[4] = &m_sliderPreLowpassCutoff;
    m_rgpHandlers[5] = NULL;
}

STDMETHODIMP CDirectSoundFXDistortionPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXDistortion, reinterpret_cast<void**>(&m_IDSFXDistortion));
    return hr;
}

STDMETHODIMP CDirectSoundFXDistortionPage::Apply(void)
{
    if (!m_IDSFXDistortion)
        return E_UNEXPECTED;

    DSFXDistortion dsfxdistortion;
    ZeroMemory(&dsfxdistortion, sizeof(DSFXDistortion));

    dsfxdistortion.fGain = m_sliderGain.GetValue();
    dsfxdistortion.fEdge = m_sliderEdge.GetValue();
    dsfxdistortion.fPostEQCenterFrequency = m_sliderPostEQCenterFrequency.GetValue();
    dsfxdistortion.fPostEQBandwidth = m_sliderPostEQBandwidth.GetValue();
    dsfxdistortion.fPreLowpassCutoff = m_sliderPreLowpassCutoff.GetValue();

    HRESULT hr = m_IDSFXDistortion->SetAllParameters(&dsfxdistortion);
    if (FAILED(hr))
        return hr;

    hr = m_IDSFXDistortion->GetAllParameters(&dsfxdistortion);
    if (FAILED(hr))
        return hr;

    m_sliderGain.SetValue(dsfxdistortion.fGain);
    m_sliderEdge.SetValue(dsfxdistortion.fEdge);
    m_sliderPostEQCenterFrequency.SetValue(dsfxdistortion.fPostEQCenterFrequency);
    m_sliderPostEQBandwidth.SetValue(dsfxdistortion.fPostEQBandwidth);
    m_sliderPreLowpassCutoff.SetValue(dsfxdistortion.fPreLowpassCutoff);

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXDistortionPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXDistortion)
        return 1;

    DSFXDistortion dsfxdistortion;
    ZeroMemory(&dsfxdistortion, sizeof(DSFXDistortion));
    m_IDSFXDistortion->GetAllParameters(&dsfxdistortion);

    m_sliderGain.Init(GetDlgItem(IDC_SLIDER_Gain), GetDlgItem(IDC_EDIT_Gain), -60, 0, false);
    m_sliderGain.SetValue(dsfxdistortion.fGain);

    m_sliderEdge.Init(GetDlgItem(IDC_SLIDER_Edge), GetDlgItem(IDC_EDIT_Edge), 0, 100, false);
    m_sliderEdge.SetValue(dsfxdistortion.fEdge);

    m_sliderPostEQCenterFrequency.Init(GetDlgItem(IDC_SLIDER_PostEQCenterFrequency), GetDlgItem(IDC_EDIT_PostEQCenterFrequency), 100, 8000, true);
    m_sliderPostEQCenterFrequency.SetValue(dsfxdistortion.fPostEQCenterFrequency);

    m_sliderPostEQBandwidth.Init(GetDlgItem(IDC_SLIDER_PostEQBandwidth), GetDlgItem(IDC_EDIT_PostEQBandwidth), 100, 8000 , true);
    m_sliderPostEQBandwidth.SetValue(dsfxdistortion.fPostEQBandwidth);

    m_sliderPreLowpassCutoff.Init(GetDlgItem(IDC_SLIDER_PreLowpassCutoff), GetDlgItem(IDC_EDIT_PreLowpassCutoff), 100, 8000 , true);
    m_sliderPreLowpassCutoff.SetValue(dsfxdistortion.fPreLowpassCutoff);

    return 1;
}

LRESULT CDirectSoundFXDistortionPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxechopage.h ===
// DirectSoundFXEchoPage.h : Declaration of the CDirectSoundFXEchoPage

#ifndef __DIRECTSOUNDFXECHOPAGE_H_
#define __DIRECTSOUNDFXECHOPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXEchoPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXEchoPage
class ATL_NO_VTABLE CDirectSoundFXEchoPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDirectSoundFXEchoPage, &CLSID_DirectSoundFXEchoPage>,
	public IPropertyPageImpl<CDirectSoundFXEchoPage>,
	public CDialogImpl<CDirectSoundFXEchoPage>
{
public:
	CDirectSoundFXEchoPage();

	enum {IDD = IDD_DIRECTSOUNDFXECHOPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXECHOPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXEchoPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXEchoPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
	CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXEchoPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXEcho> m_IDSFXEcho;
    CSliderValue m_sliderWetDryMix;
    CSliderValue m_sliderFeedback;
    CSliderValue m_sliderLeftDelay;
    CSliderValue m_sliderRightDelay;
    CRadioChoice m_radioPanDelay;
    Handler *m_rgpHandlers[6];
};

#endif //__DIRECTSOUNDFXECHOPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxflangerpage.h ===
// DirectSoundFXFlangerPage.h : Declaration of the CDirectSoundFXFlangerPage

#ifndef __DIRECTSOUNDFXFLANGERPAGE_H_
#define __DIRECTSOUNDFXFLANGERPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXFlangerPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXFlangerPage
class ATL_NO_VTABLE CDirectSoundFXFlangerPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXFlangerPage, &CLSID_DirectSoundFXFlangerPage>,
    public IPropertyPageImpl<CDirectSoundFXFlangerPage>,
    public CDialogImpl<CDirectSoundFXFlangerPage>
{
public:
    CDirectSoundFXFlangerPage();

    enum {IDD = IDD_DIRECTSOUNDFXFLANGERPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXFLANGERPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXFlangerPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXFlangerPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXFlangerPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXFlanger> m_IDSFXFlanger;
    CSliderValue m_sliderWetDryMix;
    CSliderValue m_sliderDepth;
    CSliderValue m_sliderFeedback;
    CSliderValue m_sliderFrequency;
    CSliderValue m_sliderDelay;
    CSliderValue m_sliderPhase;
    CRadioChoice m_radioWaveform;
    Handler *m_rgpHandlers[8];
};

#endif //__DIRECTSOUNDFXFLANGERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxgarglepage.cpp ===
// DirectSoundFXGarglePage.cpp : Implementation of CDirectSoundFXGarglePage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXGarglePage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXGarglePage

const CRadioChoice::ButtonEntry g_rgWaveButtons[] =
    {
        IDC_RADIO_TRIANGLE, DSFXGARGLE_WAVE_TRIANGLE,
        IDC_RADIO_SQUARE, DSFXGARGLE_WAVE_SQUARE,
        0
    };

CDirectSoundFXGarglePage::CDirectSoundFXGarglePage()
  : m_radioWaveform(g_rgWaveButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXGarglePage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXGarglePage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXGarglePage;

    m_rgpHandlers[0] = &m_sliderRate;
    m_rgpHandlers[1] = &m_radioWaveform;
    m_rgpHandlers[2] = NULL;
}

STDMETHODIMP CDirectSoundFXGarglePage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXGargle, reinterpret_cast<void**>(&m_IDSFXGargle));
    return hr;
}

STDMETHODIMP CDirectSoundFXGarglePage::Apply(void)
{
    if (!m_IDSFXGargle)
        return E_UNEXPECTED;

    DSFXGargle dsfxgargle;
    ZeroMemory(&dsfxgargle, sizeof(DSFXGargle));

    dsfxgargle.dwRateHz = static_cast<DWORD>(m_sliderRate.GetValue());
    dsfxgargle.dwWaveShape = m_radioWaveform.GetChoice(*this);

    HRESULT hr = m_IDSFXGargle->SetAllParameters(&dsfxgargle);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXGarglePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXGargle)
        return 1;

    DSFXGargle dsfxgargle;
    ZeroMemory(&dsfxgargle, sizeof(DSFXGargle));
    m_IDSFXGargle->GetAllParameters(&dsfxgargle);

    m_sliderRate.Init(GetDlgItem(IDC_SLIDER_Rate), GetDlgItem(IDC_EDIT_Rate), 1, 1000, true);
    m_sliderRate.SetValue(static_cast<float>(dsfxgargle.dwRateHz));

    m_radioWaveform.SetChoice(*this, dsfxgargle.dwWaveShape);

    return 1;
}

LRESULT CDirectSoundFXGarglePage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2reverbpage.h ===
// DirectSoundFXI3DL2ReverbPage.h : Declaration of the CDirectSoundFXI3DL2ReverbPage

#ifndef __DIRECTSOUNDFXI3DL2REVERBPAGE_H_
#define __DIRECTSOUNDFXI3DL2REVERBPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

#define NUMPRESETS 30

EXTERN_C const CLSID CLSID_DirectSoundFXI3DL2ReverbPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2ReverbPage
class ATL_NO_VTABLE CDirectSoundFXI3DL2ReverbPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXI3DL2ReverbPage, &CLSID_DirectSoundFXI3DL2ReverbPage>,
    public IPropertyPageImpl<CDirectSoundFXI3DL2ReverbPage>,
    public CDialogImpl<CDirectSoundFXI3DL2ReverbPage>
{
public:
    CDirectSoundFXI3DL2ReverbPage();

    enum {IDD = IDD_DIRECTSOUNDFXI3DL2REVERBPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXI3DL2REVERBPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXI3DL2ReverbPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXI3DL2ReverbPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnComboControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXI3DL2ReverbPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnComboControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXI3DL2Reverb> m_IDSFXI3DL2Reverb;
    CSliderValue m_sliderRoom;
    CSliderValue m_sliderRoomHF;
    CSliderValue m_sliderRoomRolloffFactor;
    CSliderValue m_sliderDecayTime;
    CSliderValue m_sliderDecayHFRatio;
    CSliderValue m_sliderReflections;
    CSliderValue m_sliderReflectionsDelay;
    CSliderValue m_sliderReverb;
    CSliderValue m_sliderReverbDelay;
    CSliderValue m_sliderDiffusion;
    CSliderValue m_sliderDensity;
    CSliderValue m_sliderHFReference;
    CSliderValue m_sliderQuality;
    Handler *m_rgpHandlers[14];

protected:
    static DSFXI3DL2Reverb Presets[];
    void FillCombo(HWND hWnd);
};

#endif //__DIRECTSOUNDFXI3DL2REVERBPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2reverbpage.cpp ===
// DirectSoundFXI3DL2ReverbPage.cpp : Implementation of CDirectSoundFXI3DL2ReverbPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXI3DL2ReverbPage.h"

DSFXI3DL2Reverb CDirectSoundFXI3DL2ReverbPage::Presets[] =
{
    {I3DL2_ENVIRONMENT_PRESET_DEFAULT},
    {I3DL2_ENVIRONMENT_PRESET_GENERIC},
    {I3DL2_ENVIRONMENT_PRESET_PADDEDCELL},
    {I3DL2_ENVIRONMENT_PRESET_ROOM},
    {I3DL2_ENVIRONMENT_PRESET_BATHROOM},
    {I3DL2_ENVIRONMENT_PRESET_LIVINGROOM},
    {I3DL2_ENVIRONMENT_PRESET_STONEROOM},
    {I3DL2_ENVIRONMENT_PRESET_AUDITORIUM},
    {I3DL2_ENVIRONMENT_PRESET_CONCERTHALL},
    {I3DL2_ENVIRONMENT_PRESET_CAVE},
    {I3DL2_ENVIRONMENT_PRESET_ARENA},
    {I3DL2_ENVIRONMENT_PRESET_HANGAR},
    {I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY},
    {I3DL2_ENVIRONMENT_PRESET_HALLWAY},
    {I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR},
    {I3DL2_ENVIRONMENT_PRESET_ALLEY},
    {I3DL2_ENVIRONMENT_PRESET_FOREST},
    {I3DL2_ENVIRONMENT_PRESET_CITY},
    {I3DL2_ENVIRONMENT_PRESET_MOUNTAINS},
    {I3DL2_ENVIRONMENT_PRESET_QUARRY},
    {I3DL2_ENVIRONMENT_PRESET_PLAIN},      
    {I3DL2_ENVIRONMENT_PRESET_PARKINGLOT},
    {I3DL2_ENVIRONMENT_PRESET_SEWERPIPE},
    {I3DL2_ENVIRONMENT_PRESET_UNDERWATER}, 
    {I3DL2_ENVIRONMENT_PRESET_SMALLROOM},
    {I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM},
    {I3DL2_ENVIRONMENT_PRESET_LARGEROOM},
    {I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL},
    {I3DL2_ENVIRONMENT_PRESET_LARGEHALL},
    {I3DL2_ENVIRONMENT_PRESET_PLATE},
};
    
/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2ReverbPage

CDirectSoundFXI3DL2ReverbPage::CDirectSoundFXI3DL2ReverbPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXI3DL2ReverbPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXI3DL2ReverbPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXI3DL2ReverbPage;

    m_rgpHandlers[0]  = &m_sliderRoom;
    m_rgpHandlers[1]  = &m_sliderRoomHF;
    m_rgpHandlers[2]  = &m_sliderRoomRolloffFactor;
    m_rgpHandlers[3]  = &m_sliderDecayTime;
    m_rgpHandlers[4]  = &m_sliderDecayHFRatio;
    m_rgpHandlers[5]  = &m_sliderReflections;
    m_rgpHandlers[6]  = &m_sliderReflectionsDelay;
    m_rgpHandlers[7]  = &m_sliderReverb;
    m_rgpHandlers[8]  = &m_sliderReverbDelay;
    m_rgpHandlers[9]  = &m_sliderDiffusion;
    m_rgpHandlers[10] = &m_sliderDensity;
    m_rgpHandlers[11] = &m_sliderHFReference;
    m_rgpHandlers[12] = &m_sliderQuality;
    m_rgpHandlers[13] = NULL;
}

STDMETHODIMP CDirectSoundFXI3DL2ReverbPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXI3DL2Reverb, reinterpret_cast<void**>(&m_IDSFXI3DL2Reverb));
    return hr;
}

STDMETHODIMP CDirectSoundFXI3DL2ReverbPage::Apply(void)
{
    if (!m_IDSFXI3DL2Reverb)
        return E_UNEXPECTED;

    DSFXI3DL2Reverb dsfxi3dl2reverb;
    ZeroMemory(&dsfxi3dl2reverb, sizeof(DSFXI3DL2Reverb));

    dsfxi3dl2reverb.lRoom = static_cast<LONG>(m_sliderRoom.GetValue());
    dsfxi3dl2reverb.lRoomHF = static_cast<LONG>(m_sliderRoomHF.GetValue());
    dsfxi3dl2reverb.flRoomRolloffFactor = m_sliderRoomRolloffFactor.GetValue();
    dsfxi3dl2reverb.flDecayTime = m_sliderDecayTime.GetValue();
    dsfxi3dl2reverb.flDecayHFRatio = m_sliderDecayHFRatio.GetValue();
    dsfxi3dl2reverb.lReflections = static_cast<LONG>(m_sliderReflections.GetValue());
    dsfxi3dl2reverb.flReflectionsDelay = m_sliderReflectionsDelay.GetValue();
    dsfxi3dl2reverb.lReverb = static_cast<LONG>(m_sliderReverb.GetValue());
    dsfxi3dl2reverb.flReverbDelay = m_sliderReverbDelay.GetValue();
    dsfxi3dl2reverb.flDiffusion = m_sliderDiffusion.GetValue();
    dsfxi3dl2reverb.flDensity = m_sliderDensity.GetValue();
    dsfxi3dl2reverb.flHFReference = m_sliderHFReference.GetValue();

    HRESULT hr = m_IDSFXI3DL2Reverb->SetAllParameters(&dsfxi3dl2reverb);
    if (FAILED(hr))
        return hr;
    hr = m_IDSFXI3DL2Reverb->SetQuality(static_cast<long>(m_sliderQuality.GetValue()));
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXI3DL2ReverbPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXI3DL2Reverb)
        return 1;

    DSFXI3DL2Reverb dsfxi3dl2reverb;
    ZeroMemory(&dsfxi3dl2reverb, sizeof(DSFXI3DL2Reverb));
    m_IDSFXI3DL2Reverb->GetAllParameters(&dsfxi3dl2reverb);
    LONG lQuality = 0;
    m_IDSFXI3DL2Reverb->GetQuality(&lQuality);

    m_sliderRoom.Init(GetDlgItem(IDC_SLIDER_Room), GetDlgItem(IDC_EDIT_Room), DSFX_I3DL2REVERB_ROOM_MIN, DSFX_I3DL2REVERB_ROOM_MAX, true);
    m_sliderRoom.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoom));

    m_sliderRoomHF.Init(GetDlgItem(IDC_SLIDER_RoomHF), GetDlgItem(IDC_EDIT_RoomHF), DSFX_I3DL2REVERB_ROOMHF_MIN, DSFX_I3DL2REVERB_ROOMHF_MAX, true);
    m_sliderRoomHF.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoomHF));

    m_sliderRoomRolloffFactor.Init(GetDlgItem(IDC_SLIDER_RoomRolloffFactor), GetDlgItem(IDC_EDIT_RoomRolloffFactor), DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN, DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX, false);
    m_sliderRoomRolloffFactor.SetValue(dsfxi3dl2reverb.flRoomRolloffFactor);

    m_sliderDecayTime.Init(GetDlgItem(IDC_SLIDER_DecayTime), GetDlgItem(IDC_EDIT_DecayTime), DSFX_I3DL2REVERB_DECAYTIME_MIN, DSFX_I3DL2REVERB_DECAYTIME_MAX, false);
    m_sliderDecayTime.SetValue(dsfxi3dl2reverb.flDecayTime);

    m_sliderDecayHFRatio.Init(GetDlgItem(IDC_SLIDER_DecayHFRatio), GetDlgItem(IDC_EDIT_DecayHFRatio), DSFX_I3DL2REVERB_DECAYHFRATIO_MIN, DSFX_I3DL2REVERB_DECAYHFRATIO_MAX, false);
    m_sliderDecayHFRatio.SetValue(dsfxi3dl2reverb.flDecayHFRatio);

    m_sliderReflections.Init(GetDlgItem(IDC_SLIDER_Reflections), GetDlgItem(IDC_EDIT_Reflections), DSFX_I3DL2REVERB_REFLECTIONS_MIN, DSFX_I3DL2REVERB_REFLECTIONS_MAX, true);
    m_sliderReflections.SetValue(static_cast<float>(dsfxi3dl2reverb.lReflections));

    m_sliderReflectionsDelay.Init(GetDlgItem(IDC_SLIDER_ReflectionsDelay), GetDlgItem(IDC_EDIT_ReflectionsDelay), DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN, DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX, false);
    m_sliderReflectionsDelay.SetValue(dsfxi3dl2reverb.flReflectionsDelay);

    m_sliderReverb.Init(GetDlgItem(IDC_SLIDER_Reverb), GetDlgItem(IDC_EDIT_Reverb), DSFX_I3DL2REVERB_REVERB_MIN, DSFX_I3DL2REVERB_REVERB_MAX, true);
    m_sliderReverb.SetValue(static_cast<float>(dsfxi3dl2reverb.lReverb));

    m_sliderReverbDelay.Init(GetDlgItem(IDC_SLIDER_ReverbDelay), GetDlgItem(IDC_EDIT_ReverbDelay), DSFX_I3DL2REVERB_REVERBDELAY_MIN, DSFX_I3DL2REVERB_REVERBDELAY_MAX, false);
    m_sliderReverbDelay.SetValue(dsfxi3dl2reverb.flReverbDelay);

    m_sliderDiffusion.Init(GetDlgItem(IDC_SLIDER_Diffusion), GetDlgItem(IDC_EDIT_Diffusion), DSFX_I3DL2REVERB_DIFFUSION_MIN, DSFX_I3DL2REVERB_DIFFUSION_MAX, false);
    m_sliderDiffusion.SetValue(dsfxi3dl2reverb.flDiffusion);

    m_sliderDensity.Init(GetDlgItem(IDC_SLIDER_Density), GetDlgItem(IDC_EDIT_Density), DSFX_I3DL2REVERB_DENSITY_MIN, DSFX_I3DL2REVERB_DENSITY_MAX, false);
    m_sliderDensity.SetValue(dsfxi3dl2reverb.flDensity);

    m_sliderHFReference.Init(GetDlgItem(IDC_SLIDER_HFReference), GetDlgItem(IDC_EDIT_HFReference), DSFX_I3DL2REVERB_HFREFERENCE_MIN, DSFX_I3DL2REVERB_HFREFERENCE_MAX, false);
    m_sliderHFReference.SetValue(dsfxi3dl2reverb.flHFReference);

    m_sliderQuality.Init(GetDlgItem(IDC_SLIDER_Quality), GetDlgItem(IDC_EDIT_Quality), DSFX_I3DL2REVERB_QUALITY_MIN, DSFX_I3DL2REVERB_QUALITY_MAX, true);
    m_sliderQuality.SetValue(static_cast<float>(lQuality));

    FillCombo(GetDlgItem(IDC_PRESET));

    return 1;
}

LRESULT CDirectSoundFXI3DL2ReverbPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
    {
        //Mark the Page as Dirty
        SetDirty(TRUE);

        //Clear the ComboBox
        ::SendMessage(GetDlgItem(IDC_PRESET),CB_SETCURSEL, static_cast<WPARAM>(-1),static_cast<LPARAM>(0));
    }
    return lr;
}

void CDirectSoundFXI3DL2ReverbPage::FillCombo(HWND hWnd)
{
    CONST int BUFFERLEN=256;  //Maximum size of the string for the DropDown.
    TCHAR tchBuffer[BUFFERLEN];
    LRESULT lr;
    int cCh;
    
    //We're going to fillup the DropDown Listbox with strings and data
    for (int i=0;i<NUMPRESETS;i++)
    {
        //Load the Strings
        cCh = LoadString(_Module.GetResourceInstance(),IDS_PRESETDefault + i, tchBuffer, BUFFERLEN);

        // 0 indicates an error -- bail
        ATLASSERT(cCh != 0);

        //Put the string in the dropdown
        //lr will be the index in the dropdown where the item was put
        lr =::SendMessage(hWnd,CB_ADDSTRING,(WPARAM) 0,(LPARAM) tchBuffer);
        ATLASSERT(lr != CB_ERR && lr != CB_ERRSPACE);

        //Put the index into the preset array that goes with the string
        //into the itemdata for the dropdown
        lr = ::SendMessage(hWnd,CB_SETITEMDATA,(WPARAM) lr,(LPARAM) i);
        ATLASSERT(lr != CB_ERR);
        
        //Don't select anything to start
        ::SendMessage(hWnd,CB_SETCURSEL,(WPARAM)-1,(LPARAM)0);
    }
}

LRESULT CDirectSoundFXI3DL2ReverbPage::OnComboControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = 0;
    bHandled = FALSE;
    HWND hWnd;

    switch(uMsg)
    {
    case WM_COMMAND:
        if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRESET)
        {   
            hWnd = reinterpret_cast<HWND>(lParam);
            //Get the Index of the Current Selection
            lr = ::SendMessage(hWnd, CB_GETCURSEL, static_cast<WPARAM>(0), static_cast<LPARAM>(0));
            if (lr == CB_ERR)
                break;
            //Get the ItemData -- This is the index into the Presets Array
            lr = ::SendMessage(hWnd, CB_GETITEMDATA, static_cast<WPARAM>(lr), static_cast<LPARAM>(0));
            if (lr == CB_ERR)
                break;

            //Set the object with the presets
            m_IDSFXI3DL2Reverb->SetAllParameters(&Presets[lr]);

            //Retrive the values from the object
            DSFXI3DL2Reverb dsfxi3dl2reverb;
            ZeroMemory(&dsfxi3dl2reverb, sizeof(DSFXI3DL2Reverb));
            m_IDSFXI3DL2Reverb->GetAllParameters(&dsfxi3dl2reverb);

            //Set the sliders
            m_sliderRoom.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoom));
            m_sliderRoomHF.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoomHF));
            m_sliderRoomRolloffFactor.SetValue(dsfxi3dl2reverb.flRoomRolloffFactor);
            m_sliderDecayTime.SetValue(dsfxi3dl2reverb.flDecayTime);
            m_sliderDecayHFRatio.SetValue(dsfxi3dl2reverb.flDecayHFRatio);
            m_sliderReflections.SetValue(static_cast<float>(dsfxi3dl2reverb.lReflections));
            m_sliderReflectionsDelay.SetValue(dsfxi3dl2reverb.flReflectionsDelay);
            m_sliderReverb.SetValue(static_cast<float>(dsfxi3dl2reverb.lReverb));
            m_sliderReverbDelay.SetValue(dsfxi3dl2reverb.flReverbDelay);
            m_sliderDiffusion.SetValue(dsfxi3dl2reverb.flDiffusion);
            m_sliderDensity.SetValue(dsfxi3dl2reverb.flDensity);
            m_sliderHFReference.SetValue(dsfxi3dl2reverb.flHFReference);
            
            bHandled = TRUE;
            SetDirty(TRUE);
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2sourcepage.h ===
// DirectSoundFXI3DL2SourcePage.h : Declaration of the CDirectSoundFXI3DL2SourcePage

#ifndef __DIRECTSOUNDFXI3DL2SOURCEPAGE_H_
#define __DIRECTSOUNDFXI3DL2SOURCEPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXI3DL2SourcePage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2SourcePage
class ATL_NO_VTABLE CDirectSoundFXI3DL2SourcePage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXI3DL2SourcePage, &CLSID_DirectSoundFXI3DL2SourcePage>,
    public IPropertyPageImpl<CDirectSoundFXI3DL2SourcePage>,
    public CDialogImpl<CDirectSoundFXI3DL2SourcePage>
{
public:
    CDirectSoundFXI3DL2SourcePage();

    enum {IDD = IDD_DIRECTSOUNDFXI3DL2SOURCEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXI3DL2SOURCEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXI3DL2SourcePage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXI3DL2SourcePage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXI3DL2SourcePage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXI3DL2Source> m_IDSFXI3DL2Source;
    CSliderValue m_sliderDirect;
    CSliderValue m_sliderDirectHF;
    CSliderValue m_sliderRoom;
    CSliderValue m_sliderRoomHF;
    CSliderValue m_sliderRoomRolloffFactor;
    CSliderValue m_sliderObstruction;
    CSliderValue m_sliderObstructionLFRatio;
    CSliderValue m_sliderOcclusion;
    CSliderValue m_sliderOcclusionLFRatio;
    CRadioChoice m_radioFlags;
    Handler *m_rgpHandlers[11];
};

#endif //__DIRECTSOUNDFXI3DL2SOURCEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxgarglepage.h ===
// DirectSoundFXGarglePage.h : Declaration of the CDirectSoundFXGarglePage

#ifndef __DIRECTSOUNDFXGARGLEPAGE_H_
#define __DIRECTSOUNDFXGARGLEPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXGarglePage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXGarglePage
class ATL_NO_VTABLE CDirectSoundFXGarglePage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXGarglePage, &CLSID_DirectSoundFXGarglePage>,
    public IPropertyPageImpl<CDirectSoundFXGarglePage>,
    public CDialogImpl<CDirectSoundFXGarglePage>
{
public:
    CDirectSoundFXGarglePage();

    enum {IDD = IDD_DIRECTSOUNDFXGARGLEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXGARGLEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXGarglePage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXGarglePage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXGarglePage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXGargle> m_IDSFXGargle;
    CSliderValue m_sliderRate;
    CRadioChoice m_radioWaveform;
    Handler *m_rgpHandlers[3];
};

#endif //__DIRECTSOUNDFXGARGLEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxparameqpage.h ===
// DirectSoundFXParamEqPage.h : Declaration of the CDirectSoundFXParamEqPage

#ifndef __DIRECTSOUNDFXPARAMEQPAGE_H_
#define __DIRECTSOUNDFXPARAMEQPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXParamEqPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXParamEqPage
class ATL_NO_VTABLE CDirectSoundFXParamEqPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXParamEqPage, &CLSID_DirectSoundFXParamEqPage>,
    public IPropertyPageImpl<CDirectSoundFXParamEqPage>,
    public CDialogImpl<CDirectSoundFXParamEqPage>
{
public:
    CDirectSoundFXParamEqPage();

    enum {IDD = IDD_DIRECTSOUNDFXPARAMEQPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXPARAMEQPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXParamEqPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXParamEqPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXParamEqPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXParamEq> m_IDSFXParamEq;
    CSliderValue m_sliderCenter;
    CSliderValue m_sliderBandwidth;
    CSliderValue m_sliderGain;
    Handler *m_rgpHandlers[4];
};

#endif //__DIRECTSOUNDFXPARAMEQPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2sourcepage.cpp ===
// DirectSoundFXI3DL2SourcePage.cpp : Implementation of CDirectSoundFXI3DL2SourcePage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXI3DL2SourcePage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2SourcePage

const CRadioChoice::ButtonEntry g_rgWaveFlags[] =
    {
        IDC_RADIO_LPF, DSFX_I3DL2SOURCE_OCC_LPF,
        IDC_RADIO_VOLUME, DSFX_I3DL2SOURCE_OCC_VOLUME,
        0
    };

CDirectSoundFXI3DL2SourcePage::CDirectSoundFXI3DL2SourcePage()
  : m_radioFlags(g_rgWaveFlags)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXI3DL2SourcePage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXI3DL2SourcePage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXI3DL2SourcePage;

    m_rgpHandlers[0]  = &m_sliderDirect;
    m_rgpHandlers[1]  = &m_sliderDirectHF;
    m_rgpHandlers[2]  = &m_sliderRoom;
    m_rgpHandlers[3]  = &m_sliderRoomHF;
    m_rgpHandlers[4]  = &m_sliderRoomRolloffFactor;
    m_rgpHandlers[5]  = &m_sliderObstruction;
    m_rgpHandlers[6]  = &m_sliderObstructionLFRatio;
    m_rgpHandlers[7]  = &m_sliderOcclusion;
    m_rgpHandlers[8]  = &m_sliderOcclusionLFRatio;
    m_rgpHandlers[9]  = &m_radioFlags;
    m_rgpHandlers[10] = NULL;
}

STDMETHODIMP CDirectSoundFXI3DL2SourcePage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXI3DL2Source, reinterpret_cast<void**>(&m_IDSFXI3DL2Source));
    return hr;
}

STDMETHODIMP CDirectSoundFXI3DL2SourcePage::Apply(void)
{
    if (!m_IDSFXI3DL2Source)
        return E_UNEXPECTED;

    DSFXI3DL2Source dsfxi3dl2source;
    ZeroMemory(&dsfxi3dl2source, sizeof(DSFXI3DL2Source));

    dsfxi3dl2source.lDirect = static_cast<LONG>(m_sliderDirect.GetValue());
    dsfxi3dl2source.lDirectHF = static_cast<LONG>(m_sliderDirectHF.GetValue());
    dsfxi3dl2source.lRoom = static_cast<LONG>(m_sliderRoom.GetValue());
    dsfxi3dl2source.lRoomHF = static_cast<LONG>(m_sliderRoomHF.GetValue());
    dsfxi3dl2source.flRoomRolloffFactor = m_sliderRoomRolloffFactor.GetValue();
    dsfxi3dl2source.Obstruction.lHFLevel = static_cast<LONG>(m_sliderObstruction.GetValue());
    dsfxi3dl2source.Obstruction.flLFRatio = m_sliderObstructionLFRatio.GetValue();
    dsfxi3dl2source.Occlusion.lHFLevel = static_cast<LONG>(m_sliderOcclusion.GetValue());
    dsfxi3dl2source.Occlusion.flLFRatio = m_sliderOcclusionLFRatio.GetValue();
    dsfxi3dl2source.dwFlags = m_radioFlags.GetChoice(*this);

    HRESULT hr = m_IDSFXI3DL2Source->SetAllParameters(&dsfxi3dl2source);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXI3DL2SourcePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXI3DL2Source)
        return 1;

    DSFXI3DL2Source dsfxi3dl2source;
    ZeroMemory(&dsfxi3dl2source, sizeof(DSFXI3DL2Source));
    m_IDSFXI3DL2Source->GetAllParameters(&dsfxi3dl2source);

    m_sliderDirect.Init(GetDlgItem(IDC_SLIDER_Direct), GetDlgItem(IDC_EDIT_Direct), DSFX_I3DL2SOURCE_DIRECT_MIN, DSFX_I3DL2SOURCE_DIRECT_MAX, true);
    m_sliderDirect.SetValue(static_cast<float>(dsfxi3dl2source.lDirect));

    m_sliderDirectHF.Init(GetDlgItem(IDC_SLIDER_DirectHF), GetDlgItem(IDC_EDIT_DirectHF), DSFX_I3DL2SOURCE_DIRECTHF_MIN, DSFX_I3DL2SOURCE_DIRECTHF_MAX, true);
    m_sliderDirectHF.SetValue(static_cast<float>(dsfxi3dl2source.lDirectHF));

    m_sliderRoom.Init(GetDlgItem(IDC_SLIDER_Room), GetDlgItem(IDC_EDIT_Room), DSFX_I3DL2SOURCE_ROOM_MIN, DSFX_I3DL2SOURCE_ROOM_MAX, true);
    m_sliderRoom.SetValue(static_cast<float>(dsfxi3dl2source.lRoom));

    m_sliderRoomHF.Init(GetDlgItem(IDC_SLIDER_RoomHF), GetDlgItem(IDC_EDIT_RoomHF), DSFX_I3DL2SOURCE_ROOMHF_MIN, DSFX_I3DL2SOURCE_ROOMHF_MAX, true);
    m_sliderRoomHF.SetValue(static_cast<float>(dsfxi3dl2source.lRoomHF));

    m_sliderRoomRolloffFactor.Init(GetDlgItem(IDC_SLIDER_RoomRolloffFactor), GetDlgItem(IDC_EDIT_RoomRolloffFactor), DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN, DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX, false);
    m_sliderRoomRolloffFactor.SetValue(dsfxi3dl2source.flRoomRolloffFactor);

    m_sliderObstruction.Init(GetDlgItem(IDC_SLIDER_Obstruction), GetDlgItem(IDC_EDIT_Obstruction), DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN, DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX, true);
    m_sliderObstruction.SetValue(static_cast<float>(dsfxi3dl2source.Obstruction.lHFLevel));

    m_sliderObstructionLFRatio.Init(GetDlgItem(IDC_SLIDER_ObstructionLFRatio), GetDlgItem(IDC_EDIT_ObstructionLFRatio), DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN, DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX, false);
    m_sliderObstructionLFRatio.SetValue(dsfxi3dl2source.Obstruction.flLFRatio);

    m_sliderOcclusion.Init(GetDlgItem(IDC_SLIDER_Occlusion), GetDlgItem(IDC_EDIT_Occlusion), DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN, DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX, true);
    m_sliderOcclusion.SetValue(static_cast<float>(dsfxi3dl2source.Occlusion.lHFLevel));

    m_sliderOcclusionLFRatio.Init(GetDlgItem(IDC_SLIDER_OcclusionLFRatio), GetDlgItem(IDC_EDIT_OcclusionLFRatio), DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN, DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX, false);
    m_sliderOcclusionLFRatio.SetValue(dsfxi3dl2source.Occlusion.flLFRatio);

    m_radioFlags.SetChoice(*this, dsfxi3dl2source.dwFlags);

    return 1;
}

LRESULT CDirectSoundFXI3DL2SourcePage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxparameqpage.cpp ===
// DirectSoundFXParamEqPage.cpp : Implementation of CDirectSoundFXParamEqPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXParamEqPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXParamEqPage

CDirectSoundFXParamEqPage::CDirectSoundFXParamEqPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXParamEqPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXParamEqPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXParamEqPage;

    m_rgpHandlers[0] = &m_sliderCenter;
    m_rgpHandlers[1] = &m_sliderBandwidth;
    m_rgpHandlers[2] = &m_sliderGain;
    m_rgpHandlers[3] = NULL;
}

STDMETHODIMP CDirectSoundFXParamEqPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXParamEq, reinterpret_cast<void**>(&m_IDSFXParamEq));
    return hr;
}

STDMETHODIMP CDirectSoundFXParamEqPage::Apply(void)
{
    if (!m_IDSFXParamEq)
        return E_UNEXPECTED;

    DSFXParamEq dsfxparameq;
    ZeroMemory(&dsfxparameq, sizeof(DSFXParamEq));

    dsfxparameq.fCenter = m_sliderCenter.GetValue();
    dsfxparameq.fBandwidth = m_sliderBandwidth.GetValue();
    dsfxparameq.fGain = m_sliderGain.GetValue();

    HRESULT hr = m_IDSFXParamEq->SetAllParameters(&dsfxparameq);
    if (FAILED(hr))
        return hr;

    hr = m_IDSFXParamEq->GetAllParameters(&dsfxparameq);
    if (FAILED(hr))
        return hr;
        
    m_sliderCenter.SetValue(dsfxparameq.fCenter);
    m_sliderBandwidth.SetValue(dsfxparameq.fBandwidth);
    m_sliderGain.SetValue(dsfxparameq.fGain);

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXParamEqPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXParamEq)
        return 1;

    DSFXParamEq dsfxparameq;
    ZeroMemory(&dsfxparameq, sizeof(DSFXParamEq));
    m_IDSFXParamEq->GetAllParameters(&dsfxparameq);

    m_sliderCenter.Init(GetDlgItem(IDC_SLIDER_Center), GetDlgItem(IDC_EDIT_Center), 80, 16000, true);
    m_sliderCenter.SetValue(dsfxparameq.fCenter);

    m_sliderBandwidth.Init(GetDlgItem(IDC_SLIDER_Bandwidth), GetDlgItem(IDC_EDIT_Bandwidth), 1, 36, false);
    m_sliderBandwidth.SetValue(dsfxparameq.fBandwidth);

    m_sliderGain.Init(GetDlgItem(IDC_SLIDER_Gain), GetDlgItem(IDC_EDIT_Gain), -15, 15, false);
    m_sliderGain.SetValue(dsfxparameq.fGain);

    return 1;
}

LRESULT CDirectSoundFXParamEqPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\makefile.inc ===
buildidl : $O\dsdmoprp.h

$O\dsdmoprp.h : ..\dsdmoprp.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header  $O\dsdmoprp.h \
    -tlb     $O\dsdmoprp.tlb \
    -iid     $O\dsdmoprp_i.c \
    -dlldata $(PROXY_DIR)\dlldata.c \
    -proxy   $(PROXY_DIR)\dsdmoprp_p.c \
    ..\dsdmoprp.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\dsdmoprp.cpp ===
// dsdmoprp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f dsdmoprpps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "dsdmoprp.h"

#include "dsdmoprp_i.c"
#include "DirectSoundFXChorusPage.h"
#include "DirectSoundFXCompressorPage.h"
#include "DirectSoundFXDistortionPage.h"
#include "DirectSoundFXEchoPage.h"
#include "DirectSoundFXFlangerPage.h"
#include "DirectSoundFXParamEqPage.h"
#include "DirectSoundFXGarglePage.h"
#include "DirectSoundFXWavesReverbPage.h"
//#include "DirectSoundFXI3DL2SourcePage.h"
#include "DirectSoundFXI3DL2ReverbPage.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DirectSoundFXChorusPage, CDirectSoundFXChorusPage)
OBJECT_ENTRY(CLSID_DirectSoundFXCompressorPage, CDirectSoundFXCompressorPage)
OBJECT_ENTRY(CLSID_DirectSoundFXDistortionPage, CDirectSoundFXDistortionPage)
OBJECT_ENTRY(CLSID_DirectSoundFXEchoPage, CDirectSoundFXEchoPage)
OBJECT_ENTRY(CLSID_DirectSoundFXFlangerPage, CDirectSoundFXFlangerPage)
OBJECT_ENTRY(CLSID_DirectSoundFXParamEqPage, CDirectSoundFXParamEqPage)
OBJECT_ENTRY(CLSID_DirectSoundFXGarglePage, CDirectSoundFXGarglePage)
OBJECT_ENTRY(CLSID_DirectSoundFXWavesReverbPage, CDirectSoundFXWavesReverbPage)
//OBJECT_ENTRY(CLSID_DirectSoundFXI3DL2SourcePage, CDirectSoundFXI3DL2SourcePage)
OBJECT_ENTRY(CLSID_DirectSoundFXI3DL2ReverbPage, CDirectSoundFXI3DL2ReverbPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DSDMOPRPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxwavesreverbpage.h ===
// DirectSoundFXWavesReverbPage.h : Declaration of the CDirectSoundFXWavesReverbPage

#ifndef __DIRECTSOUNDFXWAVESREVERBPAGE_H_
#define __DIRECTSOUNDFXWAVESREVERBPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXWavesReverbPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXWavesReverbPage
class ATL_NO_VTABLE CDirectSoundFXWavesReverbPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXWavesReverbPage, &CLSID_DirectSoundFXWavesReverbPage>,
    public IPropertyPageImpl<CDirectSoundFXWavesReverbPage>,
    public CDialogImpl<CDirectSoundFXWavesReverbPage>
{
public:
    CDirectSoundFXWavesReverbPage();

    enum {IDD = IDD_DIRECTSOUNDFXWAVESREVERBPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXWAVESREVERBPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXWavesReverbPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXWavesReverbPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXWavesReverbPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXWavesReverb> m_IDSFXWavesReverb;
    CSliderValue m_sliderInGain;
    CSliderValue m_sliderReverbMix;
    CSliderValue m_sliderReverbTime;
    CSliderValue m_sliderHighFreqRTRatio;
    Handler *m_rgpHandlers[5];
};

#endif //__DIRECTSOUNDFXWAVESREVERBPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxwavesreverbpage.cpp ===
// DirectSoundFXWavesReverbPage.cpp : Implementation of CDirectSoundFXWavesReverbPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXWavesReverbPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXWavesReverbPage

CDirectSoundFXWavesReverbPage::CDirectSoundFXWavesReverbPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXWavesReverbPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXWavesReverbPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXWavesReverbPage;

    m_rgpHandlers[0] = &m_sliderInGain;
    m_rgpHandlers[1] = &m_sliderReverbMix;
    m_rgpHandlers[2] = &m_sliderReverbTime;
    m_rgpHandlers[3] = &m_sliderHighFreqRTRatio;
    m_rgpHandlers[4] = NULL;
}

STDMETHODIMP CDirectSoundFXWavesReverbPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXWavesReverb, reinterpret_cast<void**>(&m_IDSFXWavesReverb));
    return hr;
}

STDMETHODIMP CDirectSoundFXWavesReverbPage::Apply(void)
{
    if (!m_IDSFXWavesReverb)
        return E_UNEXPECTED;

    DSFXWavesReverb dsfxwavesreverb;
    ZeroMemory(&dsfxwavesreverb, sizeof(DSFXWavesReverb));

    dsfxwavesreverb.fInGain = m_sliderInGain.GetValue();
    dsfxwavesreverb.fReverbMix = m_sliderReverbMix.GetValue();
    dsfxwavesreverb.fReverbTime = m_sliderReverbTime.GetValue();
    dsfxwavesreverb.fHighFreqRTRatio = m_sliderHighFreqRTRatio.GetValue();

    HRESULT hr = m_IDSFXWavesReverb->SetAllParameters(&dsfxwavesreverb);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXWavesReverbPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXWavesReverb)
        return 1;

    DSFXWavesReverb dsfxwavesreverb;
    ZeroMemory(&dsfxwavesreverb, sizeof(DSFXWavesReverb));
    m_IDSFXWavesReverb->GetAllParameters(&dsfxwavesreverb);

    m_sliderInGain.Init(GetDlgItem(IDC_SLIDER_InGain), GetDlgItem(IDC_EDIT_InGain), DSFX_WAVESREVERB_INGAIN_MIN, DSFX_WAVESREVERB_INGAIN_MAX, false);
    m_sliderInGain.SetValue(dsfxwavesreverb.fInGain);

    m_sliderReverbMix.Init(GetDlgItem(IDC_SLIDER_ReverbMix), GetDlgItem(IDC_EDIT_ReverbMix), DSFX_WAVESREVERB_REVERBMIX_MIN, DSFX_WAVESREVERB_REVERBMIX_MAX, false);
    m_sliderReverbMix.SetValue(dsfxwavesreverb.fReverbMix);

    m_sliderReverbTime.Init(GetDlgItem(IDC_SLIDER_ReverbTime), GetDlgItem(IDC_EDIT_ReverbTime), DSFX_WAVESREVERB_REVERBTIME_MIN, DSFX_WAVESREVERB_REVERBTIME_MAX, false);
    m_sliderReverbTime.SetValue(dsfxwavesreverb.fReverbTime);

    m_sliderHighFreqRTRatio.Init(GetDlgItem(IDC_SLIDER_HighFreqRTRatio), GetDlgItem(IDC_EDIT_HighFreqRTRatio), DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN, DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX, false);
    m_sliderHighFreqRTRatio.SetValue(dsfxwavesreverb.fHighFreqRTRatio);

    return 1;
}

LRESULT CDirectSoundFXWavesReverbPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <initguid.h>
#include <dsound.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsdmoprp.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLEDirectSoundFXChorusPage 101
#define IDS_HELPFILEDirectSoundFXChorusPage 102
#define IDS_DOCSTRINGDirectSoundFXChorusPage 103
#define IDR_DIRECTSOUNDFXCHORUSPAGE     104
#define IDD_DIRECTSOUNDFXCHORUSPAGE     105
#define IDS_TITLEDirectSoundFXCompressorPage 106
#define IDS_HELPFILEDirectSoundFXCompressorPage 107
#define IDS_DOCSTRINGDirectSoundFXCompressorPage 108
#define IDR_DIRECTSOUNDFXCOMPRESSORPAGE 109
#define IDD_DIRECTSOUNDFXCOMPRESSORPAGE 110
#define IDS_TITLEDirectSoundFXDistortionPage 111
#define IDS_HELPFILEDirectSoundFXDistortionPage 112
#define IDS_DOCSTRINGDirectSoundFXDistortionPage 113
#define IDR_DIRECTSOUNDFXDISTORTIONPAGE 114
#define IDD_DIRECTSOUNDFXDISTORTIONPAGE 115
#define IDS_TITLEDirectSoundFXEchoPage  116
#define IDS_HELPFILEDirectSoundFXEchoPage 117
#define IDS_DOCSTRINGDirectSoundFXEchoPage 118
#define IDR_DIRECTSOUNDFXECHOPAGE       119
#define IDD_DIRECTSOUNDFXECHOPAGE       120
#define IDS_TITLEDirectSoundFXFlangerPage 121
#define IDS_HELPFILEDirectSoundFXFlangerPage 122
#define IDS_DOCSTRINGDirectSoundFXFlangerPage 123
#define IDR_DIRECTSOUNDFXFLANGERPAGE    124
#define IDD_DIRECTSOUNDFXFLANGERPAGE    125
#define IDS_TITLEDirectSoundFXParamEqPage 126
#define IDS_HELPFILEDirectSoundFXParamEqPage 127
#define IDS_DOCSTRINGDirectSoundFXParamEqPage 128
#define IDR_DIRECTSOUNDFXPARAMEQPAGE    129
#define IDD_DIRECTSOUNDFXPARAMEQPAGE    130
#define IDS_TITLEDirectSoundFXGarglePage 131
#define IDS_HELPFILEDirectSoundFXGarglePage 132
#define IDS_DOCSTRINGDirectSoundFXGarglePage 133
#define IDR_DIRECTSOUNDFXGARGLEPAGE     134
#define IDD_DIRECTSOUNDFXGARGLEPAGE     135
#define IDS_TITLEDirectSoundFXWavesReverbPage 136
#define IDS_HELPFILEDirectSoundFXWavesReverbPage 137
#define IDS_DOCSTRINGDirectSoundFXWavesReverbPage 138
#define IDR_DIRECTSOUNDFXWAVESREVERBPAGE 139
#define IDD_DIRECTSOUNDFXWAVESREVERBPAGE 140
#define IDS_TITLEDirectSoundFXI3DL2SourcePage 141
#define IDS_HELPFILEDirectSoundFXI3DL2SourcePage 142
#define IDS_DOCSTRINGDirectSoundFXI3DL2SourcePage 143
#define IDR_DIRECTSOUNDFXI3DL2SOURCEPAGE 144
#define IDD_DIRECTSOUNDFXI3DL2SOURCEPAGE 145
#define IDS_TITLEDirectSoundFXI3DL2ReverbPage 146
#define IDS_HELPFILEDirectSoundFXI3DL2ReverbPage 147
#define IDS_DOCSTRINGDirectSoundFXI3DL2ReverbPage 148
#define IDR_DIRECTSOUNDFXI3DL2REVERBPAGE 149
#define IDD_DIRECTSOUNDFXI3DL2REVERBPAGE 150
#define IDC_SLIDER_WetDryMix            201
#define IDC_EDIT_WetDryMix              202
#define IDC_SLIDER_Phase                203
#define IDC_EDIT_Phase                  204
#define IDC_RADIO_SIN                   205
#define IDC_RADIO_TRIANGLE              206
#define IDC_EDIT_Depth                  207
#define IDC_SLIDER_Depth                208
#define IDC_EDIT_Feedback               209
#define IDC_SLIDER_Feedback             210
#define IDC_EDIT_Gain                   210
#define IDC_EDIT_Frequency              211
#define IDC_SLIDER_Gain                 211
#define IDC_SLIDER_Frequency            212
#define IDC_EDIT_Edge                   212
#define IDC_EDIT_Bandwidth              212
#define IDC_EDIT_ReverbMix              212
#define IDC_EDIT_DirectHF               212
#define IDC_EDIT_Delay                  213
#define IDC_EDIT_Attack                 213
#define IDC_SLIDER_Edge                 213
#define IDC_SLIDER_Bandwidth            213
#define IDC_SLIDER_ReverbMix            213
#define IDC_SLIDER_DirectHF             213
#define IDC_SLIDER_Delay                214
#define IDC_EDIT_PostEQCenterFrequency  214
#define IDC_EDIT_ReverbTime             214
#define IDC_EDIT_Room                   214
#define IDC_SLIDER_PostEQCenterFrequency 215
#define IDC_SLIDER_ReverbTime           215
#define IDC_SLIDER_Room                 215
#define IDC_SLIDER_Attack               216
#define IDC_EDIT_PostEQBandwidth        216
#define IDC_RADIO_PANNED                216
#define IDC_EDIT_HighFreqRTRatio        216
#define IDC_EDIT_RoomHF                 216
#define IDC_SLIDER_PostEQBandwidth      217
#define IDC_RADIO_NOTPANNED             217
#define IDC_SLIDER_HighFreqRTRatio      217
#define IDC_SLIDER_RoomHF               217
#define IDC_EDIT_PreLowpassCutoff       218
#define IDC_EDIT_RoomRolloffFactor      218
#define IDC_SLIDER_PreLowpassCutoff     219
#define IDC_SLIDER_RoomRolloffFactor    219
#define IDC_EDIT_Release                220
#define IDC_EDIT_Center                 220
#define IDC_EDIT_Obstruction            220
#define IDC_SLIDER_Release              221
#define IDC_SLIDER_Center               221
#define IDC_SLIDER_Obstruction          221
#define IDC_EDIT_LeftDelay              222
#define IDC_EDIT_Rate                   222
#define IDC_EDIT_ObstructionLFRatio     222
#define IDC_SLIDER_LeftDelay            223
#define IDC_SLIDER_Rate                 223
#define IDC_SLIDER_ObstructionLFRatio   223
#define IDC_EDIT_Threshold              224
#define IDC_EDIT_RightDelay             224
#define IDC_RADIO_SQUARE                224
#define IDC_EDIT_Occlusion              224
#define IDC_SLIDER_Threshold            225
#define IDC_SLIDER_RightDelay           225
#define IDC_EDIT_InGain                 225
#define IDC_SLIDER_Occlusion            225
#define IDC_EDIT_Ratio                  226
#define IDC_SLIDER_InGain               226
#define IDC_EDIT_OcclusionLFRatio       226
#define IDC_SLIDER_Ratio                227
#define IDC_SLIDER_OcclusionLFRatio     227
#define IDC_EDIT_Direct                 228
#define IDC_SLIDER_Direct               229
#define IDC_EDIT_Predelay               230
#define IDC_SLIDER_Predelay             231
#define IDC_EDIT_CompMeterReset         232
#define IDC_RADIO_LPF                   232
#define IDC_SLIDER_CompMeterReset       233
#define IDC_RADIO_VOLUME                233
#define IDC_EDIT_CompInputMeter         234
#define IDC_SLIDER_CompInputMeter       235
#define IDC_PRESET                      235
#define IDC_EDIT_CompGainMeter          236
#define IDC_EDIT_DecayTime              236
#define IDC_SLIDER_CompGainMeter        237
#define IDC_SLIDER_DecayTime            237
#define IDC_EDIT_DecayHFRatio           238
#define IDC_SLIDER_DecayHFRatio         239
#define IDC_EDIT_Reflections            240
#define IDC_SLIDER_Reflections          241
#define IDC_EDIT_ReflectionsDelay       242
#define IDC_SLIDER_ReflectionsDelay     243
#define IDC_EDIT_Reverb                 244
#define IDC_SLIDER_Reverb               245
#define IDC_EDIT_ReverbDelay            246
#define IDC_SLIDER_ReverbDelay          247
#define IDC_EDIT_Diffusion              250
#define IDC_SLIDER_Diffusion            251
#define IDC_EDIT_Density                252
#define IDC_SLIDER_Density              253
#define IDC_EDIT_HFReference            254
#define IDC_SLIDER_HFReference          255
#define IDC_EDIT_Quality                256
#define IDC_SLIDER_Quality              257
#define IDS_PRESETDefault               500
#define IDS_PRESETGeneric               501
#define IDS_PRESETPaddedCell            502
#define IDS_PRESETRoom                  503
#define IDS_PRESETBathroom              504
#define IDS_PRESETLivingRoom            505
#define IDS_PRESETStoneRoom             506
#define IDS_PRESETAuditorium            507
#define IDS_PRESETConcertHall           508
#define IDS_PRESETCave                  509
#define IDS_PRESETArena                 510
#define IDS_PRESETHangar                511
#define IDS_PRESETCarpetedHallway       512
#define IDS_PRESETHallway               513
#define IDS_PRESETStoneCorridor         514
#define IDS_PRESETAlley                 515
#define IDS_PRESETForest                516
#define IDS_PRESETCity                  517
#define IDS_PRESETMountains             518
#define IDS_PRESETQuarry                519
#define IDS_PRESETPlain                 520
#define IDS_PRESETParkingLot            521
#define IDS_PRESETSewerPipe             522
#define IDS_PRESETUnderWater            523
#define IDS_PRESETSmallRoom             524
#define IDS_PRESETMediumRoom            525
#define IDS_PRESETLargeRoom             526
#define IDS_PRESETMediumHall            527
#define IDS_PRESETLargeHall             528
#define IDS_PRESETPlate                 529

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         236
#define _APS_NEXT_SYMED_VALUE           151
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\sources.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!ifndef DXROOT
DXROOT = $(BASEDIR)\multimedia\directx
!endif

!include $(DXROOT)\project.mk
!include ..\..\buildmode.inc
	
MAJORCOMP  = windows
MINORCOMP  = directx

TARGETNAME = dsdmoprp
TARGETTYPE = DYNLINK
TARGETPATH = $(_OBJ_DIR)
UMTYPE     = windows
DLLDEF     = ..\dsdmoprp.def
DLLENTRY   = _DllMainCRTStartup

USE_MSVCRT = 1
USE_MAPSYM = 1

ATL_VER    = 30
USE_STATIC_ATL = 1


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Od

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif


# 04/11/2000 - allows for addition of BoundsChecker, etc 
# libs specified in the OS environment

TARGETLIBS=$(TARGETLIBS) \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\gdi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\oleaut32.lib \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
    $(BASEDIR)\public\sdk\lib\*\user32.lib      \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib		\
    $(BASEDIR)\public\sdk\lib\*\advapi32.lib 

INCLUDES = $(PROJECT_INC_PATH);\
           $(DXROOT)\inc;\
           $(BASEDIR)\public\sdk\inc

SOURCES=\
    dsdmoprp.idl                      \
    dsdmoprp.cpp                      \
    dsdmoprp.rc                       \
    StdAfx.cpp                        \
    ControlHelp.cpp                   \
    DirectSoundFXChorusPage.cpp       \
    DirectSoundFXCompressorPage.cpp   \
    DirectSoundFXDistortionPage.cpp   \
    DirectSoundFXEchoPage.cpp         \
    DirectSoundFXFlangerPage.cpp      \
    DirectSoundFXGarglePage.cpp       \
    DirectSoundFXParamEqPage.cpp      \
    DirectSoundFXWavesReverbPage.cpp  \
    DirectSoundFXI3DL2ReverbPage.cpp

#   DirectSoundFXI3DL2SourcePage.cpp

NTTARGETFILE0 = buildidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AE61EBE6_B69A_44B5_A468_E1BE7AF28509__INCLUDED_)
#define AFX_STDAFX_H__AE61EBE6_B69A_44B5_A468_E1BE7AF28509__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <mmsystem.h> //  I have to put this here or dsound includes fail.

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AE61EBE6_B69A_44B5_A468_E1BE7AF28509__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsdmoprp\bchecker\makefile.inc ===
buildidl : $(O)\dsdmoprp.h

$(O)\dsdmoprp.h : dsdmoprp.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\dsdmoprp.h \
    -tlb     $O\dsdmoprp.tlb \
    -iid     $O\dsdmoprp_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\dsdmoprp_p.c  \
    dsdmoprp.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\capteff.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        capteff.h
 *  Content:     Declaration of CCaptureEffect and CCaptureEffectChain.
 *  Description: Capture effects support. More info in capteff.cpp.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 04/19/00  jstokes  Cloned from effects.h
 *
 ***************************************************************************/

#ifndef __CAPTEFF_H__
#define __CAPTEFF_H__

#ifdef __cplusplus

#include "mediaobj.h"   // For DMO_MEDIA_TYPE
#include "kshlp.h"      // For KSNODE


//
// Class representing DirectSound audio capture effect instances
//

class CCaptureEffect : public CDsBasicRuntime
{
    friend class CKsTopology;

public:
    CCaptureEffect(DSCEFFECTDESC& fxDescriptor);
    ~CCaptureEffect();
    HRESULT Initialize(DMO_MEDIA_TYPE& dmoMediaType);

    DSCEFFECTDESC               m_fxDescriptor;         // Creation parameters
    IMediaObject*               m_pMediaObject;         // The DMO's standard interface
    IDirectSoundDMOProxy*       m_pDMOProxy;            // The DMO's proxy interface
    DWORD                       m_fxStatus;             // Current effect status

    // Only used if the effect is implemented by a KS filter:
    KSNODE                      m_ksNode;               // KS node controlling the effect 
};


//
// The DirectSound capture effects chain class
//

class CCaptureEffectChain
{
    friend class CKsCaptureDevice;
    friend class CKsTopology;

public:
    CCaptureEffectChain(CDirectSoundCaptureBuffer* pBuffer);
    ~CCaptureEffectChain();

    HRESULT Initialize          (DWORD dwFxCount, LPDSCEFFECTDESC pFxDesc);
    HRESULT GetFxStatus         (LPDWORD pdwResultCodes);
    HRESULT GetEffectInterface  (REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID* ppObject);

    // Public accessors
    DWORD GetFxCount()          {return m_fxList.GetNodeCount();}
    BOOL NeedsMicrosoftAEC();

private:
    // Effects processing state
    CObjectList<CCaptureEffect> m_fxList;      // Capture effect object list
    WAVEFORMATEX                m_waveFormat;  // Format of audio data to be processed
};

#endif // __cplusplus
#endif // __CAPTEFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\capteff.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        capteff.cpp
 *
 *  Content:     Implementation of CCaptureEffect and CCaptureEffectChain.
 *
 *  Description: These classes support effects processing on captured audio.
 *               They are somewhat analogous to the render effect classes in
 *               but the model for capture effects is very different: render
 *               effects are only processed by DirectX Media Objects (DMOs),
 *               in user mode, whereas capture effects are processed by KS
 *               filters, in kernel mode and/or hardware, and DMOs are only
 *               used as placeholders for the KS filters.  Hence this file
 *               is mercifully simpler than effects.cpp.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 04/19/00  jstokes  Created
 * 01/30/01  duganp   Removed some vestigial DMO-handling code left over
 *                    from when this file was cloned from effects.cpp
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <uuids.h>   // For MEDIATYPE_Audio, MEDIASUBTYPE_PCM and FORMAT_WaveFormatEx


/***************************************************************************
 *
 *  CCaptureEffect::CCaptureEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffect::CCaptureEffect"

CCaptureEffect::CCaptureEffect(DSCEFFECTDESC& fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCaptureEffect);

    // Initialize defaults
    ASSERT(m_pMediaObject == NULL);
    ASSERT(m_pDMOProxy == NULL);
    m_fxStatus = DSCFXR_UNALLOCATED;
    m_ksNode.NodeId = NODE_UNINITIALIZED;
    m_ksNode.CpuResources = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;

    // Keep local copy of our effect description structure
    m_fxDescriptor = fxDescriptor;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffect::~CCaptureEffect
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffect::~CCaptureEffect"

CCaptureEffect::~CCaptureEffect(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCaptureEffect);

    // During shutdown, if the buffer hasn't been freed, these calls can
    // cause an access violation because the DMO DLL has been unloaded.
    try
    {
        RELEASE(m_pDMOProxy);
        RELEASE(m_pMediaObject);
    }
    catch (...) {}

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffect::Initialize
 *
 *  Description:
 *      Create the DirectX Media Object corresponding to this effect.
 *
 *  Arguments:
 *      DMO_MEDIA_TYPE* [in]: Information (wave format, etc.) used to
 *                            initialize our contained DMO.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffect::Initialize"

HRESULT CCaptureEffect::Initialize(DMO_MEDIA_TYPE& dmoMediaType)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    hr = CoCreateInstance(m_fxDescriptor.guidDSCFXInstance, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pMediaObject);

    if (SUCCEEDED(hr))
        hr = m_pMediaObject->QueryInterface(IID_IDirectSoundDMOProxy, (void**)&m_pDMOProxy);

    if (SUCCEEDED(hr))
        hr = m_pMediaObject->SetInputType(0, &dmoMediaType, 0);

    if (SUCCEEDED(hr))
        hr = m_pMediaObject->SetOutputType(0, &dmoMediaType, 0);

    // Save the effect creation status for future reference
    m_fxStatus = SUCCEEDED(hr)              ? DSCFXR_UNALLOCATED :
                 hr == REGDB_E_CLASSNOTREG  ? DSCFXR_UNKNOWN     :
                 DSCFXR_FAILED;

    if (FAILED(hr))
    {
        RELEASE(m_pDMOProxy);
        RELEASE(m_pMediaObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::CCaptureEffectChain
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::CCaptureEffectChain"

CCaptureEffectChain::CCaptureEffectChain(CDirectSoundCaptureBuffer* pBuffer)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCaptureEffectChain);

    // Get our owning buffer's audio data format
    DWORD dwWfxSize = sizeof m_waveFormat;
    HRESULT hr = pBuffer->GetFormat(&m_waveFormat, &dwWfxSize);
    ASSERT(SUCCEEDED(hr));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffectChain::~CCaptureEffectChain
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::~CCaptureEffectChain"

CCaptureEffectChain::~CCaptureEffectChain(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCaptureEffectChain);

    // m_fxList's destructor takes care of releasing our CCaptureEffect objects

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffectChain::Initialize
 *
 *  Description:
 *      Initializes the effects chain with the effects requested.
 *
 *  Arguments:
 *      DWORD [in]: Number of effects requested
 *      LPDSCEFFECTDESC [in]: Pointer to effect description structures
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::Initialize"

HRESULT CCaptureEffectChain::Initialize(DWORD dwFxCount, LPDSCEFFECTDESC pFxDesc)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(dwFxCount > 0);
    CHECK_READ_PTR(pFxDesc);

    DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = m_waveFormat.wBitsPerSample == 16 ? 2 : 1;
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(&m_waveFormat);

    for (DWORD i=0; i<dwFxCount && SUCCEEDED(hr); ++i)
    {
        CCaptureEffect* pEffect = NEW(CCaptureEffect(pFxDesc[i]));
        hr = HRFROMP(pEffect);

        if (SUCCEEDED(hr))
            hr = pEffect->Initialize(dmt);

        if (SUCCEEDED(hr))
            m_fxList.AddNodeToList(pEffect);

        RELEASE(pEffect);  // It's managed by m_fxList now
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::GetFxStatus
 *
 *  Description:
 *      Obtains the HW/SW location flags for the current effect chain.
 *
 *  Arguments:
 *      DWORD* [out]: Receives the location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::GetFxStatus"

HRESULT CCaptureEffectChain::GetFxStatus(LPDWORD pdwResultCodes)
{
    DPF_ENTER();
    ASSERT(IS_VALID_WRITE_PTR(pdwResultCodes, GetFxCount() * sizeof(DWORD)));

    DWORD n = 0;
    for (CNode<CCaptureEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pdwResultCodes[n++] = pFxNode->m_data->m_fxStatus;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::GetEffectInterface
 *
 *  Description:
 *      Searches the effect chain for an effect with a given COM CLSID and
 *      interface IID at a given index; returns a pointer to the interface.
 *
 *  Arguments:
 *      REFGUID [in]: CLSID required, or GUID_All_Objects for any CLSID.
 *      DWORD [in]: Index N of effect desired.  If the first argument was
 *                  GUID_All_Objects, we will return the Nth effect in the
 *                  chain; and if it was a specific CLSID, we return the
 *                  Nth effect with that CLSID.
 *      REFGUID [in]: Interface to query for from the selected effect.
 *      VOID** [out]: Receives a pointer to the requested COM interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::GetEffectInterface"

HRESULT CCaptureEffectChain::GetEffectInterface(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DMUS_E_NOT_FOUND;
    DPF_ENTER();

    DWORD count = 0;
    for (CNode<CCaptureEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        if (pFxNode->m_data->m_fxDescriptor.guidDSCFXClass == guidObject)
            if (count++ == dwIndex)
                break;

    if (pFxNode)
        hr = pFxNode->m_data->m_pMediaObject->QueryInterface(iidInterface, (void**)ppObject);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::NeedsMicrosoftAEC
 *
 *  Description:
 *      Determines whether this effect chain contains any of the Microsoft
 *      full-duplex effects (AEC, AGC, NC), and therefore requires a
 *      sysaudio graph with MS AEC enabled.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if we have a Microsoft full-duplex effect.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::NeedsMicrosoftAEC"

BOOL CCaptureEffectChain::NeedsMicrosoftAEC()
{
    BOOL fNeedsAec = FALSE;
    DPF_ENTER();

    for (CNode<CCaptureEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode && !fNeedsAec; pFxNode = pFxNode->m_pNext)
        if (pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance == GUID_DSCFX_MS_AEC ||
            pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance == GUID_DSCFX_MS_NS  ||
            pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance == GUID_DSCFX_MS_AGC)
            fNeedsAec = TRUE;

    DPF_LEAVE(fNeedsAec);
    return fNeedsAec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created
 *  1999-2001   duganp  Fixes, changes, enhancements
 *
 ***************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef DEBUG
#undef DBG
#endif

// Disable empty controlled statement warnings for our macros
#pragma warning(disable:4390)

typedef struct _DEBUGINFO
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA Data;
    HANDLE                                   hLogFile;
} DEBUGINFO, *LPDEBUGINFO;

// Longest DPF message size allowed after expansion
#define MAX_DPF_MESSAGE             0x200

#define DPFLVLMASK                  0x000000FFUL
#define NEWDPFLVL(a)                (~DPFLVLMASK | (BYTE)(a))
#define OLDDPFLVL(a)                (DPFLVLMASK & (BYTE)(a))

#define HOLYCOW                     "******************************************************************************"
#define CRLF                        "\r\n"
                                    
#define DPFLVL_ABSOLUTE             NEWDPFLVL(0)    // Disregard level
#define DPFLVL_ERROR                NEWDPFLVL(1)    // Errors
#define DPFLVL_WARNING              NEWDPFLVL(2)    // Warnings
#define DPFLVL_INFO                 NEWDPFLVL(3)    // General info
#define DPFLVL_MOREINFO             NEWDPFLVL(4)    // More info
#define DPFLVL_API                  NEWDPFLVL(5)    // API/Interface method calls
#define DPFLVL_BUSYAPI              NEWDPFLVL(6)    // Very frequent interface calls
#define DPFLVL_LOCK                 NEWDPFLVL(7)    // Lock, lock, who's got the lock?
#define DPFLVL_ENTER                NEWDPFLVL(8)    // Function enter/leave
#define DPFLVL_CONSTRUCT            NEWDPFLVL(9)    // Object con/destruction

#define DPF_GUID_STRING             "{%8.8lX-%4.4X-%4.4X-%2.2X%2.2X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X}"
#define DPF_GUID_VAL(guid)          (guid).Data1, (guid).Data2, (guid).Data3, (guid).Data4[0], (guid).Data4[1], (guid).Data4[2], (guid).Data4[3], (guid).Data4[4], (guid).Data4[5], (guid).Data4[6], (guid).Data4[7]

#undef DPF_FNAME
#define DPF_FNAME                   NULL

#ifdef ASSERT
#undef ASSERT  // Some headers (e.g. ntrtl.h) define ASSERTs which conflict with ours
#endif

#ifdef RDEBUG
    #define DPFINIT()               dopen(NULL)
    #define DPFCLOSE()              dclose()
    #define RPF                     DPRINTF
#else // RDEBUG
    #pragma warning(disable:4002)
    #define DPFINIT() 
    #define DPFCLOSE()
    #define RPF()
#endif // RDEBUG

#ifdef DEBUG
    #define DPF                     DPRINTF
    #define DPRINTF                 g_pszDbgFname = DPF_FNAME, g_pszDbgFile = __FILE__, g_nDbgLine = __LINE__, dprintf
    #define DSASSERT(a)             DPRINTF(DPFLVL_ABSOLUTE, CRLF HOLYCOW CRLF "Assertion failed in %s, line %u: %s" CRLF HOLYCOW, TEXT(__FILE__), __LINE__, TEXT(a))
    #ifdef USE_INLINE_ASM
        #define ASSERT(a)           do if (!(a)) {DSASSERT(#a); __asm {int 3}} while (0)
        #define BREAK()             do __asm {int 3} while (0)
    #else
        #define ASSERT(a)           do if (!(a)) {DSASSERT(#a); DebugBreak();} while (0)
        #define BREAK()             DebugBreak()
    #endif
#else // DEBUG
    #pragma warning(disable:4002)
    #define DPF()
    #define DPRINTF                 dprintf
    #define ASSERT(a)
    #define BREAK()
#endif // DEBUG

#define DPF_API0(a)                         DPF(DPFLVL_API, #a)
#define DPF_API1(a,b)                       DPF(DPFLVL_API, #a ": " #b "=0x%p", DWORD_PTR(b))
#define DPF_API2(a,b,c)                     DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p", DWORD_PTR(b), DWORD_PTR(c))
#define DPF_API3(a,b,c,d)                   DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d))
#define DPF_API4(a,b,c,d,e)                 DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e))
#define DPF_API5(a,b,c,d,e,f)               DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f))
#define DPF_API6(a,b,c,d,e,f,g)             DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g))
#define DPF_API7(a,b,c,d,e,f,g,h)           DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h))
#define DPF_API8(a,b,c,d,e,f,g,h,i)         DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p, " #i "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h), DWORD_PTR(i))
#define DPF_API9(a,b,c,d,e,f,g,h,i,j)       DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p, " #i "=0x%p, " #j "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h), DWORD_PTR(i), DWORD_PTR(j))
#define DPF_API10(a,b,c,d,e,f,g,h,i,j,k)    DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p, " #i "=0x%p, " #j "=0x%p, " #k "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h), DWORD_PTR(i), DWORD_PTR(j), DWORD_PTR(k))

#define DPF_CONSTRUCT(a)            DPF(DPFLVL_CONSTRUCT, "Constructing " #a " at 0x%p", this)
#define DPF_DESTRUCT(a)             DPF(DPFLVL_CONSTRUCT, "Destroying " #a " at 0x%p", this)

#define DPF_ENTER()                 DPF(DPFLVL_ENTER, "Enter")
#define DPF_LEAVE(a)                DPF(DPFLVL_ENTER, "Leave, returning 0x%p", (DWORD_PTR)(a))
#define DPF_LEAVE_VOID()            DPF(DPFLVL_ENTER, "Leave")
#define DPF_LEAVE_HRESULT(hr)       DPF(DPFLVL_ENTER, "Leave, returning %s", HRESULTtoSTRING(hr))
#define DPF_API_LEAVE(a)            DPF(DPFLVL_API, "Leave, returning 0x%p", (DWORD_PTR)(a))
#define DPF_API_LEAVE_VOID()        DPF(DPFLVL_API, "Leave")
#define DPF_API_LEAVE_HRESULT(hr)   DPF(DPFLVL_API, "Leave, returning %s", HRESULTtoSTRING(hr))

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DEBUGINFO g_dinfo;
#ifdef DEBUG
extern LPCSTR g_pszDbgFname;
extern LPCSTR g_pszDbgFile;
extern UINT g_nDbgLine;
#endif

extern void dopen(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *);
extern void dclose(void);
extern void dprintf(DWORD, LPCSTR, ...);

extern PTSTR StateName(DWORD dwState);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\decibels.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       decibels.h
 *  Content:    Decibel helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/13/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DECIBELS_H__
#define __DECIBELS_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DWORD DBToAmpFactor(LONG);
extern LONG AmpFactorToDB(DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DECIBELS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\debug.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.c
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created.
 *  1999-2001   duganp  Fixes, changes, enhancements
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <stdio.h>          // For sprintf(), vsprintf() and vswprintf()
#include <tchar.h>          // For _stprintf()

// This entire file is conditional on RDEBUG being defined
#ifdef RDEBUG

#ifndef DPF_LIBRARY
#define DPF_LIBRARY         "DSOUND"
#endif

DEBUGINFO                   g_dinfo;
BOOL                        g_fDbgOpen;

// Variables only used when detailed DEBUG output is enabled
#ifdef DEBUG
LPCSTR                      g_pszDbgFname;
LPCSTR                      g_pszDbgFile;
UINT                        g_nDbgLine;
#endif

/***************************************************************************
 *
 *  dstrcpy
 *
 *  Description:
 *      Copies one string to another.
 *
 *  Arguments:
 *      LPSTR [in/out]: destination string.
 *      LPCSTR [in]: source string.
 *
 *  Returns:  
 *      LPSTR: pointer to the end of the string.
 *
 ***************************************************************************/

LPSTR dstrcpy(LPSTR dst, LPCSTR src)
{
    while (*dst++ = *src++);
    return dst-1;
}


/***************************************************************************
 *
 *  dopen
 *
 *  Description:
 *      Initializes the debugger.
 *
 *  Arguments:
 *      DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA * [in]: optional debug 
 *                                                       information.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dopen(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *pData)
{
    HKEY                    hkey;
    HRESULT                 hr;

    // Free any current settings
    dclose();

    // Initialize data
    if (pData)
        CopyMemory(&g_dinfo.Data, pData, sizeof(*pData));
    else
    {
        ZeroMemory(&g_dinfo, sizeof(g_dinfo));
        g_dinfo.Data.Flags = DIRECTSOUNDDEBUG_DPFINFOF_DEFAULT;
        g_dinfo.Data.DpfLevel = DIRECTSOUNDDEBUG_DPFLEVEL_DEFAULT;
        g_dinfo.Data.BreakLevel = DIRECTSOUNDDEBUG_BREAKLEVEL_DEFAULT;
    }

    // Get registry data
    if (pData)
        hr = RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND | REGOPENPATH_ALLOWCREATE, 1, REGSTR_DEBUG);
    else
        hr = RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, REGSTR_DEBUG);

    if (SUCCEEDED(hr))
    {
        if (pData)
        {
            RhRegSetBinaryValue(hkey, REGSTR_FLAGS, &g_dinfo.Data.Flags, sizeof(g_dinfo.Data.Flags));
            RhRegSetBinaryValue(hkey, REGSTR_DPFLEVEL, &g_dinfo.Data.DpfLevel, sizeof(g_dinfo.Data.DpfLevel));
            RhRegSetBinaryValue(hkey, REGSTR_BREAKLEVEL, &g_dinfo.Data.BreakLevel, sizeof(g_dinfo.Data.BreakLevel));
            RhRegSetStringValue(hkey, REGSTR_LOGFILE, g_dinfo.Data.LogFile);
        }
        else
        {
            RhRegGetBinaryValue(hkey, REGSTR_FLAGS, &g_dinfo.Data.Flags, sizeof(g_dinfo.Data.Flags));
            RhRegGetBinaryValue(hkey, REGSTR_DPFLEVEL, &g_dinfo.Data.DpfLevel, sizeof(g_dinfo.Data.DpfLevel));
            RhRegGetBinaryValue(hkey, REGSTR_BREAKLEVEL, &g_dinfo.Data.BreakLevel, sizeof(g_dinfo.Data.BreakLevel));
            RhRegGetStringValue(hkey, REGSTR_LOGFILE, g_dinfo.Data.LogFile, sizeof(g_dinfo.Data.LogFile));
            if (g_dinfo.Data.DpfLevel < g_dinfo.Data.BreakLevel)
                g_dinfo.Data.DpfLevel = g_dinfo.Data.BreakLevel;
        }
        RhRegCloseKey(&hkey);
    }

#ifdef DEBUG

    // Open the log file
    if (g_dinfo.Data.LogFile[0])
    {
        DWORD dwFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

        // It's only practical to write every trace message direct to disk
        // at debug levels lower than DPFLVL_API:
        if (NEWDPFLVL(g_dinfo.Data.DpfLevel) < DPFLVL_API)
            dwFlags |= FILE_FLAG_WRITE_THROUGH;
            
        g_dinfo.hLogFile = CreateFile(g_dinfo.Data.LogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, dwFlags, NULL);
    }
    if (IsValidHandleValue(g_dinfo.hLogFile))
        MakeHandleGlobal(&g_dinfo.hLogFile);

#endif // DEBUG

    g_fDbgOpen = TRUE;
}


/***************************************************************************
 *
 *  dclose
 *
 *  Description:
 *      Uninitializes the debugger.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dclose(void)
{
    if (!g_fDbgOpen)
        return;
    
#ifdef DEBUG

    // Close the log file
    CLOSE_HANDLE(g_dinfo.hLogFile);

#endif // DEBUG

    g_fDbgOpen = FALSE;
}


/***************************************************************************
 *
 *  dprintf
 *
 *  Description:
 *      Writes a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: debug level.  String will only print if this level is
 *                  less than or equal to the global level.
 *      LPCSTR [in]: string.
 *      ... [in]: optional string modifiers.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dprintf(DWORD dwLevel, LPCSTR pszFormat, ...)
{
    const BOOL              fNewDpf = MAKEBOOL(dwLevel & ~DPFLVLMASK);
    CHAR                    szMessage[MAX_DPF_MESSAGE];
    LPSTR                   pszString = szMessage;
    DWORD                   dwWritten;
    va_list                 va;
    
    // Bail out early if we have nothing to do
    if (OLDDPFLVL(dwLevel) > g_dinfo.Data.DpfLevel)
        return;

    // Build up the trace message; start with the library name
    pszString = dstrcpy(pszString, DPF_LIBRARY ": ");

#ifdef DEBUG

    // Add process and thread ID
    if (g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID)
        pszString += sprintf(pszString, "PID=%lx TID=%lx: ", GetCurrentProcessId(), GetCurrentThreadId());

    // Add the source file and line number
    if (g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE)
        pszString += sprintf(pszString, "%s:%lu: ", g_pszDbgFile, g_nDbgLine);

    // Add the function name
    if (fNewDpf && (g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME) && dwLevel != DPFLVL_BUSYAPI)
        pszString += sprintf(pszString, "%s: ", g_pszDbgFname);

#endif // DEBUG

    // Add the type of message this is (i.e. error or warning), but only if the
    // dpf level was specified in terms of DPFLVL_*.  This will prevent confusion
    // in old code that uses raw numbers instead of DPFLVL macros.
    switch (dwLevel)
    {
        case DPFLVL_ERROR:
            pszString = dstrcpy(pszString, "Error: ");
            break;

        case DPFLVL_WARNING:
            pszString = dstrcpy(pszString, "Warning: ");
            break;

        case DPFLVL_API:
            pszString = dstrcpy(pszString, "API call: ");
            break;
    }

    // Format the string
    va_start(va, pszFormat);
#ifdef UNICODE
    {
        TCHAR szTcharMsg[MAX_DPF_MESSAGE];
        TCHAR szTcharFmt[MAX_DPF_MESSAGE];
        AnsiToTchar(szMessage, szTcharMsg, MAX_DPF_MESSAGE);
        AnsiToTchar(pszFormat, szTcharFmt, MAX_DPF_MESSAGE);
        vswprintf(szTcharMsg + lstrlen(szTcharMsg), szTcharFmt, va);
        TcharToAnsi(szTcharMsg, szMessage, MAX_DPF_MESSAGE);
    }
#else
        vsprintf(pszString, pszFormat, va);
#endif
    va_end(va);
    strcat(pszString, CRLF);

    // Output to the debugger
    if (!(g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_LOGTOFILEONLY))
        OutputDebugStringA(szMessage);

#ifdef DEBUG
    // Write to the log file
    if (IsValidHandleValue(g_dinfo.hLogFile))
        WriteFile(g_dinfo.hLogFile, szMessage, strlen(szMessage), &dwWritten, NULL);      
#endif // DEBUG

    // Break into the debugger if required
    if (fNewDpf && g_dinfo.Data.BreakLevel && OLDDPFLVL(dwLevel) <= g_dinfo.Data.BreakLevel)
        BREAK();
}


/***************************************************************************
 *
 *  StateName
 *
 *  Description:
 *      Translates a combination of VAD_BUFFERSTATE flags into a string.
 *
 *  Arguments:
 *      DWORD [in]: Combination of VAD_BUFFERSTATE flags.
 *
 *  Returns:  
 *      PTSTR [out]: Pointer to static string containing the result.
 *
 ***************************************************************************/

PTSTR StateName(DWORD dwState)
{
    static TCHAR szState[100];

    if (dwState == VAD_BUFFERSTATE_STOPPED)
    {
        _stprintf(szState, TEXT("STOPPED"));
    }
    else
    {
        _stprintf(szState, TEXT("%s%s%s%s%s%s%s"),
                (dwState & VAD_BUFFERSTATE_STARTED) ? TEXT("STARTED ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_LOOPING) ? TEXT("LOOPING ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_WHENIDLE) ? TEXT("WHENIDLE ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_INFOCUS) ? TEXT("INFOCUS ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_OUTOFFOCUS) ? TEXT("OUTOFFOCUS ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_LOSTCONSOLE) ? TEXT("LOSTCONSOLE ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_SUSPEND) ? TEXT("SUSPEND") : TEXT(""));
    }

    return szState;
}

#endif // RDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\decibels.c ===
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;
#include "dsoundi.h"

#ifndef Not_VxD
#pragma warning(disable:4002)
#undef DPF
#define DPF()
#endif

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
DWORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    };

;

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    // input lDB is 100ths of decibels

    // REMIND hack to make mixer code work- it only handles 16-bit factors and
    //  cannot amplify
    if (0 <= lDB) return 0x0000FFFF;
    
    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB+5)/10;		    // scaled to 1/10th dB units
    
    if (lDB > -1)   lDB = -1;	    // upper boundary
    if (lDB < -964) lDB = -964;	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index.
    ASSERT(lDB >= 0);
    ASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));
    
    dwFactor = tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

// Note, could use DirectSound3D's fyl2x function instead of searching 
// through the table.
LONG AmpFactorToDB( DWORD dwFactor )
{
    LONG    lDB;
    int	    i;
    int	    iMax;

    // dwFactor better be valid.
    ASSERT((LONG)dwFactor >= 0);

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;
    
    if (dwFactor < 0x0000FFFF) 
    {
        for (i = 0; i <= iMax - 1; i++) {
	         if (dwFactor <= tblDBTenthsToAmpFactor[i]) break;
        }
        lDB = (i - 964) * 10;
    }
    else
    {
        lDB = 0; 
    }


    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dmacpy32.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

 void DMACopy32Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PBYTE pOutput = (PBYTE)pvOutput;

   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PBYTE)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      ;
#if 1
      if (iters) 
	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*4]
	lea	edx, [edi+ebx*1]
	dec	ebx
	mov	plBuild, eax
	mov	pOutput, edx

	mov	ecx, 0x8000

	movd		mm5, ecx
	punpckldq	mm5, mm5	// 32768, 32768

	mov	ecx, 0x80

	movd		mm6, ecx
	punpcklwd	mm6, mm6
	punpckldq	mm6, mm6


	cmp	ebx, 15
	jl	Last

	sub	ebx, 7
	and	edx, 7
	je	Top

	add	ebx, 7
First:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl

	dec	ebx
	lea	eax, [edi+ebx*1]
	and	eax, 7
	cmp	eax, 7
	jne	First
	
	sub	ebx, 7

Top:
#ifdef GTW_REORDER
	movq		mm1, [esi+ebx*4]
	movq		mm2, [esi+ebx*4+8]
	jmp	Top00
Top0:
	movq		mm7, [esi+ebx*4]
	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*1+8], mm1

	movq		mm2, [esi+ebx*4+8]
	movq		mm1, mm7
Top00:
	movq		mm3, [esi+ebx*4+16]
	packssdw	mm1, mm2	// Clip.

	movq		mm4, [esi+ebx*4+24]
	psraw		mm1, 8

	packssdw	mm3, mm4
	sub	ebx, 8

	psraw		mm3, 8
	paddw		mm1, mm6

	paddw		mm3, mm6
	jge	Top0

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*1+8], mm1
#else
	movq		mm1, [esi+ebx*4]
	movq		mm2, [esi+ebx*4+8]
	movq		mm3, [esi+ebx*4+16]
	movq		mm4, [esi+ebx*4+24]

	packssdw	mm1, mm2	// Clip.
	packssdw	mm3, mm4

	psraw		mm1, 8
	psraw		mm3, 8

	paddw		mm1, mm6
	paddw		mm3, mm6

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*1], mm1

	sub	ebx, 8
	jge	Top
#endif

	add	ebx, 7	// 8
	jl	Done	// jle

//	dec	ebx
Last:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl

	dec	ebx
	jge	Last
Done:
	emms
      }
#else
      LONG Sample;
      ++iters;
      while (--iters) {
	 Sample = *plBuild;
	 plBuild++;
         if ((LONG)((SHORT)Sample) != Sample) {
	    if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
	    else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
         }
	 Sample += 32768;
	 *pOutput = (BYTE)DIVIDEBY256(Sample);
	 pOutput++;
      }
#endif
      if (pOutput >= pWrapPoint) {
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dmacpy34.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

void DMACopy34Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PBYTE pOutput = (PBYTE)pvOutput;
   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PBYTE)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      iters /= 2;;
#if 1
      if (iters) 
	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*8]
	lea	edx, [edi+ebx*2]
	dec	ebx
	mov	plBuild, eax
	mov	pOutput, edx

	mov	ecx, 32768

	movd		mm5, ecx
	punpckldq	mm5, mm5	// 32768, 32768

	mov	ecx, 0x80

	movd		mm6, ecx
	punpcklwd	mm6, mm6
	punpckldq	mm6, mm6

	cmp	ebx, 7
	jl	Last

	sub	ebx, 3
	and	edx, 7
	je	Top

	add	ebx, 3
	lea	ebx, [ebx*2+1]
First:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl

	dec	ebx
	lea	eax, [edi+ebx*1]
	and	eax, 7
	cmp	eax, 7
	jne	First
	
	shr	ebx, 1
	sub	ebx, 3

Top:
#ifdef GTW_REORDER
	movq		mm1, [esi+ebx*8]
	movq		mm2, [esi+ebx*8+8]
	jmp	Top00
Top0:
	movq		mm7, [esi+ebx*8]
	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*2+8], mm1

	movq		mm2, [esi+ebx*8+8]
	movq		mm1, mm7
Top00:
	movq		mm3, [esi+ebx*8+16]
	packssdw	mm1, mm2	// Clip.

	movq		mm4, [esi+ebx*8+24]
	psraw		mm1, 8

	packssdw	mm3, mm4
	sub	ebx, 4

	psraw		mm3, 8
	paddw		mm1, mm6

	paddw		mm3, mm6
	jge	Top0

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*2+8], mm1
#else
	movq		mm1, [esi+ebx*8]
	movq		mm2, [esi+ebx*8+8]
	movq		mm3, [esi+ebx*8+16]
	movq		mm4, [esi+ebx*8+24]

	packssdw	mm1, mm2	// Clip.
	packssdw	mm3, mm4

	psraw		mm1, 8
	psraw		mm3, 8

	paddw		mm1, mm6
	paddw		mm3, mm6

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*2], mm1

	sub	ebx, 4
	jge	Top
#endif

	add	ebx, 3	// 4
	jl	Done	// jle

//	dec	ebx
Last:
	lea	ebx, [ebx*2+1]
Lab:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl
	dec	ebx
	jge	Lab
Done:
	emms
      }
#else
      LONG SampleL;
      LONG SampleR;
      ++iters;
      while (--iters) {
	 SampleL = *plBuild;
	 SampleR = *(plBuild+1);
	 plBuild += 2;
         if ((LONG)((SHORT)SampleL) != SampleL) {
	    if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
	    else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
         }
         if ((LONG)((SHORT)SampleR) != SampleR) {
	    if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
	    else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
         }
	 SampleL += 32768;
	 SampleR += 32768;
	 *pOutput = (BYTE)DIVIDEBY256(SampleL);
	 *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
	 pOutput += 2;
      }
#endif
      if (pOutput >= pWrapPoint) {
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:    DLL entry point
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#define INITGUID

#include <verinfo.h>
#include "dsoundi.h"

#ifndef NOVXD
#ifndef VER_PRODUCTVERSION_DW
#define VER_PRODUCTVERSION_DW MAKELONG(MAKEWORD(MANVERSION, MANREVISION), MAKEWORD(MANMINORREV, BUILD_NUMBER))
#endif // VER_PRODUCTVERSION_DW
#endif // NOVXD

#ifdef SHARED
#include <dbt.h>  // For DBT_DEVNODES_CHANGED
#endif // SHARED

/***************************************************************************
 *
 * Global variables
 *
 ***************************************************************************/

// DLL reference count
ULONG                       g_ulDllRefCount;

// The DirectSound Administrator
CDirectSoundAdministrator*  g_pDsAdmin;

// The virtual audio device manager
CVirtualAudioDeviceManager* g_pVadMgr;

#ifndef NOVXD

// DSOUND.VXD handle
HANDLE                      g_hDsVxd;

#endif // NOVXD

// The mixer mutex
LONG                        lMixerMutexMutex;
LONG                        lDummyMixerMutex;
PLONG                       gpMixerMutex;
int                         cMixerEntry;
DWORD                       tidMixerOwner;

// These DLL globals are used by DDHELP and therefore have to be a specific
// name (I hate globals without a g_, but what are you going to do?)
HINSTANCE                   hModule;
DWORD                       dwHelperPid;

// Prototypes
BOOL DllProcessAttach(HINSTANCE, DWORD);
void DllProcessDetach(DWORD);


/***************************************************************************
 *
 *  EnterDllMainMutex
 *
 *  Description:
 *      Takes the DllMain mutex.
 *
 *  Arguments:
 *      DWORD [in]: current process id.
 *
 *  Returns:  
 *      HANDLE: the DllMain mutex.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "EnterDllMainMutex"

HANDLE EnterDllMainMutex(DWORD dwProcessId)
{
#ifdef SHARED
    const LPCTSTR           pszMutex            = TEXT("DirectSound DllMain mutex (shared)");
#else // SHARED
    const LPCTSTR           pszMutexTemplate    = TEXT("DirectSound DllMain mutex (0x%8.8lX)");
    TCHAR                   szMutex[0x100];
    LPTSTR                  pszMutex;
#endif // SHARED

    HANDLE                  hMutex;
    DWORD                   dwWait;

    DPF_ENTER();

#ifndef SHARED
    wsprintf(szMutex, pszMutexTemplate, dwProcessId);
    pszMutex = szMutex;
#endif // SHARED

    hMutex = CreateMutex(NULL, FALSE, pszMutex);
    ASSERT(IsValidHandleValue(hMutex));

    dwWait = WaitObject(INFINITE, hMutex);
    ASSERT(WAIT_OBJECT_0 == dwWait);

    DPF_LEAVE(hMutex);
    
    return hMutex;
}


/***************************************************************************
 *
 *  LeaveDllMainMutex
 *
 *  Description:
 *      Releases the DllMain mutex.
 *
 *  Arguments:
 *      HANDLE [in]: the DllMain mutex.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LeaveDllMainMutex"

void LeaveDllMainMutex(HANDLE hMutex)
{
    DPF_ENTER();
    
    ASSERT(IsValidHandleValue(hMutex));

    ReleaseMutex(hMutex);
    CLOSE_HANDLE(hMutex);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CleanupAfterProcess
 *
 *  Description:
 *      Cleans up behind a process that's going away.
 *
 *  Arguments:
 *      DWORD [in]: process ID to clean up after.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CleanupAfterProcess"

void CleanupAfterProcess(DWORD dwProcessId)
{
    DWORD dwCount = 0;
    
    ENTER_DLL_MUTEX();
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "Cleaning up behind process 0x%8.8lX", dwProcessId);
    
    if(g_pDsAdmin)
    {
        dwCount = g_pDsAdmin->FreeOrphanedObjects(dwProcessId, TRUE);
    }

    if(dwCount)
    {
        RPF(DPFLVL_ERROR, "Process 0x%8.8lX leaked %lu top-level objects", dwProcessId, dwCount);
    }

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  DdhelpProcessNotifyProc
 *
 *  Description:
 *      Callback procedure for DDHELP notifications.
 *
 *  Arguments:
 *      LPDDHELPDATA [in]: data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "DdhelpProcessNotifyProc"

BOOL FAR PASCAL DdhelpProcessNotifyProc(LPDDHELPDATA pData)
{
    DPF_ENTER();

    // Detach this process from the DLL
    DllProcessDetach(pData->pid);

    DPF_LEAVE(TRUE);
    
    return TRUE;
}

#endif // SHARED


/***************************************************************************
 *
 *  DdhelpDeviceChangeNotifyProc
 *
 *  Description:
 *      Callback procedure for DDHELP notifications.
 *
 *  Arguments:
 *      UINT [in]: device change event.
 *      DWORD [in]: device change data.
 *
 *  Returns:  
 *      BOOL: TRUE to allow the device change.
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "DdhelpDeviceChangeNotifyProc"

BOOL FAR PASCAL DdhelpDeviceChangeNotifyProc(UINT uEvent, DWORD dwData)
{
    ENTER_DLL_MUTEX();
    DPF_ENTER();

    DPF(DPFLVL_MOREINFO, "uEvent = %lu", uEvent);

    // Reset the static device list
    if(uEvent == DBT_DEVNODES_CHANGED && g_pVadMgr)
    {
        DPF(DPFLVL_INFO, "Resetting static driver list");
        g_pVadMgr->FreeStaticDriverList();
    }
    
    DPF_LEAVE(TRUE);
    LEAVE_DLL_MUTEX();
    return TRUE;
}

#endif // SHARED


/***************************************************************************
 *
 *  PinLibrary
 *
 *  Description:
 *      Adds a reference to the DLL so that it remains loaded even after
 *      freed by the owning process.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PinLibrary"

BOOL PinLibrary(HINSTANCE hInst)
{
#ifdef SHARED
    static TCHAR            szDllName[MAX_PATH];
#else // SHARED
    TCHAR                   szDllName[MAX_PATH];
#endif // SHARED

    BOOL                    fSuccess;
    HINSTANCE               hPinInst;

    DPF_ENTER();
    
    // Get our DLL path
    fSuccess = GetModuleFileName(hInst, szDllName, NUMELMS(szDllName));

    if(!fSuccess)
    {
        DPF(DPFLVL_ERROR, "Unable to get module name");
    }

    // Add a reference to the library
    if(fSuccess)
    {
#ifdef SHARED
        hPinInst = HelperLoadLibrary(szDllName);
#else // SHARED
        hPinInst = LoadLibrary(szDllName);
#endif // SHARED

        if(!hPinInst)
        {
            DPF(DPFLVL_ERROR, "Unable to load %s", szDllName);
            fSuccess = FALSE;
        }
    }

    DPF_LEAVE(fSuccess);
    
    return fSuccess;
}


/***************************************************************************
 *
 *  DllFirstProcessAttach
 *
 *  Description:
 *      Handles first process attach for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllFirstProcessAttach"

BOOL DllFirstProcessAttach(HINSTANCE hInst, DWORD dwProcessId)
{
#ifndef NOVXD
    DWORD                   dwVxdVersion;
#endif // NOVXD

    BOOL                    fSuccess;
    HRESULT                 hr;

    DPF_ENTER();
    
    // We don't need thread calls
    DisableThreadLibraryCalls(hInst);
    
    // Save the module instance handle
    hModule = hInst;

    // Initialize the memory manager
    fSuccess = MemInit();

    // Initialize the debugger
    if(fSuccess)
    {
        DPFINIT();
    }

    // Create the global lock object
    if(fSuccess)
    {
        g_pDllLock = NEW(CPreferredLock);
        fSuccess = MAKEBOOL(g_pDllLock);
    }

    if(fSuccess)
    {
        hr = g_pDllLock->Initialize();
        fSuccess = SUCCEEDED(hr);
    }

#ifndef NOVXD

    // Open DSOUND.VXD
    if(fSuccess)
    {
        hr = VxdOpen();
        
        if(SUCCEEDED(hr))
        {
            hr = VxdInitialize();
            
            if(FAILED(hr))
            {
                VxdClose();
            }
        }
    }

    // Make sure the VxD and DLL match
    if(fSuccess && g_hDsVxd)
    {
        if(VER_PRODUCTVERSION_DW != (dwVxdVersion = VxdGetInternalVersionNumber()))
        {
            RPF(DPFLVL_ERROR, "DSOUND.DLL and DSOUND.VXD are mismatched.  DSOUND.DLL version: 0x%8.8lX.  DSOUND.VXD version: 0x%8.8lX", VER_PRODUCTVERSION_DW, dwVxdVersion);
            VxdShutdown();
            VxdClose();
        }
    }
    
    // Set up ptr to the kernel-mode mixer mutex
    if(fSuccess && g_hDsVxd)
    {
        gpMixerMutex = VxdGetMixerMutexPtr();
    }

#endif // NOVXD
        
    if(fSuccess && !gpMixerMutex)
    {
        gpMixerMutex = &lDummyMixerMutex;
    }

#ifdef SHARED

    // Load DDHELP
    if(fSuccess)
    {
        CreateHelperProcess(&dwHelperPid);

        if(!dwHelperPid)
        {
            DPF(DPFLVL_ERROR, "Unable to create helper process");
            fSuccess = FALSE;
        }
    }

    if(fSuccess)
    {
        if(!WaitForHelperStartup())
        {
            DPF(DPFLVL_ERROR, "WaitForHelperStartup failed");
            fSuccess = FALSE;
        }
    }

#else // SHARED

    if(fSuccess)
    {
        dwHelperPid = dwProcessId;
    }

#endif // SHARED

    // Create the virtual audio device manager
    if(fSuccess)
    {
        g_pVadMgr = NEW(CVirtualAudioDeviceManager);
        fSuccess = MAKEBOOL(g_pVadMgr);
    }
    
    // Create the DirectSound Administrator
    if(fSuccess)
    {
        g_pDsAdmin = NEW(CDirectSoundAdministrator);
        fSuccess = MAKEBOOL(g_pDsAdmin);
    }

#ifdef SHARED

    // Ask DDHELP to notify us of any device changes
    if(fSuccess)
    {
        HelperAddDeviceChangeNotify(DdhelpDeviceChangeNotifyProc);
    }

#endif // SHARED

    // Determine the WDM version based on platform
    if (fSuccess)
    {
        KsQueryWdmVersion();
    }    

    // Pin the DLL in memory.  This is odd behavior for any DLL, but it may be
    // risky to change it, for appcompat reasons.  NOTE: this must be the last
    // call made by this function, so that if any of the previous calls fails,
    // we don't pin an unitialized dsound.dll in memory (bug 395950).
    if(fSuccess)
    {
        fSuccess = PinLibrary(hInst);
    }

    // Announce our presence to the world
    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "DirectSound is ready to rock at 0x%p...", hInst);
    }

    DPF_LEAVE(fSuccess);
    
    return fSuccess;
}


/***************************************************************************
 *
 *  DllLastProcessDetach
 *
 *  Description:
 *      Handles final process detach for DllMain.
 *
 *  Arguments:
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllLastProcessDetach"

void DllLastProcessDetach(DWORD dwProcessId)
{
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "DirectSound going away...");

    // Free the DirectSound Administrator
    ABSOLUTE_RELEASE(g_pDsAdmin);

    // Free the virtual audio device manager
    ABSOLUTE_RELEASE(g_pVadMgr);

#ifndef NOVXD

    // Release DSOUND.VXD
    if(g_hDsVxd)
    {
        VxdShutdown();
        VxdClose();
    }

#endif // NOVXD

    // Reset the mixer mutex pointer
    gpMixerMutex = NULL;

    // Free the global lock
    DELETE(g_pDllLock);

    // Free the memory manager
    MemFini();
    
    // Uninitialize the debugger
    DPFCLOSE();

    // There are no more references to this DLL
    g_ulDllRefCount = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllProcessAttach
 *
 *  Description:
 *      Handles process attaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllProcessAttach"

BOOL DllProcessAttach(HINSTANCE hInst, DWORD dwProcessId)
{
    BOOL                    fSuccess    = TRUE;
    HANDLE                  hMutex      = NULL;

    DPF_ENTER();

#ifndef DX_FINAL_RELEASE
    // Warn the user if this is an expired pre-release DirectSound DLL.
    SYSTEMTIME st;
    GetSystemTime(&st);

    if ((st.wYear > DX_EXPIRE_YEAR) || 
        (st.wYear == DX_EXPIRE_YEAR && st.wMonth > DX_EXPIRE_MONTH) ||
        (st.wYear == DX_EXPIRE_YEAR && st.wMonth == DX_EXPIRE_MONTH && st.wDay > DX_EXPIRE_DAY))
    {
        MessageBox(NULL, DX_EXPIRE_TEXT, TEXT("Microsoft DirectSound"), MB_OK);
        RPF(DPFLVL_ABSOLUTE, "This pre-release version of DirectX has expired; please upgrade to the latest version.");
    }
#endif // DX_FINAL_RELEASE

#ifdef SHARED
    if(dwProcessId != dwHelperPid)
#endif // SHARED
    {
        hMutex = EnterDllMainMutex(dwProcessId);
    }

    // Increment the DLL reference count
    AddRef(&g_ulDllRefCount);

#ifdef SHARED
    if(dwProcessId != dwHelperPid)
#endif // SHARED
    {
        // Is this the first attach?
        if(1 == g_ulDllRefCount)
        {
            // Yes.  Initialize everything.
            fSuccess = DllFirstProcessAttach(hInst, dwProcessId);

            if(!fSuccess)
            {
                DllLastProcessDetach(dwProcessId);
            }
        }
    
#ifdef SHARED
        // Ask DDHELP to keep an eye on this process for us
        if(fSuccess)
        {
            SignalNewProcess(dwProcessId, DdhelpProcessNotifyProc);
        }
#endif // SHARED

    }

    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "DirectSound process 0x%8.8lX started - DLL ref count=%lu", dwProcessId, g_ulDllRefCount);
    }

    if(hMutex)
    {
        LeaveDllMainMutex(hMutex);
    }

#ifdef ENABLE_PERFLOG
    // Initialize performance logging
    HKEY PerfKey=NULL;
    DWORD PerfValue=0;
    DWORD sizePerfValue=sizeof(DWORD);
    if (RegOpenKey (HKEY_LOCAL_MACHINE,TEXT("SOFTWARE\\Microsoft\\DirectX"),&PerfKey)== ERROR_SUCCESS) {
        if (RegQueryValueEx (PerfKey,TEXT("GlitchInstrumentation"),NULL,NULL,(LPBYTE)&PerfValue,&sizePerfValue)== ERROR_SUCCESS) {
            if (PerfValue>0) {
                InitializePerflog();
            } //if perfvalue
        } //if regqueryvalue
        RegCloseKey(PerfKey);
    } //if regopen key
#endif

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  DllProcessDetach
 *
 *  Description:
 *      Handles process detaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllProcessDetach"

void DllProcessDetach(DWORD dwProcessId)
{
    HANDLE                  hMutex;

    DPF_ENTER();
    
    hMutex = EnterDllMainMutex(dwProcessId);
    
    // Clean up any objects left behind by the object

#ifdef SHARED
    if(dwProcessId != dwHelperPid)
#endif // SHARED
    {
        CleanupAfterProcess(dwProcessId);
    }

    // Clean up per-process streaming thread and ksuser.dll dynaload table
    FreeStreamingThread(dwProcessId);
    RemovePerProcessKsUser(dwProcessId);

    // Decrement the DLL ref count
    Release(&g_ulDllRefCount);

    // Is this the last detach?
    if(!g_ulDllRefCount)
    {
        DllLastProcessDetach(dwProcessId);
    }

    DPF(DPFLVL_INFO, "process id 0x%8.8lX, ref count %lu", dwProcessId, g_ulDllRefCount);

    LeaveDllMainMutex(hMutex);

#ifdef ENABLE_PERFLOG
    // Terminate performance logging
    PerflogShutdown();
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllThreadAttach
 *
 *  Description:
 *      Handles thread attaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *      DWORD [in]: thread id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllThreadAttach"

void DllThreadAttach(DWORD dwProcessId, DWORD dwThreadId)
{
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "process id 0x%8.8lX, thread id 0x%8.8lX", dwProcessId, dwThreadId);
    
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllThreadDetach
 *
 *  Description:
 *      Handles thread detaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *      DWORD [in]: thread id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllThreadDetach"

void DllThreadDetach(DWORD dwProcessId, DWORD dwThreadId)
{
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "process id 0x%8.8lX, thread id 0x%8.8lX", dwProcessId, dwThreadId);
    
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllMain
 *
 *  Description:
 *      DLL entry point.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: reason for call.
 *      LPVOID [in]: reserved.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllMain"

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved)
{
    const DWORD             dwProcessId = GetCurrentProcessId();
    const DWORD             dwThreadId  = GetCurrentThreadId();
    BOOL                    fAllow      = TRUE;

    DPF_ENTER();

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            fAllow = DllProcessAttach(hInst, dwProcessId);
            break;

        case DLL_PROCESS_DETACH:

#ifdef SHARED
            if(dwProcessId == dwHelperPid)
#endif // SHARED
            {            
                DllProcessDetach(dwProcessId);
            }

            break;

        case DLL_THREAD_ATTACH:
            DllThreadAttach(dwProcessId, dwThreadId);
            break;

        case DLL_THREAD_DETACH:
            DllThreadDetach(dwProcessId, dwThreadId);
            break;

        default:
            DPF(DPFLVL_ERROR, "Unknown DllMain call reason %lu", dwReason);
            break;
    }

    DPF_LEAVE(fAllow);

    return fAllow;
}


#ifdef WIN95
/***************************************************************************
 *
 *  main
 *
 *  Description:
 *      On Windows 9x, libc.lib requires us to have a main() function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "main"

void __cdecl main(void)
{
    DPF(DPFLVL_ERROR, "This function should never be called");
    ASSERT(FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dmacpy37.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

void DMACopy37Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PWORD pOutput = (PWORD)pvOutput;

   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PWORD)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      ;
#if 1
      if (iters) 
	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*4]
	lea	edx, [edi+ebx*2]
	dec	ebx
	mov	plBuild, eax
	mov	pOutput, edx
	cmp	ebx, 7
	jl	Last

	sub	ebx, 3
	and	edx, 7
	je	Top

	add	ebx, 3
First:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	movd		ecx, mm1

	mov	WORD PTR [edi+ebx*2], cx

	dec	ebx
	lea	eax, [edi+ebx*2]
	and	eax, 7
	cmp	eax, 6
	jne	First

	sub	ebx, 3
Top:
#ifdef GTW_REORDER
	jmp	Top00
Top0:
	movq		[edi+ebx*2+8], mm1

Top00:
	movq		mm1, [esi+ebx*4]

	movq		mm2, [esi+ebx*4+8]

	packssdw	mm1, mm2
	sub	ebx, 4

	jge	Top0

	movq		[edi+ebx*2+8], mm1
#else
	movq		mm1, [esi+ebx*4]
	movq		mm2, [esi+ebx*4+8]

	sub	ebx, 4

	packssdw	mm1, mm2
	movq		[edi+ebx*2+8], mm1

	jge	Top
#endif

	add	ebx, 3	// 4
	jl	Done	// jle
	
//	dec	ebx
Last:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	movd		ecx, mm1

	mov	WORD PTR [edi+ebx*2], cx

	dec	ebx
	jge	Last
Done:
	emms
      }
#else
      LONG Sample;
      ++iters;
      while (--iters) {
	 Sample = *plBuild;
	 plBuild++;
         if ((LONG)((SHORT)Sample) != Sample) {
	    if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
	    else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
         }
	 *pOutput = (WORD)Sample;
	 pOutput++;
      }
#endif
      if (pOutput >= pWrapPoint) {
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
      }
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dmacpy39.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

void DMACopy39Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PWORD pOutput = (PWORD)pvOutput;

   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PWORD)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      iters /= 2;;

#if 1
      if (iters)
      	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*8]
	lea	edx, [edi+ebx*4]
	dec	ebx
	cmp	ebx, 3

	mov	plBuild, eax
	mov	pOutput, edx
	jl	Last

	dec	ebx
	and	edx, 7
	je	Top

	movq		mm1, [esi+ebx*8+8]
	packssdw	mm1, mm1
	movd		[edi+ebx*4+4], mm1

	dec	ebx

Top:
#ifdef GTW_REORDER
	jmp	Top00
Top0:
	movq		[edi+ebx*4+8], mm1

Top00:
	movq		mm1, [esi+ebx*8]

	movq		mm2, [esi+ebx*8+8]

	packssdw	mm1, mm2
	sub	ebx, 2

	jge	Top0

	movq		[edi+ebx*4+8], mm1
#else
	movq		mm1, [esi+ebx*8]
	movq		mm2, [esi+ebx*8+8]

	sub	ebx, 2

	packssdw	mm1, mm2
	movq		[edi+ebx*4+8], mm1

	jge	Top
#endif

	add	ebx, 2
	jle	Done

	dec	ebx
Last:
	movq		mm1, [esi+ebx*8]
	packssdw	mm1, mm1
	movd		[edi+ebx*4], mm1

	dec	ebx
	jge	Last
Done:
	emms
      }
#else
      LONG SampleL;
      LONG SampleR;
      ++iters;
      while (--iters) {
	 SampleL = *plBuild;
	 SampleR = *(plBuild+1);
	 plBuild += 2;
         if ((LONG)((SHORT)SampleL) != SampleL) {
	    if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
	    else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
         }
         if ((LONG)((SHORT)SampleR) != SampleR) {
	    if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
	    else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
         }
	 *pOutput = (WORD)SampleL;
	 *(pOutput+1) = (WORD)SampleR;
	 pOutput += 2;
      }
#endif
      if (pOutput >= pWrapPoint) {
         pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//

#ifndef DMSTRM_H
#define DMSTRM_H

#ifdef __cplusplus

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // __cplusplus

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dmstrm.cpp ===
//
// dmstrm.cpp
//
// Copyright (c) 1995-1999 Microsoft Corporation
//

#include "dsoundi.h"
#include "dmusicc.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    ASSERT(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream;
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    ASSERT (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    ASSERT (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DEBUG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            DPF(DPFLVL_MOREINFO, "Parsing %S, Read %ld of %ld\n",
                szName, m_pChunk->lRead, RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent)
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DEBUG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
                DPF(DPFLVL_MOREINFO, "Entering %S, Length %ld, File position is %ld",
                    szName, m_pChunk->cksize, (long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DEBUG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        DPF(DPFLVL_MOREINFO, "Type %S", szName);
                    }
#endif
                }
                else
                {
                    DPF(DPFLVL_WARNING, "Unable to read file");
                }
            }
        }
        else
        {
            DPF(DPFLVL_WARNING, "Unable to read file");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                DPF(DPFLVL_WARNING, "Unable to read file");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DEBUG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
            DPF(DPFLVL_MOREINFO, "Leaving %S, Read %ld of %ld, File Position is %ld",
                szName, m_pChunk->lRead, lSize, (long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            DPF(DPFLVL_ERROR, "Unable to read %ld bytes from file", cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart + RIFF_ALIGN(m_pChunk->cksize);
    }
}

HRESULT CRiffParser::SeekBack()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD)));
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ds3d.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ds3d.h
 *  Content:    DirectSound 3D helper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/12/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DS3D_H__
#define __DS3D_H__

// How does overall volume change based on position?
#define GAIN_FRONT                  0.9f
#define GAIN_REAR                   0.6f
#define GAIN_IPSI                   1.f
#define GAIN_CONTRA                 0.2f
#define GAIN_UP                     0.8f
#define GAIN_DOWN                   0.5f

// How does dry/wet mix change based on position?
#define SHADOW_FRONT                1.f
#define SHADOW_REAR                 0.5f
#define SHADOW_IPSI                 1.f
#define SHADOW_CONTRA               0.2f
#define SHADOW_UP                   0.8f
#define SHADOW_DOWN                 0.2f

// Max wet/dry mix when outside cone
#define SHADOW_CONE                 0.5f

// A constant representing the average volume difference between the
// Pan3D and VMAX HRTF 3D processing algorithms, in 1/100ths of a dB:
#define PAN3D_HRTF_ADJUSTMENT       500

// Dirty bits
#define DS3DPARAM_LISTENER_DISTANCEFACTOR   0x00000001
#define DS3DPARAM_LISTENER_DOPPLERFACTOR    0x00000002
#define DS3DPARAM_LISTENER_ROLLOFFFACTOR    0x00000004
#define DS3DPARAM_LISTENER_ORIENTATION      0x00000008
#define DS3DPARAM_LISTENER_POSITION         0x00000010
#define DS3DPARAM_LISTENER_VELOCITY         0x00000020
#define DS3DPARAM_LISTENER_PARAMMASK        0x0000003F
#define DS3DPARAM_LISTENER_SPEAKERCONFIG    0x00000040
#define DS3DPARAM_LISTENER_MASK             0x0000007F

#define DS3DPARAM_OBJECT_CONEANGLES         0x00000001
#define DS3DPARAM_OBJECT_CONEORIENTATION    0x00000002
#define DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME  0x00000004
#define DS3DPARAM_OBJECT_MAXDISTANCE        0x00000008
#define DS3DPARAM_OBJECT_MINDISTANCE        0x00000010
#define DS3DPARAM_OBJECT_MODE               0x00000020
#define DS3DPARAM_OBJECT_POSITION           0x00000040
#define DS3DPARAM_OBJECT_VELOCITY           0x00000080
#define DS3DPARAM_OBJECT_PARAMMASK          0x000000FF
#define DS3DPARAM_OBJECT_FREQUENCY          0x00000100
#define DS3DPARAM_OBJECT_MASK               0x000001FF

typedef FLOAT *LPFLOAT;

typedef struct tagSPHERICAL
{
    FLOAT               rho;
    FLOAT               theta;
    FLOAT               phi;
} SPHERICAL, *LPSPHERICAL;

typedef struct tagROTATION
{
    FLOAT               pitch;
    FLOAT               yaw;
    FLOAT               roll;
} ROTATION, *LPROTATION;

typedef struct tagOBJECT_ITD_CONTEXT
{
    FLOAT               flDistanceAttenuation;
    FLOAT               flConeAttenuation;
    FLOAT               flConeShadow;
    FLOAT               flPositionAttenuation;
    FLOAT               flPositionShadow;
    FLOAT               flVolSmoothScale;
    FLOAT               flVolSmoothScaleRecip;
    FLOAT               flVolSmoothScaleDry;
    FLOAT               flVolSmoothScaleWet;
    DWORD               dwSmoothFreq;
    DWORD               dwDelay;
} OBJECT_ITD_CONTEXT, *LPOBJECT_ITD_CONTEXT;

typedef struct tagOBJECT_IIR_CONTEXT
{
    BOOL                bReverseCoeffs;
    FLOAT               flCoeffs;
    FLOAT               flConeAttenuation;
    FLOAT               flConeShadow;
    FLOAT               flPositionAttenuation;
    FLOAT               flPositionShadow;
    FLOAT               flVolSmoothScale;
    FLOAT               flVolSmoothScaleRecip;
    FLOAT               flVolSmoothScaleDry;
    FLOAT               flVolSmoothScaleWet;
    DWORD               dwSmoothFreq;
    DWORD               dwDelay;
} OBJECT_IIR_CONTEXT, *LPOBJECT_IIR_CONTEXT;

#ifdef __cplusplus

// Reference typedefs
typedef const D3DVECTOR& REFD3DVECTOR;

// Fwd decl
class CVxdPropertySet;
class C3dObject;
class CIirLut;
class CSecondaryRenderWaveBuffer;

// Generic 3D listener base class
class C3dListener
    : public CDsBasicRuntime
{
    friend class C3dObject;
    friend class CSw3dObject;
    friend class CItd3dObject;
    friend class CIir3dObject;
    friend class CPan3dObject;

protected:
    CList<C3dObject *>  m_lstObjects;               // List of objects owned by this listener
    DS3DLISTENER        m_lpCurrent;                // Current parameters
    DS3DLISTENER        m_lpDeferred;               // Deferred parameters
    DWORD               m_dwDeferred;               // Lists dirty deferred parameters
    DWORD               m_dwSpeakerConfig;          // Speaker Config

public:
    C3dListener(void);
    virtual ~C3dListener(void);

public:
    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Listener/world properties
    virtual HRESULT GetOrientation(D3DVECTOR*, D3DVECTOR*);
    virtual HRESULT SetOrientation(REFD3DVECTOR, REFD3DVECTOR, BOOL);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT GetDistanceFactor(LPFLOAT);
    virtual HRESULT SetDistanceFactor(FLOAT, BOOL);
    virtual HRESULT GetDopplerFactor(LPFLOAT);
    virtual HRESULT SetDopplerFactor(FLOAT, BOOL);
    virtual HRESULT GetRolloffFactor(LPFLOAT);
    virtual HRESULT SetRolloffFactor(FLOAT, BOOL);
    virtual HRESULT GetAllParameters(LPDS3DLISTENER);
    virtual HRESULT SetAllParameters(LPCDS3DLISTENER, BOOL);

    // Population
    virtual void AddObjectToList(C3dObject *);
    virtual void RemoveObjectFromList(C3dObject *);

    // Listener location
    virtual DWORD GetListenerLocation(void);

    // Speaker configuration
    virtual HRESULT GetSpeakerConfig(LPDWORD);
    virtual HRESULT SetSpeakerConfig(DWORD);

protected:
    virtual HRESULT CommitAllObjects(void);
    virtual HRESULT UpdateAllObjects(DWORD);
};

inline void C3dListener::AddObjectToList(C3dObject *pObject)
{
    m_lstObjects.AddNodeToList(pObject);
}

inline void C3dListener::RemoveObjectFromList(C3dObject *pObject)
{
    m_lstObjects.RemoveDataFromList(pObject);
}

inline HRESULT C3dListener::GetDistanceFactor(LPFLOAT pflDistanceFactor)
{
    *pflDistanceFactor = m_lpCurrent.flDistanceFactor;
    return DS_OK;
}

inline HRESULT C3dListener::GetDopplerFactor(LPFLOAT pflDopplerFactor)
{
    *pflDopplerFactor = m_lpCurrent.flDopplerFactor;
    return DS_OK;
}

inline HRESULT C3dListener::GetRolloffFactor(LPFLOAT pflRolloffFactor)
{
    *pflRolloffFactor = m_lpCurrent.flRolloffFactor;
    return DS_OK;
}

inline HRESULT C3dListener::GetOrientation(D3DVECTOR* pvFront, D3DVECTOR* pvTop)
{
    if(pvFront)
    {
        *pvFront = m_lpCurrent.vOrientFront;
    }

    if(pvTop)
    {
        *pvTop = m_lpCurrent.vOrientTop;
    }

    return DS_OK;
}

inline HRESULT C3dListener::GetPosition(D3DVECTOR* pvPosition)
{
    *pvPosition = m_lpCurrent.vPosition;
    return DS_OK;
}

inline HRESULT C3dListener::GetVelocity(D3DVECTOR* pvVelocity)
{
    *pvVelocity = m_lpCurrent.vVelocity;
    return DS_OK;
}

inline HRESULT C3dListener::GetAllParameters(LPDS3DLISTENER pParams)
{
    ASSERT(sizeof(*pParams) == pParams->dwSize);
    CopyMemoryOffset(pParams, &m_lpCurrent, sizeof(DS3DLISTENER), sizeof(pParams->dwSize));
    return DS_OK;
}

inline DWORD C3dListener::GetListenerLocation(void)
{
    return DSBCAPS_LOCSOFTWARE;
}

inline HRESULT C3dListener::GetSpeakerConfig(LPDWORD pdwConfig)
{
    *pdwConfig = m_dwSpeakerConfig;
    return DS_OK;
}

// Generic 3D object base class
class C3dObject
    : public CDsBasicRuntime
{
    friend class CWrapper3dObject;

protected:
    C3dListener *           m_pListener;            // Pointer to the listener that owns this object
    DS3DBUFFER              m_opCurrent;            // Current parameters
    DS3DBUFFER              m_opDeferred;           // Deferred parameters
    DWORD                   m_dwDeferred;           // Lists dirty deferred parameters
    GUID                    m_guid3dAlgorithm;      // 3D algorithm identifier
    BOOL                    m_fMuteAtMaxDistance;   // TRUE to mute 3D at max distance
    BOOL                    m_fDopplerEnabled;      // TRUE to allow Doppler processing

public:
    C3dObject(C3dListener *, REFGUID, BOOL, BOOL);
    virtual ~C3dObject(void);

public:
    // Initialization
    virtual HRESULT Initialize(void);

    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Object properties
    virtual HRESULT GetConeAngles(LPDWORD, LPDWORD);
    virtual HRESULT GetConeOrientation(D3DVECTOR*);
    virtual HRESULT GetConeOutsideVolume(LPLONG);
    virtual HRESULT GetMaxDistance(LPFLOAT);
    virtual HRESULT GetMinDistance(LPFLOAT);
    virtual HRESULT GetMode(LPDWORD);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT GetAllParameters(LPDS3DBUFFER);
    
    virtual HRESULT SetConeAngles(DWORD, DWORD, BOOL);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, BOOL);
    virtual HRESULT SetConeOutsideVolume(LONG, BOOL);
    virtual HRESULT SetMaxDistance(FLOAT, BOOL);
    virtual HRESULT SetMinDistance(FLOAT, BOOL);
    virtual HRESULT SetMode(DWORD, BOOL);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, BOOL);

    virtual C3dListener *GetListener(void);
    virtual REFGUID GetAlgorithm(void);

    // Object events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

    // Object calculation
    virtual HRESULT Recalc(DWORD, DWORD) = 0;
    virtual BOOL IsAtMaxDistance(void);

    // Object location
    virtual DWORD GetObjectLocation(void) = 0;
};

inline HRESULT C3dObject::GetConeAngles(LPDWORD pdwInside, LPDWORD pdwOutside) 
{ 
    if(pdwInside)
    {
        *pdwInside = m_opCurrent.dwInsideConeAngle; 
    }

    if(pdwOutside)
    {
        *pdwOutside = m_opCurrent.dwOutsideConeAngle; 
    }

    return DS_OK;
}

inline HRESULT C3dObject::GetConeOrientation(D3DVECTOR* pvConeOrientation)
{ 
    *pvConeOrientation = m_opCurrent.vConeOrientation;
    return DS_OK;
}

inline HRESULT C3dObject::GetConeOutsideVolume(LPLONG plConeOutsideVolume)
{
    *plConeOutsideVolume = m_opCurrent.lConeOutsideVolume;
    return DS_OK;
}

inline HRESULT C3dObject::GetMaxDistance(LPFLOAT pflMaxDistance)
{
    *pflMaxDistance = m_opCurrent.flMaxDistance;
    return DS_OK;
}

inline HRESULT C3dObject::GetMinDistance(LPFLOAT pflMinDistance)
{
    *pflMinDistance = m_opCurrent.flMinDistance;
    return DS_OK;
}

inline HRESULT C3dObject::GetMode(LPDWORD pdwMode)
{
    *pdwMode = m_opCurrent.dwMode;
    return DS_OK;
}

inline HRESULT C3dObject::GetPosition(D3DVECTOR* pvPosition)
{
    *pvPosition = m_opCurrent.vPosition;
    return DS_OK;
}

inline HRESULT C3dObject::GetVelocity(D3DVECTOR* pvVelocity)
{
    *pvVelocity = m_opCurrent.vVelocity;
    return DS_OK;
}

inline HRESULT C3dObject::GetAllParameters(LPDS3DBUFFER pParams)
{
    ASSERT(sizeof(*pParams) == pParams->dwSize);
    CopyMemoryOffset(pParams, &m_opCurrent, sizeof(DS3DBUFFER), sizeof(pParams->dwSize));
    return DS_OK;
}

inline C3dListener *C3dObject::GetListener(void)
{
    return m_pListener;
}

inline REFGUID C3dObject::GetAlgorithm(void)
{
    return m_guid3dAlgorithm;
}

inline HRESULT C3dObject::SetAttenuation(PDSVOLUMEPAN pdsvp, LPBOOL pfContinue)
{
    *pfContinue = TRUE;
    return DS_OK;
}

inline HRESULT C3dObject::SetFrequency(DWORD dwFrequency, LPBOOL pfContinue)
{
    *pfContinue = TRUE;
    return DS_OK;
}

inline HRESULT C3dObject::SetMute(BOOL fMute, LPBOOL pfContinue)
{
    *pfContinue = TRUE;
    return DS_OK;
}

// Software 3D object base class
class CSw3dObject
    : public C3dObject
{
protected:
    SPHERICAL               m_spherical;            // Spherical coordinates
    ROTATION                m_rotation;             // Object rotation
    DWORD                   m_dwUserFrequency;      // Last Buffer frequency set by the user
    DWORD                   m_dwDopplerFrequency;   // Last Buffer Doppler frequency
    BOOL                    m_fAtMaxDistance;       // TRUE if we're >= max distance
    BOOL                    m_fInInnerCone;         // TRUE if we're in the inner cone
    BOOL                    m_fInOuterCone;         // TRUE if we're in the outer cone
    FLOAT                   m_flAttenuation;        // 
    FLOAT                   m_flHowFarOut;          // 
    FLOAT                   m_flAttDistance;        // 

public:
    CSw3dObject(C3dListener *, REFGUID, BOOL, BOOL, DWORD);
    virtual ~CSw3dObject(void);

public:
    // Buffer recalc
    virtual HRESULT Recalc(DWORD, DWORD);

    // Object location
    virtual DWORD GetObjectLocation(void);

    // Object events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);

    // Object calculation
    virtual BOOL IsAtMaxDistance(void);

protected:
    // Nasty math
    virtual void UpdateConeAttenuation(void);
    virtual void UpdatePositionAttenuation(void);
    virtual void UpdateHrp(void);
    virtual void UpdateListenerOrientation(void);
    virtual void UpdateDoppler(void);
    virtual void UpdateAlgorithmHrp(D3DVECTOR *) = 0;

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void) = 0;
};

inline DWORD CSw3dObject::GetObjectLocation(void)
{
    return DSBCAPS_LOCSOFTWARE;
}

// Hardware 3D object base class
class CHw3dObject
    : public C3dObject
{
public:
    CHw3dObject(C3dListener *, BOOL, BOOL);
    virtual ~CHw3dObject(void);

public:
    // Object location
    virtual DWORD GetObjectLocation(void);
};

inline DWORD CHw3dObject::GetObjectLocation(void)
{
    return DSBCAPS_LOCHARDWARE;
}

// Base class for all ITD 3D objects
class CItd3dObject
    : public CSw3dObject
{
protected:
    OBJECT_ITD_CONTEXT        m_ofcLeft;              // Left channel FIR context
    OBJECT_ITD_CONTEXT        m_ofcRight;             // Right channel FIR context

public:
    CItd3dObject(C3dListener *, BOOL, BOOL, DWORD);
    virtual ~CItd3dObject(void);

protected:
    // Nasty math
    virtual void UpdateConeAttenuation(void);
    virtual void UpdatePositionAttenuation(void);
    virtual void UpdateHrp(void);
    virtual void UpdateDoppler(void);
    virtual void UpdateAlgorithmHrp(D3DVECTOR *);

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void) = 0;

    // Output buffer properties
    virtual DWORD Get3dOutputSampleRate(void) = 0;
};

// Base class for all IIR 3D objects
class CIir3dObject
    : public CSw3dObject
{
protected:
    CIirLut*                m_pLut;                  // IIR coefficient look up table
    OBJECT_IIR_CONTEXT      m_oicLeft;               // Left channel context
    OBJECT_IIR_CONTEXT      m_oicRight;              // Right channel context
    BOOL                    m_fUpdatedCoeffs;
    PVOID                   m_pSigmaCoeffs;
    UINT                    m_ulNumSigmaCoeffs;
    PVOID                   m_pDeltaCoeffs;
    UINT                    m_ulNumDeltaCoeffs;
    BOOL                    m_fSwapChannels;

public:
    CIir3dObject(C3dListener *, REFGUID, BOOL, BOOL, DWORD);
    virtual ~CIir3dObject(void);

public:
    // Initialization
    virtual HRESULT Initialize(void);

protected:
    // Nasty math
    virtual void UpdateAlgorithmHrp(D3DVECTOR *);

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void) = 0;

    // Desired Filter Coefficient Format
    virtual HRESULT GetFilterMethodAndCoeffFormat(KSDS3D_HRTF_FILTER_METHOD*,KSDS3D_HRTF_COEFF_FORMAT*) = 0;
    virtual HRESULT InitializeFilters(KSDS3D_HRTF_FILTER_QUALITY, FLOAT, ULONG, ULONG, ULONG, ULONG) = 0;
};

// Simple stereo pan 3D object
class CPan3dObject
    : public CSw3dObject
{
private:
    CSecondaryRenderWaveBuffer *    m_pBuffer;
    FLOAT                           m_flPowerRight;
    LONG                            m_lUserVolume;
    BOOL                            m_fUserMute;

public:
    CPan3dObject(C3dListener *, BOOL, BOOL, DWORD, CSecondaryRenderWaveBuffer *);
    virtual ~CPan3dObject(void);

public:
    // Object events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

private:
    // Nasty math
    virtual void UpdateAlgorithmHrp(D3DVECTOR *);
    virtual LONG CalculateVolume(void);
    virtual LONG CalculatePan(void);

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void);
};

// Wrapper 3D object
class CWrapper3dObject
    : public C3dObject
{
protected:
    C3dObject *             m_p3dObject;            // Pointer to the real 3D object
    DSVOLUMEPAN             m_dsvpUserAttenuation;  // Last attenuation set by the user
    DWORD                   m_dwUserFrequency;      // Last buffer frequency set by the user
    BOOL                    m_fUserMute;            // Last mute status set by the user

public:
    CWrapper3dObject(C3dListener *, REFGUID, BOOL, BOOL, DWORD);
    virtual ~CWrapper3dObject(void);

public:
    // The actual 3D object
    virtual HRESULT SetObjectPointer(C3dObject *);

    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Object properties
    virtual HRESULT SetConeAngles(DWORD, DWORD, BOOL);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, BOOL);
    virtual HRESULT SetConeOutsideVolume(LONG, BOOL);
    virtual HRESULT SetMaxDistance(FLOAT, BOOL);
    virtual HRESULT SetMinDistance(FLOAT, BOOL);
    virtual HRESULT SetMode(DWORD, BOOL);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, BOOL);

    // Buffer events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

    // Buffer recalc
    virtual HRESULT Recalc(DWORD, DWORD);

    // Object location
    virtual DWORD GetObjectLocation(void);
};

#endif // __cplusplus

#endif // __DS3D_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsadmin.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsadmin.h
 *  Content:    DirectSound Administrator
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/9/97      dereks  Created
 *  2/13/97     dereks  Focus manager reborn as Administrator.
 *
 ***************************************************************************/

#ifndef __DSADMIN_H__
#define __DSADMIN_H__

#include "streamer.h"

#ifndef SHARED
#define SHARED_THREAD_LIST
#endif

#define WAITDELAY_DEFAULT   500
#define WAITDELAY_CAPTURE   200

typedef struct tagDSCOOPERATIVELEVEL
{
    DWORD               dwThreadId;
    DWORD               dwPriority;
} DSCOOPERATIVELEVEL, *LPDSCOOPERATIVELEVEL;

typedef struct tagDSFOCUS
{
    HWND                hWnd;
    UINT                uState;
    BOOL                fApmSuspend;
} DSFOCUS, *LPDSFOCUS;

#ifdef SHARED_THREAD_LIST

typedef struct tagDSSHAREDTHREADLISTDATA
{
    DWORD               dwProcessId;
    DSCOOPERATIVELEVEL  dsclCooperativeLevel;
} DSSHAREDTHREADLISTDATA, *LPDSSHAREDTHREADLISTDATA;

typedef struct tagDSSHAREDCAPTUREFOCUSDATA
{
    DWORD               dwProcessId;
    HWND                hWndFocus;
    DWORD               fdwFlags;
} DSSHAREDCAPTUREFOCUSDATA, *LPDSSHAREDCAPTUREFOCUSDATA;

// Flags that can be used in the DSSHAREDCAPTUREFOCUSDATA.fdwFlags field
#define DSCBFLAG_UPDATE 0x00000100
#define DSCBFLAG_YIELD  0x00000200
#define DSCBFLAG_FOCUS  0x00000400
#define DSCBFLAG_STRICT 0x00000800

#endif // SHARED_THREAD_LIST

typedef enum
{
    DSBUFFERFOCUS_INFOCUS = 0,
    DSBUFFERFOCUS_OUTOFFOCUS,
    DSBUFFERFOCUS_LOST
} DSBUFFERFOCUS, *LPDSBUFFERFOCUS;

#ifdef __cplusplus

// Forward declarations
class CDirectSound;
class CClassFactory;
class CDirectSoundCapture;
class CDirectSoundFullDuplex;
class CDirectSoundBuffer;
class CDirectSoundBufferConfig;

// The DirectSound Administrator object
class CDirectSoundAdministrator
    : public CDsBasicRuntime, private CThread
{
public:
    CList<CDirectSound*>            m_lstDirectSound;       // List of DirectSound objects
    CList<CDirectSoundCapture*>     m_lstCapture;           // List of DirectSoundCapture objects
    CList<CDirectSoundFullDuplex*>  m_lstFullDuplex;        // List of DirectSoundFullDuplex objects
    CList<CDirectSoundSink*>        m_lstDirectSoundSink;   // List of DirectSoundSink objects
    CList<CDirectSoundBufferConfig*>m_lstDSBufferConfig;    // List of CDirectSoundBufferConfig objects
    CList<CClassFactory*>           m_lstClassFactory;      // List of ClassFactory objects

private:
    CRefCount                       m_rcThread;             // Thread reference count
    DSFOCUS                         m_dsfCurrent;           // Current focus state
    DSCOOPERATIVELEVEL              m_dsclCurrent;          // Cooperative level of window in focus
    DWORD                           m_dwWaitDelay;          // Amount of time set for wait
    ULONG                           m_ulConsoleSessionId;   // TS session currently owning the console
    
#ifdef SHARED
    HANDLE                          m_hApmSuspend;          // APM suspend event
#endif // SHARED

#ifdef SHARED_THREAD_LIST
    static const DWORD              m_dwSharedThreadLimit;  // Arbitrary limitation of threads in the shared list
    CSharedMemoryBlock *            m_pSharedThreads;       // Shared thread ID array
    static const DWORD              m_dwCaptureDataLimit;   // Arbitrary limitation of threads in the shared list
    CSharedMemoryBlock *            m_pCaptureFocusData;    // Shared thread ID array
#endif // SHARED_THREAD_LIST

public:
    CDirectSoundAdministrator(void);
    ~CDirectSoundAdministrator(void);

public:
    // Creation
    HRESULT Initialize(void);
    HRESULT Terminate(void);

    // Focus state
    void UpdateGlobalFocusState(BOOL);
    DSBUFFERFOCUS GetBufferFocusState(CDirectSoundBuffer *);
    void UpdateCaptureState(void);
    static BOOL CALLBACK EnumWinProc(HWND hWnd, LPARAM lParam);
    static BOOL IsCaptureSplitterAvailable();

    // Object maintainance
    void RegisterObject(CDirectSound*);
    void UnregisterObject(CDirectSound*);
    void RegisterObject(CDirectSoundCapture* pObj)      {m_lstCapture.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundCapture* pObj)    {m_lstCapture.RemoveDataFromList(pObj);}
    void RegisterObject(CDirectSoundFullDuplex* pObj)   {m_lstFullDuplex.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundFullDuplex* pObj) {m_lstFullDuplex.RemoveDataFromList(pObj);}
    void RegisterObject(CDirectSoundSink* pObj)         {m_lstDirectSoundSink.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundSink* pObj)       {m_lstDirectSoundSink.RemoveDataFromList(pObj);}
    void RegisterObject(CDirectSoundBufferConfig* pObj) {m_lstDSBufferConfig.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundBufferConfig*pObj){m_lstDSBufferConfig.RemoveDataFromList(pObj);}
    void RegisterObject(CClassFactory* pObj)            {m_lstClassFactory.AddNodeToList(pObj);}
    void UnregisterObject(CClassFactory* pObj)          {m_lstClassFactory.RemoveDataFromList(pObj);}
    DWORD FreeOrphanedObjects(DWORD, BOOL);

#ifdef SHARED_THREAD_LIST

    // Shared thread list
    HRESULT UpdateSharedThreadList(void);
    HRESULT UpdateCaptureFocusList(void);

    // Capture Focus list
    HRESULT WriteCaptureFocusList(void);

#endif // SHARED_THREAD_LIST

private:
    // Focus state
    void GetSystemFocusState(LPDSFOCUS);
    void GetDsoundFocusState(LPDSCOOPERATIVELEVEL, LPBOOL);
    void HandleFocusChange(void);
    void HandleCaptureFocusChange(HWND hWndCurrent);

    // The worker thread proc
    HRESULT ThreadProc(void);

#ifdef SHARED_THREAD_LIST

    // Shared thread list
    HRESULT CreateSharedThreadList(void);
    HRESULT ReadSharedThreadList(CList<DSSHAREDTHREADLISTDATA> *);
    HRESULT WriteSharedThreadList(void);

    // Shared Capture Focus Data
    HRESULT CreateCaptureFocusList(void);
    HRESULT ReadCaptureFocusList(CList<DSSHAREDCAPTUREFOCUSDATA> *);
    HRESULT MarkUpdateCaptureFocusList(DWORD dwProcessId, BOOL fUpdate);

#endif // SHARED_THREAD_LIST

};

inline void CDirectSoundAdministrator::RegisterObject(CDirectSound *pObject)
{
    m_lstDirectSound.AddNodeToList(pObject);

#ifdef SHARED_THREAD_LIST

    // Make sure the thread list actually exists.  We do this here and in
    // ::Initialize because ::RegisterObject may be called before
    // ::Initialize.
    CreateSharedThreadList();

    UpdateSharedThreadList();

#endif // SHARED_THREAD_LIST

}

inline void CDirectSoundAdministrator::UnregisterObject(CDirectSound *pObject)
{
    m_lstDirectSound.RemoveDataFromList(pObject);

#ifdef SHARED_THREAD_LIST

    UpdateSharedThreadList();

#endif // SHARED_THREAD_LIST

}

// The one and only DirectSound Administrator
extern CDirectSoundAdministrator *g_pDsAdmin;

typedef struct tagDSENUMWINDOWINFO
{
#ifdef SHARED_THREAD_LIST
    CNode<DSSHAREDCAPTUREFOCUSDATA> *pDSC;
    DWORD                            dwId;
#else   // SHARED_THREAD_LIST
    CNode<CDirectSoundCapture *>    *pDSC;
#endif  // SHARED_THREAD_LIST
    HWND                             hWndFocus;
} DSENUMWINDOWINFO, *LPDSENUMWINDOWINFO;

#endif // __cplusplus

#endif // __DSADMIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsadmin.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsadmin.cpp
 *  Content:    DirectSound Administrator
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/9/97      dereks  Created
 *  2/13/97     dereks  Focus manager reborn as Administrator.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "nt.h"         // For USER_SHARED_DATA
#include "ntrtl.h"
#include "nturtl.h"
#include "dsoundi.h"

#ifdef SHARED
#include "ddhelp.h"
#endif


/***************************************************************************
 *
 *  CDirectSoundAdministrator
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::CDirectSoundAdministrator"

#ifdef SHARED_THREAD_LIST

const DWORD CDirectSoundAdministrator::m_dwSharedThreadLimit = 1024;
const DWORD CDirectSoundAdministrator::m_dwCaptureDataLimit  = 1024;

#endif // SHARED_THREAD_LIST

CDirectSoundAdministrator::CDirectSoundAdministrator(void)
    : CThread(TRUE, TEXT("DirectSound Administrator"))
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundAdministrator);

    // Initialize defaults

#ifdef SHARED
    m_hApmSuspend = NULL;
#endif // SHARED

#ifdef SHARED_THREAD_LIST
    m_pSharedThreads = NULL;
#endif // SHARED_THREAD_LIST

    m_dwWaitDelay = WAITDELAY_DEFAULT;
    m_ulConsoleSessionId = -1;
    
    // Initialize the default focus
    ZeroMemory(&m_dsfCurrent, sizeof(m_dsfCurrent));
    ZeroMemory(&m_dsclCurrent, sizeof(m_dsclCurrent));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundAdministrator
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::~CDirectSoundAdministrator"

CDirectSoundAdministrator::~CDirectSoundAdministrator(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundAdministrator);

    // Terminate the worker thread
    CThread::Terminate();

    // Free resources

#ifdef SHARED
    CLOSE_HANDLE(m_hApmSuspend);
#endif // SHARED

#ifdef SHARED_THREAD_LIST
    RELEASE(m_pSharedThreads);
    RELEASE(m_pCaptureFocusData);
#endif // SHARED_THREAD_LIST

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::Initialize"

HRESULT CDirectSoundAdministrator::Initialize(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

#ifdef SHARED

    // Create synchronization objects
    if(!m_hApmSuspend)
    {
        m_hApmSuspend = CreateGlobalEvent(TEXT(DDHELP_APMSUSPEND_EVENT_NAME), TRUE);
        hr = HRFROMP(m_hApmSuspend);
    }

#endif // SHARED

#ifdef SHARED_THREAD_LIST

    // Make sure the thread lists exist
    if (SUCCEEDED(hr))
    {
        hr = CreateSharedThreadList();
    }

    if (SUCCEEDED(hr))
    {
        hr = CreateCaptureFocusList();
    }

#endif // SHARED_THREAD_LIST

    // Initialize focus state
    if(SUCCEEDED(hr))
    {
        UpdateGlobalFocusState(TRUE);
    }

    // Create the worker thread
    if(SUCCEEDED(hr) && !m_hThread)
    {
        hr = CThread::Initialize();
    }

    // Increment the reference count
    if(SUCCEEDED(hr))
    {
        m_rcThread.AddRef();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Terminates the thread.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::Terminate"

HRESULT CDirectSoundAdministrator::Terminate(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(!m_rcThread.Release())
    {
        hr = CThread::Terminate();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ThreadProc
 *
 *  Description:
 *      Main thread proc for the DirectSound Administrator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::ThreadProc"

HRESULT CDirectSoundAdministrator::ThreadProc(void)
{
    BOOL                    fContinue;

    DPF_ENTER();

    fContinue = TpWaitObjectArray(m_dwWaitDelay, 0, NULL, NULL);

    if(fContinue)
    {
        UpdateGlobalFocusState(FALSE);
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  UpdateGlobalFocusState
 *
 *  Description:
 *      Updates focus state for the entire system.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to force refresh.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateGlobalFocusState"

void CDirectSoundAdministrator::UpdateGlobalFocusState(BOOL fForce)
{
    DSFOCUS                 dsf;
    DSCOOPERATIVELEVEL      dscl;

    DPF_ENTER();

#pragma TODO("Make this function thread-safe when called from the worker thread")

    // Save the current focus state
    CopyMemory(&dsf, &m_dsfCurrent, sizeof(m_dsfCurrent));
    CopyMemory(&dscl, &m_dsclCurrent, sizeof(m_dsclCurrent));

    // Update the system focus state
    GetSystemFocusState(&m_dsfCurrent);

    // Update the dsound focus state
    GetDsoundFocusState(&m_dsclCurrent, &fForce);

    // Has anything really changed?
    if(!fForce)
    {
        fForce = !CompareMemory(&dscl, &m_dsclCurrent, sizeof(m_dsclCurrent));
    }

    // If it has, handle the change for the render buffers
    if(fForce)
    {
        HandleFocusChange();
    }

    // If a different TS session has taken ownership of the console,
    // we need to force a capture focus update
    if(m_ulConsoleSessionId != USER_SHARED_DATA->ActiveConsoleId)
    {
        m_ulConsoleSessionId = USER_SHARED_DATA->ActiveConsoleId;
        fForce = TRUE;
    }
    
    // Handle the focus change for the capture buffers
    if(fForce)
    {
        HandleCaptureFocusChange(m_dsfCurrent.hWnd);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumWinProc
 *
 *  Description:
 *      EnumWindow callback function.
 *
 *  Arguments:
 *      HWND [in]: Current window that has focus.
 *      LPARAM [in]: Pointer to a DSENUMWINDOWINFO structure.
 *
 *  Returns:
 *      (BOOL) TRUE to continue enumerating, FALSE to stop.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::EnumWinProc"

BOOL CALLBACK CDirectSoundAdministrator::EnumWinProc(HWND hWnd, LPARAM lParam)
{
#ifdef SHARED_THREAD_LIST

    LPDSENUMWINDOWINFO                      pDSEnumInfo;
    CNode<DSSHAREDCAPTUREFOCUSDATA>        *pDSC;

    pDSEnumInfo = (LPDSENUMWINDOWINFO)lParam;

    // Are we looking for top level window?
    if (NULL == pDSEnumInfo->pDSC)
    {
        pDSEnumInfo->hWndFocus = hWnd;
        return FALSE;
    }

    // Finding highest Z-order window...
    for (pDSC = pDSEnumInfo->pDSC; pDSC; pDSC = pDSC->m_pNext)
    {
        if ((hWnd == pDSC->m_data.hWndFocus) &&
            !(pDSC->m_data.fdwFlags & DSCBFLAG_YIELD) &&
            !(pDSC->m_data.fdwFlags & DSCBFLAG_STRICT))
        {
            // Found it
            DPF(DPFLVL_INFO, "Found window handle 0x%08lx", hWnd);
            pDSEnumInfo->dwId = pDSC->m_data.dwProcessId;
            pDSEnumInfo->hWndFocus = hWnd;
            return FALSE;
        }
    }

#else // SHARED_THREAD_LIST

    LPDSENUMWINDOWINFO                      pDSEnumInfo;
    CNode<CDirectSoundCapture *> *          pCObjectNode;
    CNode<CDirectSoundCaptureBuffer *> *    pCBufferNode;
    HRESULT                                 hr;

    pDSEnumInfo = (LPDSENUMWINDOWINFO)lParam;

    // Are we looking for top level window?
    if (NULL == pDSEnumInfo->pDSC)
    {
        pDSEnumInfo->hWndFocus = hWnd;
        return FALSE;
    }

    for (pCObjectNode = pDSEnumInfo->pDSC; pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
    {
        hr = pCObjectNode->m_data->IsInit();
        if (FAILED(hr))
            continue;

        for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
        {
            hr = pCBufferNode->m_data->IsInit();
            if (SUCCEEDED(hr))
            {
                if ((hWnd == pCBufferNode->m_data->m_hWndFocus) &&
                    !(pCBufferNode->m_data->m_pDeviceBuffer->m_fYieldedFocus) &&
                    !(pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags & DSCBCAPS_STRICTFOCUS))
                {
                    // Found it
                    DPF(DPFLVL_INFO, "EnumWinProc found 0x%08lx", hWnd);
                    pDSEnumInfo->hWndFocus = hWnd;
                    return FALSE;
                }
            }
        }
    }

#endif // SHARED_THREAD_LIST

    // Hmm... Still haven't found it
    return TRUE;
}


/***************************************************************************
 *
 *  UpdateCaptureState
 *
 *  Description:
 *      Updates focus state for the capture system.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateCaptureState"

void CDirectSoundAdministrator::UpdateCaptureState(void)
{
    DPF_ENTER();

#ifdef SHARED_THREAD_LIST
    // Write the status of the current buffers before updating focus status
    WriteCaptureFocusList();
#endif

    HandleCaptureFocusChange(GetForegroundApplication());

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  HandleCaptureFocusChange
 *
 *  Description:
 *      Updates focus state for the capture system.
 *
 *  Arguments:
 *      HWND [in]: Current Window that has focus.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::HandleCaptureFocusChange"

void CDirectSoundAdministrator::HandleCaptureFocusChange(HWND hWndFocus)
{
    CNode<CDirectSoundCapture *> *          pCObjectNode;
    CNode<CDirectSoundCaptureBuffer *> *    pCBufferNode;
    DSENUMWINDOWINFO                        dsewi;
    HRESULT                                 hr;

    if(TpEnterDllMutex())
    {
        DPF_ENTER();

#ifdef SHARED_THREAD_LIST  // The WinNT case

        CList<DSSHAREDCAPTUREFOCUSDATA>     lstCapture;
        CNode<DSSHAREDCAPTUREFOCUSDATA> *   pCNode;
        DWORD                               dwProcess  = GetCurrentProcessId();
        DWORD                               dwTargetId = 0L;

        // Assert that we have been initialized
        ASSERT(m_pCaptureFocusData);

        // Lock the list
        m_pCaptureFocusData->Lock();

        // Get global list of capture buffers
        hr = ReadCaptureFocusList(&lstCapture);

        // Ignore regular buffers if splitter enabled (manbug #39519)
        if (!IsCaptureSplitterAvailable())
        {
            // Check for regular buffers first
            if (SUCCEEDED(hr))
            {
                for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
                {
                    if (!(pCNode->m_data.fdwFlags & DSCBFLAG_FOCUS))
                    {
                        dwTargetId = pCNode->m_data.dwProcessId;
                        hWndFocus  = pCNode->m_data.hWndFocus;
                        goto FoundWindow;
                    }
                }
            }
        }

        // No regular buffers; look for focus-aware buffers in focus
        if(SUCCEEDED(hr))
        {
            for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
            {
                if ((hWndFocus == pCNode->m_data.hWndFocus) &&
                    !(pCNode->m_data.fdwFlags & DSCBFLAG_YIELD))
                {
                    dwTargetId = pCNode->m_data.dwProcessId;
                    DPF(DPFLVL_INFO, "Process 0x%08X: Found buffer for 0x%08X (hWndFocus=0x%08X)", dwProcess, dwTargetId, hWndFocus);
                    goto FoundWindow;
                }
            }
        }

        // Have to resolve through Z-order
        if(SUCCEEDED(hr))
        {
            dsewi.pDSC      = lstCapture.GetListHead();
            dsewi.dwId      = 0L;
            dsewi.hWndFocus = NULL;

            EnumWindows(EnumWinProc, (LPARAM)&dsewi);

            dwTargetId = dsewi.dwId;
            hWndFocus  = dsewi.hWndFocus;
        }

    FoundWindow:

        if(SUCCEEDED(hr))
        {
            BOOL fStarted = TRUE;

            for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
            {
                hr = pCObjectNode->m_data->IsInit();
                if (FAILED(hr))
                    continue;

                for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
                {
                    hr = pCBufferNode->m_data->IsInit();
                    if (SUCCEEDED(hr))
                    {
                        hr = pCBufferNode->m_data->ChangeFocus(hWndFocus);

                        if (FAILED(hr))
                        {
                            DPF(DPFLVL_INFO, "Process 0x%08X: ChangeFocus failed with %s", dwProcess, HRESULTtoSTRING(hr));
                            fStarted = FALSE;
                        }
                    }
                }
            }

            if (fStarted)
            {
                // Let's mark ourselves 'clean'
                MarkUpdateCaptureFocusList(dwProcess, FALSE);
            }
            else
            {
                // This probably means that we tried to start our buffer, but another
                // process has this device allocated...

                for (dwTargetId = 0, pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
                {
                    if (pCNode->m_data.fdwFlags & VAD_BUFFERSTATE_STARTED)
                    {
                        dwTargetId = pCNode->m_data.dwProcessId;
                        break;
                    }
                }

                if (dwTargetId)
                {
                    MarkUpdateCaptureFocusList(pCNode->m_data.dwProcessId, TRUE);
                    MarkUpdateCaptureFocusList(dwProcess, TRUE);
                }
            }

            for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
            {
                if (dwProcess != pCNode->m_data.dwProcessId)
                {
                    MarkUpdateCaptureFocusList(pCNode->m_data.dwProcessId, TRUE);
                }
            }

            WriteCaptureFocusList();
        }

        // Unlock the list
        m_pCaptureFocusData->Unlock();

#else // SHARED_THREAD_LIST - the Win9x case

        if (NULL == hWndFocus)
        {
            // This should never happen!
            dsewi.pDSC      = NULL;
            dsewi.hWndFocus = NULL;
            EnumWindows(EnumWinProc, (LPARAM)&dsewi);
            hWndFocus = dsewi.hWndFocus;
        }

        // Changing this to work on a per device basis...
        // Ughh! Changing this back, as it turns out, Capture object != Capture device

        // Ignore regular buffers if splitter enabled - Manbug #39519
        if (!IsCaptureSplitterAvailable())
        {
            // First we check if there any non-focus aware buffers - Millennium bug 124237
            for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
            {
                hr = pCObjectNode->m_data->IsInit();
                if (FAILED(hr))
                    continue;

                for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
                {
                    hr = pCBufferNode->m_data->IsInit();
                    if (SUCCEEDED(hr))
                    {
                        if (0 == (DSCBCAPS_FOCUSAWARE & pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags))
                        {
                            DPF(DPFLVL_INFO, "Found non-focus aware buffer.");
                            hWndFocus = NULL;
                            goto ExitLoop;
                        }
                    }
                }
            }
        }

        // Find focus aware buffer(s) associated with current window
        for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
        {
            hr = pCObjectNode->m_data->IsInit();
            if (FAILED(hr))
                continue;

            for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                hr = pCBufferNode->m_data->IsInit();
                if (SUCCEEDED(hr))
                {
                    // Note: Not double checking the DSCB_FOCUSAWARE flag since hWnd is non-zero

                    if ((hWndFocus == pCBufferNode->m_data->m_hWndFocus) &&
                        !pCBufferNode->m_data->m_pDeviceBuffer->m_fYieldedFocus)
                    {
                        DPF(DPFLVL_INFO, "Found buffer with 0x%08lx handle", hWndFocus);
                        goto ExitLoop;
                    }
                }
            }
        }

        // Didn't find window so let's enumerate them
        dsewi.pDSC      = m_lstCapture.GetListHead();
        dsewi.hWndFocus = NULL;

        EnumWindows(EnumWinProc, (LPARAM)&dsewi);

        hWndFocus = dsewi.hWndFocus;

        DPF(DPFLVL_MOREINFO, "Found z-order window 0x%08lx handle", hWndFocus);

    ExitLoop:
        // Note: Since losing focus will potentially release a device,
        // we have to "lose" focus on appropriate buffers since it may be
        // allocated when the buffer that gains focus tries to open it.

        // Losing focus
        for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
        {
            hr = pCObjectNode->m_data->IsInit();
            if (FAILED(hr))
                continue;

            for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                hr = pCBufferNode->m_data->IsInit();
                if (SUCCEEDED(hr))
                {
                    if (hWndFocus != pCBufferNode->m_data->m_hWndFocus)
                    {
                        hr = pCBufferNode->m_data->ChangeFocus(hWndFocus);
                    }
                }
            }
        }

        // Getting focus
        for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
        {
            hr = pCObjectNode->m_data->IsInit();
            if (FAILED(hr))
                continue;

            for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                hr = pCBufferNode->m_data->IsInit();
                if (SUCCEEDED(hr))
                {
                    if (hWndFocus == pCBufferNode->m_data->m_hWndFocus)
                    {
                        hr = pCBufferNode->m_data->ChangeFocus(hWndFocus);
                    }
                }
            }
        }

#endif // SHARED_THREAD_LIST

        DPF_LEAVE_VOID();
        LEAVE_DLL_MUTEX();
    }
}


/***************************************************************************
 *
 *  HandleFocusChange
 *
 *  Description:
 *      Updates focus state for the entire system.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::HandleFocusChange"

void CDirectSoundAdministrator::HandleFocusChange(void)
{
    CDirectSoundPrimaryBuffer *             pPrimaryInFocus = NULL;
    CNode<CDirectSound *> *                 pObjectNode;
    CNode<CDirectSoundSecondaryBuffer *> *  pBufferNode;
    CNode<CDirectSoundSecondaryBuffer *> *  pCheckNode;
    CList<CDirectSoundSecondaryBuffer *>    lstInFocus;
    DSBUFFERFOCUS                           bfFocus;
    HRESULT                                 hr;

    if(TpEnterDllMutex())
    {
        DPF_ENTER();
        DPF(DPFLVL_INFO, "Focus on thread 0x%8.8lX (priority %lu)", m_dsclCurrent.dwThreadId, m_dsclCurrent.dwPriority);

        // Update the system's focus state
        for(pObjectNode = m_lstDirectSound.GetListHead(); pObjectNode; pObjectNode = pObjectNode->m_pNext)
        {
            hr = pObjectNode->m_data->IsInit();
            if(SUCCEEDED(hr))
            {
                // Update all lost and out-of-focus secondary buffers
                for(pBufferNode = pObjectNode->m_data->m_lstSecondaryBuffers.GetListHead(); pBufferNode; pBufferNode = pBufferNode->m_pNext)
                {
                    hr = pBufferNode->m_data->IsInit();
                    if(SUCCEEDED(hr))
                    {
                        bfFocus = GetBufferFocusState(pBufferNode->m_data);

                        switch(bfFocus)
                        {
                            case DSBUFFERFOCUS_INFOCUS:
                                pCheckNode = lstInFocus.AddNodeToList(pBufferNode->m_data);
                                ASSERT(pCheckNode != NULL);
                                break;

                            case DSBUFFERFOCUS_OUTOFFOCUS:
                                pBufferNode->m_data->Activate(FALSE);
                                break;

                            case DSBUFFERFOCUS_LOST:
                                pBufferNode->m_data->Lose();
                                break;
                        }
                    }
                }

                // Update all lost and out-of-focus primary buffers.  It's possible that
                // there may be more than one DirectSound object in focus, so we only
                // use the first one we find.  This also means that any primary buffers
                // that are actually in focus may be considered lost or out-of-focus.
                if(SUCCEEDED(hr) && pObjectNode->m_data->m_pPrimaryBuffer)
                {
                    hr = pObjectNode->m_data->m_pPrimaryBuffer->IsInit();

                    if(SUCCEEDED(hr))
                    {
                        if(pPrimaryInFocus != pObjectNode->m_data->m_pPrimaryBuffer)
                        {
                            bfFocus = GetBufferFocusState(pObjectNode->m_data->m_pPrimaryBuffer);

                            switch(bfFocus)
                            {
                                case DSBUFFERFOCUS_INFOCUS:
                                    if(pPrimaryInFocus)
                                    {
                                        RPF(DPFLVL_WARNING, "Multiple primary buffers are in focus!");
                                    }
                                    else
                                    {
                                        pPrimaryInFocus = pObjectNode->m_data->m_pPrimaryBuffer;
                                    }

                                    break;

                                case DSBUFFERFOCUS_OUTOFFOCUS:
                                    pObjectNode->m_data->m_pPrimaryBuffer->Activate(FALSE);
                                    break;

                                case DSBUFFERFOCUS_LOST:
                                    pObjectNode->m_data->m_pPrimaryBuffer->Lose();
                                    break;
                            }
                        }
                    }
                }
            }
        }

        // Activate the primary buffer that's in focus
        if(pPrimaryInFocus)
        {
            pPrimaryInFocus->Activate(TRUE);
        }

        // Activate all in-focus secondary buffers
        for(pBufferNode = lstInFocus.GetListHead(); pBufferNode; pBufferNode = pBufferNode->m_pNext)
        {
            pBufferNode->m_data->Activate(TRUE);
        }

        DPF_LEAVE_VOID();
        LEAVE_DLL_MUTEX();
    }
}


/***************************************************************************
 *
 *  GetSystemFocusState
 *
 *  Description:
 *      Determines the thread that currently has focus, and it's
 *      priority (cooperative level).
 *
 *  Arguments:
 *      LPDSFOCUS [out]: receives current focus state.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::GetSystemFocusState"

void CDirectSoundAdministrator::GetSystemFocusState(LPDSFOCUS pData)
{
    DPF_ENTER();

    // WARNING: GetForegroundWindow is a 16-bit call, and therefore
    // takes the Win16 lock.
    pData->hWnd = GetForegroundApplication();
    pData->uState = GetWindowState(pData->hWnd);
    pData->fApmSuspend = FALSE;

#ifdef SHARED

    DWORD dwWait = WaitObject(0, m_hApmSuspend);

    if(WAIT_OBJECT_0 == dwWait)
    {
        pData->fApmSuspend = TRUE;
    }

#endif // SHARED

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetDsoundFocusState
 *
 *  Description:
 *      Determines the thread that currently has focus, and it's
 *      priority (cooperative level).
 *
 *  Arguments:
 *      LPDSCOOPERATIVELEVEL [out]: receives current focus state.
 *      LPBOOL [out]: receives a flag to force a focus update
 *
 *  Returns:
 *      BOOL: TRUE if the current focus state agrees with the Administrator.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::GetDsoundFocusState"

void CDirectSoundAdministrator::GetDsoundFocusState(LPDSCOOPERATIVELEVEL pData, LPBOOL pfForce)
{
#ifdef SHARED_THREAD_LIST
    CList<DSSHAREDTHREADLISTDATA>       lstThreads;
    CNode<DSSHAREDTHREADLISTDATA> *     pNode;
    CList<DSSHAREDCAPTUREFOCUSDATA>     lstCapture;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *   pCNode;
    HRESULT                             hr;
#else // SHARED_THREAD_LIST
    CNode<CDirectSound *> *             pNode;
#endif // SHARED_THREAD_LIST

    LPDSCOOPERATIVELEVEL            pdsclCheck;

    DPF_ENTER();
    CHECK_WRITE_PTR(pData);
    CHECK_WRITE_PTR(pfForce);    

    // Initialize
    pData->dwThreadId = 0;
    pData->dwPriority = DSSCL_NONE;

    // No thread is in focus if we're suspended, no window is in focus,
    // or the window in focus is minimized.
    if(!m_dsfCurrent.fApmSuspend)
    {
        if(m_dsfCurrent.hWnd && IsWindow(m_dsfCurrent.hWnd))
        {
            if(SW_SHOWMINIMIZED != m_dsfCurrent.uState)
            {
                pData->dwThreadId = GetWindowThreadProcessId(m_dsfCurrent.hWnd, NULL);
            }
        }
    }

    // Walk the list of DirectSound objects looking for the one with the
    // highest priority that has focus set to this thread id.
    if(pData->dwThreadId)
    {

#ifdef SHARED_THREAD_LIST

        hr = ReadSharedThreadList(&lstThreads);

        if(SUCCEEDED(hr))
        {
            for(pNode = lstThreads.GetListHead(); pNode; pNode = pNode->m_pNext)
            {
                pdsclCheck = &pNode->m_data.dsclCooperativeLevel;

#else // SHARED_THREAD_LIST

            for(pNode = m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
            {
                pdsclCheck = &pNode->m_data->m_dsclCooperativeLevel;
                ASSERT(pNode->m_data);  // See Millennium bug 126722
                if (pNode->m_data)

#endif // SHARED_THREAD_LIST

                if(pData->dwThreadId == pdsclCheck->dwThreadId)
                {
                    pData->dwPriority = max(pData->dwPriority, pdsclCheck->dwPriority);
                }
            }

#ifdef SHARED_THREAD_LIST

        }

#endif // SHARED_THREAD_LIST

#ifdef SHARED_THREAD_LIST
    hr = ReadCaptureFocusList(&lstCapture);

    if (SUCCEEDED(hr))
    {
        DWORD dwProcessId = GetCurrentProcessId();

        for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
        {
            // Are we marked as update?
            if ((dwProcessId == pCNode->m_data.dwProcessId) && (pCNode->m_data.fdwFlags & DSCBFLAG_UPDATE))
            {
                *pfForce = TRUE;
                DPF(DPFLVL_INFO, "Focus update requested by another application");
            }
        }
    }
#endif // SHARED_THREAD_LIST

    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetBufferFocusState
 *
 *  Description:
 *      Determines if a buffer should be muted or not based on the current
 *      focus state.
 *
 *  Arguments:
 *      CDirectSoundBuffer * [in]: object for which to update focus state.
 *
 *  Returns:
 *      DSBUFFERFOCUS: buffer focus state.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::GetBufferFocusState"

DSBUFFERFOCUS CDirectSoundAdministrator::GetBufferFocusState(CDirectSoundBuffer *pBuffer)
{
    DSBUFFERFOCUS           bfFocus     = DSBUFFERFOCUS_INFOCUS;
    BOOL                    fFriends;

    DPF_ENTER();

    // If we're in an APM suspension state, all buffers are lost.  If a
    // WRITEPRIMARY app is in focus, all other buffers are lost.  If a
    // WRITEPRIMARY app is out of focus, it's lost.
    if(m_dsfCurrent.fApmSuspend)
    {
        DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because of APM suspension", pBuffer);
        bfFocus = DSBUFFERFOCUS_LOST;
    }
    else
    {
        if(DSSCL_WRITEPRIMARY == m_dsclCurrent.dwPriority)
        {
            if(!(pBuffer->m_dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER) || m_dsclCurrent.dwThreadId != pBuffer->m_pDirectSound->m_dsclCooperativeLevel.dwThreadId)
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because a WRITEPRIMARY app is in focus", pBuffer);
                bfFocus = DSBUFFERFOCUS_LOST;
            }
        }
        else if(DSSCL_WRITEPRIMARY == pBuffer->m_pDirectSound->m_dsclCooperativeLevel.dwPriority)
        {
            if(pBuffer->m_dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER)
            {
                if(DSSCL_NONE != m_dsclCurrent.dwPriority || !(pBuffer->m_dsbd.dwFlags & DSBCAPS_STICKYFOCUS))
                {
                    DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because it's WRITEPRIMARY and out of focus", pBuffer);
                    bfFocus = DSBUFFERFOCUS_LOST;
                }
            }
            else
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because it's secondary and WRITEPRIMARY", pBuffer);
                bfFocus = DSBUFFERFOCUS_LOST;
            }
        }
    }

    // Determine the relationship of the buffer and the object in focus.  If
    // the buffer's parent and the object in focus are the same, or the
    // buffer's parent's thread and the object's thread are the same, we
    // consider the two to be "friends", i.e. they share focus.
    if(DSBUFFERFOCUS_INFOCUS == bfFocus)
    {
        fFriends = (pBuffer->m_pDirectSound->m_dsclCooperativeLevel.dwThreadId == m_dsclCurrent.dwThreadId);

        // The DSSCL_EXCLUSIVE cooperative level is obsolescent; old apps that request
        // it should be treated as level DSSCL_PRIORITY instead (Millennium bug 102307)
        if(0)  // Was: if(m_dsclCurrent.dwPriority == DSSCL_EXCLUSIVE)
        {
            // If the app in focus is exclusive, all other buffers
            // stop playing, regardless of caps
            bfFocus = fFriends ? DSBUFFERFOCUS_INFOCUS : DSBUFFERFOCUS_OUTOFFOCUS;
        }
        else
        {
            // Assuming <= DSSCL_PRIORITY
            if(pBuffer->m_dsbd.dwFlags & DSBCAPS_GLOBALFOCUS)
            {
                // Global buffers are only muted if an exclusive app
                // comes into focus
            }
            else if(pBuffer->m_dsbd.dwFlags & DSBCAPS_STICKYFOCUS)
            {
                // Sticky buffers are only muted if another DirectSound app
                // comes into focus
                bfFocus = (fFriends || (DSSCL_NONE == m_dsclCurrent.dwPriority && (pBuffer->m_dwStatus & DSBSTATUS_ACTIVE))) ? DSBUFFERFOCUS_INFOCUS : DSBUFFERFOCUS_OUTOFFOCUS;
            }
            else
            {
                // Normal buffers are muted when any other app comes into
                // focus
                bfFocus = fFriends ? DSBUFFERFOCUS_INFOCUS : DSBUFFERFOCUS_OUTOFFOCUS;
            }
        }
    }

    DPF_LEAVE(bfFocus);
    return bfFocus;
}


/***************************************************************************
 *
 *  FreeOrphanedObjects
 *
 *  Description:
 *      Frees objects that are left behind when a process goes away.
 *
 *  Arguments:
 *      DWORD [in]: process id, or 0 for all objects.
 *      BOOL [in]: TRUE to actually free objects.
 *
 *  Returns:
 *      DWORD: count of orphaned objects that were (or must be) freed.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::FreeOrphanedObjects"

DWORD CDirectSoundAdministrator::FreeOrphanedObjects(DWORD dwProcessId, BOOL fFree)
{
    DWORD                           dwCount = 0;
    CNode<CDirectSound*>            *pDsNode,   *pDsNext;
    CNode<CDirectSoundCapture*>     *pDsCNode,  *pDsCNext;
    CNode<CDirectSoundFullDuplex*>  *pDsFdNode, *pDsFdNext;
    CNode<CDirectSoundSink*>        *pSinkNode, *pSinkNext;
    CNode<CDirectSoundBufferConfig*>*pDsBcNode, *pDsBcNext;
    CNode<CClassFactory*>           *pCfNode,   *pCfNext;

    DPF_ENTER();

    // Make sure the process cleaned up after itself.  Search the global
    // object lists for any that were owned by this process and remove them.

    // DirectSoundFullDuplex objects:
    // Must free the DSFD object before the DS or DSC objects since the DSFD
    // will also try to release its DS and DSC objects.  If these are freed
    // first, we hit a fault.
    for(pDsFdNode = m_lstFullDuplex.GetListHead(); pDsFdNode; pDsFdNode = pDsFdNext)
    {
        pDsFdNext = pDsFdNode->m_pNext;
        if(!dwProcessId || pDsFdNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundFullDuplex object at 0x%lX...", pDsFdNode->m_data->m_pImpDirectSoundFullDuplex);
                pDsFdNode->m_data->AbsoluteRelease();
            }
        }
    }

    // DirectSound objects:
    for(pDsNode = m_lstDirectSound.GetListHead(); pDsNode; pDsNode = pDsNext)
    {
        pDsNext = pDsNode->m_pNext;
        if(!dwProcessId || pDsNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSound object at 0x%lX...", pDsNode->m_data->m_pImpDirectSound);
                pDsNode->m_data->AbsoluteRelease();
            }
        }
    }

    // DirectSoundCapture objects:
    for(pDsCNode = m_lstCapture.GetListHead(); pDsCNode; pDsCNode = pDsCNext)
    {
        pDsCNext = pDsCNode->m_pNext;
        if(!dwProcessId || pDsCNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundCapture object at 0x%lX...", pDsCNode->m_data->m_pImpDirectSoundCapture);
                pDsCNode->m_data->AbsoluteRelease();
            }
        }
    }

    // DirectSoundSink objects:
    for(pSinkNode = m_lstDirectSoundSink.GetListHead(); pSinkNode; pSinkNode = pSinkNext)
    {
        pSinkNext = pSinkNode->m_pNext;
        if(!dwProcessId || pSinkNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundSink object at 0x%lX...", pSinkNode->m_data->m_pImpDirectSoundSink);
                pSinkNode->m_data->AbsoluteRelease();
            }
        }
    }

    // CDirectSoundBufferConfig objects:
    for(pDsBcNode = m_lstDSBufferConfig.GetListHead(); pDsBcNode; pDsBcNode = pDsBcNext)
    {
        pDsBcNext = pDsBcNode->m_pNext;
        if(!dwProcessId || pDsBcNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                DPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundBufferConfig object at 0x%lX...", pDsBcNode->m_data);
                pDsBcNode->m_data->AbsoluteRelease();
            }
        }
    }

    // Class factory objects:
    for(pCfNode = m_lstClassFactory.GetListHead(); pCfNode; pCfNode = pCfNext)
    {
        pCfNext = pCfNode->m_pNext;
        if(!dwProcessId || pCfNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned class factory object...");
                pCfNode->m_data->AbsoluteRelease();
            }
        }
    }

    DPF_LEAVE(dwCount);
    return dwCount;
}


/***************************************************************************
 *
 *  IsCaptureSplitterAvailable
 *
 *  Description:
 *      Checks the availability of the capture splitter.
 *      NOTE: this function could be a global helper function.  There's no
 *      reason for it to be a static member of CDirectSoundAdministrator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if available, FALSE otherwise.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::IsCaptureSplitterAvailable"

BOOL CDirectSoundAdministrator::IsCaptureSplitterAvailable(void)
{
    static BOOL fChecked = FALSE;
    static BOOL fSplitter;

    DPF_ENTER();

    if (!fChecked)
    {
        // The capture splitter is only present on Windows ME, XP and later
        WINVERSION vers = GetWindowsVersion();
        fSplitter = (vers == WIN_ME || vers >= WIN_XP);
        fChecked = TRUE;
    }

    DPF_LEAVE(fSplitter);
    return fSplitter;
}


/***************************************************************************
 *
 *  UpdateSharedThreadList
 *
 *  Description:
 *      Updates the shared thread list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateSharedThreadList"

HRESULT CDirectSoundAdministrator::UpdateSharedThreadList(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = WriteSharedThreadList();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST



/***************************************************************************
 *
 *  CreateSharedThreadList
 *
 *  Description:
 *      Creates the shared thread list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::CreateSharedThreadList"

HRESULT CDirectSoundAdministrator::CreateSharedThreadList(void)
{
    const LPCTSTR           pszName = TEXT("DirectSound Administrator shared thread array");
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if(!m_pSharedThreads)
    {
        m_pSharedThreads = NEW(CSharedMemoryBlock);
        hr = HRFROMP(m_pSharedThreads);

        if(SUCCEEDED(hr))
        {
            hr = m_pSharedThreads->Initialize(PAGE_READWRITE, sizeof(DSSHAREDTHREADLISTDATA) * m_dwSharedThreadLimit, pszName);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


/***************************************************************************
 *
 *  ReadSharedThreadList
 *
 *  Description:
 *      Reads the shared thread list.
 *
 *  Arguments:
 *      CList * [out]: receives shared thread list data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::ReadSharedThreadList"

HRESULT CDirectSoundAdministrator::ReadSharedThreadList(CList<DSSHAREDTHREADLISTDATA> *plst)
{
    LPDSSHAREDTHREADLISTDATA        pData   = NULL;
    DWORD                           cbData  = 0;
    HRESULT                         hr      = DS_OK;
    CNode<DSSHAREDTHREADLISTDATA> * pNode;
    DWORD                           i;

    DPF_ENTER();

    ASSERT(!plst->GetNodeCount());

    // Assert that we've been initialized.  Initialization used to happen here,
    // but it was moved to make shared memory access thread-safe across processes.
    ASSERT(m_pSharedThreads);

    // Lock the list
    m_pSharedThreads->Lock();

    // Read the thread list
    if(SUCCEEDED(hr))
    {
        hr = m_pSharedThreads->Read((LPVOID *)&pData, &cbData);
    }

    // Convert to list format
    if(SUCCEEDED(hr))
    {
        ASSERT(!(cbData % sizeof(*pData)));

        for(i = 0; i < cbData / sizeof(*pData) && SUCCEEDED(hr); i++)
        {
            pNode = plst->AddNodeToList(pData[i]);
            hr = HRFROMP(pNode);
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unlock the list
    m_pSharedThreads->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


/***************************************************************************
 *
 *  WriteSharedThreadList
 *
 *  Description:
 *      Writes the shared thread list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::WriteSharedThreadList"

HRESULT CDirectSoundAdministrator::WriteSharedThreadList(void)
{
    LPDSSHAREDTHREADLISTDATA        pData       = NULL;
    CList<DSSHAREDTHREADLISTDATA>   lstThreads;
    DSSHAREDTHREADLISTDATA          dsstld;
    CNode<CDirectSound *> *         pDsNode;
    CNode<DSSHAREDTHREADLISTDATA> * pThNode;
    CNode<DSSHAREDTHREADLISTDATA> * pThNext;
    DWORD                           dwCount;
    UINT                            i;
    HRESULT                         hr;

    DPF_ENTER();

    // Save the current process id
    dsstld.dwProcessId = GetCurrentProcessId();

    // Assert that we've been Initialized.
    ASSERT(m_pSharedThreads);

    // Lock the list
    m_pSharedThreads->Lock();

    // Get the shared thread list.  This will also make sure the list is
    // created and initialized.
    hr = ReadSharedThreadList(&lstThreads);

    // Remove our old threads from the list
    if(SUCCEEDED(hr))
    {
        pThNode = lstThreads.GetListHead();

        while(pThNode)
        {
            pThNext = pThNode->m_pNext;

            if(dsstld.dwProcessId == pThNode->m_data.dwProcessId)
            {
                lstThreads.RemoveNodeFromList(pThNode);
            }

            pThNode = pThNext;
        }
    }

    // Add our new threads to the list
    if(SUCCEEDED(hr))
    {
        for(pDsNode = m_lstDirectSound.GetListHead(); pDsNode && SUCCEEDED(hr); pDsNode = pDsNode->m_pNext)
        {
            dsstld.dsclCooperativeLevel.dwThreadId = pDsNode->m_data->m_dsclCooperativeLevel.dwThreadId;
            dsstld.dsclCooperativeLevel.dwPriority = pDsNode->m_data->m_dsclCooperativeLevel.dwPriority;

            hr = HRFROMP(lstThreads.AddNodeToList(dsstld));
            ASSERT(SUCCEEDED(hr));
        }
    }

    // Write the shared thread list
    if(SUCCEEDED(hr) && (dwCount = lstThreads.GetNodeCount()))
    {
        if(dwCount > m_dwSharedThreadLimit)
        {
            DPF(DPFLVL_ERROR, "Reached arbitrary limitation!  %lu threads will not be written to the shared list!", dwCount - m_dwSharedThreadLimit);
            dwCount = m_dwSharedThreadLimit;
        }

        pData = MEMALLOC_A(DSSHAREDTHREADLISTDATA, dwCount);
        hr = HRFROMP(pData);

        if(SUCCEEDED(hr))
        {
            for(i = 0, pThNode = lstThreads.GetListHead(); i < dwCount; i++, pThNode = pThNode->m_pNext)
            {
                ASSERT(pThNode);
                CopyMemory(pData + i, &pThNode->m_data, sizeof(pThNode->m_data));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_pSharedThreads->Write(pData, dwCount * sizeof(*pData));
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unock the list
    m_pSharedThreads->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateCaptureFocusList"

HRESULT CDirectSoundAdministrator::UpdateCaptureFocusList(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = WriteCaptureFocusList();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::CreateCaptureFocusList"

HRESULT CDirectSoundAdministrator::CreateCaptureFocusList(void)
{
    const LPCTSTR           pszName = TEXT("DirectSound Administrator capture focus array");
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if(!m_pCaptureFocusData)
    {
        m_pCaptureFocusData = NEW(CSharedMemoryBlock);
        hr = HRFROMP(m_pCaptureFocusData);

        if(SUCCEEDED(hr))
        {
            hr = m_pCaptureFocusData->Initialize(PAGE_READWRITE, sizeof(DSSHAREDCAPTUREFOCUSDATA) * m_dwCaptureDataLimit, pszName);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::ReadCaptureFocusList"

HRESULT CDirectSoundAdministrator::ReadCaptureFocusList(CList<DSSHAREDCAPTUREFOCUSDATA> *plst)
{
    LPDSSHAREDCAPTUREFOCUSDATA        pData   = NULL;
    DWORD                             cbData  = 0;
    HRESULT                           hr      = DS_OK;
    CNode<DSSHAREDCAPTUREFOCUSDATA> * pNode;
    DWORD                             i;

    DPF_ENTER();

    // Assert that we've been initialized.
    // The initialization used to happen here.
    ASSERT(m_pCaptureFocusData);

    // Lock the list
    m_pCaptureFocusData->Lock();

    // Read the thread list
    if(SUCCEEDED(hr))
    {
        hr = m_pCaptureFocusData->Read((LPVOID *)&pData, &cbData);
    }

    // Convert to list format
    if(SUCCEEDED(hr))
    {
        ASSERT(!(cbData % sizeof(*pData)));

        for(i = 0; i < cbData / sizeof(*pData) && SUCCEEDED(hr); i++)
        {
            pNode = plst->AddNodeToList(pData[i]);
            hr = HRFROMP(pNode);
        }
    }

    // Clean up
    MEMFREE(pData);

    // UnlockTheList
    m_pCaptureFocusData->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::WriteCaptureFocusList"

HRESULT CDirectSoundAdministrator::WriteCaptureFocusList(void)
{
    LPDSSHAREDCAPTUREFOCUSDATA           pData       = NULL;
    CList<DSSHAREDCAPTUREFOCUSDATA>      lstThreads;
    DSSHAREDCAPTUREFOCUSDATA             dsscfd;
    CNode<CDirectSoundCapture *> *       pDscNode;
    CNode<CDirectSoundCaptureBuffer *> * pCBufferNode;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *    pThNode;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *    pThNext;
    DWORD                                dwCount;
    UINT                                 i;
    HRESULT                              hr;
    BOOL                                 fUpdate = FALSE;

    DPF_ENTER();

    // Save the current process id
    dsscfd.dwProcessId = GetCurrentProcessId();

    // Lock the list
    m_pCaptureFocusData->Lock();

    // Get the shared thread list.  This will also make sure the list is
    // created and initialized.
    hr = ReadCaptureFocusList(&lstThreads);

    // Remove our old threads from the list
    if(SUCCEEDED(hr))
    {
        pThNode = lstThreads.GetListHead();

        while(pThNode)
        {
            pThNext = pThNode->m_pNext;

            if(dsscfd.dwProcessId == pThNode->m_data.dwProcessId)
            {
                if (0 != (pThNode->m_data.fdwFlags & DSCBFLAG_UPDATE))
                {
                    fUpdate = TRUE;
                }

                lstThreads.RemoveNodeFromList(pThNode);
            }

            pThNode = pThNext;
        }
    }

    // Add our new buffers to the list
    if(SUCCEEDED(hr))
    {
        for (pDscNode = m_lstCapture.GetListHead(); pDscNode; pDscNode = pDscNode->m_pNext)
        {
            for (pCBufferNode = pDscNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                dsscfd.hWndFocus = pCBufferNode->m_data->m_hWndFocus;

                // Combine these flags to save space
                hr = pCBufferNode->m_data->GetStatus(&dsscfd.fdwFlags);
                dsscfd.fdwFlags |= (pCBufferNode->m_data->m_pDeviceBuffer->m_fYieldedFocus) ? DSCBFLAG_YIELD : 0;
                dsscfd.fdwFlags |= (pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) ? DSCBFLAG_FOCUS : 0;
                dsscfd.fdwFlags |= (pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags & DSCBCAPS_STRICTFOCUS) ? DSCBFLAG_STRICT : 0;
                dsscfd.fdwFlags |= fUpdate ? DSCBFLAG_UPDATE : 0;

                hr = HRFROMP(lstThreads.AddNodeToList(dsscfd));
                ASSERT(SUCCEEDED(hr));
            }
        }
    }

    // Write the shared thread list
    if(SUCCEEDED(hr) && (dwCount = lstThreads.GetNodeCount()))
    {
        if(dwCount > m_dwCaptureDataLimit)
        {
            DPF(DPFLVL_ERROR, "Reached arbitrary limitation!  %lu threads will not be written to the shared list!", dwCount - m_dwCaptureDataLimit);
            dwCount = m_dwCaptureDataLimit;
        }

        pData = MEMALLOC_A(DSSHAREDCAPTUREFOCUSDATA, dwCount);
        hr = HRFROMP(pData);

        if(SUCCEEDED(hr))
        {
            for(i = 0, pThNode = lstThreads.GetListHead(); i < dwCount; i++, pThNode = pThNode->m_pNext)
            {
                ASSERT(pThNode);
                CopyMemory(pData + i, &pThNode->m_data, sizeof(pThNode->m_data));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_pCaptureFocusData->Write(pData, dwCount * sizeof(*pData));
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unlock the list
    m_pCaptureFocusData->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::MarkUpdateCaptureFocusList"

HRESULT CDirectSoundAdministrator::MarkUpdateCaptureFocusList(DWORD dwProcessId, BOOL fUpdate)
{
    LPDSSHAREDCAPTUREFOCUSDATA           pData       = NULL;
    CList<DSSHAREDCAPTUREFOCUSDATA>      lstThreads;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *    pThNode;
    DWORD                                dwCount;
    UINT                                 i;
    HRESULT                              hr;

    DPF_ENTER();

    // Get the shared thread list.  This will also make sure the list is
    // created and initialized.

    // Assert that we've been initialized
    ASSERT(m_pCaptureFocusData);

    // Lock the list
    m_pCaptureFocusData->Lock();

    hr = ReadCaptureFocusList(&lstThreads);

    // Put the list in memory
    if(SUCCEEDED(hr) && (dwCount = lstThreads.GetNodeCount()))
    {
        if (dwCount > m_dwCaptureDataLimit)
        {
            DPF(DPFLVL_ERROR, "Reached arbitrary limitation!  %lu threads will not be written to the shared list!", dwCount - m_dwCaptureDataLimit);
            dwCount = m_dwCaptureDataLimit;
        }

        pData = MEMALLOC_A(DSSHAREDCAPTUREFOCUSDATA, dwCount);
        hr = HRFROMP(pData);

        if(SUCCEEDED(hr))
        {
            for(i = 0, pThNode = lstThreads.GetListHead(); i < dwCount; i++, pThNode = pThNode->m_pNext)
            {
                ASSERT(pThNode);
                CopyMemory(pData + i, &pThNode->m_data, sizeof(pThNode->m_data));

                // Change the update flag on the appropriate buffer
                if(pThNode->m_data.dwProcessId == dwProcessId)
                {
                    if (fUpdate)
                    {
                        pData[i].fdwFlags |= DSCBFLAG_UPDATE;
                    }
                    else
                    {
                        pData[i].fdwFlags &= (~DSCBFLAG_UPDATE);
                    }
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_pCaptureFocusData->Write(pData, dwCount * sizeof(*pData));
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unlock the list
    m_pCaptureFocusData->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\ds3d.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ds3d.cpp
 *  Content:    DirectSound 3D helper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/12/97     dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <math.h>

const D3DVECTOR g_vDefaultOrientationFront  = { 0.0f, 0.0f, 1.0f };
const D3DVECTOR g_vDefaultOrientationTop    = { 0.0f, 1.0f, 0.0f };
const D3DVECTOR g_vDefaultConeOrientation   = { 0.0f, 0.0f, 1.0f };
const D3DVECTOR g_vDefaultPosition          = { 0.0f, 0.0f, 0.0f };
const D3DVECTOR g_vDefaultVelocity          = { 0.0f, 0.0f, 0.0f };

/***************************************************************************
 *
 *  C3dListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::C3dListener"

C3dListener::C3dListener
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(C3dListener);

    // Initialize defaults
    m_lpCurrent.dwSize = sizeof(m_lpCurrent);
    m_lpCurrent.vPosition = g_vDefaultPosition;
    m_lpCurrent.vVelocity = g_vDefaultVelocity;
    m_lpCurrent.vOrientFront = g_vDefaultOrientationFront;
    m_lpCurrent.vOrientTop = g_vDefaultOrientationTop;
    m_lpCurrent.flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
    m_lpCurrent.flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
    m_lpCurrent.flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;

    CopyMemory(&m_lpDeferred, &m_lpCurrent, sizeof(m_lpCurrent));
    
    m_dwDeferred = 0;
    m_dwSpeakerConfig = DSSPEAKER_DEFAULT;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~C3dListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::~C3dListener"

C3dListener::~C3dListener
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(C3dListener);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CommitDeferred
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::CommitDeferred"

HRESULT 
C3dListener::CommitDeferred
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    // Update all deferred parameters
    if(m_dwDeferred & DS3DPARAM_LISTENER_DISTANCEFACTOR)
    {
        m_lpCurrent.flDistanceFactor = m_lpDeferred.flDistanceFactor;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_DOPPLERFACTOR)
    {
        m_lpCurrent.flDopplerFactor = m_lpDeferred.flDopplerFactor;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_ROLLOFFFACTOR)
    {
        m_lpCurrent.flRolloffFactor = m_lpDeferred.flRolloffFactor;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_ORIENTATION)
    {
        m_lpCurrent.vOrientFront = m_lpDeferred.vOrientFront;
        m_lpCurrent.vOrientTop = m_lpDeferred.vOrientTop;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_POSITION)
    {
        m_lpCurrent.vPosition = m_lpDeferred.vPosition;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_VELOCITY)
    {
        m_lpCurrent.vVelocity = m_lpDeferred.vVelocity;
    }

    // Commit all objects deferred parameters
    hr = CommitAllObjects();

    // Update all objects
    if(SUCCEEDED(hr))
    {
        hr = UpdateAllObjects(m_dwDeferred);
    }

    // All clean
    if(SUCCEEDED(hr))
    {
        m_dwDeferred = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets distance factor for the world.
 *
 *  Arguments:
 *      FLOAT [in]: distance factor.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetDistanceFactor"

HRESULT 
C3dListener::SetDistanceFactor
(
    FLOAT                   flDistanceFactor, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.flDistanceFactor = flDistanceFactor;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_DISTANCEFACTOR);
    }
    else
    {
        m_lpDeferred.flDistanceFactor = flDistanceFactor;
        m_dwDeferred |= DS3DPARAM_LISTENER_DISTANCEFACTOR;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets Doppler factor for the world.
 *
 *  Arguments:
 *      FLOAT [in]: Doppler factor.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetDopplerFactor"

HRESULT 
C3dListener::SetDopplerFactor
(
    FLOAT                   flDopplerFactor, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.flDopplerFactor = flDopplerFactor;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_DOPPLERFACTOR);
    }
    else
    {
        m_lpDeferred.flDopplerFactor = flDopplerFactor;
        m_dwDeferred |= DS3DPARAM_LISTENER_DOPPLERFACTOR;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets rolloff factor for the world.
 *
 *  Arguments:
 *      FLOAT [in]: rolloff factor.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetRolloffFactor"

HRESULT 
C3dListener::SetRolloffFactor
(
    FLOAT                   flRolloffFactor, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.flRolloffFactor = flRolloffFactor;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_ROLLOFFFACTOR);
    }
    else
    {
        m_lpDeferred.flRolloffFactor = flRolloffFactor;
        m_dwDeferred |= DS3DPARAM_LISTENER_ROLLOFFFACTOR;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetOrienation
 *
 *  Description:
 *      Sets listener orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetOrientation"

HRESULT 
C3dListener::SetOrientation
(
    REFD3DVECTOR            vOrientFront, 
    REFD3DVECTOR            vOrientTop, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.vOrientFront = vOrientFront;
        m_lpCurrent.vOrientTop = vOrientTop;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_ORIENTATION);
    }
    else
    {
        m_lpDeferred.vOrientFront = vOrientFront;
        m_lpDeferred.vOrientTop = vOrientTop;
        m_dwDeferred |= DS3DPARAM_LISTENER_ORIENTATION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets listener position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetPosition"

HRESULT 
C3dListener::SetPosition
(
    REFD3DVECTOR            vPosition, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.vPosition = vPosition;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_POSITION);
    }
    else
    {
        m_lpDeferred.vPosition = vPosition;
        m_dwDeferred |= DS3DPARAM_LISTENER_POSITION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets listener velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetVelocity"

HRESULT 
C3dListener::SetVelocity
(
    REFD3DVECTOR            vVelocity, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.vVelocity = vVelocity;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_VELOCITY);
    }
    else
    {
        m_lpDeferred.vVelocity = vVelocity;
        m_dwDeferred |= DS3DPARAM_LISTENER_VELOCITY;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener parameters.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetAllParameters"

HRESULT 
C3dListener::SetAllParameters
(
    LPCDS3DLISTENER         pParams, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        CopyMemoryOffset(&m_lpCurrent, pParams, sizeof(DS3DLISTENER), sizeof(pParams->dwSize));
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_PARAMMASK);
    }
    else
    {
        CopyMemoryOffset(&m_lpDeferred, pParams, sizeof(DS3DLISTENER), sizeof(pParams->dwSize));
        m_dwDeferred |= DS3DPARAM_LISTENER_PARAMMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateAllObjects
 *
 *  Description:
 *      Updates all objects in the world.
 *
 *  Arguments:
 *      DWORD [in]: listener settings to recalculate.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::UpdateAllObjects"

HRESULT 
C3dListener::UpdateAllObjects
(
    DWORD                   dwListener
)
{
    CNode<C3dObject *> *    pNode;
    HRESULT                 hr;
    
    DPF_ENTER();
    
    // Update all objects in the world
    for(pNode = m_lstObjects.GetListHead(), hr = DS_OK; pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = pNode->m_data->Recalc(dwListener, 0);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitAllObjects
 *
 *  Description:
 *      Commits deferred settings on all objects in the world.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::CommitAllObjects"

HRESULT 
C3dListener::CommitAllObjects
(
    void
)
{
    CNode<C3dObject *> *    pNode;
    HRESULT                 hr;
    
    DPF_ENTER();
    
    // Update all objects in the world
    for(pNode = m_lstObjects.GetListHead(), hr = DS_OK; pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = pNode->m_data->CommitDeferred();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets speaker config.
 *
 *  Arguments:
 *      DWORD [in]: new speaker config.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetSpeakerConfig"

HRESULT 
C3dListener::SetSpeakerConfig
(
    DWORD                   dwSpeakerConfig
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    m_dwSpeakerConfig = dwSpeakerConfig;
    hr = UpdateAllObjects(DS3DPARAM_LISTENER_SPEAKERCONFIG);
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  C3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm identifier.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::C3dObject"

C3dObject::C3dObject
(
    C3dListener *           pListener, 
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(C3dObject);

    // Initialize defaults
    ASSERT(pListener);
    
    m_pListener = pListener;
    m_pListener->AddObjectToList(this);

    m_guid3dAlgorithm = guid3dAlgorithm;
    m_fMuteAtMaxDistance = fMuteAtMaxDistance;
    m_fDopplerEnabled = fDopplerEnabled;

    m_opCurrent.dwSize = sizeof(m_opCurrent);
    m_opCurrent.vPosition = g_vDefaultPosition;
    m_opCurrent.vVelocity = g_vDefaultVelocity;
    m_opCurrent.dwInsideConeAngle = DS3D_DEFAULTCONEANGLE;
    m_opCurrent.dwOutsideConeAngle = DS3D_DEFAULTCONEANGLE;
    m_opCurrent.vConeOrientation = g_vDefaultConeOrientation;
    m_opCurrent.lConeOutsideVolume = DS3D_DEFAULTCONEOUTSIDEVOLUME;
    m_opCurrent.flMaxDistance = DS3D_DEFAULTMAXDISTANCE;
    m_opCurrent.flMinDistance = DS3D_DEFAULTMINDISTANCE;
    m_opCurrent.dwMode = DS3DMODE_NORMAL;

    CopyMemory(&m_opDeferred, &m_opCurrent, sizeof(m_opCurrent));

    m_dwDeferred = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~C3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::~C3dObject"

C3dObject::~C3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(C3dObject);

    m_pListener->RemoveObjectFromList(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the 3D object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::Initialize"

HRESULT 
C3dObject::Initialize(void)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    // It's important that the object is positioned correctly from the
    // beginning.
    hr = Recalc(DS3DPARAM_LISTENER_MASK, DS3DPARAM_OBJECT_MASK);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferred
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::CommitDeferred"

HRESULT 
C3dObject::CommitDeferred(void)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    // Update current data
    if(m_dwDeferred & DS3DPARAM_OBJECT_CONEANGLES)
    {
        m_opCurrent.dwInsideConeAngle = m_opDeferred.dwInsideConeAngle;
        m_opCurrent.dwOutsideConeAngle = m_opDeferred.dwOutsideConeAngle;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_CONEORIENTATION)
    {
        m_opCurrent.vConeOrientation = m_opDeferred.vConeOrientation;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME)
    {
        m_opCurrent.lConeOutsideVolume = m_opDeferred.lConeOutsideVolume;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_MAXDISTANCE)
    {
        m_opCurrent.flMaxDistance = m_opDeferred.flMaxDistance;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_MINDISTANCE)
    {
        m_opCurrent.flMinDistance = m_opDeferred.flMinDistance;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_MODE)
    {
        m_opCurrent.dwMode = m_opDeferred.dwMode;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_POSITION)
    {
        m_opCurrent.vPosition = m_opDeferred.vPosition;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_VELOCITY)
    {
        m_opCurrent.vVelocity = m_opDeferred.vVelocity;
    }

    // Recalculate the object parameters
    hr = Recalc(0, m_dwDeferred);

    // All clean
    if(SUCCEEDED(hr))
    {
        m_dwDeferred = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets sound cone angles.
 *
 *  Arguments:
 *      DWORD [in]: inside cone angle.
 *      DWORD [in]: outside cone angle.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetConeAngles"

HRESULT 
C3dObject::SetConeAngles
(
    DWORD                   dwInsideConeAngle, 
    DWORD                   dwOutsideConeAngle, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.dwInsideConeAngle = dwInsideConeAngle;
        m_opCurrent.dwOutsideConeAngle = dwOutsideConeAngle;
        hr = Recalc(0, DS3DPARAM_OBJECT_CONEANGLES);
    }
    else
    {
        m_opDeferred.dwInsideConeAngle = dwInsideConeAngle;
        m_opDeferred.dwOutsideConeAngle = dwOutsideConeAngle;
        m_dwDeferred |= DS3DPARAM_OBJECT_CONEANGLES;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets sound cone orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetConeOrientation"

HRESULT 
C3dObject::SetConeOrientation
(
    REFD3DVECTOR            vConeOrientation, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.vConeOrientation = vConeOrientation;
        hr = Recalc(0, DS3DPARAM_OBJECT_CONEORIENTATION);
    }
    else
    {
        m_opDeferred.vConeOrientation = vConeOrientation;
        m_dwDeferred |= DS3DPARAM_OBJECT_CONEORIENTATION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets volume outside the sound cone.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetConeOutsideVolume"

HRESULT 
C3dObject::SetConeOutsideVolume
(
    LONG                    lConeOutsideVolume, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.lConeOutsideVolume = lConeOutsideVolume;
        hr = Recalc(0, DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME);
    }
    else
    {
        m_opDeferred.lConeOutsideVolume = lConeOutsideVolume;
        m_dwDeferred |= DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the maximum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: max distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetMaxDistance"

HRESULT 
C3dObject::SetMaxDistance
(
    FLOAT                   flMaxDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.flMaxDistance = flMaxDistance;
        hr = Recalc(0, DS3DPARAM_OBJECT_MAXDISTANCE);
    }
    else
    {
        m_opDeferred.flMaxDistance = flMaxDistance;
        m_dwDeferred |= DS3DPARAM_OBJECT_MAXDISTANCE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the minimum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: min distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetMinDistance"

HRESULT 
C3dObject::SetMinDistance
(
    FLOAT                   flMinDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.flMinDistance = flMinDistance;
        hr = Recalc(0, DS3DPARAM_OBJECT_MINDISTANCE);
    }
    else
    {
        m_opDeferred.flMinDistance = flMinDistance;
        m_dwDeferred |= DS3DPARAM_OBJECT_MINDISTANCE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the object mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetMode"

HRESULT 
C3dObject::SetMode
(
    DWORD                   dwMode, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.dwMode = dwMode;
        hr = Recalc(0, DS3DPARAM_OBJECT_MODE);
    }
    else
    {
        m_opDeferred.dwMode = dwMode;
        m_dwDeferred |= DS3DPARAM_OBJECT_MODE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the object position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetPosition"

HRESULT 
C3dObject::SetPosition
(
    REFD3DVECTOR            vPosition, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.vPosition = vPosition;
        hr = Recalc(0, DS3DPARAM_OBJECT_POSITION);
    }
    else
    {
        m_opDeferred.vPosition = vPosition;
        m_dwDeferred |= DS3DPARAM_OBJECT_POSITION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the object velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR[in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetVelocity"

HRESULT 
C3dObject::SetVelocity
(
    REFD3DVECTOR            vVelocity, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.vVelocity = vVelocity;
        hr = Recalc(0, DS3DPARAM_OBJECT_VELOCITY);
    }
    else
    {
        m_opDeferred.vVelocity = vVelocity;
        m_dwDeferred |= DS3DPARAM_OBJECT_VELOCITY;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object parameters.
 *
 *  Arguments:
 *      LPCDS3DBUFFER [in]: object parameters.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetAllParameters"

HRESULT 
C3dObject::SetAllParameters
(
    LPCDS3DBUFFER           pParams, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        CopyMemoryOffset(&m_opCurrent, pParams, sizeof(DS3DBUFFER), sizeof(pParams->dwSize));
        hr = Recalc(0, DS3DPARAM_OBJECT_PARAMMASK);
    }
    else
    {
        CopyMemoryOffset(&m_opDeferred, pParams, sizeof(DS3DBUFFER), sizeof(pParams->dwSize));
        m_dwDeferred |= DS3DPARAM_OBJECT_PARAMMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  IsAtMaxDistance
 *
 *  Description:
 *      Determines if the object is muted based on distance.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the object is at its maxiumum distance.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::IsAtMaxDistance"

BOOL
C3dObject::IsAtMaxDistance
(
    void
)
{
    BOOL                    fAtMaxDistance;
    D3DVECTOR               vHrp;
    ROTATION                rotation;
    SPHERICAL               spherical;

    DPF_ENTER();

    if(DS3DMODE_DISABLE != m_opCurrent.dwMode && m_fMuteAtMaxDistance)
    {
        if(m_pListener && DS3DMODE_NORMAL == m_opCurrent.dwMode)
        {
            GetRotations(&rotation.pitch, &rotation.yaw, &rotation.roll, &m_pListener->m_lpCurrent.vOrientFront, &m_pListener->m_lpCurrent.vOrientTop);
            GetHeadRelativeVector(&vHrp, &m_opCurrent.vPosition, &m_pListener->m_lpCurrent.vPosition, rotation.pitch, rotation.yaw, rotation.roll);
            CartesianToSpherical(&spherical.rho, &spherical.theta, &spherical.phi, &vHrp);
        }
        else
        {
            CartesianToSpherical(&spherical.rho, &spherical.theta, &spherical.phi, &m_opCurrent.vPosition);
        }

        fAtMaxDistance = (spherical.rho > m_opCurrent.flMaxDistance);
    }
    else
    {
        fAtMaxDistance = FALSE;
    }
        
    DPF_LEAVE(fAtMaxDistance);

    return fAtMaxDistance;
}


/***************************************************************************
 *
 *  CSw3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm identifier.
 *      DWORD [in]: frequency.
 *      BOOL [in]: TRUE to mute 3D at max distance.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::CSw3dObject"

CSw3dObject::CSw3dObject
(
    C3dListener *           pListener, 
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwUserFrequency
)
    : C3dObject(pListener, guid3dAlgorithm, fMuteAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSw3dObject);

    // Initialize defaults
    m_dwUserFrequency = dwUserFrequency;
    m_dwDopplerFrequency = dwUserFrequency;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CSw3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::~CSw3dObject"

CSw3dObject::~CSw3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CSw3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Recalc
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object 
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *      DWORD [in]: changed object settings.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::Recalc"

HRESULT 
CSw3dObject::Recalc
(
    DWORD                   dwListener, 
    DWORD                   dwObject
)
{
    BOOL                    fHrp                    = FALSE;
    BOOL                    fListenerOrientation    = FALSE;
    BOOL                    fDoppler                = FALSE;
    BOOL                    fPosition               = FALSE;
    BOOL                    fCone                   = FALSE;
    HRESULT                 hr                      = DS_OK;

    DPF_ENTER();

    // Determine which settings need to be recalculated
    if(dwListener & DS3DPARAM_LISTENER_DISTANCEFACTOR)
    {
        fHrp = fDoppler = TRUE;
    }
                                                           
    if(dwListener & DS3DPARAM_LISTENER_DOPPLERFACTOR)
    {
        fDoppler = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_ROLLOFFFACTOR)
    {
        fPosition = TRUE;
    }                              

    if(dwListener & DS3DPARAM_LISTENER_ORIENTATION)
    {
        fListenerOrientation = TRUE;
        fHrp = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_POSITION)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_VELOCITY)
    {
        fDoppler = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_SPEAKERCONFIG)
    {
        fHrp = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_CONEANGLES)
    {
        fCone = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_CONEORIENTATION)
    {
        fCone = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME)
    {
        fCone = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_MAXDISTANCE)
    {
        fPosition = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_MINDISTANCE)
    {
        fPosition = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_MODE)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_POSITION)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_VELOCITY)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_FREQUENCY)
    {
        fDoppler = TRUE;
    }

    // Recalculate
    if(fListenerOrientation)
    {
        UpdateListenerOrientation();
    }

    if(fHrp)
    {
        UpdateHrp();
    }

    if(fDoppler)
    {
        UpdateDoppler();
    }

    if(fPosition && !fHrp)
    {
        UpdatePositionAttenuation();
    }

    if(fCone && !fHrp)
    {
        UpdateConeAttenuation();
    }

    // Commit to the device
    if(fHrp || fDoppler || fPosition || fCone)
    {
        hr = Commit3dChanges();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateConeAttenuation
 *
 *  Description:
 *      Updates object attenuation based on cone properties.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateConeAttenuation"

void 
CSw3dObject::UpdateConeAttenuation
(
    void
)
{
    D3DVECTOR               vPos;
    D3DVECTOR               vHeadPos;
    FLOAT                   flSpreadi;
    FLOAT                   flCosSpreadi;
    FLOAT                   flSpreado;
    FLOAT                   flCosSpreado;
    FLOAT                   flCosTheta;
    DWORD                   dwMode;

    DPF_ENTER();

    //initialization
    SET_EMPTY_VECTOR(vPos);

    // Put the object at the origin - where are we now?

    // In Normal mode, we calculate it for real.  In HeadRelative mode, 
    // we assume the position given is already head relative.  In Disable 
    // mode, we assume the object is on top of the listener (no 3D).

    // If everywhere is inside the cone, don't waste time
    if(m_opCurrent.dwInsideConeAngle < 360)
    {
        dwMode = m_opCurrent.dwMode;

        if(!m_pListener && DS3DMODE_NORMAL == m_opCurrent.dwMode)
        {
            dwMode = DS3DMODE_HEADRELATIVE;
        }

        if(DS3DMODE_NORMAL == dwMode)
        {
            SubtractVector(&vPos, &m_pListener->m_lpCurrent.vPosition, &m_opCurrent.vPosition);
        }
        else if(DS3DMODE_HEADRELATIVE == dwMode)
        {
            SET_EMPTY_VECTOR(vHeadPos);
            SubtractVector(&vPos, &vHeadPos, &m_opCurrent.vPosition);
        }
    }

    // If we're at the same point as the object, we're in the cone
    // note that the angle is alwas <= 360, but we want to handle bad
    // values gracefully.
    if(m_opCurrent.dwInsideConeAngle >= 360 || IsEmptyVector(&vPos))
    {
        m_fInInnerCone = TRUE;
        m_fInOuterCone = TRUE;
    }
    else
    {
        // What is the angle between us and the cone vector?  Note
        // that the cone vector has maginitude 1 already.
        flCosTheta = DotProduct(&vPos, &m_opCurrent.vConeOrientation) 
                     / MagnitudeVector(&vPos);

        // From 0 to pi, cos(theta) > cos(phi) for theta < phi

        // Inner cone: how many radians out from the center of the cone
        // is one edge?
        flSpreadi = m_opCurrent.dwInsideConeAngle * PI_OVER_360;
        flCosSpreadi = (FLOAT)cos(flSpreadi);
        m_fInInnerCone = flCosTheta > flCosSpreadi;

        // Outer cone: how many radians out from the center of the cone
        // is one edge?
        flSpreado = m_opCurrent.dwOutsideConeAngle * PI_OVER_360;
        flCosSpreado = (FLOAT)cos(flSpreado);
        m_fInOuterCone = flCosTheta > flCosSpreado;
    }

    if(m_fInInnerCone)
    {
        // We're inside both cones.  Don't attenuate.
        m_flAttenuation = 1.0f;
        m_flHowFarOut = 1.0f;
    }
    else if(!m_fInOuterCone)
    {
        // We're outside both cones.  Fully attenuate by lConeOutsideVolume
        // 100ths of a dB.  Remember, 6dB down is half the amplitude.  Low
        // pass filter by SHADOW_CONE.
        m_flAttenuation = (FLOAT)pow2(m_opCurrent.lConeOutsideVolume 
                          * (1.0f / 600.0f));
        m_flHowFarOut = 1.0f;
    }
    else
    {
        // Where between the cones are we?  0 means on the inner edge, 1 means
        // on the outer edge.
        m_flHowFarOut = (flCosSpreadi - flCosTheta) 
                      / (flCosSpreadi - flCosSpreado);

        // Attenuate by as much as lConeOutsideVolume 100ths of a dB if we're
        // on the edge of the outer cone.  Basically, I've (dannymi) chosen to
        // do no change on the edge of the inner cone and the maximum change when
        // your on the edge of the outer cone and the above else does maximum
        // change whenever you're outside both.
        m_flAttenuation = (FLOAT)pow2(m_opCurrent.lConeOutsideVolume 
                          * m_flHowFarOut * (1.0f / 600.0f));

    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdatePositionAttenuation
 *
 *  Description:
 *      Updates object attenuation based on position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdatePositionAttenuation"

void 
CSw3dObject::UpdatePositionAttenuation
(
    void
)
{
    FLOAT                   flRolloffFactor;

    DPF_ENTER();

    // Now figure out the new volume attenuation due to the new distance.
    // Every doubling of the distance of the object from its min distance
    // halves the amplitude (6dB down) with 100% rolloff (1.0).
    // For rolloff factors other than 100% we scale it so it will rolloff
    // faster/slower than normal, using the only formula I could dream up
    // that made sense.
    if(m_spherical.rho >= m_opCurrent.flMaxDistance)
    {
        m_spherical.rho = m_opCurrent.flMaxDistance;
        m_fAtMaxDistance = TRUE;
    }
    else
    {
        m_fAtMaxDistance = FALSE;
    }

    if(m_pListener)
    {
         flRolloffFactor = m_pListener->m_lpCurrent.flRolloffFactor;
    }
    else
    {
        flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
    }

    if(m_spherical.rho > m_opCurrent.flMinDistance && flRolloffFactor > 0.0f)
    {
        m_flAttDistance = m_opCurrent.flMinDistance / 
           ((m_spherical.rho - m_opCurrent.flMinDistance) * flRolloffFactor 
            + m_opCurrent.flMinDistance);
    }
    else
    {
        m_flAttDistance = 1.0f;
    }


    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateListenerOrientation
 *
 *  Description:
 *      Updates the listener's orientation.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateListenerOrientation"

void 
CSw3dObject::UpdateListenerOrientation
(
    void
)
{
    DWORD                   dwMode;

    DPF_ENTER();

    // Figure out where this object is relative to the listener's head

    // In Normal mode, we update the orientation.  In HeadRelative mode, 
    // we assume the orientation is the default. 

    dwMode = m_opCurrent.dwMode;

    if(!m_pListener && DS3DMODE_NORMAL == dwMode)
    {
        dwMode = DS3DMODE_HEADRELATIVE;
    }

    if(DS3DMODE_NORMAL == dwMode)
    {
        GetRotations(&m_rotation.pitch, 
                     &m_rotation.yaw, 
                     &m_rotation.roll, 
                     &m_pListener->m_lpCurrent.vOrientFront, 
                     &m_pListener->m_lpCurrent.vOrientTop); 
    }
    else 
    {
        m_rotation.pitch = 0.0;
        m_rotation.yaw = 0.0; 
        m_rotation.roll = 0.0;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateDoppler
 *
 *  Description:
 *      Updates doppler shift.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateDoppler"

void 
CSw3dObject::UpdateDoppler
(
    void
)
{
    D3DVECTOR               vListenerVelocity;
    D3DVECTOR               vListenerPosition;
    FLOAT                   flRelVel;
    FLOAT                   flFreqDoppler;
    FLOAT                   flDopplerFactor;
    FLOAT                   flDistanceFactor;
    D3DVECTOR               vHeadPos;
    D3DVECTOR               vHeadVel;
    DWORD                   dwMode;
    double                  dTemp;

    DPF_ENTER();

    // Update the Doppler effect.  Don't bother if there's no current
    // effect and we know right away we won't want one.
    if(m_pListener)
    {
        flDopplerFactor = m_pListener->m_lpCurrent.flDopplerFactor;
        flDistanceFactor = m_pListener->m_lpCurrent.flDistanceFactor;
        vListenerVelocity = m_pListener->m_lpCurrent.vVelocity;
        vListenerPosition = m_pListener->m_lpCurrent.vPosition;
    }
    else
    {
        flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;
        flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
        SET_EMPTY_VECTOR(vListenerVelocity);
        SET_EMPTY_VECTOR(vListenerPosition);
    }
    
    if(flDopplerFactor > 0.0f && 
       (!IsEmptyVector(&vListenerVelocity) || !IsEmptyVector(&m_opCurrent.vVelocity)))
    {
        // In Normal mode, we calculate it for real.  In HeadRelative mode, 
        // we assume the position given is already head relative.  In Disable 
        // mode, we assume the object is on top of the listener (no 3D).
        dwMode = m_opCurrent.dwMode;

        if(!m_pListener && DS3DMODE_NORMAL == dwMode)
        {
            dwMode = DS3DMODE_HEADRELATIVE;
        }

        if(DS3DMODE_NORMAL == dwMode)
        {
            GetRelativeVelocity(&flRelVel, 
                                &m_opCurrent.vPosition, 
                                &m_opCurrent.vVelocity, 
                                &vListenerPosition, 
                                &vListenerVelocity);
        }
        else if(DS3DMODE_HEADRELATIVE == dwMode)
        {
            SET_EMPTY_VECTOR(vHeadPos);
            SET_EMPTY_VECTOR(vHeadVel);
            
            GetRelativeVelocity(&flRelVel, 
                                &m_opCurrent.vPosition, 
                                &m_opCurrent.vVelocity, 
                                &vHeadPos, &vHeadVel);
        }
        else
        {
            flRelVel = 0.0f;
        }

        // Make the units mm/s
        dTemp = flRelVel;
        dTemp *= flDistanceFactor;
        dTemp *= 1000;

        // They may want an exaggerated Doppler effect
        dTemp *= flDopplerFactor;

        // Clamp to the float type's valid range
        if (dTemp < -FLT_MAX)
            flRelVel = -FLT_MAX;
        else if (dTemp > FLT_MAX)
            flRelVel = FLT_MAX;
        else
            flRelVel = FLOAT(dTemp);

        GetDopplerShift(&flFreqDoppler, (FLOAT)m_dwUserFrequency, flRelVel);
        m_dwDopplerFrequency = (DWORD)flFreqDoppler;
    }
    else
    {
        m_dwDopplerFrequency = m_dwUserFrequency;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateHrp
 *
 *  Description:
 *      Updates object head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateHrp"

void 
CSw3dObject::UpdateHrp
(
    void
)
{
    BOOL                    fOk                 = TRUE;
    D3DVECTOR               vHrp;
    DWORD                   dwMode;

    DPF_ENTER();

    // Figure out where this object is relative to the listener's head

    // In Normal mode, we calculate it for real.  In HeadRelative mode, 
    // we assume the position given is already head relative.  In Disable 
    // mode, we assume the object is on top of the listener (no 3D).
    dwMode = m_opCurrent.dwMode;

    if(!m_pListener && DS3DMODE_NORMAL == dwMode)
    {
        dwMode = DS3DMODE_HEADRELATIVE;
    }

    if(DS3DMODE_NORMAL == dwMode)
    {
        fOk = GetHeadRelativeVector(&vHrp, 
                                    &m_opCurrent.vPosition, 
                                    &m_pListener->m_lpCurrent.vPosition, 
                                    m_rotation.pitch, 
                                    m_rotation.yaw, 
                                    m_rotation.roll);
    }
    else if(DS3DMODE_HEADRELATIVE == dwMode)
    {
        vHrp = m_opCurrent.vPosition;
    }
    else
    {
        SET_EMPTY_VECTOR(vHrp);
    }

    if(fOk)
    {
        UpdateAlgorithmHrp(&vHrp);

        // Update properties
        UpdateConeAttenuation();
        UpdatePositionAttenuation();
    }
    else
    {
        // We'll assume the head is at the origin looking forward and
        // rightside up
        CartesianToSpherical(&(m_spherical.rho), 
                             &(m_spherical.theta), 
                             &(m_spherical.phi), 
                             &m_opCurrent.vPosition);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  IsAtMaxDistance
 *
 *  Description:
 *      Determines if the object is muted based on distance.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the object is at its maxiumum distance.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::IsAtMaxDistance"

BOOL
CSw3dObject::IsAtMaxDistance
(
    void
)
{
    BOOL                    fAtMaxDistance;

    DPF_ENTER();

    if(DS3DMODE_DISABLE != m_opCurrent.dwMode && m_fMuteAtMaxDistance)
    {
        fAtMaxDistance = m_fAtMaxDistance;
    }
    else
    {
        fAtMaxDistance = FALSE;
    }
        
    DPF_LEAVE(fAtMaxDistance);

    return fAtMaxDistance;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::SetAttenuation"

HRESULT 
CSw3dObject::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    // We should never have allowed panning on 3D buffers, but the first release of DS3D
    // allowed it and we had to maintain it for app-compat.  In DirectSound 8.0 and later
    // this flag combination is disallowed, but this code must live on anyway.
    hr = C3dObject::SetAttenuation(pdsvp, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Gives the 3D object first notification of a frequency change
 *      to its owning buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::SetFrequency"

HRESULT 
CSw3dObject::SetFrequency
(
    DWORD                   dwFrequency,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    m_dwUserFrequency = dwFrequency;
    hr = Recalc(0, DS3DPARAM_OBJECT_FREQUENCY);

    if(SUCCEEDED(hr))
    {
        *pfContinue = FALSE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CHw3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHw3dObject::CHw3dObject"

CHw3dObject::CHw3dObject
(
    C3dListener *           pListener, 
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled
)
    : C3dObject(pListener, GUID_NULL, fMuteAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CHw3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CHw3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHw3dObject::~CHw3dObject"

CHw3dObject::~CHw3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CHw3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CItd3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::CItd3dObject"

CItd3dObject::CItd3dObject
(
    C3dListener *           pListener, 
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwUserFrequency
)
    : CSw3dObject(pListener, DS3DALG_ITD, fMuteAtMaxDistance, fDopplerEnabled, dwUserFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CItd3dObject);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CItd3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::~CItd3dObject"

CItd3dObject::~CItd3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CItd3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateConeAttenuation
 *
 *  Description:
 *      Updates object attenuation based on cone properties.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateConeAttenuation"

void 
CItd3dObject::UpdateConeAttenuation
(
    void
)
{
    FLOAT                   flShadow;

    DPF_ENTER();

    CSw3dObject::UpdateConeAttenuation();

    if(m_fInInnerCone)
    {
        // We're inside both cones.  Don't attenuate.
        flShadow = 1.0f;
    }
    else if(!m_fInOuterCone)
    {
        flShadow = SHADOW_CONE;
    }
    else
    {
        flShadow = 1.0f - (1.0f - SHADOW_CONE) * m_flHowFarOut;
    }

    // Update the FIR context
    m_ofcLeft.flConeAttenuation = m_ofcRight.flConeAttenuation = m_flAttenuation;
    m_ofcLeft.flConeShadow = m_ofcRight.flConeShadow = flShadow;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdatePositionAttenuation
 *
 *  Description:
 *      Updates object attenuation based on position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdatePositionAttenuation"

void 
CItd3dObject::UpdatePositionAttenuation
(
    void
)
{
    FLOAT                   flAtt3dLeft;
    FLOAT                   flAtt3dRight;
    FLOAT                   flAttShadowLeft;
    FLOAT                   flAttShadowRight;
    FLOAT                   flScale;

    DPF_ENTER();

    CSw3dObject::UpdatePositionAttenuation();

    // Now figure out the attenuations based on the position of the object
    // about your head.  We have constants defined for the attenuation and 
    // dry/wet mix you get when the object is exactly in front, rear, 
    // beside each ear, straight up, or straight down.  Interpolate in 
    // between these values to get the attenuation we will use.
    if(0.0f == m_spherical.rho)
    {
        // Sound is on top of you, well, not above I mean in the same spot, well,
        // you know what I mean
        flAtt3dLeft = flAtt3dRight = GAIN_IPSI;
        flAttShadowLeft = flAttShadowRight = SHADOW_IPSI;
    }
    else if(m_spherical.theta >= 0.0f && m_spherical.theta <= PI_OVER_TWO)
    {
        // Everything is in above you on your right
        flScale = m_spherical.theta * TWO_OVER_PI;
        flAtt3dLeft = GAIN_CONTRA + flScale * (GAIN_UP - GAIN_CONTRA);
        flAtt3dRight = GAIN_IPSI + flScale * (GAIN_UP - GAIN_IPSI);
        flAttShadowLeft = SHADOW_CONTRA + flScale * (SHADOW_UP - SHADOW_CONTRA);
        flAttShadowRight = SHADOW_IPSI + flScale * (SHADOW_UP - SHADOW_IPSI);
    }
    else if(m_spherical.theta > PI_OVER_TWO && m_spherical.theta <= PI)
    {
        // Sound is in above you on your left
        flScale = (m_spherical.theta - PI_OVER_TWO) * TWO_OVER_PI;
        flAtt3dLeft = GAIN_UP + flScale * (GAIN_IPSI - GAIN_UP);
        flAtt3dRight = GAIN_UP + flScale * (GAIN_CONTRA - GAIN_UP);
        flAttShadowLeft = SHADOW_UP + flScale * (SHADOW_IPSI - SHADOW_UP);
        flAttShadowRight = SHADOW_UP + flScale * (SHADOW_CONTRA - SHADOW_UP);
    }
    else if(m_spherical.theta > PI && m_spherical.theta <= THREE_PI_OVER_TWO)
    {
        // Sound is in below you on your left
        flScale = (m_spherical.theta - PI) * TWO_OVER_PI;
        flAtt3dLeft = GAIN_IPSI + flScale * (GAIN_DOWN - GAIN_IPSI);
        flAtt3dRight = GAIN_CONTRA + flScale * (GAIN_DOWN - GAIN_CONTRA);
        flAttShadowLeft = SHADOW_IPSI + flScale * (SHADOW_DOWN - SHADOW_IPSI);
        flAttShadowRight = SHADOW_CONTRA + flScale * (SHADOW_DOWN - SHADOW_CONTRA);
    }
    else
    {
        // Sound is in below you on your right
        flScale = (m_spherical.theta - THREE_PI_OVER_TWO) * TWO_OVER_PI;
        flAtt3dLeft = GAIN_DOWN + flScale * (GAIN_CONTRA - GAIN_DOWN);
        flAtt3dRight = GAIN_DOWN + flScale * (GAIN_IPSI - GAIN_DOWN);
        flAttShadowLeft = SHADOW_DOWN + flScale * (SHADOW_CONTRA - SHADOW_DOWN);
        flAttShadowRight = SHADOW_DOWN + flScale * (SHADOW_IPSI - SHADOW_DOWN);
    }

    if(m_spherical.phi < 0.0f)
    {
        // Sound is behind you
        flScale = m_spherical.phi * TWO_OVER_PI;
        flAtt3dLeft = flAtt3dLeft + flScale * (flAtt3dLeft - GAIN_REAR);
        flAtt3dRight = flAtt3dRight + flScale * (flAtt3dRight - GAIN_REAR);
        flAttShadowLeft = flAttShadowLeft + flScale * (flAttShadowLeft - SHADOW_REAR);
        flAttShadowRight = flAttShadowRight + flScale * (flAttShadowRight - SHADOW_REAR);
    }
    else if(m_spherical.phi > 0.0f)
    {
        // Sound is in front of you
        flScale = m_spherical.phi * TWO_OVER_PI;
        flAtt3dLeft = flAtt3dLeft - flScale * (flAtt3dLeft - GAIN_FRONT);
        flAtt3dRight = flAtt3dRight - flScale * (flAtt3dRight - GAIN_FRONT);
        flAttShadowLeft = flAttShadowLeft - flScale * (flAttShadowLeft - SHADOW_FRONT);
        flAttShadowRight = flAttShadowRight - flScale * (flAttShadowRight - SHADOW_FRONT);
    }

    // Update FIR context
    m_ofcLeft.flDistanceAttenuation = m_ofcRight.flDistanceAttenuation = m_flAttDistance;
    m_ofcLeft.flPositionAttenuation = m_flAttDistance * flAtt3dLeft;
    m_ofcRight.flPositionAttenuation = m_flAttDistance * flAtt3dRight;
    m_ofcLeft.flPositionShadow = flAttShadowLeft;
    m_ofcRight.flPositionShadow = flAttShadowRight;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates ITD algorithm specific head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateAlgorithmHrp"

void 
CItd3dObject::UpdateAlgorithmHrp
(
    D3DVECTOR *             pvHrp
)
{
    FLOAT                   flDelay;
    FLOAT                   flDistanceFactor;
    DWORD                   dwOutputSampleRate;

    DPF_ENTER();

    CartesianToSpherical(&(m_spherical.rho), 
                         &(m_spherical.theta), 
                         &(m_spherical.phi), 
                         pvHrp);

    // Now, figure out how much to phase shift to give 3D effect
    dwOutputSampleRate = Get3dOutputSampleRate();
    ASSERT(dwOutputSampleRate);

    if(m_pListener)
    {
        flDistanceFactor = m_pListener->m_lpCurrent.flDistanceFactor;
    }
    else
    {
        flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
    }
    
    GetTimeDelay(&flDelay, pvHrp, flDistanceFactor);

    if(flDelay > 0.0f)
    {
        m_ofcLeft.dwDelay = 0;
        m_ofcRight.dwDelay = (DWORD)(flDelay * dwOutputSampleRate);
    }
    else
    {
        m_ofcLeft.dwDelay = (DWORD)(-flDelay * dwOutputSampleRate);
        m_ofcRight.dwDelay = 0;
    }


    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateHrp
 *
 *  Description:
 *      Updates object head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateHrp"

void 
CItd3dObject::UpdateHrp
(
    void
)
{

    DPF_ENTER();

    // Reset the delays in case UpdateHrp cannot.
    m_ofcLeft.dwDelay = 0;
    m_ofcRight.dwDelay = 0;

    CSw3dObject::UpdateHrp();
}


/***************************************************************************
 *
 *  UpdateDoppler
 *
 *  Description:
 *      Updates doppler shift.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateDoppler"

void 
CItd3dObject::UpdateDoppler
(
    void
)
{

    DPF_ENTER();

    CSw3dObject::UpdateDoppler();

    // We will do volume changes smoothly at 6dB per 1/8 second
    m_ofcRight.dwSmoothFreq = m_dwDopplerFrequency;
    m_ofcLeft.dwSmoothFreq = m_ofcRight.dwSmoothFreq;

    m_ofcRight.flVolSmoothScale = (FLOAT)pow2(8.0f / m_dwDopplerFrequency);
    m_ofcLeft.flVolSmoothScale = m_ofcRight.flVolSmoothScale;

    m_ofcRight.flVolSmoothScaleRecip = 1.0f / m_ofcLeft.flVolSmoothScale;
    m_ofcLeft.flVolSmoothScaleRecip = m_ofcRight.flVolSmoothScaleRecip;

    DPF_LEAVE_VOID();
}

/***************************************************************************
 *    
 *  CIir3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::CIir3dObject"

CIir3dObject::CIir3dObject
(
    C3dListener *           pListener, 
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwUserFrequency
)
    : CSw3dObject(pListener, guid3dAlgorithm, fMuteAtMaxDistance, fDopplerEnabled, dwUserFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CIir3dObject);

    // Initialize defaults
    m_pLut = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CIir3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::~CIir3dObject"

CIir3dObject::~CIir3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CIir3dObject);

    // Free memory
    DELETE(m_pLut);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the 3D object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::Initialize"

HRESULT 
CIir3dObject::Initialize
(
    void
)
{
    HRESULT                     hr;
    KSDS3D_HRTF_COEFF_FORMAT    cfCoeffFormat;
    KSDS3D_HRTF_FILTER_QUALITY  FilterQuality;
    KSDS3D_HRTF_FILTER_METHOD   fmFilterMethod;
    ULONG                       ulMaxBiquads;
    ULONG                       ulFilterTransitionMuteLength;
    ULONG                       ulFilterOverlapBufferLength;
    ULONG                       ulOutputOverlapBufferLength;
    ESampleRate                 IirSampleRate;
    
    DPF_ENTER();

    if(m_pLut)
    {
        // Free memory
        DELETE(m_pLut);
    }

    m_fUpdatedCoeffs = FALSE;

    // Create the IIR filter look up table object
    m_pLut = NEW(CIirLut);
    hr = HRFROMP(m_pLut);

    // Determine which filter coefficient format
    // the hardware or kmixer wants and initialize
    // the LUT appropriately.
    if(SUCCEEDED(hr))
    {
        hr = GetFilterMethodAndCoeffFormat(&fmFilterMethod,&cfCoeffFormat);
    }

    if(SUCCEEDED(hr))
    {
        if(DS3DALG_HRTF_LIGHT == m_guid3dAlgorithm)
        {
            FilterQuality = LIGHT_FILTER;
        }
        else if(DS3DALG_HRTF_FULL == m_guid3dAlgorithm)
        {
            FilterQuality = FULL_FILTER;
        }
        else
        {
            ASSERT(0);
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = 
            m_pLut->Initialize
            (
                cfCoeffFormat, 
                FilterQuality,
                m_pListener->m_dwSpeakerConfig  // Could also include Sample rate here.
            );
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pLut->DsFrequencyToIirSampleRate(m_dwUserFrequency, &IirSampleRate);
    }

    // Initialize the maximum number of coefficients.
    if(SUCCEEDED(hr))
    {
        ulMaxBiquads = m_pLut->GetMaxBiquadCoeffs();
        ulFilterTransitionMuteLength = m_pLut->GetFilterTransitionMuteLength(FilterQuality, IirSampleRate);
        ulFilterOverlapBufferLength = m_pLut->GetFilterOverlapBufferLength(FilterQuality, IirSampleRate);
        ulOutputOverlapBufferLength = m_pLut->GetOutputOverlapBufferLength(IirSampleRate);

        hr = InitializeFilters
             (
                 FilterQuality, 
                 (FLOAT)m_dwUserFrequency,  
                 NumBiquadsToNumCanonicalCoeffs(ulMaxBiquads),
                 ulFilterTransitionMuteLength,
                 ulFilterOverlapBufferLength,
                 ulOutputOverlapBufferLength
             );
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = C3dObject::Initialize();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates IIR 3D algorithm specific head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::UpdateAlgorithmHrp"

void CIir3dObject::UpdateAlgorithmHrp
(
    D3DVECTOR *             pvHrp
)
{
    ESampleRate             eSampleRate;
    FLOAT                   flAzimuth;
    FLOAT                   flElevation;
    FLOAT                   flRho;
    BOOL                    fUpdatedSigmaCoeffs;
    BOOL                    fUpdatedDeltaCoeffs;

    DPF_ENTER();

    //Parameter validation
    if (pvHrp == NULL)
        return;
        
    // We need to recalculate m_spherical here.
    // This is a good candidate for optimization!

    CartesianToSpherical(&(m_spherical.rho), 
                         &(m_spherical.theta), 
                         &(m_spherical.phi), 
                         pvHrp);

    CartesianToAzimuthElevation(&flRho, 
                         &flAzimuth, 
                         &flElevation, 
                         pvHrp);

    flAzimuth = flAzimuth * 180.0f / PI;  // convert to degrees
    flElevation = flElevation * 180.0f / PI;

    if(flAzimuth > Cd3dvalMaxAzimuth)
    {
        flAzimuth = Cd3dvalMaxAzimuth; 
    }

    if(flAzimuth < Cd3dvalMinAzimuth) 
    {
        flAzimuth = Cd3dvalMinAzimuth; 
    }

    if(flElevation > Cd3dvalMaxElevationData)
    {
        flElevation = Cd3dvalMaxElevationData; 
    }

    if(flElevation < Cd3dvalMinElevationData)
    {
        flElevation = Cd3dvalMinElevationData; 
    }

    if(m_dwDopplerFrequency >= 46050)  // mean of 44.1 and 48 kHz
    {
        eSampleRate = tag48000Hz;
    }
    else if(46050>m_dwDopplerFrequency && m_dwDopplerFrequency >= 38050) // mean of 32.0 and 44.1 kHz
    {
        eSampleRate = tag44100Hz;
    }
    else if(38050>m_dwDopplerFrequency && m_dwDopplerFrequency >= 27025) // mean of 22.05 and 32.0 kHz
    {
        eSampleRate = tag32000Hz;
    }
    else if(27025>m_dwDopplerFrequency &&  m_dwDopplerFrequency > 19025)  // mean of 16.0 and 22.050 kHz
    {
        eSampleRate = tag22050Hz;
    }
    else if(19025>m_dwDopplerFrequency &&  m_dwDopplerFrequency > 13512.50)  // mean of 11.025 and 16.0 kHz
    {
        eSampleRate = tag16000Hz;
    }
    else if(13512.5>m_dwDopplerFrequency &&  m_dwDopplerFrequency > 9512.50)  // mean of 8.0 and 11.025 kHz
    {
        eSampleRate = tag11025Hz;
    }
    else
    {
        eSampleRate = tag8000Hz;
    }

    fUpdatedDeltaCoeffs = 
        m_pLut->HaveCoeffsChanged
        (
            flAzimuth,      
            flElevation,      
            eSampleRate,
            tagDelta
         );

    fUpdatedSigmaCoeffs = 
        m_pLut->HaveCoeffsChanged
        (
            flAzimuth,      
            flElevation,      
            eSampleRate,
            tagSigma
         );

    m_fUpdatedCoeffs = fUpdatedDeltaCoeffs 
                       | fUpdatedSigmaCoeffs;

    if(flAzimuth < 0.0f)
    {
        m_fSwapChannels = TRUE;
    }
    else
    {
        m_fSwapChannels = FALSE;
    }       

    if(fUpdatedDeltaCoeffs)
    {
        m_pDeltaCoeffs =
            m_pLut->GetCoeffs
            (
                flAzimuth, 
                flElevation,  
                eSampleRate, 
                tagDelta, 
                &m_ulNumDeltaCoeffs
            );
    }

    if(fUpdatedSigmaCoeffs)
    {
        m_pSigmaCoeffs =
            m_pLut->GetCoeffs
            (
                flAzimuth, 
                flElevation, 
                eSampleRate, 
                tagSigma, 
                &m_ulNumSigmaCoeffs
            );

    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *    
 *  CPan3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener* [in]: (passed on to our base constructor)
 *      BOOL [in]:         (passed on to our base constructor)
 *      DWORD [in]:        (passed on to our base constructor)
 *      CSecondaryRenderWaveBuffer* [in]: buffer we're associated to
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::CPan3dObject"

CPan3dObject::CPan3dObject
(
    C3dListener *                   pListener, 
    BOOL                            fMuteAtMaxDistance,
    BOOL                            fDopplerEnabled,
    DWORD                           dwFrequency,
    CSecondaryRenderWaveBuffer *    pBuffer
)
    : CSw3dObject(pListener, DS3DALG_NO_VIRTUALIZATION, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CPan3dObject);

    // Intialize defaults
    m_pBuffer = pBuffer;
    m_flPowerRight = 0.5f;
    m_lUserVolume = DSBVOLUME_MAX;
    m_fUserMute = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CPan3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::~CPan3dObject"

CPan3dObject::~CPan3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CPan3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::SetAttenuation"

HRESULT 
CPan3dObject::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    m_lUserVolume = pdsvp->lVolume;
    
    hr = Commit3dChanges();

    if(SUCCEEDED(hr))
    {
        *pfContinue = FALSE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Gives the 3D object first notification of a mute status change
 *      to its owning buffer.
 *
 *  Arguments:
 *      BOOL [in]: mute value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::SetMute"

HRESULT 
CPan3dObject::SetMute
(
    BOOL                    fMute,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    m_fUserMute = fMute;

    hr = Commit3dChanges();

    if(SUCCEEDED(hr))
    {
        *pfContinue = FALSE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates Pan algorithm specific head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::UpdateAlgorithmHrp"

void 
CPan3dObject::UpdateAlgorithmHrp
(    
    D3DVECTOR *             pvHrp
)
{
    DPF_ENTER();

    // m_spherical.theta and .phi are unused for Pan3D, so here we
    // just need to update m_spherical.rho (used by our base class).
    
    if (pvHrp->x == 0 && pvHrp->y == 0 && pvHrp->z == 0)
    {
        m_spherical.rho = 0.f;
        m_flPowerRight = 0.5f;
    }
    else
    {
        m_spherical.rho = MagnitudeVector(pvHrp);
        m_flPowerRight = pvHrp->x / (2.0f * m_spherical.rho) + 0.5f;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::Commit3dChanges"

HRESULT 
CPan3dObject::Commit3dChanges
(
    void
)
{
    HRESULT                 hr                      = DS_OK;
    DSVOLUMEPAN             dsvp;
    BOOL                    fMute;
    DWORD                   dwFrequency;

    DPF_ENTER();

    // Calculate values
    if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
    {
        dsvp.lVolume = m_lUserVolume;
        dsvp.lPan = DSBPAN_CENTER;
        fMute = m_fUserMute;
        dwFrequency = m_dwUserFrequency;
    }
    else
    {
        dsvp.lVolume = m_lUserVolume + CalculateVolume();
        dsvp.lPan = CalculatePan();
        fMute = (m_fUserMute || (DSBVOLUME_MIN == dsvp.lVolume));
        dwFrequency = m_dwDopplerFrequency;
    }
    
    // Apply values
    FillDsVolumePan(dsvp.lVolume, dsvp.lPan, &dsvp);
    
    hr = m_pBuffer->SetAttenuation(&dsvp);

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetMute(fMute);
    }

    if(SUCCEEDED(hr) && m_fDopplerEnabled)
    {
        hr = m_pBuffer->SetBufferFrequency(dwFrequency, TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CalculateVolume
 *
 *  Description:
 *      Calculates a volume value based on object position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LONG: Volume.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::CalculateVolume"

LONG
CPan3dObject::CalculateVolume
(
    void
)
{
    const double            dbLog10_2       = 0.30102999566398;  // log10(2.0)
    double                  dbAttenuation;
    LONG                    lVolume;
    
    DPF_ENTER();
    
    if(IsAtMaxDistance())
    {
        lVolume = DSBVOLUME_MIN;
    }
    else
    {
        dbAttenuation = m_flAttenuation * m_flAttDistance;
        
        if(0.0 < dbAttenuation)
        {
            lVolume = (LONG)(dbLog10_2 * fylog2x(2000.0, dbAttenuation));
            // Reduce the volume to roughly match the HRTF algorithm's level:
            lVolume -= PAN3D_HRTF_ADJUSTMENT;
        }
        else
        {
            lVolume = DSBVOLUME_MIN;
        }
    }

    DPF_LEAVE(lVolume);

    return lVolume;
}


/***************************************************************************
 *
 *  CalculatePan
 *
 *  Description:
 *      Calculates a pan value based on object position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LONG: Pan.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::CalculatePan"

LONG
CPan3dObject::CalculatePan
(
    void
)
{
    const double            dbLog10_2       = 0.30102999566398;  // log10(2.0)
    LONG                    lPan;
    
    DPF_ENTER();
    
    if(m_flPowerRight >= 0.5)
    {
        if(m_flPowerRight < 1.0)
        {
            // The magic number 3000 comes from
            // (K * 100 * 10)*log10(-2.0 * m_flPowerRight + 2.0)
            // where K = 3 was tweeked to give a nice transition 
            // ( not to sharp when crossing azimuth = 0) but not
            // creating a discontinuity on the extremes 
            // (azimuth ~= +/- 90 degrees).
            lPan = -(LONG)(dbLog10_2 * fylog2x(3000.0, -2.0 * m_flPowerRight + 2.0)); 
        }
        else
        {
            lPan = DSBPAN_RIGHT;
        }
    }
    else
    {
        if(m_flPowerRight > 0.0)
        {
            // The magic number 3000 comes from
            // (K * 100 * 10)*log10(2.0 * m_flPowerRight)
            // where K = 3 was tweeked to give a nice transition 
            // ( not to sharp when crossing azimuth = 0) but not
            // creating a discontinuity on the extremes 
            // (azimuth ~= +/- 90 degrees).
            lPan = (LONG)(dbLog10_2 * fylog2x(3000.0, 2.0 * m_flPowerRight));
        }
        else
        {
            lPan = DSBPAN_LEFT;
        }
    }

    DPF_LEAVE(lPan);

    return lPan;
}


/***************************************************************************
 *
 *  CWrapper3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm.
 *      DWORD [in]: buffer frequency.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::CWrapper3dObject"

CWrapper3dObject::CWrapper3dObject
(
    C3dListener *           pListener,
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMute3dAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwFrequency
)
    : C3dObject(pListener, guid3dAlgorithm, fMute3dAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CWrapper3dObject);

    // Initialize defaults
    m_p3dObject = NULL;
    m_dwUserFrequency = dwFrequency;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CWrapper3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::~CWrapper3dObject"

CWrapper3dObject::~CWrapper3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CWrapper3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetObjectPointer
 *
 *  Description:
 *      Sets the real 3D object pointer.
 *
 *  Arguments:
 *      C3dObject * [in]: 3D object pointer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetObjectPointer"

HRESULT 
CWrapper3dObject::SetObjectPointer
(
    C3dObject               *p3dObject
)
{
    HRESULT                 hr  = DS_OK;
    BOOL                    f;
    
    DPF_ENTER();

    // Update the listener's world
    if(p3dObject)
    {
        m_pListener->RemoveObjectFromList(p3dObject);
    }

    // Commit all settings to the new object
    if(p3dObject)
    {
        p3dObject->m_dwDeferred = m_dwDeferred;

        CopyMemory(&p3dObject->m_opDeferred, &m_opDeferred, sizeof(m_opDeferred));
    }

    if(p3dObject)
    {
        hr = p3dObject->SetAllParameters(&m_opCurrent, TRUE);
    }

    if(SUCCEEDED(hr) && p3dObject)
    {
        hr = p3dObject->SetAttenuation(&m_dsvpUserAttenuation, &f);
    }

    if(SUCCEEDED(hr) && p3dObject)
    {
        hr = p3dObject->SetFrequency(m_dwUserFrequency, &f);
    }

    if(SUCCEEDED(hr) && p3dObject)
    {
        hr = p3dObject->SetMute(m_fUserMute, &f);
    }

    // Save a pointer to the object
    if(SUCCEEDED(hr))
    {
        m_p3dObject = p3dObject;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferred
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::CommitDeferred"

HRESULT 
CWrapper3dObject::CommitDeferred
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    hr = C3dObject::CommitDeferred();

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->CommitDeferred();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets sound cone angles.
 *
 *  Arguments:
 *      DWORD [in]: inside cone angle.
 *      DWORD [in]: outside cone angle.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetConeAngles"

HRESULT 
CWrapper3dObject::SetConeAngles
(
    DWORD                   dwInsideConeAngle, 
    DWORD                   dwOutsideConeAngle, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets sound cone orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetConeOrientation"

HRESULT 
CWrapper3dObject::SetConeOrientation
(
    REFD3DVECTOR            vConeOrientation, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetConeOrientation(vConeOrientation, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetConeOrientation(vConeOrientation, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets volume outside the sound cone.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetConeOutsideVolume"

HRESULT 
CWrapper3dObject::SetConeOutsideVolume
(
    LONG                    lConeOutsideVolume, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetConeOutsideVolume(lConeOutsideVolume, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetConeOutsideVolume(lConeOutsideVolume, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the maximum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: max distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMaxDistance"

HRESULT 
CWrapper3dObject::SetMaxDistance
(
    FLOAT                   flMaxDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetMaxDistance(flMaxDistance, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetMaxDistance(flMaxDistance, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the minimum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: min distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMinDistance"

HRESULT 
CWrapper3dObject::SetMinDistance
(
    FLOAT                   flMinDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetMinDistance(flMinDistance, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetMinDistance(flMinDistance, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the object mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMode"

HRESULT 
CWrapper3dObject::SetMode
(
    DWORD                   dwMode, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetMode(dwMode, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetMode(dwMode, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the object position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetPosition"

HRESULT 
CWrapper3dObject::SetPosition
(
    REFD3DVECTOR            vPosition, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetPosition(vPosition, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetPosition(vPosition, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the object velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR[in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetVelocity"

HRESULT 
CWrapper3dObject::SetVelocity
(
    REFD3DVECTOR            vVelocity, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetVelocity(vVelocity, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetVelocity(vVelocity, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object parameters.
 *
 *  Arguments:
 *      LPCDS3DBUFFER [in]: object parameters.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetAllParameters"

HRESULT 
CWrapper3dObject::SetAllParameters
(
    LPCDS3DBUFFER           pParams, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetAllParameters(pParams, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetAllParameters(pParams, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetAttenuation"

HRESULT 
CWrapper3dObject::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(m_p3dObject)
    {
        hr = m_p3dObject->SetAttenuation(pdsvp, pfContinue);
    }
    else
    {
        CopyMemory(&m_dsvpUserAttenuation, pdsvp, sizeof(*pdsvp));
        hr = C3dObject::SetAttenuation(pdsvp, pfContinue);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Gives the 3D object first notification of a frequency change
 *      to its owning buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetFrequency"

HRESULT 
CWrapper3dObject::SetFrequency
(
    DWORD                   dwFrequency,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_p3dObject)
    {
        hr = m_p3dObject->SetFrequency(dwFrequency, pfContinue);
    }
    else
    {
        m_dwUserFrequency = dwFrequency;
        hr = C3dObject::SetFrequency(dwFrequency, pfContinue);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Gives the 3D object first notification of a mute status change
 *      to its owning buffer.
 *
 *  Arguments:
 *      BOOL [in]: mute value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMute"

HRESULT 
CWrapper3dObject::SetMute
(
    BOOL                    fMute,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_p3dObject)
    {
        hr = m_p3dObject->SetMute(fMute, pfContinue);
    }
    else
    {
        m_fUserMute = fMute;
        hr = C3dObject::SetMute(fMute, pfContinue);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetObjectLocation
 *
 *  Description:
 *      Gets the object's location (i.e. software/hardware).
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: DSBCAPS_LOC* flags representing the object's processing
 *             location.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::GetObjectLocation"

DWORD 
CWrapper3dObject::GetObjectLocation(void)
{
    DWORD                   dwLocation;
    
    DPF_ENTER();

    if(m_p3dObject)
    {
        dwLocation = m_p3dObject->GetObjectLocation();
    }
    else
    {
        dwLocation = DSBCAPS_LOCSOFTWARE;
    }

    DPF_LEAVE(dwLocation);

    return dwLocation;
}


/***************************************************************************
 *
 *  Recalc
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object 
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *      DWORD [in]: changed object settings.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::Recalc"

HRESULT 
CWrapper3dObject::Recalc
(
   DWORD                    dwListener, 
   DWORD                    dwObject
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // We only want to recalc listener settings from here.  All other calls
    // to Recalc come from within C3dObject methods.
    if(m_p3dObject && dwListener)
    {
        hr = m_p3dObject->Recalc(dwListener, 0);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsaphack.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:      dsaphack.c
 *  Content:   DirectSound "app-hack" extension.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/16/98    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

typedef struct tagAPPHACKENTRY
{
    LPCTSTR             pszName;
    DWORD               cbData;
} APPHACKENTRY, *LPAPPHACKENTRY;

typedef struct tagAPPHACKTABLE
{
    LPAPPHACKENTRY      aEntries;
    ULONG               cEntries;
} APPHACKTABLE, *LPAPPHACKTABLE;

#define BEGIN_DECLARE_APPHACK_ENTRIES(name) \
            APPHACKENTRY name[] = {

#define DECLARE_APPHACK_ENTRY(name, type) \
                { TEXT(#name), sizeof(type) },

#define END_DECLARE_APPHACK_ENTRIES() \
            };

#define BEGIN_DECLARE_APPHACK_TABLE(name) \
            APPHACKTABLE name = 

#define DECLARE_APPHACK_TABLE(entries) \
                { entries, NUMELMS(entries) }

#define END_DECLARE_APPHACK_TABLE() \
            ;

BEGIN_DECLARE_APPHACK_ENTRIES(g_aheAppHackEntries)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_DEVACCEL, DSAPPHACK_DEVACCEL)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_DISABLEDEVICE, VADDEVICETYPE)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_PADCURSORS, LONG)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_MODIFYCSBFAILURE, HRESULT)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_RETURNWRITEPOS, VADDEVICETYPE)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_SMOOTHWRITEPOS, DSAPPHACK_SMOOTHWRITEPOS)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_CACHEPOSITIONS, VADDEVICETYPE)
END_DECLARE_APPHACK_ENTRIES()

BEGIN_DECLARE_APPHACK_TABLE(g_ahtAppHackTable)
    DECLARE_APPHACK_TABLE(g_aheAppHackEntries)
END_DECLARE_APPHACK_TABLE()


/***************************************************************************
 *
 *  AhGetCurrentApplicationPath
 *
 *  Description:
 *      Gets the full path to the current application's executable.
 *
 *  Arguments:
 *      LPTSTR [out]: receives application id.  This buffer is assumed to be 
 *                   at least MAX_PATH characters in size.
 *      LPTSTR * [out]: receives pointer to executable part of the path.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetCurrentApplicationPath"

BOOL
AhGetCurrentApplicationPath
(
    LPTSTR                  pszPath,
    LPTSTR *                ppszModule
)
{
    BOOL                    fSuccess                = TRUE;
    TCHAR                   szOriginal[MAX_PATH];
#ifdef SHARED
    BOOL                    fQuote                  = FALSE;
    LPTSTR                  pszOriginal;
    LPTSTR                  pszCommandLine;
    LPTSTR                  psz[2];
#endif // SHARED

    DPF_ENTER();
    
#ifdef SHARED

    // Get the application's command line
    pszOriginal = GetCommandLine();

    // Allocate a buffer to serve as a copy
    pszCommandLine = MEMALLOC_A(TCHAR, lstrlen(pszOriginal) + 2);

    if(!pszCommandLine)
    {
        DPF(DPFLVL_ERROR, "Out of memory allocating command-line");
        fSuccess = FALSE;
    }

    // Reformat the command-line so that NULLs divide the arguments
    // instead of quotes and spaces.
    if(fSuccess)
    {
        psz[0] = pszOriginal;
        psz[1] = pszCommandLine;

        while(*psz[0])
        {
            switch(*psz[0])
            {
                case '"':
                    fQuote = !fQuote;
                    break;

                case ' ':
                    *psz[1]++ = fQuote ? ' ' : 0;
                    break;

                default:
                    *psz[1]++ = *psz[0];
                    break;
            }

            psz[0]++;
        }
    }

    // Push the command line pointer ahead of any whitespace
    if(fSuccess)
    {
        psz[0] = pszCommandLine;

        while(' ' == *psz[0])
        {
            psz[0]++;
        }
    }
    
    // Get the module's executable name
    if(fSuccess)
    {
        fSuccess = MAKEBOOL(GetFullPathName(psz[0], MAX_PATH, pszPath, ppszModule));
    }

    // Trim any whitespace from the end of the executable path
    if(fSuccess)
    {
        psz[1] = pszPath + lstrlen(pszPath) - 1;
        
        while(psz[1] > pszPath && ' ' == *psz[1])
        {
            *psz[1]-- = 0;
        }
    }

    // Clean up
    MEMFREE(pszCommandLine);

    // A hack to fix OSR 133656.  The right way to do would be to combine this
    // function with AhGetApplicationId(), so we don't call CreateFile twice.
    if (fSuccess)
    {
        HANDLE hFile = CreateFile(pszPath, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            fSuccess = FALSE;
        else
            CloseHandle(hFile);
    }

    // If this fails (e.g. because someone called CreateProcess without
    // putting the program name in the command line argument) we try the
    // NT solution. It seems to work as well as the above, even on Win9X.
    if (!fSuccess)

#endif // SHARED

    {
        fSuccess = GetModuleFileName(GetModuleHandle(NULL), szOriginal, MAX_PATH);
        if(fSuccess)
        {
            fSuccess = MAKEBOOL(GetFullPathName(szOriginal, MAX_PATH, pszPath, ppszModule));
        }
    }

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  AhGetApplicationId
 *
 *  Description:
 *      Gets the id used to identify the current application.
 *
 *  Arguments:
 *      LPTSTR [out]: receives application id.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetApplicationId"

BOOL
AhGetApplicationId
(
    LPTSTR                  pszAppId
)
{
    HANDLE                  hFile                   = NULL;
    TCHAR                   szExecutable[MAX_PATH];
    LPTSTR                  pszModule;
    IMAGE_NT_HEADERS        nth;
    IMAGE_DOS_HEADER        dh;
    DWORD                   cbRead;
    DWORD                   dwFileSize;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    // Get the application path
    fSuccess = AhGetCurrentApplicationPath(szExecutable, &pszModule);

    if(fSuccess)
    {
        DPF(DPFLVL_MOREINFO, "Application executable path: %s", szExecutable);
        DPF(DPFLVL_MOREINFO, "Application module: %s", pszModule);
    }
                    
    // Open the executable
    if(fSuccess)
    {
        hFile = CreateFile(szExecutable, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

        if(!IsValidHandleValue(hFile))
        {
            DPF(DPFLVL_ERROR, "CreateFile failed to open %s with error %lu", szExecutable, GetLastError());
            fSuccess = FALSE;
        }
    }

    // Read the executable's DOS header
    if(fSuccess)
    {
        fSuccess = ReadFile(hFile, &dh, sizeof(dh), &cbRead, NULL);

        if(!fSuccess || sizeof(dh) != cbRead)
        {
            DPF(DPFLVL_ERROR, "Unable to read DOS header");
            fSuccess = FALSE;
        }
    }

    if(fSuccess && IMAGE_DOS_SIGNATURE != dh.e_magic)
    {
        DPF(DPFLVL_ERROR, "Invalid DOS signature");
        fSuccess = FALSE;
    }

    // Read the executable's PE header
    if(fSuccess)
    {
        cbRead = SetFilePointer(hFile, dh.e_lfanew, NULL, FILE_BEGIN);

        if((LONG)cbRead != dh.e_lfanew)
        {
            DPF(DPFLVL_ERROR, "Unable to seek to PE header");
            fSuccess = FALSE;
        }
    }

    if(fSuccess)
    {
        fSuccess = ReadFile(hFile, &nth, sizeof(nth), &cbRead, NULL);

        if(!fSuccess || sizeof(nth) != cbRead)
        {
            DPF(DPFLVL_ERROR, "Unable to read PE header");
            fSuccess = FALSE;
        }
    }

    if(fSuccess && IMAGE_NT_SIGNATURE != nth.Signature)
    {
        DPF(DPFLVL_ERROR, "Invalid PE signature");
        fSuccess = FALSE;
    }

    // Get the executable's size
    if(fSuccess)
    {
        // Assuming < 4 GB
        dwFileSize = GetFileSize(hFile, NULL);

        if(MAX_DWORD == dwFileSize)
        {
            DPF(DPFLVL_ERROR, "Unable to get file size");
            fSuccess = FALSE;
        }
    }

    // Create the application id
    if(fSuccess)
    {
        // Check for the QuickTime special case
        if (!lstrcmpi(pszModule, TEXT("QuickTimePlayer.exe")) && nth.FileHeader.TimeDateStamp < 0x38E50000) // Circa 3/31/2000
        {
            wsprintf(pszAppId, TEXT("Pre-May 2000 QuickTime"));
        }
        else
        {
            wsprintf(pszAppId, TEXT("%s%8.8lX%8.8lX"), pszModule, nth.FileHeader.TimeDateStamp, dwFileSize);
            CharUpper(pszAppId);
        }
        DPF(DPFLVL_INFO, "Application id: %s", pszAppId);
    }

    // Clean up
    CLOSE_HANDLE(hFile);

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  AhOpenApplicationKey
 *
 *  Description:
 *      Opens or creates the application's root key.
 *
 *  Arguments:
 *      LPCTSTR [in]: application id.
 *      BOOL [in]: TRUE to allow for creation of a new key.
 *
 *  Returns: 
 *      HKEY: registry key handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhOpenApplicationKey"

HKEY
AhOpenApplicationKey
(
    LPCTSTR                 pszAppId
)
{

#ifdef DEBUG

    TCHAR                   szName[0x100]   = { 0 };
    LONG                    cbName          = sizeof(szName);

#endif // DEBUG

    HKEY                    hkey            = NULL;
    HRESULT                 hr;

    DPF_ENTER();
    
    // Open the parent key
    hr = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 2, REGSTR_APPHACK, pszAppId);

#ifdef DEBUG

    // Query for the application description
    if(SUCCEEDED(hr))
    {
        RhRegGetStringValue(hkey, NULL, szName, cbName);
        DPF(DPFLVL_INFO, "Application description: %s", szName);
    }

#endif // DEBUG                

    DPF_LEAVE(hkey);

    return hkey;
}


/***************************************************************************
 *
 *  AhGetHackValue
 *
 *  Description:
 *      Queries an apphack value.
 *
 *  Arguments:
 *      HKEY [in]: application registry key.
 *      DSAPPHACKID [in]: apphack id.
 *      LPVOID [out]: receives apphack data.
 *      DWORD [in]: size of above data buffer.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetHackValue"

BOOL
AhGetHackValue
(
    HKEY                    hkey,
    DSAPPHACKID             ahid,
    LPVOID                  pvData,
    DWORD                   cbData
)
{
    HRESULT                 hr;
    
    ASSERT(ahid < (DSAPPHACKID)g_ahtAppHackTable.cEntries);
    ASSERT(cbData == g_ahtAppHackTable.aEntries[ahid].cbData);

    DPF_ENTER();
    
    hr = RhRegGetBinaryValue(hkey, g_ahtAppHackTable.aEntries[ahid].pszName, pvData, cbData);

    DPF_LEAVE(DS_OK == hr);

    return DS_OK == hr;
}


/***************************************************************************
 *
 *  AhGetAppHacks
 *
 *  Description:
 *      Gets all app-hacks for the current application.
 *
 *  Arguments:
 *      LPDSAPPHACKS [out]: receives app-hack data.
 *
 *  Returns: 
 *      BOOL: TRUE if any apphacks exist for the current application.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetAppHacks"

BOOL
AhGetAppHacks
(
    LPDSAPPHACKS            pahAppHacks
)
{
    static const DSAPPHACKS ahDefaults                  = {{DIRECTSOUNDMIXER_ACCELERATIONF_FULL, 0}, 0, 0, DS_OK, FALSE, {FALSE, 0}};
    TCHAR                   szAppId[DSAPPHACK_MAXNAME]  = {0};
    HKEY                    hkey                        = NULL;
    BOOL                    fSuccess;
    
    DPF_ENTER();
    
    // Assume defaults
    CopyMemory(pahAppHacks, &ahDefaults, sizeof(ahDefaults));
    
    // Get the application id
    fSuccess = AhGetApplicationId(szAppId);

    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "Finding apphacks for %s...", szAppId);
    }

    // Open the application key
    if(fSuccess)
    {
        hkey = AhOpenApplicationKey(szAppId);
        fSuccess = MAKEBOOL(hkey);
    }

    // Query all apphack values
    if(fSuccess)
    {
        AhGetHackValue(hkey, DSAPPHACKID_DEVACCEL, &pahAppHacks->daDevAccel, sizeof(pahAppHacks->daDevAccel));
        AhGetHackValue(hkey, DSAPPHACKID_DISABLEDEVICE, &pahAppHacks->vdtDisabledDevices, sizeof(pahAppHacks->vdtDisabledDevices));
        AhGetHackValue(hkey, DSAPPHACKID_PADCURSORS, &pahAppHacks->lCursorPad, sizeof(pahAppHacks->lCursorPad));
        AhGetHackValue(hkey, DSAPPHACKID_MODIFYCSBFAILURE, &pahAppHacks->hrModifyCsbFailure, sizeof(pahAppHacks->hrModifyCsbFailure));
        AhGetHackValue(hkey, DSAPPHACKID_RETURNWRITEPOS, &pahAppHacks->vdtReturnWritePos, sizeof(pahAppHacks->vdtReturnWritePos));
        AhGetHackValue(hkey, DSAPPHACKID_SMOOTHWRITEPOS, &pahAppHacks->swpSmoothWritePos, sizeof(pahAppHacks->swpSmoothWritePos));
        AhGetHackValue(hkey, DSAPPHACKID_CACHEPOSITIONS, &pahAppHacks->vdtCachePositions, sizeof(pahAppHacks->vdtCachePositions));
    }

    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "dwAcceleration:               0x%lX (applied to device type 0x%lX)", pahAppHacks->daDevAccel.dwAcceleration, pahAppHacks->daDevAccel.vdtDevicesAffected);
        DPF(DPFLVL_INFO, "vdtDisabledDevices:           0x%lX", pahAppHacks->vdtDisabledDevices);
        DPF(DPFLVL_INFO, "lCursorPad:                   %ld", pahAppHacks->lCursorPad);
        DPF(DPFLVL_INFO, "hrModifyCsbFailure:           %s", HRESULTtoSTRING(pahAppHacks->hrModifyCsbFailure));
        DPF(DPFLVL_INFO, "vdtReturnWritePos:            %lu", pahAppHacks->vdtReturnWritePos);
        DPF(DPFLVL_INFO, "swpSmoothWritePos.fEnable:    %lu", pahAppHacks->swpSmoothWritePos.fEnable);
        DPF(DPFLVL_INFO, "swpSmoothWritePos.lCursorPad: %lu", pahAppHacks->swpSmoothWritePos.lCursorPad);
        DPF(DPFLVL_INFO, "vdtCachePositions:            %lu", pahAppHacks->vdtCachePositions);
    }
    else
    {
        DPF(DPFLVL_INFO, "No apphacks exist");
    }

    // Clean up
    RhRegCloseKey(&hkey);

    DPF_LEAVE(fSuccess);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsaphack.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsaphack.h
 *  Content:    DirectSound "app-hack" extension.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/16/98    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSAPHACK_H__
#define __DSAPHACK_H__

#define DSAPPHACK_MAXNAME   (MAX_PATH + 16 + 16)

typedef enum
{
    DSAPPHACKID_DEVACCEL,           // Turn off certain acceleration flags on per-device basis
    DSAPPHACKID_DISABLEDEVICE,      // Turn off certain devices (force them into emulation)
    DSAPPHACKID_PADCURSORS,         // Pad the play and write cursors
    DSAPPHACKID_MODIFYCSBFAILURE,   // Change all CreateSoundBuffer failure codes to this
    DSAPPHACKID_RETURNWRITEPOS,     // Return write position as play position
    DSAPPHACKID_SMOOTHWRITEPOS,     // Return write position as play position + a constant
    DSAPPHACKID_CACHEPOSITIONS      // Cache device positions for apps which poll too often
} DSAPPHACKID, *LPDSAPPHACKID;

typedef struct tagDSAPPHACK_DEVACCEL
{
    DWORD           dwAcceleration;
    VADDEVICETYPE   vdtDevicesAffected;
} DSAPPHACK_DEVACCEL, *LPDSAPPHACK_DEVACCEL;

typedef struct tagDSAPPHACK_SMOOTHWRITEPOS
{
    BOOL            fEnable;
    LONG            lCursorPad;
} DSAPPHACK_SMOOTHWRITEPOS, *LPDSAPPHACK_SMOOTHWRITEPOS;

typedef struct tagDSAPPHACKS
{
    DSAPPHACK_DEVACCEL          daDevAccel;
    VADDEVICETYPE               vdtDisabledDevices;
    LONG                        lCursorPad;
    HRESULT                     hrModifyCsbFailure;
    VADDEVICETYPE               vdtReturnWritePos;
    DSAPPHACK_SMOOTHWRITEPOS    swpSmoothWritePos;
    VADDEVICETYPE               vdtCachePositions;
} DSAPPHACKS, *LPDSAPPHACKS;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern BOOL AhGetApplicationId(LPTSTR);
extern HKEY AhOpenApplicationKey(LPCTSTR);
extern BOOL AhGetHackValue(HKEY, DSAPPHACKID, LPVOID, DWORD);
extern BOOL AhGetAppHacks(LPDSAPPHACKS);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSAPHACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbasic.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbasic.cpp
 *  Content:    Basic class that all DirectSound objects are derived from.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  9/4/98      dereks  Created.
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  CRefCount
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      ULONG [in]: initial reference count.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::CRefCount"

inline CRefCount::CRefCount(ULONG ulRefCount)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CRefCount);

    m_ulRefCount = ulRefCount;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CRefCount
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::~CRefCount"

inline CRefCount::~CRefCount(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CRefCount);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetRefCount
 *
 *  Description:
 *      Gets the object's reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::GetRefCount"

inline ULONG CRefCount::GetRefCount(void)
{
    return m_ulRefCount;
}


/***************************************************************************
 *
 *  SetRefCount
 *
 *  Description:
 *      Sets the object's reference count.
 *
 *  Arguments:
 *      ULONG [in]: object reference count.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::SetRefCount"

inline void CRefCount::SetRefCount(ULONG ulRefCount)
{
    m_ulRefCount = ulRefCount;
}


/***************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::AddRef"

inline ULONG CRefCount::AddRef(void)
{
    return ::AddRef(&m_ulRefCount);
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::Release"

inline ULONG CRefCount::Release(void)
{
    return ::Release(&m_ulRefCount);
}


/***************************************************************************
 *
 *  CDsBasicRuntime
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to delete the object on release.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::CDsBasicRuntime"

inline CDsBasicRuntime::CDsBasicRuntime(BOOL fAbsoluteRelease)
    : CRefCount(1), m_dwOwnerPid(GetCurrentProcessId()), m_dwOwnerTid(GetCurrentThreadId())
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDsBasicRuntime);

    ASSERT(IN_SHARED_MEMORY(this));

    m_fAbsoluteRelease = fAbsoluteRelease;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDsBasicRuntime
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::~CDsBasicRuntime"

inline CDsBasicRuntime::~CDsBasicRuntime(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDsBasicRuntime);

    ASSERT(!GetRefCount());

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetOwnerProcessId
 *
 *  Description:
 *      Gets the object's owning process id.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: process id.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::GetOwnerProcessId"

inline DWORD CDsBasicRuntime::GetOwnerProcessId(void) const
{
    return m_dwOwnerPid;
}


/***************************************************************************
 *
 *  GetOwnerThreadId
 *
 *  Description:
 *      Gets the object's owning thread id.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: thread id.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::GetOwnerThreadId"

inline DWORD CDsBasicRuntime::GetOwnerThreadId(void) const
{
    return m_dwOwnerTid;
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::Release"

inline ULONG CDsBasicRuntime::Release(void)
{
    ULONG                   ulRefCount;

    ulRefCount = CRefCount::Release();

    if(!ulRefCount)
    {
        AbsoluteRelease();
    }

    return ulRefCount;
}


/***************************************************************************
 *
 *  AbsoluteRelease
 *
 *  Description:
 *      Frees the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::AbsoluteRelease"

inline void CDsBasicRuntime::AbsoluteRelease(void)
{
    CDsBasicRuntime *       pThis   = this;

    SetRefCount(0);
    
    if(m_fAbsoluteRelease)
    {
        DELETE(pThis);
    }
}


/***************************************************************************
 *
 *  __AddRef
 *
 *  Description:
 *      Increments the reference count on an object.
 *
 *  Arguments:
 *      type * [in]: object pointer.
 *
 *  Returns:  
 *      type *: object pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__AddRef"

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}


/***************************************************************************
 *
 *  __Release
 *
 *  Description:
 *      Releases an object.
 *
 *  Arguments:
 *      type * [in]: object pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__Release"

template <class type> void __Release(type *p)
{
    if(p)
    {
        p->Release();
    }
}


/***************************************************************************
 *
 *  __AbsoluteRelease
 *
 *  Description:
 *      Releases an object.
 *
 *  Arguments:
 *      type * [in]: object pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__AbsoluteRelease"

template <class type> void __AbsoluteRelease(type *p)
{
    if(p)
    {
        p->AbsoluteRelease();
    }
}


/***************************************************************************
 *
 *  CObjectList
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::CObjectList"

template <class type> CObjectList<type>::CObjectList(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CObjectList);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CObjectList
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::~CObjectList"

template <class type> CObjectList<type>::~CObjectList(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CObjectList);
    
    RemoveAllNodesFromList();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AddNodeToList
 *
 *  Description:
 *      Adds a node to the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::AddNodeToList"

template <class type> CNode<type *> *CObjectList<type>::AddNodeToList(type *pData)
{
    return InsertNodeIntoList(m_lst.GetListTail(), pData);
}


/***************************************************************************
 *
 *  InsertNodeIntoList
 *
 *  Description:
 *      Inserts a new node into a specific point in the list.
 *
 *  Arguments:
 *      CNode * [in]: node to insert the new one after.
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::InsertNodeIntoList"

template <class type> CNode<type *> *CObjectList<type>::InsertNodeIntoList(CNode<type *> *pPrev, type *pData)
{
    CNode<type *> *         pNode;

    pNode = m_lst.InsertNodeIntoList(pPrev, pData);

    if(pNode && pNode->m_data)
    {
        pNode->m_data->AddRef();
    }

    return pNode;
}


/***************************************************************************
 *
 *  RemoveNodeFromList
 *
 *  Description:
 *      Removes a node from the list.
 *
 *  Arguments:
 *      CNode * [in]: node pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::RemoveNodeFromList"

template <class type> void CObjectList<type>::RemoveNodeFromList(CNode<type *> *pNode)
{
    RELEASE(pNode->m_data);
    m_lst.RemoveNodeFromList(pNode);
}


/***************************************************************************
 *
 *  RemoveAllNodesFromList
 *
 *  Description:
 *      Removes all nodes from the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::RemoveAllNodesFromList"

template <class type> void CObjectList<type>::RemoveAllNodesFromList(void)
{
    while(m_lst.GetListHead())
    {
        RemoveNodeFromList(m_lst.GetListHead());
    }
}


/***************************************************************************
 *
 *  RemoveDataFromList
 *
 *  Description:
 *      Removes a node from the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::RemoveDataFromList"

template <class type> BOOL CObjectList<type>::RemoveDataFromList(type *pData)
{
    CNode<type *> *         pNode;

    pNode = IsDataInList(pData);

    if(pNode)
    {
        RemoveNodeFromList(pNode);
    }

    return MAKEBOOL(pNode);
}


/***************************************************************************
 *
 *  IsDataInList
 *
 *  Description:
 *      Determines if a piece of data appears in the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::IsDataInList"

template <class type> CNode<type *> *CObjectList<type>::IsDataInList(type *pData)
{
    return m_lst.IsDataInList(pData);
}


/***************************************************************************
 *
 *  GetListHead
 *
 *  Description:
 *      Gets the first node in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CNode *: list head pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetListHead"

template <class type> CNode<type *> *CObjectList<type>::GetListHead(void)
{ 
    return m_lst.GetListHead();
}


/***************************************************************************
 *
 *  GetListTail
 *
 *  Description:
 *      Gets the last node in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CNode *: list tail pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetListTail"

template <class type> CNode<type *> *CObjectList<type>::GetListTail(void)
{ 
    return m_lst.GetListTail();
}


/***************************************************************************
 *
 *  GetNodeCount
 *
 *  Description:
 *      Gets the count of nodes in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      UINT: count of nodes in the list.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetNodeCount"

template <class type> UINT CObjectList<type>::GetNodeCount(void)
{ 
    return m_lst.GetNodeCount(); 
}


/***************************************************************************
 *
 *  GetNodeByIndex
 *
 *  Description:
 *      Gets a node by it's index in the list.
 *
 *  Arguments:
 *      UINT [in]: node index.
 *
 *  Returns:  
 *      CNode *: node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetNodeByIndex"

template <class type> CNode<type *> *CObjectList<type>::GetNodeByIndex(UINT uIndex)
{
    return m_lst.GetNodeByIndex(uIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsapi.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.cpp
 *  Content:    DirectSound APIs
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      REFGUID [in]: driver GUID or NULL to use preferred driver.
 *      LPDIRECTSOUND * [out]: receives IDirectSound interface to the new
 *                             DirectSound object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreate"

HRESULT WINAPI DirectSoundCreate
(
    LPCGUID         pGuid,
    LPDIRECTSOUND*  ppIDirectSound,
    LPUNKNOWN       pUnkOuter
)
{
    CDirectSound *          pDirectSound    = NULL;
    LPDIRECTSOUND           pIDirectSound   = NULL;
    HRESULT                 hr              = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCreate, pGuid, ppIDirectSound, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSound))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSound object
    if(SUCCEEDED(hr))
    {
        pDirectSound = NEW(CDirectSound);
        hr = HRFROMP(pDirectSound);
    }

    // Initialize the object
    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSound interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound, TRUE, (LPVOID *)&pIDirectSound);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSound = pIDirectSound;
    }
    else
    {
        RELEASE(pDirectSound);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCreate8
 *
 *  Description:
 *      Creates and initializes a DirectSound 8.0 object.
 *
 *  Arguments:
 *      REFGUID [in]: Driver GUID or NULL to use preferred driver.
 *      LPDIRECTSOUND8 * [out]: Receives IDirectSound8 interface to
 *                              the new DirectSound object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreate8"

HRESULT WINAPI DirectSoundCreate8
(
    LPCGUID         pGuid,
    LPDIRECTSOUND8* ppIDirectSound8,
    LPUNKNOWN       pUnkOuter
)
{
    CDirectSound *          pDirectSound    = NULL;
    LPDIRECTSOUND8          pIDirectSound8  = NULL;
    HRESULT                 hr              = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCreate8, pGuid, ppIDirectSound8, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSound8))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSound object
    if(SUCCEEDED(hr))
    {
        pDirectSound = NEW(CDirectSound);
        hr = HRFROMP(pDirectSound);
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        pDirectSound->SetDsVersion(DSVERSION_DX8);

        // Initialize the object
        hr = pDirectSound->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSound8 interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound8, TRUE, (LPVOID *)&pIDirectSound8);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSound8 = pIDirectSound8;
    }
    else
    {
        RELEASE(pDirectSound);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCaptureCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundCapture object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID or NULL/GUID_NULL to use preferred driver.
 *      LPDIRECTSOUNDCAPTURE * [out]: receives IDirectSoundCapture interface
 *                                    to the new DirectSoundCapture object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureCreate"

HRESULT WINAPI DirectSoundCaptureCreate
(
    LPCGUID                 pGuid,
    LPDIRECTSOUNDCAPTURE*   ppIDirectSoundCapture,
    LPUNKNOWN               pUnkOuter
)
{
    CDirectSoundCapture *   pDirectSoundCapture     = NULL;
    LPDIRECTSOUNDCAPTURE    pIDirectSoundCapture    = NULL;
    HRESULT                 hr                      = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCaptureCreate, pGuid, ppIDirectSoundCapture, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSoundCapture))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSoundCapture object
    if(SUCCEEDED(hr))
    {
        pDirectSoundCapture = NEW(CDirectSoundCapture);
        hr = HRFROMP(pDirectSoundCapture);
    }

    // Initialize the object
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundCapture->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSoundCapture interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundCapture->QueryInterface(IID_IDirectSoundCapture, TRUE, (LPVOID *)&pIDirectSoundCapture);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSoundCapture = pIDirectSoundCapture;
    }
    else
    {
        RELEASE(pDirectSoundCapture);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCaptureCreate8
 *
 *  Description:
 *      Creates and initializes a DirectSoundCapture 8.0 object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID or NULL/GUID_NULL to use preferred driver.
 *      LPDIRECTSOUNDCAPTURE8 * [out]: receives IDirectSoundCapture8 interface
 *                                     to the new DirectSoundCapture8 object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureCreate8"

HRESULT WINAPI DirectSoundCaptureCreate8
(
    LPCGUID                 pGuid,
    LPDIRECTSOUNDCAPTURE8*  ppIDirectSoundCapture8,
    LPUNKNOWN               pUnkOuter
)
{
    CDirectSoundCapture *   pDirectSoundCapture     = NULL;
    LPDIRECTSOUNDCAPTURE    pIDirectSoundCapture8   = NULL;
    HRESULT                 hr                      = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCaptureCreate8, pGuid, ppIDirectSoundCapture8, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSoundCapture8))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSoundCapture object
    if(SUCCEEDED(hr))
    {
        pDirectSoundCapture = NEW(CDirectSoundCapture);
        hr = HRFROMP(pDirectSoundCapture);
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        pDirectSoundCapture->SetDsVersion(DSVERSION_DX8);

        // Initialize the object
        hr = pDirectSoundCapture->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSoundCapture8 interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundCapture->QueryInterface(IID_IDirectSoundCapture8, TRUE, (LPVOID *)&pIDirectSoundCapture8);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSoundCapture8 = pIDirectSoundCapture8;
    }
    else
    {
        RELEASE(pDirectSoundCapture);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundFullDuplexCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundFullDuplex object.
 *
 *  Arguments:
 *      REFGUID [in]: driver GUID or NULL to use preferred capture driver.
 *      REFGUID [in]: driver GUID or NULL to use preferred render driver.
 *      LPDIRECTSOUNDAEC * [out]: receives IDirectSoundFullDuplex interface to the new
 *                             DirectSoundFullDuplex object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundFullDuplexCreate"

HRESULT WINAPI
DirectSoundFullDuplexCreate
(
    LPCGUID                         pCaptureGuid,
    LPCGUID                         pRenderGuid,
    LPCDSCBUFFERDESC                lpDscBufferDesc,
    LPCDSBUFFERDESC                 lpDsBufferDesc,
    HWND                            hWnd,
    DWORD                           dwLevel,
    LPDIRECTSOUNDFULLDUPLEX*        lplpDSFD,
    LPLPDIRECTSOUNDCAPTUREBUFFER8   lplpDirectSoundCaptureBuffer8,
    LPLPDIRECTSOUNDBUFFER8          lplpDirectSoundBuffer8,
    LPUNKNOWN                       pUnkOuter
)
{
    CDirectSoundFullDuplex *       pDirectSoundFullDuplex    = NULL;
    LPDIRECTSOUNDFULLDUPLEX        pIDirectSoundFullDuplex   = NULL;
    CDirectSoundCaptureBuffer *    pCaptureBuffer            = NULL;
    LPDIRECTSOUNDCAPTUREBUFFER8    pIdsCaptureBuffer8        = NULL;
    CDirectSoundBuffer *           pBuffer                   = NULL;
    LPDIRECTSOUNDBUFFER8           pIdsBuffer8               = NULL;
    HRESULT                        hr                        = DS_OK;
    DSCBUFFERDESC                  dscbdi;
    DSBUFFERDESC                   dsbdi;

    ENTER_DLL_MUTEX();
    DPF_API10(DirectSoundFullDuplexCreate, pCaptureGuid, pRenderGuid, lpDscBufferDesc, lpDsBufferDesc, lplpDSFD, hWnd, dwLevel, lplpDirectSoundCaptureBuffer8, lplpDirectSoundBuffer8, pUnkOuter);
    DPF_ENTER();

    if(pCaptureGuid && !IS_VALID_READ_GUID(pCaptureGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid capture guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(pRenderGuid && !IS_VALID_READ_GUID(pRenderGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid render guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(lpDscBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DSC buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(lpDscBufferDesc, &dscbdi, DSVERSION_DX8);
        if (FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(lpDsBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DS buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(lpDsBufferDesc, &dsbdi, DSVERSION_DX8, FALSE);
        if (FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && (dsbdi.dwFlags & DSBCAPS_PRIMARYBUFFER))
    {
        RPF(DPFLVL_ERROR, "Cannot specify DSBCAPS_PRIMARYBUFFER with DirectSoundFullDuplexCreate");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hWnd))
    {
        RPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwLevel < DSSCL_FIRST || dwLevel > DSSCL_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid cooperative level");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDSFD))
    {
        RPF(DPFLVL_ERROR, "Invalid DirectSoundFullDuplex interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundCaptureBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid capture buffer interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid render buffer interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSoundFullDuplex object
    if(SUCCEEDED(hr))
    {
        pDirectSoundFullDuplex = NEW(CDirectSoundFullDuplex);
        hr = HRFROMP(pDirectSoundFullDuplex);
    }

    // Initialize the object
    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        pDirectSoundFullDuplex->SetDsVersion(DSVERSION_DX8);

        hr = pDirectSoundFullDuplex->Initialize(pCaptureGuid, pRenderGuid, &dscbdi, &dsbdi, hWnd, dwLevel, &pCaptureBuffer, &pBuffer);
    }

    // Query for an IDirectSoundFullDuplex interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundFullDuplex->QueryInterface(IID_IDirectSoundFullDuplex, TRUE, (LPVOID *)&pIDirectSoundFullDuplex);
    }

    // Query for an IDirectSoundCaptureBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pCaptureBuffer->QueryInterface(IID_IDirectSoundCaptureBuffer8, TRUE, (LPVOID *)&pIdsCaptureBuffer8);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8, TRUE, (LPVOID *)&pIdsBuffer8);
    }

    if(SUCCEEDED(hr))
    {
        *lplpDSFD = pIDirectSoundFullDuplex;
        *lplpDirectSoundCaptureBuffer8 = pIdsCaptureBuffer8;
        *lplpDirectSoundBuffer8 = pIdsBuffer8;
    }
    else
    {
        RELEASE(pCaptureBuffer);
        RELEASE(pBuffer);
        RELEASE(pDirectSoundFullDuplex);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CallDirectSoundEnumerateCallback
 *
 *  Description:
 *      Helper function for DirectSoundEnumerate.  This function converts
 *      arguments into the proper format and calls the callback function.
 *
 *  Arguments:
 *      LPDSENUMCALLBACKA [in]: pointer to the ANSI callback function.
 *      LPDSENUMCALLBACKW [in]: pointer to the Unicode callback function.
 *      CDeviceDescription * [in]: driver information.
 *      LPVOID [in]: passed directly to the callback function.
 *      LPBOOL: [in/out]: TRUE to continue enumerating.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CallDirectSoundEnumerateCallback"

HRESULT CallDirectSoundEnumerateCallback(LPDSENUMCALLBACKA pfnCallbackA, LPDSENUMCALLBACKW pfnCallbackW, CDeviceDescription *pDesc, LPVOID pvContext, LPBOOL pfContinue)
{
    static const LPCSTR     pszEmptyA   = "";
    static const LPCWSTR    pszEmptyW   = L"";
    LPGUID                  pguid;
    LPCSTR                  pszNameA;
    LPCWSTR                 pszNameW;
    LPCSTR                  pszPathA;
    LPCWSTR                 pszPathW;

    DPF_ENTER();

    if(IS_NULL_GUID(&pDesc->m_guidDeviceId))
    {
        pguid = NULL;
    }
    else
    {
        pguid = &pDesc->m_guidDeviceId;
    }

    if(pDesc->m_strName.IsEmpty())
    {
        pszNameA = pszEmptyA;
        pszNameW = pszEmptyW;
    }
    else
    {
        pszNameA = pDesc->m_strName;
        pszNameW = pDesc->m_strName;
    }

    if(pDesc->m_strPath.IsEmpty())
    {
        pszPathA = pszEmptyA;
        pszPathW = pszEmptyW;
    }
    else
    {
        pszPathA = pDesc->m_strPath;
        pszPathW = pDesc->m_strPath;
    }

    if(*pfContinue && pfnCallbackA)
    {
        *pfContinue = pfnCallbackA(pguid, pszNameA, pszPathA, pvContext);
    }

    if(*pfContinue && pfnCallbackW)
    {
        *pfContinue = pfnCallbackW(pguid, pszNameW, pszPathW, pvContext);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  InternalDirectSoundEnumerate
 *
 *  Description:
 *      Enumerates available drivers.  The GUIDs passed to the callback
 *      function can be passed to DirectSoundCreate in order to create
 *      a DirectSound object using that driver.
 *
 *  Arguments:
 *      LPDSENUMCALLBACK [in]: pointer to the callback function.
 *      LPVOID [in]: passed directly to the callback function.
 *      BOOL [in]: TRUE if the callback expects Unicode strings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InternalDirectSoundEnumerate"

HRESULT InternalDirectSoundEnumerate(LPDSENUMCALLBACKA pfnCallbackA, LPDSENUMCALLBACKW pfnCallbackW, LPVOID pvContext, VADDEVICETYPE vdt)
{
    const DWORD                     dwEnumDriversFlags      = VAD_ENUMDRIVERS_ORDER | VAD_ENUMDRIVERS_REMOVEPROHIBITEDDRIVERS | VAD_ENUMDRIVERS_REMOVEDUPLICATEWAVEDEVICES;
    BOOL                            fContinue               = TRUE;
    CDeviceDescription *            pPreferred              = NULL;
    HRESULT                         hr                      = DS_OK;
    DSAPPHACKS                      ahAppHacks;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription *> *   pNode;
    TCHAR                           szDescription[0x100];

    ENTER_DLL_MUTEX();
    DPF_ENTER();

    if(SUCCEEDED(hr) && pfnCallbackA && !IS_VALID_CODE_PTR(pfnCallbackA))
    {
        RPF(DPFLVL_ERROR, "Invalid callback function pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pfnCallbackW && !IS_VALID_CODE_PTR(pfnCallbackW))
    {
        RPF(DPFLVL_ERROR, "Invalid callback function pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pfnCallbackA && !pfnCallbackW)
    {
        RPF(DPFLVL_ERROR, "No callback function pointer supplied");
        hr = DSERR_INVALIDPARAM;
    }

    // Load apphacks in order to disable certain devices
    if(SUCCEEDED(hr))
    {
        AhGetAppHacks(&ahAppHacks);
        vdt &= ~ahAppHacks.vdtDisabledDevices;
    }

    // Enumerate available drivers for all device types corresponding
    // to the supplied device type mask.
    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->EnumDrivers(vdt, dwEnumDriversFlags, &lstDrivers);
    }

    // Pass the preferred device to the callback function
    if(SUCCEEDED(hr))
    {
        pPreferred = NEW(CDeviceDescription);
        hr = HRFROMP(pPreferred);
    }

    if(SUCCEEDED(hr) && IS_RENDER_VAD(vdt) && fContinue)
    {
        if(LoadString(hModule, IDS_PRIMARYDRIVER, szDescription, NUMELMS(szDescription)))
        {
            pPreferred->m_strName = szDescription;

            hr = CallDirectSoundEnumerateCallback(pfnCallbackA, pfnCallbackW, pPreferred, pvContext, &fContinue);
        }
    }

    if(SUCCEEDED(hr) && IS_CAPTURE_VAD(vdt) && fContinue)
    {
        if(LoadString(hModule, IDS_PRIMARYCAPDRIVER, szDescription, NUMELMS(szDescription)))
        {
            pPreferred->m_strName = szDescription;

            hr = CallDirectSoundEnumerateCallback(pfnCallbackA, pfnCallbackW, pPreferred, pvContext, &fContinue);
        }
    }

    // Pass each driver to the callback function
    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = CallDirectSoundEnumerateCallback(pfnCallbackA, pfnCallbackW, pNode->m_data, pvContext, &fContinue);
    }

    // Clean up
    RELEASE(pPreferred);

    DPF_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundEnumerate
 *
 *  Description:
 *      Enumerates available drivers.  The GUIDs passed to the callback
 *      function can be passed to DirectSoundCreate in order to create
 *      a DirectSound object using that driver.
 *
 *  Arguments:
 *      LPDSENUMCALLBACK [in]: pointer to the callback function.
 *      LPVOID [in]: passed directly to the callback function.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundEnumerateA"

HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundEnumerateA, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(pfnCallback, NULL, pvContext, VAD_DEVICETYPE_RENDERMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "DirectSoundEnumerateW"

HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundEnumerateW, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(NULL, pfnCallback, pvContext, VAD_DEVICETYPE_RENDERMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCaptureEnumerate
 *
 *  Description:
 *      Enumerates available drivers.  The GUIDs passed to the callback
 *      function can be passed to DirectSoundCaptureCreate in order to create
 *      a DirectSoundCapture object using that driver.
 *
 *  Arguments:
 *      LPDSENUMCALLBACK [in]: pointer to the callback function.
 *      LPVOID [in]: passed directly to the callback function.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureEnumerateA"

HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundCaptureEnumerateA, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(pfnCallback, NULL, pvContext, VAD_DEVICETYPE_CAPTUREMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureEnumerateW"

HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundCaptureEnumerateW, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(NULL, pfnCallback, pvContext, VAD_DEVICETYPE_CAPTUREMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceID
 *
 *  Description:
 *      Translates from default device IDs to specific device IDs.
 *
 *      If the 'pGuidSrc' argument is one of the default IDs defined
 *      in dsound.h (DSDEVID_DefaultPlayback, DSDEVID_DefaultCapture,
 *      DSDEVID_DefaultVoicePlayback or DSDEVID_DefaultVoiceCapture),
 *      we return the corresponding device GUID in 'pGuidDest'.
 *
 *      Otherwise, if 'pGuidSrc' is already a valid specific device
 *      ID, we just copy it to 'pGuidDest' and return success.
 *
 *  Arguments:
 *      LPCGUID [in]: a (speficic or default) device ID.
 *      LPGUID [out]: receives the corresponding device ID.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetDeviceID"

HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest)
{
    HRESULT hr = DS_OK;
    ENTER_DLL_MUTEX();
    DPF_API2(GetDeviceID, pGuidSrc, pGuidDest);
    DPF_ENTER();

    if (!IS_VALID_READ_GUID(pGuidSrc) || !IS_VALID_WRITE_GUID(pGuidDest))
    {
        RPF(DPFLVL_ERROR, "Invalid GUID pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        // GetDeviceDescription() maps from a default ID to a specific ID
        CDeviceDescription *pDesc = NULL;
        hr = g_pVadMgr->GetDeviceDescription(*pGuidSrc, &pDesc);

        if (SUCCEEDED(hr))
        {
            *pGuidDest = pDesc->m_guidDeviceId;
            pDesc->Release();
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbasic.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbasic.h
 *  Content:    Basic class that all DirectSound objects are derived from.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/9/97      dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSBASIC_H__
#define __DSBASIC_H__

#ifdef __cplusplus

// Reference count class
class CRefCount
{
private:
    ULONG               m_ulRefCount;

public:
    CRefCount(ULONG = 0);
    virtual ~CRefCount(void);

public:
    ULONG GetRefCount(void);
    void SetRefCount(ULONG);
    virtual ULONG AddRef(void);
    virtual ULONG Release(void);
};

// Base class that all DirectSound objects are derived from
class CDsBasicRuntime
    : public CRefCount
{
private:
    const DWORD         m_dwOwnerPid;       // Owning process id
    const DWORD         m_dwOwnerTid;       // Owning thread id
    BOOL                m_fAbsoluteRelease; // TRUE to delete the object on release

public:
    CDsBasicRuntime(BOOL = TRUE);
    virtual ~CDsBasicRuntime(void);

public:
    // Object ownership
    DWORD GetOwnerProcessId(void) const;
    DWORD GetOwnerThreadId(void) const;
    
    // Object reference management
    virtual ULONG Release(void);
    void AbsoluteRelease(void);
};

// Runtime extension of the CList template class
template <class type> class CObjectList
{
private:
    CList<type *>           m_lst;

public:
    CObjectList(void);
    virtual ~CObjectList(void);

public:
    // Node creation, removal
    virtual CNode<type *> *AddNodeToList(type *);
    virtual CNode<type *> *InsertNodeIntoList(CNode<type *> *, type *);
    virtual void RemoveNodeFromList(CNode<type *> *);
    virtual void RemoveAllNodesFromList(void);
    
    // Node manipulation by data
    virtual BOOL RemoveDataFromList(type *);
    virtual CNode<type *> *IsDataInList(type *);
    virtual CNode<type *> *GetNodeByIndex(UINT);
    
    // Basic list information
    virtual CNode<type *> *GetListHead(void);
    virtual CNode<type *> *GetListTail(void);
    virtual UINT GetNodeCount(void);
};

// Release/Absolute release helpers
template <class type> type *__AddRef(type *);
template <class type> void __Release(type *);
template <class type> void __AbsoluteRelease(type *);

#define ADDREF(p) \
            __AddRef(p)

#define RELEASE(p) \
            __Release(p), (p) = NULL

#define ABSOLUTE_RELEASE(p) \
            __AbsoluteRelease(p), (p) = NULL

#include "dsbasic.cpp"

#endif // __cplusplus

#endif // __DSBASIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbnotes.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbnotes.h
 *  Content:    Notification events.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/11/97     FrankYe Created.
 *
 ***************************************************************************/

#ifndef __DSBNOTES_H__
#define __DSBNOTES_H__

#ifdef __cplusplus

class CDsbNotes {
    public:
	CDsbNotes();
	~CDsbNotes();
	HRESULT Initialize(int cbBuffer);
	__inline BOOL HasNotifications(void);
	HRESULT SetNotificationPositions(int cNotes, LPCDSBPOSITIONNOTIFY paNotes);
	void SetPosition(int ibPosition);
	void NotifyToPosition(int ibNewPosition, int *pdbNextNotify);
	void NotifyStop(void);

    private:
	void SetDsbEvent(HANDLE Event);
	void FreeNotificationPositions(void);
	
	int			m_cNotes;
        int                     m_cPosNotes;
	LPDSBPOSITIONNOTIFY	m_paNotes;
	
	int			m_cbBuffer;

	int			m_ibLastPosition;
	int			m_iNextPositionNote;
};

__inline BOOL CDsbNotes::HasNotifications(void) { return (0 != m_cNotes); }

#endif // __cplusplus

#endif // __DSBNOTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbnotes.cpp ===
//--------------------------------------------------------------------------;
//
//  File: dsbnotes.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  History:
//      03/11/97        FrankYe         Created
//
//--------------------------------------------------------------------------;
#define NODSOUNDSERVICETABLE

#include "dsoundi.h"
#include <limits.h>

#ifndef Not_VxD
#pragma warning(disable:4002)
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif

#ifndef NOVXD
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hSource);
#endif // NOVXD

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::CDsbNotes"

// The debug output from dsound.vxd is overwhelming some people.
// This is a stopgap solution until someone is inspired to set up
// the same fine-grained debug level system here as in dsound.dll.
// Define DPF_VERBOSE as 1 if you want to re-enable all traces...
#define DPF_VERBOSE 0

CDsbNotes::CDsbNotes(void)
{
#ifdef Not_VxD
    m_cNotes = 0;
    m_cPosNotes = 0;
    m_paNotes = NULL;
    m_iNextPositionNote = 0;
#else
    ASSERT(FALSE);
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::~CDsbNotes"

CDsbNotes::~CDsbNotes(void)
{
#ifdef Not_VxD
    FreeNotificationPositions();
#else
    ASSERT(FALSE);
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::Initialize"

HRESULT CDsbNotes::Initialize(int cbBuffer)
{
#ifdef Not_VxD
    m_cbBuffer = cbBuffer;
    return S_OK;
#else
    ASSERT(FALSE);
    return E_NOTIMPL;
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::SetNotificationPositions"

HRESULT CDsbNotes::SetNotificationPositions(int cEvents, LPCDSBPOSITIONNOTIFY paNotes)
{
#ifdef Not_VxD
    const DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr;
    int i, j;

    hr = S_OK;

    // First remove existing notifications
    FreeNotificationPositions();

    //
    // The VxDHandles are opened only once for each Win32 event handle.  And
    // it is valid for the client to use the same Win32 event handle for
    // multiple position events.
    //
    // So, we need use nested loops such that for each Win32 event handle
    // we open a VxDHandle and use that same VxDHandle if the same
    // Win32 event handle is used again in the list.
    //
    // Pseudocode:
    //
    //  For each element in list
    //      If VxD handle is not open, then open it
    //          For remaining elements in list
    //              If Win32 handle is the same as the one we just processed
    //                  Use the same VxD handle
    //

    m_cNotes = cEvents;
    m_cPosNotes = m_cNotes;

    if(m_cNotes) {
        m_paNotes = MEMALLOC_A(DSBPOSITIONNOTIFY, m_cNotes);
        if(m_paNotes) {
            for(i = 0; i < m_cNotes; i++) {
                m_paNotes[i].dwOffset = paNotes[i].dwOffset;
                if(DSBPN_OFFSETSTOP == m_paNotes[i].dwOffset) m_cPosNotes--;
                if(!m_paNotes[i].hEventNotify) {
#ifndef NOVXD
                    if(g_hDsVxd) {
                        m_paNotes[i].hEventNotify = (HANDLE)OpenVxDHandle(paNotes[i].hEventNotify);
                    } else {
#endif // NOVXD
                        m_paNotes[i].hEventNotify = GetGlobalHandleCopy(paNotes[i].hEventNotify, dwProcessId, FALSE);
#ifndef NOVXD
                    }
#endif // NOVXD
                } else {
                    for(j = i + 1; j < m_cNotes; j++) {
                        if(paNotes[j].hEventNotify == paNotes[i].hEventNotify) {
                            m_paNotes[j].hEventNotify = m_paNotes[i].hEventNotify;
                        }
                    }
                }
            }

        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
#else
    ASSERT(FALSE);
    return E_NOTIMPL;
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::SetPosition"

void CDsbNotes::SetPosition(int ibPosition)
{
    if (0 == m_cPosNotes) return;
    
    for(int i = 0; i < m_cPosNotes; i++) {
        if(m_paNotes[i].dwOffset >= (DWORD)ibPosition) break;
    }

    if(i == m_cPosNotes) i = 0;

    ASSERT(i >= 0);
    ASSERT(i < m_cPosNotes);

    m_ibLastPosition = ibPosition;
    m_iNextPositionNote = i;

    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::NotifyToPosition"

void CDsbNotes::NotifyToPosition(IN  int ibPosition,
                 OUT int *pdbNextNotify)
{
    int ibNotify;
    int dbNextNotify;
    int cSignals;
    BOOL fSignal;
    int i;

    *pdbNextNotify = INT_MAX;
    
    if (0 == m_cPosNotes) return;

    // Setup loop

#if DPF_VERBOSE
#ifdef Not_VxD
    DPF(DPFLVL_MOREINFO, "Position = %lu", ibPosition);
#else // Not_VxD
    DPF(("Position = %lu", ibPosition));
#endif // Not_VxD
#endif // DPF_VERBOSE
    
    cSignals = 0;
    fSignal = TRUE;
    i = m_iNextPositionNote - 1;
    
    while (fSignal && cSignals++ < m_cPosNotes) {

        HANDLE Event;

        // Advance index into ring buffer;
        if (++i == m_cPosNotes) i = 0;

        fSignal = FALSE;
        ibNotify = m_paNotes[i].dwOffset;
        Event = m_paNotes[i].hEventNotify;

        // If the notify position is >= last position and < current position
        // then we should signal it.
        if (m_ibLastPosition <= ibPosition) {
            // We have not wrapped
            if (ibNotify >= m_ibLastPosition && ibNotify < ibPosition) {
#if DPF_VERBOSE
#ifdef Not_VxD
                DPF(DPFLVL_MOREINFO, "Signalling %lu", ibNotify);
#else // Not_VxD
                DPF(("Signalling %lu", ibNotify));
#endif // Not_VxD
#endif // DPF_VERBOSE
                SetDsbEvent(Event);
                fSignal = TRUE;
            }
        } else {
            // We have wrapped
            if (ibNotify >= m_ibLastPosition || ibNotify < ibPosition) {
#if DPF_VERBOSE
#ifdef Not_VxD
                DPF(DPFLVL_MOREINFO, "Signalling %lu (wrapped)", ibNotify);
#else // Not_VxD
                DPF(("Signalling %lu (wrapped)", ibNotify));
#endif // Not_VxD
#endif // DPF_VERBOSE
                SetDsbEvent(Event);
                fSignal = TRUE;
            }
        }

    }

    // New state
    m_iNextPositionNote = i;
    m_ibLastPosition = ibPosition;

    // Compute time, in bytes, 'til next notify
    if (ibNotify >= ibPosition) {
        dbNextNotify = ibNotify - ibPosition;
    } else {
        dbNextNotify = ibNotify + m_cbBuffer - ibPosition;
    }

    *pdbNextNotify = dbNextNotify;
    
    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::NotifyStop"

void CDsbNotes::NotifyStop(void)
{
    for (int i = m_cPosNotes; i < m_cNotes; i++) SetDsbEvent(m_paNotes[i].hEventNotify);
    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::SetDsbEvent"

void CDsbNotes::SetDsbEvent(HANDLE Event)
{
#ifdef Not_VxD
#ifndef NOVXD
    if(g_hDsVxd) {
    VxdEventScheduleWin32Event((DWORD)Event, 0);
    } else {
#endif // NOVXD
    SetEvent(Event);
#ifndef NOVXD
    }
#endif // NOVXD
#else
    eventScheduleWin32Event((DWORD)Event, 0);
#endif
    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::FreeNotificationPositions"

void CDsbNotes::FreeNotificationPositions(void)
{
#ifdef Not_VxD
    //
    // The VxDHandles are opened only once for each Win32 event handle.  And
    // it is valid for the client to use the same Win32 event handle for
    // multiple position events.
    //
    // So, we need use nested loops such that for each VxDHandle that we
    // close we find all duplicates and mark them as closed, too.
    //
    // Pseudocode:
    //
    //  For each element in list
    //      If VxD handle is open, then close it
    //          For remaining elements in list
    //              If VxD handle is the same as the one we just closed
    //                  Mark it closed
    //
    
    if (m_cNotes) {
        ASSERT(m_paNotes);
        for (int i = 0; i < m_cNotes; i++) {
            if (m_paNotes[i].hEventNotify) {
#ifndef NOVXD
                if(g_hDsVxd) {
                    VxdEventCloseVxdHandle((DWORD)m_paNotes[i].hEventNotify);
                } else {
#endif //NOVXD
                    CloseHandle(m_paNotes[i].hEventNotify);
#ifndef NOVXD
                }
#endif // NOVXD

                for (int j = i+1; j < m_cNotes; j++) {
                    if (m_paNotes[j].hEventNotify == m_paNotes[i].hEventNotify) {
                        m_paNotes[j].hEventNotify = NULL;
                    }
                }
            }
        }
        MEMFREE(m_paNotes);
        m_paNotes = NULL;
        m_cNotes = 0;
        m_cPosNotes = 0;
    } else {
        ASSERT(!(m_paNotes));
        ASSERT(!(m_cPosNotes));
    }
#else
    ASSERT(FALSE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbuf.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbuf.cpp
 *  Content:    DirectSound Buffer object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Many changes, fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"

inline DWORD DSBCAPStoDSBPLAY(DWORD dwCaps)     {return (dwCaps >> 1) & DSBPLAY_LOCMASK;}
inline DWORD DSBCAPStoDSBSTATUS(DWORD dwCaps)   {return (dwCaps << 1) & DSBSTATUS_LOCMASK;}
inline DWORD DSBPLAYtoDSBCAPS(DWORD dwPlay)     {return (dwPlay << 1) & DSBCAPS_LOCMASK;}
inline DWORD DSBPLAYtoDSBSTATUS(DWORD dwPlay)   {return (dwPlay << 2) & DSBSTATUS_LOCMASK;}
inline DWORD DSBSTATUStoDSBCAPS(DWORD dwStatus) {return (dwStatus >> 1) & DSBCAPS_LOCMASK;}
inline DWORD DSBSTATUStoDSBPLAY(DWORD dwStatus) {return (dwStatus >> 2) & DSBPLAY_LOCMASK;}


/***************************************************************************
 *
 *  CDirectSoundBuffer
 *
 *  Description:
 *      DirectSound buffer object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::CDirectSoundBuffer"

CDirectSoundBuffer::CDirectSoundBuffer(CDirectSound *pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundBuffer);

    // Initialize defaults
    m_pDirectSound = pDirectSound;
    m_dwStatus = 0;

    InitStruct(&m_dsbd, sizeof(m_dsbd));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundBuffer
 *
 *  Description:
 *      DirectSound buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::~CDirectSoundBuffer"

CDirectSoundBuffer::~CDirectSoundBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBuffer);

    // Free memory
    MEMFREE(m_dsbd.lpwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateBufferStatusFlags
 *
 *  Description:
 *      Converts a set of VAD_BUFFERSTATE_* flags to DSBSTATUS_* flags.
 *
 *  Arguments:
 *      DWORD [in]: VAD_BUFFERSTATE_* flags.
 *      LPDWORD [in/out]: current buffer flags.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::UpdateBufferStatusFlags"

void CDirectSoundBuffer::UpdateBufferStatusFlags(DWORD dwState, LPDWORD pdwStatus)
{
    const DWORD dwStateMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING;

    DPF_ENTER();

    dwState &= dwStateMask;

    if(!(dwState & VAD_BUFFERSTATE_STARTED))
    {
        ASSERT(!(dwState & VAD_BUFFERSTATE_LOOPING));
        dwState &= ~VAD_BUFFERSTATE_LOOPING;
    }

    if(dwState & VAD_BUFFERSTATE_STARTED)
    {
        *pdwStatus |= DSBSTATUS_PLAYING;
    }
    else
    {
        *pdwStatus &= ~DSBSTATUS_PLAYING;
    }

    if(dwState & VAD_BUFFERSTATE_LOOPING)
    {
        *pdwStatus |= DSBSTATUS_LOOPING;
    }
    else
    {
        *pdwStatus &= ~DSBSTATUS_LOOPING;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDirectSoundPrimaryBuffer
 *
 *  Description:
 *      DirectSound primary buffer object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: pointer to the parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::CDirectSoundPrimaryBuffer"

CDirectSoundPrimaryBuffer::CDirectSoundPrimaryBuffer(CDirectSound *pDirectSound)
    : CDirectSoundBuffer(pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundPrimaryBuffer);

    // Initialize defaults
    m_pImpDirectSoundBuffer = NULL;
    m_pDeviceBuffer = NULL;
    m_p3dListener = NULL;
    m_pPropertySet = NULL;
    m_dwRestoreState = VAD_BUFFERSTATE_STOPPED | VAD_BUFFERSTATE_WHENIDLE;
    m_fWritePrimary = FALSE;
    m_ulUserRefCount = 0;
    m_hrInit = DSERR_UNINITIALIZED;
    m_bDataLocked = FALSE; 

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundPrimaryBuffer
 *
 *  Description:
 *      DirectSound primary buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::~CDirectSoundPrimaryBuffer"

CDirectSoundPrimaryBuffer::~CDirectSoundPrimaryBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBuffer);

    // Make sure to give up WRITEPRIMARY access
    if(m_pDeviceBuffer)
    {
        SetPriority(DSSCL_NONE);
    }

    // Free all interfaces
    DELETE(m_pImpDirectSoundBuffer);

    // Free owned objects
    ABSOLUTE_RELEASE(m_p3dListener);
    ABSOLUTE_RELEASE(m_pPropertySet);

    // Free the device buffer
    RELEASE(m_pDeviceBuffer);

    // The owning DirectSound object is responsible for updating the global
    // focus state.

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Initialize"

HRESULT CDirectSoundPrimaryBuffer::Initialize(LPCDSBUFFERDESC pDesc)
{
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);
    ASSERT(pDesc);

    // Create the device buffer
    hr = m_pDirectSound->m_pDevice->CreatePrimaryBuffer(pDesc->dwFlags, m_pDirectSound, &m_pDeviceBuffer);

    // Attempt to create the property set object
    if(SUCCEEDED(hr))
    {
        m_pPropertySet = NEW(CDirectSoundPropertySet(this));
        hr = HRFROMP(m_pPropertySet);

        if(SUCCEEDED(hr))
        {
            hr = m_pPropertySet->Initialize();
        }

        if(SUCCEEDED(hr))
        {
            // We don't care if this fails
            m_pPropertySet->AcquireResources(m_pDeviceBuffer);
        }
    }

    // Attempt to create the 3D listener
    if(SUCCEEDED(hr) && (pDesc->dwFlags & DSBCAPS_CTRL3D))
    {
        m_p3dListener = NEW(CDirectSound3dListener(this));
        hr = HRFROMP(m_p3dListener);

        if(SUCCEEDED(hr))
        {
            hr = m_p3dListener->Initialize(m_pDeviceBuffer);
        }
    }

    // Register the standard buffer interface with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundBuffer, this, &m_pImpDirectSoundBuffer);
    }

    // Build the local buffer description
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetCaps(&vrbc);
    }

    if(SUCCEEDED(hr))
    {
        m_dsbd.dwFlags = (vrbc.dwFlags & DSBCAPS_LOCMASK);
        m_dsbd.dwBufferBytes = vrbc.dwBufferBytes;

        m_dsbd.lpwfxFormat = AllocDefWfx();
        hr = HRFROMP(m_dsbd.lpwfxFormat);
    }

    // If the 3D listener has been created, he's already registered the
    // 3D listener interface.
    if(SUCCEEDED(hr) && m_p3dListener)
    {
        m_dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }

    // Handle buffer caps flags change
    if(SUCCEEDED(hr))
    {
        hr = SetBufferFlags(pDesc->dwFlags);
    }

    // Handle priority change
    if(SUCCEEDED(hr))
    {
        hr = SetPriority(m_pDirectSound->m_dsclCooperativeLevel.dwPriority);
    }

    // The DirectSound object creating this buffer is responsible for updating
    // the global focus state.

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Queries capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetCaps"

HRESULT CDirectSoundPrimaryBuffer::GetCaps(LPDSBCAPS pDsbCaps)
{
    DPF_ENTER();

    ASSERT(LXOR(m_dsbd.dwFlags & DSBCAPS_LOCSOFTWARE, m_dsbd.dwFlags & DSBCAPS_LOCHARDWARE));

    pDsbCaps->dwFlags = m_dsbd.dwFlags;
    pDsbCaps->dwBufferBytes = m_dsbd.dwBufferBytes;
    pDsbCaps->dwUnlockTransferRate = 0;
    pDsbCaps->dwPlayCpuOverhead = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  OnCreateSoundBuffer
 *
 *  Description:
 *      Called in response to an application calling
 *      CreateSoundBuffer(DSBCAPS_PRIMARYBUFFER).
 *
 *  Arguments:
 *      DWORD [in]: new buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::OnCreateSoundBuffer"

HRESULT CDirectSoundPrimaryBuffer::OnCreateSoundBuffer(DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // COMPATCOMPAT: in previous versions of DirectSound, calling
    // CreateSoundBuffer(PRIMARYBUFFER) once would change the buffer flags,
    // but calling it twice would just return a pointer to the same,
    // unmodified buffer.  I've introduced new behavior in this version
    // that would allow an app to modify the capabilities of the primary
    // buffer on-the-fly by calling CreateSoundBuffer(PRIMARYBUFFER) more
    // than once.  This could potentially free interfaces that the app
    // will later try to use.  One way to fix this would be to add a data
    // member to the DirectSound or primary buffer object that stores
    // whether or not the application has created a primary buffer already.

    // The steps outlined above are now implemented here:
    if(m_ulUserRefCount)
    {
        RPF((dwFlags == m_dsbd.dwFlags) ? DPFLVL_WARNING : DPFLVL_ERROR, "The primary buffer already exists.  Any changes made to the buffer description will be ignored.");
    }
    else
    {
        hr = SetBufferFlags(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        AddRef();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetBufferFlags
 *
 *  Description:
 *      Changes capabilities for the buffer.  This function is also
 *      responsible for creating and freeing interfaces.
 *
 *  Arguments:
 *      DWORD [in]: new buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetBufferFlags"

HRESULT CDirectSoundPrimaryBuffer::SetBufferFlags(DWORD dwFlags)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwVolPanCaps;

    DPF_ENTER();

    // Make sure we can handle the requested flags
    if((dwFlags & DSBCAPS_CTRL3D) && !m_p3dListener)
    {
        RPF(DPFLVL_ERROR, "No 3D listener support");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Not all capabilities of the DirectSound primary buffer map to the
    // methods of the device primary buffer.  Specifically, attenuation is
    // handled by the render device.  Let's check these flags before
    // proceeding.
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLATTENUATION))
    {
        hr = m_pDirectSound->m_pDevice->GetVolumePanCaps(&dwVolPanCaps);

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLVOLUME) && !(dwVolPanCaps & DSBCAPS_CTRLVOLUME))
        {
            RPF(DPFLVL_ERROR, "The device does not support CTRLVOLUME");
            hr = DSERR_CONTROLUNAVAIL;
        }

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLPAN) && !(dwVolPanCaps & DSBCAPS_CTRLPAN))
        {
            RPF(DPFLVL_ERROR, "The device does not support CTRLPAN");
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    // Fix up the 3D listener interface
    if(SUCCEEDED(hr) && ((m_dsbd.dwFlags & DSBCAPS_CTRL3D) != (dwFlags & DSBCAPS_CTRL3D)))
    {
        if(dwFlags & DSBCAPS_CTRL3D)
        {
            DPF(DPFLVL_INFO, "Primary buffer becoming CTRL3D.  Registering IID_IDirectSound3DListener");
            hr = RegisterInterface(IID_IDirectSound3DListener, m_p3dListener->m_pImpDirectSound3dListener, m_p3dListener->m_pImpDirectSound3dListener);
        }
        else
        {
            DPF(DPFLVL_INFO, "Primary buffer becoming ~CTRL3D.  Unregistering IID_IDirectSound3DListener");
            hr = UnregisterInterface(IID_IDirectSound3DListener);
        }
    }

    // Save buffer flags.  We're assuming that the buffer location has
    // already been saved to m_dsbd.dwFlags at this point.
    if(SUCCEEDED(hr))
    {
        m_dsbd.dwFlags = (dwFlags & ~DSBCAPS_LOCMASK) | (m_dsbd.dwFlags & DSBCAPS_LOCMASK);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: size of the format structure.  On entry, this
 *                        must be initialized to the size of the structure.
 *                        On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetFormat"

HRESULT CDirectSoundPrimaryBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CopyWfxApi(m_dsbd.lpwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the format for a given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetFormat"

HRESULT CDirectSoundPrimaryBuffer::SetFormat(LPCWAVEFORMATEX pwfxFormat)
{
    LPWAVEFORMATEX              pwfxLocal   = NULL;
    BOOL                        fActive     = MAKEBOOL(m_dwStatus & DSBSTATUS_ACTIVE);
    HRESULT                     hr          = DS_OK;
    CNode<CDirectSound *> *     pNode;
    BOOL bRewriteStartupSilence             = FALSE;

    DPF_ENTER();

    // Check access rights
    if(m_pDirectSound->m_dsclCooperativeLevel.dwPriority < DSSCL_PRIORITY)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not PRIORITY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Save a local copy of the format
    if(SUCCEEDED(hr))
    {
        pwfxLocal = CopyWfxAlloc(pwfxFormat);
        hr = HRFROMP(pwfxLocal);
    }

    // We can only change the format if we're active
    if(SUCCEEDED(hr) && !fActive)
    {
        // The Administrator says we're out of focus.  If there's not really anyone
        // else in focus, we're going to cheat and set the format anyway.

        // DuganP: This is weird - presumably done so fewer apps will break when the
        // user switches focus away from them temporarily.  There's the problem that
        // if multiple apps are in this state, whoever's last to set the format wins.
        // However, app-compat probably means we can't touch this code any more, so...

        for(pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(pNode->m_data && SUCCEEDED(pNode->m_data->IsInit()))
            {
                if(pNode->m_data->m_pPrimaryBuffer && this != pNode->m_data->m_pPrimaryBuffer && SUCCEEDED(pNode->m_data->m_pPrimaryBuffer->IsInit()))
                {
                    if(DSBUFFERFOCUS_INFOCUS == g_pDsAdmin->GetBufferFocusState(pNode->m_data->m_pPrimaryBuffer))
                    {
                        // NOTE: We added a "&& pNode->m_data->GetOwnerProcessId() != GetOwnerProcessId())"
                        // clause to fix WinME bug 120317, and we removed it again to fix DX8 bug 40627.

                        // We found an in-focus primary buffer [in another app], so fail.
                        break;
                    }
                }
            }
        }

        if(!pNode)
        {
            fActive = TRUE;
        }
    }

    // Apply the format to the device
    if(SUCCEEDED(hr))
    {
        if( m_fWritePrimary )
        {        
            //
            // See if this a WRITEPRIMARY app that's about to change to a new sample size.
            // If so, silence will need to be re-written for the new sample size
            // (providing the app hasn't locked any data yet).
            //
            LPWAVEFORMATEX pwfxOld;
            DWORD dwSize;
            HRESULT hrTmp = m_pDirectSound->m_pDevice->GetGlobalFormat(NULL, &dwSize);
            if(SUCCEEDED(hrTmp))
            {
                pwfxOld = (LPWAVEFORMATEX)MEMALLOC_A(BYTE, dwSize);
                if( pwfxOld )
                {
                    hrTmp = m_pDirectSound->m_pDevice->GetGlobalFormat(pwfxOld, &dwSize);
                    if( SUCCEEDED( hr ) )
                    {
                        if( pwfxLocal->wBitsPerSample != pwfxOld->wBitsPerSample )
                        {
                            bRewriteStartupSilence = TRUE;
                        }
                    }                                    
                    MEMFREE(pwfxOld);
                }
            }                
        }    
    
        if(fActive)
        {
            DPF(DPFLVL_INFO, "Setting the format on device " DPF_GUID_STRING, DPF_GUID_VAL(m_pDirectSound->m_pDevice->m_pDeviceDescription->m_guidDeviceId));

            // If we're WRITEPRIMARY, the format needs to be exact.  Otherwise,
            // we'll try to set the next closest format.  We're checking the
            // actual focus priority instead of our local writeprimary flag
            // in case the buffer is lost.
            if(DSSCL_WRITEPRIMARY == m_pDirectSound->m_dsclCooperativeLevel.dwPriority)
            {
                hr = m_pDirectSound->SetDeviceFormatExact(pwfxLocal);
            }
            else
            {
                hr = m_pDirectSound->SetDeviceFormat(pwfxLocal);
            }
        }
        else
        {
            DPF(DPFLVL_INFO, "NOT setting the format on device " DPF_GUID_STRING, DPF_GUID_VAL(m_pDirectSound->m_pDevice->m_pDeviceDescription->m_guidDeviceId));
        }
    }

    // Update the stored format
    if(SUCCEEDED(hr))
    {
        MEMFREE(m_dsbd.lpwfxFormat);
        m_dsbd.lpwfxFormat = pwfxLocal;
        
        if( bRewriteStartupSilence && !m_bDataLocked )
        {        
            // Refill the buffer with silence in the new sample size format,
            // only if the primary buffer was started playing before Locking any data.
            DSBUFFERFOCUS bfFocus = g_pDsAdmin->GetBufferFocusState(this);
            if( bfFocus == DSBUFFERFOCUS_INFOCUS)
            {
                ASSERT( m_fWritePrimary );
                // Request write access first
                HRESULT hrTmp = m_pDeviceBuffer->RequestWriteAccess(TRUE);
                if(SUCCEEDED(hrTmp))
                {
                    // Fill the buffer with silence.  At this point, we MUST be WRITEPRIMARY.
                    ::FillSilence(m_pDeviceBuffer->m_pSysMemBuffer->GetPlayBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);
                    hrTmp = m_pDeviceBuffer->CommitToDevice(0, m_pDeviceBuffer->m_pSysMemBuffer->GetSize());
#ifdef DEBUG                    
                    if(FAILED( hrTmp ) )
                    {
                        // Not a catastrophic failure if we fail this
                        DPF(DPFLVL_WARNING, "CommitToDevice for buffer at 0x%p failed (%ld) ", this, hrTmp);
                    }
#endif                    
                }   
#ifdef DEBUG                
                else
                {
                    // again, not a catastrophic failure
                    DPF(DPFLVL_WARNING, "RequestWriteAccess failed for buffer at 0x%p failed with %ld", this, hrTmp );
                }
#endif                
            }
        }            
                
    }
    else
    {
        MEMFREE(pwfxLocal);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetFrequency"

HRESULT CDirectSoundPrimaryBuffer::GetFrequency(LPDWORD pdwFrequency)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFREQUENCY");

    DPF_LEAVE_HRESULT(DSERR_CONTROLUNAVAIL);

    return DSERR_CONTROLUNAVAIL;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetFrequency"

HRESULT CDirectSoundPrimaryBuffer::SetFrequency(DWORD dwFrequency)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFREQUENCY");

    DPF_LEAVE_HRESULT(DSERR_CONTROLUNAVAIL);

    return DSERR_CONTROLUNAVAIL;
}


/***************************************************************************
 *
 *  GetPan
 *
 *  Description:
 *      Retrieves pan for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetPan"

HRESULT CDirectSoundPrimaryBuffer::GetPan(LPLONG plPan)
{
    HRESULT                 hr      = DS_OK;
    DSVOLUMEPAN             dsvp;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Ask the device for global attenuation and convert to pan
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->m_pDevice->GetGlobalAttenuation(&dsvp);
    }

    if(SUCCEEDED(hr))
    {
        *plPan = dsvp.lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetPan"

HRESULT CDirectSoundPrimaryBuffer::SetPan(LONG lPan)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set device pan
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->SetDevicePan(lPan);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Retrieves volume for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetVolume"

HRESULT CDirectSoundPrimaryBuffer::GetVolume(LPLONG plVolume)
{
    HRESULT                 hr      = DS_OK;
    DSVOLUMEPAN             dsvp;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Ask the device for global attenuation and convert to volume
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->m_pDevice->GetGlobalAttenuation(&dsvp);
    }

    if(SUCCEEDED(hr))
    {
        *plVolume = dsvp.lVolume;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the volume for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetVolume"

HRESULT CDirectSoundPrimaryBuffer::SetVolume(LONG lVolume)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set device volume
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->SetDeviceVolume(lVolume);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetNotificationPositions"

HRESULT CDirectSoundPrimaryBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLPOSITIONNOTIFY");

    DPF_LEAVE_HRESULT(DSERR_CONTROLUNAVAIL);

    return DSERR_CONTROLUNAVAIL;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetCurrentPosition"

HRESULT CDirectSoundPrimaryBuffer::GetCurrentPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwPlay;
    DWORD                   dwWrite;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check access rights
    if(SUCCEEDED(hr) && !m_fWritePrimary)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not WRITEPRIMARY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // We save the position to local variables so that the object we're
    // calling into doesn't have to worry about whether one or both of
    // the arguments are NULL.
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetCursorPosition(&dwPlay, &dwWrite);
    }

    // Block-align the positions
    if(SUCCEEDED(hr))
    {
        dwPlay = BLOCKALIGN(dwPlay, m_dsbd.lpwfxFormat->nBlockAlign);
        dwWrite = BLOCKALIGN(dwWrite, m_dsbd.lpwfxFormat->nBlockAlign);
    }

    // Apply app-hacks
    if(SUCCEEDED(hr) && m_pDirectSound->m_ahAppHacks.lCursorPad)
    {
        dwPlay = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
        dwWrite = PadCursor(dwWrite, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
    }

    if(SUCCEEDED(hr) && (m_pDirectSound->m_ahAppHacks.vdtReturnWritePos & m_pDirectSound->m_pDevice->m_vdtDeviceType))
    {
        dwPlay = dwWrite;
    }

    if(SUCCEEDED(hr) && m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.fEnable)
    {
        dwWrite = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.lCursorPad);
    }

    // Success
    if(SUCCEEDED(hr) && pdwPlay)
    {
        *pdwPlay = dwPlay;
    }

    if(SUCCEEDED(hr) && pdwWrite)
    {
        *pdwWrite = dwWrite;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play position for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetCurrentPosition"

HRESULT CDirectSoundPrimaryBuffer::SetCurrentPosition(DWORD dwPlayCursor)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support SetCurrentPosition");

    DPF_LEAVE_HRESULT(DSERR_INVALIDCALL);

    return DSERR_INVALIDCALL;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetStatus"

HRESULT CDirectSoundPrimaryBuffer::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                 hr          = DS_OK;
    DWORD                   dwStatus;
    DWORD                   dwState;

    DPF_ENTER();

    // Update the buffer status.  If we're lost, that's the only state we
    // care about
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        dwStatus = DSBSTATUS_BUFFERLOST;
    }
    else
    {
        // Get the current device buffer state
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
            UpdateBufferStatusFlags(dwState, &m_dwStatus);
        }

        // Fill in the buffer location
        if(SUCCEEDED(hr))
        {
            m_dwStatus |= DSBCAPStoDSBSTATUS(m_dsbd.dwFlags);
        }

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
        }
    }

    // Mask off bits that shouldn't get back to the app
    if(SUCCEEDED(hr))
    {
        dwStatus &= DSBSTATUS_USERMASK;
    }

    if(SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        dwStatus &= ~DSBSTATUS_LOCDEFERMASK;
    }

    if(SUCCEEDED(hr) && pdwStatus)
    {
        *pdwStatus = dwStatus;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: priority.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Play"

HRESULT CDirectSoundPrimaryBuffer::Play(DWORD dwPriority, DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Validate flags
    if(dwFlags != DSBPLAY_LOOPING)
    {
        RPF(DPFLVL_ERROR, "The only valid flag for primary buffers is LOOPING, which must always be set");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwPriority)
    {
        RPF(DPFLVL_ERROR, "Priority is not valid for primary buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops playing the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Stop"

HRESULT CDirectSoundPrimaryBuffer::Stop(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetBufferState
 *
 *  Description:
 *      Sets the buffer play/stop state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetBufferState"

HRESULT CDirectSoundPrimaryBuffer::SetBufferState(DWORD dwNewState)
{
    DWORD                   dwOldState;
    HRESULT                 hr;

    DPF_ENTER();

    if(m_fWritePrimary)
    {
        dwNewState &= ~VAD_BUFFERSTATE_WHENIDLE;
    }
    else
    {
        dwNewState |= VAD_BUFFERSTATE_WHENIDLE;
    }

    hr = m_pDeviceBuffer->GetState(&dwOldState);

    if(SUCCEEDED(hr) && dwNewState != dwOldState)
    {
        hr = m_pDeviceBuffer->SetState(dwNewState);
    }

    if(SUCCEEDED(hr))
    {
        m_dwRestoreState = dwNewState;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Activate
 *
 *  Description:
 *      Activates or deactivates the buffer object.
 *
 *  Arguments:
 *      BOOL [in]: Activation state.  TRUE to activate, FALSE to deactivate.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Activate"

HRESULT CDirectSoundPrimaryBuffer::Activate(BOOL fActive)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Apply cached properties.  If we fail while doing this, hard luck,
    // but there's nothing we can do about it.  We should never return
    // failure from Activate.
    if(MAKEBOOL(m_dwStatus & DSBSTATUS_ACTIVE) != fActive)
    {
        if(fActive)
        {
            m_dwStatus |= DSBSTATUS_ACTIVE;

            // Restore cached format
            hr = m_pDirectSound->SetDeviceFormatExact(m_dsbd.lpwfxFormat);

            if(FAILED(hr))
            {
                RPF(DPFLVL_WARNING, "Unable to restore cached primary buffer format");
            }

            // Restore primary buffer state
            hr = SetBufferState(m_dwRestoreState);

            if(FAILED(hr))
            {
                RPF(DPFLVL_WARNING, "Unable to restore cached primary buffer state");
            }
        }
        else
        {
            m_dwStatus &= ~DSBSTATUS_ACTIVE;
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetPriority
 *
 *  Description:
 *      Sets buffer priority.
 *
 *  Arguments:
 *      DWORD [in]: new priority.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetPriority"

HRESULT CDirectSoundPrimaryBuffer::SetPriority(DWORD dwPriority)
{
    const BOOL              fCurrent    = m_fWritePrimary;
    const BOOL              fNew        = (DSSCL_WRITEPRIMARY == dwPriority);
    HRESULT                 hr          = DS_OK;
    const DSBUFFERFOCUS     bfFocus     = g_pDsAdmin->GetBufferFocusState(this);

    DPF_ENTER();

    // Update our copy of the priority
    m_fWritePrimary = fNew;

    // If we're becoming WRITEPRIMARY but are out of focus, become immediately
    // lost.
    if (fNew && !fCurrent && bfFocus != DSBUFFERFOCUS_INFOCUS)
    {
        // Give up WRITEPRIMARY access
        m_fWritePrimary = FALSE;

        // Deactivate the buffer
        Activate(FALSE);

        // Flag the buffer as lost
        m_dwStatus |= DSBSTATUS_BUFFERLOST;

        hr = DSERR_OTHERAPPHASPRIO;
    }


    // Make sure the WRITEPRIMARY state has actually changed
    if(SUCCEEDED(hr) && fNew != fCurrent)
    {
        // If we're becoming WRITEPRIMARY, we need to request primary
        // access to the device.
        if(fNew)
        {
            // Request write access
            hr = m_pDeviceBuffer->RequestWriteAccess(TRUE);

            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p has become WRITEPRIMARY", this);
            }
        }

        // Fill the buffer with silence.  At this point, we MUST be WRITEPRIMARY.
        if(SUCCEEDED(hr))
        {
            ::FillSilence(m_pDeviceBuffer->m_pSysMemBuffer->GetPlayBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);
            hr = m_pDeviceBuffer->CommitToDevice(0, m_pDeviceBuffer->m_pSysMemBuffer->GetSize());
        }

        // If we're leaving WRITEPRIMARY, we need to relinquish primary
        // access to the device.
        if(!fNew)
        {
            // Free any open locks on the buffer
            m_pDeviceBuffer->OverrideLocks();

            // Give up write access
            hr = m_pDeviceBuffer->RequestWriteAccess(FALSE);

            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p is no longer WRITEPRIMARY", this);
            }
        }

        // Reset the buffer state
        if(SUCCEEDED(hr))
        {
            SetBufferState(VAD_BUFFERSTATE_STOPPED);
        }
    }

    // If we're currently lost, but the cooperative level has changed to
    // something other than WRITEPRIMARY, we'll go ahead and restore the
    // buffer for the app.  Only WRITEPRIMARY buffers can be lost.
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST) && !fNew)
    {
        m_dwStatus &= ~DSBSTATUS_BUFFERLOST;
    }

    // Recover from any errors
    if(FAILED(hr))
    {
        m_fWritePrimary = fCurrent;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for writing.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     ppvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the ppvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr2 parameter. If
 *                     ppvAudioPtr2 is NULL, this value will be 0.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Lock"

HRESULT CDirectSoundPrimaryBuffer::Lock(DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check access rights
    if(SUCCEEDED(hr) && !m_fWritePrimary)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not WRITEPRIMARY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Handle flags
    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_FROMWRITECURSOR))
    {
        hr = GetCurrentPosition(NULL, &dwWriteCursor);
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_ENTIREBUFFER))
    {
        dwWriteBytes = m_dsbd.dwBufferBytes;
    }

    // Cursor validation
    if(SUCCEEDED(hr) && dwWriteCursor >= m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_FROMWRITECURSOR));

        RPF(DPFLVL_ERROR, "Write cursor past buffer end");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwWriteBytes > m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size larger than buffer size");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !dwWriteBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size must be > 0");
        hr = DSERR_INVALIDPARAM;
    }

    // Lock the device buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Lock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
    }
    m_bDataLocked = TRUE; // used to signal that app has written data (reset only required 1 per buffer creation)

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Unlock"

HRESULT CDirectSoundPrimaryBuffer::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check access rights
    if(SUCCEEDED(hr) && !m_fWritePrimary)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not WRITEPRIMARY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Unlock the device buffer.  Because we fail the call when the buffer is
    // lost (or out of focus), there's no need to notify the device buffer of
    // any state change.
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lose
 *
 *  Description:
 *      Flags the buffer as lost.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Lose"

HRESULT CDirectSoundPrimaryBuffer::Lose(void)
{
    DPF_ENTER();

    // We can only be lost if we're WRITEPRIMARY
    if(!(m_dwStatus & DSBSTATUS_BUFFERLOST) && m_fWritePrimary)
    {
        // Stop the buffer.  All lost buffers are stopped by definition.
        SetBufferState(VAD_BUFFERSTATE_STOPPED);

        // Give up WRITEPRIMARY access
        SetPriority(DSSCL_NONE);

        // Deactivate the buffer
        Activate(FALSE);

        // Flag the buffer as lost
        m_dwStatus |= DSBSTATUS_BUFFERLOST;
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Restore
 *
 *  Description:
 *      Attempts to restore a lost bufer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Restore"

HRESULT CDirectSoundPrimaryBuffer::Restore(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        // Are we still lost?
        if(DSBUFFERFOCUS_LOST == g_pDsAdmin->GetBufferFocusState(this))
        {
            hr = DSERR_BUFFERLOST;
        }

        // Remove the lost flag
        if(SUCCEEDED(hr))
        {
            m_dwStatus &= ~DSBSTATUS_BUFFERLOST;
        }

        // Reset the focus priority
        if(SUCCEEDED(hr))
        {
            hr = SetPriority(m_pDirectSound->m_dsclCooperativeLevel.dwPriority);
        }

        // Clean up
        if(FAILED(hr))
        {
            m_dwStatus |= DSBSTATUS_BUFFERLOST;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CDirectSoundSecondaryBuffer
 *
 *  Description:
 *      DirectSound secondary buffer object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: pointer to the parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::CDirectSoundSecondaryBuffer"

CDirectSoundSecondaryBuffer::CDirectSoundSecondaryBuffer(CDirectSound *pDirectSound)
    : CDirectSoundBuffer(pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundSecondaryBuffer);

    // Initialize/check defaults
    ASSERT(m_pImpDirectSoundBuffer == NULL);
    ASSERT(m_pImpDirectSoundNotify == NULL);
    ASSERT(m_pOwningSink == NULL);
    ASSERT(m_pDeviceBuffer == NULL);
    ASSERT(m_p3dBuffer == NULL);
    ASSERT(m_pPropertySet == NULL);
    ASSERT(m_fxChain == NULL);
    ASSERT(m_dwPriority == 0);
    ASSERT(m_dwVmPriority == 0);
    ASSERT(m_fMute == FALSE);
#ifdef FUTURE_MULTIPAN_SUPPORT
    ASSERT(m_dwChannelCount == 0);
    ASSERT(m_pdwChannels == NULL);
    ASSERT(m_plChannelVolumes == NULL);
#endif
    ASSERT(m_guidBufferID == GUID_NULL);
    ASSERT(m_dwAHLastGetPosTime == 0);
    ASSERT(m_dwAHCachedPlayPos == 0);
    ASSERT(m_dwAHCachedWritePos == 0);

    m_fCanStealResources = TRUE;
    m_hrInit = DSERR_UNINITIALIZED;
    m_hrPlay = DS_OK;
    m_playState = Stopped;
    m_dwSliceBegin = MAX_DWORD;
    m_dwSliceEnd = MAX_DWORD;

#ifdef ENABLE_PERFLOG
    // Initialize performance state if logging is enabled
    m_pPerfState = NULL;
    if (PerflogTracingEnabled())
    {
        m_pPerfState = NEW(BufferPerfState(this));
        // We don't mind if this allocation fails
    }
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundSecondaryBuffer
 *
 *  Description:
 *      DirectSound secondary buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::~CDirectSoundSecondaryBuffer"

CDirectSoundSecondaryBuffer::~CDirectSoundSecondaryBuffer(void)
{
    HRESULT                 hr;

    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBuffer);

    // If we're a MIXIN buffer, inform all our senders that we're going
    // away, and unregister with the streaming thread
    if ((m_dsbd.dwFlags & DSBCAPS_MIXIN) && SUCCEEDED(m_hrInit))
    {
        CNode<CDirectSoundSecondaryBuffer*>* pDsbNode;
        for (pDsbNode = m_pDirectSound->m_lstSecondaryBuffers.GetListHead(); pDsbNode; pDsbNode = pDsbNode->m_pNext)
            if (pDsbNode->m_data->HasFX())
                pDsbNode->m_data->m_fxChain->NotifyRelease(this);
        m_pStreamingThread->UnregisterMixBuffer(this);
    }

    // If we're a SINKIN buffer, unregister with our owning sink
    if (m_pOwningSink)
    {
        hr = m_pOwningSink->RemoveBuffer(this);
        ASSERT(SUCCEEDED(hr));
        RELEASE(m_pOwningSink);
    }

    // Release our FX chain, if we have one
    RELEASE(m_fxChain);

    // Make sure the buffer is stopped
    if(m_pDeviceBuffer)
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);
        ASSERT(SUCCEEDED(hr) || hr == DSERR_NODRIVER);
    }

    // Unregister with the parent object
    m_pDirectSound->m_lstSecondaryBuffers.RemoveDataFromList(this);

    // Free all interfaces
    DELETE(m_pImpDirectSoundNotify);
    DELETE(m_pImpDirectSoundBuffer);

    // Free owned objects
    ABSOLUTE_RELEASE(m_p3dBuffer);
    ABSOLUTE_RELEASE(m_pPropertySet);

    // Release the device buffer
    RELEASE(m_pDeviceBuffer);

    // Clean up memory
#ifdef FUTURE_MULTIPAN_SUPPORT
    MEMFREE(m_pdwChannels);
    MEMFREE(m_plChannelVolumes);
#endif

#ifdef ENABLE_PERFLOG
    DELETE(m_pPerfState);
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: buffer description.
 *      CDirectSoundBuffer * [in]: source buffer to duplicate from, or NULL
 *                                 to create a new buffer object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Initialize"

HRESULT CDirectSoundSecondaryBuffer::Initialize(LPCDSBUFFERDESC pDesc, CDirectSoundSecondaryBuffer *pSource)
{
#ifdef DEBUG
    const ULONG             ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG

    DSBUFFERFOCUS           bfFocus;
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);
    ASSERT(LXOR(pSource, pDesc));

    if(pDesc)
    {
        DPF(DPFLVL_MOREINFO, "dwFlags: 0x%8.8lX", pDesc->dwFlags);
        DPF(DPFLVL_MOREINFO, "dwBufferBytes: %lu", pDesc->dwBufferBytes);
        DPF(DPFLVL_MOREINFO, "dwReserved: %lu", pDesc->dwReserved);

        if(pDesc->lpwfxFormat)
        {
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->wFormatTag: %u", pDesc->lpwfxFormat->wFormatTag);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nChannels: %u", pDesc->lpwfxFormat->nChannels);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nSamplesPerSec: %lu", pDesc->lpwfxFormat->nSamplesPerSec);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nAvgBytesPerSec: %lu", pDesc->lpwfxFormat->nAvgBytesPerSec);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nBlockAlign: %u", pDesc->lpwfxFormat->nBlockAlign);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->wBitsPerSample: %u", pDesc->lpwfxFormat->wBitsPerSample);

            if(WAVE_FORMAT_PCM != pDesc->lpwfxFormat->wFormatTag)
            {
                DPF(DPFLVL_MOREINFO, "lpwfxFormat->cbSize: %u", pDesc->lpwfxFormat->cbSize);
            }
        }

        DPF(DPFLVL_MOREINFO, "guid3DAlgorithm: " DPF_GUID_STRING, DPF_GUID_VAL(pDesc->guid3DAlgorithm));
    }

    // Initialize the buffer
    hr = InitializeEmpty(pDesc, pSource);

    // Register with the parent object
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pDirectSound->m_lstSecondaryBuffers.AddNodeToList(this));
    }

    // Set default properties
    if(SUCCEEDED(hr))
    {
        if(pSource && (m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME) && DSBVOLUME_MAX != pSource->m_lVolume)
        {
            SetVolume(pSource->m_lVolume);
        }
        else
        {
            m_lVolume = DSBVOLUME_MAX;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(pSource && (m_dsbd.dwFlags & DSBCAPS_CTRLPAN) && DSBPAN_CENTER != pSource->m_lPan)
        {
            SetPan(pSource->m_lPan);
        }
        else
        {
            m_lPan = DSBPAN_CENTER;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(pSource && (m_dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY) && m_dsbd.lpwfxFormat->nSamplesPerSec != pSource->m_dwFrequency)
        {
            SetFrequency(pSource->m_dwFrequency);
        }
        else
        {
            m_dwFrequency = m_dsbd.lpwfxFormat->nSamplesPerSec;
        }
    }

    // Attempt to create the property set object
    if(SUCCEEDED(hr))
    {
        m_pPropertySet = NEW(CDirectSoundSecondaryBufferPropertySet(this));
        hr = HRFROMP(m_pPropertySet);

        if(SUCCEEDED(hr))
        {
            hr = m_pPropertySet->Initialize();
        }
    }

    // Attempt to create the 3D buffer
    if(SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_CTRL3D))
    {
        m_p3dBuffer = NEW(CDirectSound3dBuffer(this));
        hr = HRFROMP(m_p3dBuffer);

        if(SUCCEEDED(hr))
        {
            hr = m_p3dBuffer->Initialize(m_dsbd.guid3DAlgorithm, m_dsbd.dwFlags, m_dwFrequency, m_pDirectSound->m_pPrimaryBuffer->m_p3dListener, pSource ? pSource->m_p3dBuffer : NULL);
        }
    }

    // Handle any possible resource acquisitions
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetCaps(&vrbc);
    }

    // Manbug 36422: CEmSecondaryRenderWaveBuffer objects can return LOCSOFTWARE|LOCDEFER,
    // in which case we incorrectly acquired resources here for deferred emulated buffers.
    // Hence the "&& !(vrbc.dwFlags & DSBCAPS_LOCDEFER)" below.

    if(SUCCEEDED(hr) && (vrbc.dwFlags & DSBCAPS_LOCMASK) && !(vrbc.dwFlags & DSBCAPS_LOCDEFER))
    {
        hr = HandleResourceAcquisition(vrbc.dwFlags & DSBCAPS_LOCMASK);
    }

    // Register the interfaces with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundBuffer, this, &m_pImpDirectSoundBuffer);
    }

    if(SUCCEEDED(hr) && GetDsVersion() >= DSVERSION_DX8)
    {
        hr = RegisterInterface(IID_IDirectSoundBuffer8, m_pImpDirectSoundBuffer, m_pImpDirectSoundBuffer);
    }

    if(SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundNotify, this, &m_pImpDirectSoundNotify);
    }

    // Initialize focus state
    if(SUCCEEDED(hr))
    {
        bfFocus = g_pDsAdmin->GetBufferFocusState(this);

        switch(bfFocus)
        {
            case DSBUFFERFOCUS_INFOCUS:
                hr = Activate(TRUE);
                break;

            case DSBUFFERFOCUS_OUTOFFOCUS:
                hr = Activate(FALSE);
                break;

            case DSBUFFERFOCUS_LOST:
                hr = Lose();
                break;
        }
    }

    // If this is a MIXIN buffer, register it with the streaming thread
    if (SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_MIXIN))
    {
        m_pStreamingThread = GetStreamingThread();
        hr = HRFROMP(m_pStreamingThread);
        if (SUCCEEDED(hr))
        {
            hr = m_pStreamingThread->RegisterMixBuffer(this);
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {

#ifdef DEBUG
        if(IS_KS_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType))
        {
            DPF(DPFLVL_MOREINFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
        }
#endif // DEBUG

        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  InitializeEmpty
 *
 *  Description:
 *      Initializes a buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: buffer description.
 *      CDirectSoundBuffer * [in]: source buffer to duplicate from, or NULL
 *                                 to create a new buffer object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::InitializeEmpty"

HRESULT CDirectSoundSecondaryBuffer::InitializeEmpty(LPCDSBUFFERDESC pDesc, CDirectSoundSecondaryBuffer *pSource)
{
    BOOL                    fRealDuplicate  = FALSE;
    VADRBUFFERDESC          vrbd;
    HRESULT                 hr;

    DPF_ENTER();

    // Save buffer description
    if(pSource)
    {
        m_dwOriginalFlags = pSource->m_dwOriginalFlags;
        hr = CopyDsBufferDesc(&pSource->m_dsbd, &m_dsbd);

        // We're going to reset the flags back to those originally passed to
        // CreateSoundBuffer so that the duplicate buffer is created with
        // the same *requested* capabilities as the original.

        // COMPATCOMPAT: one side effect of doing this is that if the source buffer
        // is in hardware, but no location flags were specified when creating it,
        // any number of its duplicates may potentially live in software.  This
        // is new behavior as of version 5.0a.

        if(SUCCEEDED(hr))
        {
            m_dsbd.dwFlags = m_dwOriginalFlags;
        }
    }
    else
    {
        m_dwOriginalFlags = pDesc->dwFlags;
        hr = CopyDsBufferDesc(pDesc, &m_dsbd);
    }

    // Fill in any missing pieces
    if(SUCCEEDED(hr) && !pSource)
    {
        m_dsbd.dwBufferBytes = GetAlignedBufferSize(m_dsbd.lpwfxFormat, m_dsbd.dwBufferBytes);
    }

    // Include legacy Voice Manager stuff
    if(SUCCEEDED(hr) && DSPROPERTY_VMANAGER_MODE_DEFAULT != m_pDirectSound->m_vmmMode)
    {
        m_dsbd.dwFlags |= DSBCAPS_LOCDEFER;
    }

    // Attempt to duplicate the device buffer
    if(SUCCEEDED(hr) && pSource)
    {
        hr = pSource->m_pDeviceBuffer->Duplicate(&m_pDeviceBuffer);

        // If we failed to duplicate the buffer, and the source buffer's
        // original flags don't specify a location, fall back on software.
        fRealDuplicate = SUCCEEDED(hr);

        if(FAILED(hr) && !(pSource->m_dwOriginalFlags & DSBCAPS_LOCHARDWARE))
        {
            hr = DS_OK;
        }
    }

    // Attempt to create the device buffer
    if(SUCCEEDED(hr) && !m_pDeviceBuffer)
    {
        vrbd.dwFlags = m_dsbd.dwFlags;
        vrbd.dwBufferBytes = m_dsbd.dwBufferBytes;
        vrbd.pwfxFormat = m_dsbd.lpwfxFormat;
        vrbd.guid3dAlgorithm = m_dsbd.guid3DAlgorithm;

        hr = m_pDirectSound->m_pDevice->CreateSecondaryBuffer(&vrbd, m_pDirectSound, &m_pDeviceBuffer);
    }

    // Initialize the buffer data
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            if(!fRealDuplicate)
            {
                ASSERT(m_pDeviceBuffer->m_pSysMemBuffer->GetSize() == m_dsbd.dwBufferBytes);
                ASSERT(pSource->m_pDeviceBuffer->m_pSysMemBuffer->GetSize() == m_dsbd.dwBufferBytes);

                CopyMemory(GetWriteBuffer(), pSource->GetWriteBuffer(), m_dsbd.dwBufferBytes);
            }
        }
        else if(GetBufferType())  // If true, buffer is MIXIN or SINKIN (FIXME - does this simplify the sink?)
        {
            ClearWriteBuffer();
        }
        else
        {
#ifdef RDEBUG
            // Write some ugly noise into the buffer to catch remiss apps
            ::FillNoise(GetWriteBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);
#else // RDEBUG
            if(GetDsVersion() < DSVERSION_DX8)
            {
                // For apps written for DirectX 8 or later, we decided not to
                // waste time initializing all secondary buffers with silence.
                // They'll still be zeroed out by our memory allocator, though ;-)
                ClearWriteBuffer();
            }
#endif // RDEBUG
        }

        if(!pSource || !fRealDuplicate)
        {
            hr = CommitToDevice(0, m_dsbd.dwBufferBytes);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AttemptResourceAcquisition
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::AttemptResourceAcquisition"

HRESULT CDirectSoundSecondaryBuffer::AttemptResourceAcquisition(DWORD dwFlags)
{
    HRESULT                                 hr              = DSERR_INVALIDPARAM;
    CList<CDirectSoundSecondaryBuffer *>    lstBuffers;
    CNode<CDirectSoundSecondaryBuffer *> *  pNode;
    HRESULT                                 hrTemp;

    DPF_ENTER();
    ASSERT(m_pDeviceBuffer);

    if (m_dwStatus & DSBSTATUS_RESOURCESACQUIRED)
    {
        hr = DS_OK;
    }
    else
    {
        // Include legacy Voice Manager stuff
        if(DSPROPERTY_VMANAGER_MODE_DEFAULT != m_pDirectSound->m_vmmMode)
        {
            ASSERT(m_dsbd.dwFlags & DSBCAPS_LOCDEFER);
            ASSERT(!(dwFlags & DSBPLAY_LOCDEFERMASK));

            dwFlags &= ~DSBPLAY_LOCDEFERMASK;
            dwFlags |= DSBCAPStoDSBPLAY(m_dsbd.dwFlags);

            switch(m_pDirectSound->m_vmmMode)
            {
                case DSPROPERTY_VMANAGER_MODE_AUTO:
                    dwFlags |= DSBPLAY_TERMINATEBY_TIME;
                    break;

               case DSPROPERTY_VMANAGER_MODE_USER:
                    dwFlags |= DSBPLAY_TERMINATEBY_PRIORITY;
                    break;
            }
        }

        // Try to acquire resources.  If any of the TERMINATEBY flags were specified,
        // we'll need to try to explicitly acquire hardware resources, then attempt
        // to steal, then fall back on software.
        if(!(dwFlags & DSBPLAY_LOCSOFTWARE))
        {
            hr = AcquireResources(DSBCAPS_LOCHARDWARE);

            if(FAILED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_MASK))
            {
                hrTemp = GetResourceTheftCandidates(dwFlags & DSBPLAY_TERMINATEBY_MASK, &lstBuffers);
                if(SUCCEEDED(hrTemp))
                {
                    if(pNode = lstBuffers.GetListHead())
                        hr = StealResources(pNode->m_data);
                }
                else
                {
                    hr = hrTemp;
                }
            }
        }

        if(FAILED(hr) && !(dwFlags & DSBPLAY_LOCHARDWARE))
        {
            hr = AcquireResources(DSBCAPS_LOCSOFTWARE);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      DWORD [in]: buffer location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::AcquireResources"

HRESULT CDirectSoundSecondaryBuffer::AcquireResources(DWORD dwFlags)
{
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);
    ASSERT(!(m_dwStatus & DSBSTATUS_RESOURCESACQUIRED));

    hr = m_pDeviceBuffer->GetCaps(&vrbc);

    if(SUCCEEDED(hr))
    {
        if(!(vrbc.dwFlags & DSBCAPS_LOCMASK))
        {
            // Try to acquire the device buffer
            hr = m_pDeviceBuffer->AcquireResources(dwFlags);
        }
        else if((dwFlags & DSBCAPS_LOCMASK) != (vrbc.dwFlags & DSBCAPS_LOCMASK))
        {
            hr = DSERR_INVALIDCALL;
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has acquired resources at 0x%p", this, m_pDeviceBuffer);
        hr = CommitToDevice(0, m_dsbd.dwBufferBytes);

        // Handle the resource acquisition
        if(SUCCEEDED(hr))
        {
            hr = HandleResourceAcquisition(vrbc.dwFlags & DSBCAPS_LOCMASK);
        }

        if (FAILED(hr))
        {
            // Free any resources acquired so far
            HRESULT hrTemp = FreeResources(FALSE);

            ASSERT(SUCCEEDED(hrTemp));  // Not much we can do if this fails
        }            
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  StealResources
 *
 *  Description:
 *      Steals hardware resources from another buffer.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer * [in]: buffer to steal from.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::StealResources"

HRESULT CDirectSoundSecondaryBuffer::StealResources(CDirectSoundSecondaryBuffer *pSource)
{
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hrTemp;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);
    ASSERT(!(m_dwStatus & DSBSTATUS_RESOURCESACQUIRED));

    DPF(DPFLVL_INFO, "Stealing resources from buffer at 0x%p", pSource);

    ASSERT(pSource->m_dwStatus & DSBSTATUS_RESOURCESACQUIRED);

    // Get the buffer location
    hr = pSource->m_pDeviceBuffer->GetCaps(&vrbc);

    if(SUCCEEDED(hr))
    {
        ASSERT(vrbc.dwFlags & DSBCAPS_LOCHARDWARE);
    }

    // Steal hardware resources
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->StealResources(pSource->m_pDeviceBuffer);
    }

    if(SUCCEEDED(hr))
    {
        // Free the source buffer's resources (since they're now our resources).
        hr = pSource->FreeResources(TRUE);

        if(SUCCEEDED(hr))
        {
            hr = CommitToDevice(0, m_dsbd.dwBufferBytes);
        }

        // Handle the resource acquisition
        if(SUCCEEDED(hr))
        {
            hr = HandleResourceAcquisition(vrbc.dwFlags & DSBCAPS_LOCMASK);
        }

    }
    else if(DSERR_UNSUPPORTED == hr)
    {
        // The device buffer doesn't support resource theft.  Free the
        // source buffer's resources and try to acquire our own.
        hr = pSource->FreeResources(TRUE);

        if(SUCCEEDED(hr))
        {
            hr = AcquireResources(DSBCAPS_LOCHARDWARE);

            // Try to reacquire the source buffer's resources
            if(FAILED(hr))
            {
                hrTemp = pSource->AcquireResources(DSBCAPS_LOCHARDWARE);

                if(FAILED(hrTemp))
                {
                    RPF(DPFLVL_ERROR, "Unable to reacquire hardware resources!");
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetResourceTheftCandidates
 *
 *  Description:
 *      Finds objects that are available to have their resources stolen.
 *
 *  Arguments:
 *      CList * [out]: destination list.
 *      DWORD [in]: TERMINATEBY flags.  If none are specified, all
 *                  compatible buffers are added to the list.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetResourceTheftCandidates"

HRESULT CDirectSoundSecondaryBuffer::GetResourceTheftCandidates(DWORD dwFlags, CList<CDirectSoundSecondaryBuffer *> *plstDest)
{
    HRESULT                                 hr              = DS_OK;
    CNode<CDirectSoundSecondaryBuffer *> *  pNode;
    CNode<CDirectSoundSecondaryBuffer *> *  pNext;
    CDirectSoundSecondaryBuffer *           pTimeBuffer;
    DWORD                                   dwStatus;
    DWORD                                   dwMinPriority;
    DWORD                                   dwPriority;
    DWORD                                   cbMinRemain;
    DWORD                                   cbRemain;
    COMPAREBUFFER                           cmp[2];

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);

    // First, find all compatible buffers
    for(pNode = m_pDirectSound->m_lstSecondaryBuffers.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        // We never want to look at ourselves.  It's just sick.
        if(this == pNode->m_data)
        {
            continue;
        }

        // We can only steal from LOCDEFER buffers
        if(!(pNode->m_data->m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
        {
            continue;
        }

        // This flag prevents us from stealing resources from buffers that have
        // just called UserAcquireResources() and haven't called Play() yet
        if(!pNode->m_data->m_fCanStealResources)
        {
            continue;
        }

        // Make sure the object actually has some hardware resources
        hr = pNode->m_data->GetStatus(&dwStatus);

        if(FAILED(hr))
        {
            break;
        }

        if(!(dwStatus & DSBSTATUS_LOCHARDWARE))
        {
            continue;
        }

        // Compare the buffer properties
        cmp[0].dwFlags = m_dsbd.dwFlags;
        cmp[0].pwfxFormat = m_dsbd.lpwfxFormat;
        cmp[0].guid3dAlgorithm = m_dsbd.guid3DAlgorithm;

        cmp[1].dwFlags = pNode->m_data->m_dsbd.dwFlags;
        cmp[1].pwfxFormat = pNode->m_data->m_dsbd.lpwfxFormat;
        cmp[1].guid3dAlgorithm = pNode->m_data->m_dsbd.guid3DAlgorithm;

        if(!CompareBufferProperties(&cmp[0], &cmp[1]))
        {
            continue;
        }

        hr = HRFROMP(plstDest->AddNodeToList(pNode->m_data));
        if (FAILED(hr))
        {
            break;
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Found %lu compatible buffers", plstDest->GetNodeCount());
    }

    // Remove all buffers that are > the lowest priority
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_PRIORITY))
    {
        dwMinPriority = GetBufferPriority();

        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            dwPriority = pNode->m_data->GetBufferPriority();

            if(dwPriority < dwMinPriority)
            {
                dwMinPriority = dwPriority;
            }
        }

        pNode = plstDest->GetListHead();

        while(pNode)
        {
            pNext = pNode->m_pNext;

            dwPriority = pNode->m_data->GetBufferPriority();

            if(dwPriority > dwMinPriority)
            {
                plstDest->RemoveNodeFromList(pNode);
            }

            pNode = pNext;
        }

#ifdef DEBUG
        DPF(DPFLVL_MOREINFO, "%lu buffers passed the priority test", plstDest->GetNodeCount());
        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has priority %lu", pNode->m_data, pNode->m_data->GetBufferPriority());
        }
#endif // DEBUG

    }

    // Remove any buffers that aren't at max distance
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE))
    {
        pNode = plstDest->GetListHead();

        while(pNode)
        {
            pNext = pNode->m_pNext;

            if(!pNode->m_data->m_p3dBuffer || !pNode->m_data->m_p3dBuffer->m_pWrapper3dObject->IsAtMaxDistance())
            {
                plstDest->RemoveNodeFromList(pNode);
            }

            pNode = pNext;
        }

#ifdef DEBUG
        DPF(DPFLVL_MOREINFO, "%lu buffers passed the distance test", plstDest->GetNodeCount());
        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p is at max distance", pNode->m_data);
        }
#endif // DEBUG

    }

    // Find the buffer with the least amount of time remaining
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_TIME))
    {
        cbMinRemain = MAX_DWORD;
        pTimeBuffer = NULL;

        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            hr = pNode->m_data->GetPlayTimeRemaining(&cbRemain);

            if(FAILED(hr))
            {
                break;
            }

            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has %lu bytes remaining", pNode->m_data, cbRemain);

            if(cbRemain < cbMinRemain)
            {
                cbMinRemain = cbRemain;
                pTimeBuffer = pNode->m_data;
            }
        }

        if(SUCCEEDED(hr))
        {
            plstDest->RemoveAllNodesFromList();

            if(pTimeBuffer)
            {
                hr = HRFROMP(plstDest->AddNodeToList(pTimeBuffer));
            }

            DPF(DPFLVL_MOREINFO, "%lu buffers passed the time test", plstDest->GetNodeCount());
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPlayTimeRemaining
 *
 *  Description:
 *      Gets the amount of time the buffer has remaining before stopping.
 *
 *  Arguments:
 *      LPDWORD [out]: receives time (in bytes).
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetPlayTimeRemaining"

HRESULT CDirectSoundSecondaryBuffer::GetPlayTimeRemaining(LPDWORD pdwRemain)
{
    DWORD                   dwRemain    = MAX_DWORD;
    HRESULT                 hr          = DS_OK;
    DWORD                   dwPlay;

    DPF_ENTER();

    if(!(m_dwStatus & DSBSTATUS_LOOPING))
    {
        hr = GetCurrentPosition(&dwPlay, NULL);

        if(SUCCEEDED(hr))
        {
            dwRemain = m_dsbd.dwBufferBytes - dwPlay;
        }
    }

    if(SUCCEEDED(hr))
    {
        *pdwRemain = dwRemain;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees hardware resources.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if the buffer has been terminated as a result of
 *                 resources being stolen.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::FreeResources"

HRESULT CDirectSoundSecondaryBuffer::FreeResources(BOOL fTerminate)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);

    // Make sure the buffer is stopped
    hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);

    // Free owned objects' resources
    if(SUCCEEDED(hr) && m_p3dBuffer)
    {
        hr = m_p3dBuffer->FreeResources();
    }

    if(SUCCEEDED(hr) && m_pPropertySet)
    {
        hr = m_pPropertySet->FreeResources();
    }

    // Free the device buffer's resources
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->FreeResources();
    }

    // Resources have been freed
    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has freed its resources", this);
        m_dwStatus &= ~DSBSTATUS_RESOURCESACQUIRED;
    }

    // If resources were freed as a result of a termination, update
    // the status.
    if(SUCCEEDED(hr) && fTerminate)
    {
        m_dwStatus |= DSBSTATUS_TERMINATED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HandleResourceAcquisition
 *
 *  Description:
 *      Handles acquisition of hardware resources.
 *
 *  Arguments:
 *      DWORD [in]: location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::HandleResourceAcquisition"

HRESULT CDirectSoundSecondaryBuffer::HandleResourceAcquisition(DWORD dwFlags)
{
    HRESULT                 hr  = S_OK;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);

    // Acquire 3D resources
    if(SUCCEEDED(hr) && m_p3dBuffer)
    {
        hr = m_p3dBuffer->AcquireResources(m_pDeviceBuffer);
    }

    // Acquire property set resources.  It's OK if this fails.
    if(SUCCEEDED(hr) && m_pPropertySet)
    {
        m_pPropertySet->AcquireResources(m_pDeviceBuffer);
    }

    // Acquire effect handling resources if necessary
    if(SUCCEEDED(hr) && HasFX())
    {
        hr = m_fxChain->AcquireFxResources();
    }

    // Resources have been acquired
    if(SUCCEEDED(hr))
    {
        m_dwStatus |= DSBSTATUS_RESOURCESACQUIRED;
    }

    // If the buffer was created *without* LOCDEFER, the caps must reflect
    // the location.  If the buffer was create *with* LOCDEFER, the caps
    // will never reflect anything other than that; call GetStatus instead.
    if(SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        m_dsbd.dwFlags |= dwFlags & DSBCAPS_LOCMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Queries capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetCaps"

HRESULT CDirectSoundSecondaryBuffer::GetCaps(LPDSBCAPS pDsbCaps)
{
    DPF_ENTER();

    ASSERT(sizeof(DSBCAPS) == pDsbCaps->dwSize);

    if(m_dsbd.dwFlags & DSBCAPS_LOCDEFER)
    {
        ASSERT(!(m_dsbd.dwFlags & DSBCAPS_LOCMASK));
    }
    else
    {
        ASSERT(LXOR(m_dsbd.dwFlags & DSBCAPS_LOCSOFTWARE, m_dsbd.dwFlags & DSBCAPS_LOCHARDWARE));
    }

    pDsbCaps->dwFlags = m_dsbd.dwFlags & DSBCAPS_VALIDFLAGS;  // Remove any special internal flags (e.g. DSBCAPS_SINKIN)
    pDsbCaps->dwBufferBytes = GetBufferType() ? 0 : m_dsbd.dwBufferBytes;  // Shouldn't report internal size of sink/MIXIN buffers
    pDsbCaps->dwUnlockTransferRate = 0;
    pDsbCaps->dwPlayCpuOverhead = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: size of the format structure.  On entry, this
 *                        must be initialized to the size of the structure.
 *                        On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetFormat"

HRESULT CDirectSoundSecondaryBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    hr = CopyWfxApi(m_dsbd.lpwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the format for a given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFormat"

HRESULT CDirectSoundSecondaryBuffer::SetFormat(LPCWAVEFORMATEX pwfxFormat)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Secondary buffers don't support SetFormat");

    DPF_LEAVE_HRESULT(DSERR_INVALIDCALL);

    return DSERR_INVALIDCALL;
}


/***************************************************************************
 *
 *  GetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetFrequency"

HRESULT CDirectSoundSecondaryBuffer::GetFrequency(LPDWORD pdwFrequency)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLFREQUENCY");
        hr = DSERR_CONTROLUNAVAIL;
    }

    if(SUCCEEDED(hr))
    {
        *pdwFrequency = m_dwFrequency;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the frequency for the given buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFrequency"

HRESULT CDirectSoundSecondaryBuffer::SetFrequency(DWORD dwFrequency)
{
    BOOL                    fContinue   = TRUE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLFREQUENCY");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Handle default frequency
    if(SUCCEEDED(hr) && DSBFREQUENCY_ORIGINAL == dwFrequency)
    {
        dwFrequency = m_dsbd.lpwfxFormat->nSamplesPerSec;
    }

    // Validate the frequency
    if(SUCCEEDED(hr) && (dwFrequency < DSBFREQUENCY_MIN || dwFrequency > DSBFREQUENCY_MAX))
    {
        RPF(DPFLVL_ERROR, "Specified invalid frequency %lu (valid range is %lu to %lu)", dwFrequency, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);
        hr = DSERR_INVALIDPARAM;
    }

    // Only set the frequency if it's changed
    if(SUCCEEDED(hr) && dwFrequency == m_dwFrequency)
    {
        fContinue = FALSE;
    }

    // Update the 3D object
    if(SUCCEEDED(hr) && m_p3dBuffer && fContinue)
    {
        hr = m_p3dBuffer->SetFrequency(dwFrequency, &fContinue);
    }

    // Update the device buffer
    if(SUCCEEDED(hr) && fContinue)
    {
        hr = m_pDeviceBuffer->SetBufferFrequency(dwFrequency);
    }

    // Update our local copy
    if(SUCCEEDED(hr))
    {
        m_dwFrequency = dwFrequency;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPan
 *
 *  Description:
 *      Retrieves pan for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetPan"

HRESULT CDirectSoundSecondaryBuffer::GetPan(LPLONG plPan)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    if(SUCCEEDED(hr))
    {
        *plPan = m_lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetPan"

HRESULT CDirectSoundSecondaryBuffer::SetPan(LONG lPan)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set the pan if it has changed
    if(SUCCEEDED(hr) && lPan != m_lPan)
    {
        hr = SetAttenuation(m_lVolume, lPan);

        // Update our local copy
        if(SUCCEEDED(hr))
        {
            m_lPan = lPan;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Retrieves volume for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVolume"

HRESULT CDirectSoundSecondaryBuffer::GetVolume(LPLONG plVolume)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    if(SUCCEEDED(hr))
    {
        *plVolume = m_lVolume;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the volume for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetVolume"

HRESULT CDirectSoundSecondaryBuffer::SetVolume(LONG lVolume)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set the volume if it has changed
    if(SUCCEEDED(hr) && lVolume != m_lVolume)
    {
#ifdef FUTURE_MULTIPAN_SUPPORT
        if (m_dsbd.dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
        {
            hr = m_pDeviceBuffer->SetChannelAttenuations(lVolume, m_dwChannelCount, m_pdwChannels, m_plChannelVolumes);
        }
        else
#endif
        {
            hr = SetAttenuation(lVolume, m_lPan);
        }

        // Update our local copy
        if(SUCCEEDED(hr))
        {
            m_lVolume = lVolume;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAttenuation
 *
 *  Description:
 *      Obtains the buffer's true current attenuation, after 3D processing
 *      (unlike GetVolume, which returns the last volume set by the app).
 *
 *  Arguments:
 *      FLOAT* [out]: attenuation in millibels.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetAttenuation"

HRESULT CDirectSoundSecondaryBuffer::GetAttenuation(FLOAT* pfAttenuation)
{
    DPF_ENTER();

    // FIXME: this function needs to obtain the buffer's true attenuation
    // (i.e. the attenuation set via SetVolume() plus the extra attenuation
    // caused by DS3D processing).  Unfortunately we don't have a method in
    // our device buffer class hierarchy (vad.h - CRenderWaveBuffer et al)
    // to obtain a buffer's attenuation.  And the code in ds3d.cpp doesn't
    // explicitly save this info either (it just passes it along to the 3D
    // object implemenation - which in some cases is external to dsound,
    // e.g. ks3d.cpp).
    //
    // So we have two options:
    //
    // - Add a GetVolume() to the CSecondaryRenderWaveBuffer hierarchy;
    //   In some cases it can read the volume directly off the buffer
    //   (e.g. for KS buffers); in others (e.g. VxD buffers) the DDI
    //   doesn't provide for that, so we'd have to remember the last
    //   successfully set volume and return that (this last may be the
    //   best implementation; in fact it may be possibly to do it just
    //   once, in the base class).
    //
    // - Make the C3dObject hierarchy do attenuation calculations for
    //   all 3d objects (even KS ones that don't require it), and save
    //   the result.
    //
    // The first option looks much easier.
    // (MANBUG 39130 - POSTPONED TO DX8.1)
    
    HRESULT hr = DS_OK;
    *pfAttenuation = 0.0f;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the volume and pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetAttenuation"

HRESULT CDirectSoundSecondaryBuffer::SetAttenuation(LONG lVolume, LONG lPan)
{
    BOOL                    fContinue   = TRUE;
    HRESULT                 hr          = DS_OK;
    DSVOLUMEPAN             dsvp;

    DPF_ENTER();

    // Calculate the attenuation based on the volume and pan
    if(SUCCEEDED(hr) && fContinue)
    {
        FillDsVolumePan(lVolume, lPan, &dsvp);
    }

    // Update the 3D object
    if(SUCCEEDED(hr) && m_p3dBuffer && fContinue)
    {
        hr = m_p3dBuffer->SetAttenuation(&dsvp, &fContinue);
    }

    // Update the device buffer
    if(SUCCEEDED(hr) && fContinue)
    {
        hr = m_pDeviceBuffer->SetAttenuation(&dsvp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetNotificationPositions"

HRESULT CDirectSoundSecondaryBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    HRESULT                 hr              = DS_OK;
    LPDSBPOSITIONNOTIFY     paNotesOrdered  = NULL;
    DWORD                   dwState;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPOSITIONNOTIFY");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Validate notifications
    if(SUCCEEDED(hr))
    {
        hr = ValidateNotificationPositions(m_dsbd.dwBufferBytes, dwCount, paNotes, m_dsbd.lpwfxFormat->nBlockAlign, &paNotesOrdered);
    }

    // We must be stopped in order to set notification positions
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr) && dwState & VAD_BUFFERSTATE_STARTED)
        {
            RPF(DPFLVL_ERROR, "Buffer must be stopped before setting notification positions");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set notifications
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->SetNotificationPositions(dwCount, paNotesOrdered);
    }

    MEMFREE(paNotesOrdered);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetOwningSink
 *
 *  Description:
 *      Sets the owning CDirectSoundSink object for this buffer.
 *
 *  Arguments:
 *      CDirectSoundSink * [in]: The new the owning sink object.
 *
 *  Returns:
 *      void 
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetOwningSink"

void CDirectSoundSecondaryBuffer::SetOwningSink(CDirectSoundSink* pOwningSink)
{
    DPF_ENTER();

    ASSERT(m_dsbd.dwFlags & DSBCAPS_SINKIN);
    ASSERT(m_pOwningSink == NULL);
    CHECK_WRITE_PTR(pOwningSink);

    m_pOwningSink = pOwningSink;
    m_pOwningSink->AddRef();

    m_pDeviceBuffer->SetOwningSink(pOwningSink);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetCurrentPosition"

HRESULT CDirectSoundSecondaryBuffer::GetCurrentPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwPlay;
    DWORD                   dwWrite;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "GetCurrentPosition() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // We save the position to local variables so that the object we're
    // calling into doesn't have to worry about whether one or both of
    // the arguments are NULL.
    if(SUCCEEDED(hr))
    {
        if( m_pDirectSound->m_ahAppHacks.vdtCachePositions & m_pDirectSound->m_pDevice->m_vdtDeviceType )
        {
            // App hack for Furby calling GetCurrentPosition every .5ms on multiple buffers which stresses NT/WDM systems
            DWORD dwNow = timeGetTime();
            if( m_dwAHLastGetPosTime > 0 && 
                dwNow >= m_dwAHLastGetPosTime &&   // catch unlikely wrap-around and '=' because of 5ms accuracy of timeGetTime()
                dwNow - m_dwAHLastGetPosTime < 5 ) // 5ms tolerance
            {
                dwPlay  = m_dwAHCachedPlayPos;
                dwWrite = m_dwAHCachedWritePos;
            }
            else
            {
                hr = m_pDeviceBuffer->GetCursorPosition(&dwPlay, &dwWrite);
                m_dwAHCachedPlayPos  = dwPlay;
                m_dwAHCachedWritePos = dwWrite;
            }
            m_dwAHLastGetPosTime = dwNow;
        }
        else
        {
            hr = m_pDeviceBuffer->GetCursorPosition(&dwPlay, &dwWrite);
        }
    }

    // Block-align the positions
    if(SUCCEEDED(hr))
    {
        dwPlay = BLOCKALIGN(dwPlay, m_dsbd.lpwfxFormat->nBlockAlign);
        dwWrite = BLOCKALIGN(dwWrite, m_dsbd.lpwfxFormat->nBlockAlign);
    }

    // Apply app-hacks and cursor adjustments
    if(SUCCEEDED(hr))
    {
        // If the buffer has effects, we return the FX cursor as the write cursor
        if(HasFX())
        {
            DWORD dwDistance = BytesToMs(DISTANCE(dwWrite, m_dwSliceEnd, GetBufferSize()), Format());
            if (dwDistance > 200)
                DPF(DPFLVL_WARNING, "FX cursor suspiciously far ahead of write cursor (%ld ms)", dwDistance);
            else
                dwWrite = m_dwSliceEnd;  // FIXME: may not always be valid
        }

        if (m_pDirectSound->m_ahAppHacks.lCursorPad)
        {
            dwPlay = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
            dwWrite = PadCursor(dwWrite, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
        }

        if(m_pDirectSound->m_ahAppHacks.vdtReturnWritePos & m_pDirectSound->m_pDevice->m_vdtDeviceType)
        {
            dwPlay = dwWrite;
        }

        if(m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.fEnable)
        {
            dwWrite = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.lCursorPad);
        }
    }

    // Success
    if(SUCCEEDED(hr) && pdwPlay)
    {
        *pdwPlay = dwPlay;
    }

    if(SUCCEEDED(hr) && pdwWrite)
    {
        *pdwWrite = dwWrite;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play position for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetCurrentPosition"

HRESULT CDirectSoundSecondaryBuffer::SetCurrentPosition(DWORD dwPlay)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "SetCurrentPosition() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check the cursor position
    if(SUCCEEDED(hr) && dwPlay >= m_dsbd.dwBufferBytes)
    {
        RPF(DPFLVL_ERROR, "Cursor position out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    // Make sure dwPlay is block-aligned
    if(SUCCEEDED(hr))
    {
        dwPlay = BLOCKALIGN(dwPlay, m_dsbd.lpwfxFormat->nBlockAlign);
    }

    // Prime the effects chain for the new play position
    if(SUCCEEDED(hr) && HasFX())
    {
        hr = m_fxChain->PreRollFx(dwPlay);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->SetCursorPosition(dwPlay);
    }

    // Mark the play state as stopped to force the streaming thread
    // to react to our new cursor position
    if(SUCCEEDED(hr))
    {
        m_playState = Stopped;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetStatus"

HRESULT CDirectSoundSecondaryBuffer::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                 hr          = DS_OK;
    DWORD                   dwStatus;
    DWORD                   dwState;
    VADRBUFFERCAPS          vrbc;

    DPF_ENTER();

    // Update the buffer status.  If we're lost, that's the only state we care about
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        dwStatus = DSBSTATUS_BUFFERLOST;
    }
    else
    {
        // Get the current device buffer state
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
            UpdateBufferStatusFlags(dwState, &m_dwStatus);
        
            // If we thought we were playing, but now we're stopped, handle
            // the transition.
            if((dwStatus & DSBSTATUS_PLAYING) && !(m_dwStatus & DSBSTATUS_PLAYING))
            {
                hr = Stop();
            }
        }

        // Fill in the buffer location
        if(SUCCEEDED(hr))
        {
            m_dwStatus &= ~DSBSTATUS_LOCMASK;

            if(m_dwStatus & DSBSTATUS_RESOURCESACQUIRED)
            {
                hr = m_pDeviceBuffer->GetCaps(&vrbc);

                if(SUCCEEDED(hr))
                {
                    m_dwStatus |= DSBCAPStoDSBSTATUS(vrbc.dwFlags);
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
        }
    }

    // Mask off bits that shouldn't get back to the app
    if(SUCCEEDED(hr))
    {
        dwStatus &= DSBSTATUS_USERMASK;
    }

    if(SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        dwStatus &= ~DSBSTATUS_LOCDEFERMASK;
    }

    if(SUCCEEDED(hr) && pdwStatus)
    {
        *pdwStatus = dwStatus;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: priority.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Play"

HRESULT CDirectSoundSecondaryBuffer::Play(DWORD dwPriority, DWORD dwFlags)
{
#ifdef DEBUG
    const ULONG             ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG

    DWORD                   dwState = VAD_BUFFERSTATE_STARTED;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // Make sure cooperative level has been set
    if(SUCCEEDED(hr) && (!m_pDirectSound->m_dsclCooperativeLevel.dwThreadId || DSSCL_NONE == m_pDirectSound->m_dsclCooperativeLevel.dwPriority))
    {
        RPF(DPFLVL_ERROR, "Cooperative level must be set before calling Play");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Priority is only valid if we're LOCDEFER
    if(SUCCEEDED(hr) && dwPriority && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        RPF(DPFLVL_ERROR, "Priority is only valid on LOCDEFER buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // Validate flags
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_LOCDEFERMASK) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        RPF(DPFLVL_ERROR, "Specified a flag that is only valid on LOCDEFER buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // For MIXIN/sink buffers, the DSBPLAY_LOOPING flag is mandatory
    if(SUCCEEDED(hr) && GetBufferType() && !(dwFlags & DSBPLAY_LOOPING))
    {
        RPF(DPFLVL_ERROR, "The LOOPING flag must always be set for MIXIN/sink buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Refresh the current buffer status
    if(SUCCEEDED(hr))
    {
        hr = GetStatus(NULL);
    }

    // Set buffer priority
    if(SUCCEEDED(hr))
    {
        m_dwPriority = dwPriority;
    }

    // Reset the special success code
    m_pDeviceBuffer->m_hrSuccessCode = DS_OK;

    // Make sure resources have been acquired
    if(SUCCEEDED(hr))
    {
        hr = AttemptResourceAcquisition(dwFlags);
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        if(dwFlags & DSBPLAY_LOOPING)
        {
            dwState |= VAD_BUFFERSTATE_LOOPING;
        }

        hr = SetBufferState(dwState);
    }

    if(SUCCEEDED(hr))
    {
        // If the buffer was previously terminated, remove the flag from the status
        m_dwStatus &= ~DSBSTATUS_TERMINATED;

        // Make it possible to steal this buffer's resources
        m_fCanStealResources = TRUE;
    }

    // Save the result code
    m_hrPlay = hr;

#ifdef DEBUG
    if(IS_KS_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType))
    {
        DPF(DPFLVL_INFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
    }
#endif // DEBUG

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops playing the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Stop"

HRESULT CDirectSoundSecondaryBuffer::Stop(void)
{
#ifdef DEBUG
    const ULONG             ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG

    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

#ifdef ENABLE_PERFLOG
    // Check if there were any glitches
    if (m_pPerfState)
    {
        m_pPerfState->OnUnlockBuffer(0, GetBufferSize());
    }
#endif

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);
    }

    // If we're LOCDEFER and the buffer is stopped, resources can be freed
    if(SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_LOCDEFER) && (m_dwStatus & DSBSTATUS_RESOURCESACQUIRED))
    {
        hr = FreeResources(FALSE);
    }

#ifdef DEBUG
    if(IS_KS_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType))
    {
        DPF(DPFLVL_MOREINFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
    }
#endif // DEBUG

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetBufferState
 *
 *  Description:
 *      Sets the buffer play/stop state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetBufferState"

HRESULT CDirectSoundSecondaryBuffer::SetBufferState(DWORD dwNewState)
{
    DWORD                   dwOldState;
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDeviceBuffer->GetState(&dwOldState);

    if(SUCCEEDED(hr) && dwNewState != dwOldState)
    {
        // Our state is changing; reset the performance tracing state
        #ifdef ENABLE_PERFLOG
        if (PerflogTracingEnabled())
        {
            if (!m_pPerfState)
                m_pPerfState = NEW(BufferPerfState(this));
            if (m_pPerfState) 
                m_pPerfState->Reset();
        }
        #endif

        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p going from %s to %s", this, StateName(dwOldState), StateName(dwNewState));

        hr = m_pDeviceBuffer->SetState(dwNewState);

        if (SUCCEEDED(hr) && HasSink())
        {
            #ifdef FUTURE_WAVE_SUPPORT
            if ((m_dsbd.dwFlags & DSBCAPS_FROMWAVEOBJECT) && (dwNewState & VAD_BUFFERSTATE_STARTED))
                hr = m_pOwningSink->Activate(TRUE);

            // FIXME: maybe this activation should be handled by the sink
            // itself in SetBufferState() below, so it can also take care
            // of deactivation when it runs out of active clients

            if (SUCCEEDED(hr))
            #endif // FUTURE_WAVE_SUPPORT

            hr = m_pOwningSink->SetBufferState(this, dwNewState, dwOldState);
        }

        if (SUCCEEDED(hr) && HasFX())
            hr = m_fxChain->NotifyState(dwNewState);

        // If a MIXIN or SINKIN buffer is stopping, clear it and set its position to 0
        if (SUCCEEDED(hr) && GetBufferType() && !(dwNewState & VAD_BUFFERSTATE_STARTED))
        {
            ClearWriteBuffer();  // FIXME - does this simplify the sink?
            ClearPlayBuffer();
            m_pDeviceBuffer->SetCursorPosition(0);
            m_playState = Stopped;  // This stops FX processing on this buffer,
                                    // and forces the streaming thread to reset
                                    // our current slice next time it wakes up
            m_dwSliceBegin = m_dwSliceEnd = MAX_DWORD;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Activate
 *
 *  Description:
 *      Activates or deactivates the buffer object.
 *
 *  Arguments:
 *      BOOL [in]: Activation state.  TRUE to activate, FALSE to deactivate.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Activate"

HRESULT CDirectSoundSecondaryBuffer::Activate(BOOL fActive)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = SetMute(!fActive);

    if(SUCCEEDED(hr))
    {
        if(fActive)
        {
            m_dwStatus |= DSBSTATUS_ACTIVE;

            // If we're a MIXIN or SINKIN buffer, we have to clear our lost
            // status (since the app can't call Restore() to do it for us)
            if (GetBufferType())
            {
                // If the buffer was playing before it got lost, restart it
                if (m_dwStatus & DSBSTATUS_STOPPEDBYFOCUS)
                    hr = SetBufferState(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);

                // Clear our BUFFERLOST and STOPPEDBYFOCUS status flags
                m_dwStatus &= ~(DSBSTATUS_BUFFERLOST | DSBSTATUS_STOPPEDBYFOCUS);
            }
        }
        else
        {
            m_dwStatus &= ~DSBSTATUS_ACTIVE;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: Mute state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetMute"

HRESULT CDirectSoundSecondaryBuffer::SetMute(BOOL fMute)
{
    BOOL                    fContinue   = TRUE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    // Only set the mute status if it's changed
    if(SUCCEEDED(hr) && fMute == m_fMute)
    {
        fContinue = FALSE;
    }

    // Update the 3D object
    if(SUCCEEDED(hr) && m_p3dBuffer && fContinue)
    {
        hr = m_p3dBuffer->SetMute(fMute, &fContinue);
    }

    // Update the device buffer
    if(SUCCEEDED(hr) && fContinue)
    {
        hr = m_pDeviceBuffer->SetMute(fMute);
    }

    // Update our local copy
    if(SUCCEEDED(hr))
    {
        m_fMute = fMute;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for writing.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     ppvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the ppvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr2 parameter. If
 *                     ppvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: locking flags
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Lock"

HRESULT CDirectSoundSecondaryBuffer::Lock(DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Lock() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Handle flags
    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_FROMWRITECURSOR))
    {
        hr = GetCurrentPosition(NULL, &dwWriteCursor);
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_ENTIREBUFFER))
    {
        dwWriteBytes = m_dsbd.dwBufferBytes;
    }

    // Cursor validation
    if(SUCCEEDED(hr) && dwWriteCursor >= m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_FROMWRITECURSOR));

        RPF(DPFLVL_ERROR, "Write cursor past buffer end");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwWriteBytes > m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size larger than buffer size");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !dwWriteBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size must be > 0");
        hr = DSERR_INVALIDPARAM;
    }

    // Lock the device buffer
    if(SUCCEEDED(hr))
    {
        if (GetDsVersion() >= DSVERSION_DX8)
        {
            // DX8 removes support for apps that lock their buffers
            // and never bother to unlock them again (see the comment
            // in CVxdSecondaryRenderWaveBuffer::Lock for explanation)
            hr = DirectLock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
        }
        else    
        {
            hr = m_pDeviceBuffer->Lock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Unlock"

HRESULT CDirectSoundSecondaryBuffer::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Unlock() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Unlock the device buffer
    if(SUCCEEDED(hr))
    {
        if (GetDsVersion() >= DSVERSION_DX8)
        {
            // DX8 removes support for apps that lock their buffers
            // and never bother to unlock them again (see the comment
            // in CVxdSecondaryRenderWaveBuffer::Lock for explanation)
            hr = DirectUnlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
        }
        else
        {
            hr = m_pDeviceBuffer->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
        }
    }

    // Update the processed FX buffer if necessary
    if(SUCCEEDED(hr) && HasFX())
    {
        m_fxChain->UpdateFx(pvAudioPtr1, dwAudioBytes1);
        if (pvAudioPtr2 && dwAudioBytes2)
            m_fxChain->UpdateFx(pvAudioPtr2, dwAudioBytes2);
    }

#ifdef ENABLE_PERFLOG
    // Check if there were any glitches
    if (m_pPerfState)
    {
        if (pvAudioPtr1)
            m_pPerfState->OnUnlockBuffer(PtrDiffToUlong(LPBYTE(pvAudioPtr1) - GetPlayBuffer()), dwAudioBytes1);
        if (pvAudioPtr2)
            m_pPerfState->OnUnlockBuffer(PtrDiffToUlong(LPBYTE(pvAudioPtr2) - GetPlayBuffer()), dwAudioBytes2);
    }
#endif

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lose
 *
 *  Description:
 *      Flags the buffer as lost.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Lose"

HRESULT CDirectSoundSecondaryBuffer::Lose(void)
{
    DPF_ENTER();

    if(!(m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        // If the buffer is MIXIN or SINKIN, and is currently playing,
        // flag it as stopped due to a focus change
        if (GetBufferType())
        {
            DWORD dwState = 0;
            m_pDeviceBuffer->GetState(&dwState);
            if (dwState & VAD_BUFFERSTATE_STARTED)
                m_dwStatus |= DSBSTATUS_STOPPEDBYFOCUS;
        }

        // Stop the buffer.  All lost buffers are stopped by definition.
        SetBufferState(VAD_BUFFERSTATE_STOPPED);

        // Flag the buffer as lost
        m_dwStatus |= DSBSTATUS_BUFFERLOST;

        // Deactivate the buffer
        Activate(FALSE);

        // Free any open locks on the buffer
        m_pDeviceBuffer->OverrideLocks();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Restore
 *
 *  Description:
 *      Attempts to restore a lost bufer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Restore"

HRESULT CDirectSoundSecondaryBuffer::Restore(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Restore() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        // Are we still lost?
        if(DSBUFFERFOCUS_LOST == g_pDsAdmin->GetBufferFocusState(this))
        {
            hr = DSERR_BUFFERLOST;
        }
        else
        {
            m_dwStatus &= ~DSBSTATUS_BUFFERLOST;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVoiceManagerMode
 *
 *  Description:
 *      Gets the current voice manager mode.
 *
 *  Arguments:
 *      VmMode * [out]: receives voice manager mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVoiceManagerMode"

HRESULT CDirectSoundSecondaryBuffer::GetVoiceManagerMode(VmMode *pvmmMode)
{
    DPF_ENTER();

    *pvmmMode = m_pDirectSound->m_vmmMode;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVoiceManagerMode
 *
 *  Description:
 *      Sets the current voice manager mode.
 *
 *  Arguments:
 *      VmMode [in]: voice manager mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetVoiceManagerMode"

HRESULT CDirectSoundSecondaryBuffer::SetVoiceManagerMode(VmMode vmmMode)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(vmmMode < DSPROPERTY_VMANAGER_MODE_FIRST || vmmMode > DSPROPERTY_VMANAGER_MODE_LAST)
    {
        RPF(DPFLVL_ERROR, "Invalid Voice Manager mode");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        m_pDirectSound->m_vmmMode = vmmMode;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVoiceManagerPriority
 *
 *  Description:
 *      Gets the current voice manager priority.
 *
 *  Arguments:
 *      LPDWORD [out]: receives voice manager priority.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVoiceManagerPriority"

HRESULT CDirectSoundSecondaryBuffer::GetVoiceManagerPriority(LPDWORD pdwPriority)
{
    DPF_ENTER();

    *pdwPriority = m_dwVmPriority;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVoiceManagerPriority
 *
 *  Description:
 *      Sets the current voice manager priority.
 *
 *  Arguments:
 *      DWORD [in]: voice manager priority.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetVoiceManagerPriority"

HRESULT CDirectSoundSecondaryBuffer::SetVoiceManagerPriority(DWORD dwPriority)
{
    DPF_ENTER();

    m_dwVmPriority = dwPriority;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


#ifdef DEAD_CODE
/***************************************************************************
 *
 *  GetVoiceManagerState
 *
 *  Description:
 *      Gets the current voice manager state.
 *
 *  Arguments:
 *      VmState * [out]: receives voice manager state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVoiceManagerState"

HRESULT CDirectSoundSecondaryBuffer::GetVoiceManagerState(VmState *pvmsState)
{
    DWORD                   dwStatus;
    HRESULT                 hr;
    DPF_ENTER();

    hr = GetStatus(&dwStatus);

    if(SUCCEEDED(hr))
    {
        if(dwStatus & DSBSTATUS_PLAYING)
        {
            *pvmsState = DSPROPERTY_VMANAGER_STATE_PLAYING3DHW;
        }
        else if(FAILED(m_hrPlay))
        {
            *pvmsState = DSPROPERTY_VMANAGER_STATE_PLAYFAILED;
        }
        else if(dwStatus & DSBSTATUS_TERMINATED)
        {
            *pvmsState = DSPROPERTY_VMANAGER_STATE_BUMPED;
        }
        else
        {
            ASSERT(!dwStatus);
            *pvmsState = DSPROPERTY_VMANAGER_STATE_SILENT;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // DEAD_CODE


/***************************************************************************
 *
 *  SetFX
 *
 *  Description:
 *      Sets a chain of effects on this buffer, replacing any previous
 *      effect chain and, if necessary, allocating or deallocating the
 *      shadow buffer used to hold unprocessed audio .
 *
 *  Arguments:
 *      DWORD [in]: Number of effects.  0 to remove current FX chain.
 *      DSEFFECTDESC * [in]: Array of effect descriptor structures.
 *      DWORD * [out]: Receives the creation statuses of the effects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFX"

HRESULT CDirectSoundSecondaryBuffer::SetFX(DWORD dwFxCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes)
{
    DWORD                   dwStatus;
    HRESULT                 hr = DS_OK;
    DPF_ENTER();

    ASSERT(IS_VALID_READ_PTR(pDSFXDesc, dwFxCount * sizeof *pDSFXDesc));
    ASSERT(!pdwResultCodes || IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof *pdwResultCodes));

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Buffer was not created with DSBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check the buffer is inactive
    if(SUCCEEDED(hr))
    {
        hr = GetStatus(&dwStatus);
        if(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING))
        {
            RPF(DPFLVL_ERROR, "Cannot change effects, because buffer is playing");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Check there are no pending locks on the buffer
    if(SUCCEEDED(hr) && m_pDeviceBuffer->m_pSysMemBuffer->GetLockCount())
    {
        RPF(DPFLVL_ERROR, "Cannot change effects, because buffer has pending locks");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        RELEASE(m_fxChain);

        // If the effects count is 0, we can free up associated resources
        if (dwFxCount == 0)
        {
            m_pDeviceBuffer->m_pSysMemBuffer->FreeFxBuffer();
        }
        else // Allocate the pre-FX buffer and create the FX chain requested
        {
            hr = m_pDeviceBuffer->m_pSysMemBuffer->AllocateFxBuffer();
            if (SUCCEEDED(hr))
            {
                m_fxChain = NEW(CEffectChain(this));
                hr = HRFROMP(m_fxChain);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_fxChain->Initialize(dwFxCount, pDSFXDesc, pdwResultCodes);
            }
            if (SUCCEEDED(hr))
            {
                if (!(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
                {
                    hr = m_fxChain->AcquireFxResources();
                }

                // We need to preserve the return code from AcquireFxResources, in case it's
                // DS_INCOMPLETE, so we omit "hr=" from GetFxStatus (which always succeeds):
                if (pdwResultCodes)
                {
                    m_fxChain->GetFxStatus(pdwResultCodes);
                }
            }
            if (FAILED(hr))
            {
                RELEASE(m_fxChain);
                m_pDeviceBuffer->m_pSysMemBuffer->FreeFxBuffer();
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetFXBufferConfig
 *
 *  Description:
 *      Sets a chain of effects described in a CDirectSoundBufferConfig
 *      object, which represents a buffer description previously loaded
 *      from a file (or other IStream provider).
 *
 *  Arguments:
 *      CDirectSoundBufferConfig * [in]: describes the effects to be set.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFXBufferConfig"

HRESULT CDirectSoundSecondaryBuffer::SetFXBufferConfig(CDirectSoundBufferConfig* pDSBConfigObj)
{
    DWORD                   dwStatus;
    HRESULT                 hr;
    DPF_ENTER();

    CHECK_READ_PTR(pDSBConfigObj);
    ASSERT(m_dsbd.dwFlags & DSBCAPS_CTRLFX);

    hr = GetStatus(&dwStatus);
    if(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING))
    {
        DPF(DPFLVL_ERROR, "Cannot change effects, because buffer is playing");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        RELEASE(m_fxChain);

        // Allocate the pre-FX buffer and create the FX chain requested
        hr = m_pDeviceBuffer->m_pSysMemBuffer->AllocateFxBuffer();
        if (SUCCEEDED(hr))
        {
            m_fxChain = NEW(CEffectChain(this));
            hr = HRFROMP(m_fxChain);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_fxChain->Clone(pDSBConfigObj);
        }
        if (SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
        {
            hr = m_fxChain->AcquireFxResources();
        }
        if (FAILED(hr))
        {
            RELEASE(m_fxChain);
            m_pDeviceBuffer->m_pSysMemBuffer->FreeFxBuffer();
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UserAcquireResources
 *
 *  Description:
 *      Acquires hardware resources, and reports on FX creation status.
 *      The "User" means this is called only from the app (via dsimp.cpp).
 *
 *  Arguments:
 *      DWORD [in]: count of FX status flags to be returned.
 *      LPDWORD [out]: pointer to array of FX status flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::UserAcquireResources"

HRESULT CDirectSoundSecondaryBuffer::UserAcquireResources(DWORD dwFlags, DWORD dwFxCount, LPDWORD pdwResultCodes)
{
    HRESULT                 hr = DS_OK;
    DPF_ENTER();

    // Check that buffer is LOCDEFER
    if(!(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        RPF(DPFLVL_ERROR, "AcquireResources() is only valid for buffers created with DSBCAPS_LOCDEFER");
        hr = DSERR_INVALIDCALL;
    }

    if (SUCCEEDED(hr) && pdwResultCodes && (!HasFX() || dwFxCount != m_fxChain->GetFxCount()))
    {
        RPF(DPFLVL_ERROR, "Specified an incorrect effect count");
        hr = DSERR_INVALIDPARAM;
    }

    if (SUCCEEDED(hr))
        hr = AttemptResourceAcquisition(dwFlags);

    // We need to preserve the return code from AttemptResourceAcquisition, in case it's
    // DS_INCOMPLETE, so we omit the "hr=" from GetFxStatus (which always succeeds):
    if (HasFX() && pdwResultCodes)
        m_fxChain->GetFxStatus(pdwResultCodes);

    // If successful, prevent this buffer from having its resources stolen before it's played
    if (SUCCEEDED(hr))
        m_fCanStealResources = FALSE;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface. 
 *      LPVOID * [out]: Receives the interface requested.
 * 
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetObjectInPath"

HRESULT CDirectSoundSecondaryBuffer::GetObjectInPath(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr;
    DPF_ENTER();

    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Buffer was not created with DSBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }
    if (!HasFX())
    {
        hr = DSERR_OBJECTNOTFOUND;
    }
    else
    {
        hr = m_fxChain->GetEffectInterface(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetInternalCursors
 *
 *  Description:
 *      This method is used by streamer.cpp and effects.cpp (new in DX8).
 *      It obtains the current play and write cursors from our contained
 *      m_pDeviceBuffer object, and aligns them on sample block boundaries.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetInternalCursors"

HRESULT CDirectSoundSecondaryBuffer::GetInternalCursors(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    DPF_ENTER();

    HRESULT hr = m_pDeviceBuffer->GetCursorPosition(pdwPlay, pdwWrite);
    // ASSERT(SUCCEEDED(hr)); // Removed this ASSERT because the device will
    // sometimes mysteriously disappear out from under us - which is a pity,
    // because we depend utterly on GetCursorPosition() being reliable.

    if (SUCCEEDED(hr))
    {
        // If our device is emulated, add EMULATION_LATENCY_BOOST ms to the write cursor
        // FIXME: this code should be in m_pDeviceBuffer->GetCursorPosition() once we've
        // figured out what's up with cursor reporting on emulation.  For now, let's just
        // avoid regressions!  This method is only used by effects.cpp and dssink.cpp...

// DISABLED UNTIL DX8.1:
//        if (pdwWrite && IsEmulated())
//            *pdwWrite = PadCursor(*pdwWrite, GetBufferSize(), Format(), EMULATION_LATENCY_BOOST);
// OR:
//        if (IsEmulated())
//        {
//            if (pdwPlay)
//                *pdwPlay = PadCursor(*pdwPlay, GetBufferSize(), Format(), EMULATION_LATENCY_BOOST);
//            if (pdwWrite)
//                *pdwWrite = PadCursor(*pdwWrite, GetBufferSize(), Format(), EMULATION_LATENCY_BOOST);
//        }

        // The cursors aren't guaranteed to be on block boundaries - fix them:
        if (pdwPlay)
            *pdwPlay = BLOCKALIGN(*pdwPlay, Format()->nBlockAlign);
        if (pdwWrite)
            *pdwWrite = BLOCKALIGN(*pdwWrite, Format()->nBlockAlign);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentSlice
 *
 *  Description:
 *      Obtains the part of the audio buffer that is being processed
 *      during the streaming thread's current pass.
 *
 *      The "slice" terminology is whimsical but makes it easy to search
 *      for the slice-handling code in an editor.  It's better than yet
 *      another overloaded usage of "buffer".
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer slice start (as byte offset).
 *      LPDWORD [out]: receives buffer slice end (as byte offset).
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetCurrentSlice"

void CDirectSoundSecondaryBuffer::GetCurrentSlice(LPDWORD pdwSliceBegin, LPDWORD pdwSliceEnd)
{
    DPF_ENTER();

    // Make sure the slice endpoints have been initialized and are within range
    if (!(m_dsbd.dwFlags & DSBCAPS_SINKIN))
    {
        // NB: Sink buffers can be uninitialized if the sink is starting,
        // or if it decided not to advance its play position on this run.
        ASSERT(m_dwSliceBegin != MAX_DWORD && m_dwSliceEnd != MAX_DWORD);
        ASSERT(m_dwSliceBegin < GetBufferSize() && m_dwSliceEnd < GetBufferSize());
    }

    if (pdwSliceBegin) *pdwSliceBegin = m_dwSliceBegin;
    if (pdwSliceEnd) *pdwSliceEnd = m_dwSliceEnd;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetCurrentSlice
 *
 *  Description:
 *      Establishes the part of this audio buffer that is being processed
 *      during the streaming thread's current pass.
 *
 *  Arguments:
 *      DWORD [in]: Slice start (as byte offset from audio buffer start),
 *                  or the special argument CURRENT_WRITE_POS which means
 *                  "make the slice start at our current write position".
 *      DWORD [in]: Slice size in bytes.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetCurrentSlice"

void CDirectSoundSecondaryBuffer::SetCurrentSlice(DWORD dwSliceBegin, DWORD dwBytes)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DPF_TIMING(DPFLVL_MOREINFO, "begin=%lu size=%lu (%s%s%sbuffer%s at 0x%p)", dwSliceBegin, dwBytes,
               m_dsbd.dwFlags & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_dsbd.dwFlags & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_dsbd.dwFlags & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               HasFX() ? TEXT(" w/effects") : TEXT(""), this);

    ASSERT(dwBytes > 0 && dwBytes < GetBufferSize());

    if (dwSliceBegin == CURRENT_WRITE_POS)
    {
        hr = GetInternalCursors(NULL, &dwSliceBegin);
        if (SUCCEEDED(hr))
        {
            m_dwSliceBegin = PadCursor(dwSliceBegin, GetBufferSize(), Format(), INITIAL_WRITEAHEAD);
            DPF_TIMING(DPFLVL_MOREINFO, "CURRENT_WRITE_POS is %lu; setting slice start to %lu", dwSliceBegin, m_dwSliceBegin);
        }
        else  // GetInternalCursors failed; stop FX processing and force the
        {     // streaming thread to reset our slice next time it wakes up
            m_playState = Stopped;
            m_dwSliceBegin = m_dwSliceEnd = MAX_DWORD;
        }
    }
    else // dwSliceBegin != CURRENT_WRITE_POS
    {
        // Normal case: set the new slice begin position explicitly
        m_dwSliceBegin = dwSliceBegin;
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(m_dwSliceBegin < GetBufferSize());

        if (HasFX() && m_dwSliceBegin != m_dwSliceEnd)  // Discontinuous buffer slices
            m_fxChain->FxDiscontinuity();  // Inform effects of break in their input data

        m_dwSliceEnd = (m_dwSliceBegin + dwBytes) % GetBufferSize();

        // If this is a MIXIN buffer, write silence to the new slice
        if (m_dsbd.dwFlags & DSBCAPS_MIXIN)
            m_pDeviceBuffer->m_pSysMemBuffer->WriteSilence(m_dsbd.lpwfxFormat->wBitsPerSample, m_dwSliceBegin, m_dwSliceEnd);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  MoveCurrentSlice
 *
 *  Description:
 *      Shifts forward the audio buffer slice that is being processed.
 *
 *  Arguments:
 *      DWORD [in]: Size in bytes for the new buffer slice.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::MoveCurrentSlice"

void CDirectSoundSecondaryBuffer::MoveCurrentSlice(DWORD dwBytes)
{
    DPF_ENTER();

    DPF_TIMING(DPFLVL_MOREINFO, "dwBytes=%lu (%s%s%sbuffer%s at 0x%p)", dwBytes,
               m_dsbd.dwFlags & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_dsbd.dwFlags & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_dsbd.dwFlags & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               HasFX() ? TEXT(" w/effects") : TEXT(""), this);

    ASSERT(dwBytes > 0 && dwBytes < GetBufferSize());

    // Slide the current slice forwards and make it dwBytes wide
    if (m_dwSliceBegin == MAX_DWORD) // FIXME: for debugging only
    {
        ASSERT(!"Unset processing slice detected");
        m_playState = Stopped;
        m_dwSliceBegin = m_dwSliceEnd = MAX_DWORD;
        // FIXME: this code can disappear once all bugs are ironed out
    }
    else
    {
        m_dwSliceBegin = m_dwSliceEnd;
    }

    ASSERT(m_dwSliceBegin < GetBufferSize());

    m_dwSliceEnd = (m_dwSliceBegin + dwBytes) % GetBufferSize();

    // If this is a MIXIN buffer, write silence to the new slice
    if (m_dsbd.dwFlags & DSBCAPS_MIXIN)
        m_pDeviceBuffer->m_pSysMemBuffer->WriteSilence(m_dsbd.lpwfxFormat->wBitsPerSample, m_dwSliceBegin, m_dwSliceEnd);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DirectLock
 *
 *  Description:
 *      An abbreviation for the frequent operation of locking a region of
 *      our contained audio buffer.
 *
 *  Arguments:
 *      DWORD [in]: Byte offset to where the lock begins in the buffer.
 *      DWORD [in]: Size, in bytes, of the portion of the buffer to lock.
 *      LPVOID* [out]: Returns the first part of the locked region.
 *      LPDWORD [out]: Returns the size in bytes of the first part.
 *      LPVOID* [out]: Returns the second part of the locked region.
 *      LPDWORD [out]: Returns the size in bytes of the second part.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::DirectLock"

HRESULT CDirectSoundSecondaryBuffer::DirectLock(DWORD dwPosition, DWORD dwSize, LPVOID* ppvPtr1, LPDWORD pdwSize1, LPVOID* ppvPtr2, LPDWORD pdwSize2)
{
    DPF_ENTER();

    ASSERT(m_pDeviceBuffer != NULL);
    HRESULT hr = m_pDeviceBuffer->CRenderWaveBuffer::Lock(dwPosition, dwSize, ppvPtr1, pdwSize1, ppvPtr2, pdwSize2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DirectUnlock
 *
 *  Description:
 *      An abbreviation for the frequent operation of unlocking a region of
 *      our contained audio buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::DirectUnlock"

HRESULT CDirectSoundSecondaryBuffer::DirectUnlock(LPVOID pvPtr1, DWORD dwSize1, LPVOID pvPtr2, DWORD dwSize2)
{
    DPF_ENTER();

    ASSERT(m_pDeviceBuffer != NULL);
    HRESULT hr = m_pDeviceBuffer->CRenderWaveBuffer::Unlock(pvPtr1, dwSize1, pvPtr2, dwSize2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindSendLoop
 *
 *  Description:
 *      Auxiliary function used in effects.cpp to detect send loops.
 *      Returns DSERR_SENDLOOP if a send effect pointing to this buffer
 *      is detected anywhere in the send graph rooted at pCurBuffer.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Current buffer in graph traversal.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code; DSERR_SENDLOOP if a send loop
 *               is found, otherwise DS_OK.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::FindSendLoop"

HRESULT CDirectSoundSecondaryBuffer::FindSendLoop(CDirectSoundSecondaryBuffer* pCurBuffer)
{
    HRESULT hr = DS_OK;

    DPF_ENTER();
    CHECK_WRITE_PTR(pCurBuffer);

    if (pCurBuffer == this)
    {
        RPF(DPFLVL_ERROR, "Send loop detected from buffer at 0x%p to itself", this);
        hr = DSERR_SENDLOOP;
    }
    else if (pCurBuffer->HasFX())
    {
        // Buffer has effects - look for send effects and call ourself recursively.
        for (CNode<CEffect*>* pFxNode = pCurBuffer->m_fxChain->m_fxList.GetListHead();
             pFxNode && SUCCEEDED(hr);
             pFxNode = pFxNode->m_pNext)
        {
            CDirectSoundSecondaryBuffer* pDstBuffer = pFxNode->m_data->GetDestBuffer();
            if (pDstBuffer)
                hr = FindSendLoop(pDstBuffer); 
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CalculateOffset
 *
 *  Description:
 *      Given a CDirectSoundSecondaryBuffer and a byte offset into that
 *      buffer, calculates the "corresponding" byte offset in this buffer
 *      such that both buffers' play cursors will reach their respective
 *      offsets at the same time.  To do this we need to know the exact
 *      difference between the buffers' play positions, which we obtain
 *      using a voting heuristic, since our underlying driver models
 *      (VxD, WDM) don't support this operation directly.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Buffer to get offset from.
 *      DWORD [in]: Position in the buffer to which to synchronize.
 *      DWORD* [out]: Returns the corresponding position in this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::CalculateOffset"

// Our compiler doesn't allow this POSOFFSET type to be local to
// the function below, because it is used as a template argument.
struct POSOFFSET {LONG offset; int count; POSOFFSET(LONG _o =0) {offset=_o; count=1;}};

HRESULT CDirectSoundSecondaryBuffer::CalculateOffset(CDirectSoundSecondaryBuffer* pDsBuffer, DWORD dwTargetPos, DWORD* pdwSyncPos)
{
    const int nMaxAttempts = 7;  // Getting the cursor positions takes a surprisingly long time
    const int nQuorum = 3;       // How many "votes" are required to determine the offset

    // Note: these arbitrary constants were found to result in an accurate
    // offset calculation "almost always".  An out-of-sync send is very easy
    // to hear (it sound phasy and flangy); if we ever detect this problem in
    // testing, this code should be revisited.

    // Sanity checks
    CHECK_WRITE_PTR(pDsBuffer);
    CHECK_WRITE_PTR(pdwSyncPos);
    ASSERT(dwTargetPos < pDsBuffer->GetBufferSize());

    CList<POSOFFSET> lstOffsets;                // List of cursor offsets found
    CNode<POSOFFSET>* pCheckNode;               // Used to check AddNoteToList failures
    DWORD dwFirstPos1 = 0, dwFirstPos2 = 0;     // First cursor positions found
    DWORD dwPos1, dwPos2;                       // Current cursor positions found
    LONG lOffset;                               // Current offset
    BOOL fOffsetFound = FALSE;                  // Found the best offset?
    int nOurBlockSize = Format()->nBlockAlign;  // Used for brevity below
    int nBufferBlockSize = pDsBuffer->Format()->nBlockAlign; // Ditto
    HRESULT hr = DS_OK;

    DPF_ENTER();

    // Uncomment this to see how long this function takes to run
    // DWORD dwTimeBefore = timeGetTime();

    for (int i=0; i<nMaxAttempts && SUCCEEDED(hr); ++i)
    {
        hr = GetInternalCursors(&dwPos1, NULL);
        if (SUCCEEDED(hr))
            hr = pDsBuffer->GetInternalCursors(&dwPos2, NULL);
        if (SUCCEEDED(hr))
        {
            // Save the first buffer positions found
            if (i == 0)
                dwFirstPos1 = dwPos1, dwFirstPos2 = dwPos2;

            // If we detect a cursor wraparound, start all over again [??]
            if (dwPos1 < dwFirstPos1 || dwPos2 < dwFirstPos2)
            {
#ifdef ENABLE_SENDS  // Debug output for later debugging
                for (int j=0; j<5; ++j)
                {
                    DPF(DPFLVL_INFO, "Take %d: dwPos1=%d < dwFirstPos1=%d || dwPos2=%d < dwFirstPos2=%d", i, dwPos1, dwFirstPos1, dwPos2, dwFirstPos2);
                    Sleep(10); GetInternalCursors(&dwPos1, NULL); pDsBuffer->GetInternalCursors(&dwPos2, NULL);
                }
#endif
                break;
            }

            // Convert dwPos2 from pDsBuffer's sample block units into ours
            dwPos2 = dwPos2 * nOurBlockSize / nBufferBlockSize;

            LONG lNewOffset = dwPos2 - dwPos1;

            DPF_TIMING(DPFLVL_INFO, "Play offset #%d = %ld", i, lNewOffset);

            for (CNode<POSOFFSET>* pOff = lstOffsets.GetListHead(); pOff; pOff = pOff->m_pNext)
                if (pOff->m_data.offset >= lNewOffset - nOurBlockSize &&
                    pOff->m_data.offset <= lNewOffset + nOurBlockSize)
                {   // I.e. if the offsets are equal or only off by 1 sample block
                    ++pOff->m_data.count;
                    break;
                }

            if (pOff == NULL)  // A new offset was found - add it to the list
            {
                pCheckNode = lstOffsets.AddNodeToList(POSOFFSET(lNewOffset));
                ASSERT(pCheckNode != NULL);
            }
            else if (pOff->m_data.count == nQuorum)  // We have a winner!
            {
                lOffset = pOff->m_data.offset;
                fOffsetFound = TRUE;
#ifdef ENABLE_SENDS  // Debug output for later debugging
                DPF(DPFLVL_INFO, "QUORUM REACHED");
#endif
                break;
            }
        }                  
    }

    if (SUCCEEDED(hr) && !fOffsetFound)  // Didn't get enough votes for any one offset
    {
        // Just pick the one with the most "votes"
        int nBestSoFar = 0;
        for (CNode<POSOFFSET>* pOff = lstOffsets.GetListHead(); pOff; pOff = pOff->m_pNext)
            if (pOff->m_data.count > nBestSoFar)
            {
                lOffset = pOff->m_data.offset;
                nBestSoFar = pOff->m_data.count;
            }
        ASSERT(nBestSoFar > 0);
    }

    if (SUCCEEDED(hr))
    {
        // If dwTargetPos is smaller than the play position on pDsBuffer, it must have
        // wrapped around, so we put it back where it would be if it hadn't wrapped
        if (dwTargetPos < dwFirstPos2)
            dwTargetPos += pDsBuffer->GetBufferSize();

        // Convert dwTargetPos from pDsBuffer's sample block units into ours
        dwTargetPos = dwTargetPos * nOurBlockSize / nBufferBlockSize;

        #ifdef DEBUG_TIMING
        if (dwTargetPos - dwFirstPos2*nOurBlockSize/nBufferBlockSize > GetBufferSize())
            ASSERT(!"Sync buffer's target and play positions are further apart than our buffer size");
        #endif
        
        // And finally...
        *pdwSyncPos = dwTargetPos - lOffset;
        if (*pdwSyncPos >= GetBufferSize())
        {
            *pdwSyncPos -= GetBufferSize();
            ASSERT(*pdwSyncPos < GetBufferSize());
        }

        DPF_TIMING(DPFLVL_INFO, "Target buffer size=%lu, play pos=%lu, target pos=%lu", pDsBuffer->GetBufferSize(), dwFirstPos2, dwTargetPos);
        DPF_TIMING(DPFLVL_INFO, "Source buffer size=%lu, play pos=%lu, sync pos=%lu", GetBufferSize(), dwFirstPos1, *pdwSyncPos);
    }

    // Uncomment this to see how long this function takes to run
    // DWORD dwTimeAfter = timeGetTime();
    // DPF(DPFLVL_MOREINFO, "Calculations took %ld ms", dwTimeAfter-dwTimeBefore);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SynchronizeToBuffer
 *
 *  Description:
 *      Synchronizes this buffer's current processing slice to that of the
 *      buffer passed in as an argument.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Buffer to synchronize to.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SynchronizeToBuffer"

void CDirectSoundSecondaryBuffer::SynchronizeToBuffer(CDirectSoundSecondaryBuffer* pSyncBuffer)
{
    DPF_ENTER();

    DWORD dwSliceBegin, dwSliceEnd, dwSliceSize;
    pSyncBuffer->GetCurrentSlice(&dwSliceBegin, &dwSliceEnd);
    dwSliceSize = DISTANCE(dwSliceBegin, dwSliceEnd, pSyncBuffer->GetBufferSize());

    // Convert dwSliceSize from pSyncBuffer's sample block units into ours
    dwSliceSize = dwSliceSize * Format()->nBlockAlign / pSyncBuffer->Format()->nBlockAlign;

    // Convert dwSliceBegin into an offset into our buffer (taking into
    // account the relative play cursors of our buffer and pSyncBuffer)
    CalculateOffset(pSyncBuffer, dwSliceBegin, &dwSliceBegin);

    // Establish our new processing slice
    SetCurrentSlice(dwSliceBegin, dwSliceSize);

    // No point propagating an error to our caller, which is the streaming thread;
    // CalculateOffset() can only fail if GetCurrentPosition() fails, in which case
    // everything will come to a grinding halt soon enough anyway.

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdatePlayState
 *
 *  Description:
 *      Auxiliary function used by the streaming thread to update this
 *      buffer's playing state.  This is called once per buffer when the
 *      effects/streaming thread begins a processing pass; then for the
 *      rest of the pass, individual effects can query our state using
 *      GetPlayState(), without needing to call GetState() repeatedly
 *      on our device buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void) - If GetState() fails, we simply set our state to FALSE.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::UpdatePlayState"

DSPLAYSTATE CDirectSoundSecondaryBuffer::UpdatePlayState(void)
{
    DSPLAYSTATE oldPlayState = m_playState;
    DWORD dwState;
    DPF_ENTER();

    if (SUCCEEDED(m_pDeviceBuffer->GetState(&dwState)))
    {
        if (dwState & VAD_BUFFERSTATE_STARTED)
            if (m_playState <= Playing)
                m_playState = Playing;
            else
                m_playState = Starting;
        else
            if (m_playState >= Stopping)
                m_playState = Stopped;
            else
                m_playState = Stopping;
    }
    else
    {
        DPF(DPFLVL_ERROR, "Cataclysmic GetState() failure");
        m_playState = Stopped;
    }

    if (oldPlayState != m_playState)
    {
        static TCHAR* szStates[] = {TEXT("Starting"), TEXT("Playing"), TEXT("Stopping"), TEXT("Stopped")};
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p went from %s to %s", this, szStates[oldPlayState], szStates[m_playState]);
    }

    DPF_LEAVE(m_playState);
    return m_playState;
}


/***************************************************************************
 *
 *  SetInitialSlice
 *
 *  Description:
 *      Auxiliary function used by the streaming thread to establish an
 *      initial processing slice for this buffer when it starts playing.
 *      We try to synchronize with an active buffer that is sending to us,
 *      and if none are available we start at our current write cursor.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: Size of processing slice to be established.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetInitialSlice"

void CDirectSoundSecondaryBuffer::SetInitialSlice(REFERENCE_TIME rtSliceSize)
{
    DPF_ENTER();

    if (GetPlayState() == Starting && !(GetBufferType() & DSBCAPS_SINKIN))
    {
        CNode<CDirectSoundSecondaryBuffer*>* pSender;
        for (pSender = m_lstSenders.GetListHead(); pSender; pSender = pSender->m_pNext)
            if (pSender->m_data->IsPlaying())
            {
                // Found an active buffer sending to us
                DPF_TIMING(DPFLVL_INFO, "Synchronizing MIXIN buffer at 0x%p with send buffer at 0x%p", this, pSender->m_data);
                SynchronizeToBuffer(pSender->m_data);
                break;
            }
        if (pSender == NULL)
        {
            DPF_TIMING(DPFLVL_INFO, "No active buffers found sending to MIXIN buffer at 0x%p", this);
            SetCurrentSlice(CURRENT_WRITE_POS, RefTimeToBytes(rtSliceSize, Format()));
        }
    }

    DPF_LEAVE_VOID();
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelVolume
 *
 *  Description:
 *      Sets the volume on a set of output channels for a given mono buffer.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetChannelVolume"

HRESULT CDirectSoundSecondaryBuffer::SetChannelVolume(DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes)
{
    HRESULT                 hr = DS_OK;
    BOOL                    fChanged = FALSE;
    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLCHANNELVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLCHANNELVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check if channel levels have changed
    if(SUCCEEDED(hr))
    {
        if (dwChannelCount != m_dwChannelCount)
            fChanged = TRUE;
        else for (DWORD i=0; i<dwChannelCount && !fChanged; ++i)
            if (pdwChannels[i] != m_pdwChannels[i] || plVolumes[i] != m_plChannelVolumes[i])
                fChanged = TRUE;
    }
                
    // Set channel volumes if they've changed
    if(SUCCEEDED(hr) && fChanged)
    {
        hr = m_pDeviceBuffer->SetChannelAttenuations(m_lVolume, dwChannelCount, pdwChannels, plVolumes);

        // Update our local copy if successful
        if(SUCCEEDED(hr))
        {
            MEMFREE(m_pdwChannels);
            MEMFREE(m_plChannelVolumes);
            m_pdwChannels = MEMALLOC_A(DWORD, dwChannelCount);
            hr = HRFROMP(m_pdwChannels);
        }
        if (SUCCEEDED(hr))
        {
            m_plChannelVolumes = MEMALLOC_A(LONG, dwChannelCount);
            hr = HRFROMP(m_plChannelVolumes);
        }
        if (SUCCEEDED(hr))
        {
            CopyMemory(m_pdwChannels, pdwChannels, sizeof(DWORD) * dwChannelCount);
            CopyMemory(m_plChannelVolumes, plVolumes, sizeof(LONG) * dwChannelCount);
            m_dwChannelCount = dwChannelCount;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  CDirectSound3dListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::CDirectSound3dListener"

CDirectSound3dListener::CDirectSound3dListener(CDirectSoundPrimaryBuffer *pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound3dListener);

    // Initialize defaults
    m_pParent = pParent;
    m_pImpDirectSound3dListener = NULL;
    m_pDevice3dListener = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSound3dListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::~CDirectSound3dListener"

CDirectSound3dListener::~CDirectSound3dListener(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSound3dListener);

    // Free 3D listener object
    RELEASE(m_pDevice3dListener);

    // Free interface(s)
    DELETE(m_pImpDirectSound3dListener);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CPrimaryRenderWaveBuffer * [in]: device buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::Initialize"

HRESULT CDirectSound3dListener::Initialize(CPrimaryRenderWaveBuffer *pDeviceBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the device 3D listener
    hr = pDeviceBuffer->Create3dListener(&m_pDevice3dListener);

    // Create the 3D listener interfaces
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(m_pParent, IID_IDirectSound3DListener, this, &m_pImpDirectSound3dListener);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Gets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [out]: receives properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetAllParameters"

HRESULT CDirectSound3dListener::GetAllParameters(LPDS3DLISTENER pParam)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetAllParameters(pParam);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDistanceFactor
 *
 *  Description:
 *      Gets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives distance factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetDistanceFactor"

HRESULT CDirectSound3dListener::GetDistanceFactor(D3DVALUE* pflDistanceFactor)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetDistanceFactor(pflDistanceFactor);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDopplerFactor
 *
 *  Description:
 *      Gets the world's doppler factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives doppler factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetDopplerFactor"

HRESULT CDirectSound3dListener::GetDopplerFactor(D3DVALUE* pflDopplerFactor)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetDopplerFactor(pflDopplerFactor);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetOrientation
 *
 *  Description:
 *      Gets the listener's orientation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives front orientation.
 *      D3DVECTOR* [out]: receives top orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetOrientation"

HRESULT CDirectSound3dListener::GetOrientation(D3DVECTOR* pvrOrientationFront, D3DVECTOR* pvrOrientationTop)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetOrientation(pvrOrientationFront, pvrOrientationTop);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the listener's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetPosition"

HRESULT CDirectSound3dListener::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetPosition(pvrPosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetRolloffFactor
 *
 *  Description:
 *      Gets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives rolloff factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetRolloffFactor"

HRESULT CDirectSound3dListener::GetRolloffFactor(D3DVALUE* pflRolloffFactor)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetRolloffFactor(pflRolloffFactor);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the listener's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetVelocity"

HRESULT CDirectSound3dListener::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetVelocity(pvrVelocity);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [in]: properties.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetAllParameters"

HRESULT CDirectSound3dListener::SetAllParameters(LPCDS3DLISTENER pParam, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetAllParameters(pParam, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetDistanceFactor"

HRESULT CDirectSound3dListener::SetDistanceFactor(D3DVALUE flDistanceFactor, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetDistanceFactor(flDistanceFactor, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetDopplerFactor"

HRESULT CDirectSound3dListener::SetDopplerFactor(D3DVALUE flDopplerFactor, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetDopplerFactor(flDopplerFactor, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetOrientation
 *
 *  Description:
 *      Sets the listener's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: front orientation.
 *      REFD3DVECTOR [in]: top orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetOrientation"

HRESULT CDirectSound3dListener::SetOrientation(REFD3DVECTOR vrOrientationFront, REFD3DVECTOR vrOrientationTop, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetOrientation(vrOrientationFront, vrOrientationTop, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the listener's position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetPosition"

HRESULT CDirectSound3dListener::SetPosition(REFD3DVECTOR vrPosition, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetPosition(vrPosition, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetRolloffFactor"

HRESULT CDirectSound3dListener::SetRolloffFactor(D3DVALUE flRolloffFactor, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetRolloffFactor(flRolloffFactor, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the listener's velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetVelocity"

HRESULT CDirectSound3dListener::SetVelocity(REFD3DVECTOR vrVelocity, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetVelocity(vrVelocity, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::CommitDeferredSettings"

HRESULT CDirectSound3dListener::CommitDeferredSettings(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Commit all listener settings
    hr = m_pDevice3dListener->CommitDeferred();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets device speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetSpeakerConfig"

HRESULT CDirectSound3dListener::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetSpeakerConfig(dwSpeakerConfig);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CDirectSound3dBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::CDirectSound3dBuffer"

CDirectSound3dBuffer::CDirectSound3dBuffer(CDirectSoundSecondaryBuffer *pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound3dBuffer);

    // Initialize defaults
    m_pParent = pParent;
    m_pImpDirectSound3dBuffer = NULL;
    m_pWrapper3dObject = NULL;
    m_pDevice3dObject = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSound3dBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::~CDirectSound3dBuffer"

CDirectSound3dBuffer::~CDirectSound3dBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSound3dBuffer);

    // Free 3D buffer objects
    RELEASE(m_pWrapper3dObject);
    RELEASE(m_pDevice3dObject);

    // Free all interfaces
    DELETE(m_pImpDirectSound3dBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      REFGUID [in]: 3D algorithm identifier.
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: buffer frequency.
 *      CDirectSound3dListener * [in]: listener object.
 *      CDirectSound3dBuffer * [in]: source object to duplicate from.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::Initialize"

HRESULT CDirectSound3dBuffer::Initialize(REFGUID guid3dAlgorithm, DWORD dwFlags, DWORD dwFrequency, CDirectSound3dListener *pListener, CDirectSound3dBuffer *pSource)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((dwFlags & DSBCAPS_CTRLFX) && !(dwFlags & DSBCAPS_SINKIN));
    DS3DBUFFER              param;
    HRESULT                 hr;

    DPF_ENTER();

    // Create the wrapper 3D object
    m_pWrapper3dObject = NEW(CWrapper3dObject(pListener->m_pDevice3dListener, guid3dAlgorithm, fMute3dAtMaxDistance, fDopplerEnabled, dwFrequency));
    hr = HRFROMP(m_pWrapper3dObject);

    // Copy the source buffer's 3D properties
    if(SUCCEEDED(hr) && pSource)
    {
        InitStruct(&param, sizeof(param));

        hr = pSource->GetAllParameters(&param);

        if(SUCCEEDED(hr))
        {
            hr = SetAllParameters(&param, 0);
        }
    }

    // Register the 3D buffer interfaces
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(m_pParent, IID_IDirectSound3DBuffer, this, &m_pImpDirectSound3dBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pParent->RegisterInterface(IID_IDirectSound3DBufferPrivate, m_pImpDirectSound3dBuffer, (IDirectSound3DBufferPrivate*)m_pImpDirectSound3dBuffer);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer * [in]: device buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::AcquireResources"

HRESULT CDirectSound3dBuffer::AcquireResources(CSecondaryRenderWaveBuffer *pDeviceBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the device 3D object
    hr = pDeviceBuffer->Create3dObject(m_pWrapper3dObject->GetListener(), &m_pDevice3dObject);

    if(SUCCEEDED(hr))
    {
        hr = m_pWrapper3dObject->SetObjectPointer(m_pDevice3dObject);
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "3D buffer at 0x%p has acquired resources at 0x%p", this, m_pDevice3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees hardware resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::FreeResources"

HRESULT CDirectSound3dBuffer::FreeResources(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Free the device 3D object
    hr = m_pWrapper3dObject->SetObjectPointer(NULL);

    if(SUCCEEDED(hr))
    {
        RELEASE(m_pDevice3dObject);
        DPF(DPFLVL_MOREINFO, "3D buffer at 0x%p has freed its resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for a given buffer.  This function is
 *      overridden in the 3D buffer because the 3D object may need
 *      notification.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: new attenuation.
 *      LPBOOL [out]: receives TRUE if the device buffer should be notified
 *                    of the change.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetAttenuation"

HRESULT CDirectSound3dBuffer::SetAttenuation(PDSVOLUMEPAN pdsvp, LPBOOL pfContinue)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetAttenuation(pdsvp, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the frequency for a given buffer.  This function is
 *      overridden in the 3D buffer because the 3D object may need
 *      notification.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      LPBOOL [out]: receives TRUE if the device buffer should be notified
 *                    of the change.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetFrequency"

HRESULT CDirectSound3dBuffer::SetFrequency(DWORD dwFrequency, LPBOOL pfContinue)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetFrequency(dwFrequency, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Sets the mute status for a given buffer.  This function is
 *      overridden in the 3D buffer because the 3D object may need
 *      notification.
 *
 *  Arguments:
 *      BOOL [in]: new mute status.
 *      LPBOOL [out]: receives TRUE if the device buffer should be notified
 *                    of the change.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMute"

HRESULT CDirectSound3dBuffer::SetMute(BOOL fMute, LPBOOL pfContinue)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMute(fMute, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Retrieves all 3D properties for the buffer.
 *
 *  Arguments:
 *      LPDS3DBUFFER [out]: recieves properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetAllParameters"

HRESULT CDirectSound3dBuffer::GetAllParameters(LPDS3DBUFFER pParam)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetAllParameters(pParam);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

/***************************************************************************
 *
 *  GetConeAngles
 *
 *  Description:
 *      Gets inside and outside cone angles.
 *
 *  Arguments:
 *      LPDWORD [out]: receives inside cone angle.
 *      LPDWORD [out]: receives outside cone angle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetConeAngles"

HRESULT CDirectSound3dBuffer::GetConeAngles(LPDWORD pdwInside, LPDWORD pdwOutside)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetConeAngles(pdwInside, pdwOutside);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetConeOrientation
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives cone orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetConeOrientation"

HRESULT CDirectSound3dBuffer::GetConeOrientation(D3DVECTOR* pvrConeOrientation)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetConeOrientation(pvrConeOrientation);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetConeOutsideVolume
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      LPLONG [out]: receives volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetConeOutsideVolume"

HRESULT CDirectSound3dBuffer::GetConeOutsideVolume(LPLONG plVolume)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetConeOutsideVolume(plVolume);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetMaxDistance
 *
 *  Description:
 *      Gets the object's maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives max distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetMaxDistance"

HRESULT CDirectSound3dBuffer::GetMaxDistance(D3DVALUE* pflMaxDistance)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetMaxDistance(pflMaxDistance);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetMinDistance
 *
 *  Description:
 *      Gets the object's minimim distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives min distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetMinDistance"

HRESULT CDirectSound3dBuffer::GetMinDistance(D3DVALUE* pflMinDistance)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetMinDistance(pflMinDistance);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetMode
 *
 *  Description:
 *      Gets the object's mode.
 *
 *  Arguments:
 *      LPDWORD [out]: receives mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetMode"

HRESULT CDirectSound3dBuffer::GetMode(LPDWORD pdwMode)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetMode(pdwMode);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the object's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetPosition"

HRESULT CDirectSound3dBuffer::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetPosition(pvrPosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the object's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetVelocity"

HRESULT CDirectSound3dBuffer::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetVelocity(pvrVelocity);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object properties.
 *
 *  Arguments:
 *      LPDS3DBUFFER [in]: object parameters.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetAllParameters"

HRESULT CDirectSound3dBuffer::SetAllParameters(LPCDS3DBUFFER pParam, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetAllParameters(pParam, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets the sound cone's angles.
 *
 *  Arguments:
 *      DWORD [in]: inside angle.
 *      DWORD [in]: outside angle.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetConeAngles"

HRESULT CDirectSound3dBuffer::SetConeAngles(DWORD dwInside, DWORD dwOutside, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetConeAngles(dwInside, dwOutside, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets the sound cone's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetConeOrientation"

HRESULT CDirectSound3dBuffer::SetConeOrientation(REFD3DVECTOR vrOrientation, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetConeOrientation(vrOrientation, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets the sound cone's outside volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetConeOutsideVolume"

HRESULT CDirectSound3dBuffer::SetConeOutsideVolume(LONG lVolume, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetConeOutsideVolume(lVolume, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the objects maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: maximum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMaxDistance"

HRESULT CDirectSound3dBuffer::SetMaxDistance(D3DVALUE flMaxDistance, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMaxDistance(flMaxDistance, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the objects minimum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: minimum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMinDistance"

HRESULT CDirectSound3dBuffer::SetMinDistance(D3DVALUE flMinDistance, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMinDistance(flMinDistance, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the objects mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMode"

HRESULT CDirectSound3dBuffer::SetMode(DWORD dwMode, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMode(dwMode, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the objects position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetPosition"

HRESULT CDirectSound3dBuffer::SetPosition(REFD3DVECTOR vrPosition, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetPosition(vrPosition, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the objects velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetVelocity"

HRESULT CDirectSound3dBuffer::SetVelocity(REFD3DVECTOR vrVelocity, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetVelocity(vrVelocity, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAttenuation
 *
 *  Description:
 *      Obtains the buffer's current true attenuation (as opposed to
 *      GetVolume, which just returns the last volume set by the app).
 *
 *  Arguments:
 *      FLOAT* [out]: attenuation in millibels.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetAttenuation"

HRESULT CDirectSound3dBuffer::GetAttenuation(FLOAT* pfAttenuation)
{
    DPF_ENTER();

    HRESULT hr = m_pParent->GetAttenuation(pfAttenuation);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDirectSoundPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::CDirectSoundPropertySet"

CDirectSoundPropertySet::CDirectSoundPropertySet(CUnknown *pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundPropertySet);

    // Set defaults
    m_pParent = pParent;
    m_pImpKsPropertySet = NULL;
    m_pWrapperPropertySet = NULL;
    m_pDevicePropertySet = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::~CDirectSoundPropertySet"

CDirectSoundPropertySet::~CDirectSoundPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundPropertySet);

    // Free property set objects
    RELEASE(m_pWrapperPropertySet);
    RELEASE(m_pDevicePropertySet);

    // Free interface(s)
    DELETE(m_pImpKsPropertySet);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::Initialize"

HRESULT CDirectSoundPropertySet::Initialize(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the wrapper property set object
    m_pWrapperPropertySet = NEW(CWrapperPropertySet);
    hr = HRFROMP(m_pWrapperPropertySet);

    // Register interface
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(m_pParent, IID_IKsPropertySet, this, &m_pImpKsPropertySet);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      CRenderWaveBuffer * [in]: device buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::AcquireResources"

HRESULT CDirectSoundPropertySet::AcquireResources(CRenderWaveBuffer *pDeviceBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the device property set object
    ASSERT(m_pDevicePropertySet == NULL);
    hr = pDeviceBuffer->CreatePropertySet(&m_pDevicePropertySet);

    if(SUCCEEDED(hr))
    {
        hr = m_pWrapperPropertySet->SetObjectPointer(m_pDevicePropertySet);
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Property set at 0x%p has acquired resources at 0x%p", this, m_pDevicePropertySet);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees hardware resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::FreeResources"

HRESULT CDirectSoundPropertySet::FreeResources(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Free the device property set object
    hr = m_pWrapperPropertySet->SetObjectPointer(NULL);

    if(SUCCEEDED(hr))
    {
        RELEASE(m_pDevicePropertySet);
        DPF(DPFLVL_MOREINFO, "Property set at 0x%p has freed its resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::QuerySupport"

HRESULT CDirectSoundPropertySet::QuerySupport(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapperPropertySet->QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [out]: receives property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::GetProperty"

HRESULT CDirectSoundPropertySet::GetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, PULONG pcbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapperPropertySet->GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, pcbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::SetProperty"

HRESULT CDirectSoundPropertySet::SetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapperPropertySet->SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CDirectSoundSecondaryBufferPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::CDirectSoundSecondaryBufferPropertySet"

CDirectSoundSecondaryBufferPropertySet::CDirectSoundSecondaryBufferPropertySet(CDirectSoundSecondaryBuffer *pParent)
    : CDirectSoundPropertySet(pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundSecondaryBufferPropertySet);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundSecondaryBufferPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::~CDirectSoundSecondaryBufferPropertySet"

CDirectSoundSecondaryBufferPropertySet::~CDirectSoundSecondaryBufferPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundSecondaryBufferPropertySet);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::QuerySupport"

HRESULT CDirectSoundSecondaryBufferPropertySet::QuerySupport(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CPropertySetHandler::QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [out]: receives property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::GetProperty"

HRESULT CDirectSoundSecondaryBufferPropertySet::GetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, PULONG pcbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CPropertySetHandler::GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, pcbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::SetProperty"

HRESULT CDirectSoundSecondaryBufferPropertySet::SetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CPropertySetHandler::SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnsupportedQueryHandler
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::UnsupportedQueryHandler"

HRESULT CDirectSoundSecondaryBufferPropertySet::UnsupportedQueryHandler(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CDirectSoundPropertySet::QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnsupportedGetHandler
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [out]: receives property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::UnsupportedGetHandler"

HRESULT CDirectSoundSecondaryBufferPropertySet::UnsupportedGetHandler(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, PULONG pcbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CDirectSoundPropertySet::GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, pcbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnsupportedSetHandler
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::UnsupportedSetHandler"

HRESULT CDirectSoundSecondaryBufferPropertySet::UnsupportedSetHandler(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CDirectSoundPropertySet::SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbufcfg.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbufcfg.h
 *  Content:    DirectSound Buffer Descriptor.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/17/99    jimge   Created.
 *  11/24/99    petchey Completed implementation.
 *
 ***************************************************************************/

#ifndef __DSBUFCFG_H__
#define __DSBUFCFG_H__

#ifdef __cplusplus

//>>>>>>>>>>>>>> should this be inside a DSOUND id header?
#include "dmusicf.h"

#define DMUS_E_INVALID_FX_HDR E_FAIL
#define DMUS_E_FX_HDR_NOT_FIRST_CK E_FAIL

#define DSBC_PARTIALLOAD_S_OK   (1 << 1)
#define DSBC_PARTIALLOAD_E_FAIL (1 << 2)

class CDirectSoundSink;
class CRiffParser;

enum {
    DSBCFG_DSBD = 0x00000001,
    DSBCFG_BSID = 0x00000002,
    DSBCFG_DS3D = 0x00000004,
    DSBCFG_DSFX = 0x00000008,
};

class CDirectSoundBufferConfig
    : public CUnknown
{
friend CDirectSoundSink;
friend CEffectChain;
friend CEffect;

protected:
    struct CDXDMODesc
    {
        DWORD m_dwEffectFlags;
        GUID m_guidDSFXClass;
        GUID m_guidSendBuffer;
        DWORD m_dwReserved;
        IMediaObject* m_pMediaObject;
        long m_lSendLevel;
        CDXDMODesc* pNext;
    };

private:
    void AddDXDMODesc(CDXDMODesc *pDXDMODesc)
    {
        if ( m_pDXDMOMapList )
        {
            CDXDMODesc *pObj = m_pDXDMOMapList;
            while(pObj->pNext)
                pObj = pObj->pNext;
            pObj->pNext = pDXDMODesc;
        }
        else
        {
            m_pDXDMOMapList = pDXDMODesc;
        }
        m_dwDXDMOMapCount++;
    };

public:
    CDirectSoundBufferConfig();
    virtual ~CDirectSoundBufferConfig();

    // IUnknown
    //
    HRESULT QueryInterface(REFIID riid,BOOL fInternalQuery,LPVOID *ppvObj);

    // IPersist
    //
    HRESULT GetClassID(CLSID *pClassID);

    // IPersistStream
    //
    HRESULT IsDirty();
    HRESULT Load(IStream *pStream);
    HRESULT Save(IStream *pStream, BOOL fClearDirty);
    HRESULT GetSizeMax(ULARGE_INTEGER* pcbSize);

    // IDirectMusicObject
    //
    HRESULT GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    HRESULT SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    HRESULT ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

protected:
    DWORD                    m_fLoadFlags;
    DMUS_OBJECTDESC          m_DMUSObjectDesc;  // DirectMusicObjectDescription
    DSOUND_IO_DSBUFFERDESC   m_DSBufferDesc;
    DSOUND_IO_3D             m_DS3DDesc;
    LPDWORD                  m_pdwFuncIDs;      // Array of functional IDs associated with the bus
    DWORD                    m_dwFuncIDsCount;  // Number of functional IDs
    CDXDMODesc              *m_pDXDMOMapList;   // Pointer to a list of FX descriptions
    DWORD                    m_dwDXDMOMapCount;

    HRESULT LoadFx(CRiffParser *pParser);

private:
    CImpPersistStream<CDirectSoundBufferConfig> *m_pImpPersistStream;
    CImpDirectMusicObject<CDirectSoundBufferConfig> *m_pImpDirectMusicObject;
};

#endif // __cplusplus

#endif // __DSBUFCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbuf.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbuf.h
 *  Content:    DirectSound Buffer object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *
 ***************************************************************************/

#ifndef __DSBUF_H__
#define __DSBUF_H__

// Type used by class CDirectSoundSecondaryBuffer below
enum DSPLAYSTATE {Starting, Playing, Stopping, Stopped}; 
// "Stopping" isn't used yet, but may come in handy to implement effect tails later

// Special argument used by CDirectSoundSecondaryBuffer::SetCurrentSlice()
#define CURRENT_WRITE_POS MAX_DWORD


#ifdef __cplusplus

// Fwd decl
class CDirectSound;
class CDirectSound3dListener;
class CDirectSound3dBuffer;
class CDirectSoundPropertySet;
class CDirectSoundSink;

// We actually need CDirectSound to be declared here,
// since we use it in IsEmulated() below:
#include "dsobj.h"

// The DirectSound Buffer object base class
class CDirectSoundBuffer
    : public CUnknown
{
    friend class CDirectSound;
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundPrivate;
    friend class CDirectSoundSink;

protected:
    CDirectSound *              m_pDirectSound;     // Parent object
    DSBUFFERDESC                m_dsbd;             // Buffer description
    DWORD                       m_dwStatus;         // Buffer status

public:
    CDirectSoundBuffer(CDirectSound *);
    virtual ~CDirectSoundBuffer();

public:
    // Initialization
    virtual HRESULT IsInit() = 0;

    // Caps
    virtual HRESULT GetCaps(LPDSBCAPS) = 0;

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD) = 0;
    virtual HRESULT SetFormat(LPCWAVEFORMATEX) = 0;
    virtual HRESULT GetFrequency(LPDWORD) = 0;
    virtual HRESULT SetFrequency(DWORD) = 0;
    virtual HRESULT GetPan(LPLONG) = 0;
    virtual HRESULT SetPan(LONG) = 0;
    virtual HRESULT GetVolume(LPLONG) = 0;
    virtual HRESULT SetVolume(LONG) = 0;
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY) = 0;

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD) = 0;
    virtual HRESULT SetCurrentPosition(DWORD) = 0;
    virtual HRESULT GetStatus(LPDWORD) = 0;
    virtual HRESULT Play(DWORD, DWORD) = 0;
    virtual HRESULT Stop() = 0;
    virtual HRESULT Activate(BOOL) = 0;

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) = 0;
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD) = 0;
    virtual HRESULT Lose() = 0;
    virtual HRESULT Restore() = 0;

    // New methods for the DirectSound 8.0 release
    // (These have to be present in the base class but are valid only for secondary buffers)
    virtual HRESULT SetFX(DWORD, LPDSEFFECTDESC, LPDWORD) {BREAK(); return DSERR_GENERIC;}
    virtual HRESULT UserAcquireResources(DWORD, DWORD, LPDWORD) {BREAK(); return DSERR_GENERIC;}
    virtual HRESULT GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *) {BREAK(); return DSERR_GENERIC;}
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelVolume(DWORD, LPDWORD, LPLONG) {BREAK(); return DSERR_GENERIC;}
#endif

    // Inline query for buffer type (regular, MIXIN or SINKIN)
    DWORD GetBufferType() {return m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN);}

    // Public accessors to try to cut down on the excessive friendship goin' on
    const CDirectSound* GetDirectSound() {return m_pDirectSound;}

    // For modifying the final success code returned to the app if necessary
    virtual HRESULT SpecialSuccessCode() {return DS_OK;}

protected:
    virtual void UpdateBufferStatusFlags(DWORD, LPDWORD);
};

// DirectSound primary buffer
class CDirectSoundPrimaryBuffer
    : public CDirectSoundBuffer
{
    friend class CDirectSound;
    friend class CDirectSoundSecondaryBuffer;

private:
    CPrimaryRenderWaveBuffer *  m_pDeviceBuffer;    // The device buffer
    CDirectSound3dListener *    m_p3dListener;      // The 3D listener
    CDirectSoundPropertySet *   m_pPropertySet;     // The property set object
    DWORD                       m_dwRestoreState;   // Primary buffer state before going out of focus
    BOOL                        m_fWritePrimary;    // Is the buffer WRITEPRIMARY?
    ULONG                       m_ulUserRefCount;   // Reference count exposed to the user
    HRESULT                     m_hrInit;           // Has the object been initialized?
    BOOL                        m_bDataLocked;      // Signals that a WRITEPRIMARY app has written data since creating the buffer

private:
    // Interfaces
    CImpDirectSoundBuffer<CDirectSoundPrimaryBuffer> *m_pImpDirectSoundBuffer;

public:
    CDirectSoundPrimaryBuffer(CDirectSound *);
    virtual ~CDirectSoundPrimaryBuffer();

public:
    // CDsBasicRuntime overrides
    virtual ULONG AddRef();
    virtual ULONG Release();

    // Creation
    virtual HRESULT Initialize(LPCDSBUFFERDESC);
    virtual HRESULT IsInit();
    virtual HRESULT OnCreateSoundBuffer(DWORD);

    // Buffer Caps
    virtual HRESULT GetCaps(LPDSBCAPS);
    virtual HRESULT SetBufferFlags(DWORD);

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetFormat(LPCWAVEFORMATEX);
    virtual HRESULT GetFrequency(LPDWORD);
    virtual HRESULT SetFrequency(DWORD);
    virtual HRESULT GetPan(LPLONG);
    virtual HRESULT SetPan(LONG);
    virtual HRESULT GetVolume(LPLONG);
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCurrentPosition(DWORD);
    virtual HRESULT GetStatus(LPDWORD);
    virtual HRESULT Play(DWORD, DWORD);
    virtual HRESULT Stop();
    virtual HRESULT Activate(BOOL);
    virtual HRESULT SetPriority(DWORD);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT Lose();
    virtual HRESULT Restore();

private:
    virtual HRESULT SetBufferState(DWORD);
};

inline ULONG CDirectSoundPrimaryBuffer::AddRef()
{
    return ::AddRef(&m_ulUserRefCount);
}

inline ULONG CDirectSoundPrimaryBuffer::Release()
{
    return ::Release(&m_ulUserRefCount);
}

inline HRESULT CDirectSoundPrimaryBuffer::IsInit()
{
    return m_hrInit;
}

// DirectSound secondary buffer
class CDirectSoundSecondaryBuffer
    : public CDirectSoundBuffer
{
    friend class CEffectChain;      // CEffectChain currently needs access to our m_pOwningSink, m_pDeviceBuffer
                                    // and m_pImpDirectSoundBuffer; maybe this can be cleaned up later.
    friend class CDirectSoundSink;  // Likewise, needs access to m_pDeviceBuffer.
#ifdef ENABLE_PERFLOG
    friend class BufferPerfState;
    friend void OnPerflogStateChanged(void);
#endif

private:
    CDirectSoundSink *              m_pOwningSink;          // Parent sink object (maybe)
    CSecondaryRenderWaveBuffer *    m_pDeviceBuffer;        // The device buffer
    CDirectSound3dBuffer *          m_p3dBuffer;            // The 3D buffer
    CDirectSoundPropertySet *       m_pPropertySet;         // The property set object
    CEffectChain *                  m_fxChain;              // The effects chain object
    LONG                            m_lPan;                 // Pan
    LONG                            m_lVolume;              // Volume
#ifdef FUTURE_MULTIPAN_SUPPORT
    LPLONG                          m_plChannelVolumes;     // Volumes from last SetChannelVolume() call
    DWORD                           m_dwChannelCount;       // No. of channels from last SetChannelVolume()
    LPDWORD                         m_pdwChannels;          // Channels used in last SetChannelVolume()
#endif
    DWORD                           m_dwFrequency;          // Frequency
    DWORD                           m_dwOriginalFlags;      // Original buffer flags
    HRESULT                         m_hrInit;               // Has the object been initialized?
    HRESULT                         m_hrPlay;               // Last return code from ::Play
    DWORD                           m_dwPriority;           // Buffer priority
    DWORD                           m_dwVmPriority;         // Voice Manager priority
    BOOL                            m_fMute;                // Is the buffer muted?
    BOOL                            m_fCanStealResources;   // Are we allowed to steal buffer's resources?
    
    DWORD                           m_dwAHCachedPlayPos;    // for CACHEPOSITIONS apphack
    DWORD                           m_dwAHCachedWritePos;   // 
    DWORD                           m_dwAHLastGetPosTime;   // 

    // New in DX8: used by the streaming thread to handle sink/FX/MIXIN buffers
    DSPLAYSTATE                     m_playState;            // Current playing state of the buffer
    CStreamingThread*               m_pStreamingThread;     // Pointer to our owning streaming thread
    DWORD                           m_dwSliceBegin;         // The "slice" is the part of the buffer that is currently
    DWORD                           m_dwSliceEnd;           // being effects-processed and/or written to by the sink
    GUID                            m_guidBufferID;         // Unique identifier for this buffer
    CList<CDirectSoundSecondaryBuffer*> m_lstSenders;       // Buffers sending to us, if we're a MIXIN buffer
                                                            // Note: all this really belongs in a derived class
#ifdef ENABLE_PERFLOG
    BufferPerfState*                m_pPerfState;           // Performance logging helper
#endif

private:
    // Interfaces
    CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>   *m_pImpDirectSoundBuffer;
    CImpDirectSoundNotify<CDirectSoundSecondaryBuffer>   *m_pImpDirectSoundNotify;

public:
    CDirectSoundSecondaryBuffer(CDirectSound *);
    virtual ~CDirectSoundSecondaryBuffer();

public:
    // Creation
    virtual HRESULT Initialize(LPCDSBUFFERDESC, CDirectSoundSecondaryBuffer *);
    virtual HRESULT IsInit() {return m_hrInit;}

    // Caps
    virtual HRESULT GetCaps(LPDSBCAPS);

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetFormat(LPCWAVEFORMATEX);
    virtual HRESULT GetFrequency(LPDWORD);
    virtual HRESULT SetFrequency(DWORD);
    virtual HRESULT GetPan(LPLONG);
    virtual HRESULT SetPan(LONG);
    virtual HRESULT GetVolume(LPLONG);
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT GetAttenuation(FLOAT*);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCurrentPosition(DWORD);
    virtual HRESULT GetStatus(LPDWORD);
    virtual HRESULT Play(DWORD, DWORD);
    virtual HRESULT Stop();
    virtual HRESULT Activate(BOOL);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT Lose();
    virtual HRESULT Restore();

    // Legacy voice management
    virtual HRESULT GetVoiceManagerMode(VmMode *);
    virtual HRESULT SetVoiceManagerMode(VmMode);
    virtual HRESULT GetVoiceManagerPriority(LPDWORD);
    virtual HRESULT SetVoiceManagerPriority(DWORD);
    #ifdef DEAD_CODE
    virtual HRESULT GetVoiceManagerState(VmState *);
    #endif // DEAD_CODE

    // Inline abbreviations for filling the buffer with silence
    void ClearWriteBuffer() {::FillSilence(GetWriteBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);}
    void ClearPlayBuffer()  {::FillSilence(GetPlayBuffer(),  m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);}

    // For modifying the final success code returned to the app if necessary
    virtual HRESULT SpecialSuccessCode() {return m_pDeviceBuffer->SpecialSuccessCode();}

    // New in DX8: used by the streaming thread to handle sink/FX/MIXIN buffers
    void SetOwningSink(CDirectSoundSink *);
    void SetGUID(REFGUID guidBufferID) {m_guidBufferID = guidBufferID;}
    REFGUID GetGUID() {return m_guidBufferID;}
    virtual HRESULT SetFX(DWORD, LPDSEFFECTDESC, LPDWORD);
    virtual HRESULT SetFXBufferConfig(CDirectSoundBufferConfig*);
    virtual HRESULT UserAcquireResources(DWORD, DWORD, LPDWORD);
    virtual HRESULT GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);

    BOOL HasFX() {return m_fxChain != NULL;}
    BOOL HasSink() {return m_pOwningSink != NULL;}

    // For manipulations by the streaming sink/FX thread
    HRESULT GetInternalCursors(LPDWORD, LPDWORD);
    void    GetCurrentSlice(LPDWORD, LPDWORD);
    void    SetCurrentSlice(DWORD, DWORD);
    void    MoveCurrentSlice(DWORD);
    HRESULT DirectLock(DWORD, DWORD, LPVOID*, LPDWORD, LPVOID*, LPDWORD);
    HRESULT DirectUnlock(LPVOID, DWORD, LPVOID, DWORD);
    HRESULT FindSendLoop(CDirectSoundSecondaryBuffer*);
    HRESULT CalculateOffset(CDirectSoundSecondaryBuffer*, DWORD, DWORD*);
    void    SynchronizeToBuffer(CDirectSoundSecondaryBuffer*);
    void    RegisterSender(CDirectSoundSecondaryBuffer* pSender) {m_lstSenders.AddNodeToList(pSender);}
    void    UnregisterSender(CDirectSoundSecondaryBuffer* pSender) {m_lstSenders.RemoveDataFromList(pSender);}
    DSPLAYSTATE UpdatePlayState();
    void    SetInitialSlice(REFERENCE_TIME);

    // Inline helpers
    HRESULT CommitToDevice(DWORD ibCommit, DWORD cbCommit) {return m_pDeviceBuffer->CommitToDevice(ibCommit, cbCommit);}
    LPBYTE  GetPreFxBuffer()    {return m_pDeviceBuffer->m_pSysMemBuffer->GetPreFxBuffer();}
    LPBYTE  GetPostFxBuffer()   {return m_pDeviceBuffer->m_pSysMemBuffer->GetPostFxBuffer();}
    LPBYTE  GetWriteBuffer()    {return m_pDeviceBuffer->m_pSysMemBuffer->GetWriteBuffer();}
    LPBYTE  GetPlayBuffer()     {return m_pDeviceBuffer->m_pSysMemBuffer->GetPlayBuffer();}
    DWORD   GetBufferSize()     {return m_dsbd.dwBufferBytes;}
    // Was: GetBufferSize()     {return m_pDeviceBuffer->m_pSysMemBuffer->GetSize();}
    LPWAVEFORMATEX Format()     {return m_dsbd.lpwfxFormat;}
    BOOL    IsPlaying()         {return m_playState == Starting || m_playState == Playing;}
    DSPLAYSTATE GetPlayState()  {return m_playState;}
    BOOL    IsEmulated()        {return IS_EMULATED_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType);}

#ifdef FUTURE_MULTIPAN_SUPPORT
    // The DX8 multichannel volume control API
    virtual HRESULT SetChannelVolume(DWORD, LPDWORD, LPLONG);
#endif

private:
    // Initialization helpers
    virtual HRESULT InitializeEmpty(LPCDSBUFFERDESC, CDirectSoundSecondaryBuffer *);

    // Buffer properties
    virtual HRESULT SetAttenuation(LONG, LONG);
    virtual HRESULT SetMute(BOOL);

    // Buffer state
    virtual HRESULT SetBufferState(DWORD);

    // Resource management
    virtual HRESULT AttemptResourceAcquisition(DWORD);
    virtual HRESULT AcquireResources(DWORD);
    virtual HRESULT GetResourceTheftCandidates(DWORD, CList<CDirectSoundSecondaryBuffer *> *);
    virtual HRESULT StealResources(CDirectSoundSecondaryBuffer *);
    virtual HRESULT HandleResourceAcquisition(DWORD);
    virtual HRESULT FreeResources(BOOL);
    virtual DWORD GetBufferPriority();
    virtual HRESULT GetPlayTimeRemaining(LPDWORD);
};

inline DWORD CDirectSoundSecondaryBuffer::GetBufferPriority()
{
    ASSERT((!m_dwPriority && !m_dwVmPriority) || LXOR(m_dwPriority, m_dwVmPriority));
    return max(m_dwPriority, m_dwVmPriority);
}

// The DirectSound 3D Listener object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSound3dListener
    : public CDsBasicRuntime
{
    friend class CDirectSound3dBuffer;
    friend class CDirectSoundPrimaryBuffer;
    friend class CDirectSoundSecondaryBuffer;

protected:
    CDirectSoundPrimaryBuffer * m_pParent;              // The parent object
    C3dListener *               m_pDevice3dListener;    // The device 3D listener
    HRESULT                     m_hrInit;               // Has the object been initialized?

private:
    // Interfaces
    CImpDirectSound3dListener<CDirectSound3dListener> *m_pImpDirectSound3dListener;

public:
    CDirectSound3dListener(CDirectSoundPrimaryBuffer *);
    virtual ~CDirectSound3dListener();

public:
    // Creation
    virtual HRESULT Initialize(CPrimaryRenderWaveBuffer *);
    virtual HRESULT IsInit();

    // 3D properties
    virtual HRESULT GetAllParameters(LPDS3DLISTENER);
    virtual HRESULT GetDistanceFactor(D3DVALUE*);
    virtual HRESULT GetDopplerFactor(D3DVALUE*);
    virtual HRESULT GetOrientation(D3DVECTOR*, D3DVECTOR*);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT GetRolloffFactor(D3DVALUE*);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT SetAllParameters(LPCDS3DLISTENER, DWORD);
    virtual HRESULT SetDistanceFactor(D3DVALUE, DWORD);
    virtual HRESULT SetDopplerFactor(D3DVALUE, DWORD);
    virtual HRESULT SetOrientation(REFD3DVECTOR, REFD3DVECTOR, DWORD);
    virtual HRESULT SetPosition(REFD3DVECTOR, DWORD);
    virtual HRESULT SetRolloffFactor(D3DVALUE, DWORD);
    virtual HRESULT SetVelocity(REFD3DVECTOR, DWORD);
    virtual HRESULT CommitDeferredSettings();

    // Speaker configuration
    virtual HRESULT SetSpeakerConfig(DWORD);
};

inline HRESULT CDirectSound3dListener::IsInit()
{
    return m_hrInit;
}

// The DirectSound 3D Buffer object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSound3dBuffer
    : public CDsBasicRuntime
{
    friend class CDirectSoundSecondaryBuffer;

protected:
    CDirectSoundSecondaryBuffer *   m_pParent;              // The parent object
    CWrapper3dObject *              m_pWrapper3dObject;     // The wrapper 3D object
    C3dObject *                     m_pDevice3dObject;      // The device 3D object
    HRESULT                         m_hrInit;               // Has the object been initialized?

private:
    // Interfaces
    CImpDirectSound3dBuffer<CDirectSound3dBuffer> *m_pImpDirectSound3dBuffer;

public:
    CDirectSound3dBuffer(CDirectSoundSecondaryBuffer *);
    virtual ~CDirectSound3dBuffer();

public:
    // Creation
    virtual HRESULT Initialize(REFGUID, DWORD, DWORD, CDirectSound3dListener *, CDirectSound3dBuffer *);
    virtual HRESULT IsInit();

    // 3D properties
    virtual HRESULT GetAllParameters(LPDS3DBUFFER);
    virtual HRESULT GetConeAngles(LPDWORD, LPDWORD);
    virtual HRESULT GetConeOrientation(D3DVECTOR*);
    virtual HRESULT GetConeOutsideVolume(LPLONG);
    virtual HRESULT GetMaxDistance(D3DVALUE*);
    virtual HRESULT GetMinDistance(D3DVALUE*);
    virtual HRESULT GetMode(LPDWORD);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, DWORD);
    virtual HRESULT SetConeAngles(DWORD, DWORD, DWORD);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, DWORD);
    virtual HRESULT SetConeOutsideVolume(LONG, DWORD);
    virtual HRESULT SetMaxDistance(D3DVALUE, DWORD);
    virtual HRESULT SetMinDistance(D3DVALUE, DWORD);
    virtual HRESULT SetMode(DWORD, DWORD);
    virtual HRESULT SetPosition(REFD3DVECTOR, DWORD);
    virtual HRESULT SetVelocity(REFD3DVECTOR, DWORD);

    // Buffer properties
    virtual HRESULT GetAttenuation(FLOAT*);
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

protected:
    // Resource management
    virtual HRESULT AcquireResources(CSecondaryRenderWaveBuffer *);
    virtual HRESULT FreeResources();
};

inline HRESULT CDirectSound3dBuffer::IsInit()
{
    return m_hrInit;
}

// The DirectSound Property Set object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSoundPropertySet
    : public CDsBasicRuntime
{
    friend class CDirectSoundPrimaryBuffer;
    friend class CDirectSoundSecondaryBuffer;

protected:
    CUnknown *              m_pParent;              // The parent object
    CWrapperPropertySet *   m_pWrapperPropertySet;  // The wrapper property set object
    CPropertySet *          m_pDevicePropertySet;   // The device property set object
    HRESULT                 m_hrInit;               // Has the object been initialized?

private:
    // Interfaces
    CImpKsPropertySet<CDirectSoundPropertySet> *m_pImpKsPropertySet;

public:
    CDirectSoundPropertySet(CUnknown *);
    virtual ~CDirectSoundPropertySet();

public:
    // Initialization
    virtual HRESULT Initialize();
    virtual HRESULT IsInit();

    // Property sets
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

protected:
    // Resource management
    virtual HRESULT AcquireResources(CRenderWaveBuffer *);
    virtual HRESULT FreeResources();
};

inline HRESULT CDirectSoundPropertySet::IsInit()
{
    return m_hrInit;
}

// The DirectSound Property Set object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSoundSecondaryBufferPropertySet
    : public CDirectSoundPropertySet, public CPropertySetHandler
{
private:
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_VoiceManager);
    DECLARE_PROPERTY_SET_DATA_MEMBER(m_aPropertySets);

public:
    CDirectSoundSecondaryBufferPropertySet(CDirectSoundSecondaryBuffer *);
    virtual ~CDirectSoundSecondaryBufferPropertySet();

public:
    // Property handlers
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

    // Unsupported property handlers
    virtual HRESULT UnsupportedQueryHandler(REFGUID, ULONG, PULONG);
    virtual HRESULT UnsupportedGetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT UnsupportedSetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
};

#endif // __cplusplus

#endif // __DSBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dscap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscap.cpp
 *  Content:    DirectSoundCapture object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   5/25/97    johnnyl Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "nt.h"         // For USER_SHARED_DATA
#include "ntrtl.h"
#include "nturtl.h"
#include "dsoundi.h"


/***************************************************************************
 *
 *  CDirectSoundCapture
 *
 *  Description:
 *      DirectSoundCapture object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::CDirectSoundCapture"

CDirectSoundCapture::CDirectSoundCapture()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundCapture);

    // Initialize defaults
    m_hrInit = DSERR_UNINITIALIZED;

    // Register the interfaces with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSoundCapture object from CoCreateInstance
    // or IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IDirectSoundCapture, this, &m_pImpDirectSoundCapture);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDirectSoundCapture
 *
 *  Description:
 *      DirectSoundCapture object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::CDirectSoundCapture"

CDirectSoundCapture::CDirectSoundCapture
(
    CUnknown* pControllingUnknown
) : CUnknown(pControllingUnknown)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundCapture);

    // Initialize defaults
    m_hrInit = DSERR_UNINITIALIZED;

    // Register the interfaces with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSoundCapture object from CoCreateInstance
    // or IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IDirectSoundCapture, this, &m_pImpDirectSoundCapture);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundCapture
 *
 *  Description:
 *      DirectSoundCapture object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::~CDirectSoundCapture"

CDirectSoundCapture::~CDirectSoundCapture()
{
    CNode<CDirectSoundCaptureBuffer *> *    pNode;

    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundCapture);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Free all buffers
    while(pNode = m_lstBuffers.GetListHead())
    {
        RPF(DPFLVL_WARNING, "Releasing buffer object");
        pNode->m_data->AbsoluteRelease();
    }

    // Free the audio device
    RELEASE(m_pDevice);

    // Free all interfaces
    DELETE(m_pImpDirectSoundCapture);

    // Close the registry key
    RhRegCloseKey(&m_hkeyParent);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CreateCaptureBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundCapture Buffer object.
 *
 *  Arguments:
 *      LPDSCBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundCaptureBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::CreateCaptureBuffer"

HRESULT CDirectSoundCapture::CreateCaptureBuffer(LPCDSCBUFFERDESC pDesc, CDirectSoundCaptureBuffer **ppBuffer)
{
    CDirectSoundCaptureBuffer *    pBuffer = NULL;
    HRESULT                        hr      = DS_OK;

    DPF_ENTER();

    // Create the buffer object
    pBuffer = NEW(CDirectSoundCaptureBuffer(this));
    hr = HRFROMP(pBuffer);

    // Initialize the buffer
    if(SUCCEEDED(hr))
    {
        pBuffer->SetDsVersion(GetDsVersion());  // Always succeeds

        hr = pBuffer->Initialize(pDesc);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        if (!(pDesc->dwFlags & (DSCBCAPS_STRICTFOCUS|DSCBCAPS_FOCUSAWARE)))
        {
            // This is a regular buffer, let's add it to the list
            g_pDsAdmin->UpdateCaptureState();
        }
        *ppBuffer = pBuffer;
    }

    // Free resources
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with capabilities of the object.
 *
 *  Arguments:
 *      LPDSCCAPS pdscCaps [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::GetCaps"

HRESULT CDirectSoundCapture::GetCaps(LPDSCCAPS pCaps)
{
    DWORD                   dwCertification;
    HRESULT                 hr;

    DPF_ENTER();

    // Get general caps
    hr = m_pDevice->GetCaps(pCaps);

    if(SUCCEEDED(hr))
    {
        ASSERT(!(pCaps->dwFlags & DSCAPS_CERTIFIED));
    }

    // Get certification
    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->GetDriverCertificationStatus(m_pDevice, &dwCertification);
    }

    if(SUCCEEDED(hr) && VERIFY_CERTIFIED == dwCertification)
    {
        pCaps->dwFlags |= DSCAPS_CERTIFIED;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  Normally, an object would have a pointer
 *      to another object of the same type to duplicate from.  DirectSoundCapture
 *      objects, however, are responsible for duplicating themselves based
 *      on the driver GUID.  DirectSoundCapture objects are special because they
 *      can be initialized by either DirectSoundCaptureCreate or CoInitialize.
 *      If this function fails, the object should be immediately deleted.
 *
 *  Arguments:
 *      REFGUID [in]: driver GUID, or NULL to use the preferred device.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::Initialize"

HRESULT CDirectSoundCapture::Initialize
(
    LPCGUID pGuid,
    CDirectSoundFullDuplex* pFullDuplex
)
{
    GUID                    guidDevice;
    VADDEVICETYPE           vdt = VAD_DEVICETYPE_CAPTUREMASK;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);

    // Make a local copy of the driver GUID
    guidDevice = *BuildValidGuid(pGuid, NULL);

    // Take note of our owning full-duplex object, if any
    m_pFullDuplex = pFullDuplex;

    // If the given GUID is one of the special default device IDs,
    // map it to the corresponding "real" DirectSound device ID.
    // Note: if guidDevice is GUID_NULL, GetDeviceIdFromDefaultId()
    // will fail, which is OK because GUID_NULL is handled below.
    g_pVadMgr->GetDeviceIdFromDefaultId(&guidDevice, &guidDevice);

    // Open the audio device
    hr = g_pVadMgr->OpenDevice(vdt, guidDevice, (CDevice **)&m_pDevice);

    // Open the device's registry key
    if(SUCCEEDED(hr))
    {
#ifdef WINNT
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_strInterface, &m_hkeyParent);
#else
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_dwDevnode, &m_hkeyParent);
#endif
    }

    // Initialize the Administrator
    if(SUCCEEDED(hr))
    {
        hr = g_pDsAdmin->Initialize();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetDsVersion
 *
 *  Description:
 *      Makes us aware of our "functional level", so we can have different
 *      behavior depending on whether we're in a DX7 app, a DX8 app, etc.
 *
 *  Arguments:
 *      DSVERSION [in]: Owning application's functional level.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::SetDsVersion"

void CDirectSoundCapture::SetDsVersion(DSVERSION nVersion)
{
    DPF_ENTER();

    CUnknown::SetDsVersion(nVersion);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  HasMicrosoftAEC
 *
 *  Description:
 *      Determines whether this capture object belongs to a full-duplex
 *      object which has the Microsoft AEC effect enabled.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if the capture object has Microsoft AEC.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::HasMicrosoftAEC"

BOOL CDirectSoundCapture::HasMicrosoftAEC(void)
{
    BOOL fReturn = FALSE;
    DPF_ENTER();

    // Note: currently all our defined full-duplex effects (AEC, NS and AGC)
    // are dependent on AEC; they won't run if AEC isn't enabled, so we only
    // have to check for AEC here.

    if (m_pFullDuplex && m_pFullDuplex->HasAEC())
    {
        fReturn = IsEqualGUID(m_pFullDuplex->AecInstanceGuid(), GUID_DSCFX_MS_AEC);
    }

    DPF_LEAVE(fReturn);
    return fReturn;
}


/***************************************************************************
 *
 *  CDirectSoundCaptureBuffer
 *
 *  Description:
 *      DirectSoundCapture Buffer object constructor.
 *
 *  Arguments:
 *      CDirectSoundCapture * [in]: pointer to the parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::CDirectSoundCaptureBuffer"

CDirectSoundCaptureBuffer::CDirectSoundCaptureBuffer(CDirectSoundCapture *pDSC)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundBuffer);

    // Initialize defaults
    m_pImpDirectSoundCaptureBuffer = NULL;
    m_pImpDirectSoundNotify = NULL;
    m_pDSC = pDSC;
    m_pDeviceBuffer = NULL;
    m_pwfxFormat = NULL;
    m_hWndFocus = NULL;
    m_fxChain = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    // Register with the parent
    m_pDSC->AddBufferToList(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundCaptureBuffer
 *
 *  Description:
 *      DirectSoundCapture Buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::~CDirectSoundCaptureBuffer"

CDirectSoundCaptureBuffer::~CDirectSoundCaptureBuffer()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundCaptureBuffer);

    // Free up our FX chain, if present
    DELETE(m_fxChain);

    // Unregister with the parent
    m_pDSC->RemoveBufferFromList(this);

    g_pDsAdmin->UpdateCaptureState();
    DPF(DPFLVL_MOREINFO, "Updated focus on destructor.");

    // Free all interfaces
    DELETE(m_pImpDirectSoundNotify);
    DELETE(m_pImpDirectSoundCaptureBuffer);

    // Free the device buffer
    RELEASE(m_pDeviceBuffer);

    // Free memory
    MEMFREE(m_pDSCFXDesc);
    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      LPDIRECTSOUNDCAPTURE [in]: parent DirectSound object.
 *      LPDSCBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Initialize"

HRESULT CDirectSoundCaptureBuffer::Initialize(LPCDSCBUFFERDESC pDscbDesc)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwFlags = pDscbDesc->dwFlags;
    DSCBCAPS                dscbc;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);

    if (dwFlags & DSCBCAPS_STRICTFOCUS)
        dwFlags |= DSCBCAPS_FOCUSAWARE;  // Implied by DSCBCAPS_STRICTFOCUS

    if (dwFlags & DSCBCAPS_CTRLVOLUME)
        hr = m_pDSC->m_pDevice->HasVolCtrl();

    // Initialize default format
    if(SUCCEEDED(hr))
    {
        m_pwfxFormat = CopyWfxAlloc(pDscbDesc->lpwfxFormat);
        hr = HRFROMP(m_pwfxFormat);
    }

    // Make a copy of the FX descriptor
    if(SUCCEEDED(hr))
    {
        m_dwFXCount = pDscbDesc->dwFXCount;
        if(m_dwFXCount > 0)
        {
            m_pDSCFXDesc = CopyDSCFXDescAlloc(m_dwFXCount, pDscbDesc->lpDSCFXDesc);
            hr = HRFROMP(m_pDSCFXDesc);
        }
    }

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        DELETE(m_fxChain);

        if (pDscbDesc->dwFXCount != 0)
        {
            // Create the FX chain requested
            m_fxChain = NEW(CCaptureEffectChain(this));
            hr = HRFROMP(m_fxChain);

            if (SUCCEEDED(hr))
                hr = m_fxChain->Initialize(pDscbDesc->dwFXCount, pDscbDesc->lpDSCFXDesc);

            if (FAILED(hr))
                DELETE(m_fxChain);
        }
    }

    // Create the device buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->CreateBuffer(dwFlags,
                                             pDscbDesc->dwBufferBytes,
                                             m_pwfxFormat,
                                             m_fxChain,
                                             NULL,
                                             &m_pDeviceBuffer);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pDeviceBuffer);
    }

    // Save the buffer size and flags for quick reference
    if(SUCCEEDED(hr))
    {
        InitStruct(&dscbc, sizeof(dscbc));

        hr = m_pDeviceBuffer->GetCaps(&dscbc);
    }

    if(SUCCEEDED(hr))
    {
        m_dwBufferBytes = dscbc.dwBufferBytes;
        m_dwBufferFlags = dscbc.dwFlags;
    }

    // Register the capture interfaces with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundCaptureBuffer, this, &m_pImpDirectSoundCaptureBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSoundCaptureBuffer7_1, m_pImpDirectSoundCaptureBuffer, (IDirectSoundCaptureBuffer7_1*)m_pImpDirectSoundCaptureBuffer);
    }

    if(SUCCEEDED(hr) && GetDsVersion() >= DSVERSION_DX8)
    {
        hr = RegisterInterface(IID_IDirectSoundCaptureBuffer8, m_pImpDirectSoundCaptureBuffer, (IDirectSoundCaptureBuffer8*)m_pImpDirectSoundCaptureBuffer);
    }

    // Register the notification interfaces with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundNotify, this, &m_pImpDirectSoundNotify);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Queries capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetCaps"

HRESULT CDirectSoundCaptureBuffer::GetCaps(LPDSCBCAPS pDscbCaps)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDeviceBuffer->GetCaps(pDscbCaps);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: size of the format structure.  On entry, this
 *                        must be initialized to the size of the structure.
 *                        On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetFormat"

HRESULT CDirectSoundCaptureBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CopyWfxApi(m_pwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetNotificationPositions"

HRESULT CDirectSoundCaptureBuffer::SetNotificationPositions(DWORD cpn, LPCDSBPOSITIONNOTIFY pdsbpn)
{
    HRESULT                 hr = DS_OK;
    LPDSBPOSITIONNOTIFY     paNotesOrdered = NULL;
    DWORD                   dwState;

    DPF_ENTER();

    // Validate notifications
    if (SUCCEEDED(hr))
    {
        hr = ValidateNotificationPositions(m_dwBufferBytes,
                                           cpn,
                                           pdsbpn,
                                           m_pwfxFormat->nBlockAlign,
                                           &paNotesOrdered);
    }

    // We must be stopped in order to set notification positions
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr) && dwState & VAD_BUFFERSTATE_STARTED)
        {
            RPF(DPFLVL_ERROR, "Buffer must be stopped before setting notification positions");
            hr = DSERR_INVALIDCALL;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->SetNotificationPositions(cpn, paNotesOrdered);
    }

    MEMFREE(paNotesOrdered);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetCurrentPosition"

HRESULT CDirectSoundCaptureBuffer::GetCurrentPosition(LPDWORD pdwCapture, LPDWORD pdwRead)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwCapture;
    DWORD                   dwRead;

    DPF_ENTER();

    if(SUCCEEDED(hr))
    {
        // We save the position to local variables so that the object we're
        // calling into doesn't have to worry about whether one or both of
        // the arguments are NULL.
        hr = m_pDeviceBuffer->GetCursorPosition(&dwCapture, &dwRead);
    }

    if(SUCCEEDED(hr))
    {
        if(pdwCapture)
        {
            *pdwCapture = BLOCKALIGN(dwCapture, m_pwfxFormat->nBlockAlign);
        }

        if(pdwRead)
        {
            *pdwRead = BLOCKALIGN(dwRead, m_pwfxFormat->nBlockAlign);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetStatus"

HRESULT CDirectSoundCaptureBuffer::GetStatus(LPDWORD pdwStatus)
{
    DWORD                   dwState;
    DPF_ENTER();

    HRESULT hr = m_pDeviceBuffer->GetState(&dwState);

    // Convert to DSCBSTATUS
    if(SUCCEEDED(hr))
    {
        if(dwState & VAD_BUFFERSTATE_STARTED)
        {
            *pdwStatus = DSCBSTATUS_CAPTURING;
        }
        else
        {
            *pdwStatus = 0;
        }

        if(dwState & VAD_BUFFERSTATE_LOOPING)
        {
            *pdwStatus |= DSCBSTATUS_LOOPING;
        }

        if(dwState & (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE))
        {
            // These flags should never be set for non-FOCUSAWARE buffers
            ASSERT(m_dwBufferFlags & DSCBCAPS_FOCUSAWARE);
            *pdwStatus |= DSCBSTATUS_LOSTFOCUS;
        }

        if(dwState & VAD_BUFFERSTATE_INFOCUS)
        {
            // This flag should never be set for non-FOCUSAWARE buffers
            ASSERT(m_dwBufferFlags & DSCBCAPS_FOCUSAWARE);
            *pdwStatus |= DSCBSTATUS_INFOCUS;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Start
 *
 *  Description:
 *      Starts the buffer capturing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Start"

HRESULT CDirectSoundCaptureBuffer::Start(DWORD dwFlags)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if ((m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) && m_hWndFocus == NULL)
    {
        hr = DSERR_INVALIDCALL;
    }

    if (SUCCEEDED(hr))
    {
        // Start the buffer capturing
        DWORD dwState = VAD_BUFFERSTATE_STARTED;
        if (dwFlags & DSCBSTART_LOOPING)
            dwState |= VAD_BUFFERSTATE_LOOPING;

        hr = m_pDeviceBuffer->SetState(dwState);

#ifdef SHARED_THREAD_LIST
        if (hr == DSERR_INVALIDCALL && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
        {
            // We probably failed because the device is allocated; return success
            hr = DS_OK;
        }
        g_pDsAdmin->WriteCaptureFocusList();
#endif
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops capturing to the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Stop"

HRESULT CDirectSoundCaptureBuffer::Stop(void)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // Set the buffer state
    hr = m_pDeviceBuffer->SetState(VAD_BUFFERSTATE_STOPPED);

#ifdef SHARED_THREAD_LIST
    g_pDsAdmin->WriteCaptureFocusList();
#endif

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for reading.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: flags for lock operation. Can be DSCBLOCK_ENTIREBUFFER.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Lock"

HRESULT CDirectSoundCaptureBuffer::Lock(DWORD dwReadCursor,
                                        DWORD dwReadBytes,
                                        LPVOID *ppvAudioPtr1,
                                        LPDWORD pdwAudioBytes1,
                                        LPVOID *ppvAudioPtr2,
                                        LPDWORD pdwAudioBytes2,
                                        DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Read Cursor out of range?
    if (dwReadCursor >= m_dwBufferBytes)
    {
        hr = DSERR_INVALIDPARAM;
    }

    // Check for invalid lock flags
    if (SUCCEEDED(hr) && (dwFlags & ~DSCBLOCK_VALIDFLAGS))
    {
        hr = DSERR_INVALIDPARAM;
    }

    // Lock entire buffer?
    if (SUCCEEDED(hr))
    {
        if (dwFlags & DSCBLOCK_ENTIREBUFFER)
        {
            dwReadBytes = m_dwBufferBytes;
        }
        // Read more than buffer size?
        else if (dwReadBytes > m_dwBufferBytes || dwReadBytes == 0)
        {
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Lock the device buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Lock(dwReadCursor, dwReadBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Unlock"

HRESULT CDirectSoundCaptureBuffer::Unlock(LPVOID pvAudioPtr1,
                                          DWORD dwAudioBytes1,
                                          LPVOID pvAudioPtr2,
                                          DWORD dwAudioBytes2)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Unlock the device buffer.
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetVolume"

HRESULT CDirectSoundCaptureBuffer::SetVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check whether the buffer has capture focus
    if (SUCCEEDED(hr) && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        DWORD dwState;
        m_pDeviceBuffer->GetState(&dwState);
        if (!(dwState & VAD_BUFFERSTATE_INFOCUS))
        {
            DPF(DPFLVL_ERROR, "Buffer doesn't have capture focus");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->SetVolume(lVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Gets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetVolume"

HRESULT CDirectSoundCaptureBuffer::GetVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Get device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->GetVolume(plVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMicVolume
 *
 *  Description:
 *      Sets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetMicVolume"

HRESULT CDirectSoundCaptureBuffer::SetMicVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check whether the buffer has capture focus
    if (SUCCEEDED(hr) && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        DWORD dwState;
        m_pDeviceBuffer->GetState(&dwState);
        if (!(dwState & VAD_BUFFERSTATE_INFOCUS))
        {
            DPF(DPFLVL_ERROR, "Buffer doesn't have capture focus");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->SetMicVolume(lVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetMicVolume
 *
 *  Description:
 *      Gets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetMicVolume"

HRESULT CDirectSoundCaptureBuffer::GetMicVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Get device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->GetMicVolume(plVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnableMic
 *
 *  Description:
 *      Enables/disables the microphone line on this capture buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable the microphone, FALSE to disable it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::EnableMic"

HRESULT CDirectSoundCaptureBuffer::EnableMic(BOOL fEnable)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check whether the buffer has capture focus
    if (SUCCEEDED(hr) && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        DWORD dwState;
        m_pDeviceBuffer->GetState(&dwState);
        if (!(dwState & VAD_BUFFERSTATE_INFOCUS))
        {
            DPF(DPFLVL_ERROR, "Buffer doesn't have capture focus");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->EnableMic(fEnable);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  YieldFocus
 *
 *  Description:
 *      Yields the capture focus to another capture buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::YieldFocus"

HRESULT CDirectSoundCaptureBuffer::YieldFocus(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // This is only valid if we're focus-aware and have a focus window
    if (!(m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) || !m_hWndFocus)
    {
        hr = DSERR_INVALIDCALL;
    }
    else
    {
        // Oh, it's valid...
        m_pDeviceBuffer->m_fYieldedFocus = TRUE;
        g_pDsAdmin->UpdateCaptureState();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ClaimFocus
 *
 *  Description:
 *      Regains the capture focus.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::ClaimFocus"

HRESULT CDirectSoundCaptureBuffer::ClaimFocus(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // This is only valid if we're focus-aware and have a focus window
    if (!(m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) || !m_hWndFocus)
    {
        hr = DSERR_INVALIDCALL;
    }
    else
    {
        // Oh, it's valid...
        m_pDeviceBuffer->m_fYieldedFocus = FALSE;
        g_pDsAdmin->UpdateCaptureState();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetFocusHWND
 *
 *  Description:
 *      Sets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND [in]: HWND to be associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetFocusHWND"

HRESULT CDirectSoundCaptureBuffer::SetFocusHWND(HWND hwndMainWindow)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        m_hWndFocus = hwndMainWindow;
        g_pDsAdmin->UpdateCaptureState();
    }
    else
    {
        hr = DSERR_INVALIDCALL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFocusHWND
 *
 *  Description:
 *      Gets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND * [out]: receives HWND associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetFocusHWND"

HRESULT CDirectSoundCaptureBuffer::GetFocusHWND(HWND *pHwndMainWindow)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        *pHwndMainWindow = m_hWndFocus;
    }
    else
    {
        hr = DSERR_INVALIDCALL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnableFocusNotifications
 *
 *  Description:
 *      Requests focus change notifications to be sent.
 *
 *  Arguments:
 *      HANDLE [in]: event to signal when a capture focus change occurs.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::EnableFocusNotifications"

HRESULT CDirectSoundCaptureBuffer::EnableFocusNotifications(HANDLE hFocusEvent)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        m_pDeviceBuffer->m_hEventFocus = hFocusEvent;
    }
    else
    {
        hr = DSERR_INVALIDCALL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ChangeFocus
 *
 *  Description:
 *      Notifies the buffer of the new HWND with focus.
 *
 *  Arguments:
 *      HWND [in]: Window handle that has focus.
 *
 *  Returns:
 *      None.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::ChangeFocus"

HRESULT CDirectSoundCaptureBuffer::ChangeFocus(HWND hWndFocus)
{
    HRESULT hr = DS_OK;

    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        DWORD dwState;

        #ifdef WINNT
        // On NT platforms we only grant an application capture focus if it is running
        // in the Terminal Services session that currently owns the console, to prevent
        // a Fast User Switching scenario in which an app in an inactive session could
        // "spy" on the audio being recorded at the console (Whistler bug 350622).
        if (USER_SHARED_DATA->ActiveConsoleId != NtCurrentPeb()->SessionId)
        {
            dwState = VAD_BUFFERSTATE_LOSTCONSOLE;
        }
        else
        #endif
        if (hWndFocus == m_hWndFocus)
        {
            dwState = VAD_BUFFERSTATE_INFOCUS;
        }
        else
        {
            dwState = VAD_BUFFERSTATE_OUTOFFOCUS;
        }

        hr = m_pDeviceBuffer->SetState(dwState);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface. 
 *      LPVOID * [out]: Receives the interface requested.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetObjectInPath"

HRESULT CDirectSoundCaptureBuffer::GetObjectInPath
(
    REFGUID guidObject,
    DWORD dwIndex,
    REFGUID iidInterface,
    LPVOID *ppObject
)
{
    HRESULT hr;
    DPF_ENTER();

    if(!(m_dwBufferFlags & DSCBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Buffer was not created with DSCBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }
    else if (!HasFX())
    {
        hr = DSERR_OBJECTNOTFOUND;
    }
    else
    {
        hr = m_fxChain->GetEffectInterface(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFXStatus
 *
 *  Description:
 *      Obtains the current statuses of the effects on this buffer.
 *
 *  Arguments:
 *      DWORD [in]: length of array pointed to by second argument.
 *      LPDWORD [out]: pointer to array which receives the statuses.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetFXStatus"

HRESULT CDirectSoundCaptureBuffer::GetFXStatus
(
    DWORD   dwFXCount,
    LPDWORD pdwResultCodes
)
{
    HRESULT                 hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    ASSERT(!pdwResultCodes || IS_VALID_WRITE_PTR(pdwResultCodes, dwFXCount * sizeof *pdwResultCodes));

    if (pdwResultCodes && m_fxChain)
    {
        hr = m_fxChain->GetFxStatus(pdwResultCodes);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsbufcfg.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbufcfg.cpp
 *  Content:    DirectSound Buffer Configuration 
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 11/17/99     jimge   Created.
 * 11/24/99     petchey Completed implementation.
 *
 ***************************************************************************/

#include "dsoundi.h"

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::QueryInterface"

HRESULT CDirectSoundBufferConfig::QueryInterface(REFIID riid, BOOL fInternalQuery, LPVOID *ppvObj)
{
    if (IsEqualGUID(riid, CLSID_PRIVATE_CDirectSoundBufferConfig))
    {
        *ppvObj = this;
        return S_OK;
    }
    return CUnknown::QueryInterface(riid, fInternalQuery, ppvObj);
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::CDirectSoundBufferConfig"

CDirectSoundBufferConfig::CDirectSoundBufferConfig()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundBufferConfig);

    CreateAndRegisterInterface(this, IID_IPersistStream, this, &m_pImpPersistStream);
    // FIXME: Should RegisterInterface(IID_IPersist, m_pImpPersistStream, (IPersist*)m_pImpPersistStream) too?
    CreateAndRegisterInterface(this, IID_IDirectMusicObject, this, &m_pImpDirectMusicObject);

    m_pdwFuncIDs = NULL;
    m_dwFuncIDsCount = 0;

    m_pDXDMOMapList = NULL;
    m_dwDXDMOMapCount = 0;

    ZeroMemory(&m_DMUSObjectDesc,sizeof(m_DMUSObjectDesc));
    ZeroMemory(&m_DSBufferDesc,sizeof(m_DSBufferDesc));

    m_DMUSObjectDesc.dwSize      = sizeof(m_DMUSObjectDesc);
    m_DMUSObjectDesc.dwValidData = DMUS_OBJ_CLASS;
    m_DMUSObjectDesc.guidClass   = CLSID_DirectSoundBufferConfig;

    m_fLoadFlags = 0;

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::~CDirectSoundBufferConfig"

CDirectSoundBufferConfig::~CDirectSoundBufferConfig()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBufferConfig);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    if (m_pDXDMOMapList)
    {
        CDXDMODesc *pObj = m_pDXDMOMapList;
        CDXDMODesc *pNextObj;
        while (pObj) 
        {
            pNextObj = pObj->pNext;
            if (pObj->m_pMediaObject)
            {
                // We are releasing an object in another DLL.  If we are called
                // via an AbsoluteRelease call, this DLL may already be unloaded.
                try
                {
                    pObj->m_pMediaObject->Release();
                }
                catch (...) {}
            }
            DELETE(pObj);
            pObj = pNextObj;
        }
    }
    MEMFREE(m_pdwFuncIDs);
    DELETE(m_pImpPersistStream);
    DELETE(m_pImpDirectMusicObject);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::GetClassID"

HRESULT CDirectSoundBufferConfig::GetClassID(CLSID *pClassID)
{
    DPF_ENTER();

    HRESULT hr = S_OK;

    *pClassID = CLSID_DirectSoundBufferConfig;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::Load"

HRESULT CDirectSoundBufferConfig::Load(IStream *pStream)
{
    DPF_ENTER();

    //
    // Parse file
    //

    CRiffParser Parser(pStream);
    HRESULT hr = S_OK;
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckChild;
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_DSBC_FORM))
    {
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &m_DMUSObjectDesc.guidObject, sizeof(GUID));
                m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case DMUS_FOURCC_DSBD_CHUNK:
                hr = Parser.Read( &m_DSBufferDesc, sizeof(DSOUND_IO_DSBUFFERDESC) );
                m_fLoadFlags |= DSBCFG_DSBD;
                break;
            case DMUS_FOURCC_BSID_CHUNK:
                m_pdwFuncIDs = (LPDWORD)MEMALLOC_A(char,ckNext.cksize);
                if ( m_pdwFuncIDs )
                {
                    hr = Parser.Read( m_pdwFuncIDs, ckNext.cksize );
                    if( SUCCEEDED(hr) )
                    {
                        m_fLoadFlags |= DSBCFG_BSID;
                        m_dwFuncIDsCount = ckNext.cksize/sizeof(DWORD);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
            case DMUS_FOURCC_DS3D_CHUNK:
                hr = Parser.Read( &m_DS3DDesc, sizeof(DSOUND_IO_3D) );
                m_fLoadFlags |= DSBCFG_DS3D;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckChild);
                    while(Parser.NextChunk(&hr))
                    {
                        if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&m_DMUSObjectDesc.wszName, DMUS_MAX_NAME * sizeof(WCHAR));
                            m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;
                case DMUS_FOURCC_DSBC_LIST:
                    Parser.EnterList(&ckChild);
                    while(Parser.NextChunk(&hr))
                    {
                        if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_DSFX_FORM))
                        {
                            hr = LoadFx(&Parser);
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_INVALIDCHUNK;
    }

    if (SUCCEEDED(hr))
    {
        m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_LOADED;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::GetDescriptor"

HRESULT CDirectSoundBufferConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    DPF_ENTER();

    HRESULT hr = S_OK;

    CopyMemory(pDesc, &m_DMUSObjectDesc, sizeof(m_DMUSObjectDesc));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::SetDescriptor"

HRESULT CDirectSoundBufferConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    DPF_ENTER();

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_DMUSObjectDesc.guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            lstrcpyW(m_DMUSObjectDesc.wszName, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            lstrcpyW(m_DMUSObjectDesc.wszCategory, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_DMUSObjectDesc.wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if ( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_DMUSObjectDesc.vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_DMUSObjectDesc.ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }

        m_DMUSObjectDesc.dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::ParseDescriptor"

HRESULT CDirectSoundBufferConfig::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    DPF_ENTER();
    CRiffParser Parser(pStream);
    RIFFIO ckMain;
	RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_DSBC_FORM))
    {
        dwValidData = 0;
        Parser.EnterList(&ckNext);
	    while(Parser.NextChunk(&hr))
	    {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_GUID_CHUNK:
				hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
				dwValidData |= DMUS_OBJ_OBJECT;
				break;
            case DMUS_FOURCC_VERSION_CHUNK:
				hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
				dwValidData |= DMUS_OBJ_VERSION;
				break;
			case DMUS_FOURCC_CATEGORY_CHUNK:
				hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
				dwValidData |= DMUS_OBJ_CATEGORY;
				break;
			case DMUS_FOURCC_DATE_CHUNK:
				hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
				break;
			case FOURCC_LIST:
				switch(ckNext.fccType)
				{
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
					{
						if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
						{
							hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            dwValidData |= DMUS_OBJ_NAME;
						}
					}
                    Parser.LeaveList();
					break;            
				}
				break;
		    }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::Save"

HRESULT CDirectSoundBufferConfig::Save(IStream *pStream, BOOL fClearDirty)
{
    DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::GetSizeMax"

HRESULT CDirectSoundBufferConfig::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::IsDirty"

HRESULT CDirectSoundBufferConfig::IsDirty()
{
    DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::LoadFx"

HRESULT CDirectSoundBufferConfig::LoadFx(CRiffParser *pParser)
{
    DPF_ENTER();

    RIFFIO ckNext;
    
    DSOUND_IO_DXDMO_HEADER ioDxDMOHdr;
    CDXDMODesc *pCurrDXDMODesc = NULL;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        if(ckNext.ckid == DMUS_FOURCC_DSFX_CHUNK)
        {    
            hr = pParser->Read(&ioDxDMOHdr, sizeof(DSOUND_IO_DXDMO_HEADER));
            if(SUCCEEDED(hr) && (ioDxDMOHdr.dwReserved != 0 || ioDxDMOHdr.guidReserved != GUID_NULL))
            {
                DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: reserved fields must be zero");
                hr = DMUS_E_INVALIDCHUNK;
            }

            if (SUCCEEDED(hr) && (ioDxDMOHdr.guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                || ioDxDMOHdr.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                ))
            {
                if (ioDxDMOHdr.guidSendBuffer == GUID_NULL)
                {
                    DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: send effect must specify a non-null guidSendBuffer");
                    hr = DMUS_E_INVALIDCHUNK;
                }
            }
            else
            {
                if (ioDxDMOHdr.guidSendBuffer != GUID_NULL)
                {
                    DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: not a send effect, so guidSendBuffer must be null");
                    hr = DMUS_E_INVALIDCHUNK;
                }
            }

            if(SUCCEEDED(hr) && (m_fLoadFlags & DSBCFG_DSBD))
            {
                pCurrDXDMODesc = NULL;

                CDXDMODesc *pDXDMODesc = NEW(CDXDMODesc);
                hr = HRFROMP(pDXDMODesc);
                if (SUCCEEDED(hr))
                {
                    pCurrDXDMODesc = pDXDMODesc;
                    pDXDMODesc->m_dwEffectFlags = ioDxDMOHdr.dwEffectFlags;
                    pDXDMODesc->m_guidDSFXClass = ioDxDMOHdr.guidDSFXClass;
                    pDXDMODesc->m_guidSendBuffer = ioDxDMOHdr.guidSendBuffer;
                    pDXDMODesc->m_dwReserved = ioDxDMOHdr.dwReserved;
                    pDXDMODesc->m_lSendLevel = 0;

                    if (!IsEqualGUID(pDXDMODesc->m_guidDSFXClass, GUID_DSFX_SEND)
#ifdef ENABLE_I3DL2SOURCE
                        && !IsEqualGUID(pDXDMODesc->m_guidDSFXClass, GUID_DSFX_STANDARD_I3DL2SOURCE)
#endif
                        )
                    {
                        hr = CoCreateInstance(pDXDMODesc->m_guidDSFXClass, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&pDXDMODesc->m_pMediaObject);
                    }

                    if (SUCCEEDED(hr))
                    {
                        AddDXDMODesc(pDXDMODesc);
                        // FIXME: we shouldn't be ferreting away all this info (m_pDXDMOMapList etc);
                        // once we have the DMOs, we don't need all this data just to call Clone()
                        m_fLoadFlags |= DSBCFG_DSFX;
                    }

                    if (FAILED(hr))
                    {
                        DELETE(pDXDMODesc);
                    }
                }
            }
        }
        else if(ckNext.ckid == DMUS_FOURCC_DSFX_DATA && pCurrDXDMODesc)
        {    
            if (pCurrDXDMODesc->m_pMediaObject)
            {
                IPersistStream* pPersistStream = NULL;
                hr = pCurrDXDMODesc->m_pMediaObject->QueryInterface(IID_IPersistStream,(void**)&pPersistStream);
                if (SUCCEEDED(hr))
                {
                    pParser->MarkPosition();
                    hr = pPersistStream->Load(pParser->GetStream());
                    pParser->SeekForward();
                    pPersistStream->Release();
                }
            }
            // Special case for Send Effects -- Read the send level manually.  The
            // Send effect doesn't implement IPersistStream.
            else if (IsEqualGUID(pCurrDXDMODesc->m_guidDSFXClass, GUID_DSFX_SEND))
            {
                hr = pParser->Read((void*)&pCurrDXDMODesc->m_lSendLevel, sizeof(long));
                if (SUCCEEDED(hr))
                {
                    // validate the SendLevel
                    if (!((pCurrDXDMODesc->m_lSendLevel <= 0) && (pCurrDXDMODesc->m_lSendLevel >= -10000)))
                    {
                        // Invalid Send Level
                        pCurrDXDMODesc->m_lSendLevel = 0;
                        hr = DSERR_INVALIDPARAM;
                    }
                }
            }
            pCurrDXDMODesc = NULL;    // clear this just in case 
        }
    }
    pParser->LeaveList();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsclock.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.h
 *  Content:    The clock code from orginally derived from dmsynth DX7
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/25/0     petchey	Created
 *
 ***************************************************************************/

#include "dsoundi.h"

#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()
{
	m_rfOffset = 0;
    m_rfBaseOffset = 0;
}

// When the clock starts, it needs to mark down the 
// difference between the time it is given and its concept of time. 

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)
{
	m_rfOffset = 0;
    m_rfBaseOffset = rfMasterTime - rfSlaveTime;
}	


// Convert the passed time to use the same base as the master clock.

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
	rfSlaveTime += m_rfBaseOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfBaseOffset;
	*prfTime = rfSlaveTime;
}

/*	SyncToMaster provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/
void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime, BOOL fLockToMaster)
{
	rfSlaveTime += (m_rfOffset + m_rfBaseOffset);
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
    // If fLockToMaster is true, we want to adjust our offset that we use for conversions, 
    // so our clock will slave to the master clock.
    if (fLockToMaster)
    {
        m_rfBaseOffset -= rfSlaveTime;
    }
    // Otherwise, we want to put a value into m_rfOffset that will be used to 
    // tweak the master clock so it will slave to our time.
    else
    {
	    m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
    }
}

CSampleClock::CSampleClock()
{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)
{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

CSampleClock::~CSampleClock()
{
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prfTime)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefToSampleTime(REFERENCE_TIME rfTime)
{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	rfTime += m_dwStart;
	return rfTime;
}

void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock, BOOL fLockToMaster)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime,fLockToMaster);
	}
}


CDirectSoundClock::CDirectSoundClock()
{
    m_pDSSink  = NULL;
}

void CDirectSoundClock::Init(CDirectSoundSink *pDSSink)
{
    m_pDSSink = pDSSink;
}

HRESULT CDirectSoundClock::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID( riid, IID_IReferenceClock ) ||
        ::IsEqualIID( riid, IID_IUnknown ) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDirectSoundClock::AddRef()
{
    if (m_pDSSink)
    {
        return m_pDSSink->AddRef();
    }
    else return 0;
}

ULONG CDirectSoundClock::Release()
{
    if (m_pDSSink)
    {
        return m_pDSSink->Release();
    }
    else return 0;
}

HRESULT STDMETHODCALLTYPE CDirectSoundClock::AdviseTime(REFERENCE_TIME /*baseTime*/,
                                                        REFERENCE_TIME /*streamTime*/,
                                                        HANDLE /*hEvent*/,
                                                        DWORD * /*pdwAdviseCookie*/)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CDirectSoundClock::AdvisePeriodic(REFERENCE_TIME /*startTime*/,
                                                            REFERENCE_TIME /*periodTime*/,
                                                            HANDLE /*hSemaphore*/,
                                                            DWORD * /*pdwAdviseCookie*/)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CDirectSoundClock::Unadvise( DWORD /*dwAdviseCookie*/ )
{
    return E_NOTIMPL;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundClock::GetTime"

HRESULT STDMETHODCALLTYPE CDirectSoundClock::GetTime(LPREFERENCE_TIME pTime)
{
    HRESULT hr = E_FAIL;

    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

    if (m_pDSSink != NULL)
    {
        REFERENCE_TIME rtCompare;
        if (m_pDSSink->m_pIMasterClock)
        {

            m_pDSSink->m_pIMasterClock->GetTime(&rtCompare);

            hr = m_pDSSink->SampleToRefTime(m_pDSSink->ByteToSample(m_pDSSink->m_llAbsWrite), pTime);


            if (FAILED(hr))
            {
                DPF(DPFLVL_WARNING, "Sink Latency Clock: SampleToRefTime failed");
                return hr;
            }

            if (*pTime < rtCompare)
            {
                // Make this DPFLVL_WARNING level again when 33786 is fixed
                DPF(DPFLVL_INFO, "Sink Latency Clock off. Latency time is %ldms, Master time is %ldms",
                    (long) (*pTime / 10000), (long) (rtCompare / 10000));
                *pTime = rtCompare;
            }
            else if (*pTime > (rtCompare + (10000 * 1000)))
            {
                // Make this DPFLVL_WARNING level again when 33786 is fixed
                DPF(DPFLVL_INFO, "Sink Latency Clock off. Latency time is %ldms, Master time is %ldms",
                    (long) (*pTime / 10000), (long) (rtCompare / 10000));
                *pTime = rtCompare + (10000 * 1000);
            }

            hr = S_OK;
        }
        else
        {
            DPF(DPFLVL_WARNING, "Sink Latency Clock - GetTime called with no master clock");
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dscap.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscap.h
 *  Content:    DirectSoundCapture object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   5/25/97    johnnyl Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __DSCAP_H__
#define __DSCAP_H__

#ifdef __cplusplus

//
// The main DirectSoundCapture object
//

class CDirectSoundCapture : public CUnknown
{
    friend class CDirectSoundCaptureBuffer;
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundPrivate;
    friend class CDirectSoundFullDuplex;

private:

    CCaptureDevice *                    m_pDevice;      // The audio device
    CList<CDirectSoundCaptureBuffer *>  m_lstBuffers;   // List of capture buffers
    DSCCAPS                             m_dscCaps;      // Device caps
    HKEY                                m_hkeyParent;   // Root key for this device
    HRESULT                             m_hrInit;       // Has the object been initialized?
    CDirectSoundFullDuplex *            m_pFullDuplex;  // Owning full-duplex object

    // Interfaces
    CImpDirectSoundCapture<CDirectSoundCapture> *m_pImpDirectSoundCapture;

public:

    CDirectSoundCapture();
    CDirectSoundCapture(CUnknown*);
    virtual ~CDirectSoundCapture();

    // Creation
    virtual HRESULT Initialize(LPCGUID, CDirectSoundFullDuplex *);
    HRESULT IsInit(void) {return m_hrInit;}

    // Functionality versioning
    virtual void SetDsVersion(DSVERSION);

    // Caps
    virtual HRESULT GetCaps(LPDSCCAPS);

    // Buffers
    virtual HRESULT CreateCaptureBuffer(LPCDSCBUFFERDESC, CDirectSoundCaptureBuffer **);
    virtual void AddBufferToList(CDirectSoundCaptureBuffer* pBuffer) {m_lstBuffers.AddNodeToList(pBuffer);}
    virtual void RemoveBufferFromList(CDirectSoundCaptureBuffer* pBuffer) {m_lstBuffers.RemoveDataFromList(pBuffer);}

    // AEC
    virtual BOOL HasMicrosoftAEC(void);
};


//
// The DirectSoundCapture Buffer object
//

class CDirectSoundCaptureBuffer : public CUnknown
{
    friend class CDirectSoundCapture;
    friend class CDirectSoundAdministrator;

private:

    CDirectSoundCapture *   m_pDSC;                     // Parent DirectSoundCapture object
    CCaptureWaveBuffer *    m_pDeviceBuffer;            // The device buffer
    LPWAVEFORMATEX          m_pwfxFormat;               // Current format
    DWORD                   m_dwFXCount;                // Number of capture effects
    LPDSCEFFECTDESC         m_pDSCFXDesc;               // Array of capture effects
    DWORD                   m_dwBufferFlags;            // Creation flags
    DWORD                   m_dwBufferBytes;            // Buffer size
    HWND                    m_hWndFocus;                // Focus window
    HRESULT                 m_hrInit;                   // Has the object been initialized?
    CCaptureEffectChain *   m_fxChain;                  // The effects chain object

    // Interfaces
    CImpDirectSoundCaptureBuffer<CDirectSoundCaptureBuffer> *m_pImpDirectSoundCaptureBuffer;
    CImpDirectSoundNotify<CDirectSoundCaptureBuffer> *m_pImpDirectSoundNotify;

    // Methods
    HRESULT ChangeFocus(HWND hWndFocus);

public:

    CDirectSoundCaptureBuffer(CDirectSoundCapture *);
    virtual ~CDirectSoundCaptureBuffer();

    // Creation
    virtual HRESULT Initialize(LPCDSCBUFFERDESC);
    HRESULT IsInit(void) {return m_hrInit;}

    // Caps
    virtual HRESULT GetCaps(LPDSCBCAPS);

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT GetStatus(LPDWORD);
    virtual HRESULT Start(DWORD);
    virtual HRESULT Stop(void);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);

    // New DirectSound 7.1 methods
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT GetVolume(LPLONG);
    virtual HRESULT SetMicVolume(LONG);
    virtual HRESULT GetMicVolume(LPLONG);
    virtual HRESULT EnableMic(BOOL);
    virtual HRESULT YieldFocus();
    virtual HRESULT ClaimFocus();
    virtual HRESULT SetFocusHWND(HWND);
    virtual HRESULT GetFocusHWND(HWND *);
    virtual HRESULT EnableFocusNotifications(HANDLE);

    // New DirectSound 8.0 methods
    HRESULT GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);
    HRESULT GetFXStatus(DWORD, LPDWORD);
    BOOL    HasFX()             {return m_fxChain != NULL;}
    BOOL    NeedsMicrosoftAEC() {return m_fxChain ? m_fxChain->NeedsMicrosoftAEC() : FALSE;}
};

#endif // __cplusplus

#endif // __DSCAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsclock.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.h
 *  Content:    The clock code from orginally derived from dmsynth DX7
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/25/0     petchey	Created
 *
 ***************************************************************************/

#ifndef __DSCLOCK_H__
#define __DSCLOCK_H__

#ifdef __cplusplus

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime,BOOL fLockToMaster);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { *prfTime = m_rfOffset; };
private:
	REFERENCE_TIME		m_rfOffset;
    REFERENCE_TIME      m_rfBaseOffset;
};

class CSampleClock
{
public:
						CSampleClock();
						~CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock,BOOL fLockToMaster);
	LONGLONG			RefToSampleTime(REFERENCE_TIME rfTime);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { m_PLClock.GetClockOffset(prfTime); };

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;			// Initial sample offset.
	DWORD				m_dwSampleRate;
};

class CDirectSoundClock : public IReferenceClock
{
public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
		/* [out] */ REFERENCE_TIME *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
		/* [in] */ DWORD dwAdviseCookie);

public: 
                CDirectSoundClock();
    void        Init(CDirectSoundSink *m_pDSSink);
    void        Stop();         // Call store current time as offset.
    void        Start();        // Call to reinstate running.
private:
    BOOL        m_fStopped;      // Currently changing configuration.
    CDirectSoundSink *m_pDSSink; // Pointer to parent sink object.
};

#endif // __cplusplus

#endif //__DSCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dscom.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscom.cpp
 *  Content:    COM/OLE helpers
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/26/97     dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CImpUnknown
 *
 *  Description:
 *      IUnknown implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: controlling unknown object.
 *      LPVOID [in]: ignored.  Provided for compatibility with other
 *                   interfaces' constructors.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::CImpUnknown"

CImpUnknown::CImpUnknown
(
    CUnknown *pUnknown,
    LPVOID pvIgnored
) : m_signature(INTSIG_IUNKNOWN)
{
    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_CONSTRUCT(CImpUnknown);

    // Initialize defaults
    m_pUnknown = pUnknown;
    m_ulRefCount = 0;
    m_fValid = FALSE;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpUnknown
 *
 *  Description:
 *      IUnknown implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::~CImpUnknown"

CImpUnknown::~CImpUnknown(void)
{
    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_DESTRUCT(CImpUnknown);

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  QueryInterface
 *
 *  Description:
 *      Queries the object for a given interface.
 *
 *  Arguments:
 *      REFIID [in]: interface id.
 *      LPVOID FAR * [out]: receives pointer to new interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::QueryInterface"

HRESULT STDMETHODCALLTYPE CImpUnknown::QueryInterface
(
    REFIID riid,
    LPVOID *ppvObj
)
{
    HRESULT                 hr  = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API2(IUnknown::QueryInterface, &riid, ppvObj);
    DPF_ENTER();

    if(!IS_VALID_IUNKNOWN(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&riid))
    {
        RPF(DPFLVL_ERROR, "Invalid interface id pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_WRITE_PTR(ppvObj, sizeof(LPVOID)))
        {
            *ppvObj = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid interface buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pUnknown->QueryInterface(riid, FALSE, ppvObj);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increases the object reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::AddRef"

ULONG STDMETHODCALLTYPE CImpUnknown::AddRef(void)
{
    ULONG                   ulRefCount  = MAX_ULONG;

    ENTER_DLL_MUTEX();
    DPF_API0(IUnknown::AddRef);
    DPF_ENTER();

    if(IS_VALID_IUNKNOWN(this))
    {
        ulRefCount = ::AddRef(&m_ulRefCount);
        m_pUnknown->AddRef();
    }
    else
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
    }

    DPF_API_LEAVE(ulRefCount);
    LEAVE_DLL_MUTEX();
    return ulRefCount;
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decreases the object reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::Release"

ULONG STDMETHODCALLTYPE CImpUnknown::Release(void)
{
    ULONG                   ulRefCount  = MAX_ULONG;

    ENTER_DLL_MUTEX();
    DPF_API0(IUnknown::Release);
    DPF_ENTER();

    if(IS_VALID_IUNKNOWN(this))
    {
        ulRefCount = ::Release(&m_ulRefCount);
        m_pUnknown->Release();
    }
    else
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
    }

    DPF_API_LEAVE(ulRefCount);
    LEAVE_DLL_MUTEX();
    return ulRefCount;
}


/***************************************************************************
 *
 *  CUnknown
 *
 *  Description:
 *      Unknown object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::CUnknown"

CUnknown::CUnknown(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CUnknown);

    // Initialize defaults
    m_pControllingUnknown = NULL;
    m_nVersion = DSVERSION_DX7;  // Baseline functional level is DirectX 7.0

    // Register the interface(s) with the interface manager.  Normally, this
    // would be done from the object's ::Initialize method, but we have to
    // guarantee that all objects can be QI'd for IUnknown, regardless of
    // whether they're initialized or not.
    CreateAndRegisterInterface(this, IID_IUnknown, this, &m_pImpUnknown);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CUnknown
 *
 *  Description:
 *      Unknown object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::CUnknown"

CUnknown::CUnknown
(
    CUnknown*               pControllingUnknown
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CUnknown);

    // Initialize defaults
    m_pControllingUnknown = pControllingUnknown;
    m_nVersion = DSVERSION_DX7;  // Baseline functional level is DirectX 7.0

    // Register the interface(s) with the interface manager.  Normally, this
    // would be done from the object's ::Initialize method, but we have to
    // guarantee that all objects can be QI'd for IUnknown, regardless of
    // whether they're initialized or not.
    CreateAndRegisterInterface(this, IID_IUnknown, this, &m_pImpUnknown);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CUnknown
 *
 *  Description:
 *      Unknown object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::~CUnknown"

CUnknown::~CUnknown(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CUnknown);

    // Free all interfaces
    DELETE(m_pImpUnknown);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QueryInterface
 *
 *  Description:
 *      Finds an interface in the list and returns a pointer to its
 *      implementation object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      LPVOID * [out]: recieves pointer to implementation object.
 *      BOOL [in]: TRUE if this is an internal query (i.e. from within
 *                 DirectSoundCreate for example).
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::QueryInterface"

HRESULT CUnknown::QueryInterface
(
    REFGUID     guid,
    BOOL        fInternalQuery,
    LPVOID*     ppvInterface
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(m_pControllingUnknown)
    {
        hr = m_pControllingUnknown->QueryInterface(guid, fInternalQuery, ppvInterface);
    }
    else
    {
        hr = NonDelegatingQueryInterface(guid, fInternalQuery, ppvInterface);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::AddRef"

ULONG
CUnknown::AddRef
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    if(m_pControllingUnknown)
    {
        ulRefCount = m_pControllingUnknown->AddRef();
    }
    else
    {
        ulRefCount = NonDelegatingAddRef();
    }

    DPF_LEAVE(ulRefCount);
    return ulRefCount;
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::Release"

ULONG
CUnknown::Release
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    if(m_pControllingUnknown)
    {
        ulRefCount = m_pControllingUnknown->Release();
    }
    else
    {
        ulRefCount = NonDelegatingRelease();
    }

    DPF_LEAVE(ulRefCount);
    return ulRefCount;
}


/***************************************************************************
 *
 *  RegisterInterface
 *
 *  Description:
 *      Registers a new interface with the object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      CImpUnknown * [in]: pointer to the CImpUnknown piece of the
 *                          interface.
 *      LPVOID [in]: pointer to the interface implementation object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::RegisterInterface"

HRESULT CUnknown::RegisterInterface
(
    REFGUID guid,
    CImpUnknown *pImpUnknown,
    LPVOID pvInterface
)
{
    INTERFACENODE           iface;
    HRESULT                 hr;

    DPF_ENTER();

    DPF(DPFLVL_MOREINFO, "Registering interface " DPF_GUID_STRING " at 0x%p", DPF_GUID_VAL(guid), pvInterface);

    ASSERT(!IS_NULL_GUID(&guid));

#ifdef DEBUG

    hr = FindInterface(guid, NULL);
    ASSERT(FAILED(hr));

#endif // DEBUG

    // Validate the interface
    pImpUnknown->m_ulRefCount = 0;
    pImpUnknown->m_fValid = TRUE;

    // Add the interface to the list
    iface.guid = guid;
    iface.pImpUnknown = pImpUnknown;
    iface.pvInterface = pvInterface;

    hr = HRFROMP(m_lstInterfaces.AddNodeToList(iface));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UnregisterInterface
 *
 *  Description:
 *      Removes a registered interface from the list.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::UnregisterInterface"

HRESULT CUnknown::UnregisterInterface
(
    REFGUID guid
)
{
    const BOOL              fAll    = IS_NULL_GUID(&guid);
    HRESULT                 hr      = DS_OK;
    CNode<INTERFACENODE> *  pNode;

    DPF_ENTER();

    do
    {
        // Find the node in the list
        if(fAll)
        {
            pNode = m_lstInterfaces.GetListHead();
        }
        else
        {
            hr = FindInterface(guid, &pNode);
        }

        if(FAILED(hr) || !pNode)
        {
            break;
        }

        DPF(DPFLVL_MOREINFO, "Unregistering interface " DPF_GUID_STRING, DPF_GUID_VAL(pNode->m_data.guid));

        // Invalidate the interface
        pNode->m_data.pImpUnknown->m_ulRefCount = 0;
        pNode->m_data.pImpUnknown->m_fValid = FALSE;

        // Remove the node from the list
        m_lstInterfaces.RemoveNodeFromList(pNode);
    }
    while(fAll);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  NonDelegatingQueryInterface
 *
 *  Description:
 *      Finds an interface in the list and returns a pointer to its
 *      implementation object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      LPVOID * [out]: recieves pointer to implementation object.
 *
 *  Returns:
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::NonDelegatingQueryInterface"

HRESULT
CUnknown::NonDelegatingQueryInterface
(
    REFGUID                 guid,
    BOOL                    fInternalQuery,
    LPVOID *                ppvInterface
)
{
    CNode<INTERFACENODE> *  pNode;
    HRESULT                 hr;

    DPF_ENTER();

    // Find the node in the list
    hr = FindInterface(guid, &pNode);

    // Increase the interface and object's reference counts
    if(SUCCEEDED(hr))
    {
        // Internal queries only addref the interface, not the object.
        // The reason for this is that interface reference counts are
        // initialized to 0, while objects reference counts are initialized
        // to 1.
        ::AddRef(&pNode->m_data.pImpUnknown->m_ulRefCount);

        if(!fInternalQuery)
        {
            AddRef();
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppvInterface = pNode->m_data.pvInterface;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindInterface
 *
 *  Description:
 *      Finds an interface in the list and returns a pointer to its
 *      implementation object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      CNode ** [out]: receives pointer to the node in the list.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::FindInterface"

HRESULT CUnknown::FindInterface
(
    REFGUID                 guid,
    CNode<INTERFACENODE>**  ppNode
)
{
    CNode<INTERFACENODE> *  pNode;
    HRESULT                 hr;

    DPF_ENTER();

    for(pNode = m_lstInterfaces.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if(guid == pNode->m_data.guid)
        {
            break;
        }
    }

    hr = pNode ? S_OK : E_NOINTERFACE;

    if(SUCCEEDED(hr) && ppNode)
    {
        *ppNode = pNode;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CClassFactory
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CClassFactory::CClassFactory"

ULONG CClassFactory::m_ulServerLockCount = 0;

CClassFactory::CClassFactory(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CClassFactory);

    // Register the interface(s) with the interface manager
    CreateAndRegisterInterface(this, IID_IClassFactory, this, &m_pImpClassFactory);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CClassFactory
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CClassFactory::~CClassFactory"

CClassFactory::~CClassFactory(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CClassFactory);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Free the interface(s)
    DELETE(m_pImpClassFactory);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  LockServer
 *
 *  Description:
 *      Locks or unlocks the dll.  Note that this function does not
 *      currently lock the application into memory.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to lock the dll, FALSE to unlock it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CClassFactory::LockServer"

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    DPF_ENTER();

    if(fLock)
    {
        ASSERT(m_ulServerLockCount < MAX_ULONG);

        if(m_ulServerLockCount < MAX_ULONG)
        {
            m_ulServerLockCount++;
        }
    }
    else
    {
        ASSERT(m_ulServerLockCount > 0);

        if(m_ulServerLockCount > 0)
        {
            m_ulServerLockCount--;
        }
    }

    DPF_LEAVE(S_OK);
    return S_OK;
}


/***************************************************************************
 *
 *  CreateInstance
 *
 *  Description:
 *      Creates an object corresponding to the given IID.
 *
 *  Arguments:
 *      REFIID [in]: object interface id.
 *      LPVOID * [out]: receives pointer to the new object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundClassFactory::CreateInstance"

template <class object_type> HRESULT CDirectSoundClassFactory<object_type>::CreateInstance(REFIID iid, LPVOID *ppvInterface)
{
    object_type *           pObject;
    HRESULT                 hr;

    DPF_ENTER();

    // Create a new DirectSound object
    DPF(DPFLVL_INFO, "Creating object via IClassFactory::CreateInstance");

    pObject = NEW(object_type);
    hr = HRFROMP(pObject);

    if(SUCCEEDED(hr))
    {
        // Set the functional level on the object
        pObject->SetDsVersion(GetDsVersion());

        // Query for the requested interface
        hr = pObject->QueryInterface(iid, TRUE, ppvInterface);
    }

    // Free resources
    if(FAILED(hr))
    {
        ABSOLUTE_RELEASE(pObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DllGetClassObject
 *
 *  Description:
 *      Creates a DirectSound Class Factory object.
 *
 *  Arguments:
 *      REFCLSID [in]: CLSID of the class factory object to create.
 *      REFIID [in]: IID of the interface to return.
 *      LPVOID * [out]: receives interface pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllGetClassObject"

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppvInterface)
{
    CClassFactory *         pClassFactory   = NULL;
    HRESULT                 hr              = S_OK;

    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_API3(DllGetClassObject, &clsid, &iid, ppvInterface);

    if(!IS_VALID_READ_GUID(&clsid))
    {
        RPF(DPFLVL_ERROR, "Invalid class id pointer");
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&iid))
    {
        RPF(DPFLVL_ERROR, "Invalid interface id pointer");
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppvInterface))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = E_INVALIDARG;
    }

    // Create a new ClassFactory object
    if(SUCCEEDED(hr))
    {
        if(CLSID_DirectSound == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSound>);
        }
        else if(CLSID_DirectSound8 == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSound>);

            // Set the DX8 functional level on the factory object
            if (pClassFactory)
                pClassFactory->SetDsVersion(DSVERSION_DX8);
        }
        else if(CLSID_DirectSoundCapture == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundCapture>);
        }
        else if(CLSID_DirectSoundCapture8 == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundCapture>);

            // Set the DX8 functional level on the factory object
            if (pClassFactory)
                pClassFactory->SetDsVersion(DSVERSION_DX8);
        }
        else if(CLSID_DirectSoundPrivate == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundPrivate>);
        }
        else if(CLSID_DirectSoundFullDuplex == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundFullDuplex>);
        }
        else if(CLSID_DirectSoundBufferConfig == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundBufferConfig>);
        }
        else
        {
            RPF(DPFLVL_ERROR, "Unknown class id");
            hr = CLASS_E_CLASSNOTAVAILABLE;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(pClassFactory);
    }

    // Query for the requested interface
    if(SUCCEEDED(hr))
    {
        hr = pClassFactory->QueryInterface(iid, TRUE, ppvInterface);
    }

    // Free resources
    if(FAILED(hr))
    {
        ABSOLUTE_RELEASE(pClassFactory);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  Description:
 *      Returns whether or not the dll can be freed by the calling process.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllCanUnloadNow"

STDAPI DllCanUnloadNow(void)
{
    DWORD                           dwCount = 0;
    HRESULT                         hr      = S_OK;

    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_API0(DllCanUnloadNow);

    // The dll can be unloaded if there's no locks on the server or objects
    // owned by the calling process.
    if(g_pDsAdmin)
    {
        dwCount = g_pDsAdmin->FreeOrphanedObjects(GetCurrentProcessId(), FALSE);
    }

    if(CClassFactory::m_ulServerLockCount > 0)
    {
        RPF(DPFLVL_ERROR, "%lu active locks on the server", CClassFactory::m_ulServerLockCount);
        hr = S_FALSE;
    }

    if(dwCount > 0)
    {
        RPF(DPFLVL_ERROR, "%lu objects still exist", dwCount);
        hr = S_FALSE;
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsdriver.inc ===
;
;DSVXD.INC
;
;Include file for HAL and HEL VXD layers
;
;Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
;

                ;
                ;Return byte count to caller
                ;
                ;Do not use ESI as parameter!
                ;

OUTCNT          MACRO RetCnt
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpcbBytesReturned
                or esi,esi
                jz exit
                mov DWORD PTR [esi],RetCnt
exit:           pop esi

                ENDM

                ;
                ;Return 4-byte DWORD to caller
                ;
                ;Do not use ESI as parameter!
                ;

OUTDWORD        MACRO RetVal
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpvOutBuffer
                or esi,esi
                jz exit
                mov DWORD PTR [esi],RetVal
                OUTCNT 4
exit:           pop esi

                ENDM

                ;
                ;Read 4-byte DWORD from caller
                ;
                ;Do not use ESI as parameter!
                ;

INDWORD         MACRO RetVal
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpvInBuffer
                mov RetVal,-1
                or esi,esi
                jz exit
                mov RetVal,DWORD PTR [esi]
exit:           pop esi

                ENDM

                ;
                ;String copy/write macros
                ;

REP_MOVSB       MACRO

                push ecx
                and ecx,3
                rep movsb
                pop ecx
                shr ecx,2
                rep movsd

                ENDM

REP_STOSB       MACRO

                push ecx
                and ecx,3
                rep stosb
                pop ecx
                shr ecx,2
                rep stosd

                ENDM

                ;
                ;Scale definition
                ;
DS_SCALE_MAX	equ 65535
DS_SCALE_MID	equ 32768

                ;
                ;Error codes
                ;

HAL_OK              equ 0
HAL_ERROR           equ 1
HAL_CANT_OPEN_VXD   equ 2
HAL_ALLOC_FAILED    equ 3
HAL_NOT_ALLOCATED   equ 4
HAL_MUST_STOP_FIRST equ 5

HAL_SYSALLOCMEM	    equ 11

                ;
                ;Base mode flag equates
                ;        Note: This file is generated by modeflag.m4

include <modeflag.inc>

                ;
                ;HALHWMODE afAbilityFlags values
                ;
                ;These flags describe dynamic capabilities (what the device
                ;can/cannot do)
                ;

A_CAN_CHANGE_VOLUME         equ 00000001b  ;Can change volume while playing
A_CANNOT_CHANGE_VOLUME      equ 00000000b  ;Cannot change volume while playing

A_CAN_CHANGE_MODE           equ 00000010b  ;Can change PCM mode while playing
A_CANNOT_CHANGE_MODE        equ 00000000b  ;Cannot change PCM mode while playing

A_CAN_CHANGE_RATE           equ 00000100b  ;Can change rate while playing
A_CANNOT_CHANGE_RATE        equ 00000000b  ;Cannot change rate while playing

A_CAN_LOOP_SECONDARY        equ 00001000b  ;Can loop secondary buffers before starting
A_CANNOT_LOOP_SECONDARY     equ 00000000b  ;Cannot loop secondary buffers before starting

A_CAN_UNLOOP_SECONDARY      equ 00010000b  ;Secondary bufers do not have to loop
A_CANNOT_UNLOOP_SECONDARY   equ 00000000b  ;Secondary buffers must always loop

A_CAN_CHANGE_LOOP_STATUS    equ 00100000b  ;Can turn looping on/off during playback
A_CANNOT_CHANGE_LOOP_STATUS equ 00000000b  ;Cannot turn looping on/off during playback

                ;
                ;HALSTRBUF.dwFlags values
                ;

HSB_DMA_ALLOC   equ 1h		;Buffer was allocated from DMA services
HSB_RAM_ALLOC   equ 2h		;Buffer was allocated from sound card RAM

                ;
                ;
                ;Passed to HAL_ChangeStreamFormat() to inhibit parameter
                ;change
                ;

HF_NO_CHANGE    equ -1


                ;
                ;DSound Caps
                ;


DSC_LOCK_SYSMEM		equ 65535
DSC_LOCK_SLOW		equ 64
DSC_PLAY_DMA		equ 20
DSC_PLAY_ONBOARD	equ 0


DSC_CAPSF_MONO		equ 1
DSC_CAPSF_STEREO	equ 2
DSC_CAPSF_8BIT		equ 4
DSC_CAPSF_16BIT		equ 8


                ;
                ;Stream buffer descriptor
                ;
HALSTRBUF STRUCT
 hfFormat       DWORD ?
 dwSampleRate   DWORD ?
 dwUserSampleRate DWORD ?
 dwVolume       DWORD ?
 dwPan	        DWORD ?
 dwLVolume      DWORD ?
 dwRVolume      DWORD ?
 dwMVolume      DWORD ?
HALSTRBUF ENDS

                ;
                ;Mix session descriptor
                ;

MIXSESSION STRUCT
 lpBuildBuffer  DWORD ?
 dwBuildSize    DWORD ?
 HALOutStrBuf   HALSTRBUF <>
 pBuffer	DWORD ?
 cbBuffer	DWORD ?
 nOutputBytes   DWORD ?
MIXSESSION ENDS

                ;
                ;Mixer input descriptor
                ;

MIXERINPUT STRUCT
 HALInStrBuf    HALSTRBUF <>
 pBuffer	DWORD ?
 cbBuffer	DWORD ?
 lpdwInputPos   DWORD ?
 dwInputBytes   DWORD ?
 dwOutputOffset DWORD ?
MIXERINPUT ENDS


; VxD ID registered to DSHEL.VXD
DSOUND_Device_ID		EQU	357Eh

ifdef DDB_Sys_Crit_Init_Done

; DSound Driver  VxDs use this service to

Begin_Service_Table	DSOUND
        DSOUND_Service  _DSOUND_GetVersion, LOCAL
        DSOUND_Service  _DSOUND_RegisterDeviceDriver, VxD_CODE
        DSOUND_Service  _DSOUND_DeregisterDeviceDriver, VxD_CODE
End_Service_Table DSOUND


ENDIF   ; DDB_Sys_Crit_Init_Done (VxD's only)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsfd.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsfd.h
 *  Content:    DirectSoundFullDuplex object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/1/98    jstokes Created
 *
 ***************************************************************************/

#ifndef __DSFULLDUPLEX_H__
#define __DSFULLDUPLEX_H__

#ifdef __cplusplus

// The main DirectSoundFullDuplex object
class CDirectSoundFullDuplex
    : public CUnknown
{
    friend class CDirectSoundPrivate;
    friend class CDirectSoundAdministrator;

protected:
    HRESULT                             m_hrInit;
    CDirectSoundCapture*                m_pDirectSoundCapture;
    CDirectSound*                       m_pDirectSound;
    BOOL                                m_fIncludeAec;
    GUID                                m_guidAecInstance;
    DWORD                               m_dwAecFlags;

private:
    // Interfaces
    CImpDirectSoundFullDuplex<CDirectSoundFullDuplex>* m_pImpDirectSoundFullDuplex;

public:
    CDirectSoundFullDuplex();
    virtual ~CDirectSoundFullDuplex();

public:
    // Creation
    virtual HRESULT Initialize(LPCGUID, LPCGUID, LPCDSCBUFFERDESC, LPCDSBUFFERDESC, HWND, DWORD, CDirectSoundCaptureBuffer**, CDirectSoundBuffer**);
    virtual HRESULT IsInit(void) {return m_hrInit;}

    // Public accessors
    BOOL HasAEC() {return m_fIncludeAec;}
    REFGUID AecInstanceGuid() {return m_guidAecInstance;}
    DWORD AecCreationFlags() {return m_dwAecFlags;}
};

#endif // __cplusplus

#endif // __DSFULLDUPLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dscom.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscom.h
 *  Content:    COM/OLE helpers
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/26/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSCOM_H__
#define __DSCOM_H__

#ifdef __cplusplus

// Interface list
typedef struct tagINTERFACENODE
{
    GUID                guid;
    CImpUnknown *       pImpUnknown;
    LPVOID              pvInterface;
} INTERFACENODE, *LPINTERFACENODE;

// IUnknown implementation
class CUnknown
    : public CDsBasicRuntime
{
private:
    CList<INTERFACENODE>    m_lstInterfaces;        // List of registered interfaces
    CImpUnknown *           m_pImpUnknown;          // IUnknown interface pointer
    CUnknown*               m_pControllingUnknown;  // Used for aggregation.

public:
    CUnknown(void);
    CUnknown(CUnknown*);
    virtual ~CUnknown(void);

public:
    // Interface management
    virtual HRESULT RegisterInterface(REFGUID, CImpUnknown *, LPVOID);
    virtual HRESULT UnregisterInterface(REFGUID);

    // IUnknown methods
    virtual HRESULT QueryInterface(REFGUID, BOOL, LPVOID *);
    virtual ULONG AddRef(void);
    virtual ULONG Release(void);

    // INonDelegatingUnknown methods
    virtual HRESULT NonDelegatingQueryInterface(REFGUID, BOOL, LPVOID *);
    virtual ULONG NonDelegatingAddRef(void);
    virtual ULONG NonDelegatingRelease(void);

    // Functionality versioning
    virtual void SetDsVersion(DSVERSION nVersion) {m_nVersion = nVersion;}
    DSVERSION GetDsVersion() {return m_nVersion;}

protected:
    virtual HRESULT FindInterface(REFGUID, CNode<INTERFACENODE> **);

private:
    // Functionality versioning
    DSVERSION m_nVersion;
};

__inline ULONG CUnknown::NonDelegatingAddRef(void)
{
    return CRefCount::AddRef();
}

__inline ULONG CUnknown::NonDelegatingRelease(void)
{
    return CDsBasicRuntime::Release();
}

// IClassFactory implementation
class CClassFactory
    : public CUnknown
{
public:
    static ULONG            m_ulServerLockCount;

private:
    // Interfaces
    CImpClassFactory<CClassFactory> *m_pImpClassFactory;

public:
    CClassFactory(void);
    virtual ~CClassFactory(void);

public:
    virtual HRESULT CreateInstance(REFIID, LPVOID *) = 0;
    virtual HRESULT LockServer(BOOL);
};

// DirectSound class factory template definition
template <class object_type> class CDirectSoundClassFactory
    : public CClassFactory
{
public:
    virtual HRESULT CreateInstance(REFIID, LPVOID *);
};

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID, REFIID, LPVOID *);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsimp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsimp.h
 *  Content:    DirectSound object implementation
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *
 ***************************************************************************/

#ifndef __DSIMP_H__
#define __DSIMP_H__

// Interface signatures
typedef enum
{
    INTSIG_DELETED                      = 'KCUS',
    INTSIG_IUNKNOWN                     = 'KNUI',
    INTSIG_IDIRECTSOUND                 = 'DNSD',
    INTSIG_IDIRECTSOUNDBUFFER           = 'FBSD',
    INTSIG_IDIRECTSOUND3DBUFFER         = 'FBD3',
    INTSIG_IDIRECTSOUND3DLISTENER       = 'SLD3',
    INTSIG_ICLASSFACTORY                = 'FSLC',
    INTSIG_IDIRECTSOUNDNOTIFY           = 'ETON',
    INTSIG_IKSPROPERTYSET               = 'PSKI',
    INTSIG_IDIRECTSOUNDCAPTURE          = 'PCSD',
    INTSIG_IDIRECTSOUNDCAPTUREBUFFER    = 'BCSD',
    INTSIG_IDIRECTSOUNDFULLDUPLEX       = 'FDSD',
    INTSIG_IDIRECTSOUNDSINK             = 'KSSD',
    INTSIG_IPERSIST                     = 'TSRP',
    INTSIG_IPERSISTSTREAM               = 'MSRP',
    INTSIG_IDIRECTMUSICOBJECT           = 'BOMD',
} INTERFACE_SIGNATURE;

#ifdef __cplusplus

// COMPATCOMPAT: previous versions of DirectSound used a static structure
// to represent the vtbl.  void meant that an application could call a
// method on a released object and simply fail.  Now, the user will almost
// certainly page fault.

// Fwd decl
class CUnknown;

// IUnknown
class CImpUnknown
    : public IUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    CUnknown *                  m_pUnknown;
    ULONG                       m_ulRefCount;
    BOOL                        m_fValid;

public:
    CImpUnknown(CUnknown *, LPVOID = NULL);
    virtual ~CImpUnknown(void);

public:
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);
};

#define IMPLEMENT_IUNKNOWN() \
    inline virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID FAR *ppv) \
    { \
        return CImpUnknown::QueryInterface(riid, ppv); \
    } \
    \
    inline virtual ULONG STDMETHODCALLTYPE AddRef(void) \
    { \
        return CImpUnknown::AddRef(); \
    } \
    \
    inline virtual ULONG STDMETHODCALLTYPE Release(void) \
    { \
        return CImpUnknown::Release(); \
    }

// IDirectSound
template <class object_type> class CImpDirectSound
    : public IDirectSound8, public IDirectSoundPrivate, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSound(CUnknown *, object_type *);
    virtual ~CImpDirectSound(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    // IDirectSound methods
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN);
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSCAPS);
    virtual HRESULT STDMETHODCALLTYPE DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *);
    virtual HRESULT STDMETHODCALLTYPE SetCooperativeLevel(HWND, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Compact(void);
    virtual HRESULT STDMETHODCALLTYPE GetSpeakerConfig(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE SetSpeakerConfig(DWORD);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPCGUID);

    // IDirectSound8 methods
    virtual HRESULT STDMETHODCALLTYPE AllocSink(LPWAVEFORMATEX, LPDIRECTSOUNDCONNECT *);
    virtual HRESULT STDMETHODCALLTYPE VerifyCertification(LPDWORD);
#ifdef FUTURE_WAVE_SUPPORT
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBufferFromWave(IUnknown*, DWORD, LPDIRECTSOUNDBUFFER*);
#endif
};

// IDirectSoundBuffer
template <class object_type> class CImpDirectSoundBuffer
    : public IDirectSoundBuffer8, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundBuffer(CUnknown *, object_type *);
    virtual ~CImpDirectSoundBuffer(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    // IDirectSoundBuffer methods
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSBCAPS);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetFormat(LPWAVEFORMATEX, DWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE GetPan(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE GetFrequency(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPDIRECTSOUND, LPCDSBUFFERDESC);
    virtual HRESULT STDMETHODCALLTYPE Lock(DWORD, DWORD, LPVOID FAR *, LPDWORD, LPVOID FAR *, LPDWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Play(DWORD, DWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetCurrentPosition(DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX);
    virtual HRESULT STDMETHODCALLTYPE SetVolume(LONG);
    virtual HRESULT STDMETHODCALLTYPE SetPan(LONG);
    virtual HRESULT STDMETHODCALLTYPE SetFrequency(DWORD);
    virtual HRESULT STDMETHODCALLTYPE Stop(void);
    virtual HRESULT STDMETHODCALLTYPE Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Restore(void);

    // IDirectSoundBuffer8 methods
    virtual HRESULT STDMETHODCALLTYPE SetFX(DWORD, LPDSEFFECTDESC, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE AcquireResources(DWORD, DWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT STDMETHODCALLTYPE SetChannelVolume(DWORD, LPDWORD, LPLONG);
#endif
};

// IDirectSound3DListener
template <class object_type> class CImpDirectSound3dListener
    : public IDirectSound3DListener, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSound3dListener(CUnknown *, object_type *);
    virtual ~CImpDirectSound3dListener(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE GetAllParameters(LPDS3DLISTENER);
    virtual HRESULT STDMETHODCALLTYPE GetDistanceFactor(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetDopplerFactor(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetOrientation(D3DVECTOR*, D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetPosition(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetRolloffFactor(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetVelocity(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DLISTENER, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetDistanceFactor(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetDopplerFactor(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetOrientation(D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetRolloffFactor(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void);
};

// IDirectSound3DBuffer
template <class object_type> class CImpDirectSound3dBuffer
    : public IDirectSound3DBuffer, public IDirectSound3DBufferPrivate, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSound3dBuffer(CUnknown *, object_type *);
    virtual ~CImpDirectSound3dBuffer(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE GetAllParameters(LPDS3DBUFFER);
    virtual HRESULT STDMETHODCALLTYPE GetConeAngles(LPDWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetConeOrientation(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetConeOutsideVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE GetMaxDistance(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetMinDistance(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetMode(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetPosition(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetVelocity(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD, DWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetConeOrientation(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetMaxDistance(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetMinDistance(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetMode(DWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE GetAttenuation(FLOAT*);
};

// IClassFactory
template <class object_type> class CImpClassFactory
    : public IClassFactory, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpClassFactory(CUnknown *, object_type *);
    virtual ~CImpClassFactory(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    virtual HRESULT STDMETHODCALLTYPE LockServer(BOOL);
};

// IDirectSoundNotify
template <class object_type> class CImpDirectSoundNotify
    : public IDirectSoundNotify, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundNotify(CUnknown *, object_type *);
    virtual ~CImpDirectSoundNotify(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);
};

// IKsPropertySet
template <class object_type> class CImpKsPropertySet
    : public IKsPropertySet, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpKsPropertySet(CUnknown *, object_type *);
    virtual ~CImpKsPropertySet(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE Get(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG);
    virtual HRESULT STDMETHODCALLTYPE Set(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
    virtual HRESULT STDMETHODCALLTYPE QuerySupport(REFGUID, ULONG, PULONG);
};

// IDirectSoundCapture
template <class object_type> class CImpDirectSoundCapture
    : public IDirectSoundCapture, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundCapture(CUnknown *, object_type *);
    virtual ~CImpDirectSoundCapture(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE CreateCaptureBuffer(LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN);
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSCCAPS);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPCGUID);
};

// IDirectSoundCaptureBuffer
template <class object_type> class CImpDirectSoundCaptureBuffer
    : public IDirectSoundCaptureBuffer7_1, public IDirectSoundCaptureBuffer8, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundCaptureBuffer(CUnknown *, object_type *);
    virtual ~CImpDirectSoundCaptureBuffer(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    // IDirectSoundCaptureBuffer methods
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSCBCAPS);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetFormat(LPWAVEFORMATEX, DWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC);
    virtual HRESULT STDMETHODCALLTYPE Lock(DWORD, DWORD, LPVOID FAR *, LPDWORD, LPVOID FAR *, LPDWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Start(DWORD);
    virtual HRESULT STDMETHODCALLTYPE Stop();
    virtual HRESULT STDMETHODCALLTYPE Unlock(LPVOID, DWORD, LPVOID, DWORD);

    // IDirectSoundCaptureBuffer7_1 methods
    virtual HRESULT STDMETHODCALLTYPE SetVolume(LONG);
    virtual HRESULT STDMETHODCALLTYPE GetVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE SetMicVolume(LONG);
    virtual HRESULT STDMETHODCALLTYPE GetMicVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE EnableMic(BOOL);
    virtual HRESULT STDMETHODCALLTYPE YieldFocus(void);
    virtual HRESULT STDMETHODCALLTYPE ClaimFocus(void);
    virtual HRESULT STDMETHODCALLTYPE SetFocusHWND(HWND);
    virtual HRESULT STDMETHODCALLTYPE GetFocusHWND(HWND FAR *);
    virtual HRESULT STDMETHODCALLTYPE EnableFocusNotifications(HANDLE);

    // IDirectSoundCaptureBuffer8 methods
    virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);
    virtual HRESULT STDMETHODCALLTYPE GetFXStatus(DWORD, LPDWORD);
};

// DirectSound sink object
template <class object_type> class CImpDirectSoundSink
    : public IDirectSoundConnect, public IDirectSoundSynthSink, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundSink(CUnknown *, object_type *);
    virtual ~CImpDirectSoundSink();

public:
    IMPLEMENT_IUNKNOWN();

public:
    // IDirectSoundConnect methods
    virtual HRESULT STDMETHODCALLTYPE AddSource(IDirectSoundSource *pSource);
    virtual HRESULT STDMETHODCALLTYPE RemoveSource(IDirectSoundSource *pSource);
    virtual HRESULT STDMETHODCALLTYPE SetMasterClock(IReferenceClock *pClock);
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusCount, REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer);
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBufferFromConfig(IUnknown *pUnknown, LPDIRECTSOUNDBUFFER *ppDSBuffer);
    virtual HRESULT STDMETHODCALLTYPE GetSoundBuffer(DWORD dwBusId, LPDIRECTSOUNDBUFFER *ppBuffer);
    virtual HRESULT STDMETHODCALLTYPE GetBusCount(DWORD *pdwCount);
    virtual HRESULT STDMETHODCALLTYPE GetBusIDs(DWORD *pdwBusIDs, DWORD *pdwFuncIDs, DWORD dwBusCount);
    virtual HRESULT STDMETHODCALLTYPE GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID);
    virtual HRESULT STDMETHODCALLTYPE GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount);

    // IDirectSoundSynthSink methods
    virtual HRESULT STDMETHODCALLTYPE GetLatencyClock(IReferenceClock **ppClock);
    virtual HRESULT STDMETHODCALLTYPE Activate(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prt);
    virtual HRESULT STDMETHODCALLTYPE RefToSampleTime(REFERENCE_TIME rt, LONGLONG *pllSampleTime);
    virtual HRESULT STDMETHODCALLTYPE GetFormat(LPWAVEFORMATEX, DWORD, LPDWORD);
};

// IPersistStream
template <class object_type> class CImpPersistStream
    : public IPersistStream, public CImpUnknown  // FIXME: should derive from IPersist too?
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpPersistStream(CUnknown *, object_type *);
    virtual ~CImpPersistStream();

public:
    IMPLEMENT_IUNKNOWN();

public:
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);
    virtual HRESULT STDMETHODCALLTYPE IsDirty();
    virtual HRESULT STDMETHODCALLTYPE Load(IStream *pStream);
    virtual HRESULT STDMETHODCALLTYPE Save(IStream *pStream, BOOL fClearDirty);
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER* pcbSize);
};

// IDirectMusicObject
template <class object_type> class CImpDirectMusicObject
    : public IDirectMusicObject, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectMusicObject(CUnknown *, object_type *);
    virtual ~CImpDirectMusicObject();

public:
    IMPLEMENT_IUNKNOWN();

public:
    virtual HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);
};


// IDirectSoundFullDuplex
template <class object_type> class CImpDirectSoundFullDuplex
    : public IDirectSoundFullDuplex, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundFullDuplex(CUnknown *, object_type *);
    virtual ~CImpDirectSoundFullDuplex(void);

public:
    // IDirectSoundFullDuplex methods
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPCGUID, LPCGUID, LPCDSCBUFFERDESC, LPCDSBUFFERDESC, HWND, DWORD, LPLPDIRECTSOUNDCAPTUREBUFFER8, LPLPDIRECTSOUNDBUFFER8);

public:
    inline virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID FAR *ppv)
    {
        return CImpUnknown::QueryInterface(riid, ppv);
    }

    inline virtual ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return CImpUnknown::AddRef();
    }

    inline virtual ULONG STDMETHODCALLTYPE Release(void)
    {
        return CImpUnknown::Release();
    }
};

// Helper functions
template <class interface_type, class object_type> HRESULT CreateAndRegisterInterface(CUnknown *, REFGUID, object_type *, interface_type **);

#endif // __cplusplus

#endif // __DSIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsfd.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsfd.cpp
 *  Content:    DirectSoundFullDuplex class implementation
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/1/98    jstokes Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CDirectSoundFullDuplex
 *
 *  Description:
 *      DirectSoundFullDuplex object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundFullDuplex::CDirectSoundFullDuplex"

CDirectSoundFullDuplex::CDirectSoundFullDuplex()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundFullDuplex);

    // Set defaults
    m_pImpDirectSoundFullDuplex = NULL;
    m_hrInit = DSERR_UNINITIALIZED;
    m_fIncludeAec = FALSE;
    m_guidAecInstance = GUID_NULL;
    m_dwAecFlags = 0;
    m_pDirectSound = NULL;
    m_pDirectSoundCapture = NULL;

    // Register the interface with the interface manager
    CreateAndRegisterInterface(this, IID_IDirectSoundFullDuplex, this, &m_pImpDirectSoundFullDuplex);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundFullDuplex
 *
 *  Description:
 *      DirectSoundFullDuplex object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundFullDuplex::~CDirectSoundFullDuplex"

CDirectSoundFullDuplex::~CDirectSoundFullDuplex()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundFullDuplex);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    if(m_pDirectSoundCapture)
    {
        m_pDirectSoundCapture->NonDelegatingRelease();
    }

    if(m_pDirectSound)
    {
        m_pDirectSound->NonDelegatingRelease();
    }

    // Free all interfaces
    DELETE(m_pImpDirectSoundFullDuplex);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundFullDuplex::Initialize"

HRESULT CDirectSoundFullDuplex::Initialize
(
    LPCGUID                         pguidCaptureDevice,
    LPCGUID                         pguidRenderDevice,
    LPCDSCBUFFERDESC                pDscBufferDesc,
    LPCDSBUFFERDESC                 pDsBufferDesc,
    HWND                            hWnd,
    DWORD                           dwLevel,
    CDirectSoundCaptureBuffer **    ppDirectSoundCaptureBuffer,
    CDirectSoundBuffer **           ppDirectSoundBuffer
)
{
    HRESULT                         hr = DS_OK;

    DPF_ENTER();

    *ppDirectSoundCaptureBuffer = NULL;
    *ppDirectSoundBuffer = NULL;

    // DirectSoundFullDuplex objects are only supported since Whistler
    if (GetWindowsVersion() < WIN_XP)
    {
        RPF(DPFLVL_ERROR, "IDirectSoundFullDuplex not supported on this OS");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr))
    {
        // Create and initialize the DirectSoundCapture object
        m_pDirectSoundCapture = NEW(CDirectSoundCapture(this));
        hr = HRFROMP(m_pDirectSoundCapture);
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object and initialize it
        m_pDirectSoundCapture->SetDsVersion(GetDsVersion());

        hr = m_pDirectSoundCapture->Initialize(pguidCaptureDevice, this);
    }

    // Register the IDirectSoundCapture8 (=IDirectSoundCapture) interface
    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSoundCapture8, m_pDirectSoundCapture->m_pImpDirectSoundCapture, (IDirectSoundCapture8*)(m_pDirectSoundCapture->m_pImpDirectSoundCapture));
    }

    // Create the DirectSoundCaptureBuffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSoundCapture->CreateCaptureBuffer(pDscBufferDesc, ppDirectSoundCaptureBuffer);
    }

    // NOTE: This call to CreateCaptureBuffer() has the important side effect of
    // updating the instance GUIDs in our effect list, mapping GUID_DSCFX_SYSTEM_*
    // to GUID_DSCFX_MS_* etc. for the system effects that default to MS ones.

    // Figure out our AEC status, flags, and implementation to be used
    if(SUCCEEDED(hr))
    {
        for (DWORD i=0; i<pDscBufferDesc->dwFXCount; i++)
        {
            if(pDscBufferDesc->lpDSCFXDesc[i].guidDSCFXClass == GUID_DSCFX_CLASS_AEC)
            {
                if (m_fIncludeAec)
                {
                    RPF(DPFLVL_ERROR, "Cannot request AEC effect twice");
                    hr = DSERR_INVALIDPARAM;
                    break;
                }
                m_fIncludeAec = TRUE;
                m_dwAecFlags = pDscBufferDesc->lpDSCFXDesc[i].dwFlags;
                m_guidAecInstance = pDscBufferDesc->lpDSCFXDesc[i].guidDSCFXInstance;
            }
        }
    }


#ifdef DEAD_CODE
    // This code is disabled because AEC.SYS now has status reporting,
    // and can inform the application whether it has converged or not.
    // Our current AEC implementation is almost guaranteed to fail if
    // used across different devices, but future versions may succeed,
    // so we don't want to disable this scenario here in DirectSound.

    // If the Microsoft AEC effect has been requested, we check here that the
    // device GUIDs requested both refer to the same WDM device, so that timing
    // will stay in sync.  This is a temporary measure until we get clock rate
    // matching working in Blackcomb (bug #99702).

    if (SUCCEEDED(hr) && m_guidAecInstance == GUID_DSCFX_MS_AEC)
    {
        // First translate the device IDs requested to specific device GUIDs
        GUID guidRender = IS_NULL_GUID(pguidRenderDevice) ? DSDEVID_DefaultPlayback : *pguidRenderDevice;
        GUID guidCapture = IS_NULL_GUID(pguidCaptureDevice) ? DSDEVID_DefaultCapture : *pguidCaptureDevice;
        g_pVadMgr->GetDeviceIdFromDefaultId(&guidRender, &guidRender);
        g_pVadMgr->GetDeviceIdFromDefaultId(&guidCapture, &guidCapture);

        // Now check that the device IDs correspond to the same device
        if (g_pVadMgr->GetDriverDeviceType(guidRender) != VAD_DEVICETYPE_KSRENDER ||
            g_pVadMgr->GetDriverDeviceType(guidCapture) != VAD_DEVICETYPE_KSCAPTURE ||
            guidRender.Data4[7] != guidCapture.Data4[7])
        {
            RPF(DPFLVL_ERROR, "The MS_AEC effect cannot be used across different audio render and capture devices");
            hr = DSERR_UNSUPPORTED;
        }

        // We don't allow AEC to run on USB devices, since all known full-duplex
        // USB devices (e.g. telephone handsets) have different sample rates in
        // their render and capture parts, which breaks AEC.

        if(SUCCEEDED(hr))
        {
            BOOL fAecAllowed;

            // See if the device has an AEC setting in the registry
            if (RhRegGetBinaryValue(m_pDirectSoundCapture->m_hkeyParent, REGSTR_ALLOW_MS_AEC, &fAecAllowed, sizeof fAecAllowed) == DS_OK)
            {
                RPF(fAecAllowed ? DPFLVL_INFO : DPFLVL_ERROR,
                    "The MS_AEC effect is explicitly %sabled for this device in the registry",
                    fAecAllowed ? TEXT("en") : TEXT("dis"));
            }
            else
            {
                // If there is no registry setting, allow AEC only on non-USB devices
                // (or USB devices that don't use the usbaudio.sys class driver)
                fAecAllowed = _stricmp(m_pDirectSoundCapture->m_pDevice->m_pDeviceDescription->m_strPath, "usbaudio.sys");
                if (!fAecAllowed)
                    RPF(DPFLVL_ERROR, "The MS_AEC effect cannot be used on USB devices unless explicitly enabled in the registry");
            }

            if (!fAecAllowed)
                hr = DSERR_UNSUPPORTED;
        }
    }
#endif // DEAD_CODE


    // Create and initialize the DirectSound object
    if(SUCCEEDED(hr))
    {
        m_pDirectSound = NEW(CDirectSound((CUnknown*)this));
        hr = HRFROMP(m_pDirectSound);
    }
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->Initialize(pguidRenderDevice, this);
    }

    // Register the IDirectSound and IDirectSound8 interfaces
    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSound, m_pDirectSound->m_pImpDirectSound, (IDirectSound*)(m_pDirectSound->m_pImpDirectSound));
    }
    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSound8, m_pDirectSound->m_pImpDirectSound, (IDirectSound8*)(m_pDirectSound->m_pImpDirectSound));
    }

    if(SUCCEEDED(hr))
    {
        // Set the functional level on the object
        m_pDirectSound->SetDsVersion(GetDsVersion());
    }

    // Set the cooperative level
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->SetCooperativeLevel(GetWindowThreadProcessId(GetRootParentWindow(hWnd), NULL), dwLevel);
    }

    // Create the DirectSoundBuffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->CreateSoundBuffer(pDsBufferDesc, ppDirectSoundBuffer);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }
    else
    {
        RELEASE(*ppDirectSoundCaptureBuffer);
        RELEASE(*ppDirectSoundBuffer);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsimp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsimp.cpp
 *  Content:    DirectSound interface implementations.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Changed, updated, expanded, tidied up
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  CreateAndRegisterInterface
 *
 *  Description:
 *      Creates and registers a new interface with the object.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      REFGUID [in]: GUID of the interface.
 *      object_type * [in]: owning object pointer.
 *      interface_type * [in]: interface implementation object pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::CreateAndRegisterInterface"

template <class interface_type, class object_type> HRESULT CreateAndRegisterInterface(CUnknown *pUnknown, REFGUID guid, object_type *pObject, interface_type **ppInterface)
{
    interface_type *        pInterface;
    HRESULT                 hr;

    DPF_ENTER();

    pInterface = NEW(interface_type(pUnknown, pObject));
    hr = HRFROMP(pInterface);

    if(SUCCEEDED(hr))
    {
        hr = pUnknown->RegisterInterface(guid, pInterface, pInterface);
    }

    if(SUCCEEDED(hr))
    {
        *ppInterface = pInterface;
    }
    else
    {
        DELETE(pInterface);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSound
 *
 *  Description:
 *      IDirectSound implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::CImpDirectSound"

template <class object_type> CImpDirectSound<object_type>::CImpDirectSound(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUND)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSound);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSound
 *
 *  Description:
 *      IDirectSound implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::~CImpDirectSound"

template <class object_type> CImpDirectSound<object_type>::~CImpDirectSound(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSound);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundBuffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: description of the buffer to be created.
 *      LPDIRECTSOUNDBUFFER * [out]: receives a pointer to the new buffer.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::CreateSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;
    DSBUFFERDESC            dsbdi;

    DPF_API3(IDirectSound::CreateSoundBuffer, pcDSBufferDesc, ppDSBuffer, pUnkOuter);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(pcDSBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(pcDSBufferDesc, &dsbdi, m_pObject->GetDsVersion(), FALSE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && (pcDSBufferDesc->dwFlags & DSBCAPS_MIXIN))
    {
        RPF(DPFLVL_ERROR, "Flag 0x00002000 not valid");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
        hr = m_pObject->CreateSoundBuffer(&dsbdi, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the object.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::GetCaps(LPDSCAPS pCaps)
{
    HRESULT                 hr  = DS_OK;

    DPF_API1(IDirectSound::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DuplicateSoundBuffer
 *
 *  Description:
 *      Makes a copy of an existing sound buffer object.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: source buffer.
 *      LPDIRECTSOUNDBUFFER * [out]: receives destination buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::DuplicateSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER pIdsbSource, LPDIRECTSOUNDBUFFER *ppIdsbDest)
{
    CImpDirectSoundBuffer<CDirectSoundBuffer> * pSource = (CImpDirectSoundBuffer<CDirectSoundBuffer> *)pIdsbSource;
    CDirectSoundBuffer *                        pDest   = NULL;
    HRESULT                                     hr      = DS_OK;

    DPF_API2(IDirectSound::DuplicateSoundBuffer, pIdsbSource, ppIdsbDest);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUNDBUFFER(pSource))
    {
        RPF(DPFLVL_ERROR, "Invalid source buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = pSource->m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Source buffer not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppIdsbDest))
        {
            *ppIdsbDest = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid dest buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Duplicate the buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pObject->DuplicateSoundBuffer(pSource->m_pObject, &pDest);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pDest->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppIdsbDest);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pDest);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetCooperativeLevel
 *
 *  Description:
 *      Sets the object's cooperative level.
 *
 *  Arguments:
 *      HWND [in]: window handle to associate sounds with.
 *      DWORD [in]: cooperative level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::SetCooperativeLevel"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::SetCooperativeLevel(HWND hWnd, DWORD dwPriority)
{
    HRESULT                 hr  = DS_OK;

    DPF_API2(IDirectSound::SetCooperativeLevel, hWnd, dwPriority);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hWnd))
    {
        RPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwPriority < DSSCL_FIRST || dwPriority > DSSCL_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid cooperative level");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetCooperativeLevel(GetWindowThreadProcessId(GetRootParentWindow(hWnd), NULL), dwPriority);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Compact
 *
 *  Description:
 *      Compacts memory.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::Compact"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::Compact(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSound::Compact);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Compact();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSpeakerConfig
 *
 *  Description:
 *      Retrieves the current speaker configuration.
 *
 *  Arguments:
 *      LPDWORD [out]: receives speaker config.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::GetSpeakerConfig"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound::GetSpeakerConfig, pdwSpeakerConfig);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwSpeakerConfig))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwSpeakerConfig pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSpeakerConfig(pdwSpeakerConfig);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets the current speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker config.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::SetSpeakerConfig"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound::SetSpeakerConfig, dwSpeakerConfig);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && dwSpeakerConfig & ~(DSSPEAKER_CONFIG_MASK | DSSPEAKER_GEOMETRY_MASK))
    {
        RPF(DPFLVL_ERROR, "Invalid dwSpeakerConfig value");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (DSSPEAKER_CONFIG(dwSpeakerConfig) < DSSPEAKER_FIRST || DSSPEAKER_CONFIG(dwSpeakerConfig) > DSSPEAKER_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid dwSpeakerConfig value");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && DSSPEAKER_STEREO != DSSPEAKER_CONFIG(dwSpeakerConfig) && DSSPEAKER_GEOMETRY(dwSpeakerConfig))
    {
        RPF(DPFLVL_ERROR, "Geometry only valid with STEREO");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && DSSPEAKER_GEOMETRY(dwSpeakerConfig) && (DSSPEAKER_GEOMETRY(dwSpeakerConfig) < DSSPEAKER_GEOMETRY_MIN || DSSPEAKER_GEOMETRY(dwSpeakerConfig) > DSSPEAKER_GEOMETRY_MAX))
    {
        RPF(DPFLVL_ERROR, "Invalid geometry value");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetSpeakerConfig(dwSpeakerConfig);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID.  This parameter may be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::Initialize(LPCGUID pGuid)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound::Initialize, pGuid);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DS_OK == hr)
        {
            RPF(DPFLVL_ERROR, "DirectSound object already initialized");
            hr = DSERR_ALREADYINITIALIZED;
        }
        else if(DSERR_UNINITIALIZED == hr)
        {
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Initialize(pGuid, NULL);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(SUCCEEDED(m_pObject->IsInit()));
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  AllocSink
 *
 *  Description:
 *      Allocate a new DirectSound sink.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: The format the sink will run in
 *      LPDIRECTSOUNDSINK * [out]: The returned sink
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::AllocSink"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::AllocSink(LPWAVEFORMATEX pwfex, LPDIRECTSOUNDCONNECT *ppSinkConnect)
{
    HRESULT             hr    = DS_OK;
    CDirectSoundSink *  pSink = NULL;

    DPF_API2(IDirectSoundPrivate::AllocSink, pwfex, ppSinkConnect);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    // Only DX8 apps should be able to obtain the IDirectSoundPrivate interface.
    ASSERT(m_pObject->GetDsVersion() >= DSVERSION_DX8);

    if(SUCCEEDED(hr) && !IS_VALID_READ_WAVEFORMATEX(pwfex))
    {
        RPF(DPFLVL_ERROR, "Invalid wave format pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Currently the only supported format is 16-bit mono PCM
    if(SUCCEEDED(hr) && !IsValidWfx(pwfex))
    {
        RPF(DPFLVL_ERROR, "Invalid sink wave format");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (pwfex->nChannels != 1 || pwfex->wBitsPerSample != 16))
    {
        RPF(DPFLVL_ERROR, "Sink wave format must be 16 bit mono");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppSinkConnect))
    {
        RPF(DPFLVL_ERROR, "Invalid IDirectSoundConnect interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->AllocSink(pwfex, &pSink);
    }

    if(SUCCEEDED(hr))
    {
        hr = pSink->QueryInterface(IID_IDirectSoundConnect, TRUE, (void**)ppSinkConnect);
    }

    if(FAILED(hr))
    {
        RELEASE(pSink);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  VerifyCertification
 *
 *  Description:
 *      Verify driver is certified.
 *
 *  Arguments:
 *      LPDWORD [out]: The value DS_CERTIFIED or DS_UNCERTIFIED
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::VerifyCertification"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::VerifyCertification(LPDWORD lpdwCertified)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSound8::VerifyCertification, lpdwCertified);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lpdwCertified))
    {
        RPF(DPFLVL_ERROR, "Invalid certification flag pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->VerifyCertification(lpdwCertified);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


#ifdef FUTURE_WAVE_SUPPORT
/***************************************************************************
 *
 *  CreateSoundBufferFromWave
 *
 *  Description:
 *      Create a buffer from an IDirectSoundWave object.
 *
 *  Arguments:
 *      LPUNKNOWN [in]: IUnknown interface of wave object.
 *      DWORD [in]: Buffer creation flags.
 *      LPDIRECTSOUNDBUFFER * [out]: receives destination buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::CreateSoundBufferFromWave"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::CreateSoundBufferFromWave(IUnknown *pUnkWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    HRESULT  hr;
    CDirectSoundBuffer *    pBuffer     = NULL;
    IDirectSoundWave *      pDSWave     = (IDirectSoundWave*)pUnkWave;
    LPWAVEFORMATEX          pwfxFormat;
    DWORD                   dwWfxSize;

    DPF_API3(IDirectSound8::CreateSoundBufferFromWave, pUnkWave, dwFlags, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pDSWave))
    {
        RPF(DPFLVL_ERROR, "Invalid pDSWave pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidDsBufferFlags(dwFlags, DSBCAPS_FROMWAVEVALIDFLAGS))
    {
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;

        hr = pDSWave->GetFormat(NULL, 0, &dwWfxSize);
        if(SUCCEEDED(hr))
        {
            pwfxFormat = LPWAVEFORMATEX(MEMALLOC_A(BYTE, dwWfxSize));
            hr = HRFROMP(pwfxFormat);
        }

        if(SUCCEEDED(hr))
        {
            hr = pDSWave->GetFormat(pwfxFormat, dwWfxSize, NULL);
        }

        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Could not obtain wave format");
        }
        else if(!IsValidWfx(pwfxFormat))
        {
            RPF(DPFLVL_ERROR, "Invalid wave format");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        hr = m_pObject->CreateSoundBufferFromWave(pDSWave, dwFlags, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
#endif // FUTURE_WAVE_SUPPORT


/***************************************************************************
 *
 *  CImpDirectSoundBuffer
 *
 *  Description:
 *      IDirectSoundBuffer implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::CImpDirectSoundBuffer"

template <class object_type> CImpDirectSoundBuffer<object_type>::CImpDirectSoundBuffer(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDBUFFER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundBuffer);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundBuffer
 *
 *  Description:
 *      IDirectSoundBuffer implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::~CImpDirectSoundBuffer"

template <class object_type> CImpDirectSoundBuffer<object_type>::~CImpDirectSoundBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundBuffer);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSBCAPS structure with the capabilities of the buffer.
 *
 *  Arguments:
 *      LPDSBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetCaps(LPDSBCAPS pCaps)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSBCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetCurrentPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetCurrentPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::GetCurrentPosition: pdwPlay=0x%p, pdwWrite=0x%p", pdwPlay, pdwWrite);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pdwPlay && !IS_VALID_TYPED_WRITE_PTR(pdwPlay))
    {
        RPF(DPFLVL_ERROR, "Invalid play cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwWrite && !IS_VALID_TYPED_WRITE_PTR(pdwWrite))
    {
        RPF(DPFLVL_ERROR, "Invalid write cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pdwPlay && !pdwWrite)
    {
        RPF(DPFLVL_ERROR, "Both cursor pointers can't be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCurrentPosition(pdwPlay, pdwWrite);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::GetCurrentPosition: Leave, returning %s (Play=%ld, Write=%ld)", HRESULTtoSTRING(hr), pdwPlay ? *pdwPlay: -1, pdwWrite ? *pdwWrite : -1);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      DWORD [in]: size of the above structure.
 *      LPDWORD [in/out]: On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundBuffer::GetFormat, pwfxFormat, dwSizeAllocated, pdwSizeWritten);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pwfxFormat && !IS_VALID_WRITE_WAVEFORMATEX(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwSizeWritten && !IS_VALID_TYPED_WRITE_PTR(pdwSizeWritten))
    {
        RPF(DPFLVL_ERROR, "Invalid size pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pwfxFormat && !pdwSizeWritten)
    {
        RPF(DPFLVL_ERROR, "Either pwfxFormat or pdwSizeWritten must be non-NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(!pwfxFormat)
        {
            dwSizeAllocated = 0;
        }

        hr = m_pObject->GetFormat(pwfxFormat, &dwSizeAllocated);

        if(SUCCEEDED(hr) && pdwSizeWritten)
        {
            *pdwSizeWritten = dwSizeAllocated;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Retrieves volume for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetVolume(LPLONG plVolume)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        RPF(DPFLVL_ERROR, "Invalid volume pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetPan
 *
 *  Description:
 *      Retrieves pan for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetPan"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetPan(LPLONG plPan)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetPan, plPan);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plPan))
    {
        RPF(DPFLVL_ERROR, "Invalid pan pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetPan(plPan);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetFrequency"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetFrequency(LPDWORD pdwFrequency)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetFrequency, pdwFrequency);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwFrequency))
    {
        RPF(DPFLVL_ERROR, "Invalid frequency buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFrequency(pdwFrequency);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetStatus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetStatus, pdwStatus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwStatus))
    {
        RPF(DPFLVL_ERROR, "Invalid status pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetStatus(pdwStatus);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.
 *
 *  Arguments:
 *      LPDIRECTSOUND [in]: parent DirectSound object.
 *      LPDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Initialize(LPDIRECTSOUND pIds, LPCDSBUFFERDESC pcDSBufferDesc)
{
    CImpDirectSound<CDirectSound> * pImpDirectSound = (CImpDirectSound<CDirectSound> *)pIds;
    HRESULT                         hr              = DS_OK;
    DSBUFFERDESC                    dsbdi;

    DPF_API2(IDirectSoundBuffer::Initialize, pIds, pcDSBufferDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUND(pImpDirectSound))
    {
        RPF(DPFLVL_ERROR, "Invalid parent interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(pcDSBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pcDSBufferDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(pcDSBufferDesc, &dsbdi, m_pObject->GetDsVersion(), FALSE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    // It's never valid to call this function.  We don't support
    // creating a DirectSoundBuffer object from anywhere but
    // IDirectSound::CreateSoundBuffer.
    if(SUCCEEDED(hr))
    {
        RPF(DPFLVL_ERROR, "DirectSound buffer already initialized");
        hr = DSERR_ALREADYINITIALIZED;
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for writing.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: flags modifying the lock event.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Lock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Lock(DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                     hr              = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Lock: WriteCursor=%lu, WriteBytes=%lu, Flags=0x%lX", dwWriteCursor, dwWriteBytes, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr1))
        {
            *ppvAudioPtr1 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes1))
        {
            *pdwAudioBytes1 = 0;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && ppvAudioPtr2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr2))
        {
            *ppvAudioPtr2 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && pdwAudioBytes2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes2))
        {
            *pdwAudioBytes2 = 0;
        }
        else if(ppvAudioPtr2)
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSBLOCK_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Lock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Lock: Leave, returning %s (AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu)",
        HRESULTtoSTRING(hr),
        ppvAudioPtr1 ? *ppvAudioPtr1 : NULL,
        pdwAudioBytes1 ? *pdwAudioBytes1 : NULL,
        ppvAudioPtr2 ? *ppvAudioPtr2 : NULL,
        pdwAudioBytes2 ? *pdwAudioBytes2 : NULL);

    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: reserved.  Must be 0.
 *      DWORD [in]: priority.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Play"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Play(DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundBuffer::Play, dwReserved1, dwPriority, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && dwReserved1)
    {
        RPF(DPFLVL_ERROR, "Reserved argument(s) are not zero");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSBPLAY_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_TIME) && (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE))
    {
        RPF(DPFLVL_ERROR, "Cannot use DSBPLAY_TERMINATEBY_TIME and DSBPLAY_TERMINATEBY_DISTANCE simultaneously");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Play(dwPriority, dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        // Let the buffer use a special successful return code if it wants to
        hr = m_pObject->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play position for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetCurrentPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetCurrentPosition(DWORD dwPlayCursor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetCurrentPosition, dwPlayCursor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetCurrentPosition(dwPlayCursor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the format for a given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetFormat(LPCWAVEFORMATEX pwfxFormat)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetFormat, pwfxFormat);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_WAVEFORMATEX(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidWfx(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFormat(pwfxFormat);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the volume for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetVolume(LONG lVolume)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetVolume, lVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX))
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetVolume(lVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetPan"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetPan(LONG lPan)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetPan, lPan);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lPan < DSBPAN_LEFT || lPan > DSBPAN_RIGHT))
    {
        RPF(DPFLVL_ERROR, "Pan out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetPan(lPan);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetFrequency"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetFrequency(DWORD dwFrequency)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetFrequency, dwFrequency);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (dwFrequency != DSBFREQUENCY_ORIGINAL && (dwFrequency < DSBFREQUENCY_MIN || dwFrequency > DSBFREQUENCY_MAX)))
    {
        RPF(DPFLVL_ERROR, "Frequency out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFrequency(dwFrequency);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops playing the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Stop"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Stop(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSoundBuffer::Stop);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Stop();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Unlock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Unlock: AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu",
        pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvAudioPtr1, dwAudioBytes1))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwAudioBytes2 && !IS_VALID_READ_PTR(pvAudioPtr2, dwAudioBytes2))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Unlock: Leave, returning %s", HRESULTtoSTRING(hr));
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Restore
 *
 *  Description:
 *      Restores a lost buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Restore"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Restore(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSoundBuffer::Restore);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Restore();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFX
 *
 *  Description:
 *      Sets a chain of effects on this buffer, replacing any previous
 *      effect chain and, if necessary, allocating or deallocating the
 *      shadow buffer used to hold unprocessed audio .
 *
 *  Arguments:
 *      DWORD [in]: Number of effects.  0 to remove current FX chain.
 *      DSEFFECTDESC * [in]: Array of effect descriptor structures.
 *      DWORD * [out]: Receives the creation statuses of the effects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetFX"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetFX(DWORD dwFxCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes)
{
    HRESULT hr = DS_OK;

    DPF_API3(IDirectSoundBuffer8::SetFX, dwFxCount, pDSFXDesc, pdwResultCodes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (dwFxCount == 0) != (pDSFXDesc == NULL))
    {
        RPF(DPFLVL_ERROR, "Inconsistent dwFxCount and pDSFXDesc parameters");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFxCount == 0) && (pdwResultCodes != NULL))
    {
        RPF(DPFLVL_ERROR, "If dwFxCount is 0, pdwResultCodes must be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pDSFXDesc, dwFxCount * sizeof *pDSFXDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDSFXDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwResultCodes && !IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof *pdwResultCodes))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwResultCodes pointer");
        hr = DSERR_INVALIDPARAM;
    }

    for(DWORD i=0; SUCCEEDED(hr) && i<dwFxCount; ++i)
    {
        // This is ugly, but we know the <CDirectSoundPrimaryBuffer> instantiation
        // of this template doesn't get linked in, so we can cast safely here...
        if(!IsValidEffectDesc(pDSFXDesc+i, (CDirectSoundSecondaryBuffer*)m_pObject))
        {
            RPF(DPFLVL_ERROR, "Invalid DSEFFECTDESC structure #%d", i);
            hr = DSERR_INVALIDPARAM;
        }
        else if(pDSFXDesc[i].dwReserved1 != 0)
        {
            RPF(DPFLVL_ERROR, "Reserved fields in the DSEFFECTDESC structure must be 0");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFX(dwFxCount, pDSFXDesc, pdwResultCodes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquire resources for this buffer and report on effect status.
 *
 *  Arguments:
 *      DWORD [in]: Flags to control resource acquisition.
 *      DWORD [in]: Number of FX currently present on this buffer
 *      LPDWORD [out]: Array of effect status codes.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::AcquireResources"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::AcquireResources(DWORD dwFlags, DWORD dwFxCount, LPDWORD pdwResultCodes)
{
    HRESULT hr = DS_OK;

    DPF_API3(IDirectSoundBuffer8::AcquireResources, dwFlags, dwFxCount, pdwResultCodes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSBPLAY_LOCDEFERMASK))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_TIME) && (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE))
    {
        RPF(DPFLVL_ERROR, "Cannot use DSBPLAY_TERMINATEBY_TIME and DSBPLAY_TERMINATEBY_DISTANCE simultaneously");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFxCount == 0) && (pdwResultCodes != NULL))
    {
        RPF(DPFLVL_ERROR, "If the dwFxCount argument is 0, pdwResultCodes must be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFxCount != 0) && (!IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof(DWORD))))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwResultCodes pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->UserAcquireResources(dwFlags, dwFxCount, pdwResultCodes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface.
 *      LPVOID * [out]: Receives the interface requested.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetObjectInPath"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetObjectInPath(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DS_OK;

    DPF_API4(IDirectSoundBuffer8::GetObjectInPath, &guidObject, dwIndex, &iidInterface, ppObject);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidObject))
    {
        RPF(DPFLVL_ERROR, "Invalid guidObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&iidInterface))
    {
        RPF(DPFLVL_ERROR, "Invalid iidInterface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppObject))
    {
        RPF(DPFLVL_ERROR, "Invalid ppObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetObjectInPath(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelVolume
 *
 *  Description:
 *      Sets the volume on a set of output channels for a given mono buffer.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetChannelVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetChannelVolume(DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundBuffer::SetChannelVolume, dwChannelCount, pdwChannels, plVolumes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (dwChannelCount < 1 || dwChannelCount > 64))
    {
        RPF(DPFLVL_ERROR, "dwChannelCount out of bounds (1 to 64)");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pdwChannels, dwChannelCount * sizeof(DWORD)))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwChannels pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(plVolumes, dwChannelCount * sizeof(LONG)))
    {
        RPF(DPFLVL_ERROR, "Invalid plVolumes pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        DWORD dwChannelsSoFar = 0;
        for(DWORD i=0; i<dwChannelCount && SUCCEEDED(hr); ++i)
        {
            // The channel position must have exactly one bit set, other than the top bit (SPEAKER_ALL)
            if(!pdwChannels[i] || (pdwChannels[i] & (pdwChannels[i]-1)) || pdwChannels[i] == SPEAKER_ALL)
            {
                RPF(DPFLVL_ERROR, "Channel %d invalid", i);
                hr = DSERR_INVALIDPARAM;
            }
            if(dwChannelsSoFar & pdwChannels[i])
            {
                RPF(DPFLVL_ERROR, "Repeated channel position in pdwChannels");
                hr = DSERR_INVALIDPARAM;
            }
            else
            {
                dwChannelsSoFar |= pdwChannels[i];
            }
            if(plVolumes[i] < DSBVOLUME_MIN || plVolumes[i] > DSBVOLUME_MAX)
            {
                RPF(DPFLVL_ERROR, "Volume %d out of bounds", i);
                hr = DSERR_INVALIDPARAM;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetChannelVolume(dwChannelCount, pdwChannels, plVolumes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  CImpClassFactory
 *
 *  Description:
 *      IClassFactory implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::CImpClassFactory"

template <class object_type> CImpClassFactory<object_type>::CImpClassFactory(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_ICLASSFACTORY)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpClassFactory);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpClassFactory
 *
 *  Description:
 *      IClassFactory implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::~CImpClassFactory"

template <class object_type> CImpClassFactory<object_type>::~CImpClassFactory(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpClassFactory);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  CreateInstance
 *
 *  Description:
 *      Creates an instance of an object supported by this class factory.
 *
 *  Arguments:
 *      LPUNKNOWN [in]: controlling unknown.
 *      REFIID [in]: interface ID.
 *      LPVOID * [out]: receives requested interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::CreateInstance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpClassFactory<object_type>::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppvInterface)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IClassFactory::CreateInstance, pUnkOuter, &riid, ppvInterface);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_ICLASSFACTORY(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation not supported");
        hr = DSERR_NOAGGREGATION;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&riid))
    {
        RPF(DPFLVL_ERROR, "Invalid interface ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvInterface))
        {
            *ppvInterface = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid interface buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->CreateInstance(riid, ppvInterface);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  LockServer
 *
 *  Description:
 *      Increases or decreases the lock count on the dll.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to lock the server, FALSE to unlock it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::LockServer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpClassFactory<object_type>::LockServer(BOOL fLock)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IClassFactory::LockServer, fLock);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_ICLASSFACTORY(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->LockServer(fLock);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSound3dBuffer
 *
 *  Description:
 *      IDirectSound3dBuffer implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::CImpDirectSound3dBuffer"

template <class object_type> CImpDirectSound3dBuffer<object_type>::CImpDirectSound3dBuffer(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUND3DBUFFER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSound3dBuffer);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CDirectSound3dBuffer
 *
 *  Description:
 *      IDirectSound3dBuffer implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::~CDirectSound3dBuffer"

template <class object_type> CImpDirectSound3dBuffer<object_type>::~CImpDirectSound3dBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSound3dBuffer);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Retrieves all 3D properties for the buffer.
 *
 *  Arguments:
 *      LPDS3DBUFFER [out]: recieves properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetAllParameters(LPDS3DBUFFER pParam)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetAllParameters, pParam);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DS3DBUFFER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetAllParameters(pParam);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetConeAngles
 *
 *  Description:
 *      Gets inside and outside cone angles.
 *
 *  Arguments:
 *      LPDWORD [out]: receives inside cone angle.
 *      LPDWORD [out]: receives outside cone angle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetConeAngles"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetConeAngles(LPDWORD pdwInside, LPDWORD pdwOutside)
{
    HRESULT hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::GetConeAngles, pdwInside, pdwOutside);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwInside && !IS_VALID_TYPED_WRITE_PTR(pdwInside))
    {
        RPF(DPFLVL_ERROR, "Invalid inside pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwOutside && !IS_VALID_TYPED_WRITE_PTR(pdwOutside))
    {
        RPF(DPFLVL_ERROR, "Invalid inside pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pdwInside && !pdwOutside)
    {
        RPF(DPFLVL_ERROR, "Both inside and outside pointers are NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetConeAngles(pdwInside, pdwOutside);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetConeOrientation
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives cone orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetConeOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetConeOrientation(D3DVECTOR* pvrConeOrientation)
{
    HRESULT hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetConeOrientation, pvrConeOrientation);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrConeOrientation))
    {
        RPF(DPFLVL_ERROR, "Invalid vector pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetConeOrientation(pvrConeOrientation);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetConeOutsideVolume
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      LPLONG [out]: receives volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetConeOutsideVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetConeOutsideVolume(LPLONG plVolume)
{
    HRESULT hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetConeOutsideVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        RPF(DPFLVL_ERROR, "Invalid volume pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetConeOutsideVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMaxDistance
 *
 *  Description:
 *      Gets the object's maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives max distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetMaxDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetMaxDistance(D3DVALUE* pflMaxDistance)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetMaxDistance, pflMaxDistance);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid distance pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMaxDistance(pflMaxDistance);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMinDistance
 *
 *  Description:
 *      Gets the object's minimim distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives min distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetMinDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetMinDistance(D3DVALUE* pflMinDistance)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetMinDistance, pflMinDistance);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflMinDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid distance pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMinDistance(pflMinDistance);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMode
 *
 *  Description:
 *      Gets the object's mode.
 *
 *  Arguments:
 *      LPDWORD [out]: receives mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetMode"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetMode(LPDWORD pdwMode)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetMode, pdwMode);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwMode))
    {
        RPF(DPFLVL_ERROR, "Invalid mode pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMode(pdwMode);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the object's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetPosition, pvrPosition);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrPosition))
    {
        RPF(DPFLVL_ERROR, "Invalid position pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetPosition(pvrPosition);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the object's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetVelocity, pvrVelocity);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrVelocity))
    {
        RPF(DPFLVL_ERROR, "Invalid velocity pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVelocity(pvrVelocity);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object properties.
 *
 *  Arguments:
 *      LPDS3DBUFFER [in]: object parameters.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetAllParameters(LPCDS3DBUFFER pParam, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;
    BOOL                        fNorm;

    DPF_API2(IDirectSound3DBuffer::SetAllParameters, pParam, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DS3DBUFFER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(pParam->vPosition.x) || _isnan(pParam->vPosition.y) || _isnan(pParam->vPosition.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vPosition");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->vVelocity.x) || _isnan(pParam->vVelocity.y) || _isnan(pParam->vVelocity.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vVelocity");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->flMinDistance) || _isnan(pParam->flMaxDistance)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flMinDistance or flMaxDistance");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IsValidDs3dBufferConeAngles(pParam->dwInsideConeAngle, pParam->dwOutsideConeAngle))
    {
        hr = DSERR_INVALIDPARAM;
    }

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(pParam->vConeOrientation.x) || _isnan(pParam->vConeOrientation.y) || _isnan(pParam->vConeOrientation.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vConeOrientation");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        vr = pParam->vConeOrientation;
        CheckVector(&vr);
        fNorm = NormalizeVector(&vr);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length vector vConeOrientation");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_CONE_OUTSIDE_VOLUME(pParam->lConeOutsideVolume))
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MAX_DISTANCE(pParam->flMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Max Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MIN_DISTANCE(pParam->flMinDistance))
    {
        RPF(DPFLVL_ERROR, "Min Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MODE(pParam->dwMode))
    {
        RPF(DPFLVL_ERROR, "Invalid mode");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector((D3DVECTOR*)&(pParam->vPosition));
        CheckVector((D3DVECTOR*)&(pParam->vVelocity));
        CheckVector((D3DVECTOR*)&(pParam->vConeOrientation));
        fNorm = NormalizeVector((D3DVECTOR*)&(pParam->vConeOrientation));
        hr = m_pObject->SetAllParameters(pParam, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets the sound cone's angles.
 *
 *  Arguments:
 *      DWORD [in]: inside angle.
 *      DWORD [in]: outside angle.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetConeAngles"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetConeAngles(DWORD dwInside, DWORD dwOutside, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSound3DBuffer::SetConeAngles, dwInside, dwOutside, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidDs3dBufferConeAngles(dwInside, dwOutside))
    {
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetConeAngles(dwInside, dwOutside, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets the sound cone's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetConeOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetConeOrientation(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;
    BOOL                        fNorm;

    DPF_API4(IDirectSound3DBuffer::SetConeOrientation, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        SET_VECTOR(vr, x, y, z);

        CheckVector(&vr);
        fNorm = NormalizeVector(&vr);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length cone orientation vector");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetConeOrientation(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets the sound cone's outside volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetConeOutsideVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetConeOutsideVolume(LONG lVolume, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetConeOutsideVolume, lVolume, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_CONE_OUTSIDE_VOLUME(lVolume))
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetConeOutsideVolume(lVolume, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the object's maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: maximum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetMaxDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetMaxDistance(D3DVALUE flMaxDistance, DWORD dwFlags)
{
    HRESULT hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetMaxDistance, flMaxDistance, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flMaxDistance");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MAX_DISTANCE(flMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Max Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMaxDistance(flMaxDistance, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the object's minimum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: minimum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetMinDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetMinDistance(D3DVALUE flMinDistance, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetMinDistance, flMinDistance, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flMinDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flMinDistance");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MIN_DISTANCE(flMinDistance))
    {
        RPF(DPFLVL_ERROR, "Min Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMinDistance(flMinDistance, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the object's mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetMode"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetMode(DWORD dwMode, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetMode, dwMode, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MODE(dwMode))
    {
        RPF(DPFLVL_ERROR, "Invalid mode");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMode(dwMode, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the object's position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DBuffer::SetPosition, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetPosition(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the object's velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DBuffer::SetVelocity, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetVelocity(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetAttenuation
 *
 *  Description:
 *      Obtains the buffer's current true attenuation (as opposed to
 *      GetVolume, which just returns the last volume set by the app).
 *
 *  Arguments:
 *      FLOAT* [out]: attenuation in millibels.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBufferPrivate::GetAttenuation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetAttenuation(FLOAT* pfAttenuation)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetAttenuation, pfAttenuation);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pfAttenuation))
    {
        RPF(DPFLVL_ERROR, "Invalid attenuation pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetAttenuation(pfAttenuation);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSound3dListener
 *
 *  Description:
 *      IDirectSound3dListener implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::CImpDirectSound3dListener"

template <class object_type> CImpDirectSound3dListener<object_type>::CImpDirectSound3dListener(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUND3DLISTENER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSound3dListener);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSound3dListener
 *
 *  Description:
 *      IDirectSound3dListener implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::~CImpDirectSound3dListener"

template <class object_type> CImpDirectSound3dListener<object_type>::~CImpDirectSound3dListener(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSound3dListener);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Gets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [out]: receives properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetAllParameters(LPDS3DLISTENER pParam)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetAllParameters, pParam);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DS3DLISTENER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetAllParameters(pParam);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetDistanceFactor
 *
 *  Description:
 *      Gets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives distance factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetDistanceFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetDistanceFactor(D3DVALUE* pflDistanceFactor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetDistanceFactor, pflDistanceFactor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetDistanceFactor(pflDistanceFactor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetDopplerFactor
 *
 *  Description:
 *      Gets the world's doppler factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives doppler factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetDopplerFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetDopplerFactor(D3DVALUE* pflDopplerFactor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetDopplerFactor, pflDopplerFactor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetDopplerFactor(pflDopplerFactor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetOrientation
 *
 *  Description:
 *      Gets the listener's orientation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives front orientation.
 *      D3DVECTOR* [out]: receives top orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetOrientation(D3DVECTOR* pvrOrientationFront, D3DVECTOR* pvrOrientationTop)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::GetOrientation, pvrOrientationFront, pvrOrientationTop);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrOrientationFront) || !IS_VALID_TYPED_WRITE_PTR(pvrOrientationTop))
    {
        RPF(DPFLVL_ERROR, "Invalid orientation buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetOrientation(pvrOrientationFront, pvrOrientationTop);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the listener's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetPosition, pvrPosition);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrPosition))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetPosition(pvrPosition);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetRolloffFactor
 *
 *  Description:
 *      Gets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives rolloff factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetRolloffFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetRolloffFactor(D3DVALUE* pflRolloffFactor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetRolloffFactor, pflRolloffFactor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetRolloffFactor(pflRolloffFactor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the listener's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetVelocity, pvrVelocity);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrVelocity))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVelocity(pvrVelocity);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [in]: properties.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetAllParameters(LPCDS3DLISTENER pParam, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vrFront;
    D3DVECTOR                   vrTop;
    BOOL                        fNorm;

    DPF_API2(IDirectSound3DListener::SetAllParameters, pParam, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DS3DLISTENER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DISTANCE_FACTOR(pParam->flDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Distance factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DOPPLER_FACTOR(pParam->flDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Doppler factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(pParam->vPosition.x) || _isnan(pParam->vPosition.y) || _isnan(pParam->vPosition.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vPosition");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->vVelocity.x) || _isnan(pParam->vVelocity.y) || _isnan(pParam->vVelocity.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vVelocity");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->flDistanceFactor) || _isnan(pParam->flRolloffFactor) || _isnan(pParam->flDopplerFactor)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    CopyMemory(&vrFront, &(pParam->vOrientFront), sizeof(vrFront));
    CopyMemory(&vrTop, &(pParam->vOrientTop), sizeof(vrTop));

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(vrFront.x) || _isnan(vrFront.y) || _isnan(vrFront.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vOrientFront");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(vrTop.x) || _isnan(vrTop.y) || _isnan(vrTop.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vOrientTop");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vrFront);
        fNorm = NormalizeVector(&vrFront);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length vector vOrientFront");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vrTop);
        fNorm = NormalizeVector(&vrTop);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length vector vOrientTop");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !MakeOrthogonal(&vrFront, &vrTop))
    {
        RPF(DPFLVL_ERROR, "Invalid orientation vectors");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_ROLLOFF_FACTOR(pParam->flRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Rolloff factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector((D3DVECTOR*)&(pParam->vPosition));
        CheckVector((D3DVECTOR*)&(pParam->vVelocity));
        CheckVector((D3DVECTOR*)&(pParam->vOrientFront));
        CheckVector((D3DVECTOR*)&(pParam->vOrientTop));
        fNorm = NormalizeVector((D3DVECTOR*)&(pParam->vOrientFront));
        fNorm = NormalizeVector((D3DVECTOR*)&(pParam->vOrientTop));
        MakeOrthogonal((D3DVECTOR*)&(pParam->vOrientFront), (D3DVECTOR*)&(pParam->vOrientTop));
        hr = m_pObject->SetAllParameters(pParam, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetDistanceFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetDistanceFactor(D3DVALUE flDistanceFactor, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::SetDistanceFactor, flDistanceFactor, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flDistanceFactor");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DISTANCE_FACTOR(flDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Distance factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetDistanceFactor(flDistanceFactor, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetDopplerFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetDopplerFactor(D3DVALUE flDopplerFactor, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::SetDopplerFactor, flDopplerFactor, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flDopplerFactor");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DOPPLER_FACTOR(flDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Doppler factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetDopplerFactor(flDopplerFactor, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetOrientation
 *
 *  Description:
 *      Sets the listener's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: front orientation.
 *      REFD3DVECTOR [in]: top orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetOrientation(D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront, D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwFlags)
{
    HRESULT                     hr      = DS_OK;
    D3DVECTOR                   vrFront;
    D3DVECTOR                   vrTop;
    D3DVECTOR                   vrTemp;
    BOOL                        fNorm;

    DPF_API7(IDirectSound3DListener::SetOrientation, xFront, yFront, zFront, xTop, yTop, zTop, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(xFront) || _isnan(yFront) || _isnan(zFront) ||
                         _isnan(xTop)   || _isnan(yTop)   || _isnan(zTop)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        SET_VECTOR(vrFront, xFront, yFront, zFront);
        SET_VECTOR(vrTop, xTop, yTop, zTop);
        SET_VECTOR(vrTemp, xTop, yTop, zTop);

        CheckVector(&vrFront);
        fNorm = NormalizeVector(&vrFront);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length front vector");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vrTop);
        fNorm = NormalizeVector(&vrTop);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length top vector");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Normalize vrTemp so the subsequent call to MakeOrthogonal is valid
    if(SUCCEEDED(hr))
    {
        CheckVector(&vrTemp);
        fNorm = NormalizeVector(&vrTemp);
        if(!fNorm)
        {
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !MakeOrthogonal(&vrFront, &vrTemp))
    {
        RPF(DPFLVL_ERROR, "Invalid orientation vectors");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetOrientation(vrFront, vrTemp, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the listener's position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DListener::SetPosition, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetPosition(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetRolloffFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetRolloffFactor(D3DVALUE flRolloffFactor, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::SetRolloffFactor, flRolloffFactor, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flRolloffFactor");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_ROLLOFF_FACTOR(flRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Rolloff factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetRolloffFactor(flRolloffFactor, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the listener's velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DListener::SetVelocity, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetVelocity(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::CommitDeferredSettings"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::CommitDeferredSettings(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSound3DListener::CommitDeferredSettings);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->CommitDeferredSettings();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundNotify
 *
 *  Description:
 *      IDirectSoundNotify implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundNotify::CImpDirectSoundNotify"

template <class object_type> CImpDirectSoundNotify<object_type>::CImpDirectSoundNotify(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDNOTIFY)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundNotify);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundNotify
 *
 *  Description:
 *      IDirectSoundNotify implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundNotify::~CImpDirectSoundNotify"

template <class object_type> CImpDirectSoundNotify<object_type>::~CImpDirectSoundNotify(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundNotify);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundNotify::SetNotificationPositions"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundNotify<object_type>::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSoundNotify::SetNotificationPositions, dwCount, paNotes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDNOTIFY(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwCount && !IS_VALID_READ_PTR(paNotes, dwCount * sizeof(DSBPOSITIONNOTIFY)))
    {
        RPF(DPFLVL_ERROR, "Invalid notify buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!paNotes || !dwCount))
    {
        paNotes = NULL;
        dwCount = 0;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetNotificationPositions(dwCount, paNotes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpKsPropertySet
 *
 *  Description:
 *      IKsPropertySet implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::CImpKsPropertySet"

template <class object_type> CImpKsPropertySet<object_type>::CImpKsPropertySet(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IKSPROPERTYSET)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpKsPropertySet);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpKsPropertySet
 *
 *  Description:
 *      IKsPropertySet implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::~CImpKsPropertySet"

template <class object_type> CImpKsPropertySet<object_type>::~CImpKsPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpKsPropertySet);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  Get
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set ID.
 *      ULONG [in]: property ID.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [out]: receives property data.
 *      ULONG [in]: size of data passed in.
 *      PULONG [out]: size of data returned.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::Get"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpKsPropertySet<object_type>::Get(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData, PULONG pcbPropertyData)
{
    HRESULT                     hr  = DS_OK;

    DPF_API7(IKsPropertySet::Get, &guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData, pcbPropertyData);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IKSPROPERTYSET(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidPropertySetId(guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyParams || !cbPropertyParams))
    {
        pvPropertyParams = NULL;
        cbPropertyParams = 0;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvPropertyParams, cbPropertyParams))
    {
        RPF(DPFLVL_ERROR, "Invalid property parameters pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyData || !IS_VALID_READ_PTR(pvPropertyData, cbPropertyData)))
    {
        RPF(DPFLVL_ERROR, "Invalid property data pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, &cbPropertyData);

        if(pcbPropertyData)
        {
            *pcbPropertyData = cbPropertyData;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Set
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set ID.
 *      ULONG [in]: property ID.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [in/out]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::Set"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpKsPropertySet<object_type>::Set(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                     hr  = DS_OK;

    DPF_API6(IKsPropertySet::Set, &guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IKSPROPERTYSET(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidPropertySetId(guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyParams || !cbPropertyParams))
    {
        pvPropertyParams = NULL;
        cbPropertyParams = 0;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvPropertyParams, cbPropertyParams))
    {
        RPF(DPFLVL_ERROR, "Invalid property parameters pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyData || !cbPropertyData))
    {
        pvPropertyData = NULL;
        cbPropertyData = 0;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvPropertyData, cbPropertyData))
    {
        RPF(DPFLVL_ERROR, "Invalid property data pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set ID.
 *      ULONG [in]: property ID, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support bits.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::QuerySupport"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpKsPropertySet<object_type>::QuerySupport(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IKsPropertySet::QuerySupport, &guidPropertySetId, ulPropertyId, pulSupport);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IKSPROPERTYSET(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidPropertySetId(guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pulSupport))
    {
        RPF(DPFLVL_ERROR, "Invalid support pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

        #ifdef DEBUG
        static GUID DSPROPSETID_EAX20_ListenerProperties = {0x306a6a8, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22};
        static GUID DSPROPSETID_EAX20_BufferProperties = {0x306a6a7, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22};
        static GUID DSPROPSETID_I3DL2_ListenerProperties = {0xda0f0520, 0x300a, 0x11d3, 0x8a, 0x2b, 0x00, 0x60, 0x97, 0x0d, 0xb0, 0x11};
        static GUID DSPROPSETID_I3DL2_BufferProperties = {0xda0f0521, 0x300a, 0x11d3, 0x8a, 0x2b, 0x00, 0x60, 0x97, 0x0d, 0xb0, 0x11};
        TCHAR* pszPropSetName = NULL;

        if (guidPropertySetId == DSPROPSETID_VoiceManager)
            pszPropSetName = TEXT("DSPROPSETID_VoiceManager");
        else if (guidPropertySetId == DSPROPSETID_EAX20_ListenerProperties)
            pszPropSetName = TEXT("DSPROPSETID_EAX20_ListenerProperties");
        else if (guidPropertySetId == DSPROPSETID_EAX20_BufferProperties)
            pszPropSetName = TEXT("DSPROPSETID_EAX20_BufferProperties");
        else if (guidPropertySetId == DSPROPSETID_I3DL2_ListenerProperties)
            pszPropSetName = TEXT("DSPROPSETID_I3DL2_ListenerProperties");
        else if (guidPropertySetId == DSPROPSETID_I3DL2_BufferProperties)
            pszPropSetName = TEXT("DSPROPSETID_I3DL2_BufferProperties");

        if (pszPropSetName)
            DPF(DPFLVL_INFO, "Request for %s %sed", pszPropSetName, SUCCEEDED(hr) ? TEXT("succeed") : TEXT("fail"));
        else
            DPF(DPFLVL_INFO, "Request for unknown property set " DPF_GUID_STRING " %sed",
                DPF_GUID_VAL(guidPropertySetId), SUCCEEDED(hr) ? TEXT("succeed") : TEXT("fail"));
        #endif
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundCapture
 *
 *  Description:
 *      IDirectSoundCapture implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::CImpDirectSoundCapture"

template <class object_type> CImpDirectSoundCapture<object_type>::CImpDirectSoundCapture(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDCAPTURE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundCapture);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundCapture
 *
 *  Description:
 *      IDirectSoundCapture implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::~CImpDirectSoundCapture"

template <class object_type> CImpDirectSoundCapture<object_type>::~CImpDirectSoundCapture(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundCapture);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  CreateCaptureBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundCaptureBuffer object.
 *
 *  Arguments:
 *      LPCDSCBUFFERDESC [in]: description of the buffer to be created.
 *      LPDIRECTSOUNDCAPTUREBUFFER * [out]: receives a pointer to the new buffer.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::CreateCaptureBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCapture<object_type>::CreateCaptureBuffer(LPCDSCBUFFERDESC pDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppIdscb, LPUNKNOWN pUnkOuter)
{
    CDirectSoundCaptureBuffer * pBuffer = NULL;
    HRESULT                     hr      = DS_OK;
    DSCBUFFERDESC               dscbdi;

    DPF_API3(IDirectSoundCapture::CreateCaptureBuffer, pDesc, ppIdscb, pUnkOuter);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTURE(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer description");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(pDesc, &dscbdi, m_pObject->GetDsVersion());
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIdscb))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppIdscb = NULL;
        hr = m_pObject->CreateCaptureBuffer(&dscbdi, &pBuffer);
    }

    // NOTE: This call to CreateCaptureBuffer() has the important side effect of
    // updating the instance GUIDs in our effect list, mapping GUID_DSCFX_SYSTEM_*
    // to GUID_DSCFX_MS_* etc. for the system effects that default to MS ones.

    // Restrict some capture effects for use only with FullDuplex objects
    if(SUCCEEDED(hr) && pBuffer->NeedsMicrosoftAEC() && !m_pObject->HasMicrosoftAEC())
    {
        RPF(DPFLVL_ERROR, "The MS AEC, AGC and NS effects can only be used on full-duplex objects created with MS_AEC enabled");
        hr = DSERR_INVALIDPARAM;
    }

    // Query for an IDirectSoundCaptureBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundCaptureBuffer, TRUE, (LPVOID*)ppIdscb);
    }

    // Free resources
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with the capabilities of the object.
 *
 *  Arguments:
 *      LPDSCCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCapture<object_type>::GetCaps(LPDSCCAPS pCaps)
{
    HRESULT                 hr  = DS_OK;

    DPF_API1(IDirectSoundCapture::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTURE(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSCCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID.  This parameter may be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCapture<object_type>::Initialize(LPCGUID pGuid)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCapture::Initialize, pGuid);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTURE(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DS_OK == hr)
        {
            RPF(DPFLVL_ERROR, "DirectSoundCapture object already initialized");
            hr = DSERR_ALREADYINITIALIZED;
        }
        else if(DSERR_UNINITIALIZED == hr)
        {
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Initialize(pGuid, NULL);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(SUCCEEDED(m_pObject->IsInit()));
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundCaptureBuffer
 *
 *  Description:
 *      IDirectSoundCaptureBuffer implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::CImpDirectSoundCaptureBuffer"

template <class object_type> CImpDirectSoundCaptureBuffer<object_type>::CImpDirectSoundCaptureBuffer(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDCAPTUREBUFFER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundCaptureBuffer);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundCaptureBuffer
 *
 *  Description:
 *      IDirectSoundCaptureBuffer implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::~CImpDirectSoundCaptureBuffer"

template <class object_type> CImpDirectSoundCaptureBuffer<object_type>::~CImpDirectSoundCaptureBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundCaptureBuffer);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCBCAPS structure with the capabilities of the buffer.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetCaps(LPDSCBCAPS pCaps)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSCBCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current capture/read positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetCurrentPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetCurrentPosition(LPDWORD pdwCapture, LPDWORD pdwRead)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::GetCurrentPosition: pdwCapture=0x%p, pdwRead=0x%p", pdwCapture, pdwRead);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pdwCapture && !IS_VALID_TYPED_WRITE_PTR(pdwCapture))
    {
        RPF(DPFLVL_ERROR, "Invalid capture cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwRead && !IS_VALID_TYPED_WRITE_PTR(pdwRead))
    {
        RPF(DPFLVL_ERROR, "Invalid read cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pdwCapture && !pdwRead)
    {
        RPF(DPFLVL_ERROR, "Both cursor pointers can't be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCurrentPosition(pdwCapture, pdwRead);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::GetCurrentPosition: Leave, returning %s (Capture=%ld, Read=%ld)", HRESULTtoSTRING(hr), pdwCapture ? *pdwCapture : -1, pdwRead ? *pdwRead : -1);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      DWORD [in]: size of the above structure.
 *      LPDWORD [in/out]: On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundCaptureBuffer::GetFormat, pwfxFormat, dwSizeAllocated, pdwSizeWritten);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pwfxFormat)
    {
        DWORD dwSizeCheck = max(sizeof(WAVEFORMATEX), dwSizeAllocated);
        if(!IS_VALID_WRITE_PTR(pwfxFormat, dwSizeCheck))
        {
            RPF(DPFLVL_ERROR, "Invalid format buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && pdwSizeWritten && !IS_VALID_TYPED_WRITE_PTR(pdwSizeWritten))
    {
        RPF(DPFLVL_ERROR, "Invalid size pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pwfxFormat && !pdwSizeWritten)
    {
        RPF(DPFLVL_ERROR, "Either pwfxFormat or pdwSizeWritten must be non-NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(!pwfxFormat)
        {
            dwSizeAllocated = 0;
        }

        hr = m_pObject->GetFormat(pwfxFormat, &dwSizeAllocated);

        if(SUCCEEDED(hr) && pdwSizeWritten)
        {
            *pdwSizeWritten = dwSizeAllocated;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetStatus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer::GetStatus, pdwStatus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwStatus))
    {
        RPF(DPFLVL_ERROR, "Invalid status pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetStatus(pdwStatus);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.
 *
 *  Arguments:
 *      LPDIRECTSOUNDCAPTURE [in]: parent DirectSoundCapture object.
 *      LPDSCBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Initialize(LPDIRECTSOUNDCAPTURE pIdsc, LPCDSCBUFFERDESC pDesc)
{
    CImpDirectSoundCapture<CDirectSoundCapture> *   pImpDsCap   = (CImpDirectSoundCapture<CDirectSoundCapture> *)pIdsc;
    HRESULT                                         hr          = DS_OK;
    DSCBUFFERDESC                                   dscbdi;

    DPF_API2(IDirectSoundCaptureBuffer::Initialize, pIdsc, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUNDCAPTURE(pImpDsCap))
    {
        RPF(DPFLVL_ERROR, "Invalid parent interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer description");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(pDesc, &dscbdi, m_pObject->GetDsVersion());
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    // It's never valid to call this function.  We don't support
    // creating a DirectSoundCaptureBuffer object from anywhere but
    // IDirectSoundCapture::CreateCaptureBuffer.
    if(SUCCEEDED(hr))
    {
        RPF(DPFLVL_ERROR, "DirectSoundCapture buffer already initialized");
        hr = DSERR_ALREADYINITIALIZED;
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for reading.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: flags modifying the lock event.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Lock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Lock(DWORD dwReadCursor, DWORD dwReadBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                     hr              = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Lock: ReadCursor=%lu, ReadBytes=%lu, Flags=0x%lX", dwReadCursor, dwReadBytes, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr1))
        {
            *ppvAudioPtr1 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes1))
        {
            *pdwAudioBytes1 = 0;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && ppvAudioPtr2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr2))
        {
            *ppvAudioPtr2 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && pdwAudioBytes2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes2))
        {
            *pdwAudioBytes2 = 0;
        }
        else if(ppvAudioPtr2)
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSCBLOCK_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Lock(dwReadCursor, dwReadBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Lock: Leave, returning %s (AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu)",
        HRESULTtoSTRING(hr),
        ppvAudioPtr1 ? *ppvAudioPtr1 : NULL,
        pdwAudioBytes1 ? *pdwAudioBytes1 : NULL,
        ppvAudioPtr2 ? *ppvAudioPtr2 : NULL,
        pdwAudioBytes2 ? *pdwAudioBytes2 : NULL);

    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Start
 *
 *  Description:
 *      Starts the buffer capturing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Start"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Start(DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer::Start, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSCBSTART_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Start(dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops capturing to the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Stop"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Stop(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSoundCaptureBuffer::Stop);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Stop();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Unlock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Unlock: AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu",
        pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvAudioPtr1, dwAudioBytes1))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwAudioBytes2 && !IS_VALID_READ_PTR(pvAudioPtr2, dwAudioBytes2))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Unlock: Leave, returning %s", HRESULTtoSTRING(hr));
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::SetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::SetVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::SetVolume, lVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX))
    {
        DPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetVolume(lVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Gets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::GetVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        DPF(DPFLVL_ERROR, "Invalid volume ptr");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMicVolume
 *
 *  Description:
 *      Sets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::SetMicVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::SetMicVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::SetMicVolume, lVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX))
    {
        DPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMicVolume(lVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMicVolume
 *
 *  Description:
 *      Gets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetMicVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetMicVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::GetMicVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        DPF(DPFLVL_ERROR, "Invalid volume ptr");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMicVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  EnableMic
 *
 *  Description:
 *      Enables/disables the microphone line on this capture buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable the microphone, FALSE to disable it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::EnableMic"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::EnableMic(BOOL fEnable)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::EnableMic, fEnable);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->EnableMic(fEnable);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  YieldFocus
 *
 *  Description:
 *      Yields the capture focus to another capture buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::YieldFocus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::YieldFocus(void)
{
    HRESULT hr = DS_OK;

    DPF_API0(IDirectSoundCaptureBuffer7_1::YieldFocus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->YieldFocus();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  ClaimFocus
 *
 *  Description:
 *      Regains the capture focus.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::ClaimFocus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::ClaimFocus(void)
{
    HRESULT hr = DS_OK;

    DPF_API0(IDirectSoundCaptureBuffer7_1::ClaimFocus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->ClaimFocus();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFocusHWND
 *
 *  Description:
 *      Sets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND [in]: HWND to be associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::SetFocusHWND"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::SetFocusHWND(HWND hwndMainWindow)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::SetFocusHWND, hwndMainWindow);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hwndMainWindow))
    {
        DPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFocusHWND(hwndMainWindow);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFocusHWND
 *
 *  Description:
 *      Gets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND * [out]: receives HWND associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetFocusHWND"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetFocusHWND(HWND *pHwndMainWindow)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::GetFocusHWND, pHwndMainWindow);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pHwndMainWindow))
    {
        DPF(DPFLVL_ERROR, "Invalid window handle ptr");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFocusHWND(pHwndMainWindow);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  EnableFocusNotifications
 *
 *  Description:
 *      Requests focus change notifications to be sent.
 *
 *  Arguments:
 *      HANDLE [in]: event to signal when a capture focus change occurs.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::EnableFocusNotifications"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::EnableFocusNotifications(HANDLE hFocusEvent)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::EnableFocusNotifications, hFocusEvent);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !(hFocusEvent == NULL || IS_VALID_HANDLE(hFocusEvent)))
    {
        DPF(DPFLVL_ERROR, "Invalid event");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->EnableFocusNotifications(hFocusEvent);
    }

    DPF_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface.
 *      LPVOID * [out]: Receives the interface requested.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetObjectInPath"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetObjectInPath(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DS_OK;

    DPF_API4(IDirectSoundCaptureBuffer8::GetObjectInPath, &guidObject, dwIndex, &iidInterface, ppObject);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidObject))
    {
        RPF(DPFLVL_ERROR, "Invalid guidObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&iidInterface))
    {
        RPF(DPFLVL_ERROR, "Invalid iidInterface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppObject))
    {
        RPF(DPFLVL_ERROR, "Invalid ppObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetObjectInPath(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFXStatus
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetFXStatus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetFXStatus(DWORD dwFXCount, LPDWORD pdwFXStatus)
{
    HRESULT hr = DS_OK;

    DPF_API2(IDirectSoundCaptureBuffer8::GetFXStatus, dwFXCount, pdwFXStatus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && dwFXCount <= 0)
    {
        RPF(DPFLVL_ERROR, "Invalid dwFXCount <= 0");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(pdwFXStatus))
    {
        RPF(DPFLVL_ERROR, "Invalid dwFXStatus pointer");
        hr = DSERR_INVALIDPARAM;
    }


    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFXStatus(dwFXCount, pdwFXStatus);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundSink
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::CImpDirectSoundSink"

template <class object_type> CImpDirectSoundSink<object_type>::CImpDirectSoundSink(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDSINK)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundSink);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundSink
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::~CImpDirectSoundSink"

template <class object_type> CImpDirectSoundSink<object_type>::~CImpDirectSoundSink()
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundSink);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  AddSource
 *
 *  Description:
 *      Set attached source
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::AddSource"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::AddSource(IDirectSoundSource *pDSSource)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::AddSource, pDSSource);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->AddSource(pDSSource);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  RemoveSource
 *
 *  Description:
 *      Remove the attached source from the sink
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::RemoveSource"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::RemoveSource(IDirectSoundSource *pDSSource)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::RemoveSource, pDSSource);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->RemoveSource(pDSSource);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMasterClock
 *
 *  Description:
 *      IDirectSoundSink set master clock
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::SetMasterClock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::SetMasterClock(IReferenceClock *pClock)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::SetMasterClock, pClock);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMasterClock(pClock);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetLatencyClock
 *
 *  Description:
 *      IDirectSoundSink get latency clock
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetLatencyClock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetLatencyClock(IReferenceClock **ppClock)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundSynthSink::GetLatencyClock, ppClock);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppClock))
    {
        RPF(DPFLVL_ERROR, "Invalid ppClock pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetLatencyClock(ppClock);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Activate
 *
 *  Description:
 *      IDirectSoundSink activate
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::Activate"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::Activate(BOOL fEnable)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundSynthSink::Activate, fEnable);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Activate(fEnable);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SampleToRefTime
 *
 *  Description:
 *      IDirectSoundSink convert sample to reference time
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::SampleToRefTime"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prtTime)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSoundSynthSink::SampleToRefTime, llSampleTime, prtTime);
    DPF_ENTER();

    // This function doesn't take the DLL mutex because the clock object
    // itself is protected with a finer-grained critical section

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(prtTime))
    {
        RPF(DPFLVL_ERROR, "Invalid prtTime pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SampleToRefTime(llSampleTime, prtTime);
    }

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  RefToSampleTime
 *
 *  Description:
 *      IDirectSoundSink convert reference to sample time
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::RefToSampleTime"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::RefToSampleTime(REFERENCE_TIME rtTime, LONGLONG *pllSampleTime)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSoundSynthSink::RefToSampleTime, rtTime, pllSampleTime);
    DPF_ENTER();

    // This function doesn't take the DLL mutex because the clock object
    // itself is protected with a finer-grained critical section

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pllSampleTime))
    {
        RPF(DPFLVL_ERROR, "Invalid pllSampleTime pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->RefToSampleTime(rtTime, pllSampleTime);
    }

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: On exit, size of waveformat passed in;
 *                        on exit, size required/used.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundSynthSink::GetFormat, pwfxFormat, dwSizeAllocated, pdwSizeWritten);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pwfxFormat && !IS_VALID_WRITE_WAVEFORMATEX(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwSizeWritten && !IS_VALID_TYPED_WRITE_PTR(pdwSizeWritten))
    {
        RPF(DPFLVL_ERROR, "Invalid size pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pwfxFormat && !pdwSizeWritten)
    {
        RPF(DPFLVL_ERROR, "Either pwfxFormat or pdwSizeWritten must be non-NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(!pwfxFormat)
        {
            dwSizeAllocated = 0;
        }

        hr = m_pObject->GetFormat(pwfxFormat, &dwSizeAllocated);

        if(SUCCEEDED(hr) && pdwSizeWritten)
        {
            *pdwSizeWritten = dwSizeAllocated;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundBuffer object on a sink.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: description of the buffer to be created.
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::CreateSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount, REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;
    DSBUFFERDESC            dsbdi;

    DPF_API5(IDirectSoundConnect::CreateSoundBuffer, pcDSBufferDesc, pdwFuncID, dwBusIDCount, &guidBufferID, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pdwFuncID, sizeof(*pdwFuncID) * dwBusIDCount))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwFuncID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(pcDSBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pcDSBufferDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(pcDSBufferDesc, &dsbdi, DSVERSION_DX8, TRUE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidBufferID))
    {
        RPF(DPFLVL_ERROR, "Invalid guidBufferID argument");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid ppDSBuffer pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
        hr = m_pObject->CreateSoundBuffer(&dsbdi, pdwFuncID, dwBusIDCount, guidBufferID, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CreateSoundBufferFromConfig
 *
 *  Description:
 *      IDirectSoundSink CreateSoundBufferFromConfig
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::CreateSoundBufferFromConfig"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::CreateSoundBufferFromConfig(IUnknown *pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_API2(IDirectSoundConnect::CreateSoundBufferFromConfig, pConfig, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pConfig))
    {
        RPF(DPFLVL_ERROR, "Invalid pConfig pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
        hr = m_pObject->CreateSoundBufferFromConfig(pConfig, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSoundBuffer
 *
 *  Description:
 *      IDirectSoundSink GetSoundBuffer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetSoundBuffer(DWORD dwBusId, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_API2(IDirectSoundConnect::GetSoundBuffer, dwBusId, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid ppDSBuffer pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSoundBuffer(dwBusId, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID *)ppDSBuffer);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetBusCount
 *
 *  Description:
 *      IDirectSoundSink get bus count
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetBusCount"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetBusCount(LPDWORD pdwCount)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::GetBusCount, pdwCount);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwCount))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwCount pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetBusCount(pdwCount);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetBusIDs
 *
 *  Description:
 *      IDirectSoundSink get bus identifiers
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetBusIDs"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetBusIDs(DWORD *pdwBusIDs, DWORD *pdwFuncIDs, DWORD dwBusCount)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundConnect::GetBusIDs, pdwBusIDs, pdwFuncIDs, dwBusCount);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_PTR(pdwBusIDs, sizeof(*pdwBusIDs) * dwBusCount))
    {
        RPF(DPFLVL_ERROR, "Invalid Bus ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_PTR(pdwFuncIDs, sizeof(*pdwFuncIDs) * dwBusCount))
    {
        RPF(DPFLVL_ERROR, "Invalid Function ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetBusIDs(pdwBusIDs, pdwFuncIDs, dwBusCount);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSoundBufferBusIDs
 *
 *  Description:
 *      IDirectSoundSink get bus identifiers
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetSoundBufferBusIDs"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount)
{
    HRESULT hr = DS_OK;

    DPF_API4(IDirectSoundConnect::GetSoundBufferBusIDs, pDSBuffer, pdwBusIDs, pdwFuncIDs, pdwBusCount);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_PTR(pdwBusIDs, sizeof(*pdwBusIDs) * (*pdwBusCount)))
    {
        RPF(DPFLVL_ERROR, "Invalid Bus ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // pdwFuncIDs == NULL is acceptable
    if(SUCCEEDED(hr) && pdwFuncIDs && !IS_VALID_WRITE_PTR(pdwFuncIDs, sizeof(*pdwFuncIDs) * (*pdwBusCount)))
    {
        RPF(DPFLVL_ERROR, "Invalid Function ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    CImpDirectSoundBuffer<CDirectSoundBuffer>* pDsBuffer = (CImpDirectSoundBuffer<CDirectSoundBuffer>*)pDSBuffer;
    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUNDBUFFER(pDsBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid source buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSoundBufferBusIDs(pDsBuffer->m_pObject, pdwBusIDs, pdwFuncIDs, pdwBusCount);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFunctionalID
 *
 *  Description:
 *      Gets the functional ID from a bus ID.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetFunctionalID"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID)
{
    HRESULT hr = DS_OK;

    DPF_API2(IDirectSoundConnect::GetFunctionalID, dwBusID, pdwFuncID);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwFuncID))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwFuncID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFunctionalID(dwBusID, pdwFuncID);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpPersistStream
 *
 *  Description:
 *      IPersistStream
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::CImpPersistStream"

template <class object_type> CImpPersistStream<object_type>::CImpPersistStream(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IPERSISTSTREAM)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpPersistStream);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpPersistStream
 *
 *  Description:
 *      IPersistStream implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::~CImpPersistStream"

template <class object_type> CImpPersistStream<object_type>::~CImpPersistStream()
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpPersistStream);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetClassID
 *
 *  Description:
 *      IPersist::GetClassID
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::GetClassID"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::GetClassID(CLSID *pclsid)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IPersist::GetClassID, pclsid);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pclsid))
    {
        RPF(DPFLVL_ERROR, "Invalid pclsid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetClassID(pclsid);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  IsDirty
 *
 *  Description:
 *      IPersistStream::IsDirty
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::IsDirty"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::IsDirty()
{
    HRESULT                     hr;

    DPF_API0(IPersistStream::IsDirty);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        hr = m_pObject->IsDirty();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Load
 *
 *  Description:
 *      IPersistStream::Load
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::Load"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::Load(IStream *pStream)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IPersistStream::Load, pStream);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pStream))
    {
        RPF(DPFLVL_ERROR, "Invalid pStream pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Load(pStream);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Save
 *
 *  Description:
 *      IPersistStream::Save
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::Save"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::Save(IStream *pStream, BOOL fClearDirty)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IPersistStream::Save, pStream, fClearDirty);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pStream))
    {
        RPF(DPFLVL_ERROR, "Invalid pStream pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Save(pStream, fClearDirty);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSizeMax
 *
 *  Description:
 *      IPersistStream::GetSizeMax
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::GetSizeMax"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::GetSizeMax(ULARGE_INTEGER *pul)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IPersistStream::GetSizeMax, pul);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pul))
    {
        RPF(DPFLVL_ERROR, "Invalid pul pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSizeMax(pul);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectMusicObject
 *
 *  Description:
 *      IDirectMusicObject implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::CImpDirectMusicObject"

template <class object_type> CImpDirectMusicObject<object_type>::CImpDirectMusicObject(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTMUSICOBJECT)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectMusicObject);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectMusicObject
 *
 *  Description:
 *      IDirectMusicObject implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::~CImpDirectMusicObject"

template <class object_type> CImpDirectMusicObject<object_type>::~CImpDirectMusicObject()
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectMusicObject);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetDescriptor
 *
 *  Description:
 *      CImpDirectMusicObject::GetDescriptor
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::GetDescriptor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectMusicObject<object_type>::GetDescriptor(DMUS_OBJECTDESC *pDesc)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectMusicObject::GetDescriptor, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTMUSICOBJECT(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetDescriptor(pDesc);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetDescriptor
 *
 *  Description:
 *      CImpDirectMusicObject::SetDescriptor
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::SetDescriptor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectMusicObject<object_type>::SetDescriptor(DMUS_OBJECTDESC *pDesc)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectMusicObject::SetDescriptor, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTMUSICOBJECT(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetDescriptor(pDesc);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  ParseDescriptor
 *
 *  Description:
 *      CImpDirectMusicObject::ParseDescriptor
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::ParseDescriptor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectMusicObject<object_type>::ParseDescriptor(IStream *pStream, DMUS_OBJECTDESC *pDesc)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectMusicObject::ParseDescriptor, pStream, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTMUSICOBJECT(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pStream))
    {
        RPF(DPFLVL_ERROR, "Invalid pStream pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->ParseDescriptor(pStream, pDesc);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundFullDuplex
 *
 *  Description:
 *      IDirectSoundFullDuplex implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundFullDuplex::CImpDirectSoundFullDuplex"

template <class object_type> CImpDirectSoundFullDuplex<object_type>::CImpDirectSoundFullDuplex(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDFULLDUPLEX)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundFullDuplex);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundFullDuplex
 *
 *  Description:
 *      IDirectSoundFullDuplex implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundFullDuplex::~CImpDirectSoundFullDuplex"

template <class object_type> CImpDirectSoundFullDuplex<object_type>::~CImpDirectSoundFullDuplex(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundFullDuplex);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}

/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the DirectSoundFullDuplex object.
 *
 *  Arguments: [MISSING]
 *      LPCGUID [in]:
 *      LPCGUID [in]:
 *      LPCDSCBUFFERDESC [in]:
 *      LPCDSBUFFERDESC [in]:
 *      HWND [in]:
 *      DWORD [in]:
 *      LPLPDIRECTSOUNDCAPTUREBUFFER8 [out]:
 *      LPLPDIRECTSOUNDBUFFER8 [out]:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundFullDuplex::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundFullDuplex<object_type>::Initialize
(
    LPCGUID                         pCaptureGuid,
    LPCGUID                         pRenderGuid,
    LPCDSCBUFFERDESC                lpDscBufferDesc,
    LPCDSBUFFERDESC                 lpDsBufferDesc,
    HWND                            hWnd,
    DWORD                           dwLevel,
    LPLPDIRECTSOUNDCAPTUREBUFFER8   lplpDirectSoundCaptureBuffer8,
    LPLPDIRECTSOUNDBUFFER8          lplpDirectSoundBuffer8
)
{
    CDirectSoundCaptureBuffer *     pCaptureBuffer          = NULL;
    CDirectSoundBuffer *            pBuffer                 = NULL;
    HRESULT                         hr                      = DS_OK;
    DSCBUFFERDESC                   dscbdi;
    DSBUFFERDESC                    dsbdi;

    DPF_API8(IDirectSoundFullDuplex::Initialize, pCaptureGuid, pRenderGuid, lpDscBufferDesc, lpDsBufferDesc, hWnd, dwLevel, lplpDirectSoundCaptureBuffer8, lplpDirectSoundBuffer8);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDFULLDUPLEX(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(pCaptureGuid && !IS_VALID_READ_GUID(pCaptureGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid capture guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(pRenderGuid && !IS_VALID_READ_GUID(pRenderGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid render guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(lpDscBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DSC buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(lpDscBufferDesc, &dscbdi, DSVERSION_DX8);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(lpDsBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DS buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(lpDsBufferDesc, &dsbdi, DSVERSION_DX8, FALSE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && (dsbdi.dwFlags & DSBCAPS_PRIMARYBUFFER))
    {
        RPF(DPFLVL_ERROR, "Cannot specify DSBCAPS_PRIMARYBUFFER with DirectSoundFullDuplexCreate");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hWnd))
    {
        RPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwLevel < DSSCL_FIRST || dwLevel > DSSCL_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid cooperative level");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundCaptureBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid capture buffer interface buffer8");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid render buffer interface buffer8");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DS_OK == hr)
        {
            RPF(DPFLVL_ERROR, "DirectSoundFullDuplex object already initialized");
            hr = DSERR_ALREADYINITIALIZED;
        }
        else if(DSERR_UNINITIALIZED == hr)
        {
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        m_pObject->SetDsVersion(DSVERSION_DX8);

        hr = m_pObject->Initialize(pCaptureGuid, pRenderGuid, &dscbdi, &dsbdi,
                                   hWnd, dwLevel, &pCaptureBuffer, &pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(SUCCEEDED(m_pObject->IsInit()));
    }

    // Query for the required interfaces
    if(SUCCEEDED(hr))
    {
        hr = pCaptureBuffer->QueryInterface(IID_IDirectSoundCaptureBuffer8, TRUE, (LPVOID*)lplpDirectSoundCaptureBuffer8);
        ASSERT(SUCCEEDED(hr));
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8, TRUE, (LPVOID*)lplpDirectSoundBuffer8);
        ASSERT(SUCCEEDED(hr));
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsoundi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsoundi.h
 *  Content:    DirectSound internal header
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  08/25/99    duganp  Added effects processing for DirectX 8
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __DSOUNDI_H__
#define __DSOUNDI_H__

// Turn off spurious warnings about always true/false conditionals
// generated by some of our validation macros.
#pragma warning(disable:4296)

// We'll ask for what we need, thank you
#ifndef WIN32_LEAN_AND_MEAN
  #define WIN32_LEAN_AND_MEAN
#endif

#ifndef COM_NO_WINDOWS_H
  #define COM_NO_WINDOWS_H
#endif

// Define all flavors of 'WIN32'
#if defined(WIN32) || defined(_WIN32)
  #ifndef WIN32
    #define WIN32
  #endif
  #ifndef _WIN32
    #define _WIN32
  #endif
#endif // defined(WIN32) || defined(_WIN32)

// Define all flavors of 'WIN64'
#if defined(WIN64) || defined(_WIN64)
  #ifndef WIN64
    #define WIN64
  #endif
  #ifndef _WIN64
    #define _WIN64
  #endif
#endif // defined(WIN64) || defined(_WIN64)

// Define all flavors of 'DEBUG'
#ifdef DEBUG
  #ifndef _DEBUG
    #define _DEBUG
  #endif
  #ifndef RDEBUG
    #define RDEBUG
  #endif
  #ifndef DBG
    #define DBG 1
  #endif
#endif // DEBUG

// Either WIN95 or WINNT must always be defined.
// WIN95 really means "any Win9X platform" (including Windows 98 and ME).
// WINNT means "any NT-based platform" including Windows 2000, XP, etc.

#ifdef Not_VxD
  #if defined(WIN95) && defined(WINNT)
    #error Both WIN95 and WINNT defined
  #endif // defined(WIN95) && defined(WINNT)
  #if !defined(WIN95) && !defined(WINNT)
    #error Neither WIN95 nor WINNT defined
  #endif // !defined(WIN95) && !defined(WINNT)
#endif // Not_VxD

// Define or undefine all flavors of UNICODE
#ifdef WINNT
  #ifndef UNICODE
    #define UNICODE
  #endif
  #ifndef _UNICODE
    #define _UNICODE
  #endif
#else
  #undef UNICODE
  #undef _UNICODE
#endif // WINNT

// If we're building the VxD, we're obviously X86
#if !defined(Not_VxD) && !defined(_X86_)
  #define _X86_
#endif

// Can we use inline X86 assembler?  This definition must be before the
// inclusion of runtime.h and any other header files that use USE_INLINE_ASM
// in the future.
#if defined(_X86_) && !defined(WIN64)
  #define USE_INLINE_ASM
#endif

#include <windows.h>
#include <stddef.h>
#include <objbase.h>
#include <mmsystem.h>
#include <mmddkp.h>

#ifndef Not_VxD // If building dsound.vxd:

  #define WANTVXDWRAPS

  #ifdef __cplusplus
    extern "C" {
  #endif // __cplusplus
  #include <vmm.h>
  #include <vwin32.h>
  #include <vxdwraps.h>
  #include <vtd.h>
  #include <vmcpd.h>
  #ifdef __cplusplus
    }
  #endif // __cplusplus

#endif // Not_VxD

#include "dsmemmgr.h"
#include "dsoundp.h"
#include "dsprv.h"

#ifdef Not_VxD // If building dsound.dll:

  #include "debug.h"
  #include "runtime.h"

  #ifdef SHARED
    #include "ddrawp.h"
    #include "w95help.h"
  #endif // SHARED

  #ifndef NOKS
    #include <mmreg.h>      // Need to include mmreg.h before ksmedia.h; otherwise ksmedia.h
    #include <ks.h>         // will not define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT etc.
    #include <ksmedia.h>
    #include <dmksctrl.h>
  #endif // NOKS

  #ifdef WIN95
    #include "unicode.h"
  #endif // WIN95

  #include <dmusici.h>

  #include "resource.h"
  #include "dsdrvi.h"
  #include "dynaload.h"
  #include "decibels.h"
  #include "misc.h"
  #include "tlist.h"
  #include "vmanpset.h"
  #include "dsbasic.h"
  #include "dsvalid.h"
  #include "synch.h"
  #include "grace.h"
  #include "vad.h"
  #include "miscinl.h"
  #include "dsimp.h"
  #include "dscom.h"
  #include "dsadmin.h"
  #include "pnphlp.h"
  #include "iirlut.h"
  #include "vmaxcoef.h"
  #include "vmaxhead.h"
  #include "reghlp.h"
  #include "ds3d.h"
  #include "pset.h"
  #include "verify.h"
  #include "mxvad.h"
  #include "emvad.h"
  #include "vector.h"
  #include "capteff.h"
  #include "effects.h"
  #include "dsbufcfg.h"
  #include "dmstrm.h"
  #include "dsfd.h"

  #ifdef WINNT
    #define ENABLE_PERFLOG
    #include "perf.h"
  #endif

  #ifndef NOVXD
    #include "vxdvad.h"
    #include "dsvxdhlp.h"
    #include "dsvxd.h"
  #endif // NOVXD

  #ifndef NOKS
    #include "kshlp.h"
    #include "ks3d.h"
    #include "ksvad.h"
    #include "kscap.h"
  #endif // NOKS

  #include "dsaphack.h"
  #include "dsbuf.h"
  #include "dsclock.h"
  #include "dssink.h"
  #include "dsobj.h"
  #include "dsprvobj.h"
  #include "dscap.h"
  #include "ksuserw.h"

#else // !Not_VxD - building dsound.vxd:

  #include "runtime.h"
  #include "dsdrvi.h"
  #include "dsvxdi.h"
  #include "grace.h"

#endif // Not_VxD

#include "dsbnotes.h"

#if defined(Not_VxD) && defined(__cplusplus)
#include "dsimp.cpp"
#include "tlist.cpp"
#include "miscinl.cpp"
#endif // defined(Not_VxD) && defined(__cplusplus)

#endif // __DSOUNDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsprvobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.cpp
 *  Content:    DirectSound Private Object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/05/97    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

typedef struct tagDEVICEPRESENCE
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Emulated;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  VxD;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  WDM;
} DEVICEPRESENCE, *LPDEVICEPRESENCE;

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundMixer)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, CDirectSoundPrivate::GetMixerSrcQuality, CDirectSoundPrivate::SetMixerSrcQuality)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION, CDirectSoundPrivate::GetMixerAcceleration, CDirectSoundPrivate::SetMixerAcceleration)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundDevice)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1, CDirectSoundPrivate::GetDevicePresence1, CDirectSoundPrivate::SetDevicePresence1)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A, CDirectSoundPrivate::GetWaveDeviceMappingA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1, CDirectSoundPrivate::GetDeviceDescription1, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1, CDirectSoundPrivate::EnumerateDevices1, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W, CDirectSoundPrivate::GetWaveDeviceMappingW, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A, CDirectSoundPrivate::GetDeviceDescriptionA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W, CDirectSoundPrivate::GetDeviceDescriptionW, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A, CDirectSoundPrivate::EnumerateDevicesA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W, CDirectSoundPrivate::EnumerateDevicesW, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE, CDirectSoundPrivate::GetDevicePresence, CDirectSoundPrivate::SetDevicePresence)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundBasicAcceleration)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, CDirectSoundPrivate::GetBasicAcceleration, CDirectSoundPrivate::SetBasicAcceleration)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT, CDirectSoundPrivate::GetDefaultAcceleration, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundDebug)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A, CDirectSoundPrivate::GetDebugDpfInfoA, CDirectSoundPrivate::SetDebugDpfInfoA)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W, CDirectSoundPrivate::GetDebugDpfInfoW, CDirectSoundPrivate::SetDebugDpfInfoW)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A, CDirectSoundPrivate::TranslateResultCodeA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W, CDirectSoundPrivate::TranslateResultCodeW, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundPersistentData)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A, CDirectSoundPrivate::GetPersistentDataA, CDirectSoundPrivate::SetPersistentDataA)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W, CDirectSoundPrivate::GetPersistentDataW, CDirectSoundPrivate::SetPersistentDataW)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundBuffer)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID, CDirectSoundPrivate::GetBufferDeviceId, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSound)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUND_OBJECTS, CDirectSoundPrivate::GetDirectSoundObjects, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS, CDirectSoundPrivate::GetDirectSoundCaptureObjects, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_SETS(CDirectSoundPrivate, m_aPropertySets)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundMixer)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundDevice)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundBasicAcceleration)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundDebug)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundPersistentData)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundBuffer)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSound)
END_DECLARE_PROPERTY_SETS()


/***************************************************************************
 *
 *  CDirectSoundPrivate
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CDirectSoundPrivate"

CDirectSoundPrivate::CDirectSoundPrivate
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundPrivate);

    // Register the interface(s) with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSound object from CoCreateInstance or
    // IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IKsPropertySet, this, &m_pImpKsPropertySet);

    // Initialize the base class
    SetHandlerData(m_aPropertySets, NUMELMS(m_aPropertySets), this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundPrivate
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::~CDirectSoundPrivate"

CDirectSoundPrivate::~CDirectSoundPrivate
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundPrivate);

    // Free all interfaces
    DELETE(m_pImpKsPropertySet);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetMixerSrcQuality
 *
 *  Description:
 *      Gets the mixer SRC quality for a particular device or the default.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetMixerSrcQuality"

HRESULT WINAPI
CDirectSoundPrivate::GetMixerSrcQuality
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA            pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    pData->Quality = DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT;

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_SRCQUALITY;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Quality;
    Persist.DataSize = sizeof(pData->Quality);

    cbPersist = sizeof(Persist);

    hr = GetPersistentData(pThis, &Persist, &cbPersist);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMixerSrcQuality
 *
 *  Description:
 *      Sets the mixer SRC quality for a particular device or the default.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetMixerSrcQuality"

HRESULT WINAPI
CDirectSoundPrivate::SetMixerSrcQuality
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA            pData,
    ULONG                                                   cbData
)
{
    CNode<CDirectSound *> *                                 pNode;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    VADDEVICETYPE                                           vdt;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_SRCQUALITY;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Quality;
    Persist.DataSize = sizeof(pData->Quality);

    hr = SetPersistentData(pThis, &Persist, sizeof(Persist));

    if(SUCCEEDED(hr))
    {
        vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);
    }

    if(SUCCEEDED(hr) && IS_RENDER_VAD(vdt))
    {
        for(pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(SUCCEEDED(pNode->m_data->IsInit()))
            {
                if(pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId)
                {
                    pNode->m_data->m_pDevice->SetSrcQuality(pData->Quality);
                    break;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, DPF_GUID_STRING " SRC quality set to %lu", DPF_GUID_VAL(pData->DeviceId), pData->Quality);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetMixerAcceleration
 *
 *  Description:
 *      Gets mixer accleration settings for a particular device or the
 *      default.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetMixerAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::GetMixerAcceleration
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA          pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    pData->Flags = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_ACCELERATION;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Flags;
    Persist.DataSize = sizeof(pData->Flags);

    cbPersist = sizeof(Persist);

    hr = GetPersistentData(pThis, &Persist, &cbPersist);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMixerAcceleration
 *
 *  Description:
 *      Sets mixer accleration settings for a particular device or the
 *      default.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetMixerAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::SetMixerAcceleration
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA          pData,
    ULONG                                                   cbData
)
{
    CNode<CDirectSound *> *                                 pNode;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    VADDEVICETYPE                                           vdt;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_ACCELERATION;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Flags;
    Persist.DataSize = sizeof(pData->Flags);

    hr = SetPersistentData(pThis, &Persist, sizeof(Persist));

    if(SUCCEEDED(hr))
    {
        vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);
    }

    if(SUCCEEDED(hr) && IS_RENDER_VAD(vdt))
    {
        for(pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(SUCCEEDED(pNode->m_data->IsInit()))
            {
                if(pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId)
                {
                    pNode->m_data->m_pDevice->SetAccelerationFlags(pData->Flags);
                    break;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, DPF_GUID_STRING " acceleration flags set to %lu", DPF_GUID_VAL(pData->DeviceId), pData->Flags);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDevicePresence
 *
 *  Description:
 *      Gets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDevicePresence"

HRESULT WINAPI
CDirectSoundPrivate::GetDevicePresence
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA             pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    pData->Present = TRUE;

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_DEVICEPRESENCE;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Present;
    Persist.DataSize = sizeof(pData->Present);

    switch(pData->DeviceType)
    {
        case DIRECTSOUNDDEVICE_TYPE_EMULATED:
            Persist.ValueName = REGSTR_EMULATED;
            break;

        case DIRECTSOUNDDEVICE_TYPE_VXD:
            Persist.ValueName = REGSTR_VXD;
            break;

        case DIRECTSOUNDDEVICE_TYPE_WDM:
            Persist.ValueName = REGSTR_WDM;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    cbPersist = sizeof(Persist);

    hr = GetPersistentData(pThis, &Persist, &cbPersist);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetDevicePresence
 *
 *  Description:
 *      Sets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDevicePresence"

HRESULT WINAPI
CDirectSoundPrivate::SetDevicePresence
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA             pData,
    ULONG                                                   cbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_DEVICEPRESENCE;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Present;
    Persist.DataSize = sizeof(pData->Present);

    switch(pData->DeviceType)
    {
        case DIRECTSOUNDDEVICE_TYPE_EMULATED:
            Persist.ValueName = REGSTR_EMULATED;
            break;

        case DIRECTSOUNDDEVICE_TYPE_VXD:
            Persist.ValueName = REGSTR_VXD;
            break;

        case DIRECTSOUNDDEVICE_TYPE_WDM:
            Persist.ValueName = REGSTR_WDM;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    hr = SetPersistentData(pThis, &Persist, sizeof(Persist));


    // The chagnes above could change the available drivers.
    // Let's reset the static driver list.
    DPF(DPFLVL_INFO, "Resetting static driver list");
    g_pVadMgr->FreeStaticDriverList();


    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, DPF_GUID_STRING " (%s) presence set to %lu", DPF_GUID_VAL(pData->DeviceId), Persist.ValueName, pData->Present);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDevicePresence1
 *
 *  Description:
 *      Gets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDevicePresence1"

HRESULT WINAPI
CDirectSoundPrivate::GetDevicePresence1
(
    CDirectSoundPrivate *                           pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA   pData,
    PULONG                                          pcbData
)
{
    HRESULT                                         hr      = DS_OK;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA      Data;
    VADDEVICETYPE                                   vdt;
    ULONG                                           cbData;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);

    if(!vdt)
    {
        RPF(DPFLVL_ERROR, "Invalid device GUID: " DPF_GUID_STRING, DPF_GUID_VAL(pData->DeviceId));
        hr = DSERR_NODRIVER;
    }

    if(SUCCEEDED(hr))
    {
        cbData = sizeof(Data);

        Data.DeviceId = pData->DeviceId;

        switch(vdt)
        {
            case VAD_DEVICETYPE_EMULATEDRENDER:
            case VAD_DEVICETYPE_EMULATEDCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;
                break;

            case VAD_DEVICETYPE_VXDRENDER:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;
                break;

            case VAD_DEVICETYPE_KSRENDER:
            case VAD_DEVICETYPE_KSCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        hr = GetDevicePresence(pThis, &Data, &cbData);
    }

    if(SUCCEEDED(hr))
    {
        pData->Present = Data.Present;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetDevicePresence1
 *
 *  Description:
 *      Sets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDevicePresence1"

HRESULT WINAPI
CDirectSoundPrivate::SetDevicePresence1
(
    CDirectSoundPrivate *                           pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA   pData,
    ULONG                                           cbData
)
{
    HRESULT                                         hr      = DS_OK;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA      Data;
    VADDEVICETYPE                                   vdt;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);

    if(!vdt)
    {
        RPF(DPFLVL_ERROR, "Invalid device GUID: " DPF_GUID_STRING, DPF_GUID_VAL(pData->DeviceId));
        hr = DSERR_NODRIVER;
    }

    if(SUCCEEDED(hr))
    {
        Data.DeviceId = pData->DeviceId;
        Data.Present = pData->Present;

        switch(vdt)
        {
            case VAD_DEVICETYPE_EMULATEDRENDER:
            case VAD_DEVICETYPE_EMULATEDCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;
                break;

            case VAD_DEVICETYPE_VXDRENDER:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;
                break;

            case VAD_DEVICETYPE_KSRENDER:
            case VAD_DEVICETYPE_KSCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        hr = SetDevicePresence(pThis, &Data, sizeof(Data));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device GUID based on a waveOut/waveIn device
 *      description string.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetWaveDeviceMapping"

HRESULT WINAPI
CDirectSoundPrivate::GetWaveDeviceMapping
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA    pData,
    PULONG                                                  pcbData
)
{
    const UINT                                              cWaveOutDevs    = waveOutGetNumDevs();
    const UINT                                              cWaveInDevs     = waveInGetNumDevs();
    HRESULT                                                 hr              = DS_OK;
    CObjectList<CDeviceDescription>                         lstDrivers;
    CNode<CDeviceDescription *> *                           pDriverNode;
    WAVEOUTCAPS                                             woc;
    WAVEINCAPS                                              wic;
    UINT                                                    uId;
    MMRESULT                                                mmr;
    VADDEVICETYPE                                           vdt;

    DPF_ENTER();

    if (pData == NULL)
    {
        hr = E_POINTER;
        DPF_LEAVE_HRESULT(hr);
        return hr;
    }

    ASSERT(*pcbData >= sizeof(*pData));

    DPF(DPFLVL_INFO, "Looking for %s", pData->DeviceName);

    switch(pData->DataFlow)
    {
        case DIRECTSOUNDDEVICE_DATAFLOW_RENDER:
            vdt = VAD_DEVICETYPE_RENDERMASK;

            for(uId = 0; uId < cWaveOutDevs; uId++)
            {
                mmr = waveOutGetDevCaps(uId, &woc, sizeof(woc));
                if(MMSYSERR_NOERROR == mmr && !lstrcmp(woc.szPname, pData->DeviceName))
                    break;
            }

            if(uId >= cWaveOutDevs)
            {
                RPF(DPFLVL_ERROR, "Invalid waveOut device string: %s", pData->DeviceName);
                hr = DSERR_NODRIVER;
            }

            break;

        case DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE:
            vdt = VAD_DEVICETYPE_CAPTUREMASK;

            for(uId = 0; uId < cWaveInDevs; uId++)
            {
                mmr = waveInGetDevCaps(uId, &wic, sizeof(wic));
                if(MMSYSERR_NOERROR == mmr && !lstrcmp(wic.szPname, pData->DeviceName))
                    break;
            }

            if(uId >= cWaveInDevs)
            {
                RPF(DPFLVL_ERROR, "Invalid waveIn device string: %s", pData->DeviceName);
                hr = DSERR_NODRIVER;
            }

            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid data flow: %lu", pData->DataFlow);
            hr = DSERR_INVALIDPARAM;
            break;
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, "Wave device id: %lu", uId);
    }

    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->EnumDrivers(vdt, VAD_ENUMDRIVERS_ORDER, &lstDrivers);
    }

    if(SUCCEEDED(hr))
    {
        for(pDriverNode = lstDrivers.GetListHead(); pDriverNode; pDriverNode = pDriverNode->m_pNext)
            if(uId == pDriverNode->m_data->m_uWaveDeviceId)
                break;

        if(!pDriverNode)
        {
            RPF(DPFLVL_ERROR, "Can't find matching DirectSound device");
            hr = DSERR_NODRIVER;
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, "Found matching device: %s " DPF_GUID_STRING, (LPCTSTR)pDriverNode->m_data->m_strName, DPF_GUID_VAL(pDriverNode->m_data->m_guidDeviceId));
        pData->DeviceId = pDriverNode->m_data->m_guidDeviceId;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetWaveDeviceMappingA"

HRESULT WINAPI
CDirectSoundPrivate::GetWaveDeviceMappingA
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA  pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA     LocalData;
    ULONG                                                   cbLocalData;
    HRESULT                                                 hr;

    DPF_ENTER();

    LocalData.DeviceName = AnsiToTcharAlloc(pData->DeviceName);
    LocalData.DataFlow = pData->DataFlow;

    cbLocalData = sizeof(LocalData);

    hr = GetWaveDeviceMapping(pThis, &LocalData, &cbLocalData);

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = LocalData.DeviceId;
    }

    MEMFREE(LocalData.DeviceName);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetWaveDeviceMappingW"

HRESULT WINAPI
CDirectSoundPrivate::GetWaveDeviceMappingW
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA  pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA     LocalData;
    ULONG                                                   cbLocalData;
    HRESULT                                                 hr;

    DPF_ENTER();

    LocalData.DeviceName = UnicodeToTcharAlloc(pData->DeviceName);
    LocalData.DataFlow = pData->DataFlow;

    cbLocalData = sizeof(LocalData);

    hr = GetWaveDeviceMapping(pThis, &LocalData, &cbLocalData);

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = LocalData.DeviceId;
    }

    MEMFREE(LocalData.DeviceName);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceDescriptionA
 *
 *  Description:
 *      Gets the device description for a given DirectSound driver GUID.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDeviceDescriptionA"

HRESULT WINAPI
CDirectSoundPrivate::GetDeviceDescriptionA
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA    pData,
    PULONG                                              pcbData
)
{
    CDeviceDescription *                                pDesc   = NULL;
    HRESULT                                             hr;

    DPF_ENTER();

    hr = pData == NULL ? E_POINTER : S_OK;

    if (SUCCEEDED(hr))
    {
        ASSERT(*pcbData >= sizeof(*pData));

        if (IS_NULL_GUID(&pData->DeviceId))
            pData->DeviceId = (pData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) ? DSDEVID_DefaultPlayback : DSDEVID_DefaultCapture;

        hr = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);

        if(SUCCEEDED(hr))
            hr = CvtDriverDescA(pDesc, pData, pcbData);

        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDeviceDescriptionW"

HRESULT WINAPI
CDirectSoundPrivate::GetDeviceDescriptionW
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA    pData,
    PULONG                                              pcbData
)
{
    CDeviceDescription *                                pDesc   = NULL;
    HRESULT                                             hr;

    DPF_ENTER();

    hr = pData == NULL ? E_POINTER : S_OK;

    if (SUCCEEDED(hr))
    {
        ASSERT(*pcbData >= sizeof(*pData));

        if (IS_NULL_GUID(&pData->DeviceId))
            pData->DeviceId = (pData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) ? DSDEVID_DefaultPlayback : DSDEVID_DefaultCapture;

        hr = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);

        if(SUCCEEDED(hr))
            hr = CvtDriverDescW(pDesc, pData, pcbData);

        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDeviceDescription1"

HRESULT WINAPI
CDirectSoundPrivate::GetDeviceDescription1
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA    pData,
    PULONG                                              pcbData
)
{
    CDeviceDescription *                                pDesc   = NULL;
    HRESULT                                             hr;

    DPF_ENTER();

    hr = pData == NULL ? E_POINTER : S_OK;

    if (SUCCEEDED(hr))
    {
        ASSERT(*pcbData >= sizeof(*pData));

        if (IS_NULL_GUID(&pData->DeviceId))
            pData->DeviceId = (pData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) ? DSDEVID_DefaultPlayback : DSDEVID_DefaultCapture;

        hr = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);

        if(SUCCEEDED(hr))
            hr = CvtDriverDesc1(pDesc, pData);

        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnumerateDevices
 *
 *  Description:
 *      Enumerates all DirectSound devices.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::EnumerateDevicesA"

HRESULT WINAPI
CDirectSoundPrivate::EnumerateDevicesA
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA      pData,
    PULONG                                              pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA    pDesc       = NULL;
    ULONG                                               cbDesc      = 0;
    BOOL                                                fContinue   = TRUE;
    HRESULT                                             hr          = DS_OK;
    CObjectList<CDeviceDescription>                     lstDrivers;
    CNode<CDeviceDescription *> *                       pNode;

    DPF_ENTER();

    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_VALIDMASK, VAD_ENUMDRIVERS_ORDER, &lstDrivers);

    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr) && fContinue; pNode = pNode->m_pNext)
    {
        hr = CvtDriverDescA(pNode->m_data, NULL, &cbDesc);

        if(SUCCEEDED(hr))
        {
            pDesc = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA)MEMALLOC_A(BYTE, cbDesc);
            hr = HRFROMP(pDesc);
        }

        if(SUCCEEDED(hr))
        {
            hr = CvtDriverDescA(pNode->m_data, pDesc, &cbDesc);
        }

        if(SUCCEEDED(hr))
        {
            fContinue = pData->Callback(pDesc, pData->Context);
        }

        MEMFREE(pDesc);
        cbDesc = 0;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::EnumerateDevicesW"

HRESULT WINAPI
CDirectSoundPrivate::EnumerateDevicesW
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA      pData,
    PULONG                                              pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA    pDesc       = NULL;
    ULONG                                               cbDesc      = 0;
    BOOL                                                fContinue   = TRUE;
    HRESULT                                             hr          = DS_OK;
    CObjectList<CDeviceDescription>                     lstDrivers;
    CNode<CDeviceDescription *> *                       pNode;

    DPF_ENTER();

    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_VALIDMASK, VAD_ENUMDRIVERS_ORDER, &lstDrivers);

    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr) && fContinue; pNode = pNode->m_pNext)
    {
        hr = CvtDriverDescW(pNode->m_data, NULL, &cbDesc);

        if(SUCCEEDED(hr))
        {
            pDesc = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA)MEMALLOC_A(BYTE, cbDesc);
            hr = HRFROMP(pDesc);
        }

        if(SUCCEEDED(hr))
        {
            hr = CvtDriverDescW(pNode->m_data, pDesc, &cbDesc);
        }

        if(SUCCEEDED(hr))
        {
            fContinue = pData->Callback(pDesc, pData->Context);
        }

        MEMFREE(pDesc);
        cbDesc = 0;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::EnumerateDevices1"

HRESULT WINAPI
CDirectSoundPrivate::EnumerateDevices1
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA      pData,
    PULONG                                              pcbData
)
{
    BOOL                                                fContinue   = TRUE;
    HRESULT                                             hr          = DS_OK;
    CObjectList<CDeviceDescription>                     lstDrivers;
    CNode<CDeviceDescription *> *                       pNode;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA     Desc;

    DPF_ENTER();

    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_VALIDMASK, VAD_ENUMDRIVERS_ORDER, &lstDrivers);

    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr) && fContinue; pNode = pNode->m_pNext)
    {
        hr = CvtDriverDesc1(pNode->m_data, &Desc);

        if(SUCCEEDED(hr))
        {
            fContinue = pData->Callback(&Desc, pData->Context);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDebugDpfInfoA
 *
 *  Description:
 *      Gets DPF data.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDebugDpfInfoA"

HRESULT WINAPI
CDirectSoundPrivate::GetDebugDpfInfoA
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA pData,
    PULONG                                      pcbData
)
{
    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

#ifdef RDEBUG

    pData->Flags = g_dinfo.Data.Flags;
    pData->DpfLevel = g_dinfo.Data.DpfLevel;
    pData->BreakLevel = g_dinfo.Data.BreakLevel;
    TcharToAnsi(g_dinfo.Data.LogFile, pData->LogFile, NUMELMS(pData->LogFile));

#else // RDEBUG

    pData->Flags = pData->DpfLevel = pData->BreakLevel = 0;
    pData->LogFile[0] = '\0';

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDebugDpfInfoW"

HRESULT WINAPI
CDirectSoundPrivate::GetDebugDpfInfoW
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA pData,
    PULONG                                      pcbData
)
{
    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

#ifdef RDEBUG

    pData->Flags = g_dinfo.Data.Flags;
    pData->DpfLevel = g_dinfo.Data.DpfLevel;
    pData->BreakLevel = g_dinfo.Data.BreakLevel;
    TcharToUnicode(g_dinfo.Data.LogFile, pData->LogFile, NUMELMS(pData->LogFile));

#else // RDEBUG

    pData->Flags = pData->DpfLevel = pData->BreakLevel = 0;
    pData->LogFile[0] = '\0';

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetDebugDpfInfo
 *
 *  Description:
 *      Sets DPF data.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDebugDpfInfoA"

HRESULT
CDirectSoundPrivate::SetDebugDpfInfoA
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA pData,
    ULONG                                       cbData
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    LocalData;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

#ifdef RDEBUG

    LocalData.Flags = pData->Flags;
    LocalData.DpfLevel = pData->DpfLevel;
    LocalData.BreakLevel = pData->BreakLevel;
    AnsiToTchar(pData->LogFile, LocalData.LogFile, NUMELMS(LocalData.LogFile));
    dopen(&LocalData);

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDebugDpfInfoW"

HRESULT
CDirectSoundPrivate::SetDebugDpfInfoW
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA pData,
    ULONG                                       cbData
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    LocalData;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

#ifdef RDEBUG

    LocalData.Flags = pData->Flags;
    LocalData.DpfLevel = pData->DpfLevel;
    LocalData.BreakLevel = pData->BreakLevel;
    UnicodeToTchar(pData->LogFile, LocalData.LogFile, NUMELMS(LocalData.LogFile));
    dopen(&LocalData);

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  TranslateResultCode
 *
 *  Description:
 *      Translates an error code to a friendly string.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::TranslateResultCodeA"

HRESULT WINAPI
CDirectSoundPrivate::TranslateResultCodeA
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA pData,
    PULONG                                                  pcbData
)
{
    TCHAR                                                   szString[0x100];
    TCHAR                                                   szExplanation[0x100];
    ULONG                                                   ccString;
    ULONG                                                   cbString;
    ULONG                                                   ibString;
    ULONG                                                   ccExplanation;
    ULONG                                                   cbExplanation;
    ULONG                                                   ibExplanation;
    ULONG                                                   cbRequired;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    HresultToString(pData->ResultCode, szString, NUMELMS(szString), szExplanation, NUMELMS(szExplanation));

    ccString = TcharToAnsi(szString, NULL, 0);
    cbString = ccString * sizeof(CHAR);

    ccExplanation = TcharToAnsi(szExplanation, NULL, 0);
    cbExplanation = ccExplanation * sizeof(CHAR);

    cbRequired = sizeof(*pData);

    ibString = cbRequired;
    cbRequired += cbString;

    ibExplanation = cbRequired;
    cbRequired += cbExplanation;

    if(*pcbData >= cbRequired)
    {
        pData->String = (LPSTR)((LPBYTE)pData + ibString);
        TcharToAnsi(szString, pData->String, ccString);

        pData->Explanation = (LPSTR)((LPBYTE)pData + ibExplanation);
        TcharToAnsi(szExplanation, pData->Explanation, ccExplanation);
    }

    *pcbData = cbRequired;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::TranslateResultCodeW"

HRESULT WINAPI
CDirectSoundPrivate::TranslateResultCodeW
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA pData,
    PULONG                                                  pcbData
)
{
    TCHAR                                                   szString[0x100];
    TCHAR                                                   szExplanation[0x100];
    ULONG                                                   ccString;
    ULONG                                                   cbString;
    ULONG                                                   ibString;
    ULONG                                                   ccExplanation;
    ULONG                                                   cbExplanation;
    ULONG                                                   ibExplanation;
    ULONG                                                   cbRequired;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    HresultToString(pData->ResultCode, szString, NUMELMS(szString), szExplanation, NUMELMS(szExplanation));

    ccString = TcharToUnicode(szString, NULL, 0);
    cbString = ccString * sizeof(WCHAR);

    ccExplanation = TcharToUnicode(szExplanation, NULL, 0);
    cbExplanation = ccExplanation * sizeof(WCHAR);

    cbRequired = sizeof(*pData);

    ibString = cbRequired;
    cbRequired += cbString;

    ibExplanation = cbRequired;
    cbRequired += cbExplanation;

    if(*pcbData >= cbRequired)
    {
        pData->String = (LPWSTR)((LPBYTE)pData + ibString);
        TcharToUnicode(szString, pData->String, ccString);

        pData->Explanation = (LPWSTR)((LPBYTE)pData + ibExplanation);
        TcharToUnicode(szExplanation, pData->Explanation, ccExplanation);
    }

    *pcbData = cbRequired;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  GetDefaultAcceleration
 *
 *  Description:
 *      Gets default acceleration level.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDefaultAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::GetDefaultAcceleration
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA       pData,
    PULONG                                                      pcbData
)
{
    HRESULT                                                     hr              = DS_OK;
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA               Acceleration;
    DEVICEPRESENCE                                              DevicePresence;
    ULONG                                                       cb;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    Acceleration.DeviceId = pData->DeviceId;

    DevicePresence.Emulated.DeviceId = pData->DeviceId;
    DevicePresence.Emulated.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;

    DevicePresence.VxD.DeviceId = pData->DeviceId;
    DevicePresence.VxD.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;

    DevicePresence.WDM.DeviceId = pData->DeviceId;
    DevicePresence.WDM.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;

    // Get Default Mixer Acceleration
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   DefaultMixer;
    ULONG                                                   cbDefaultMixer;

    Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;

    DefaultMixer.DeviceId = Acceleration.DeviceId;
    DefaultMixer.SubKeyName = REGSTR_MIXERDEFAULTS;
    DefaultMixer.ValueName = REGSTR_ACCELERATION;
    DefaultMixer.RegistryDataType = REG_DWORD;
    DefaultMixer.Data = &Acceleration.Flags;
    DefaultMixer.DataSize = sizeof(Acceleration.Flags);

    cbDefaultMixer = sizeof(DefaultMixer);

    hr = GetDefaultData(pThis, &DefaultMixer, &cbDefaultMixer);


    // Get Device Presence

    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   DefaultDevice;
    ULONG                                                   cbDefaultDevice;

    // Emulated
    if (SUCCEEDED (hr))
    {
        DevicePresence.Emulated.Present = TRUE;

        DefaultDevice.DeviceId = DevicePresence.Emulated.DeviceId;
        DefaultDevice.SubKeyName = REGSTR_DEVICEPRESENCE;
        DefaultDevice.RegistryDataType = REG_DWORD;
        DefaultDevice.Data = &DevicePresence.Emulated.Present;
        DefaultDevice.DataSize = sizeof(DevicePresence.Emulated.Present);

        DefaultDevice.ValueName = REGSTR_EMULATED;



        cbDefaultDevice = sizeof(DefaultDevice);

        hr = GetDefaultData(pThis, &DefaultDevice, &cbDefaultDevice);
    }

    // VxD

    if (SUCCEEDED (hr))
    {
        DevicePresence.VxD.Present = TRUE;

        DefaultDevice.DeviceId = DevicePresence.VxD.DeviceId;
        DefaultDevice.SubKeyName = REGSTR_DEVICEPRESENCE;
        DefaultDevice.RegistryDataType = REG_DWORD;
        DefaultDevice.Data = &DevicePresence.VxD.Present;
        DefaultDevice.DataSize = sizeof(DevicePresence.VxD.Present);

        DefaultDevice.ValueName = REGSTR_VXD;

        cbDefaultDevice = sizeof(DefaultDevice);

        hr = GetDefaultData(pThis, &DefaultDevice, &cbDefaultDevice);
    }

   // WDM

    if (SUCCEEDED (hr))
    {
        DevicePresence.WDM.Present = TRUE;

        DefaultDevice.DeviceId = DevicePresence.WDM.DeviceId;
        DefaultDevice.SubKeyName = REGSTR_DEVICEPRESENCE;
        DefaultDevice.RegistryDataType = REG_DWORD;
        DefaultDevice.Data = &DevicePresence.WDM.Present;
        DefaultDevice.DataSize = sizeof(DevicePresence.WDM.Present);

        DefaultDevice.ValueName = REGSTR_WDM;

        cbDefaultDevice = sizeof(DefaultDevice);

        hr = GetDefaultData(pThis, &DefaultDevice, &cbDefaultDevice);
    }


    // Return Default


    if(SUCCEEDED(hr))
    {
        if(!DevicePresence.VxD.Present && !DevicePresence.WDM.Present)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_NONE;
        }
        else if(DIRECTSOUNDMIXER_ACCELERATIONF_FULL == Acceleration.Flags)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_FULL;
        }
        else if((Acceleration.Flags & DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD) && !(Acceleration.Flags & ~DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD))
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_STANDARD;
        }
        else
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_SAFE;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetBasicAcceleration
 *
 *  Description:
 *      Gets basic acceleration level.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetBasicAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::GetBasicAcceleration
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA  pData,
    PULONG                                                      pcbData
)
{
    HRESULT                                                     hr              = DS_OK;
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA               Acceleration;
    DEVICEPRESENCE                                              DevicePresence;
    ULONG                                                       cb;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    Acceleration.DeviceId = pData->DeviceId;

    DevicePresence.Emulated.DeviceId = pData->DeviceId;
    DevicePresence.Emulated.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;

    DevicePresence.VxD.DeviceId = pData->DeviceId;
    DevicePresence.VxD.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;

    DevicePresence.WDM.DeviceId = pData->DeviceId;
    DevicePresence.WDM.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;

    if(SUCCEEDED(hr))
    {
        cb = sizeof(Acceleration);
        hr = GetMixerAcceleration(pThis, &Acceleration, &cb);
    }

    if(SUCCEEDED(hr))
    {
        cb = sizeof(DevicePresence.Emulated);
        hr = GetDevicePresence(pThis, &DevicePresence.Emulated, &cb);
    }

    if(SUCCEEDED(hr))
    {
        cb = sizeof(DevicePresence.VxD);
        hr = GetDevicePresence(pThis, &DevicePresence.VxD, &cb);
    }

    if(SUCCEEDED(hr))
    {
        cb = sizeof(DevicePresence.WDM);
        hr = GetDevicePresence(pThis, &DevicePresence.WDM, &cb);
    }

    if(SUCCEEDED(hr))
    {
        if(!DevicePresence.VxD.Present && !DevicePresence.WDM.Present)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_NONE;
        }
        else if(DIRECTSOUNDMIXER_ACCELERATIONF_FULL == Acceleration.Flags)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_FULL;
        }
        else if((Acceleration.Flags & DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD) && !(Acceleration.Flags & ~DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD))
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_STANDARD;
        }
        else
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_SAFE;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetBasicAcceleration
 *
 *  Description:
 *      Sets basic acceleration level.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetBasicAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::SetBasicAcceleration
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA  pData,
    ULONG                                                       cbData
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA               Acceleration;
    DEVICEPRESENCE                                              DevicePresence;
    HRESULT                                                     hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Acceleration.DeviceId = pData->DeviceId;

    DevicePresence.Emulated.DeviceId = pData->DeviceId;
    DevicePresence.Emulated.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;
    DevicePresence.Emulated.Present = TRUE;

    DevicePresence.VxD.DeviceId = pData->DeviceId;
    DevicePresence.VxD.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;
    DevicePresence.VxD.Present = TRUE;

    DevicePresence.WDM.DeviceId = pData->DeviceId;
    DevicePresence.WDM.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;
    DevicePresence.WDM.Present = TRUE;

    switch(pData->Level)
    {
        case DIRECTSOUNDBASICACCELERATION_NONE:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_NONE;

            DevicePresence.VxD.Present = FALSE;
            DevicePresence.WDM.Present = FALSE;

            break;

        case DIRECTSOUNDBASICACCELERATION_SAFE:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_NONE;

            break;

        case DIRECTSOUNDBASICACCELERATION_STANDARD:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD;

            break;

        case DIRECTSOUNDBASICACCELERATION_FULL:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_FULL;

            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid basic acceleration level: %lu", pData->Level);
            hr = DSERR_INVALIDPARAM;
            break;
    }

    hr = SetMixerAcceleration(pThis, &Acceleration, sizeof(Acceleration));

    if(SUCCEEDED(hr))
    {
        hr = SetDevicePresence(pThis, &DevicePresence.Emulated, sizeof(DevicePresence.Emulated));
    }

    if(SUCCEEDED(hr))
    {
        hr = SetDevicePresence(pThis, &DevicePresence.VxD, sizeof(DevicePresence.VxD));
    }

    if(SUCCEEDED(hr))
    {
        hr = SetDevicePresence(pThis, &DevicePresence.WDM, sizeof(DevicePresence.WDM));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDefaultData
 *
 *  Description:
 *      Gets default data from the registry.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDefaultDataA"

HRESULT WINAPI
CDirectSoundPrivate::GetDefaultDataA
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));


    HKEY hkeyDefault;
    CDeviceDescription * pDesc = NULL;
    HRESULT hrT;

    hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
    if (SUCCEEDED(hrT))
    {
        if (IS_RENDER_VAD(pDesc->m_vdtDeviceType))
        {
            // Check for default persistent data
            hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
        }
        else
        {
            hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
        }

        if(SUCCEEDED(hrT))
        {
            hrT = RhRegGetValueA(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
            RhRegCloseKey(&hkeyDefault);
        }

        RELEASE(pDesc);

        if (SUCCEEDED(hrT)) hr = hrT;
    }


    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDefaultDataW"

HRESULT WINAPI
CDirectSoundPrivate::GetDefaultDataW
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    HKEY hkeyDefault;
    CDeviceDescription * pDesc = NULL;
    HRESULT hrT;

    hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
    if (SUCCEEDED(hrT))
    {
        if (IS_RENDER_VAD(pDesc->m_vdtDeviceType)) {
                // Check for default persistent data
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
        } else {
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
        }

        if(SUCCEEDED(hrT))
        {
            hrT = RhRegGetValueW(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
            RhRegCloseKey(&hkeyDefault);
        }

        RELEASE(pDesc);

        if (SUCCEEDED(hrT)) hr = hrT;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetPersistentData
 *
 *  Description:
 *      Gets persistent data from the registry.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetPersistentDataA"

HRESULT WINAPI
CDirectSoundPrivate::GetPersistentDataA
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyA(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegGetValueA(hkey, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);


    //
    // If value was not present (S_FALSE) then lets try to read the
    // machine default values
    //
    if (S_FALSE == hr)
    {
    	HKEY hkeyDefault;
        CDeviceDescription * pDesc = NULL;
    	HRESULT hrT;

        hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
        if (SUCCEEDED(hrT))
        {
	    if (IS_RENDER_VAD(pDesc->m_vdtDeviceType)) {
    	        // Check for default persistent data
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
	    } else {
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
	    }
	
            if(SUCCEEDED(hrT))
            {
                hrT = RhRegGetValueA(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
                RhRegCloseKey(&hkeyDefault);
            }

            RELEASE(pDesc);

            if (SUCCEEDED(hrT)) hr = hrT;
        }

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetPersistentDataW"

HRESULT WINAPI
CDirectSoundPrivate::GetPersistentDataW
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyW(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegGetValueW(hkey, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);

    //
    // If value was not present (S_FALSE) then lets try to read the
    // machine default values
    //
    if (S_FALSE == hr)
    {
    	HKEY hkeyDefault;
        CDeviceDescription * pDesc = NULL;
    	HRESULT hrT;

        hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
        if (SUCCEEDED(hrT))
        {
	    if (IS_RENDER_VAD(pDesc->m_vdtDeviceType)) {
    	        // Check for default persistent data
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
	    } else {
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
	    }
	
            if(SUCCEEDED(hrT))
            {
                hrT = RhRegGetValueW(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
                RhRegCloseKey(&hkeyDefault);
            }

            RELEASE(pDesc);

            if (SUCCEEDED(hrT)) hr = hrT;
        }

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetPersistentData
 *
 *  Description:
 *      Sets persistent data to the registry.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetPersistentDataA"

HRESULT WINAPI
CDirectSoundPrivate::SetPersistentDataA
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA    pData,
    ULONG                                                       cbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyA(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegSetValueA(hkey, pData->ValueName, pData->RegistryDataType, pData->Data, pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetPersistentDataW"

HRESULT WINAPI
CDirectSoundPrivate::SetPersistentDataW
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA    pData,
    ULONG                                                       cbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyW(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegSetValueW(hkey, pData->ValueName, pData->RegistryDataType, pData->Data, pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetBufferDeviceId
 *
 *  Description:
 *      Gets the device id that created the given buffer.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetBufferDeviceId"

HRESULT WINAPI
CDirectSoundPrivate::GetBufferDeviceId
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA pData,
    PULONG                                      pcbData
)
{
    CImpDirectSoundBuffer<CDirectSoundBuffer> *pBuffer = (CImpDirectSoundBuffer<CDirectSoundBuffer> *)pData->Buffer;
    HRESULT hr = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    if(!IS_VALID_IDIRECTSOUNDBUFFER(pBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = pBuffer->m_pObject->m_pDirectSound->m_pDevice->m_pDeviceDescription->m_guidDeviceId;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDirectSoundObjects
 *
 *  Description:
 *      Get information about the DirectSound objects existing in the
 *      current process.  If the pData->DeviceId field isn't GUID_NULL,
 *      return only the objects associated with that device ID.
 *
 *  Arguments:
 *      CDirectSoundPrivate* [in]: 'this' pointer.
 *      PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDirectSoundObjects"

HRESULT WINAPI
CDirectSoundPrivate::GetDirectSoundObjects
(
    CDirectSoundPrivate *                   pThis,
    PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA    pData,
    PULONG                                  pcbData
)
{
    CNode<CDirectSound*> *pNode;
    DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof *pData);

    pData->Count = 0;

    for (pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if (SUCCEEDED(pNode->m_data->IsInit()) &&
            pNode->m_data->GetOwnerProcessId() == dwProcessId &&
            (IS_NULL_GUID(&pData->DeviceId) ||
             pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId))
        {
            if (*pcbData >= (sizeof *pData + sizeof(DIRECTSOUND_INFO) * (1 + pData->Count)))
            {
                pData->Objects[pData->Count].DirectSound = pNode->m_data->m_pImpDirectSound;
                pData->Objects[pData->Count].DeviceId = pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId;
            }
            pData->Count++;
        }
    }

    // Set up the buffer size required to obtain all data:
    *pcbData = sizeof *pData + sizeof(DIRECTSOUND_INFO) * pData->Count;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDirectSoundCaptureObjects
 *
 *  Description:
 *      Get information about the DirectSoundCapture objects in the current
 *      process.  If the pData->DeviceId field isn't GUID_NULL, return only
 *      the DirectSoundCapture objects associated with that device ID.
 *
 *  Arguments:
 *      CDirectSoundPrivate* [in]: 'this' pointer.
 *      PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDirectSoundCaptureObjects"

HRESULT WINAPI
CDirectSoundPrivate::GetDirectSoundCaptureObjects
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA pData,
    PULONG                                      pcbData
)
{
    CNode<CDirectSoundCapture*> *pNode;
    DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof *pData);

    pData->Count = 0;

    for (pNode = g_pDsAdmin->m_lstCapture.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if (SUCCEEDED(pNode->m_data->IsInit()) &&
            pNode->m_data->GetOwnerProcessId() == dwProcessId &&
            (IS_NULL_GUID(&pData->DeviceId) ||
             pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId))
        {
            if (*pcbData >= (sizeof *pData + sizeof(DIRECTSOUNDCAPTURE_INFO) * (1 + pData->Count)))
            {
                pData->Objects[pData->Count].DirectSoundCapture = pNode->m_data->m_pImpDirectSoundCapture;
                pData->Objects[pData->Count].DeviceId = pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId;
            }
            pData->Count++;
        }
    }

    // Set up the buffer size required to obtain all data:
    *pcbData = sizeof *pData + sizeof(DIRECTSOUND_INFO) * pData->Count;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenPersistentDataKey
 *
 *  Description:
 *      Opens the persistent data key for a given device, or the default.
 *
 *  Arguments:
 *      REFGUID [in]: device GUID.
 *      BOOL [in]: TRUE to allow for key creation.
 *
 *  Returns:
 *      HKEY: registry key.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::OpenPersistentDataKey"

HRESULT
CDirectSoundPrivate::OpenPersistentDataKey
(
    REFGUID                 guid,
    PHKEY                   phkey
)
{
    CDeviceDescription *    pDesc       = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    hr = g_pVadMgr->GetDeviceDescription(guid, &pDesc);

    if(SUCCEEDED(hr))
    {
#ifdef WINNT
        hr = g_pVadMgr->OpenPersistentDataKey(pDesc->m_vdtDeviceType, pDesc->m_strInterface, phkey);
#else
        hr = g_pVadMgr->OpenPersistentDataKey(pDesc->m_vdtDeviceType, pDesc->m_dwDevnode, phkey);
#endif
    }

    RELEASE(pDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CvtDriverDesc
 *
 *  Description:
 *      Converts a CDeviceDescription object to a
 *      DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA structure.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: source.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: destination.
 *      PULONG [in/out]: destination size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CvtDriverDescA"

HRESULT
CDirectSoundPrivate::CvtDriverDescA
(
    CDeviceDescription *                                pSource,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA    pDest,
    PULONG                                              pcbDest
)
{
    ULONG                                               cbDest;
    LPCSTR                                              pszName;
    ULONG                                               cbName;
    ULONG                                               ibName;
    LPCSTR                                              pszPath;
    ULONG                                               cbPath;
    ULONG                                               ibPath;
    LPCSTR                                              pszInterface;
    ULONG                                               cbInterface;
    ULONG                                               ibInterface;

    DPF_ENTER();

    cbDest = sizeof *pDest;

    pszName = pSource->m_strName;
    cbName = lstrsizeA(pszName);
    ibName = cbDest;
    cbDest += cbName;

    pszPath = pSource->m_strPath;
    cbPath = lstrsizeA(pszPath);
    ibPath = cbDest;
    cbDest += cbPath;

    pszInterface = pSource->m_strInterface;
    cbInterface = lstrsizeA(pszInterface);
    ibInterface = cbDest;
    cbDest += cbInterface;

    // Set up the basic output fields
    if(pDest && (*pcbDest >= sizeof *pDest))
    {
        if(IS_EMULATED_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_EMULATED;
        else if(IS_VXD_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_VXD;
        else if(IS_KS_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_WDM;
        else
            ASSERT(FALSE);

        if(IS_RENDER_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
        else if(IS_CAPTURE_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
        else
            ASSERT(FALSE);

        pDest->DeviceId = pSource->m_guidDeviceId;
    }

    // Set up the string output fields (if there's room)
    if(*pcbDest >= cbDest)
    {
        if(pszName)
        {
            pDest->Description = (LPSTR)((LPBYTE)pDest + ibName);
            lstrcpyA(pDest->Description, pszName);
        }
        if(pszPath)
        {
            pDest->Module = (LPSTR)((LPBYTE)pDest + ibPath);
            lstrcpyA(pDest->Module, pszPath);
        }
        if(pszInterface)
        {
            pDest->Interface = (LPSTR)((LPBYTE)pDest + ibInterface);
            lstrcpyA(pDest->Interface, pszInterface);
        }
        pDest->WaveDeviceId = pSource->m_uWaveDeviceId;
    }

    *pcbDest = cbDest;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CvtDriverDescW"

HRESULT
CDirectSoundPrivate::CvtDriverDescW
(
    CDeviceDescription *                                pSource,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA    pDest,
    PULONG                                              pcbDest
)
{
    ULONG                                               cbDest;
    LPCWSTR                                             pszName;
    ULONG                                               cbName;
    ULONG                                               ibName;
    LPCWSTR                                             pszPath;
    ULONG                                               cbPath;
    ULONG                                               ibPath;
    LPCWSTR                                             pszInterface;
    ULONG                                               cbInterface;
    ULONG                                               ibInterface;

    DPF_ENTER();

    cbDest = sizeof *pDest;


    pszName = pSource->m_strName;
    cbName = lstrsizeW(pszName);
    ibName = cbDest;
    cbDest += cbName;

    pszPath = pSource->m_strPath;
    cbPath = lstrsizeW(pszPath);
    ibPath = cbDest;
    cbDest += cbPath;

    pszInterface = pSource->m_strInterface;
    cbInterface = lstrsizeW(pszInterface);
    ibInterface = cbDest;
    cbDest += cbInterface;

    // Set up the basic output fields
    if(pDest && (*pcbDest >= sizeof *pDest))
    {
        if(IS_EMULATED_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_EMULATED;
        else if(IS_VXD_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_VXD;
        else if(IS_KS_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_WDM;
        else
            ASSERT(FALSE);

        if(IS_RENDER_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
        else if(IS_CAPTURE_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
        else
            ASSERT(FALSE);

        pDest->DeviceId = pSource->m_guidDeviceId;
    }

    // Set up the string output fields (if there's room)
    if(pDest && (*pcbDest >= cbDest))
    {
        if(pszName)
        {
            pDest->Description = (LPWSTR)((LPBYTE)pDest + ibName);
            lstrcpyW(pDest->Description, pszName);
        }
        if(pszPath)
        {
            pDest->Module = (LPWSTR)((LPBYTE)pDest + ibPath);
            lstrcpyW(pDest->Module, pszPath);
        }
        if(pszInterface)
        {
            pDest->Interface = (LPWSTR)((LPBYTE)pDest + ibInterface);
            lstrcpyW(pDest->Interface, pszInterface);
        }
        pDest->WaveDeviceId = pSource->m_uWaveDeviceId;
    }

    *pcbDest = cbDest;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CvtDriverDesc1"

HRESULT
CDirectSoundPrivate::CvtDriverDesc1
(
    CDeviceDescription *                                pSource,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA    pDest
)
{
    DPF_ENTER();

    if(IS_EMULATED_VAD(pSource->m_vdtDeviceType))
        pDest->Type = DIRECTSOUNDDEVICE_TYPE_EMULATED;
    else if(IS_VXD_VAD(pSource->m_vdtDeviceType))
        pDest->Type = DIRECTSOUNDDEVICE_TYPE_VXD;
    else if(IS_KS_VAD(pSource->m_vdtDeviceType))
        pDest->Type = DIRECTSOUNDDEVICE_TYPE_WDM;
    else
        ASSERT(FALSE);

    if(IS_RENDER_VAD(pSource->m_vdtDeviceType))
        pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
    else if(IS_CAPTURE_VAD(pSource->m_vdtDeviceType))
        pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
    else
        ASSERT(FALSE);

    pDest->DeviceId = pSource->m_guidDeviceId;

    lstrcpynA(pDest->DescriptionA, pSource->m_strName, NUMELMS(pDest->DescriptionA));
    lstrcpynW(pDest->DescriptionW, pSource->m_strName, NUMELMS(pDest->DescriptionW));

    lstrcpynA(pDest->ModuleA, pSource->m_strPath, NUMELMS(pDest->ModuleA));
    lstrcpynW(pDest->ModuleW, pSource->m_strPath, NUMELMS(pDest->ModuleW));

    pDest->WaveDeviceId = pSource->m_uWaveDeviceId;
    pDest->Devnode = pSource->m_dwDevnode;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsmemmgr.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmemmgr.h
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/02/98    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSMEMMGR_H__
#define __DSMEMMGR_H__

#ifdef Not_VxD

#ifdef SHARED
#define SHARED_MEMORY_BOUNDARY  0x7FFFFFFF
#else
#define SHARED_MEMORY_BOUNDARY  0
#endif

#define IN_SHARED_MEMORY(p) \
            (((DWORD_PTR)(p)) > SHARED_MEMORY_BOUNDARY)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern BOOL MemInit(void);
extern void MemFini(void);

#ifdef DEBUG
extern LPVOID MemAlloc(SIZE_T, LPCTSTR, UINT, LPCTSTR);
extern LPVOID MemAllocCopy(LPCVOID, SIZE_T, LPCTSTR, UINT, LPCTSTR);
#else // DEBUG
extern LPVOID MemAlloc(SIZE_T);
extern LPVOID MemAllocCopy(LPCVOID, SIZE_T);
#endif // DEBUG

extern void MemFree(LPVOID);

#ifdef __cplusplus
}
#endif // __cplusplus

#else // Not_VxD

#define MemAlloc(a) \
            _HeapAllocate(a, HEAPZEROINIT | HEAPSWAP)

#define MemFree(a) \
            _HeapFree(a, 0)

#endif // Not_VxD

#if defined(DEBUG) && defined(Not_VxD)

#define MEMALLOC_A(type, count) \
            ((type *)MemAlloc(sizeof(type) * (count), TEXT(__FILE__), __LINE__, NULL))

#define MEMALLOC_A_COPY(type, count, src) \
            ((type *)MemAllocCopy(src, sizeof(type) * (count), TEXT(__FILE__), __LINE__, NULL))

#else // defined(DEBUG) && defined(Not_VxD)

#define MEMALLOC_A(type, count) \
            ((type *)MemAlloc(sizeof(type) * (count)))

#define MEMALLOC_A_COPY(type, count, src) \
            ((type *)MemAllocCopy(src, sizeof(type) * (count)))

#endif // defined(DEBUG) && defined(Not_VxD)

#define MEMALLOC(type) \
            MEMALLOC_A(type, 1)

#define MEMALLOC_COPY(type, src) \
            MEMALLOC_A_COPY(type, 1, src)

#define MEMALLOC_HR(p, type) \
            HRFROMP(p = MEMALLOC(type))

#define MEMALLOC_A_HR(p, type, count) \
            HRFROMP(p = MEMALLOC_A(type, count))

#define MEMALLOC_COPY_HR(p, type, src) \
            HRFROMP(p = MEMALLOC_COPY(type, src))

#define MEMALLOC_A_COPY_HR(p, type, count, src) \
            HRFROMP(p = MEMALLOC_A_COPY(type, count, src))

#define MEMFREE(p) \
            if (p) MemFree(p), (p) = NULL

#endif // __DSMEMMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsmemmgr.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmemmgr.c
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/02/98    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

// On Win9x we have to use our own heap because we create it SHARED;
// and in debug builds we do also, so that our HeapValidate() calls
// will only validate dsound's memory allocations, not the app's.
// But on NT retail builds we use the process heap for efficiency:

// #if defined(SHARED) || defined(DEBUG)
#define USE_OWN_HEAP
// #endif

// NOTE: we had to revert to the old behavior (always using a
// private heap in dsound) because of major appcompat issues -
// see Whistler bug 307628 for details.

static HANDLE g_hHeap = NULL;

#define MEMALIGN(size)      BLOCKALIGNPAD(size, sizeof(SIZE_T))

#ifndef HEAP_SHARED
#define HEAP_SHARED         0x04000000
#endif

#ifdef DEBUG

typedef struct tagDSMEMBLOCK
{
    DWORD                   dwCookie;
    struct tagDSMEMBLOCK *  pPrev;
    struct tagDSMEMBLOCK *  pNext;
    SIZE_T                  cbBuffer;
    LPCTSTR                 pszFile;
    UINT                    nLine;
    LPCTSTR                 pszClass;
} DSMEMBLOCK, *LPDSMEMBLOCK;
typedef const DSMEMBLOCK *LPCDSMEMBLOCK;

#define DSMEMBLOCK_SIZE     MEMALIGN(sizeof(DSMEMBLOCK))

#define PTRFROMBLOCK(p)     (((LPBYTE)(p)) + DSMEMBLOCK_SIZE)

#define BLOCKFROMPTR(p)     ((LPDSMEMBLOCK)(((LPBYTE)(p)) - DSMEMBLOCK_SIZE))

#ifndef FREE_MEMORY_PATTERN
#define FREE_MEMORY_PATTERN 0xDEADBEEF
#endif

#ifndef VALID_MEMORY_COOKIE
#define VALID_MEMORY_COOKIE 0xBAAABAAA
#endif

#ifndef FREE_MEMORY_COOKIE
#define FREE_MEMORY_COOKIE  0xBABABABA
#endif

#ifdef WINNT
#define ASSERT_VALID_HEAP() ASSERT(HeapValidate(g_hHeap, 0, NULL))
#else
#define ASSERT_VALID_HEAP()
#endif

static LPDSMEMBLOCK g_pFirst = NULL;
static HANDLE g_hHeapMutex = NULL;

#endif // DEBUG


/***************************************************************************
 *
 *  EnterHeapMutex
 *
 *  Description:
 *      Takes the heap mutex.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "EnterHeapMutex"

void EnterHeapMutex(void)
{
    DWORD dwWait = WaitObject(INFINITE, g_hHeapMutex);
    if (WAIT_OBJECT_0 != dwWait)
    {
        DPF(DPFLVL_WARNING, "WaitObject returned %s instead of WAIT_OBJECT_0", dwWait);
    }
    ASSERT_VALID_HEAP();
}

#endif // DEBUG


/***************************************************************************
 *
 *  LeaveHeapMutex
 *
 *  Description:
 *      Releases the heap mutex.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "LeaveHeapMutex"

void LeaveHeapMutex(void)
{
    BOOL fSuccess;

    ASSERT_VALID_HEAP();

    fSuccess = ReleaseMutex(g_hHeapMutex);
    ASSERT(fSuccess);
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemState
 *
 *  Description:
 *      Prints the current memory state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "MemState"

static void MemState(void)
{
    LPDSMEMBLOCK pCurrent;
    
    EnterHeapMutex();

    for(pCurrent = g_pFirst; pCurrent; pCurrent = pCurrent->pNext)
    {
        DPF(DPFLVL_ERROR, "%s at 0x%p (%lu) allocated from %s, line %lu", pCurrent->pszClass ? pCurrent->pszClass : TEXT("Memory"), PTRFROMBLOCK(pCurrent), pCurrent->cbBuffer, pCurrent->pszFile, pCurrent->nLine);
    }

    LeaveHeapMutex();
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemInit
 *
 *  Description:
 *      Initializes the memory manager.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemInit"

BOOL MemInit(void)
{
    BOOL fSuccess;

#ifdef USE_OWN_HEAP
    #ifdef SHARED
        g_hHeap = HeapCreate(HEAP_SHARED, 0x2000, 0);
    #else
        g_hHeap = HeapCreate(0, 0x2000, 0);
    #endif
#else
    g_hHeap = GetProcessHeap();
#endif

fSuccess = IsValidHandleValue(g_hHeap);
    
#ifdef DEBUG
    if(fSuccess)
    {
        g_hHeapMutex = CreateGlobalMutex(NULL);
        fSuccess = IsValidHandleValue(g_hHeapMutex);
    }
#endif

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  MemFini
 *
 *  Description:
 *      Frees the memory manager.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemFini"

void MemFini(void)
{
#ifdef DEBUG
    MemState();
    if (g_pFirst != NULL)
    {
        DPF(DPFLVL_ERROR, "Memory leak: g_pFirst = 0x%lX", g_pFirst);
        BREAK();
    }
    g_pFirst = NULL;
    CLOSE_HANDLE(g_hHeapMutex);
#endif

#ifdef USE_OWN_HEAP
    if(IsValidHandleValue(g_hHeap))
    {
        HeapDestroy(g_hHeap);
        g_hHeap = NULL;
    }
#endif
}


/***************************************************************************
 *
 *  MemAllocBuffer
 *
 *  Description:
 *      Allocates a buffer of memory.
 *
 *  Arguments:
 *      PSIZE_T [in/out]: size of buffer to allocate.
 *
 *  Returns:  
 *      LPVOID: buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemAllocBuffer"

LPVOID MemAllocBuffer(SIZE_T cbBuffer, PSIZE_T pcbAllocated)
{
    LPVOID pvBuffer;

    cbBuffer = MEMALIGN(cbBuffer);

    pvBuffer = HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, cbBuffer);

    if(pvBuffer && pcbAllocated)
    {
        *pcbAllocated = cbBuffer;
    }

    return pvBuffer;
}


/***************************************************************************
 *
 *  MemFreeBuffer
 *
 *  Description:
 *      Frees a buffer of memory.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemFreeBuffer"

void MemFreeBuffer(LPVOID pvBuffer)
{
    HeapFree(g_hHeap, 0, pvBuffer);
}


/***************************************************************************
 *
 *  MemAllocBlock
 *
 *  Description:
 *      Allocates a block of memory.
 *
 *  Arguments:
 *      SIZE_T [in]: size of buffer to allocate.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *      char * [in]: class name.
 *
 *  Returns:  
 *      LPDSMEMBLOCK: pointer to newly allocated block.
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "MemAllocBlock"

LPDSMEMBLOCK MemAllocBlock(SIZE_T cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass)
{
    LPDSMEMBLOCK pBlock;

    EnterHeapMutex();

    cbBuffer += DSMEMBLOCK_SIZE;
    
    pBlock = (LPDSMEMBLOCK)MemAllocBuffer(cbBuffer, &cbBuffer);

    if(pBlock)
    {
        pBlock->dwCookie = VALID_MEMORY_COOKIE;
        pBlock->pNext = g_pFirst;

        if(g_pFirst)
        {
            g_pFirst->pPrev = pBlock;
        }

        g_pFirst = pBlock;

        pBlock->cbBuffer = cbBuffer - DSMEMBLOCK_SIZE;
        pBlock->pszFile = pszFile;
        pBlock->nLine = nLine;
        pBlock->pszClass = pszClass;
    }

    LeaveHeapMutex();

    return pBlock;
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemFreeBlock
 *
 *  Description:
 *      Frees a block of memory.
 *
 *  Arguments:
 *      LPDSMEMBLOCK [in]: block pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "MemFreeBlock"

void MemFreeBlock(LPDSMEMBLOCK pBlock)
{
    EnterHeapMutex();

    ASSERT(VALID_MEMORY_COOKIE == pBlock->dwCookie);
    ASSERT(IS_VALID_WRITE_PTR(pBlock, offsetof(DSMEMBLOCK, cbBuffer) + sizeof(pBlock->cbBuffer)));
    ASSERT(IS_VALID_WRITE_PTR(pBlock, pBlock->cbBuffer));

    pBlock->dwCookie = FREE_MEMORY_COOKIE;

    if(pBlock->pPrev)
    {
        pBlock->pPrev->pNext = pBlock->pNext;
    }

    if(pBlock->pNext)
    {
        pBlock->pNext->pPrev = pBlock->pPrev;
    }

    if(pBlock == g_pFirst)
    {
        ASSERT(!pBlock->pPrev);
        g_pFirst = pBlock->pNext;
    }

    FillMemoryDword(PTRFROMBLOCK(pBlock), pBlock->cbBuffer, FREE_MEMORY_PATTERN);

    MemFreeBuffer(pBlock);

    LeaveHeapMutex();
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemAlloc
 *
 *  Description:
 *      Allocates memory.
 *
 *  Arguments:
 *      SIZE_T [in]: size of buffer to allocate.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *
 *  Returns:  
 *      LPVOID: pointer to newly allocated buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemAlloc"

LPVOID MemAlloc
(
#ifdef DEBUG
    SIZE_T cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass
#else // DEBUG
    SIZE_T cbBuffer
#endif // DEBUG
)
{
    LPVOID pvBuffer = NULL;

#ifdef DEBUG
    LPDSMEMBLOCK pBlock = MemAllocBlock(cbBuffer, pszFile, nLine, pszClass);
    if(pBlock)
    {
        pvBuffer = PTRFROMBLOCK(pBlock);
    }
#else // DEBUG
    pvBuffer = MemAllocBuffer(cbBuffer, NULL);
#endif // DEBUG

    return pvBuffer;
}


/***************************************************************************
 *
 *  MemAllocCopy
 *
 *  Description:
 *      Allocates memory and fills it with data from another buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to source buffer.
 *      SIZE_T [in]: size of buffer to allocate.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *
 *  Returns:  
 *      LPVOID: pointer to newly allocated buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemAllocCopy"

LPVOID MemAllocCopy
(
    LPCVOID pSource, 
#ifdef DEBUG
    SIZE_T cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass
#else // DEBUG
    SIZE_T cbBuffer
#endif // DEBUG
)
{
    LPVOID pDest;
    
#ifdef DEBUG
    pDest = MemAlloc(cbBuffer, pszFile, nLine, pszClass);
#else // DEBUG
    pDest = MemAlloc(cbBuffer);
#endif // DEBUG

    if(pDest)
    {
        CopyMemory(pDest, pSource, cbBuffer);
    }

    return pDest;
}


/***************************************************************************
 *
 *  MemFree
 *
 *  Description:
 *      Frees memory allocated by MemAlloc.
 *
 *  Arguments:
 *      LPVOID* [in]: buffer pointer.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemFree"

void MemFree(LPVOID pvBuffer)
{
    if(pvBuffer)
    {
#ifdef DEBUG
        MemFreeBlock(BLOCKFROMPTR(pvBuffer));
#else // DEBUG
        MemFreeBuffer(pvBuffer);
#endif // DEBUG
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsobj.h
 *  Content:    DirectSound object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __DSOBJ_H__
#define __DSOBJ_H__

#ifdef __cplusplus

// Fwd decl
class CDirectSoundBuffer;
class CDirectSoundSink;

// The main DirectSound object
class CDirectSound
    : public CUnknown, private CUsesEnumStandardFormats
{
    friend class CDirectSoundPrimaryBuffer;
    friend class CDirectSoundSecondaryBuffer;
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundPrivate;
    friend class CDirectSoundSink;
    friend class CDirectSoundFullDuplex;
#ifdef ENABLE_PERFLOG
    friend void OnPerflogStateChanged(void);
#endif

protected:
    CRenderDevice *                         m_pDevice;                  // The audio device
    CDirectSoundPrimaryBuffer *             m_pPrimaryBuffer;           // The one and only primary buffer
    CList<CDirectSoundSecondaryBuffer *>    m_lstSecondaryBuffers;      // List of all secondary buffers owned by this object
    DSCOOPERATIVELEVEL                      m_dsclCooperativeLevel;     // Cooperative level
    DSCAPS                                  m_dsc;                      // Device caps
    HKEY                                    m_hkeyParent;               // Root key for this device
    HRESULT                                 m_hrInit;                   // Has the object been initialized?
    DSAPPHACKS                              m_ahAppHacks;               // App hacks
    VmMode                                  m_vmmMode;                  // Voice manager mode

private:
    // Interfaces
    CImpDirectSound<CDirectSound> *m_pImpDirectSound;

public:
    CDirectSound(void);
    CDirectSound(CUnknown*);
    virtual ~CDirectSound(void);

public:
    // Creation
    virtual HRESULT Initialize(LPCGUID,CDirectSoundFullDuplex *);
    virtual HRESULT IsInit(void) {return m_hrInit;}

    // Functionality versioning
    virtual void SetDsVersion(DSVERSION);

    // Caps
    virtual HRESULT GetCaps(LPDSCAPS);

    // Sound buffer manipulation
    virtual HRESULT CreateSoundBuffer(LPCDSBUFFERDESC, CDirectSoundBuffer **);
    virtual HRESULT CreateSinkBuffer(LPDSBUFFERDESC, REFGUID, CDirectSoundSecondaryBuffer **, CDirectSoundSink *);
    virtual HRESULT DuplicateSoundBuffer(CDirectSoundBuffer *, CDirectSoundBuffer **);

    // Object properties
    virtual HRESULT GetSpeakerConfig(LPDWORD);
    virtual HRESULT SetSpeakerConfig(DWORD);

    // Misc
    virtual HRESULT SetCooperativeLevel(DWORD, DWORD);
    virtual HRESULT Compact(void);

    // IDirectSound8 methods
    virtual HRESULT VerifyCertification(LPDWORD);
#ifdef FUTURE_WAVE_SUPPORT
    virtual HRESULT CreateSoundBufferFromWave(IDirectSoundWave *, DWORD, CDirectSoundBuffer **);
#endif

    // IDirectSoundPrivate methods
    virtual HRESULT AllocSink(LPWAVEFORMATEX, CDirectSoundSink **);

protected:
    // Buffer creation
    virtual HRESULT CreatePrimaryBuffer(LPCDSBUFFERDESC, CDirectSoundBuffer **);
    virtual HRESULT CreateSecondaryBuffer(LPCDSBUFFERDESC, CDirectSoundBuffer **);

    // Device properties
    virtual HRESULT SetDeviceFormat(LPWAVEFORMATEX);
    virtual HRESULT SetDeviceFormatExact(LPCWAVEFORMATEX);
    virtual HRESULT SetDeviceVolume(LONG);
    virtual HRESULT SetDevicePan(LONG);

    // Misc
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
};

#endif // __cplusplus

#endif // __DSOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dsound\dsound\dsobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsobj.cpp
 *  Content:    DirectSound object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CDirectSound
 *
 *  Description:
 *      DirectSound object default constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CDirectSound"

CDirectSound::CDirectSound()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound);

    // Initialize defaults
    m_pDevice = NULL;
    m_pPrimaryBuffer = NULL;
    m_dsclCooperativeLevel.dwThreadId = 0;
    m_dsclCooperativeLevel.dwPriority = DSSCL_NORMAL;
    m_hkeyParent = NULL;
    m_hrInit = DSERR_UNINITIALIZED;
    m_vmmMode = DSPROPERTY_VMANAGER_MODE_DEFAULT;

    // Register the interfaces with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSound object from CoCreateInstance or
    // IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IDirectSound, this, &m_pImpDirectSound);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDirectSound
 *
 *  Description:
 *      DirectSound object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CDirectSound"

CDirectSound::CDirectSound
(
    CUnknown* pControllingUnknown
) : CUnknown(pControllingUnknown)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound);

    // Initialize defaults
    m_pDevice = NULL;
    m_pPrimaryBuffer = NULL;
    m_dsclCooperativeLevel.dwThreadId = 0;
    m_dsclCooperativeLevel.dwPriority = DSSCL_NORMAL;
    m_hkeyParent = NULL;
    m_hrInit = DSERR_UNINITIALIZED;
    m_vmmMode = DSPROPERTY_VMANAGER_MODE_DEFAULT;

    // Register the interfaces with the interface manager (see comment above).
    CreateAndRegisterInterface(this, IID_IDirectSound, this, &m_pImpDirectSound);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSound
 *
 *  Description:
 *      DirectSound object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::~CDirectSound"

CDirectSound::~CDirectSound(void)
{
    ULONG                                   ulCount;
    CNode<CDirectSoundSecondaryBuffer *> *  pNode;

    DPF_ENTER();
    DPF_DESTRUCT(CDirectSound);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Free all buffers
    if(ulCount = m_lstSecondaryBuffers.GetNodeCount())
    {
        while(pNode = m_lstSecondaryBuffers.GetListHead())
        {
            // Calling AbsoluteRelease instead of ABSOLUTE_RELEASE in
            // order to prevent a page fault.  ~CDirectSoundSecondaryBuffer
            // removes the buffer from the list, freeing pNode.
            // ABSOLUTE_RELEASE will try to set pNode->m_data to NULL after
            // calling AbsoluteRelease.
            pNode->m_data->AbsoluteRelease();
        }

        RPF(DPFLVL_ERROR, "Process 0x%8.8lX leaked %lu secondary buffers", GetCurrentProcessId(), ulCount);
    }

    ABSOLUTE_RELEASE(m_pPrimaryBuffer);

    // Free the audio device
    RELEASE(m_pDevice);

    // Free all interfaces
    DELETE(m_pImpDirectSound);

    // Close the registry key
    RhRegCloseKey(&m_hkeyParent);

    // Release the Administrator's worker thread
    if(SUCCEEDED(m_hrInit))
    {
        g_pDsAdmin->Terminate();
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  Normally, an object would have a pointer
 *      to another object of the same type to duplicate from.  DirectSound
 *      objects, however, are responsible for duplicating themselves based
 *      on the driver GUID.  DirectSound objects are special because they
 *      can be initialized by either DirectSoundCreate or CoInitialize.
 *      If this function fails, the object should be immediately deleted.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID, or NULL to use the preferred device.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Initialize"

HRESULT CDirectSound::Initialize
(
    LPCGUID pGuid,
    CDirectSoundFullDuplex * pFullDuplex
)
{
#ifdef DEBUG
    const ULONG                 ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG
    GUID                        guidDevice;
    VADDEVICETYPE               vdt             = VAD_DEVICETYPE_RENDERMASK;
    DWORD                       dwSpeakerConfig = DSSPEAKER_DEFAULT;
    DIRECTSOUNDMIXER_SRCQUALITY nSrcQuality     = DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT;
    DWORD                       dwAcceleration  = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;
    HRESULT                     hr              = DS_OK;
    DSBUFFERDESC                dsbd;
    HKEY                        hkey;
    HRESULT                     hrTemp;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);

    // Make a local copy of the driver GUID
    guidDevice = *BuildValidGuid(pGuid, NULL);

    // If the given GUID is one of the special default device IDs,
    // map it to the corresponding "real" DirectSound device ID.
    // Note: if guidDevice is GUID_NULL, GetDeviceIdFromDefaultId()
    // will fail, which is OK because GUID_NULL is handled below.
    g_pVadMgr->GetDeviceIdFromDefaultId(&guidDevice, &guidDevice);

    // Load apphacks for the current application
    AhGetAppHacks(&m_ahAppHacks);

    // Mask off devices that are turned off via an apphack.  OpenDevice
    // handles devices that are disabled via the standard registry keys.
    vdt &= ~m_ahAppHacks.vdtDisabledDevices;

    // Is there an open device we can use?
    hr = g_pVadMgr->FindOpenDevice(vdt, guidDevice, (CDevice **)&m_pDevice);

    if(SUCCEEDED(hr))
    {
        // Yup
        DPF(DPFLVL_INFO, "Found open device at 0x%p", m_pDevice);
    }
    else
    {
        // Nope.  Attempt to open a new device.
        hr = g_pVadMgr->OpenDevice(vdt, guidDevice, (CDevice **)&m_pDevice);
    }

    if(SUCCEEDED(hr) && pFullDuplex)
    {
        hr = m_pDevice->IncludeAEC
        (
            pFullDuplex->HasAEC(),
            pFullDuplex->AecInstanceGuid(),
            pFullDuplex->AecCreationFlags()
        );
    }

    // Read default device settings (e.g. acceleration and src quality) before
    // trying to read them from the device's registry.
    if (SUCCEEDED(hr))
    {
        HKEY hkeyDefault;
        hrTemp = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, REGSTR_MIXERDEFAULTS);
        if (SUCCEEDED(hrTemp))
        {
            RhRegGetBinaryValue(hkeyDefault, REGSTR_SRCQUALITY, &nSrcQuality, sizeof(nSrcQuality));
            RhRegGetBinaryValue(hkeyDefault, REGSTR_ACCELERATION, &dwAcceleration, sizeof(dwAcceleration));
            RhRegCloseKey(&hkeyDefault);
        }
    }

    // Open the device's registry key
    if(SUCCEEDED(hr))
    {
#ifdef WINNT
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_strInterface, &m_hkeyParent);
#else // WINNT
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_dwDevnode, &m_hkeyParent);
#endif // WINNT
    }

    // Load and apply persistent data
    if(SUCCEEDED(hr))
    {
        hrTemp = RhRegOpenKey(m_hkeyParent, REGSTR_MIXERDEFAULTS, 0, &hkey);
        if(SUCCEEDED(hrTemp))
        {
            RhRegGetBinaryValue(hkey, REGSTR_SRCQUALITY, &nSrcQuality, sizeof(nSrcQuality));
            RhRegGetBinaryValue(hkey, REGSTR_ACCELERATION, &dwAcceleration, sizeof(dwAcceleration));
            RhRegCloseKey(&hkey);
        }

        hrTemp = RhRegOpenKey(m_hkeyParent, REGSTR_SPEAKERCONFIG, 0, &hkey);
        if(SUCCEEDED(hrTemp))
        {
            RhRegGetBinaryValue(hkey, REGSTR_SPEAKERCONFIG, &dwSpeakerConfig, sizeof(dwSpeakerConfig));
            RhRegCloseKey(&hkey);
        }
    }

    if(SUCCEEDED(hr))
    {
        hrTemp = m_pDevice->SetSrcQuality(nSrcQuality);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set mixer SRC quality");
        }

        if (m_pDevice->m_vdtDeviceType & m_ahAppHacks.daDevAccel.vdtDevicesAffected)
        {
            dwAcceleration |= m_ahAppHacks.daDevAccel.dwAcceleration;
        }

        hrTemp = m_pDevice->SetAccelerationFlags(dwAcceleration);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set mixer acceleration flags");
        }

        hrTemp = SetSpeakerConfig(dwSpeakerConfig);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set speaker configuration");
            // FIXME: make sure these messages don't *always* happen
        }
    }

    // Create the primary buffer.  Every DirectSound object has exactly one
    // primary buffer.  When the application attempts to create a primary buffer
    // of its own, we'll just change some settings on the internal primary.
    if(SUCCEEDED(hr))
    {
        m_pPrimaryBuffer = NEW(CDirectSoundPrimaryBuffer(this));
        hr = HRFROMP(m_pPrimaryBuffer);
    }

    if(SUCCEEDED(hr))
    {
        InitStruct(&dsbd, sizeof(dsbd));

        dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;

        hr = m_pPrimaryBuffer->Initialize(&dsbd);
    }

    // Do not move this up before hr = m_pPrimaryBuffer->Initialize(&dsbd)
    // On a WDM driver, the dummy primary buffer isn't created until the
    // Initialize call.  After we have created the dummy primary buffer,
    // we can call GetCaps() successfully.
    if(SUCCEEDED(hr))
    {
        InitStruct(&m_dsc, sizeof(m_dsc));

        hr = m_pDevice->GetCaps(&m_dsc);
    }

    // We set the speaker config again now, after creating the primary buffer,
    // because the 3D listener also needs to receive this config.  [This call
    // to SetSpeakerConfig() is intentionally redundant with the one above.]
    if(SUCCEEDED(hr))
    {
        hrTemp = SetSpeakerConfig(dwSpeakerConfig);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set speaker configuration");
            // FIXME: make sure these message don't *always* happen
        }
    }

    // Initialize the Administrator
    if(SUCCEEDED(hr))
    {
        hr = g_pDsAdmin->Initialize();
    }

    // Success
    if(SUCCEEDED(hr))
    {
#ifdef DEBUG
        if(IS_KS_VAD(m_pDevice->m_vdtDeviceType))
        {
            DPF(DPFLVL_MOREINFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
        }
#endif // DEBUG
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDsVersion
 *
 *  Description:
 *      Makes us aware of our "functional level", so we can have different
 *      behavior depending on whether we're in a DX7 app, a DX8 app, etc.
 *
 *  Arguments:
 *      DSVERSION [in]: Owning application's functional level.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDsVersion"

void CDirectSound::SetDsVersion(DSVERSION nVersion)
{
    DPF_ENTER();

    CUnknown::SetDsVersion(nVersion);

    if (nVersion >= DSVERSION_DX8