llUsersCmDir(szCmAllUsersDir, g_hInst))
    {
        //
        // TRUE is for an All-User profile
        //
        if (!GetPhoneBookPath(szCmAllUsersDir, &pszPhonebook, TRUE))
        {
            CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- GetPhoneBookPath Failed, returning."));
            return FALSE;
        }
    }
    else
    {
        CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- GetAllUsersCmDir Failed, returning."));
        return FALSE;
    }

    //
    //  If its and IEAK5 profile then we need to get the System Directory
    //
    TCHAR szSysDir[MAX_PATH+1];
    if (bIeak5Profile)
    {
        if (0 == GetSystemDirectory(szSysDir, MAX_PATH))
        {
            CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- GetSystemDirectory Failed, returning."));
            return FALSE;
        }
    }

    //
    //  Now enumerate all of the All User Profiles and see if they need any
    //  Pre-Migration.
    //  
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_READ, &hKey))
    {
        DWORD dwIndex = 0;
        dwValueSize = MAX_PATH;
        dwDataSize = MAX_PATH;
                
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType, 
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            if (REG_SZ == dwType)
            {
                MYDBGASSERT(0 != szCurrentValue[0]);
                MYDBGASSERT(0 != szCurrentData[0]);

                if (ProfileNeedsMigration(szCurrentValue, szCurrentData))
                {
                    //
                    //  Use GetPhoneBookPath to get the path to the phonebook.
                    //
                    TCHAR szCmAllUsersDir[MAX_PATH+1] = {0};

                    //
                    //  Use RasSetEntryProperties to clear the connectoid
                    //
                    RASENTRY_V500 RasEntryV5 = {0};

                    RasEntryV5.dwSize = sizeof(RASENTRY_V500);
                    RasEntryV5.dwType = RASET_Internet;

                    if (bIeak5Profile)
                    {
                        //
                        //  Since IEAK5 didn't migrate 1.0 connectoids
                        //  properly (it writes them in %windir%\system32\pbk\rasphone.pbk
                        //  instead of under the all users profile as appropriate),
                        //  we need to set the szCustomDialDll instead of clearing it.
                        //
                        wsprintf(RasEntryV5.szCustomDialDll, TEXT("%s\\cmdial32.dll"), szSysDir);
                    }
                    // else zero the szCustomDialDll part of the entry
                    // RasEntryV5.szCustomDialDll[0] = TEXT('\0'); -- already zero-ed

                    DWORD dwRet = ((pfnSetEntryProperties)(pszPhonebook, szCurrentValue, 
                                                           (RASENTRY*)&RasEntryV5, 
                                                           RasEntryV5.dwSize, NULL, 0));
                    if (ERROR_SUCCESS != dwRet)
                    {
                        CMTRACE3(TEXT("EnumerateAndPreMigrateAllUserProfiles -- RasSetEntryProperties failed on entry %s in %s, dwRet = %u"), szCurrentValue, MYDBGSTR(pszPhonebook), dwRet);
                    }
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
       CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- No CM mappings key to migrate."));
    }

    CmFree(pszPhonebook);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  RunningUnderWow64
//
// Synopsis:  This function is used to tell if a 32-bit process is running under
//            Wow64 on an ia64 machine.  Note that if we are compiled 64-bit this
//            is always false.  We make the determination by trying to call
//            GetSystemWow64Directory.  If this function doesn't exist or returns
//            ERROR_CALL_NOT_IMPLEMENTED we know we are running on 32-bit.  If the
//            function returns successfully we know we are running under wow64.
//
// Arguments: None
//
// Returns:   BOOL - whether we are executing under wow64 or not
//
// History:   quintinb      Created     08/18/00
//
//+----------------------------------------------------------------------------
BOOL RunningUnderWow64 ()
{
#ifdef _WIN64
    return FALSE;
#else

    BOOL bReturn = FALSE;

    //
    //  First get a module handle for kernel32.dll.  Note it isn't necessary
    //  to free this handle as GetModuleHandle doesn't change the ref count.
    //
    HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));
    if (hKernel32)
    {
        //
        //  Next get the function pointer for GetSystemWow64Directory
        //
        typedef UINT (WINAPI *pfnGetSystemWow64DirectorySpec)(LPTSTR, UINT);
#ifdef UNICODE
        const CHAR* const c_pszGetSystemWow64FuncName = "GetSystemWow64DirectoryW";
#else
        const CHAR* const c_pszGetSystemWow64FuncName = "GetSystemWow64DirectoryA";
#endif

        pfnGetSystemWow64DirectorySpec pfnGetSystemWow64Directory = (pfnGetSystemWow64DirectorySpec)GetProcAddress(hKernel32, c_pszGetSystemWow64FuncName);

        if (pfnGetSystemWow64Directory)
        {
            TCHAR szSysWow64Path[MAX_PATH+1] = TEXT("");

            //
            //  GetSystemWow64Directory returns the number of chars copied to the buffer.
            //  If we get zero back, then we need to check the last error code to see what the
            //  reason for failure was.  If it was call not implemented then we know we are
            //  running on native x86.
            //
            UINT uReturn = pfnGetSystemWow64Directory(szSysWow64Path, MAX_PATH);

            DWORD dwError = GetLastError();

            CMTRACE2(TEXT("RunningUnderWow64 -- GetSystemWow64Directory returned \"%s\" and %d"), szSysWow64Path, uReturn);

            if (uReturn)
            {
                bReturn = TRUE;
            }
            else
            {
                CMTRACE1(TEXT("RunningUnderWow64 -- GetSystemWow64Directory returned zero, checking GLE=%d"), dwError);

                if (ERROR_CALL_NOT_IMPLEMENTED == dwError)
                {
                    bReturn = FALSE;
                }
                else
                {
                    //
                    //  We got an error, the return value is indeterminant.  Let's take a backup method
                    //  of looking for %windir%\syswow64 and see if we can find one.
                    //
                    if (GetWindowsDirectory (szSysWow64Path, MAX_PATH))
                    {
                        lstrcat(szSysWow64Path, TEXT("\\syswow64"));

                        HANDLE hDir = CreateFile(szSysWow64Path, GENERIC_READ, 
                                                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

                        CMTRACE2(TEXT("RunningUnderWow64 -- Fall back algorithm.  Does \"%s\" exist? %d"), szSysWow64Path, (INVALID_HANDLE_VALUE != hDir));
        
                        if (INVALID_HANDLE_VALUE != hDir)
                        {
                            bReturn = TRUE;
                            CloseHandle(hDir);
                        }
                    }
                }
            }
        }
    }

    return bReturn;

#endif
}

//+----------------------------------------------------------------------------
//
// Function:  CmstpExtensionProc
//
// Synopsis:  This function is called by cmstp.exe right after it processes the command
//            line and again after it completes its action.  It is most useful for modifying
//            the install behavior of profiles.  Since the cmstp.exe that shipped with the profile,
//            not the current version of cmstp.exe is used for the install, this proc
//            allows us to change the install flags, change the inf path, and tell cmstp
//            to continue or silently fail the install.  This version of the proc looks for
//            old versions of cmstp.exe and then copies the installation files to a temporary
//            directory and then launches the system's version of cmstp.exe with the new
//            install directory and parameters (we add the /c switch so that cmstp.exe knows to
//            cleanup after itself and to wait on the mutex).
//
// Arguments: LPDWORD pdwFlags - command line flags parsed by cmstp.exe
//            LPTSTR pszInfFile - Path to the original INF file
//            HRESULT hrRet - Return value of the action, only really used for POST
//            EXTENSIONDLLPROCTIMES PreOrPost - PRE or POST, tells when we are being called.
//
// Returns:   BOOL - Whether Cmstp.exe should continue the existing install or not.
//
// History:   quintinb Created     6/2/99
//
//+----------------------------------------------------------------------------
BOOL CmstpExtensionProc(LPDWORD pdwFlags, LPTSTR pszInfFile, HRESULT hrRet, EXTENSIONDLLPROCTIMES PreOrPost)
{
    //
    //  We don't want 32-bit profiles installing on 64-bit.  Note that the 32-bit version of cmcfg32.dll will be
    //  in the syswow64 dir on a 64-bit machine.  Thus the code below will kick in when a 32-bit version of this
    //  function is used on a 64-bit machine.  We also don't want 32-bit profiles trying to do migration, uninstalling,
    //  etc.
    //

    if (RunningUnderWow64())
    {
        //
        //  If this is an install, show an error message about not being able to install 32-bit profiles
        //  on 64-bit.
        //
        if (0 == ((*pdwFlags) & 0xFF))
        {
            //
            //  Get the long service name from the Inf
            //
            TCHAR szServiceName[MAX_PATH+1] = TEXT("");
            TCHAR szMsg[MAX_PATH+1] = TEXT("");

            MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, TEXT(""), szServiceName, CELEMS(szServiceName), pszInfFile));
            MYVERIFY(0 != LoadString(g_hInst, IDS_NO_I386_ON_IA64, szMsg, MAX_PATH));

            MYVERIFY(IDOK == MessageBox(NULL, szMsg, szServiceName, MB_OK));
        }

        //
        //  Fail whatever operation we were called to do
        //
        return FALSE;
    }

    //
    //  If the first two Hex digits in the flags value are Zero, then we have an install.
    //  Otherwise we have some other command that we wish to ignore.  We also are only
    //  interested in processing PRE install calls.
    //

    if ((0 == ((*pdwFlags) & 0xFF)) && (PRE == PreOrPost))
    {
        CMTRACE(TEXT("CmstpExtensionProc -- Entering the cmstpex processing loop."));
        //
        //  We only wish to re-launch the install with the current cmstp.exe if we are dealing with an
        //  older install.  Thus check the version stamp in the inf file.  We will re-launch any
        //  profiles with the version number less than the current version number of cmdial32.dll.
        //
        CmVersion CmVer;

        DWORD dwProfileVersionNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, c_pszVersion, 0, 
                                                                   pszInfFile);

        DWORD dwProfileBuildNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, c_pszVerBuild, 0, 
                                                                   pszInfFile);
       
        if ((CmVer.GetVersionNumber() > dwProfileVersionNumber) ||
            ((CmVer.GetVersionNumber() == dwProfileVersionNumber) && 
             (CmVer.GetBuildAndQfeNumber() > dwProfileBuildNumber)))
        {
            //
            //  Then we need to delete the CM bits included with the profile because
            //  otherwise we will get install errors due to the fact that the profile
            //  will be launched with the cmdial32.dll from system32 (the path is
            //  explicitly specified in the connectoid for the custom dial dll), but
            //  the load path used by the system is the directory from which the exe
            //  module loaded (the temp dir in this case).  Thus we will get a mixed
            //  set of bits (cmdial32.dll from system32 and cmutil.dll, cmpbk32.dll, etc.
            //  from the cab).
            //

            TCHAR szTempDir[MAX_PATH+1];

            lstrcpy (szTempDir, pszInfFile);
            LPTSTR pszSlash = CmStrrchr(szTempDir, TEXT('\\'));

            if (pszSlash)
            {
                //
                //  Then we found a last slash, Zero Terminate.
                //
                *pszSlash = TEXT('\0');

                //
                //  Now we have the old temp dir path.  Lets delete the old
                //  CM bits
                //
                MYVERIFY(0 != RenameOldCmBits (szTempDir));
            }

            //
            //  We also need to make sure that there aren't any 1.0 profiles that have a
            //  1.2 connectoid but only have a 1.0 registry format (thus they still have
            //  a 1.0 desktop GUID interface).  The problem here is that installation will try
            //  to run profile migration on these connectoids.  Older versions of cmstp.exe
            //  would delete the existing connectoids and make new ones during profile migration.
            //  The problem is that on NT5 we now respond to the RasCustomDeleteEntryNotify call, and
            //  thus will uninstall profiles that have RasDeleteEntry called on their main connectoid.
            //  To prevent this, we must pre-migrate older profiles and delete the new connectoid
            //  properly.
            //
            EnumerateAndPreMigrateAllUserProfiles(IsIeak5Cm(dwProfileVersionNumber, dwProfileBuildNumber));
        }
    }

    return TRUE; // always return TRUE so that cmstp.exe continues.  Only change this if you want cmstp.exe
                 // to fail certain actions.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcontbl\setacl.cpp ===
//+----------------------------------------------------------------------------
//
// File:    setacl.cpp
//
// Module:  PBSERVER.DLL
//
// Synopsis: Security/SID/ACL stuff for CM
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  09-Mar-2000 SumitC  Created
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "cmdebug.h"
#include "cmutil.h"

//+----------------------------------------------------------------------------
//
// Func:    SetAclPerms
//
// Desc:    Sets appropriate permissions for CM/CPS's shared objects
//
// Args:    [ppAcl] - location to return an allocated ACL
//
// Return:  BOOL, TRUE for success, FALSE for failure
//
// Notes:   fix for 30991: Security issue, don't use NULL DACLs.
//
// History: 09-Mar-2000   SumitC    Created
//          04-Apr-2000   SumitC    Give perms to Authenticated_Users as well
//
//-----------------------------------------------------------------------------
BOOL
SetAclPerms(PACL * ppAcl)
{
    DWORD                       dwError = 0;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNtAuth = SECURITY_NT_AUTHORITY;
    PSID                        psidWorldSid = NULL;
    PSID                        psidAdminSid = NULL;
    PSID                        psidUserSid = NULL;
    int                         cbAcl;
    PACL                        pAcl = NULL;

    MYDBGASSERT(OS_NT);

    // Create a SID for all users
    if ( !AllocateAndInitializeSid(  
            &siaWorld,
            1,
            SECURITY_WORLD_RID,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidWorldSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Create a SID for Authenticated Users
    if ( !AllocateAndInitializeSid(  
            &siaNtAuth,
            1,
            SECURITY_AUTHENTICATED_USER_RID,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidUserSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Create a SID for Local System account
    if ( !AllocateAndInitializeSid(  
            &siaNtAuth,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidAdminSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Calculate the length of required ACL buffer
    // with 3 ACEs.
    cbAcl =     sizeof(ACL)
            +   3 * sizeof(ACCESS_ALLOWED_ACE)
            +   GetLengthSid(psidWorldSid)
            +   GetLengthSid(psidAdminSid)
            +   GetLengthSid(psidUserSid);

    pAcl = (PACL) LocalAlloc(0, cbAcl);
    if (NULL == pAcl)
    {
        dwError = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( ! InitializeAcl(pAcl, cbAcl, ACL_REVISION2))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for all users
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_READ | GENERIC_EXECUTE,
                               psidWorldSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for Authenticated Users
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                               psidUserSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for Admins
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_ALL,
                               psidAdminSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if (dwError)
    {
        if (pAcl)
        {
           LocalFree(pAcl);
        }
    }
    else
    {
        *ppAcl = pAcl;
    }

    if (psidWorldSid)
    {
        FreeSid(psidWorldSid);
    }

    if (psidUserSid)
    {
        FreeSid(psidUserSid);
    }

    if (psidAdminSid)
    {
        FreeSid(psidAdminSid);
    }
        
    return dwError ? FALSE : TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdebug\cmdebug.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmdebug.cpp
//
// Module:   CMDEBUG.LIB
//
// Synopsis: This source file contains the debugging routines common to all 
//           of the CM components.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    02/04/98
//
//+----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>

#ifdef DEBUG

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include "cmdebug.h"
//
//  Ansi Versions
//
void MyDbgPrintfA(const char *pszFmt, ...) 
{
    va_list valArgs;
    char szTmp[512];
    CHAR szOutput[512];

    va_start(valArgs, pszFmt);
    wvsprintfA(szTmp, pszFmt, valArgs);
    va_end(valArgs);

    wsprintfA(szOutput, "0x%x: 0x%x: %s\r\n", GetCurrentProcessId(), GetCurrentThreadId(), szTmp);

    OutputDebugStringA(szOutput);

    //
    // Attempt to log output
    //

    CHAR szFileName[MAX_PATH + 1];
    DWORD dwBytes;
    
    GetSystemDirectoryA(szFileName, MAX_PATH);
    lstrcatA(szFileName, "\\CMTRACE.TXT");
    
    HANDLE hFile = CreateFileA(szFileName, 
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, 0, FILE_END))
        {
            WriteFile(hFile, szOutput, sizeof(CHAR)*lstrlenA(szOutput), &dwBytes, NULL);
        }
        CloseHandle(hFile);
    }   
}

void MyDbgAssertA(const char *pszFile, unsigned nLine, const char *pszMsg) 
{
    char szOutput[1024];

    wsprintfA(szOutput, "%s(%u) - %s", pszFile, nLine, pszMsg);

    MyDbgPrintfA(szOutput);

    //
    // Prompt user
    //

    wsprintfA(szOutput, "%s(%u) - %s\n( Press Retry to debug )", pszFile, nLine, pszMsg);
    int nCode = IDIGNORE;

    static long dwAssertCount = -1;  // Avoid another assert while the messagebox is up

    //
    // If there is no Assertion meesagebox, popup one
    //
    if (InterlockedIncrement(&dwAssertCount) == 0)
    {
        nCode = MessageBoxExA(NULL, szOutput, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE, LANG_USER_DEFAULT);
    }

    InterlockedDecrement(&dwAssertCount);

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        // break into the debugger (or Dr Watson log)
#ifdef _X86_
        _asm { int 3 };
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    else if (0 == nCode)
    {
        //
        //  MessageBoxEx Failed.  Lets call GLE
        //
        DWORD dwError = GetLastError();

        //
        //  Fall through and exit process anyway
        //
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

//
//    Unicode Versions
//

void MyDbgPrintfW(const WCHAR *pszFmt, ...) 
{
    va_list valArgs;
    CHAR szOutput[512];   
    CHAR szTmp[512];

    va_start(valArgs, pszFmt);
    int iRet = wvsprintfWtoAWrapper(szTmp, pszFmt, valArgs);
    va_end(valArgs);

    if (0 == iRet)
    {
        //
        //  We weren't able to write the Unicode string as expected.  Lets
        //  try just putting a failure string in the szTmp buffer instead.
        //
        lstrcpyA(szTmp, "MyDbgPrintfW -- wvsprintfWtoAWrapper failed.  Unsure of original message, please investigate.");
    }

#if defined(DEBUG_TRACETIME)

    static const CHAR c_szaFmtTime[] = "[%02dh%02d:%02d.%03d]";
    CHAR szTime[15] = "";       // NOTE: the size of this must be in sync with the string above

    SYSTEMTIME stLocal;
    GetLocalTime(&stLocal);
    wsprintfA (szTime, c_szaFmtTime,
                stLocal.wHour,
                stLocal.wMinute,
                stLocal.wSecond,
                stLocal.wMilliseconds);

    wsprintfA(szOutput, "%s 0x%x: 0x%x: %s\r\n", szTime, GetCurrentProcessId(), GetCurrentThreadId(), szTmp);

#else
    wsprintfA(szOutput, "0x%x: 0x%x: %s\r\n", GetCurrentProcessId(), GetCurrentThreadId(), szTmp);
#endif
    OutputDebugStringA(szOutput);

    //
    // Attempt to log output
    //

    CHAR szFileName[MAX_PATH + 1];
    DWORD dwBytes;
    
    GetSystemDirectoryA(szFileName, MAX_PATH);
    lstrcatA(szFileName, "\\CMTRACE.TXT");

    HANDLE hFile = CreateFileA(szFileName, 
                              GENERIC_WRITE,
                              FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, 0, FILE_END))
        {
            WriteFile(hFile, szOutput, sizeof(CHAR)*lstrlen(szOutput), &dwBytes, NULL);
        }
        CloseHandle(hFile);
    }   
}

void MyDbgAssertW(const char *pszFile, unsigned nLine, WCHAR *pszMsg) 
{
    CHAR szOutput[1024];

    wsprintfA(szOutput, "%s(%u) - %S", pszFile, nLine, pszMsg);

    MyDbgPrintfA(szOutput);

    //
    // Prompt user
    //

    wsprintfA(szOutput, "%s(%u) - %S\n( Press Retry to debug )", pszFile, nLine, pszMsg);
    int nCode = IDIGNORE;

    static long dwAssertCount = -1;  // Avoid another assert while the messagebox is up

    //
    // If there is no Assertion meesagebox, popup one
    //
    if (InterlockedIncrement(&dwAssertCount) == 0)
    {
        nCode = MessageBoxExA(NULL, szOutput, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE, LANG_USER_DEFAULT);
    }

    InterlockedDecrement(&dwAssertCount);

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        // break into the debugger (or Dr Watson log)
#ifdef _X86_
        _asm { int 3 };
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //DEBUG

//
//  Included to make MyDbgPrintfW work on win9x.  Please note that it steps through the string
//  byte by byte (doesn't deal with MBCS chars) but since this is really called on Format strings
//  this shouldn't be a problem.
//

void InvertPercentSAndPercentC(LPSTR pszFormat)
{
    if (pszFormat)
    {
        LPSTR pszTmp = pszFormat;
        BOOL bPrevCharPercent = FALSE;

        while(*pszTmp)
        {
            switch (*pszTmp)
            {
            case '%':
                //
                //  if we have %% then we must ignore the percent, otherwise save it.
                //
                bPrevCharPercent = !bPrevCharPercent;
                break;

            case 'S':
                if (bPrevCharPercent)
                {
                    *pszTmp = 's';
                }
                break;

            case 's':
                if (bPrevCharPercent)
                {
                    *pszTmp = 'S';
                }
                break;

            case 'C':
                if (bPrevCharPercent)
                {
                    *pszTmp = 'c';
                }
                break;

            case 'c':
                if (bPrevCharPercent)
                {
                    *pszTmp = 'C';
                }
                break;

            default:
                //
                //  don't fool ourselves by always keeping this set.
                //
                bPrevCharPercent = FALSE;
                break;
            }
            pszTmp++;
        }
    }
}

//
//  This function takes Unicode input strings (potentially in the va_list as well)
//  and uses the fact that wvsprintfA will print Unicode strings into an Ansi
//  output string if the special char %S is used instead of %s.  Thus we will convert
//  the input parameter string and then replace all the %s chars with %S chars (and vice versa).
//  This will allow us to call wvsprintfA since wvsprintfW isn't available on win9x.
//
int WINAPI wvsprintfWtoAWrapper(OUT LPSTR pszAnsiOut, IN LPCWSTR pszwFmt, IN va_list arglist)
{
    int iRet = 0;
    LPSTR pszAnsiFormat = NULL;

    if ((NULL != pszAnsiOut) && (NULL != pszwFmt) && (L'\0' != pszwFmt[0]))
    {
        //
        //  Convert pszwFmt to Ansi
        //
        DWORD dwSize = WideCharToMultiByte(CP_ACP, 0, pszwFmt, -1, pszAnsiFormat, 0, NULL, NULL);

        if (0 != dwSize)
        {
            pszAnsiFormat = (LPSTR)LocalAlloc(LPTR, dwSize*sizeof(CHAR));

            if (pszAnsiFormat)
            {
                if (WideCharToMultiByte(CP_ACP, 0, pszwFmt, -1, pszAnsiFormat, dwSize, NULL, NULL))
                {
                    //
                    //  Now change the little s's and c's to their capital equivalent and vice versa
                    //
                    InvertPercentSAndPercentC(pszAnsiFormat);
                    
                    //
                    //  Finally construct the string
                    //

                    iRet = wvsprintfA(pszAnsiOut, pszAnsiFormat, arglist);
                }
            }
        }
    }

    LocalFree(pszAnsiFormat);
    return iRet;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcontbl\contable.cpp ===
//+----------------------------------------------------------------------------
//
// File:    CONTABLE.CPP    
//
// Module:  CMCONTBL.LIB
//
// Synopsis: Implements the CM connection table (CConnectionTable). The connection
//           table is a list of active conenctions stored in a (memory only) memory 
//           mapped file, and shared by the various CM components in order to 
//           manage CM connections.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:  nickball   Created    02/02/98
//
//+----------------------------------------------------------------------------

#include <windows.h>

#include "contable.h"
#include "cmdebug.h"
#include "cmutil.h"
#include "uapi.h"
#include "setacl.h"

#if 0
#include "DumpSecInfo.cpp"
#endif

#define CONN_TABLE_NAME TEXT("CmConnectionTable")
#define CONN_TABLE_OPEN TEXT("CmConnectionOpen")

#define CONN_TABLE_NAME_WIN2K_ABOVE TEXT("Global\\CmConnectionTable")
#define CONN_TABLE_OPEN_WIN2K_ABOVE TEXT("Global\\CmConnectionOpen")

static const int MAX_LOCK_WAIT = 1000; // wait timeout in milliseconds

//
// Constructor and destructor
//
CConnectionTable::CConnectionTable()
{
    CMTRACE(TEXT("CConnectionTable::CConnectionTable()"));

    //
    // Initialize our data members
    //

    m_hMap = NULL;
    m_pConnTable = NULL;
    m_fLocked = FALSE;
    m_hEvent = NULL;
}

CConnectionTable::~CConnectionTable()
{
    CMTRACE(TEXT("CConnectionTable::~CConnectionTable()"));

    //
    // Data should have been cleaned up in Close, etc. Double-Check
    //

    MYDBGASSERT(NULL == m_pConnTable);
    MYDBGASSERT(NULL == m_hMap);
    MYDBGASSERT(FALSE == m_fLocked);
    MYDBGASSERT(NULL == m_hEvent);

    //
    // Release handles and pointers
    //

    if (m_pConnTable)
    {
        MYVERIFY(NULL != UnmapViewOfFile(m_pConnTable));
        m_pConnTable = NULL;
    }

    if (m_hMap)
    {
        MYVERIFY(NULL != CloseHandle(m_hMap));
        m_hMap = NULL;
    }

    if (m_hEvent)
    {
        MYVERIFY(NULL != CloseHandle(m_hEvent));
        m_hEvent = NULL;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::LockTable
//
// Synopsis:  Sets the internal lock on the table. Should be called internally
//            prior to any table access.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::LockTable()
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(m_hEvent);
    CMTRACE(TEXT("CConnectionTable::LockTable()"));

    HRESULT hrRet = S_OK;

    //
    // Validate our current state
    //

    if (NULL == m_hEvent)
    {
        MYDBGASSERT(FALSE);
        return E_ACCESSDENIED;
    }

    //
    // Wait for the open event to be signaled
    //

    DWORD dwWait = WaitForSingleObject(m_hEvent, MAX_LOCK_WAIT);

    //
    // If our records indicate that we are already locked at this point
    // then something is wrong within the class implementation
    //

    MYDBGASSERT(FALSE == m_fLocked); // no double locks please

    if (TRUE == m_fLocked)
    {
        SetEvent(m_hEvent);    // cleat the signal that we just set by clearing the wait
        return E_ACCESSDENIED;
    }

    //
    // Check the
    //

    if (WAIT_FAILED == dwWait)
    {
        MYDBGASSERT(FALSE);
        hrRet = GetLastError();
        return HRESULT_FROM_WIN32(hrRet);
    }

    //
    // If not signaled, bail
    //

    MYDBGASSERT(WAIT_OBJECT_0 == dwWait);

    if (WAIT_OBJECT_0 != dwWait)
    {
        if (WAIT_TIMEOUT == dwWait)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        }
        else
        {
            hrRet = E_ACCESSDENIED;
        }
    }
    else
    {
        //
        // The event is signaled automatically by virtue of the
        // fact that we cleared the wait on the event. Its locked.
        //

        m_fLocked = TRUE;
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::UnlockTable
//
// Synopsis:  Clears the internal lock on the table. Should be cleared
//            following any access to the table.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::UnlockTable()
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(m_hEvent);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::UnlockTable()"));

    HRESULT hrRet = S_OK;

    //
    // Validate our current state
    //

    if (FALSE == m_fLocked || NULL == m_hEvent)
    {
        return E_ACCESSDENIED;
    }

    //
    // Signal the open event, allowing access
    //

    if (SetEvent(m_hEvent))
    {
        m_fLocked = FALSE;
    }
    else
    {
        MYDBGASSERT(FALSE);

        hrRet = GetLastError();
        hrRet = HRESULT_FROM_WIN32(hrRet);
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::FindEntry - pszEntry
//
// Synopsis:  Determines the ID (index) of an entry in the table. Table should
//            be locked before making this call.
//
// Arguments: LPCTSTR pszEntry - Ptr to the name of the entry we are seeking.
//            LPINT piID - Ptr to buffer for ID (index) of connection
//
// Returns:   HRESULT - Failure code, or S_OK if piID filled.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::FindEntry(LPCTSTR pszEntry, LPINT piID)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    MYDBGASSERT(piID);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE1(TEXT("CConnectionTable::FindEntry(%s)"), pszEntry);

    if (FALSE == m_fLocked || NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry || NULL == piID)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Look for the entry
    //

    for (int i = 0; i < MAX_CM_CONNECTIONS; i++)
    {
        //
        // Name compare for a match
        //

        if (0 == lstrcmpU(pszEntry, m_pConnTable->Connections[i].szEntry))
        {
            MYDBGASSERT(m_pConnTable->Connections[i].dwUsage);
            MYDBGASSERT(m_pConnTable->Connections[i].CmState);

            *piID = i;

            return S_OK;
        }

    }

    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::FindEntry - hRasConn
//
// Synopsis:  Determines the ID (index) of an entry in the table. Table should
//            be locked before making this call.
//
// Arguments: HRASCONN hRasConn - Tunnel or dial handle of the entry we are seeking.
//            LPINT piID - Ptr to buffer for ID (index) of connection
//
// Returns:   HRESULT - Failure code, or S_OK if piID filled.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::FindEntry(HRASCONN hRasConn, LPINT piID)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(hRasConn);
    MYDBGASSERT(piID);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE1(TEXT("CConnectionTable::FindEntry(%u)"), (DWORD_PTR) hRasConn);

    if (FALSE == m_fLocked || NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == piID)
    {
        return E_POINTER;
    }

    if (NULL == hRasConn)
    {
        return E_INVALIDARG;
    }

    //
    // Look for the entry
    //

    for (int i = 0; i < MAX_CM_CONNECTIONS; i++)
    {
        //
        // Compare for either handle for a match
        //

        if (hRasConn == m_pConnTable->Connections[i].hDial ||
            hRasConn == m_pConnTable->Connections[i].hTunnel)
        {
            MYDBGASSERT(m_pConnTable->Connections[i].dwUsage);
            MYDBGASSERT(m_pConnTable->Connections[i].CmState);

            *piID = i;

            return S_OK;
        }

    }

    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::FindUnused
//
// Synopsis:  Determines the ID (index) of the first unused entry in the table.
//            Table should be locked before making this call.
//
// Arguments: LPINT piID - Ptr to buffer for ID (index) of connection
//
// Returns:   HRESULT - Failure code, or S_OK if piID filled.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::FindUnused(LPINT piID)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(piID);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::FindUnused()"));

    if (FALSE == m_fLocked || NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == piID)
    {
        return E_POINTER;
    }

    //
    // Look for an unused slot
    //

    for (int i = 0; i < MAX_CM_CONNECTIONS; i++)
    {
        if (0 == m_pConnTable->Connections[i].dwUsage)
        {
            MYDBGASSERT(CM_DISCONNECTED == m_pConnTable->Connections[i].CmState);

            *piID = i;

            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}


//+----------------------------------------------------------------------------
//
// Function:  Create
//
// Synopsis:  Creates a new table. This function will fail if the table already exists.
//            The table should be released by calling Close.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::Create()
{
    MYDBGASSERT(NULL == m_hMap);
    MYDBGASSERT(NULL == m_pConnTable);
    MYDBGASSERT(FALSE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::Create()"));

    if (m_hMap || m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    SECURITY_ATTRIBUTES sa;
    PACL                pAcl = NULL;

    // Initialize a default Security attributes, giving world permissions,
    // this is basically prevent Semaphores and other named objects from
    // being created because of default acls given by winlogon when perfmon
    // is being used remotely.
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = CmMalloc(sizeof(SECURITY_DESCRIPTOR));
    
    if ( !sa.lpSecurityDescriptor )
    {
        return E_OUTOFMEMORY;
    }

    if ( !InitializeSecurityDescriptor(sa.lpSecurityDescriptor,SECURITY_DESCRIPTOR_REVISION) ) 
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (OS_NT)
    {
        if (FALSE == SetAclPerms(&pAcl))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (FALSE == SetSecurityDescriptorDacl(sa.lpSecurityDescriptor, TRUE, pAcl, FALSE)) 
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    //  Now use this 'sa' for the mapped file as well as the event (below)
    //
    if (OS_NT5)
    {
        m_hMap = CreateFileMappingU(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
                                    0, sizeof(CM_CONNECTION_TABLE), CONN_TABLE_NAME_WIN2K_ABOVE);
        if (m_hMap)
        {
            CMTRACE1(TEXT("CreateFileMapping - create succeeded %s"), CONN_TABLE_NAME_WIN2K_ABOVE);
        }
        else
        {
            CMTRACE1(TEXT("CreateFileMapping - create failed %s"), CONN_TABLE_NAME_WIN2K_ABOVE);
        }
    }
    else
    {
        m_hMap = CreateFileMappingU(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
                                        0, sizeof(CM_CONNECTION_TABLE), CONN_TABLE_NAME);
        if (m_hMap)
        {
            CMTRACE1(TEXT("CreateFileMapping - create succeeded %s"), CONN_TABLE_NAME);
        }
        else
        {
            CMTRACE1(TEXT("CreateFileMapping - create failed %s"), CONN_TABLE_NAME);
        }
    }

    DWORD dwRet = ERROR_SUCCESS;

    if (NULL == m_hMap)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_ALREADY_EXISTS)
        {
            if (m_hMap)
            {
                MYVERIFY(NULL != CloseHandle(m_hMap));
                m_hMap = NULL;
            }
        }
        else
        {
            CMTRACE1(TEXT("CreateFileMapping failed with error %d"), dwRet);
            MYDBGASSERT(FALSE);
        }
    }
    else
    {
#if 0 // DBG
        DumpAclInfo(m_hMap);
#endif
        //
        // File mapping created successfully, map a view of it
        //

        m_pConnTable = (LPCM_CONNECTION_TABLE) MapViewOfFile(m_hMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
        if (NULL == m_pConnTable)
        {
            dwRet = GetLastError();
            MYVERIFY(NULL != CloseHandle(m_hMap));
            m_hMap = NULL;
        }
        else
        {
            //
            // Success, make sure mapping is empty becuase we are paranoid
            //

            ZeroMemory(m_pConnTable, sizeof(CM_CONNECTION_TABLE));

            //
            // Create the named event to be used for locking the file
            // Note: We use auto-reset.
            //

            if (OS_NT5)
            {
                m_hEvent = CreateEventU(&sa, FALSE, TRUE, CONN_TABLE_OPEN_WIN2K_ABOVE);
                if (m_hEvent)
                {
                    CMTRACE1(TEXT("CreateEventU - succeeded - %s"), CONN_TABLE_OPEN_WIN2K_ABOVE);
                }
                else
                {
                    CMTRACE1(TEXT("CreateEventU - failed - %s"), CONN_TABLE_OPEN_WIN2K_ABOVE);
                }
            }
            else
            {
                m_hEvent = CreateEventU(&sa, FALSE, TRUE, CONN_TABLE_OPEN);
                if (m_hEvent)
                {
                    CMTRACE1(TEXT("CreateEventU - succeeded - %s"), CONN_TABLE_OPEN);
                }
                else
                {
                    CMTRACE1(TEXT("CreateEventU - failed - %s"), CONN_TABLE_OPEN);
                }
            }

            if (NULL == m_hEvent)
            {
                MYDBGASSERT(FALSE);
                dwRet = GetLastError();
                m_hEvent = NULL;
            }
        }
    }

    CmFree(sa.lpSecurityDescriptor);

    if (pAcl)
    {
        LocalFree(pAcl);
    }
    
    return HRESULT_FROM_WIN32(dwRet);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::Open
//
// Synopsis:  Opens an existing table. This function will fail if no table exists.
//            The table should be released by calling Close.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code on S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::Open()
{
    MYDBGASSERT(NULL == m_hMap);
    MYDBGASSERT(NULL == m_pConnTable);
    MYDBGASSERT(FALSE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::Open()"));

    if (m_hMap || m_pConnTable)
    {
        CMTRACE(TEXT("CConnectionTable::Open() - E_ACCESSDENIED"));
        return E_ACCESSDENIED;
    }

    LRESULT lRet = ERROR_SUCCESS;

    //
    // Open the file mapping
    //

    if (OS_NT5)
    {
        m_hMap = OpenFileMappingU(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, CONN_TABLE_NAME_WIN2K_ABOVE);
    }
    else
    {
        m_hMap = OpenFileMappingU(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, CONN_TABLE_NAME);
    }

    if (NULL == m_hMap)
    {
        lRet = GetLastError();
        CMTRACE1(TEXT("CConnectionTable::Open() - OpenFileMappingU fails. GLE = 0x%x"), lRet);
    }
    else
    {
        //
        // File mapping opened successfully, map a view of it.
        //

        m_pConnTable = (LPCM_CONNECTION_TABLE) MapViewOfFile(m_hMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
        MYDBGASSERT(m_pConnTable);

        if (NULL == m_pConnTable)
        {
            MYVERIFY(NULL != CloseHandle(m_hMap));
            m_hMap = NULL;
            lRet = GetLastError();
            CMTRACE1(TEXT("CConnectionTable::Open() - MapViewOfFile fails. GLE = 0x%x"), lRet);
        }
        else
        {
            //
            // Open the named event used for locking the file
            //

            if (OS_NT5)
            {
                m_hEvent = OpenEventU(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                    NULL, CONN_TABLE_OPEN_WIN2K_ABOVE);
            }
            else
            {
                m_hEvent = OpenEventU(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                  NULL, CONN_TABLE_OPEN);
            }


            if (NULL == m_hEvent)
            {
                MYDBGASSERT(FALSE);
                lRet = GetLastError();
                CMTRACE1(TEXT("CConnectionTable::Open() - OpenEventU fails. GLE = 0x%x"), lRet);
            }
        }
    }

    return HRESULT_FROM_WIN32(lRet);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::Close
//
// Synopsis:  Closes an opened table. This function will fail if the table is
//            not open.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::Close()
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(FALSE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::Close()"));

    if (m_pConnTable)
    {
        MYVERIFY(NULL != UnmapViewOfFile(m_pConnTable));
        m_pConnTable = NULL;
    }

    if (m_hMap)
    {
        MYVERIFY(NULL != CloseHandle(m_hMap));
        m_hMap = NULL;
    }

    if (m_hEvent)
    {
        MYVERIFY(NULL != CloseHandle(m_hEvent));
        m_hEvent = NULL;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::AddEntry
//
// Synopsis:  Creates a new entry in the table with the specified name. Adding
//            an entry implies that the connection is being attempted, so the
//            connection state is set to CM_CONNECTING. If an entry for the
//            connection already exists, the usage count is incremented.
//
// Arguments: LPCTSTR pszEntry - The name of connection for which we're creating an entry.
//            BOOL fAllUser - The All User attribute of the profile
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::AddEntry(LPCTSTR pszEntry, BOOL fAllUser)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::AddEntry(%s)"), pszEntry);

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    //
    // See if we already have an entry by this name
    //

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        //
        // We do, bump the usage count.
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        //
        // Don't bump ref count when reconnecting the same connection.
        //
        if (m_pConnTable->Connections[iID].CmState != CM_RECONNECTPROMPT)
        {
            m_pConnTable->Connections[iID].dwUsage += 1;
        }

        //
        // Unless this entry is already connected, make sure
        // its now in the connecting state. This allows us
        // to preserve the usage count across prompt reconnect
        // events.
        //

        if (m_pConnTable->Connections[iID].CmState != CM_CONNECTED)
        {
            m_pConnTable->Connections[iID].CmState = CM_CONNECTING;
        }

        MYDBGASSERT(m_pConnTable->Connections[iID].dwUsage < 1000); // Sanity check
    }
    else
    {
        if (HRESULT_CODE(hrRet) == ERROR_NOT_FOUND)
        {
            //
            // Its a new entry, find the first unused slot
            //

            hrRet = FindUnused(&iID);

            MYDBGASSERT(SUCCEEDED(hrRet));

            if (SUCCEEDED(hrRet))
            {
                MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

                ZeroMemory(&m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));

                //
                // Set usage count, state and name
                //

                m_pConnTable->Connections[iID].dwUsage = 1;
                m_pConnTable->Connections[iID].CmState = CM_CONNECTING;

                lstrcpyU(m_pConnTable->Connections[iID].szEntry, pszEntry);

                m_pConnTable->Connections[iID].fAllUser = fAllUser;
            }
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::RemoveEntry
//
// Synopsis:  Decrements the usage count for the specified connection. If the
//            usage count falls to 0 the entire entry is cleared.
//
// Arguments: LPCTSTR pszEntry - The name of the entry to be removed
//
// Returns:   HRESULT - Failure code or S_OK
//
//  Note:     If the entry does not exists the request fails.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::RemoveEntry(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::RemoveEntry(%s)"), pszEntry);

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    //
    // Lock the table and locate the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        if (m_pConnTable->Connections[iID].dwUsage == 1)
        {
            ZeroMemory(&m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
        }
        else
        {
            m_pConnTable->Connections[iID].dwUsage -= 1;
            MYDBGASSERT(m_pConnTable->Connections[iID].dwUsage != 0xFFFFFFFF);
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::GetMonitorWnd
//
// Synopsis:  Simple accessor to retrieve the hwnd of the CM Connection
//            Monitor from the table.
//
// Arguments: phWnd - Ptr to buffer to receive hWnd
//
// Returns:   Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::GetMonitorWnd(HWND *phWnd)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    CMTRACE(TEXT("CConnectionTable::GetMonitorWnd()"));

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == phWnd)
    {
        return E_POINTER;
    }

    //
    // Lock the table and retrieve the HWND
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    *phWnd = m_pConnTable->hwndCmMon;

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::SetMonitorWnd
//
// Synopsis:  Simple assignment method for setting the CMMON HWND in the table
//            .
// Arguments: HWND hwndMonitor - The HWND of CMMON
//
// Returns:   HRESULT - Failure code or S_OK
//
//  Note:     hwndMonitor CAN be NULL.  It is possible CMMON is unloaded, but
//            the table statys in memory
// History:   nickball    Created    2/2/98
//            fengsun 2/20/98 change to allow NULL phwndMonitor
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetMonitorWnd(HWND hwndMonitor)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    CMTRACE(TEXT("CConnectionTable::SetMonitorWnd()"));

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    //
    // Lock the table and set the HWND
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    m_pConnTable->hwndCmMon = hwndMonitor;

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::GetEntry - pszEntry
//
// Synopsis:  Retrieves a copy the data for the specified connection based on
//            the entry name provided.
//
// Arguments: LPCTSTR pszEntry - The name of the connection
//            LPCM_CONNECTION pConnection - Ptr to a CM_CONNECTION sturct to be filled
//
// Returns:   HRESULT - Failure Code or S_OK.
//
// Note:      A NULL ptr may be passed for pConnection, if the existence of the
//            entry is the only information required.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::GetEntry(LPCTSTR pszEntry,
    LPCM_CONNECTION pConnection)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::GetEntry(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        //
        // If a buffer was given fill it.
        //

        if (pConnection)
        {
            memcpy(pConnection, &m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::GetEntry - hRasConn
//
// Synopsis:  Retrieves a copy the data for the specified connection based on the
//            Ras handle provided
//
// Arguments: HRASCONN hRasConn - Either the tunnel or dial handle of the connection
//            LPCM_CONNECTION pConnection - Ptr to a CM_CONNECTION sturct to be filled
//
// Returns:   HRESULT - Failure Code or S_OK.
//
// Note:      A NULL ptr may be passed for pConnection, if the existence of the
//            entry is the only information required.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::GetEntry(HRASCONN hRasConn,
    LPCM_CONNECTION pConnection)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(hRasConn);
    CMTRACE1(TEXT("CConnectionTable::GetEntry(%u)"), (DWORD_PTR) hRasConn);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == hRasConn)
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(hRasConn, &iID);

    if (SUCCEEDED(hrRet))
    {
        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        //
        // If a buffer was given fill it.
        //

        if (pConnection)
        {
            memcpy(pConnection, &m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::SetConnected
//
// Synopsis:  Sets the connection to CM_CONNECTED indicating that a connection
//            has been established. The caller must provide either the hDial or
//            the hTunnel parameter or both in order for the function to succeed.
//
// Arguments: LPCTSTR pszEntry - The name of the connection.
//            HRASCONN hDial - A Dial-up connection handle.
//            HRASCONN hTunnel - A tunnel connection handle.
//
// Returns:   HRESULT - Failure code or S_OK.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetConnected(LPCTSTR pszEntry,
    HRASCONN hDial,
    HRASCONN hTunnel)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::SetConnected(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0] || (NULL == hDial && NULL == hTunnel))
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    MYDBGASSERT(SUCCEEDED(hrRet));

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, set the state and Ras handles
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        MYDBGASSERT(m_pConnTable->Connections[iID].CmState != CM_CONNECTED);

        m_pConnTable->Connections[iID].CmState = CM_CONNECTED;
        m_pConnTable->Connections[iID].hDial = hDial;
        m_pConnTable->Connections[iID].hTunnel = hTunnel;
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::SetDisconnecting
//
// Synopsis:  Set the state of the connection to CM_DISCONNECTING
//
// Arguments: LPCTSTR pszEntry - The name of the connection to be set.
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetDisconnecting(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::Disconnecting(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    //MYDBGASSERT(SUCCEEDED(hrRet));

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, set the state
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        m_pConnTable->Connections[iID].CmState = CM_DISCONNECTING;
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  SetPrompting
//
// Synopsis:  Set the state of the connection to CM_RECONNECTPROMPT
//
// Arguments: LPCTSTR pszEntry - The name of the connection to be set.
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetPrompting(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::SetPrompting(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    //MYDBGASSERT(SUCCEEDED(hrRet));

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, set the state
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        m_pConnTable->Connections[iID].CmState = CM_RECONNECTPROMPT;
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::ClearEntry
//
// Synopsis:  Clears the specified entry regardless of the usage count.
//
// Arguments: LPCTSTR pszEntry - The name of the entry to be cleared.
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::ClearEntry(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::ClearEntry(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, clear it
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        ZeroMemory(&m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\actlist.h ===
//+----------------------------------------------------------------------------
//
// File:     ActList.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Define the two connect action list class
//           CAction and CActionList
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   fengsun Created    11/14/97
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "cm_misc.h"
#include "conact_str.h"
#include "conact.h"

//
// Class used
//
class CIni;
class CAction;
struct _ArgsStruct;


//+---------------------------------------------------------------------------
//
//  class CActionList
//
//  Description: A list of CAction objects
//
//  History:    fengsun Created     11/14/97
//
//----------------------------------------------------------------------------
class CActionList
{
public:
    CActionList();
    ~CActionList();
    BOOL Append(const CIni* piniService, LPCTSTR pszSection);

    void RunAutoApp(HWND hwndDlg, _ArgsStruct *pArgs); // not check return value, add as watch process
    BOOL RunAccordType(HWND hwndDlg, _ArgsStruct *pArgs, BOOL fStatusMsgOnFailure = TRUE, BOOL fOnError = FALSE); //No watch process, Check connection type

protected:
    BOOL Run(HWND hwndDlg, _ArgsStruct *pArgs, BOOL fAddWatch, BOOL fStatusMsgOnFailure, BOOL fOnError);
    
    //
    // Since we do not have a dynamic array class, here is the simple implementation
    //
    void        Add(CAction* pAction);
    CAction *   GetAt(UINT nIndex);
    UINT        GetSize() {return m_nNum;}


    CAction **  m_pActionList;      // This is a list of CAction*
    UINT        m_nNum;             // number of elements in pActionList
    UINT        m_nSize;            // The memory size of the m_pActionList
    LPCTSTR     m_pszType;          // "type" of the connect action (actually, the section name)

    enum {GROW_BY = 10}; // the dynamic array grow
};

//+---------------------------------------------------------------------------
//
//  class CAction
//
//  Description: A single action object
//
//  History:    fengsun Created     11/14/97
//
//----------------------------------------------------------------------------
class CAction
{
public:
    CAction(LPTSTR lpCommandLine, UINT dwFlags, LPTSTR lpDescript = NULL);
    ~CAction();

    HANDLE RunAsExe(CShellDll* pShellDll) const;
    HANDLE RunAsExeFromSystem(CShellDll* pShellDll, LPTSTR pszDesktop, DWORD dwLoadType);
    BOOL RunAsDll(HWND hWndParent, OUT DWORD& dwReturnValue, DWORD dwLoadType) const;
    const TCHAR* GetDescription() const {return m_pszDescription;}
    const TCHAR* GetProgram() const {return m_pszProgram;}
    void ExpandMacros(_ArgsStruct *pArgs);

    BOOL IsDll() const { return m_fIsDll; }
    void ConvertRelativePath(const CIni *piniService); 
    void ExpandEnvironmentStringsInCommand();
    void ExpandEnvironmentStringsInParams();
    
    BOOL IsAllowed(_ArgsStruct *pArgs, LPDWORD lpdwLoadType);
    BOOL RunConnectActionForCurrentConnection(_ArgsStruct *pArgs);
    BOOL HasUI() const { return ((m_dwFlags & NONINTERACTIVE) ? FALSE : TRUE); }

protected:
    BOOL GetLoadDirWithAlloc(DWORD dwLoadType, LPWSTR * ppszwPath) const;
    void ParseCmdLine(LPTSTR pszCmdLine);
    void ExpandEnvironmentStrings(LPTSTR * ppsz);

    //
    // Flags for CAction
    //
    enum { ACTION_DIALUP =      0x00000001,
           ACTION_DIRECT =      0x00000002
    };


    BOOL m_fIsDll;        // whether the action is a dll
    LPTSTR m_pszProgram;  // The program name or the dll name
    LPTSTR m_pszParams;   // The parameters of the program/dll
    LPTSTR m_pszFunction; // The function name of the dll
    LPTSTR m_pszDescription; // the description
    UINT m_dwFlags;       // a bit ORed flag

#ifdef DEBUG
public:
    void AssertValid() const;
#endif
};

inline void CActionList::RunAutoApp(HWND hwndDlg, _ArgsStruct *pArgs)
{
    Run(hwndDlg, pArgs, TRUE, FALSE, FALSE); //fAddWatch = TRUE, fStatusMsgOnFailure = FALSE
}

inline void CAction::ConvertRelativePath(const CIni *piniService)
{
    //
    // Convert the relative path to full path
    //
    LPTSTR pszTmp = ::CmConvertRelativePath(piniService->GetFile(), m_pszProgram);
    CmFree(m_pszProgram);
    m_pszProgram = pszTmp;
}

inline void CAction::ExpandEnvironmentStringsInCommand()
{
    CAction::ExpandEnvironmentStrings(&m_pszProgram);
}

inline void CAction::ExpandEnvironmentStringsInParams()
{
    CAction::ExpandEnvironmentStrings(&m_pszParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\actlist.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ActList.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Implement the two connect action list class
//           CAction and CActionList
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   fengsun Created    11/14/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ActList.h"
#include "stp_str.h"

//
//  Include the custom action parsing routine that CM and CMAK now share, HrParseCustomActionString
//
#include "parseca.cpp"

//
// Constructor and destructor
//

CActionList::CActionList()
{
    m_pActionList = NULL;
    m_nNum = 0;
    m_nSize = 0;
    m_pszType = NULL;
}

CActionList::~CActionList()
{
    for (UINT i = 0; i < m_nNum; i++)
    {
        delete m_pActionList[i];
    }

    CmFree(m_pActionList);
}


//+----------------------------------------------------------------------------
//
// Function:  CActionList::Add
//
// Synopsis:  Dynamic array function. Append the element at the end of the array
//            Grow the array if nessesary
//
// Arguments: CAction* pAction - element to be added
//
// Returns:   Nothing
//
// History:   Fengsun Created Header        11/14/97
//            tomkel  Fixed PREFIX issues   11/21/2000
//
//+----------------------------------------------------------------------------
void CActionList::Add(CAction* pAction)
{
    MYDBGASSERT(m_nNum <= m_nSize);
    MYDBGASSERT(m_nSize == 0 || m_pActionList!=NULL); // if (m_nSize!=0) ASSERT(m_pActionList!=NULL);

    m_nNum++;

    if (m_nNum > m_nSize)
    {
        //
        // Either there is not enough room OR m_pActionList is NULL (this 
        // is the first call to Add). Need to allocate memory
        //
        
        CAction** pNewList = (CAction**)CmMalloc((m_nSize + GROW_BY)*sizeof(CAction*));
        MYDBGASSERT(pNewList);

        if (m_pActionList && pNewList)
        {
            //
            // Memory was allocated and there is something to copy from m_pActionList 
            //
            CopyMemory(pNewList, m_pActionList, (m_nSize)*sizeof(CAction*));
        }

        if (pNewList)
        {
            //
            // Memory was allocated
            //
            CmFree(m_pActionList);
            m_pActionList = pNewList;
            m_nSize += GROW_BY; 
            
            //
            // Add the action
            //
            m_pActionList[m_nNum - 1] = pAction; 
        }
        else
        {
            //
            // Memory was not allocated, so Add did not happen
            // Need to decrement the number of items in list (m_nNum) 
            // since it was inceremented at the beginning.
            //
            m_nNum--;
        }
    }
    else
    {
        //
        // Just add the action to the end
        //
        m_pActionList[m_nNum - 1] = pAction; 
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CActionList::GetAt
//
// Synopsis:  Dynamic array fuction.  Get the element at nIndex
//
// Arguments: UINT nIndex - 
//
// Returns:   inline CAction* - 
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
inline CAction* CActionList::GetAt(UINT nIndex)
{
    MYDBGASSERT(nIndex<m_nNum);
    MYDBGASSERT(m_pActionList);
    MYDBGASSERT(m_nNum <= m_nSize);
    
    return m_pActionList[nIndex];
}


//+----------------------------------------------------------------------------
//
// Function:  CActionList::Append
//
// Synopsis:  Append new actions to the list from profile
//
// Arguments: const CIni* piniService - The service file containing actions information
//            LPCTSTR pszSection - The section name 
//
// Returns:   TRUE if an action was appended to the list
//
// History:   fengsun   Created Header    11/14/97
//            nickball  Removed current directory assumptions, and added piniProfile
//            nickball  Added Return code 03/22/99
//
//+----------------------------------------------------------------------------
BOOL CActionList::Append(const CIni* piniService, LPCTSTR pszSection) 
{
    MYDBGASSERT(piniService);
    
    BOOL bRet = FALSE;

    //
    // Read each of the entries and add to our list
    // Start from 0 till the first empty entry
    //

    for (DWORD dwIdx=0; ; dwIdx++) 
    {
        TCHAR szEntry[32]; // hold the entry name

        wsprintfU(szEntry, TEXT("%u"), dwIdx);
        LPTSTR pszCmd = piniService->GPPS(pszSection, szEntry); // Command line

        if (*pszCmd == TEXT('\0')) 
        {
            //
            // No more entries
            //
            CmFree(pszCmd);
            break;
        }

        //
        // Read the flag
        //
    
        UINT iFlag = 0;

        if (pszSection && pszSection[0])
        {
            wsprintfU(szEntry, c_pszCmEntryConactFlags, dwIdx); //0&Flags
            iFlag = (UINT)piniService->GPPI(pszSection, szEntry, 0);
        }

        //
        // Read the description
        //
        LPTSTR pszDescript = NULL;

        wsprintfU(szEntry, c_pszCmEntryConactDesc, dwIdx); //0&Description
        pszDescript = piniService->GPPS(pszSection, szEntry);

        //
        // CAction is responsible for releasing pszDescript
        //
        CAction* pAction = new CAction(pszCmd, iFlag, pszDescript);
        CmFree(pszCmd);
       
        if (pAction)
        {
            pAction->ConvertRelativePath(piniService);
            ASSERT_VALID(pAction);
            pAction->ExpandEnvironmentStringsInCommand();
            Add(pAction);
            bRet = TRUE;
        }
    }

    if (bRet)
    {
        m_pszType = pszSection;
    }
    
    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CActionList::RunAccordType
//
// Synopsis:  Run the action list according to the connection type
//
// Arguments: HWND hwndDlg - The parent window
//            _ArgsStruct *pArgs - 
//            BOOL fStatusMsgOnFailure - Whether to display a status message 
//                                       to the user in the event of failure
//            BOOL fOnError - are we running OnError connect action?
//
// Returns:   BOOL - FALSE, if some sync action failed to start or returns failed
//
// History:   Fengsun Created Header    12/5/97
//
//+----------------------------------------------------------------------------
BOOL CActionList::RunAccordType(HWND hwndDlg, _ArgsStruct *pArgs, BOOL fStatusMsgOnFailure, BOOL fOnError)
{
    //
    // Set the flag, so CM will not handle  WM_TIMER and RAS messages
    //
    pArgs->fIgnoreTimerRasMsg = TRUE;
    BOOL fRetValue = Run(hwndDlg, pArgs, FALSE, fStatusMsgOnFailure, fOnError);//fAddWatch = FALSE
    pArgs->fIgnoreTimerRasMsg = FALSE;

    return fRetValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CActionList::Run
//
// Synopsis:  Run the action list
//
// Arguments: HWND hwndDlg - The parent window, which is diabled during the process
//            ArgsStruct *pArgs - 
//            BOOL fAddWatch - If true, will add the process as watch process, 
//            BOOL fStatusMsgOnFailure - Whether to display a status message 
//                                       to the user in the event of failure
//            BOOL fOnError - are we running OnError connect action?
//
// Returns:   BOOL - FALSE, if some sync action failed to start or returns failed
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
BOOL CActionList::Run(HWND hwndDlg, ArgsStruct *pArgs, BOOL fAddWatch, BOOL fStatusMsgOnFailure, BOOL fOnError) 
{
    //
    // Disable the window, and enable it on return
    //
    
    CFreezeWindow FreezeWindow(hwndDlg);

    for (UINT i = 0; i < GetSize(); i++)
    {
        CAction* pAction = (CAction*)GetAt(i);
        
        DWORD dwLoadType = (DWORD)-1;
        ASSERT_VALID(pAction);
        MYDBGASSERT(m_pszType);

        //
        //  Lets check the flags value to see if this connect action should
        //  run for this type of connection.
        //
        if (FALSE == pAction->RunConnectActionForCurrentConnection(pArgs))
        {
            continue;
        }

        //
        // Replace %xxxx% with the value
        //
        pAction->ExpandMacros(pArgs);
        
        //
        //  Also expand any environment variables
        //  NOTE: the order (macros vs. env vars) is deliberate.  Macros get
        //        expanded first.
        //
        pAction->ExpandEnvironmentStringsInParams();

        //
        // Check to see if we can run the action @ this moment
        //

        if (FALSE == pAction->IsAllowed(pArgs, &dwLoadType))
        {
            //
            // If not allowed, log the fact that we didn't run this connect action
            // and then just skip it.
            //
            pArgs->Log.Log(CUSTOMACTION_NOT_ALLOWED, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());

            continue;
        }

        //
        //  If this customaction might bring up UI
        //
        if (pAction->HasUI())
        {
            //
            //  If we are in unattended mode, don't run any connect actions
            //
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                pArgs->Log.Log(CUSTOMACTION_NOT_ALLOWED, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                CMTRACE(TEXT("Run: skipped past a customaction because we are in unattended mode"));
                continue;
            }

            //
            //  Custom actions processed during a Fast User Switch can put up UI requiring
            //  user input, effectively blocking CM.
            //
            if (pArgs->fInFastUserSwitch)
            {
                CMASSERTMSG((CM_CREDS_GLOBAL != pArgs->dwCurrentCredentialType),
                            TEXT("CActionList::Run - in FUS disconnect, but connectoid has global creds!"));

                pArgs->Log.Log(CUSTOMACTION_NOT_ALLOWED, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                CMTRACE(TEXT("Run: skipped past a singleuser DLL connectaction because of FUS"));
                continue;
            }
        }

        if (pAction->IsDll())
        {
            DWORD dwActionRetValue=0; // the connect action return value, in COM format
            BOOL bLoadSucceed = FALSE; 
            
            if (hwndDlg)
            {
                //
                // Display description for DLL
                //
                if (pAction->GetDescription())
                {
                    LPTSTR lpszText = CmFmtMsg(g_hInst, IDMSG_CONN_ACTION_RUNNING, pAction->GetDescription());
                    //
                    // Update the main dialog status window
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, lpszText); 
                    CmFree(lpszText);
                }
            }
           
            bLoadSucceed = pAction->RunAsDll(hwndDlg, dwActionRetValue, dwLoadType);

            if (bLoadSucceed)
            {
                pArgs->Log.Log(CUSTOMACTIONDLL, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()),
                               pAction->GetProgram(), dwActionRetValue);
            }
            else
            {
                pArgs->Log.Log(CUSTOMACTION_WONT_RUN, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()),
                               pAction->GetProgram());
            }

            //
            // Failed to start the action, or the action returned failure
            //
            
            if (FAILED(dwActionRetValue) || !bLoadSucceed)
            {
                LPTSTR lpszText = NULL;

                if (fStatusMsgOnFailure && 
                    hwndDlg &&
                    pAction->GetDescription())
                {
                    if (bLoadSucceed)
                    {
                        lpszText = CmFmtMsg(g_hInst, IDMSG_CONN_ACTION_FAILED, 
                            pAction->GetDescription(), dwActionRetValue);
                    }
                    else
                    {
                        lpszText = CmFmtMsg(g_hInst, IDMSG_CONN_ACTION_NOTFOUND, 
                            pAction->GetDescription());
                    }
                    //
                    // Update the main dialog status window
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, lpszText); 
                }

                if (!fOnError)
                {
                    DWORD dwError = 0;

                    if (bLoadSucceed)
                    {
                        dwError = dwActionRetValue;
                    }
                    else
                    {
                        dwError = ERROR_DLL_NOT_FOUND;
                    }

                    pArgs->Log.Log(ONERROR_EVENT, dwError, pAction->GetDescription());

                    //
                    // We'll run On-Error connect actions if we are not already running OnError
                    // connect action.  This is to prevent infinite loops.
                    //
                    CActionList OnErrorActList;
                    OnErrorActList.Append(pArgs->piniService, c_pszCmSectionOnError);
                
                    //
                    // fStatusMsgOnFailure = FALSE
                    //
                    OnErrorActList.RunAccordType(hwndDlg, pArgs, FALSE, TRUE);

                    //
                    // Update the program state
                    //
                    if (fStatusMsgOnFailure)
                    {
                        lstrcpynU(pArgs->szLastErrorSrc, pAction->GetDescription(), MAX_LASTERR_LEN);
                        pArgs->dwExitCode = dwError;
                        SetInteractive(pArgs->hwndMainDlg, pArgs);
                        pArgs->psState = PS_Error;
                    }
                }

                if (lpszText)
                {
                    //
                    // restore the failure msg of the previous connect action
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, lpszText); 
                    CmFree(lpszText);
                }

                //
                // Note that if a DLL connect action fails, we will stop processing connect actions.
                // If the fStatusMsgOnFailure flag is set, then we won't show an error message
                // but connect action processing will still halt (we do this in cases where the user
                // isn't going to care such as oncancel actions, onerror actions, and cases where
                // disconnect action fail).
                //

                return FALSE;
            }
        }
        else
        {
            HANDLE  hProcess = NULL;
            TCHAR   szDesktopName[MAX_PATH];
            TCHAR   szWinDesktop[MAX_PATH];

            if (IsLogonAsSystem())
            {
                DWORD   cb;
                HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());

                //
                // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
                // On Win95/98 GetUserObjectInformation is not supported and thus the desktop name
                // will be empty so we will use the good old API
                //  
                szDesktopName[0] = 0;
                
                if (hDesk && GetUserObjectInformation(hDesk, UOI_NAME, szDesktopName, sizeof(szDesktopName), &cb))
                {
                    lstrcpyU(szWinDesktop, TEXT("Winsta0\\"));
                    lstrcatU(szWinDesktop, szDesktopName);
                
                    CMTRACE1(TEXT("CActionList::Run - Desktop = %s"), MYDBGSTR(szWinDesktop));
                
                    hProcess = pAction->RunAsExeFromSystem(&pArgs->m_ShellDll, szWinDesktop, dwLoadType);

                    if (NULL != hProcess)
                    {
                        pArgs->Log.Log(CUSTOMACTIONEXE, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                    }
                    else
                    {
                        pArgs->Log.Log(CUSTOMACTION_WONT_RUN, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                    }
                }
                else
                {
                    //
                    // Don't run action if we don't have desktop
                    //

                    CMTRACE1(TEXT("CActionList::Run/GetUserObjectInformation failed, GLE=%u"), GetLastError());
                    continue;
                }

            }
            else
            {
                hProcess = pAction->RunAsExe(&pArgs->m_ShellDll);

                if (NULL != hProcess)
                {
                    pArgs->Log.Log(CUSTOMACTIONEXE, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                }
                else
                {
                    pArgs->Log.Log(CUSTOMACTION_WONT_RUN, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                }
            }

            if (hProcess)
            {
                if (fAddWatch) 
                {
                    AddWatchProcess(pArgs,hProcess); // watch for process termination
                }
                else 
                {
                    CloseHandle(hProcess);
                }
            }
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::ParseCmdLine
//
// Synopsis:  This function parses the given command line into the program,
//            dll function name (if required), and the parameters (if any).
//            The individual command line parts are stored in member vars.
//
// Arguments: LPTSTR pszCmdLine - connect action command line to parse
//
// Returns:   Nothing
//
// History:   quintinb original code in Profwiz.cpp ReadConList()
//            fengsun copied and modified   4/16/98
//            quintinb  Rewrote and commonized with the Profwiz version 04/21/00
//
//+----------------------------------------------------------------------------
void CAction::ParseCmdLine(LPTSTR pszCmdLine)
{
    m_pszFunction = m_pszProgram = m_pszParams = NULL;

    CmStrTrim(pszCmdLine);

    HRESULT hr = HrParseCustomActionString(pszCmdLine, &m_pszProgram, &m_pszParams, &m_pszFunction);

    MYDBGASSERT(SUCCEEDED(hr));

    if (NULL == m_pszProgram)
    {
        MYDBGASSERT(FALSE); // we should never have a NULL program
        m_pszProgram = CmStrCpyAlloc(TEXT(""));        
    }

    if (NULL == m_pszParams)
    {
        m_pszParams = CmStrCpyAlloc(TEXT(""));
    }

    if (NULL == m_pszFunction)
    {
        m_pszFunction = CmStrCpyAlloc(TEXT(""));
    }

    //
    //  If we have a function, then the program was a Dll
    //
    m_fIsDll = (m_pszFunction && (TEXT('\0') != m_pszFunction[0]));
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::CAction
//
// Synopsis:  Constructor
//
// Arguments: LPTSTR lpCommandLine - The command read from the profile
//                                    CAction is responsible to free it
//            UINT dwFlags - The flags read from the profile
//            LPTSTR lpDescript - The description of the connect action read from
//                      profile.  CAction is responsible to free it.
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/15/98
//
//+----------------------------------------------------------------------------
CAction::CAction(LPTSTR lpCommandLine, UINT dwFlags, LPTSTR lpDescript) 
{
    m_dwFlags = dwFlags;
    m_pszDescription = lpDescript;

    //
    // Get all information from command line, including 
    // Program name, function name, parameters
    //
    ParseCmdLine(lpCommandLine);

    //
    // If this is a DLL, but there is no description, use the name of the file
    // Can not use C Run Time routine _tsplitpath()
    //

    if (m_fIsDll && (m_pszDescription == NULL || m_pszDescription[0]==TEXT('\0')))
    {
        //
        // Find the last '\\' to get only the file name
        //
        LPTSTR pszTmp = CmStrrchr(m_pszProgram, '\\');
        if (pszTmp == NULL)
        {
            pszTmp = m_pszProgram;
        }
        else
        {
            pszTmp++;
        }

        CmFree(m_pszDescription);
        m_pszDescription = CmStrCpyAlloc(pszTmp);
    }
}

CAction::~CAction() 
{
    CmFree(m_pszProgram); 
    CmFree(m_pszParams);
    CmFree(m_pszFunction);
    CmFree(m_pszDescription);
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunAsDll
//
// Synopsis:  Run the action as a Dll
//            Format is: DllName.dll FunctionName Argument
//                      Long file name is enclosed by '+'
//
// Arguments: HWND hwndDlg          - The parent window
//            DWORD& dwReturnValue  - The return value of the dll fuction
//            DWORD dwLoadType      - The permitted load location 
//
// Returns:   BOOL - TRUE, if the action is a Dll
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
BOOL CAction::RunAsDll(HWND hwndDlg, OUT DWORD& dwReturnValue, DWORD dwLoadType) const
{
    MYDBGASSERT(IsDll());

    dwReturnValue = FALSE;

    LPWSTR pszwModuleName = NULL;

    //
    // Determine the module name to be used
    //

    if (!GetLoadDirWithAlloc(dwLoadType, &pszwModuleName))
    {
        CMASSERTMSG(FALSE, TEXT("CAction::RunAsDll -- GetLoadDirWithAlloc Failed."));
        CmFree(pszwModuleName);
        return FALSE;
    }
    
    //
    // Load the module
    //

    HINSTANCE hLibrary = LoadLibraryExU(pszwModuleName, NULL, 0);

    if (NULL == hLibrary)
    {
        CMTRACE2(TEXT("RunAsDll() LoadLibrary(%s) failed, GLE=%u."),
                 MYDBGSTR(pszwModuleName), GetLastError());
        
        CmFree(pszwModuleName);
        return FALSE;
    }

    pfnCmConnectActionFunc pfnFunc;
    LPSTR pszFunctionName = NULL;
    LPSTR pszParams = NULL;

#ifdef UNICODE
    pszFunctionName = WzToSzWithAlloc(m_pszFunction);
#else
    pszFunctionName = m_pszFunction;
#endif

    //
    //  Get the Procedure Address
    //
    pfnFunc = (pfnCmConnectActionFunc)GetProcAddress(hLibrary, pszFunctionName);

#ifdef UNICODE
    CmFree(pszFunctionName);
#endif


    if (pfnFunc) 
    {
#if !defined (DEBUG)
        __try 
        {
#endif

#ifdef UNICODE
    pszParams = WzToSzWithAlloc(m_pszParams);
#else
    pszParams = m_pszParams;
#endif

        //
        //  Execute the Function
        //
        dwReturnValue = pfnFunc(hwndDlg, hLibrary, pszParams, SW_SHOW);

#ifdef UNICODE
        CmFree(pszParams);
#endif
        
        CMTRACE1(TEXT("RunAsDll() Executed module: %s"), MYDBGSTR(pszwModuleName));
        CMTRACE1(TEXT("\tFunction:  %s"), MYDBGSTR(m_pszFunction));
        CMTRACE1(TEXT("\tParams:  %s"), MYDBGSTR(m_pszParams));
        CMTRACE2(TEXT("\t Return Value:  %u = 0x%x"), dwReturnValue, dwReturnValue);

#if !defined (DEBUG)
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {   
        }
#endif
    }
    else
    {
        dwReturnValue = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);

        CMTRACE3(TEXT("RunAsDll() GetProcAddress(*pszwModuleName=%s,*m_pszFunction=%s) failed, GLE=%u."), 
            MYDBGSTR(pszwModuleName), MYDBGSTR(m_pszFunction), GetLastError());
    }

    CmFree(pszwModuleName);
    FreeLibrary(hLibrary);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunAsExe
//
// Synopsis:  Run the action as an exe or other shell object
//
// Arguments: CShellDll* pShellDll, pointer to the link to shell32.dll
//
// Returns:   HANDLE - The action Process handle, for Win32 only
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
HANDLE CAction::RunAsExe(CShellDll* pShellDll) const
{
    // Now we have the exe name and args separated, execute it
    
    SHELLEXECUTEINFO seiInfo;

    ZeroMemory(&seiInfo,sizeof(seiInfo));
    seiInfo.cbSize = sizeof(seiInfo);
    seiInfo.fMask |= SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS;
    seiInfo.lpFile = m_pszProgram;
    seiInfo.lpParameters = m_pszParams;
    seiInfo.nShow = SW_SHOW;

    MYDBGASSERT(pShellDll);

    if (!pShellDll->ExecuteEx(&seiInfo))
    {
        CMTRACE3(TEXT("RunAsExe() ShellExecuteEx() of %s %s GLE=%u."), 
            MYDBGSTR(m_pszProgram), MYDBGSTR(m_pszParams), GetLastError());

        return NULL;
    }

    return seiInfo.hProcess;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::GetLoadDirWithAlloc
//
// Synopsis:  Uses the dwLoadType parameter to decide how the path should be
//            modified.  This is used in the WinLogon context to prevent just
//            any executable from being executed.  Must be from the profile dir
//            or the system dir.
//
// Arguments: DWORD dwLoadType - Load type, currently 0 == system dir, 1 == profile dir (default)
//            LPWSTR pszwPath - string buffer to put the modified path in
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb      Created                 01/11/2000
//            sumitc        Change to alloc retval  05/08/2000
//
//+----------------------------------------------------------------------------
BOOL CAction::GetLoadDirWithAlloc(IN DWORD dwLoadType, OUT LPWSTR * ppszwPath) const
{
    LPWSTR  psz = NULL;
    UINT    cch = 0;
    
    //
    //  Check that we have an output buffer
    //
    if (NULL == ppszwPath)
    {
        return FALSE;
    }

    //
    //  Compute how much space we need
    //
    if (dwLoadType)
    {
        // 1 = profile dir
        cch += lstrlen(m_pszProgram) + 1;
    }
    else
    {
        // 0 = system dir
        cch = GetSystemDirectoryU(NULL, 0);
        cch += lstrlen(TEXT("\\"));
        cch += lstrlen(m_pszProgram) + 1;   // is the +1 already in the GetSystemDir retval?
    }

    //
    //  Allocate it
    //
    psz = (LPWSTR) CmMalloc(sizeof(TCHAR) * cch);
    if (NULL == psz)
    {
        return FALSE;
    }

    //
    //  Process the load type
    //
    if (dwLoadType)
    {
        //
        // If relative path, this will already be expanded.
        //

        lstrcpyU(psz, m_pszProgram);
    }
    else
    {
        //
        //  Force the system directory
        //
        if (0 == GetSystemDirectoryU(psz, cch))
        {
            CmFree(psz);
            return FALSE;
        }

        lstrcatU(psz, TEXT("\\"));
        lstrcatU(psz, m_pszProgram);
    }

    *ppszwPath = psz;
    
    return TRUE;    
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunAsExeFromSystem
//
// Synopsis:  Run the action as an exe or other shell object on the choosen desktop
//
// Arguments: CShellDll* pShellDll  - pointer to the link to shell32.dll
//            LPTSTR pszDesktop     - name of the desktop to execute the exe on
//            DWORD dwLoadType      - location from which to load the exe
//
// Returns:   HANDLE - The action Process handle, for Win32 only
//
// History:   v-vijayb          Created                 07/19/99
//            nickball          Removed fSecurity       07/27/99
//
//+----------------------------------------------------------------------------
HANDLE CAction::RunAsExeFromSystem(CShellDll* pShellDll, LPTSTR pszDesktop, DWORD dwLoadType)
{
    STARTUPINFO         StartupInfo = {0};
    PROCESS_INFORMATION ProcessInfo = {0};
    LPWSTR              pszwFullPath = NULL;
    LPWSTR              pszwCommandLine = NULL;

    MYDBGASSERT(OS_NT); 

    StartupInfo.cb = sizeof(StartupInfo);
    if (pszDesktop)
    {
        StartupInfo.lpDesktop = pszDesktop;
        StartupInfo.wShowWindow = SW_SHOW;
    }

    //
    // Use an explicit path to the modules to be launched, this
    // prevents CreateProcess from picking something up on the path.
    //
    if (!GetLoadDirWithAlloc(dwLoadType, &pszwFullPath))
    {
        CMASSERTMSG(FALSE, TEXT("CAction::RunAsExeFromSystem -- GetLoadDirWithAlloc Failed."));
        goto Cleanup;
    }

    pszwCommandLine = CmStrCpyAlloc(m_pszProgram);
    if (NULL == pszwCommandLine)
    {
        CMASSERTMSG(FALSE, TEXT("CAction::RunAsExeFromSystem -- CmStrCpyAlloc Failed."));
        goto Cleanup;
    }

    //
    // Add parameters
    //

    if (NULL == CmStrCatAlloc(&pszwCommandLine, TEXT(" ")))
    {
        goto Cleanup;
    }

    if (NULL == CmStrCatAlloc(&pszwCommandLine, m_pszParams))
    {
        goto Cleanup;
    }

    CMTRACE1(TEXT("RunAsExeFromSystem/CreateProcess() - Launching %s"), pszwCommandLine);

    //
    // Launch the modules, this could be CreateProcessU but it isn't necessary as this only runs on NT
    //
    
    if (NULL == CreateProcess(pszwFullPath, pszwCommandLine,
                              NULL, NULL, FALSE, 0,
                              NULL, NULL,
                              &StartupInfo, &ProcessInfo))
    {
        CMTRACE2(TEXT("RunAsExeFromSystem() CreateProcess() of %s failed, GLE=%u."), pszwCommandLine, GetLastError());
        
        ProcessInfo.hProcess = NULL;
        ProcessInfo.hThread = NULL;
    }

Cleanup:

   if (ProcessInfo.hThread)
   {
       CloseHandle(ProcessInfo.hThread);
   }

    CmFree(pszwFullPath);
    CmFree(pszwCommandLine);

    return ProcessInfo.hProcess;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::ExpandMacros
//
// Synopsis:  Replace the %xxxxx% in command line with the corresponding value
//
// Arguments: ArgsStruct *pArgs - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
void CAction::ExpandMacros(ArgsStruct *pArgs) 
{
    MYDBGASSERT(pArgs);

    LPTSTR pszCurr = m_pszParams;
    BOOL bValidPropertyName;

    while (*pszCurr) 
    {
        if (*pszCurr == TEXT('%'))
        {
            LPTSTR pszNextPercent = CmStrchr(pszCurr + 1, TEXT('%'));
            if (pszNextPercent) 
            {
                LPTSTR pszTmp = (LPTSTR) CmMalloc((DWORD)((pszNextPercent-pszCurr))*sizeof(TCHAR));
                if (pszTmp)
                {
                    CopyMemory(pszTmp,pszCurr+1,(pszNextPercent-pszCurr-1)*sizeof(TCHAR));

                    //
                    // Get the value from name
                    //
                    LPTSTR pszMid = pArgs->GetProperty(pszTmp, &bValidPropertyName);  

                    //
                    // If the property does not exist, use "NULL"
                    //
                    if (pszMid == NULL)
                    {
                        pszMid = CmStrCpyAlloc(TEXT("NULL"));
                    }
                    else if (pszMid[0] == TEXT('\0'))
                    {
                        CmFree(pszMid);
                        pszMid = CmStrCpyAlloc(TEXT("NULL"));
                    }
                    else if ( (lstrcmpiU(pszTmp,TEXT("Profile")) == 0) || 
                        CmStrchr(pszMid, TEXT(' ')) != NULL)
                    {
                        //
                        // If the name is %Profile% or the value has a space in it,
                        // Put the string in double quote
                        //
                        LPTSTR pszValueInQuote = (LPTSTR)CmMalloc((lstrlenU(pszMid)+3)*sizeof(pszMid[0]));
                        if (pszValueInQuote)
                        {
                            lstrcpyU(pszValueInQuote, TEXT("\""));
                            lstrcatU(pszValueInQuote, pszMid);
                            lstrcatU(pszValueInQuote, TEXT("\""));

                            CmFree(pszMid);
                            pszMid = pszValueInQuote;
                        }
                        else
                        {
                            CMTRACE1(TEXT("ExpandMacros() malloc failed, can't put string in double quotes, GLE=%u."), GetLastError());
                        }
                    }

                    // 
                    // if bValidPropertyName is FALSE then leave untouched.
                    // 

                    if (FALSE == bValidPropertyName)
                    {
                        pszCurr = pszNextPercent + 1;
                    }
                    else
                    {
                        //
                        // Replace %xxxx% with the value
                        //
                        DWORD dwLenPre = (DWORD)(pszCurr - m_pszParams);
                        DWORD dwLenMid = lstrlenU(pszMid);
                        DWORD dwLenPost = lstrlenU(pszNextPercent+1);
                        CmFree(pszTmp);
                        pszTmp = m_pszParams;
                        m_pszParams = (LPTSTR) CmMalloc((dwLenPre + dwLenMid + dwLenPost + 1)*sizeof(TCHAR));
                        if (m_pszParams)
                        {
                            CopyMemory(m_pszParams, pszTmp, dwLenPre*sizeof(TCHAR));  // before %
                            lstrcatU(m_pszParams, pszMid);       //append value
                            lstrcatU(m_pszParams, pszNextPercent+1); // after %
                            pszCurr = m_pszParams + dwLenPre + dwLenMid;                
                        }
                        else
                        {
                            // we're out of memory
                            CMTRACE1(TEXT("ExpandMacros() malloc failed, can't strip off %% signs, GLE=%u."), GetLastError());
                            m_pszParams = pszTmp;
                        }
                    }
                    CmFree(pszMid);
                }
                CmFree(pszTmp);
            }
            else
            {
                pszCurr++;            
            }
        }
        else
        {
            pszCurr++;
        }
    }
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CAction::AssertValid
//
// Synopsis:  For debug purpose only, assert the connection object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CAction::AssertValid() const
{
    MYDBGASSERT(m_pszProgram && m_pszProgram[0]);
    MYDBGASSERT(m_fIsDll == TRUE  || m_fIsDll == FALSE);
}
#endif


//+----------------------------------------------------------------------------
//
// Function:  CAction::ExpandEnvironmentStrings
//
// Synopsis:  Utility fn to expand environment variables in the given string
//
// Arguments: ppsz - ptr to string (usually member variable)
//
// Returns:   Nothing
//
// History:   SumitC    Created     29-Feb-2000
//
//+----------------------------------------------------------------------------
void CAction::ExpandEnvironmentStrings(LPTSTR * ppsz)
{
    DWORD cLen;

    MYDBGASSERT(*ppsz);

    //
    //  find out how much memory we need to allocate
    //
    cLen = ExpandEnvironmentStringsU(*ppsz, NULL, 0);

    if (cLen)
    {
        LPTSTR pszTemp = (LPTSTR) CmMalloc((cLen + 1) * sizeof(TCHAR));
 
        if (pszTemp)
        {
            DWORD cLen2 = ExpandEnvironmentStringsU(*ppsz, pszTemp, cLen);
            MYDBGASSERT(cLen == cLen2);

            if (cLen2)
            {
                CmFree(*ppsz);
                *ppsz = pszTemp;
            }
        }
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CAction::IsAllowed
//
// Synopsis:  checks Registry to see if a command is allowed to run
//
// Arguments: _ArgsStruct *pArgs    - Ptr to global args struct
//            LPDWORD lpdwLoadType  - Ptr to DWORD to be filled with load type
//
// Returns:   TRUE if action is allowed @ this time
//
// Notes:     Checks SOFTWARE\Microsoft\Connection Manager\<ServiceName>
//             Under which you will have the Values for each command
//              0 - system32 directory
//              1 - profile directory
// History:   v-vijayb    Created Header    7/20/99
//
//+----------------------------------------------------------------------------
BOOL CAction::IsAllowed(_ArgsStruct *pArgs, LPDWORD lpdwLoadType)
{
    return IsActionEnabled(m_pszProgram, pArgs->szServiceName, pArgs->piniService->GetFile(), lpdwLoadType);
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunConnectActionForCurrentConnection
//
// Synopsis:  This function compares the flags value of the connect action
//            with the current connection type (from pArgs->GetTypeOfConnection).
//            It returns TRUE if the connect action should be run for this type
//            and FALSE if the connect action should be skipped.
//
// Arguments: _ArgsStruct *pArgs    - Ptr to global args struct
//
// Returns:   TRUE if action should be executed
//
// History:   quintinb    Created       04/20/00
//
//+----------------------------------------------------------------------------
BOOL CAction::RunConnectActionForCurrentConnection(_ArgsStruct *pArgs)
{
    BOOL bReturn = TRUE;
    DWORD dwType = pArgs->GetTypeOfConnection();

    if (DIAL_UP_CONNECTION == dwType)
    {
        //
        //  Don't run direct only or tunnel connect actions
        //  on a dialup connection.
        //
        if ((m_dwFlags & DIRECT_ONLY) || (m_dwFlags & ALL_TUNNEL))
        {
            bReturn = FALSE;
        }
    }
    else if (DIRECT_CONNECTION == dwType)
    {
        //
        //  Don't run dialup only or dialup connect actions
        //  on a direct connection.
        //
        if ((m_dwFlags & DIALUP_ONLY) || (m_dwFlags & ALL_DIALUP))
        {
            bReturn = FALSE;
        }
    }
    else if (DOUBLE_DIAL_CONNECTION == dwType)
    {
        //
        //  Don't run dialup only or dialup connect actions
        //  on a direct connection.
        //
        if ((m_dwFlags & DIALUP_ONLY) || (m_dwFlags & DIRECT_ONLY))
        {
            bReturn = FALSE;
        }        
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("CActionList::Run -- unknown connection type, skipping action"));
        bReturn = FALSE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\cmfmtstr.h ===
//+----------------------------------------------------------------------------
//
// File:     cmfmtstr.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Message IDs for cmfmtstr.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------

// String IDs for cmfmtstr.rc

#define IDMSG_PORTNOTCONFIGURED         11000
#define IDMSG_RESTRICTEDLOGONHOURS      11001
#define IDMSG_ACCTDISABLED              11002
#define IDMSG_PASSWDEXPIRED             11003
#define IDMSG_NODIALINPERMISSION        11004
#define IDMSG_ABOUT_BUILDVERSION        11005
#define IDMSG_ABOUT_WARNING_PART1       11006
#define IDMSG_ABOUT_WARNING_PART2       11007
#define IDMSG_EDIT_BUTTON               11009
#define IDMSG_EDIT_NEED_PHONE           11010
#define IDMSG_CMMON_LAUNCH_FAIL         11011
#define IDS_DEFAULT_ACCESSPOINT         11013
#define IDMSG_NEED_USERNAME             11014
#define IDMSG_NEED_PASSWORD             11015
#define IDMSG_NEED_DOMAIN               11016
#define IDMSG_CANTFORMAT                11017
#define IDMSG_NEED_PHONE_DIRECT         11018
#define IDMSG_NEED_PHONE_DIAL           11019
#define IDMSG_ALREADY_CONNECTED         11020
#define IDMSG_ALREADY_CONNECTING        11021
#define IDMSG_ALREADY_DISCONNECTING     11022
#define IDMSG_UNSUPPORTED_SETTING       11023
#define IDMSG_DISCONNECTING             11024
#define IDMSG_INITIALIZING              11025
#define IDMSG_DIALING                   11026
#define IDMSG_TUNNELDIALING             11027
#define IDMSG_CHECKINGPASSWORD          11028
#define IDMSG_LINEBUSY                  11029
#define IDMSG_NOANSWER                  11030
#define IDMSG_PAUSING                   11031
#define IDMSG_TITLESERVICE              11032
#define IDMSG_UNSUPPORTED_SETTING_NUM   11033
#define IDMSG_CANCELED                  11034
#define IDMSG_UNSUPPORTED_DEVICE        11035
#define IDMSG_NOTRESPONDING             11036
#define IDMSG_PICK_VPN_ADDRESS          11037
#define IDMSG_NODIALTONE                11038
#define IDMSG_VOICEANSWER               11039
#define IDMSG_BADPASSWORD               11040
#define IDMSG_PORTINUSE                 11041
#define IDMSG_REMOTEDISCONNECTED        11042
#define IDMSG_NORAS_MSG                 11043
#define IDMSG_DISCONNECT                11044
#define IDMSG_WORKING                   11045
#define IDMSG_PPPPROBLEM                11046
#define IDMSG_TCPIPPROBLEM              11047
#define IDMSG_REBOOT_MSG                11048
//                                      11049
#define IDMSG_NOMATCHPASSWORD           11050
#define IDMSG_EFFECTIVE_NEXT_TIME       11051
#define IDS_TUNNEL_SUFFIX               11052
#define IDS_NEW_PASSWORD_TOOLTIP        11053
#define IDS_RESETPASSWORD               11054
#define IDMSG_RAS_ERROR                 11055
#define IDMSG_SYS_ERROR_DEC             11056
#define IDMSG_CM_ERROR_DEC              11057
#define IDMSG_SYS_ERROR_HEX             11058
#define IDMSG_CM_ERROR_HEX              11059
#define IDMSG_WAITING_FOR_CALLBACK      11060
#define IDMSG_NO_SCRIPT_INST_MSG_95     11061
//                                      11062
//                                      11063
//                                      11064
//                                      11065
//                                      11066
//                                      11067
//                                      11068
//                                      11069
//                                      11070
//                                      11071
//                                      11072
//                                      11073
//                                      11074
//                                      11075
//                                      11076
//                                      11077
//                                      11078
//                                      11079
//                                      11080
//                                      11081
//                                      11082
//                                      11083
//                                      11084
//                                      11085
//                                      11086
//                                      11087
//                                      11088
//                                      11089
//                                      11090
//                                      11091
//                                      11092
//                                      11093
//                                      11094
//                                      11095
//                                      11096
//                                      11097
//                                      11098   
//                                      11099
//                                      11100
//                                      11101
#define IDMSG_NO_CMP_PBK_ACCESS         11102
#define IDMSG_READY                     11103
#define IDMSG_CONFIG_FAILED_MSG         11104
#define IDMSG_DAMAGED_PROFILE           11105
#define IDMSG_WRONG_PROFILE_VERSION     11106
#define IDMSG_PROTOCOL_NOT_CONFIGURED   11107
//                                      11108
#define IDMSG_PORTNOTAVAILABLE          11109
#define IDMSG_DEVICEERROR               11110
#define IDMSG_LINEBUSYREDIAL            11111
#define IDMSG_NOANSWERREDIAL            11112
#define IDMSG_NEED_CONFIGURE_TAPI       11113
#define IDMSG_INSTALLMODEM_MANUALLY_MSG 11114
#define IDMSG_INSTALLSP_MSG             11115
#define IDMSG_TUNNEL_NOANSWER           11116
#define IDMSG_TUNNEL_NOANSWERREDIAL     11117
#define IDMSG_NOMODEM_MSG               11118
#define IDMSG_CONN_ACTION_RUNNING       11119
#define IDMSG_CONN_ACTION_FAILED        11120
#define IDMSG_CONN_ACTION_NOTFOUND      11121
#define IDMSG_TUNNELINUSE               11122
#define IDMSG_TUNNELNOTAVAILABLE        11123
#define IDMSG_NO_LOG_FILE               11124    
#define IDMSG_CANT_VIEW_LOG             11125
//                                      11126
#define IDMSG_NOPPTPINST_MSG_NT         11127
#define IDMSG_NOPPTPINST_MSG_95         11128
#define IDMSG_NOPPTPINST_MSG_98         11129
#define IDMSG_NOPPTPINST_MSG_NT_SP      11130
//                                      11131
#define IDMSG_NEED_PPTP_WIN95           11132
#define IDMSG_NEED_PPTP_NT              11133
#define IDMSG_NEED_PPTP_NT_SP           11134
#define IDMSG_COMPONENTS_CHECKING_INPROCESS 11135
#define IDS_REG_DIALUP_ADAPTER          11300
#define IDS_WANTTOEXIT                  11301
#define IDS_SERVICENOTINSTALLED         11302
#define IDS_SERVICEDISABLED             11303
#define IDS_PHONE_NUM_LABEL             11304
#define IDS_BACKUP_NUM_LABEL            11305
#define IDS_IDLETIME_NEVER              11306
#define IDS_IDLETIME_1MINUTE            11307
#define IDS_IDLETIME_5MINUTE            11308
#define IDS_IDLETIME_10MINUTE           11309
#define IDS_IDLETIME_30MINUTE           11310
#define IDS_IDLETIME_1HOUR              11311
#define IDS_IDLETIME_2HOURS             11312
#define IDS_IDLETIME_4HOURS             11313
#define IDS_IDLETIME_8HOURS             11314
#define IDS_IDLETIME_24HOURS            11315
#define IDS_PROPERTIES_SUFFIX           11316
#define IDMSG_SAVE_ACCESSPOINT          11317
#define IDMSG_DELETE_ACCESSPOINT        11318
#define IDMSG_BALLOON_TITLE_DIALINGRULES 11319
#define IDMSG_BALLOON_MSG_DIALINGRULES	11320
#define IDMSG_BALLOON_TITLE_ACCESSPOINT	11321
#define IDMSG_BALLOON_MSG_ACCESSPOINT	11322
#define IDMSG_DELETE_GLOBAL_CREDS   	11323
#define IDMSG_DELETE_ALL_CREDS          11324
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\ary.cxx ===
//+----------------------------------------------------------------------------
//
// File:	 ary.cxx
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Generic dynamic array class -- CFormsAry
//
// Copyright (c) 1992-1998 Microsoft Corporation
//
// Author:	 quintinb    Created Header   8/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "cm_misc.h"
#include "ary.hxx"

#define CFORMSARY_MAXELEMSIZE    128

//  CFormsAry class
//
//


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::~CFormsAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CFormsAry::~CFormsAry( )
{
    MemFree(PData());
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFormsAry::EnsureSize(size_t cb, int c)
{
    HRESULT hr;
    unsigned cbAlloc = ((c + 7) & ~7) * cb;

    MYDBGASSERT(c >= 0);

    if (c > ((_c + 7) & ~7) && cbAlloc > MemGetSize(PData()))
    {
        hr = MemRealloc((void **)&PData(), cbAlloc);
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array, incrementing
//      the array's logical size, and growing the array's allocated
//      size if necessary.  Note that the element is passed with a
//      pointer, rather than directly.
//
//  Arguments:  cb  Element size
//              pv  Pointer to the element to be appended
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFormsAry::AppendIndirect(size_t cb, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (S_OK != hr)
        return hr;

    memcpy(Deref(cb, _c), pv, cb);
    _c++;

    return NOERROR;
}

#if 0
/*

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//-------------------------------------------------------------------------
void
CFormsAry::Delete(size_t cb, int i)
{
    MYDBGASSERT(i >= 0);
    MYDBGASSERT(i < _c);

    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//-------------------------------------------------------------------------
BOOL
CFormsAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        Delete(cb, i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//-------------------------------------------------------------------------
void
CFormsAry::DeleteMultiple(size_t cb, int start, int end)
{
    MYDBGASSERT((start >= 0) && (end >= 0));
    MYDBGASSERT((start < _c) && (end < _c));
    MYDBGASSERT(end >= start);

    if (end < (_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (_c - end - 1) * cb);
    }

    _c -= (end - start) + 1;
}

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CFormsAry::DeleteAll(void)
{
    MemFree(PData());
    PData() = NULL;
    _c = 0;
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//-------------------------------------------------------------------------
HRESULT
CFormsAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        return hr;

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (_c - i ) * cb);

    memcpy(Deref(cb, i), pv, cb);
    _c++;
    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CFormsAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    MYDBGASSERT(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + cb, PData(), i * cb);
    memcpy(PData(), rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CFormsAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CFormsAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    MYDBGASSERT(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) PData()) + ((_c - 1) * cb), rgb, cb);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::Swap
//
//  Synopsis:   swap two members of array with each other.
//
//  Arguments:  cb  size of elements
//              i1  1st element
//              i2  2nd element
//----------------------------------------------------------------------------
void
CFormsAry::Swap(size_t cb, int i1, int i2)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    MYDBGASSERT(cb <= CFORMSARY_MAXELEMSIZE);

    if (i1 >= _c)
        i1 = _c - 1;
    if (i2 >= _c)
        i2 = _c - 1;

    if (i1 != i2)
    {
        memcpy(rgb, ((BYTE *) PData()) + (i1 * cb), cb);
        memcpy(((BYTE *) PData()) + (i1 * cb), ((BYTE *) PData()) + (i2 * cb), cb);
        memcpy(((BYTE *) PData()) + (i2 * cb), rgb, cb);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//----------------------------------------------------------------------------

int
CFormsAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = _c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return _c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::CopyAppend
//
//  Synopsis:   Copies the entire contents of another CFormsAry object and
//              appends it to the end of the array.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CFormsAry::CopyAppend(size_t cb, const CFormsAry& ary, BOOL fAddRef)
{
    return (CopyAppendIndirect(cb, ary._c, ((CFormsAry *)&ary)->PData(), fAddRef));
}


HRESULT
CFormsAry::CopyAppendIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown ** ppUnk;                  // elem to addref

    if (EnsureSize(cb, _c + c))
        return E_OUTOFMEMORY;

    if (pv)
    {
        memcpy((BYTE*) PData() + (_c * cb), pv, c * cb);
    }

    _c += c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) pv; c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::Copy
//
//  Synopsis:   Creates a copy from another CFormsAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CFormsAry::Copy(size_t cb, const CFormsAry& ary, BOOL fAddRef)
{
    return (CopyIndirect(cb, ary._c, ((CFormsAry *)&ary)->PData(), fAddRef));
}



//+------------------------------------------------------------------------
//
//  Member:     CFormsAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CFormsAry::CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    size_t          cbArray;
    IUnknown **     ppUnk;

    if (pv == PData())
        return S_OK;

    DeleteAll();
    if (pv)
    {
        cbArray = c * cb;
        PData() = MemAlloc(cbArray);
        if (!PData())
            return E_OUTOFMEMORY;

        memcpy(PData(), pv, cbArray);
    }

    _c = c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}

HRESULT
CFormsPtrAry::ClearAndReset()
{
    //  why does this function reallocate memory, rather than
    //  just memset'ing to 0? (chrisz)

    PData() = NULL;
    HRESULT hr = EnsureSize(_c);
    _c = 0;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CFormsPtrAry::*
//
//  Synopsis:   CFormsPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//-------------------------------------------------------------------------

HRESULT
CFormsPtrAry::EnsureSize(int c)
{
    return CFormsAry::EnsureSize(sizeof(void *), c);
}

HRESULT
CFormsPtrAry::Append(void * pv)
{
    return CFormsAry::AppendIndirect(sizeof(void *), &pv);
}

HRESULT
CFormsPtrAry::Insert(int i, void * pv)
{
    return CFormsAry::InsertIndirect(sizeof(void *), i, &pv);
}

int
CFormsPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) PData(); i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CFormsPtrAry::Delete(int i)
{
    CFormsAry::Delete(sizeof(void *), i);
}

BOOL
CFormsPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CFormsAry::Delete(sizeof(void *), i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
CFormsPtrAry::DeleteMultiple(int start, int end)
{
    CFormsAry::DeleteMultiple(sizeof(void*), start, end);
}

void
CFormsPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown * pUnk;

    MYDBGASSERT(idx <= _c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        (pUnk)->Release();

    Delete(idx);
}


void
CFormsPtrAry::ReleaseAll(void)
{
    int         i;
    IUnknown ** ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); i < _c; i++, ppUnk++)
    {
        if (*ppUnk)
            (*ppUnk)->Release();
    }

    DeleteAll();
}

void
CFormsPtrAry::BringToFront(int i)
{
    CFormsAry::BringToFront(sizeof(void *), i);
}


void
CFormsPtrAry::SendToBack(int i)
{
    CFormsAry::SendToBack(sizeof(void *), i);
}

void
CFormsPtrAry::Swap(int i1, int i2)
{
    CFormsAry::Swap(sizeof(void *), i1, i2);
}


HRESULT
CFormsPtrAry::CopyAppendIndirect(int c, void * pv, BOOL fAddRef)
{
    return CFormsAry::CopyAppendIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CFormsPtrAry::CopyAppend(const CFormsAry& ary, BOOL fAddRef)
{
    return CFormsAry::CopyAppend(sizeof(void *), ary, fAddRef);
}

HRESULT
CFormsPtrAry::CopyIndirect(int c, void * pv, BOOL fAddRef)
{
    return CFormsAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CFormsPtrAry::Copy(const CFormsAry& ary, BOOL fAddRef)
{
    return CFormsAry::Copy(sizeof(void *), ary, fAddRef);
}

HRESULT
CFormsPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CFormsAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}

HRESULT
CFormsPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CFormsAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header   08/17/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "icm.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\compchck.h ===
//+----------------------------------------------------------------------------
//
// File:     CompChck.h
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Provide the win32 only component checking and installing interface
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    10/21/97
//
//+----------------------------------------------------------------------------

#ifndef COMPCHCK_H
#define COMPCHCK_H

//
// By default, perform checks specified by dwComponentsToCheck, ignore reg key
//             install missed components
//
DWORD CheckAndInstallComponents(DWORD dwComponentsToCheck, 
    HWND hWndParent, 
    LPCTSTR pszServiceName,
    BOOL fIgnoreRegKey = TRUE, 
    BOOL fUnattended = FALSE);

void ClearComponentsChecked();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\cm_misc.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Implements the CFreezeWindow Class
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   henryt Created    01/13/98
//
//+----------------------------------------------------------------------------
#ifndef _CM_MISC_INC
#define _CM_MISC_INC

extern  HINSTANCE   g_hInst; // the instance handle for resource

//
// A helper class to auto disable/enable window
// The constructor will disable the window, the distructor will enable the window
//
class CFreezeWindow
{
public:
    CFreezeWindow(HWND hWnd, BOOL fDisableParent = FALSE) 
    {
        //
        // Disable the window
        // To disable a property page, the property sheet also need to be disabled
        //

        m_hWnd = hWnd; 

        if (m_hWnd)
        {
             m_fDisableParent = fDisableParent; 
             
             //
             // Store the currently focuse window
             //

             m_hFocusWnd = GetFocus();

             EnableWindow(m_hWnd, FALSE);

             if (fDisableParent)
             {
                EnableWindow(GetParent(m_hWnd), FALSE);
             }
        }
    }

    ~CFreezeWindow()
    {
        if (m_hWnd)
        {
            EnableWindow(m_hWnd, TRUE);
            if (m_fDisableParent)
            {
                EnableWindow(GetParent(m_hWnd), TRUE);
            }

            //
            // Restore focus to the previously focuses window if any.
            // Its just the right thing to do.
            //

            if (m_hFocusWnd)
            {
                SetFocus(m_hFocusWnd);
            }

        }
    }
protected:
    HWND m_hWnd;
    HWND m_hFocusWnd;
    BOOL m_fDisableParent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\connstat.h ===
//+----------------------------------------------------------------------------
//
// File:     ConnStat.h
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Definition for the class CConnStatistics  class.  Used to collect
//           dial statistics on Win9x.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 quintinb    Created Header    08/17/99
//
//+----------------------------------------------------------------------------

#ifndef CONNSTAT_H
#define CONNSTAT_H

#include <windows.h>
#include <ras.h>

//+---------------------------------------------------------------------------
//
//	class CConnStatistics
//
//	Description: A class to collect connection statistics
//               Not work for NT, NT has its own ras status dialog and 
//               idle disconnect.
//               InitStatistics() will start gathering data from registry
//               OpenByDevice   will gathering data from TAPI device handle
//
//	History:	fengsun	Created		10/1/97
//
//----------------------------------------------------------------------------
class CConnStatistics
{
public:
    CConnStatistics();
    ~CConnStatistics();

    BOOL  IsDialupTwo() const;
    DWORD GetInitBytesRead() const;
    DWORD GetInitBytesWrite() const;
    BOOL  IsAvailable() const;  // whether statistic information is available
    BOOL  InitStatistics();
    void  Close();        // No more statistic information

protected:

    BOOL GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const;
    BOOL RasConnectionExists();
    void GetStatRegValues(HINSTANCE hInst);

protected:

    DWORD  m_dwBaudRate;
    HKEY   m_hKey;          // Performance registry handle
    DWORD  m_dwInitBytesRead;
    DWORD  m_dwInitBytesWrite;

    //
    // Registry names are different for PPP and PPTP
    //

    BOOL m_fAdapter2;

    //
    // Localized version of 
    // "Dial-up Adapter"\TotalBytesRecvd"
    // "Dial-up Adapter"\TotalBytesXmit"
    // "Dial-up Adapter"\ConnectSpeed"
    //
    LPTSTR m_pszTotalBytesRecvd;
    LPTSTR m_pszTotalBytesXmit;
    LPTSTR m_pszConnectSpeed;
};

//
// Inline functions
//

inline DWORD CConnStatistics::GetInitBytesRead() const
{
    return m_dwInitBytesRead;
}

inline DWORD CConnStatistics::GetInitBytesWrite() const
{
    return m_dwInitBytesWrite;
}

inline BOOL CConnStatistics::IsDialupTwo() const
{
    return m_fAdapter2;
}

inline BOOL CConnStatistics::IsAvailable() const
{
    return OS_NT5 ? TRUE : (m_hKey != NULL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\connstat.cpp ===
//+----------------------------------------------------------------------------
//
// File:    ConnStat.cpp	 
//
// Module:  CMDIAL32.DLL
//
// Synopsis: Implementation of class CConnStatistics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 Fengsun Created    10/15/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ConnStat.h"

//
// Include the constants describing the reg keys used for perf stats
// 

#include "perf_str.h"

//
// Constructor and destructor
//

CConnStatistics::CConnStatistics()
{
    MYDBGASSERT(!OS_NT4); // class is never used on NT4

    m_hKey = NULL;
    m_dwInitBytesRead = -1;
    m_dwInitBytesWrite = -1;
    m_dwBaudRate = 0;

    m_pszTotalBytesRecvd = NULL; 
    m_pszTotalBytesXmit = NULL;
    m_pszConnectSpeed = NULL;
}

CConnStatistics::~CConnStatistics()
{
    CmFree( m_pszTotalBytesRecvd );
    CmFree( m_pszTotalBytesXmit );
    CmFree( m_pszConnectSpeed );
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::GetStatRegValues
//
// Synopsis:  Helper method, builds the reg value names using the localized 
//            form of the word "Dial-up Adapter".
//
// Arguments: HINSTANCE hInst
//
// Returns:   Nothing
//
// History:   nickball      Created     11/14/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::GetStatRegValues(HINSTANCE hInst)
{
    //
    // bug 149367 The word "Dial-up Adapter" need to be localized.  
    // Load it from resource if no loaded yet
    //

    if (m_pszTotalBytesRecvd == NULL)
    {
        m_pszTotalBytesRecvd = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesRecvd, m_fAdapter2 ? c_pszDialup_2_TotalBytesRcvd : c_pszDialupTotalBytesRcvd);

        m_pszTotalBytesXmit = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesXmit, m_fAdapter2 ? c_pszDialup_2_TotalBytesXmit : c_pszDialupTotalBytesXmit);

        m_pszConnectSpeed = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszConnectSpeed, m_fAdapter2 ? c_pszDialup_2_ConnectSpeed : c_pszDialupConnectSpeed);
    }
}

//+---------------------------------------------------------------------------
//
//	Function:	InitStatistics()
//
//	Synopsis:	Retrieves Performance Data. On 9x this data is pulled from 
//              the registry. Defaults are used NT5. Not used on NT4.
//
//	Arguments:	None
//
//	Returns:	TRUE  if succeed
//				FALSE otherwise
//
//	History:	byao	    07/16/97    created		
//              fengsun     10/97       make it a member fuction 
//              nickball    03/04/98    always close key 
//              nickball   03/04/00    added NT5 support
//
//----------------------------------------------------------------------------
BOOL CConnStatistics::InitStatistics()
{
    if (OS_W9X)
    {
        MYDBGASSERT(NULL == m_hKey); // Not already opened

        if (m_hKey)
        {
            RegCloseKey(m_hKey);
            m_hKey = NULL;
        }

        DWORD dwErrCode;
        BOOL bRet = FALSE;

        //
        // If there is already a connected dial up connection
        // use the adapter#2 registry key
        //
        m_fAdapter2 = RasConnectionExists();

        dwErrCode = RegOpenKeyExU(HKEY_DYN_DATA, 
						          c_pszDialupPerfKey,
						          0, 
						          KEY_ALL_ACCESS, 
						          &m_hKey );
        CMTRACE1(TEXT("OpenDAPPerfKey() RegOpenKeyEx() returned GLE=%u."), dwErrCode);

        if ( dwErrCode != ERROR_SUCCESS )
        {
            m_hKey = NULL;
        }
        else
        {
            GetStatRegValues(g_hInst);

            //
            // Get the initial statistic info
            //

            if (!GetPerfData(m_dwInitBytesRead, m_dwInitBytesWrite, m_dwBaudRate))
            {
                //
                // No dial-up statistic info
                //
                RegCloseKey(m_hKey);
                m_hKey = NULL;
            }
        }
    
        return m_hKey != NULL;
    }
    else
    {
        //
        // On NT5, there is the starting bytes is always zero because 
        // numbers aren't available to us until the connection is up.
        // Note: Adapter2 indicates the reg key to be examined on 9x
        // it is a non-issue on NT.
        //
    
        m_fAdapter2 = FALSE;

        m_dwInitBytesRead = 0;
        m_dwInitBytesWrite = 0;    
    }

	return TRUE;
}

//+---------------------------------------------------------------------------
//
//	Function:	GetPerfData
//
//	Synopsis:	Get Performance Data from DUN1.2 performance registry
//
//	Arguments:	
//
//	Returns:	TRUE: succeed
//				FALSE otherwise
//
//	History:	byao	created		7/16/97
//              fengsun change it into a member function 10/14/97
//					
//----------------------------------------------------------------------------
BOOL CConnStatistics::GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const
{
    MYDBGASSERT(m_hKey != NULL);
    MYDBGASSERT(m_pszTotalBytesRecvd && *m_pszTotalBytesRecvd);

    LONG dwErrCode;

    DWORD dwValueSize, dwValueType;
	DWORD dwValue;
    LPTSTR lpKeyName;

    //
    // "Dial-up Adapter\TotalBytesRecvd"
    //
    dwValueSize = sizeof(DWORD);
	dwErrCode = RegQueryValueExU(m_hKey,
                                 m_pszTotalBytesRecvd,
				                 NULL,
				                 &dwValueType,
				                 (PBYTE)&dwValue,
				                 &dwValueSize);

	if (dwErrCode == ERROR_SUCCESS) 
	{
		dwRead = dwValue;
    }
	else 
	{
		return FALSE;
	}


    //
    // "Dial-up Adapter\TotalBytesXmit"
    //
	
	dwValueSize = sizeof(DWORD);
	dwErrCode = RegQueryValueExU(m_hKey,
                                 m_pszTotalBytesXmit,
				                 NULL,
				                 &dwValueType,
				                 (PBYTE)&dwValue,
				                 &dwValueSize);

	if (dwErrCode == ERROR_SUCCESS) 
	{
		dwWrite = dwValue;
    }
	else 
	{
		return FALSE;
	}

    //
    // "Dial-up Adapter\ConnectSpeed"
    //
	dwValueSize = sizeof(DWORD);
	dwErrCode = RegQueryValueExU(m_hKey,
                                 m_pszConnectSpeed,
				                 NULL,
				                 &dwValueType,
				                 (PBYTE)&dwValue,
				                 &dwValueSize);

	if (dwErrCode == ERROR_SUCCESS) 
	{
		dwBaudRate = dwValue;
    }
	else 
	{
		return FALSE;
	}

	return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::RasConnectionExists
//
// Synopsis:  Whether there is a connected ras connection running on Win9x.
//
// Arguments: None 
//
// Returns:   BOOL - TRUE if there is one up and connected
//
// History:   fengsun Created     1/15/98
//
//+----------------------------------------------------------------------------
BOOL CConnStatistics::RasConnectionExists()
{
    //
    // Try RasEnumConnections to find out active connections
    //

    HINSTANCE hRasInstance = LoadLibraryExA("RASAPI32", NULL, 0);

    MYDBGASSERT(hRasInstance);
    if (!hRasInstance)
	{
        return FALSE;
	}

    typedef DWORD (WINAPI *PFN_RasEnumConnections)(LPRASCONN, LPDWORD, LPDWORD);
	PFN_RasEnumConnections lpRasEnumConnections;

    lpRasEnumConnections = (PFN_RasEnumConnections)GetProcAddress(hRasInstance, "RasEnumConnectionsA");

    MYDBGASSERT(lpRasEnumConnections);
	if (!lpRasEnumConnections)
	{
        FreeLibrary(hRasInstance);
        return FALSE;
	}

    DWORD dwConnections = 0;
    DWORD dwSizeNeeded = 0;
    if (lpRasEnumConnections(NULL,&dwSizeNeeded,&dwConnections))
    {
        MYDBGASSERT(dwConnections < 2);
        if (dwConnections > 0)
        {
            FreeLibrary(hRasInstance);
            return TRUE;
        }
    }

    FreeLibrary(hRasInstance);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::Close
//
// Synopsis:  Stop gathering statistic and close the handle
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Anonymous     Created Header          10/15/97
//            nickball      Reduced to close key    03/04/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::Close()
{
	if (m_hKey)
	{
		DWORD dwErrCode = RegCloseKey(m_hKey);
		CMTRACE1(TEXT("Close() RegCloseKey() returned GLE=%u."), dwErrCode);
        m_hKey = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\ctr.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ctr.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Implements the Ole Container object for the future splash 
//           Animation control.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

/*
#define STRICT
*/

// macros used to reduce verbiage in RECT handling.

#define WIDTH(r)  (r.right - r.left)
#define HEIGHT(r) (r.bottom - r.top)

// max size for LoadString.

// string constants
const WCHAR g_awchHostName[] = L"ICM FS OC Container";

//+---------------------------------------------------------------------------
//
//  Function:   LinkToOle32
//
//  Synopsis:   Initializes the specified Ole32Linkage by linking to the DLL
//              specified in pszOle32 and retrieving the proc address for the 
//              functions that we need to call
//
//  Arguments:  pOle32Link - ptr to Ole32LinkagStruct
//              pszOl32     - ptr DLL name string
//
//  Returns:    TRUE    if SUCCESS
//              FALSE   otherwise.
//
//  History:    nickball    Created     8/14/97
//
//----------------------------------------------------------------------------

BOOL LinkToOle32(
    Ole32LinkageStruct *pOle32Link,
    LPCSTR pszOle32) 
{
    MYDBGASSERT(pOle32Link);
    MYDBGASSERT(pszOle32);
    
    LPCSTR apszOle32[] = {
        "OleInitialize",
        "OleUninitialize",
        "OleSetContainedObject",
        "CoCreateInstance",
        NULL
    };

    MYDBGASSERT(sizeof(pOle32Link->apvPfnOle32)/sizeof(pOle32Link->apvPfnOle32[0])==sizeof(apszOle32)/sizeof(apszOle32[0]));

    ZeroMemory(pOle32Link, sizeof(Ole32LinkageStruct));
    
    return (LinkToDll(&pOle32Link->hInstOle32,
                        pszOle32,
                        apszOle32,
                        pOle32Link->apvPfnOle32));
}

//+---------------------------------------------------------------------------
//
//  Function:   UnlinkFromOle32
//
//  Synopsis:   The reverse of LinkToOle32().
//
//  Arguments:  pOle32Link - ptr to Ole32LinkagStruct
//
//  Returns:    Nothing
//
//  History:    nickball    Created     8/14/97
//
//----------------------------------------------------------------------------

void UnlinkFromOle32(Ole32LinkageStruct *pOle32Link) 
{
    MYDBGASSERT(pOle32Link);

    if (pOle32Link->hInstOle32) 
    {
        FreeLibrary(pOle32Link->hInstOle32);
    }

    ZeroMemory(pOle32Link, sizeof(Ole32LinkageStruct));
}

VOID CleanupCtr(LPICMOCCtr pCtr)
{
    if (pCtr)
    {
        pCtr->ShutDown();
        pCtr->Release();
    }
}


// move (translate) the rectangle by (dx, dy)
inline VOID MoveRect(LPRECT prc, int dx, int dy)
{
    prc->left += dx;
    prc->right += dx;
    prc->top += dy;
    prc->bottom += dy;
}

const ULONG MAX_STATUS_TEXT = MAX_PATH;


//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::CDynamicOleAut
//
//  Synopsis:   ctor for the Dynamic OleAut class 
//
//  Arguments:  None
//
//----------------------------------------------------------------------------

CDynamicOleAut::CDynamicOleAut()
{
    //
    // Setup OLEAUT32 linkage
    //

    LPCSTR apszOleAut[] = {
        "VariantClear",
        "VariantCopy",
        "VariantInit",
        "VariantChangeType",
        "SysAllocString",
        "SysFreeString",
        NULL
    };

    MYDBGASSERT(sizeof(m_OleAutLink.apvPfnOleAut)/sizeof(m_OleAutLink.apvPfnOleAut[0]) == 
                sizeof(apszOleAut)/sizeof(apszOleAut[0]));

    ZeroMemory(&m_OleAutLink, sizeof(m_OleAutLink));

    //
    // Do the link, but make it obvious if it fails
    //

    if (!LinkToDll(&m_OleAutLink.hInstOleAut, "OLEAUT32.DLL", 
                   apszOleAut, m_OleAutLink.apvPfnOleAut))     
    {
        if (m_OleAutLink.hInstOleAut)
        {
            FreeLibrary(m_OleAutLink.hInstOleAut);
        }
        ZeroMemory(&m_OleAutLink, sizeof(m_OleAutLink));    
    }

    MYDBGASSERT(m_OleAutLink.hInstOleAut);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::~CDynamicOleAut
//
//  Synopsis:   dtor for the Dynamic OleAut class 
//
//  Arguments:  None
//
//----------------------------------------------------------------------------

CDynamicOleAut::~CDynamicOleAut()
{
    if (m_OleAutLink.hInstOleAut) 
    {
        FreeLibrary(m_OleAutLink.hInstOleAut);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantClear
//
//  Synopsis:   Wrapper for VariantClear in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

HRESULT
CDynamicOleAut::DynVariantClear(VARIANTARG FAR* pVar)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnVariantClear)
    {
        return E_FAIL;
    }

    return m_OleAutLink.pfnVariantClear(pVar);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantCopy
//
//  Synopsis:   Wrapper for VariantCopy in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

HRESULT
CDynamicOleAut::DynVariantCopy(
    VARIANTARG FAR* pVar1, 
    VARIANTARG FAR* pVar2)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnVariantCopy)
    {
        return E_FAIL;
    }

    return m_OleAutLink.pfnVariantCopy(pVar1, pVar2);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantInit
//
//  Synopsis:   Wrapper for VariantInit in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

VOID
CDynamicOleAut::DynVariantInit(VARIANTARG FAR* pVar)
{
    if (m_OleAutLink.hInstOleAut && m_OleAutLink.pfnVariantInit)
    {
        m_OleAutLink.pfnVariantInit(pVar);    
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantChangeType
//
//  Synopsis:   Wrapper for VariantChangeType in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

HRESULT
CDynamicOleAut::DynVariantChangeType(
    VARIANTARG FAR* pVar1, 
    VARIANTARG FAR* pVar2, 
    unsigned short wFlags, 
    VARTYPE vt)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnVariantChangeType)
    {
        return E_FAIL;
    }

    return m_OleAutLink.pfnVariantChangeType(pVar1, pVar2, wFlags, vt);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynSysAllocString
//
//  Synopsis:   Wrapper for SysAllocString in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------
    
BSTR 
CDynamicOleAut::DynSysAllocString(OLECHAR FAR* sz)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnSysAllocString)
    {
        return NULL;
    }

    return m_OleAutLink.pfnSysAllocString(sz);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynSysFreeString
//
//  Synopsis:   Wrapper for SysFreeString in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

VOID 
CDynamicOleAut::DynSysFreeString(BSTR bstr)
{
    if (m_OleAutLink.hInstOleAut && m_OleAutLink.pfnSysFreeString)
    {
        m_OleAutLink.pfnSysFreeString(bstr);
    }
}
    
//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::Initialized
//
//  Synopsis:   Simple query to report if linkage is valid
//
//  Arguments:  None
//
//----------------------------------------------------------------------------
BOOL 
CDynamicOleAut::Initialized()
{
    return (NULL != m_OleAutLink.hInstOleAut);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::CICMOCCtr
//
//  Synopsis:   ctor for the OLE Controls container class.
//
//  Arguments:  [hWnd] -- hWnd for the main browser
//
//----------------------------------------------------------------------------
#pragma warning(disable:4355) // this used in initialization list
CICMOCCtr::CICMOCCtr(const HWND hWndMainDlg, const HWND hWndFrame) :
    m_hWndMainDlg(hWndMainDlg),
    m_hWndFrame(hWndFrame),
    m_CS(this),
    m_AS(this),
    m_IPF(this),
    m_IPS(this),
    m_OCtr(this),
    m_PB(this),
    m_pActiveObj(0),
    m_Ref(1),
    m_pUnk(0),
    m_pOC(0),
    m_pVO(0),
    m_pOO(0),
    m_pIPO(0),
    m_pDisp(0),
    m_state(OS_PASSIVE),
    m_dwMiscStatus(0),
    m_fModelessEnabled(TRUE)
{
    ::memset(&m_rcToolSpace, 0, sizeof m_rcToolSpace);
    InitPixelsPerInch(); // initialize the HIMETRIC routines

    // init all the state mappings to -1
    for (INT i = PS_Interactive; i < PS_Last; i++)
    {
        m_alStateMappings[i] = -1;
    }
}
#pragma warning(default:4355)

CICMOCCtr::~CICMOCCtr(VOID)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::HasLinkage
//
//  Synopsis:   Initialize - verify that we have a link to OLEAUT32.DLL
//
//----------------------------------------------------------------------------
BOOL 
CICMOCCtr::Initialized(VOID)
{   
    return m_DOA.Initialized();
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::ShutDown
//
//  Synopsis:   cleanup all the OLE stuff.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::ShutDown(VOID)
{
    if (m_pOC)
        m_pOC->Release();
    if (m_pIPO)
    {
        MYDBGASSERT(m_state == OS_UIACTIVE || m_state == OS_INPLACE);
        if (m_state == OS_UIACTIVE)
        {
            m_pIPO->UIDeactivate();
            // m_state = OS_INPLACE; // for documentation purposes
            if (m_pActiveObj)
            {
                m_pActiveObj->Release();
                m_pActiveObj = 0;
            }
        }

        m_pIPO->InPlaceDeactivate();
        // m_state = OS_RUNNING;
    }
    if (m_pVO)
    {
        // kill the advisory connection
        m_pVO->SetAdvise(DVASPECT_CONTENT, 0, 0);
        m_pVO->Release();
    }
    if (m_pOO)
    {
        m_pOO->Close(OLECLOSE_NOSAVE);
        m_pOO->SetClientSite(0);
        m_pOO->Release();
    }
    if (m_pDisp)
        m_pDisp->Release();
    if (m_pUnk)
        m_pUnk->Release();

    MYDBGASSERT(!m_pActiveObj);

    m_pDisp      = 0;
    m_pOC        = 0;
    m_pIPO       = 0;
    m_pActiveObj = 0;
    m_pVO        = 0;
    m_pOO        = 0;
    m_pUnk       = 0;
    m_state      = OS_PASSIVE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::AddRef
//
//  Synopsis:   bump refcount up on container.  Note that all the
//              interfaces handed out delegate to this one.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CICMOCCtr::AddRef(VOID)
{
    return ++m_Ref;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::Release
//
//  Synopsis:   decrement the refcount on container, and delete when it
//              hits 0 - note that all the interfaces handed out delegate
//              to this one.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CICMOCCtr::Release(VOID)
{
    ULONG ulRC = --m_Ref;

    if (!ulRC)
    {
        delete this;
    }

    return ulRC;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::QueryInterface
//
//  Synopsis:   this is where we hand out all the interfaces.  All the
//              interfaces delegate back to this.
//
//  Arguments:  [riid] -- IID of interface desired.
//              [ppv]  -- interface returned.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CICMOCCtr::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    *ppv = 0;

    LPUNKNOWN pUnk;

    if (::IsEqualIID(riid, IID_IOleClientSite))
        pUnk = &m_CS;
    else if (::IsEqualIID(riid, IID_IAdviseSink))
        pUnk = &m_AS;
    else if (::IsEqualIID(riid, IID_IUnknown))
        pUnk = this;
    else if (::IsEqualIID(riid, IID_IOleInPlaceFrame) ||
             ::IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        pUnk = &m_IPF;
    else if (::IsEqualIID(riid, IID_IOleInPlaceSite))
        pUnk = &m_IPS;
    else if (::IsEqualIID(riid, IID_IPropertyBag))
        pUnk = &m_PB;
    else
        return E_NOINTERFACE;

    pUnk->AddRef();

    *ppv = pUnk;

    return S_OK;
}


extern "C" CLSID const CLSID_FS =
{
    0xD27CDB6E,
    0xAE6D,
    0x11CF,
    { 0x96, 0xB8, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 }
};

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::CreateFSOC
//
//  Synopsis:   Creates an instance of the Future Splash OC, embedding it in
//              our container.  QIs for all the relevant pointers and
//              transitions the control to the UIActive state.
//
//  Arguments:  pOle32Link - ptr to Ole32LinkageStruct containing funtion 
//                           pointers to dynamically linked OLE32 DLL
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::CreateFSOC(Ole32LinkageStruct *pOle32Link)
{
    MYDBGASSERT(pOle32Link);

    HRESULT hr = E_FAIL;
    RECT    rc;
    LPPERSISTPROPERTYBAG pPPB = 0;

    // GetFrameWindow() also asserts that hwnd ::IsWindow()
    MYDBGASSERT(GetFrameWindow());

    //
    // Use dyna-linked CoCreateInstance to create the OC
    //

    if (pOle32Link->hInstOle32 && pOle32Link->pfnCoCreateInstance)
    {
        hr = pOle32Link->pfnCoCreateInstance(
                CLSID_FS,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                (LPVOID *) &m_pUnk);
    }
    else
    {
        hr = E_FAIL;
    }

    if (S_OK != hr)
        goto Cleanup;

    m_state = OS_RUNNING;

    // get the View object - although we rarely draw the OC thru this.
    // since we immediately transition it to the UIActive state, it
    // usually draws itself through its own wndproc.
    hr = m_pUnk->QueryInterface(IID_IViewObject, (LPVOID FAR *) &m_pVO);
    if (S_OK != hr)
        goto Cleanup;

    // get the IOleObject pointer - the main interface through which
    // we handle the basic OLE object state transition stuff
    // for the Future Splash OC
    hr = m_pUnk->QueryInterface(IID_IOleObject, (LPVOID FAR *) &m_pOO);
    if (S_OK != hr)
        goto Cleanup;

    // get status bits on the OC - we're not currently doing anything
    // with them.
    hr = m_pOO->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
    if (S_OK != hr)
        goto Cleanup;

    // set our client site into the oleobject
    hr = m_pOO->SetClientSite(&m_CS);
    if (S_OK != hr)
        goto Cleanup;

    hr = m_pUnk->QueryInterface(IID_IPersistPropertyBag, (LPVOID *) &pPPB);
    if (S_OK != hr)
        goto Cleanup;

    hr = pPPB->Load(&m_PB, 0);
    if (S_OK != hr)
        goto Cleanup;

    // set our advise sink into the view object, so we
    // get notifications that we need to redraw.
    hr = m_pVO->SetAdvise(DVASPECT_CONTENT, 0, &m_AS);
    if (S_OK != hr)
        goto Cleanup;

    //
    // Use dyna-linked OleSetContainedObject
    //
    
    if (pOle32Link->hInstOle32 && pOle32Link->pfnOleSetContainedObject)
    {
        // standard OLE protocol stuff.
        hr = pOle32Link->pfnOleSetContainedObject(m_pUnk, TRUE);
    }
    else
    {
        hr = E_FAIL;
    }
    
    if (S_OK != hr)
        goto Cleanup;

    // ditto
    hr = m_pOO->SetHostNames(g_awchHostName, 0);
    if (S_OK != hr)
        goto Cleanup;

    // get the IDispatch for the control.  This is for late-bound
    // access to the properties and methods.
    hr = m_pUnk->QueryInterface(IID_IDispatch, (LPVOID FAR *) &m_pDisp);
    if (S_OK != hr)
        goto Cleanup;

    // get the IOleControl interface; although we use it for very little.
    hr = m_pUnk->QueryInterface(IID_IOleControl, (LPVOID FAR *) &m_pOC);
    if (S_OK != hr)
        goto Cleanup;

    // transition the control to the inplace-active state - it will have
    // an hWnd after it returns from DoVerb, and will begin drawing
    // itself.

    _GetDoVerbRect(&rc); // get rect for firing verbs.

    hr = m_pOO->DoVerb(OLEIVERB_INPLACEACTIVATE, 0, &m_CS, 0, GetMainWindow(), &rc);
    if (S_OK != hr)
        goto Cleanup;

    // go ahead and UI activate it.  This will cause it to QI for our
    // IOleInPlaceFrame and call SetActiveObject, which we will store
    // in m_pActiveObj
    hr = m_pOO->DoVerb(OLEIVERB_UIACTIVATE, 0, &m_CS, 0, GetMainWindow(), &rc);
    if (S_OK != hr)
        goto Cleanup;

Cleanup:
    if (pPPB)
        pPPB->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_AdjustForTools
//
//  Synopsis:   adjusts the rect passed in for any toolspace claimed by the
//              FS OC.  Currently, the FS OC always just
//              passed in a rect with four zeros in it - but if it ever
//              does decide to do this, we're ready :).
//
//  Arguments:  [prc] -- the rect we want to reduce by the BORDERWIDTHS
//                       stored in m_rcToolSpace.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::_AdjustForTools(LPRECT prc)
{
    prc->left += m_rcToolSpace.left;
    prc->top += m_rcToolSpace.top;
    prc->bottom -= m_rcToolSpace.bottom;
    prc->right -= m_rcToolSpace.right;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::GetSize
//
//  Synopsis:   returns the size, in pixels, of the FS OC.
//
//  Arguments:  [prc] --  returned size.
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::GetSize(LPRECT prc)
{
    MYDBGASSERT(m_pOO);
    HRESULT hr;

    // if we're inplace active, just ask the frame window.
    if (m_state >= OS_INPLACE)
    {
        MYDBGASSERT(m_pIPO);
        ::GetClientRect(GetFrameWindow(), prc);
        hr = S_OK;
    }
    else  // not inplace active - probably this is never hit.
    {
        SIZEL sizel;
        hr = m_pOO->GetExtent(DVASPECT_CONTENT, &sizel);
        if (S_OK == hr)
        {
            prc->left = 0;
            prc->top = 0;
            prc->right = ::HPixFromHimetric(sizel.cx);
            prc->bottom = ::VPixFromHimetric(sizel.cy);
        }
    }

    // adjust the borders for any tools that a UIActive object
    // wants to place there.
    if (S_OK == hr)
        _AdjustForTools(prc);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::DoLayout
//
//  Synopsis:   manages the vertical layout of things -
//              sizes the OC container itself.
//
//  Arguments:  [cxMain] -- width
//              [cyMain] -- height
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::DoLayout(INT cxMain, INT cyMain)
{
    RECT rc;

    MYDBGASSERT(m_hWndFrame && ::IsWindow(m_hWndFrame));

    ::GetClientRect(m_hWndFrame, &rc);

    SetSize(&rc, TRUE);
}

HRESULT
CICMOCCtr::_SetExtent(LPRECT prc)
{
    SIZEL   sizel;
    HRESULT hr;

    sizel.cx = ::HimetricFromHPix(prc->right - prc->left);
    sizel.cy = ::HimetricFromVPix(prc->bottom - prc->top);

    MYDBGASSERT(m_pOO);

    hr = m_pOO->SetExtent(DVASPECT_CONTENT, &sizel);
    if (S_OK != hr)
        goto cleanup;

    hr = m_pOO->GetExtent(DVASPECT_CONTENT, &sizel);
    if (S_OK != hr)
        goto cleanup;

    prc->right = ::HPixFromHimetric(sizel.cx);
    prc->bottom = ::VPixFromHimetric(sizel.cy);

cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::SetSize
//
//  Synopsis:   sets the size of the FS OC space (the HTML area)
//
//  Effects:    if fMoveFrameWindow is TRUE, then it moves the whole
//              framewindow around, otherwise, it just readjusts how much
//              of the framewindow space is used by the OC itself.
//              In reality, what happens is that the OC calls us to
//              set some border space (although at this writing it still
//              is setting BORDERWIDTHS of 0,0,0,0), we allow that
//              much space, then call IOleInPlaceObject->SetObjectRects
//              to resize the object to whatever's left.
//              Otherwise, if the object is not yet active, we just
//              call IOleObject::SetExtent().
//
//  Arguments:  [prc]              -- size to set object to
//              [fMoveFrameWindow] -- is the hwnd size changing, or just
//                                    the object within?
//
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::SetSize(LPRECT prc, BOOL fMoveFrameWindow)
{
    HRESULT hr;
    RECT    rcClient;
    RECT    rcExtent;

     // get client coords.
    rcClient = *prc;
    ::MoveRect(&rcClient, -rcClient.left, -rcClient.top);

    if (fMoveFrameWindow)
    {
        ::SetWindowPos(
                GetFrameWindow(),
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                SWP_NOZORDER | SWP_NOACTIVATE);

         if (m_pActiveObj)
            m_pActiveObj->ResizeBorder(&rcClient, &m_IPF, TRUE);
    }

    // subtract off any tools the client has around .
    _AdjustForTools(&rcClient);

    rcExtent = rcClient;
    hr = _SetExtent(&rcExtent);
    if (S_OK != hr)
        goto cleanup;

    // now we need to call SetObjectRects
    if (m_pIPO && m_state >= OS_INPLACE)
        hr = m_pIPO->SetObjectRects(&rcExtent, &rcClient);

cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::Paint
//
//  Synopsis:   Paint with no parameters
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::Paint(VOID)
{
    PAINTSTRUCT ps;
    RECT        rc;

    // we don't need to call IViewObject if the object is activated.
    // it's got an hWnd and is receiving paint messages of its own.
    if (m_state < OS_INPLACE)
    {
        if (S_OK == GetSize(&rc))
        {
            ::BeginPaint(GetFrameWindow(), &ps);
              Paint(ps.hdc, &rc);
            ::EndPaint(GetFrameWindow(), &ps);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::Paint
//
//  Synopsis:   paint with the hdc and rect passed in.  Uses
//              IViewObject::Draw()
//
//  Arguments:  [hDC] -- dc to draw to - can be container's or
//                       even print dc (never is a print dc in
//                       our scenario -
//              [lpr] -- rect for painting.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::Paint(HDC hDC, LPRECT lpr)
{
    // adjust the borders in to allow for any tools the OC
    // wanted to insert - so far it never does.
    _AdjustForTools(lpr);

    // have to use a RECTL instead of RECT - remnant of the
    // OLE 16 bit days.
    RECTL rcl = {lpr->left, lpr->top, lpr->right, lpr->bottom};
    if (m_pVO)
        m_pVO->Draw(DVASPECT_CONTENT, -1, 0, 0, 0, hDC, &rcl, 0, 0, 0);
}


VOID
CICMOCCtr::MapStateToFrame(ProgState ps)
{
    // if the statemappings are -1, they are unitialized, don't use them.
    LONG lFrame = m_alStateMappings[ps];
    if (-1 != lFrame)
        SetFrame(lFrame);  // ignore error - nothing we can do.
}


HRESULT
CICMOCCtr::SetFrame(LONG lFrame)
{
    HRESULT    hr;
    OLECHAR *  pFrameNum = OLESTR("FrameNum");
    OLECHAR *  pPlay     = OLESTR("Play");
    DISPPARAMS dp = {0, 0, 0, 0};
    DISPID     dispidPut = DISPID_PROPERTYPUT;
    VARIANTARG var;
    EXCEPINFO  ei;
    DISPID     id;
    UINT       uArgErr;

    m_DOA.DynVariantInit(&var);

    V_VT(&var) = VT_I4;
    V_I4(&var) = lFrame;

    dp.cArgs = 1;
    dp.rgvarg = &var;
    dp.cNamedArgs = 1;
    dp.rgdispidNamedArgs = &dispidPut;

    hr =  m_pDisp->GetIDsOfNames(
                  IID_NULL,
                  &pFrameNum,
                  1,
                  LOCALE_SYSTEM_DEFAULT,
                  &id);

    if (S_OK != hr)
        goto Cleanup;

    hr = m_pDisp->Invoke(
                 id,
                 IID_NULL,
                 LOCALE_SYSTEM_DEFAULT,
                 DISPATCH_PROPERTYPUT,
                 &dp,
                 0,
                 &ei,
                 &uArgErr);

    if (S_OK != hr)
        goto Cleanup;

    hr = m_pDisp->GetIDsOfNames(
                  IID_NULL,
                  &pPlay,
                  1,
                  LOCALE_SYSTEM_DEFAULT,
                  &id);

    if (S_OK != hr)
        goto Cleanup;

    ::memset(&dp, 0, sizeof dp);

    hr = m_pDisp->Invoke(
                  id,
                  IID_NULL,
                  LOCALE_SYSTEM_DEFAULT,
                  DISPATCH_METHOD,
                  &dp,
                  0,
                  &ei,
                  &uArgErr);

    if (S_OK != hr)
        goto Cleanup;

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::OnActivateApp
//
//  Synopsis:   all WM_ACTIVATE messages (forwarded from
//              main browser hWnd wndproc) must call
//              IOleInPlaceActiveObject::OnFrameWindowActivate(),
//              per the OLE compound document spec.
//
//  Arguments:  [wParam] -- whatever the WM_ACTIVATE msg passed
//              [lParam] -- ditto
//
//  Returns:    0 - to say we handled the message.
//
//----------------------------------------------------------------------------
LRESULT
CICMOCCtr::OnActivateApp(WPARAM wParam, LPARAM lParam)
{
    if (m_pActiveObj)
        m_pActiveObj->OnFrameWindowActivate((BOOL)wParam);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::SetFocus
//
//  Synopsis:   transfers focus from framewindow to the current
//              in-place active object.  Per OLE Compound Document spec.
//
//----------------------------------------------------------------------------
LRESULT
CICMOCCtr::SetFocus(VOID)
{
    HWND hWnd   = NULL;
    LPOLEINPLACEACTIVEOBJECT pAO = GetIPAObject();

    if (pAO)
    {
        if (S_OK == pAO->GetWindow(&hWnd))
        {
            if (hWnd && !::IsWindow(hWnd))
                hWnd = NULL;
        }
    }

    // if no inplaceactive object, set focus to frame window.
    if (!hWnd)
        hWnd = GetFrameWindow();

    ::SetFocus(hWnd);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Class:      CAdviseSink implementations
//
//  Purpose:    to implement IAdviseSink for CICMOCCtr
//
//  Notes:      we don't do much with this interface - it's required
//              for contractual reasons only.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CAdviseSink::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CAdviseSink::Release(VOID)
{
    return m_pCtr->Release();
}

CAdviseSink::CAdviseSink(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP_(VOID)
CAdviseSink::OnDataChange(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdviseSink::OnViewChange
//
//  Synopsis:   IAdviseSink::OnViewChange() - we do get called with this
//              occasionally, but it appears that we're better off just
//              letting the control's wndproc paint it.
//              Calling this was causing extra flicker.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(VOID)
CAdviseSink::OnViewChange(DWORD dwAspect, LONG lIndex)
{
    return;
}

STDMETHODIMP_(VOID)
CAdviseSink::OnRename(LPMONIKER pmk)
{

}

STDMETHODIMP_(VOID)
CAdviseSink::OnSave(VOID)
{

}

STDMETHODIMP_(VOID)
CAdviseSink::OnClose(VOID)
{
}

//+---------------------------------------------------------------------------
//
//  Class:      COleClientSite ()
//
//  Purpose:    our implementation of IOleClientSite
//
//  Interface:  COleClientSite         -- ctor
//              QueryInterface         -- gimme an interface!
//              AddRef                 -- bump up refcount
//              Release                -- bump down refcount
//              SaveObject             -- returns E_FAIL
//              GetMoniker             -- E_NOTIMPL
//              GetContainer           -- returns our COleContainer impl
//              ShowObject             -- just say OK
//              OnShowWindow           -- just say OK
//              RequestNewObjectLayout -- E_NOTIMPL
//
//  Notes:      probably the most important thing our IOleClientSite
//              implementation does is hand off our IOleContainer
//              implementation when GetContainer() is called.
//
//----------------------------------------------------------------------------
COleClientSite::COleClientSite(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP
COleClientSite::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
COleClientSite::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
COleClientSite::Release(VOID)
{
    return m_pCtr->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::SaveObject
//
//  Synopsis:   not implemented - makes no sense in this scenario.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::SaveObject(VOID)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::GetMoniker
//
//  Synopsis:   Not yet implemented; never will be implemented.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, LPMONIKER FAR * ppmk)
{
    *ppmk = 0;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::GetContainer
//
//  Synopsis:   returns our implementation of IOleContainer.  For some
//              reason, unless we do this, frames don't work.  Note that
//              our IOleContainer implementation is stubbed out with
//              E_NOTIMPL (it seems kind of odd to implement this for
//              a container with one embedding).  But it turns out the
//              FS OC has a bug in it's error handling - it
//              QIs for IOleContainer, then QIs from that for
//              IQueryService.  In truth, we'll hand out our implementation
//              of IQueryService, from any interface - we're easy :).
//              We *want* to provide every service the OC asks for.
//              Anyway, when it can't get IOleContainer, the OC's failure
//              path seems to be constructed in such a way that frames
//              don't work thereafter.
//
//  Arguments:  [ppCtr] -- returned IOleContainer
//
//  Returns:    S_OK.  Never fails.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::GetContainer(LPOLECONTAINER FAR * ppCtr)
{
    *ppCtr = &m_pCtr->m_OCtr;
    (*ppCtr)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::ShowObject
//
//  Synopsis:   IOleClientSite::ShowObject implementation.  To quote the docs:
//              "Tells the container to position the object so it is visible
//              to the user. This method ensures that the container itself
//              is visible and not minimized."
//
//              In short, we ignore it.  We're not going to un-minimize
//              the container on the embeddings' whim :).
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::ShowObject(VOID)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::OnShowWindow
//
//  Synopsis:   fine with us, return S_OK.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::OnShowWindow(BOOL bShow)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::RequestNewObjectLayout
//
//  Synopsis:   not being called by WebBrower OC, so do not implement.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::RequestNewObjectLayout(VOID)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::CInPlaceFrame
//
//  Synopsis:   inits m_pCtr - pointer to MSNOCCtr
//
//----------------------------------------------------------------------------
CInPlaceFrame::CInPlaceFrame(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP
CInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CInPlaceFrame::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CInPlaceFrame::Release(VOID)
{
    return m_pCtr->Release();
}

// IOleWindow stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::GetWindow
//
//  Synopsis:   returns frame window
//
//  Arguments:  [phwnd] -- place to return window
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::GetWindow(HWND * phwnd)
{
    MYDBGASSERT(phwnd);

    // this can never fail if we've gotten this far.
    *phwnd = m_pCtr->GetFrameWindow();
    MYDBGASSERT(*phwnd);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::ContextSensitiveHelp
//
//  Synopsis:   This is not implemented by design - this is for
//              the SHift+F1 context sensitive help mode and Esc
//              to exit.  Esc is already being used in the main
//              accelerator table to mean 'stop browsing' to be
//              like IE3.  We do not do help this way.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// IOleInPlaceUIWindow stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::GetBorder
//
//  Synopsis:   IOleInPlaceFrame::GetBorder() - let's us restrict where
//              the server can put tools.  We don't care, they can put
//              them anywhere.
//
//  Arguments:  [lprectBorder] -- return border info in here.
//
//  Returns:    S_OK always with entire frame client rect -
//              we place no restrictions.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::GetBorder(LPRECT lprectBorder)
{
    // we have no restrictions about where the server can put tools.
    ::GetClientRect(m_pCtr->GetFrameWindow(), lprectBorder);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::RequestBorderSpace
//
//  Synopsis:   IOleInPlaceFrame::RequestBorderSpace()
//              inplace object actually requests border space - if
//              we can satisfy the request, we return S_OK, otherwise
//              INPLACE_E_NOTOOLSPACE.  It doesn't actually use the
//              borderspace until it calls
//              IOleInPlaceFrame::SetBorderSpace().  This is used for
//              negotiation.
//
//  Arguments:  [pborderwidths] -- structure (actually a RECT) that is
//                                 interpreted differently from a RECT.
//                                 The left.top.bottom.right members
//                                 represent space on each of our four
//                                 borders the server would like to use.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    RECT rc;
    RECT rcBorder;

    if (!pborderwidths)
        return S_OK;   // they're telling us no toolspace necessary.

    rcBorder = *pborderwidths;

    if (S_OK != GetBorder(&rc))
        return INPLACE_E_NOTOOLSPACE;

    if (rcBorder.left + rcBorder.right > WIDTH(rc) ||
        rcBorder.top + rcBorder.bottom > HEIGHT(rc))
        return INPLACE_E_NOTOOLSPACE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetBorderSpace
//
//  Synopsis:   Sets border space for tools - for some reason, the
//              FS OC always calls this with a pborderwidths
//              consisting of four zeros - it never actually uses any
//              border space (sigh).  Well, the code is here for this
//              to work.  We do a SetSize() to relayout stuff when
//              it does this.
//
//  Arguments:  [pborderwidths] --  space the OC wants to use.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    RECT rc;

    if (!pborderwidths)
    {
        ::memset(&m_pCtr->m_rcToolSpace, 0, sizeof m_pCtr->m_rcToolSpace);
        return S_OK;
    }

    if (S_OK != RequestBorderSpace(pborderwidths))
        return OLE_E_INVALIDRECT;

    // we get the entire client space to pass to setSize().
    ::GetClientRect(m_pCtr->GetFrameWindow(), &rc);
     m_pCtr->m_rcToolSpace = *pborderwidths;

    return m_pCtr->SetSize(&rc, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetActiveObject
//
//  Synopsis:   IOleInPlaceFrame::SetActiveObject().  The server calls
//              this normally whenever it transitions to the UIActive
//              state.  There can only be one UIActive object at a time.
//              This UIACtive object is represented by its
//              IOleInPlaceActiveObject implementation.  We call this
//              object's implementation of TranslateAccelerator() right
//              in the main message loop to give the current embedding
//              first shot at keyboard messages.
//
//              Normally, this is only called when the container transitions
//              an object to UIActive by calling
//              IOleObject::DoVerb(OLEIVERB_UIACTIVE) for the object,
//              transitioning all the other objects (we don't have any :))
//              to OS_INPLACE (if they're OLEMISC_ACTIVATEWHENVISIBLE is set)
//              or even just OS_RUNNING.
//
//  Effects:    sets a new active object in m_pActiveObj.  Releases the
//              old one, if any.
//
//  Arguments:  [pActiveObject] -- new active object
//              [pszObjName]    -- name of object - we don't use this.
//
//  Returns:    S_OK always.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetActiveObject(
        IOleInPlaceActiveObject * pActiveObject,
        LPCOLESTR                 pszObjName)
{
    // reset the toolspace rect in case the last inplacactive object
    // forgot to.
    m_pCtr->_ResetToolSpace();

    // if it was already set, save it so we can release
    // it.  We don't want to release it before we addref
    // the new one in case they're the same thing.
    LPOLEINPLACEACTIVEOBJECT pOld = m_pCtr->m_pActiveObj;

    m_pCtr->m_pActiveObj = pActiveObject;
    if (pActiveObject)
    {
        MYDBGASSERT(OS_UIACTIVE == m_pCtr->GetState());
        m_pCtr->m_pActiveObj->AddRef();
    }

    if (pOld)
        pOld->Release();

    return S_OK;
}

// IOleInPlaceFrame stuff
//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::InsertMenus
//
//  Synopsis:   OC calling us when it wants to do menu negotiation
//              It calls us with a blank hmenu that we're supposed to
//              add items to and fille out the OLEMENUGROUPWIDTHS
//              structure to let it know what we did.
//              We're not adding items to it currently.
//
//  Arguments:  [hmenuShared] -- menu to append to
//              [pMGW]        -- OLEMENUGROUPWIDTHS struct to fill out.
//
//  Returns:    S_OK
//
//
//  Note:       OC doesn't call this.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pMGW)
{
    // we're not inserting anything of our own to this menu.
    pMGW->width[0] = 0;  // 'File' menu
    pMGW->width[2] = 0;  // 'View' menu
    pMGW->width[4] = 0;  // 'Window' menu
    pMGW->width[5] = 0;  // 'Help' menu

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetMenu
//
//  Synopsis:   This is the OC calling the container asking us to
//              set the shared menu in its frame.  We're supposed to
//              use the HOLEMENU object passed in and the
//              hWndActiveObject to call OleSetMenuDescriptor() so
//              that OLE can do message filtering and route WM_COMMAND
//              messages.
//
//
//  Arguments:  [hmenuShared]      --  shared menu.
//              [holemenu]         --  ole menu descriptor thingy
//              [hwndActiveObject] --  hwnd of server who's merging menus
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    // we're not doing any menu negotiation
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::RemoveMenus
//
//  Synopsis:   IOleInPlaceFrame::RemoveMenus(), this is where the
//              server gives us a chance to remove all our items from
//              the hMenu.  We're not adding any, so we don't remove any.
//
//  Arguments:  [hmenuShared] -- menu to clean up.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::RemoveMenus(HMENU hmenuShared)
{
    // we aren't adding anything to this thing anyway.
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetStatusText
//
//  Synopsis:   called by the FS OC to put text in our status
//              text area.
//
//  Returns:    HRESULT
//
//  Arguments:  [pszStatusText] -- text to display
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    return m_pCtr->_DisplayStatusText(pszStatusText);
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_DisplayStatusText
//
//  Synopsis:   helper that displays status text.
//
//  Arguments:  [pszStatusText] -- text to display
//
//
//  Returns:    S_OK or HRESULT_FROM_WIN32(::GetLastError());
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::_DisplayStatusText(LPCOLESTR pszStatusText)
{
    CHAR ach[MAX_STATUS_TEXT];

    if (::WideCharToMultiByte(
            CP_ACP,
            0,
            pszStatusText,
            -1,
            ach,
            NElems(ach),
            0,
            0))
    {
        // put the status text somewhere.
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_WIN32(::GetLastError());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::EnableModeless
//
//  Synopsis:   this is called by the embedding to let us know it's
//              putting up a modal dialog box - we should 'grey' out
//              any of our modeless dialogs.  It delegates to
//              CICMOCCtr::EnableModeless()
//
//  Arguments:  [fEnable] -- enable or disable.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::EnableModeless(BOOL fEnable)
{
    return m_pCtr->EnableModeless(fEnable);
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::EnableModeless
//
//  Synopsis:   delegated to from CInPlaceFrame::EnableModeless().
//              always returns S_OK - we don't have any modeless
//              dialogs (yet).
//
//  Arguments:  [fEnable] -- enable or disable.
//
//  Returns:    S_OK
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::EnableModeless(BOOL fEnable)
{
    m_fModelessEnabled = fEnable;  // in case anyone wants to know.
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::TranslateAccelerator
//
//  Synopsis:   The current active object's
//              IOleInPlaceActiveObject::TranslateAccelerator() is being
//              called at the top of our main message loop.  If it
//              does *not* want to handle a message, it will call
//              this method of ours to pass the keyboard message back to
//              us.  We call ::TranslateAccelerator on the global main
//              haccel, and, if it's handled (by returning TRUE - 1),
//              we indicate it's handled by returning S_OK (0 :).
//              On the other hand, if it's *not* handled, we return
//              S_FALSE.
//
//  Arguments:  [lpmsg] -- keyboard msg to handle
//              [wID]   -- command identifier value - per spec.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // note this should never be called - only local servers
    // (out of process) should call this by using
    // OleTranslateAccelerator().
    return m_pCtr->_TransAccelerator(lpmsg, wID);
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_TransAccelerator
//
//  Synopsis:   handle accelerator messages coming from
//              either IOleInplaceFrame::TranslateAccelerator, or
//              IOleControlSite::TranslateAccelerator.
//
//  Effects:    forwards them to the main accelerator table.
//
//  Arguments:  [lpmsg] -- keyboard msg.
//              [wID]   -- per spec.
//
//  Returns:    S_OK if we handled it, S_FALSE otherwise.
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::_TransAccelerator(LPMSG lpmsg, WORD wID)
{
    // the docs suggest that this method might need to return E_INVALIDARG.
    // anyway, this is defensive.  If the FS OC
    // calls us with an 0 ptr, we just return error
    if (!lpmsg)
        return E_INVALIDARG;

    // forward the keystroke to the main accelerator table, if you have one.
    // if you handle it, say S_OK.

#if 0
    // this sample has no main accelerator table.
    if (::TranslateAccelerator(GetMainWindow(),GetMainAccel(), lpmsg))
    {
        return S_OK;      // we handled it
    }
    else
#endif
    {
        return S_FALSE;   // we didn't.
    }
}

//+---------------------------------------------------------------------------
//
//  Class:      CInPlaceSite ()
//
//  Purpose:    IOleInPlaceSite implementation.
//
//  Interface:  CInPlaceSite         -- ctor
//              QueryInterface       -- get a new interface
//              AddRef               -- bump ref count
//              Release              -- decrement ref count
//              GetWindow            -- returns frame window
//              ContextSensitiveHelp -- not implemented by design
//              CanInPlaceActivate   -- returns S_OK.
//              OnInPlaceActivate    -- caches IOleInPlaceObject ptr
//              OnUIActivate         -- returns S_OK  - sets state
//              GetWindowContext     -- returns IOleInPlaceFrame,
//                                              IOleInPlaceUIWindow,
//                                              PosRect and ClipRect
//              Scroll               -- not implemented ever
//              OnUIDeactivate       -- kills objmenu
//              OnInPlaceDeactivate  -- releases cached IOleInPlaceObject
//              DiscardUndoState     -- returns S_OK
//              DeactivateAndUndo    -- deactivates in place active object
//              OnPosRectChange      -- never implemented.
//
//----------------------------------------------------------------------------
CInPlaceSite::CInPlaceSite(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP
CInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CInPlaceSite::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CInPlaceSite::Release(VOID)
{
    return m_pCtr->Release();
}

CPropertyBag::CPropertyBag(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{

}

CPropertyBag::~CPropertyBag(VOID)
{
    for (INT i = 0; i < m_aryBagProps.Size(); i++)
    {
        m_pCtr->m_DOA.DynSysFreeString(m_aryBagProps[i].bstrName);
        m_pCtr->m_DOA.DynVariantClear(&m_aryBagProps[i].varValue);
    }
}

STDMETHODIMP
CPropertyBag::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CPropertyBag::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CPropertyBag::Release(VOID)
{
    return m_pCtr->Release();
}


static LONG
LongFromValue(LPTSTR sz)
{
    if (CmIsDigit(sz))
        return CmAtol(sz);

    return -1;
}


HRESULT
CPropertyBag::AddPropertyToBag(LPTSTR szName, LPTSTR szValue)
{
    BagProp bp;
    HRESULT hr;
    LONG    lValue;
    LPWSTR  pawch;
    //WCHAR   awch[INTERNET_MAX_URL_LENGTH] = {0};

    // initialize so error cleanup can work properly.
    bp.bstrName = 0;
    
    m_pCtr->m_DOA.DynVariantInit(&bp.varValue);

    if (!(pawch = (LPWSTR)CmMalloc(INTERNET_MAX_URL_LENGTH*sizeof(WCHAR))))
    {
        goto MemoryError;
    }

    //if (-1 == ::mbstowcs(awch, szName, NElems(awch)))
#ifndef UNICODE
    if (!MultiByteToWideChar(CP_ACP, 0, szName, -1, pawch, INTERNET_MAX_URL_LENGTH)) // NElems(awch)))
    {
        hr = E_FAIL;
        goto Error;
    }
#else
    lstrcpyU(pawch, szName);
#endif

    bp.bstrName = m_pCtr->m_DOA.DynSysAllocString(pawch);

    if (!bp.bstrName)
        goto MemoryError;

    // see if it's a VT_I4.
    lValue = ::LongFromValue(szValue);

    // it's a VT_BSTR - probably most common case
    if (-1 == lValue)
    {
        //if (-1 == ::mbstowcs(awch, szValue, NElems(awch)))
#ifndef UNICODE
        if (!MultiByteToWideChar(CP_ACP, 0, szValue, -1, pawch, INTERNET_MAX_URL_LENGTH)) // NElems(awch)))
        {
            hr = E_FAIL;
            goto Error;
        }
#else
        lstrcpyU(pawch, szValue);
#endif

        V_VT(&bp.varValue) = VT_BSTR;
        
        V_BSTR(&bp.varValue) = m_pCtr->m_DOA.DynSysAllocString(pawch);
        
        if (!V_BSTR(&bp.varValue))
            goto MemoryError;
    }
    else  // it's a VT_I4
    {
        V_VT(&bp.varValue) = VT_I4;
        V_I4(&bp.varValue) = lValue;
    }

    hr = m_aryBagProps.AppendIndirect(&bp);
    if (S_OK != hr)
        goto Error;

Cleanup:
    if (pawch)
    {
        CmFree(pawch);
    }
    return hr;

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (bp.bstrName)
            m_pCtr->m_DOA.DynSysFreeString(bp.bstrName);

    if (pawch)
    {
        CmFree(pawch);
    }

    m_pCtr->m_DOA.DynVariantClear(&bp.varValue);

    goto Cleanup;
}



STDMETHODIMP
CPropertyBag::Read(LPCOLESTR pszName, LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    for (INT i = 0; i < m_aryBagProps.Size(); i++)
    {
        if (!::lstrcmpiU(m_aryBagProps[i].bstrName, pszName))
        {
            if (V_VT(pVar) == V_VT(&m_aryBagProps[i].varValue))
            {
                return m_pCtr->m_DOA.DynVariantCopy(pVar, &m_aryBagProps[i].varValue);
            }
            else
            {
                return m_pCtr->m_DOA.DynVariantChangeType(
                              pVar,
                              &m_aryBagProps[i].varValue,
                              0,
                              V_VT(pVar));
            }
        }
    }
    return E_INVALIDARG;  // we don't have the property.
}


// IOleWindow stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::GetWindow
//
//  Synopsis:   returns frame window.
//
//  Arguments:  [phwnd] -- return window *here*
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::GetWindow(HWND * phwnd)
{
    // just reuse the CInPlaceFrame impl
    return m_pCtr->m_IPF.GetWindow(phwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::ContextSensitiveHelp
//
//  Synopsis:   This is not implemented by design - this is for
//              the SHift+F1 context sensitive help mode and Esc
//              to exit.  Esc is already being used in the main
//              accelerator table to mean 'stop browsing' to be
//              like IE3.  We do not do help this way.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// IOleInPlaceSite stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::CanInPlaceActivate
//
//  Synopsis:   just say yes.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::CanInPlaceActivate(VOID)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnInPlaceActivate
//
//  Synopsis:   caches the IOleInPlaceObject pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnInPlaceActivate(VOID)
{
    HRESULT hr = m_pCtr->m_pOO->QueryInterface(
                         IID_IOleInPlaceObject,
                         (LPVOID *) &m_pCtr->m_pIPO);

    if (S_OK == hr)
        m_pCtr->SetState(OS_INPLACE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnUIActivate
//
//  Synopsis:   just sets state bit
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnUIActivate(VOID)
{
    m_pCtr->SetState(OS_UIACTIVE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::GetWindowContext
//
//  Synopsis:   returns a bunch of interfaces and positioning interface
//              the inplace-active object needs to do its thang.
//
//  Arguments:  [ppFrame]     -- return our IOleInPlaceFrame implementation
//              [ppDoc]       -- return our IOleInPlaceUIWindow impl.
//              [prcPosRect]  -- position info
//              [prcClipRect] -- clip info - same as pos info for this case
//              [pFrameInfo]  -- return 0 - inproc object doesn't use this.
//
//  Notes:      note that ppFrame and ppDoc are really just the same
//              object because we're an SDI app.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::GetWindowContext(
       IOleInPlaceFrame    **ppFrame,
       IOleInPlaceUIWindow **ppDoc,
       LPRECT                prcPosRect,
       LPRECT                prcClipRect,
       LPOLEINPLACEFRAMEINFO pFrameInfo)
{
    // get the frame
    HRESULT hr = m_pCtr->QueryInterface(
                            IID_IOleInPlaceFrame,
                            (LPVOID *)ppFrame);

    MYDBGASSERT(S_OK == hr);

    // return the frame again :) - this is all per-spec.
    hr = m_pCtr->QueryInterface(
                        IID_IOleInPlaceUIWindow,
                        (LPVOID *) ppDoc);

    MYDBGASSERT(S_OK == hr);

    // get the clip and pos rect - same for this application.
    HWND hWnd = m_pCtr->GetMainWindow();
    MYDBGASSERT(hWnd);
    HWND hWndFrame = m_pCtr->GetFrameWindow();
      
    ::GetClientRect(hWndFrame, prcPosRect);
        
    //
    // NTRAID - #148143
    // Apparently the W9x implementation is different, so MapWindowPoints for
    // the clipping and position rect only on 9X. Also, make sure that the 
    // origin is NULL to keep post 2.0 versions of future splash happy on 9X.
    //

    if (OS_W9X)
    {
        ::MapWindowPoints(hWndFrame, hWnd, (LPPOINT)prcPosRect, 2);     
        prcPosRect->top = 0;
        prcPosRect->left = 0;
    }
    
    *prcClipRect = *prcPosRect;

    //
    // OLYMPUS - #156880 
    // Clipping handled differently by future splash versions > 2.0
    // so don't re-map the rect points, just use the client rect so we 
    // work with all splash versions - nickball
    //  

    //::MapWindowPoints(hWndFrame, hWnd, (LPPOINT)prcClipRect, 2); 
        
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::Scroll
//
//  Synopsis:   never implement this for FS OC.  This has
//              nothing to do with the scrollbars you see on the HTML.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnUIDeactivate
//
//  Synopsis:   set state bits
//
//  Arguments:  [fUndoable] -- not used
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnUIDeactivate(BOOL fUndoable)
{
    m_pCtr->SetState(OS_INPLACE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnInPlaceDeactivate
//
//  Synopsis:   releases the IOleInPlaceObject pointer we were
//              caching for the object, and sets state to OS_RUNNING.
//              Also fires the OLEIVERB_DISCARDUNDOSTATE at the control
//              to tell it to release any undo state it's holding onto.
//              I very much doubt the FS OC has any undo state,
//              but, this is the protocol.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnInPlaceDeactivate(VOID)
{
    RECT rc;

    if (m_pCtr->m_pIPO)
    {
        m_pCtr->m_pIPO->Release();
        m_pCtr->SetState(OS_RUNNING);
        m_pCtr->m_pIPO = 0;
    }

    if (m_pCtr->m_pOO)
    {
        m_pCtr->_GetDoVerbRect(&rc); // get rect for firing verbs.
        m_pCtr->m_pOO->DoVerb(
            OLEIVERB_DISCARDUNDOSTATE,
            0,
            &m_pCtr->m_CS,
            0,
            m_pCtr->GetFrameWindow(),
            0);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_GetDoVerbRect
//
//  Synopsis:   whenever firing DoVerb(), we need a rect for the object
//              that describes the area for the object in parent client coords.
//
//  Arguments:  [prc] -- rect returned.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::_GetDoVerbRect(LPRECT prc)
{
    ::GetClientRect(GetFrameWindow(), prc);
    ::MapWindowPoints(GetFrameWindow(), GetMainWindow(), (LPPOINT)prc, 2);
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::DiscardUndoState
//
//  Synopsis:   just say OK - we don't hold any undo state for
//              object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::DiscardUndoState(VOID)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::DeactivateAndUndo
//
//  Synopsis:   absolutely minimum implementation of deactivateandundo.
//              just calls IOleInPlaceObject::InPlaceDeactivate().
//
//  Returns:    S_OK always.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::DeactivateAndUndo(VOID)
{
    if (m_pCtr->m_pIPO)
        m_pCtr->m_pIPO->InPlaceDeactivate();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnPosRectChange
//
//  Synopsis:   never implement this.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnPosRectChange(LPCRECT lprcPosRect)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Class:      COleContainer ()
//
//  Purpose:    our implementation of IOleContainer.  does nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleContainer::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
COleContainer::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
COleContainer::Release(VOID)
{
    return m_pCtr->Release();
}

COleContainer::COleContainer(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{

}

STDMETHODIMP
COleContainer::EnumObjects(DWORD grfFlags, IEnumUnknown **ppenum)
{
    MYDBGASSERT(FALSE);   // never called
    return E_NOTIMPL;
}

STDMETHODIMP
COleContainer::LockContainer(BOOL fLock)
{
    MYDBGASSERT(FALSE);  // never called
    return S_OK;
}

STDMETHODIMP
COleContainer::ParseDisplayName(
                  IBindCtx *pbc,
                  LPOLESTR pszDisplayName,
                  ULONG *pchEaten,
                  IMoniker **ppmkOut)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\compchck.cpp ===
//+----------------------------------------------------------------------------
//
// File:     CompChck.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains win32 only conponents checking and installing
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   Fengsun Created    10/21/97
//
//+----------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
//
//  All the functions in this file are WIN32 implementation only
//

#include "cmmaster.h"
#include "CompChck.h"
#include "cmexitwin.cpp"
#include "winuserp.h"

//
// CSDVersion key contains the service pack that has been installed 
//

const TCHAR* const c_pszRegRas                  = TEXT("SOFTWARE\\Microsoft\\RAS");
const TCHAR* const c_pszCheckComponentsMutex    = TEXT("Connection Manager Components Checking");
const TCHAR* const c_pszRegComponentsChecked    = TEXT("ComponentsChecked");

const CHAR* const c_pszSetupPPTPCommand         = "rundll.exe rnasetup.dll,InstallOptionalComponent VPN";   // not using TEXT macro, this is W98+ only

//
// Functions internal to this file
//

static HRESULT CheckComponents(HWND hWndParent, LPCTSTR pszServiceName, DWORD dwComponentsToCheck, OUT DWORD& dwComponentsMissed, 
                      BOOL fIgnoreRegKey, BOOL fUnattended );
static BOOL  InstallComponents(DWORD dwComponentsToInstall, HWND hWndParent, LPCTSTR pszServiceName);
static BOOL MarkComponentsChecked(DWORD dwComponentsChecked);
static BOOL ReadComponentsChecked(LPDWORD pdwComponentsChecked);
static BOOL IsPPTPInstalled(void);
static BOOL InstallPPTP(void);
static BOOL IsScriptingInstalled(void);
static HRESULT ConfigSystem(HWND hwndParent, 
                     DWORD dwfOptions, 
                     LPBOOL pbReboot);
static HRESULT InetNeedSystemComponents(DWORD dwfOptions,
                                 LPBOOL pbNeedSysComponents);
static HRESULT InetNeedModem(LPBOOL pbNeedModem);
static void DisplayMessageToInstallServicePack(HWND hWndParent, LPCTSTR pszServiceName);
static inline HINSTANCE LoadInetCfg(void) 
{   
    return (LoadLibraryExA("cnetcfg.dll", NULL, 0));
}


//+----------------------------------------------------------------------------
//
//  Function    IsPPTPInstalled
//
//  Synopsis    Check to see if PPTP is already installed
//
//  Arguments   None
//
//  Returns     TRUE - PPTP has been installed
//              FALSE - otherwise
//
//  History     3/25/97     VetriV      Created
//
//-----------------------------------------------------------------------------
BOOL IsPPTPInstalled(void)
{
    BOOL bReturnCode = FALSE;


    HKEY hKey = NULL;
    DWORD dwSize = 0, dwType = 0;
    LONG lrc = 0;
    TCHAR szData[MAX_PATH+1];

    
    if (OS_NT)
    {
        if (GetOSMajorVersion() >= 5)
        {
            //
            // PPTP is always installed on NT5
            //
            bReturnCode = TRUE;
        }
        else
        {
            if (RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\RASPPTP"),
                            0,
                            KEY_READ,
                            &hKey) == 0)
            {
                RegCloseKey(hKey);
                bReturnCode = TRUE;
            }
        }
    }
    else
    {
        hKey = NULL;
        lrc = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\VPN"),
                           0,
                           KEY_READ,
                           &hKey);

        if (ERROR_SUCCESS == lrc)
        {
            dwSize = MAX_PATH;
            lrc = RegQueryValueExU(hKey, TEXT("Installed"), 0, 
                                    &dwType, (LPBYTE)szData, &dwSize);

            if (ERROR_SUCCESS == lrc)
            {
                if (0 == lstrcmpiU(szData, TEXT("1")))
                {                                                         
                    //
                    // On 9X, we need to check for Dial-Up Adapter #2. If its 
                    // not present then tunneling won't work unless we install
                    // PPTP to install the Adapter #2.
                    //

                    //
                    //  On early versions of Win9x Dial-up Adapter was localized, but on WinME, WinSE, 
                    //  or machines that have DUN 1.3 installed it isn't.  Thus, lets try the unlocalized
                    //  first and then if that fails we can try the localized version.
                    //
                    const TCHAR * const c_pszDialupAdapter = TEXT("Dial-up Adapter");
                    LPTSTR pszAdapter = NULL;

                    LPTSTR pszKey = CmStrCpyAlloc(TEXT("System\\CurrentControlSet\\Control\\PerfStats\\Enum\\"));
                    CmStrCatAlloc(&pszKey, c_pszDialupAdapter);
                    CmStrCatAlloc(&pszKey, TEXT(" #2"));

                    //
                    // Close the key that we opened above, and try the one for the adapter
                    //

                    RegCloseKey(hKey);
                    hKey = NULL;

                    if (ERROR_SUCCESS == RegOpenKeyExU(HKEY_LOCAL_MACHINE, 
                                                      pszKey, 
                                                      0, 
                                                      KEY_QUERY_VALUE, 
                                                      &hKey))
                    {
                        bReturnCode = TRUE;
                    }
                    else
                    {

                        CmFree (pszKey);
                        pszAdapter = CmLoadString(g_hInst, IDS_REG_DIALUP_ADAPTER);

                        pszKey = CmStrCpyAlloc(TEXT("System\\CurrentControlSet\\Control\\PerfStats\\Enum\\"));
                        CmStrCatAlloc(&pszKey, pszAdapter);
                        CmStrCatAlloc(&pszKey, TEXT(" #2"));
                   
                        //
                        // Close the key that we opened above, and try the one for the adapter
                        //

                        RegCloseKey(hKey);
                        hKey = NULL;

                        if (ERROR_SUCCESS == RegOpenKeyExU(HKEY_LOCAL_MACHINE, 
                                                          pszKey, 
                                                          0, 
                                                          KEY_QUERY_VALUE, 
                                                          &hKey))
                        {
                            bReturnCode = TRUE;
                        }
                    }

                    CmFree(pszKey);
                    CmFree(pszAdapter);                    
                }
            }
        }
            
        if (hKey)
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

    return bReturnCode;
}


//+----------------------------------------------------------------------------
//
//  Function    InstallPPTP
//
//  Synopsis    Install PPTP on Windows 95 and NT
//
//  Arguments   None
//
//  Returns     TRUE  --  if was successfully installed
//              FALSE --  Otherwise
//
//  History     3/25/97     VetriV      Created
//              7/8/97      VetriV      Added code to setup PPTP on Memphis
//
//-----------------------------------------------------------------------------
BOOL InstallPPTP(void)
{
    BOOL bReturnCode = FALSE;
    MSG                 msg ;
    
    if (OS_NT || OS_W95)
    {
        //
        // Don't know how to install/configure PPTP on NT. 
        // We let the admin wrestle with MSDUNXX on W95
        //

        return FALSE;
    }
    else
    {
        CHAR                szCommand[128];
        STARTUPINFOA        si;
        PROCESS_INFORMATION pi;
    
        ZeroMemory(&pi, sizeof(pi));
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(STARTUPINFOA);
        
        //
        // NOTE: The original version called "msdun12.exe /q /R:N" to install tunneling
        // on Windows 95. Now we use 98 approach only and call the following:
        // "rundll.exe rnasetup.dll,InstallOptionalComponent VPN".
        //

        MYDBGASSERT(1353 < LOWORD(GetOSBuildNumber()));
        MYDBGASSERT(OS_W98);    // based on the if clause above. The following code (A calls instead of W or U) also depends on this

        CHAR szRundllLocation[MAX_PATH + 11 + 1];  // 11 = length of "\\rundll.exe"
        (void) GetWindowsDirectoryA(szRundllLocation, MAX_PATH);
        lstrcatA(szRundllLocation, "\\rundll.exe");

        lstrcpyA(szCommand, c_pszSetupPPTPCommand);

        if (NULL == CreateProcessA(szRundllLocation, szCommand, 
                                   NULL, NULL, FALSE, 0, 
                                   NULL, NULL, &si, &pi))
        {
            CMTRACE1(TEXT("InstallPPTP() CreateProcess() failed, GLE=%u."), GetLastError());
        }
        else
        {
            CMTRACE(TEXT("InstallPPTP() Launched PPTP Install. Waiting for exit."));
            
            //
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            //
            while((MsgWaitForMultipleObjects(1, &pi.hProcess, 
                                                FALSE, INFINITE, 
                                                QS_ALLINPUT) == (WAIT_OBJECT_0 + 1)))
            {
                //
                // read all of the messages in this next loop
                // removing each message as we read it
                //
                while (PeekMessageU(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    CMTRACE(TEXT("InstallPPTP() Got Message"));
                    
                    //
                    // how to handle quit message?
                    //
                    DispatchMessageU(&msg);
                    if (msg.message == WM_QUIT)
                    {
                        CMTRACE(TEXT("InstallPPTP() Got Quit Message"));
                        goto done;
                    }
                }
            }
done:
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            //
            // PPTP was successfully installed
            //
            bReturnCode = TRUE;
            CMTRACE(TEXT("InstallPPTP() done"));
        }
    }

    return bReturnCode;
}


//+----------------------------------------------------------------------------
//
//  Function    IsMSDUN12Installed
//
//  Synopsis    Check if MSDUN 1.2 or higher is installed.
//
//  Arguments   none
//
//  Returns     TRUE - MSDUN 1.2 is installed
//
//  History     8/12/97     nickball    from ICW for 11900
//
//-----------------------------------------------------------------------------
#define DUN_12_Version "1.2"

BOOL IsMSDUN12Installed()
{
    CHAR szBuffer[MAX_PATH] = {"\0"};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);

    //
    // Try to open the Version key
    //

    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                       "System\\CurrentControlSet\\Services\\RemoteAccess",
                                       0,
                                       KEY_READ,
                                       &hkey))
    {
        return FALSE;
    }

    //
    // The key exists, check the value
    //

    if (ERROR_SUCCESS == RegQueryValueExA(hkey, "Version", NULL, &dwType, 
                                          (LPBYTE)szBuffer, &dwSize))
    {               
        //
        // If the entry starts with "1.2", (eg. "1.2c") its a hit
        //
        
        bRC = (szBuffer == CmStrStrA(szBuffer, DUN_12_Version));
    }

    RegCloseKey(hkey);

    return bRC;
}

//+----------------------------------------------------------------------------
//
//  Function    IsISDN11Installed
//
//  Synopsis    Check if ISDN 1.1 is installed
//
//  Arguments   none
//
//  Returns     TRUE - ISDN 1.1 is installed
//
//  Note:       MSDUN12 superscedes ISDN1.1, but ISDN1.1 does provide scripting
//
//  History     8/12/97     nickball    
//
//-----------------------------------------------------------------------------

BOOL IsISDN11Installed()
{
    CHAR szBuffer[MAX_PATH] = {"\0"};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);

    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\MSISDN",
        0,
        KEY_READ,
        &hkey))
    {
        goto IsISDN11InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueExA(hkey,
        "Installed",
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsISDN11InstalledExit;
    }

    if (0 == lstrcmpA("1", szBuffer))
    {
        bRC = TRUE;
    }

IsISDN11InstalledExit:
    return bRC;
}


//+----------------------------------------------------------------------------
//
//  Function    IsScriptingInstalled
//
//  Synopsis    Check to see if scripting is already installed
//
//  Arguments   None
//
//  Returns     TRUE - scripting has been installed
//
//  History     3/5/97      VetriV      From ICW code
//
//-----------------------------------------------------------------------------
BOOL IsScriptingInstalled(void)
{
    BOOL bReturnCode = FALSE;

    HKEY hkey = NULL;
    DWORD dwSize = 0, dwType = 0;
    LONG lrc = 0;
    HINSTANCE hInst = NULL;
    CHAR szData[MAX_PATH+1];

    
    if (OS_NT)
    {
        //
        // NT comes with Scripting installed
        //
        bReturnCode = TRUE;
    }
    else
    {
        //
        // OSR2 and higher releases of Windows 95 have scripting installed
        //
        if (1111 <= LOWORD(GetOSBuildNumber()))
        {
            bReturnCode = TRUE;
        }
        else
        {
            //
            // Must be Gold 95, check for installed scripting
            //
            
            if (IsMSDUN12Installed() || IsISDN11Installed())
            {
                bReturnCode = TRUE;
            }
            else
            {
                hkey = NULL;
                lrc = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                "System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP",
                                0,
                                KEY_READ,
                                &hkey);

                if (ERROR_SUCCESS == lrc)
                {
                    dwSize = MAX_PATH;
                    lrc = RegQueryValueExA(hkey, "Path", 0, &dwType, (LPBYTE)szData, &dwSize);

                    if (ERROR_SUCCESS == lrc)
                    {
                        if (0 == CmCompareStringA(szData,"smmscrpt.dll"))
                        {
                            bReturnCode = TRUE;
                        }
                    }
                }
                
                if (hkey)
                {
                    RegCloseKey(hkey);
                    hkey = NULL;
                }

                //
                // Verify that the DLL can be loaded
                //
                if (bReturnCode)
                {
                    hInst = LoadLibraryExA("smmscrpt.dll", NULL, 0);
                    
                    if (hInst)
                    {
                        FreeLibrary(hInst);
                    }
                    else
                    {
                        bReturnCode = FALSE;
                    }

                    hInst = NULL;
                }
            }
        }
    }

    return bReturnCode;
}

//+----------------------------------------------------------------------------
//  Function    VerifyRasServicesRunning
//
//  Synopsis    Make sure that the RAS services are enabled and running
//
//  Arguments   hWndDlg:        - Window Handle of parent window
//              pszServiceName  - Service name for titles
//              fUnattended:    - if TRUE, do not do not popup any UI
//
//  Return      FALSE - if the services couldn't be started
//
//  History     2/26/97     VetriV      Copied from ICW code
//-----------------------------------------------------------------------------
BOOL VerifyRasServicesRunning(HWND hWndDlg, LPCTSTR pszServiceName, BOOL fUnattended)
{
    BOOL bReturnCode = FALSE;
    HINSTANCE hInstance = NULL;
    HRESULT (WINAPI *pfn)(void);

    hInstance = LoadInetCfg();
    if (!hInstance) 
    {
        CMTRACE1(TEXT("VerifyRasServicesRunning() LoadLibrary() failed, GLE=%u."), GetLastError());
    }
    else
    {
        pfn = (HRESULT (WINAPI *)(void))GetProcAddress(hInstance, "InetStartServices");

        if (pfn)
        {
            LPTSTR pszDisabledMsg;
            LPTSTR pszExitMsg;

            pszDisabledMsg = CmFmtMsg(g_hInst, IDS_SERVICEDISABLED);
            pszExitMsg = CmFmtMsg(g_hInst, IDS_WANTTOEXIT);
            
            //
            // Check RAS Services
            //
            do 
            {
                HRESULT hr = pfn();
                
                if (ERROR_SUCCESS == hr)
                {
                    bReturnCode = TRUE;
                    break;
                }
                else
                {
                    CMTRACE1(TEXT("VerifyRasServicesRunning() InetStartServices() failed, GLE=%u."), hr);
                }

                //
                // Do not retry if unattended
                //
                if (!fUnattended)
                {
                    bReturnCode = FALSE;
                    break;
                }

                //
                //  Check the error code of OpenService
                //  Do not ask user to retry for certain errors
                //
                if (hr == ERROR_SERVICE_DOES_NOT_EXIST || hr == ERROR_FILE_NOT_FOUND ||
                    hr == ERROR_ACCESS_DENIED)
                {
                    LPTSTR pszNotInstalledMsg = CmFmtMsg(g_hInst, IDS_SERVICENOTINSTALLED);

                    //
                    // Report the error and Exit
                    //
                    MessageBoxEx(hWndDlg, pszNotInstalledMsg, pszServiceName,
                                                MB_OK|MB_ICONSTOP,
                                                LANG_USER_DEFAULT);
                    CmFree(pszNotInstalledMsg);
                    bReturnCode = FALSE;
                    break;
                }

                //
                // Report the error and allow the user to retry
                //
                if (IDYES != MessageBoxEx(hWndDlg,pszDisabledMsg,pszServiceName,
                                            MB_YESNO | MB_DEFBUTTON1 
                                            | MB_ICONWARNING,
                                            LANG_USER_DEFAULT))
                {
                    //
                    // Confirm Exit
                    //
                    if (IDYES == MessageBoxEx(hWndDlg, pszExitMsg, pszServiceName,
                                                MB_APPLMODAL | MB_ICONQUESTION 
                                                | MB_YESNO | MB_DEFBUTTON2,
                                                LANG_USER_DEFAULT))
                    {
                        bReturnCode = FALSE;
                        break;
                    }
                }
            
            } while (1);

            CmFree(pszDisabledMsg);
            CmFree(pszExitMsg);
        }
        else
        {
            CMTRACE1(TEXT("VerifyRasServicesRunning() GetProcAddress() failed, GLE=%u."), GetLastError());
        }

        FreeLibrary(hInstance);
    }

    return bReturnCode;
}

//+----------------------------------------------------------------------------
//  Function    CheckAndInstallComponents
//
//  Synopsis    Make sure the system is setup for dialing
//
//  Arguments   dwComponentsToCheck - Components to be checked
//              hWndParent          - Window Handle of parent window
//              pszServiceName      - Long service name for error titles
//              fIgnoreRegKey:      - Whether ignore ComponetsChecked registry key
//                  Default is  TRUE, check the components even if their bit is set
//                  in registry
//              fUnattended: if TRUE, do not try to install missed components,
//                                    do not popup any UI
//                  Defualt is FALSE, install.
//
//  Return      Other - if system could not be configured
//                      or if the we have to reboot to continue
//              ERROR_SUCCESS  - Check and install successfully
//
//  History     3/13/97     VetriV      
//              6/24/97     byao    Modified. Set pArgs->dwExitCode accordingly
//              11/6/97     fengsun changed parameters, do not pass pArgs
//-----------------------------------------------------------------------------
DWORD CheckAndInstallComponents(DWORD dwComponentsToCheck, HWND hWndParent, LPCTSTR pszServiceName,
                                BOOL fIgnoreRegKey, BOOL fUnattended)
{
    MYDBGASSERT( (dwComponentsToCheck & 
        ~(CC_RNA | CC_TCPIP | CC_MODEM | CC_PPTP | CC_SCRIPTING | CC_RASRUNNING | CC_CHECK_BINDINGS) ) == 0 );

    if (dwComponentsToCheck == 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // Open the mutex, so only one CM instance can call this function.
    // The destructor of CNamedMutex will release the mutex
    //

    CNamedMutex theMutex;
    if (!theMutex.Lock(c_pszCheckComponentsMutex))
    {
        //
        // Another instance of cm is checking components. Return here
        //

        if (!fUnattended)
        {
            LPTSTR pszMsg = CmLoadString(g_hInst, IDMSG_COMPONENTS_CHECKING_INPROCESS);
            MessageBoxEx(hWndParent, pszMsg, pszServiceName, MB_OK | MB_ICONERROR, LANG_USER_DEFAULT);
            CmFree(pszMsg);
        }

        return  ERROR_CANCELLED;
    }

    //
    // Find components missed
    //
    DWORD dwComponentsMissed = 0;
    DWORD dwRet = CheckComponents(hWndParent, pszServiceName, dwComponentsToCheck, dwComponentsMissed, 
                                fIgnoreRegKey, fUnattended);

    if (dwRet == ERROR_SUCCESS)
    {
        MYDBGASSERT(dwComponentsMissed == 0);
        return ERROR_SUCCESS;
    }

    if (dwRet == E_ACCESSDENIED && OS_NT5)
    {
        //
        // On NT5, non-admin user does not have access to check components
        // Continue.
        //
        return ERROR_SUCCESS;
    }

    if (fUnattended)
    {
        //
        // Do not try to install if fUnattended is TRUE
        //
        return dwRet;
    }

    if (dwComponentsMissed & ~CC_RASRUNNING)
    {
        //
        // Prompt user before configuring system
        // If modem is not installed, expilitly say that
        //

        LPTSTR pszMsg;

        if (dwComponentsMissed == CC_MODEM)
        {
            //
            // On NT4, if RAS is installed and modem is not installed or
            // not configured for dialout, then we cannot programmatically 
            // install and configure modem for the user (limitation of NT RAS 
            // install/configuration). So, we will display a message to user
            // to manually go and install and/or configure modem from NCPA
            //
            if (OS_NT4)
            {
                pszMsg = CmFmtMsg(g_hInst, IDMSG_INSTALLMODEM_MANUALLY_MSG);
                MessageBoxEx(hWndParent, pszMsg, pszServiceName,
                                            MB_OK | MB_ICONERROR,
                                            LANG_USER_DEFAULT);
                
                CmFree(pszMsg);
                return  ERROR_CANCELLED;
            }
            else
            {
                pszMsg = CmFmtMsg(g_hInst, IDMSG_NOMODEM_MSG);
            }
        }
        else
        {
            pszMsg = CmFmtMsg(g_hInst, IDMSG_NORAS_MSG);
        }

        int iRes = MessageBoxEx(hWndParent, pszMsg, pszServiceName,
                                    MB_YESNO | MB_DEFBUTTON1 | MB_ICONWARNING,
                                    LANG_USER_DEFAULT);
        CmFree(pszMsg);

        if (IDYES != iRes)      
        {
            return ERROR_CANCELLED;
        }

        if (!InstallComponents(dwComponentsMissed, hWndParent, pszServiceName))
        {
            //
            // Some time, GetLastError returns ERROR_SUCCESS
            //
            return (GetLastError() == ERROR_SUCCESS ? ERROR_CANCELLED : GetLastError());
        }
    }

    //
    // We can not do anything if RAS can not be started on NT
    //
    if (dwComponentsMissed & CC_RASRUNNING)
    {
        return dwRet;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}       
        
//+----------------------------------------------------------------------------
//  Function    MarkComponentsChecked
//
//  Synopsis    Mark(in registry) what components have been checked.
//
//  Arguments   DWORD dwComponentsInstalled - a dword(bitwise OR'ed)
//
//  Return      TRUE - success
//              FALSE  - otherwise
//
//  History     08/07/97        Fengsun  - created  
//              08/11/97        henryt   - changed return type.
//              07/03/98        nickball - create if can't open
//-----------------------------------------------------------------------------
BOOL MarkComponentsChecked(DWORD dwComponentsChecked)
{
    HKEY hKeyCm;
    
    //
    // Try to open the key for writing
    //

    LONG lRes = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                              c_pszRegCmRoot,
                              0,
                              KEY_SET_VALUE ,
                              &hKeyCm);

    //
    // If we can't open it the key may not be there, try to create it.
    //

    if (ERROR_SUCCESS != lRes)
    {
        DWORD dwDisposition;
        lRes = RegCreateKeyExU(HKEY_LOCAL_MACHINE,
                               c_pszRegCmRoot,
                               0,
                               TEXT(""),
                               REG_OPTION_NON_VOLATILE,
                               KEY_SET_VALUE,
                               NULL,
                               &hKeyCm,
                               &dwDisposition);     
    }

    //
    // On success, update the ComponentsChecked value, then close
    //

    if (ERROR_SUCCESS == lRes)
    {
        lRes = RegSetValueExU(hKeyCm, c_pszRegComponentsChecked, NULL, REG_DWORD,
                      (BYTE*)&dwComponentsChecked, sizeof(dwComponentsChecked));
        RegCloseKey(hKeyCm);
    }

    return (ERROR_SUCCESS == lRes);
}

//+----------------------------------------------------------------------------
//  Function    ReadComponentsChecked
//
//  Synopsis    Read(from registry) what components have been checked.
//
//  Arguments   LPDWORD pdwComponentsInstalled - a ptr dword(bitwise OR'ed)
//
//  Return      TRUE - success
//              FALSE  - otherwise
//
//  History     8/7/97      fengsun     original code
//              8/11/97     henryt      created the func.
//-----------------------------------------------------------------------------

BOOL ReadComponentsChecked(
    LPDWORD pdwComponentsChecked
)
{
    BOOL fSuccess = FALSE;
    HKEY hKeyCm;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    *pdwComponentsChecked = 0;

    if (RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                      c_pszRegCmRoot,
                      0,
                      KEY_QUERY_VALUE ,
                      &hKeyCm) == ERROR_SUCCESS)
    {
        if ((RegQueryValueExU(hKeyCm, 
                            c_pszRegComponentsChecked,
                            NULL,
                            &dwType,
                            (BYTE*)pdwComponentsChecked, 
                            &dwSize) == ERROR_SUCCESS)   &&
           (dwType == REG_DWORD)                        && 
           (dwSize == sizeof(DWORD)))
        {
            fSuccess = TRUE;
        }

        RegCloseKey(hKeyCm);
    }
    return fSuccess;
}




//+----------------------------------------------------------------------------
//
// Function:  ClearComponentsChecked
//
// Synopsis:  Clear the component checked flag in registry back to 0
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
void ClearComponentsChecked()
{
    MarkComponentsChecked(0);
}
        
//+----------------------------------------------------------------------------
//  Function    CheckComponents
//
//  Synopsis    Checks to see if the system has all the components 
//              required of the service profile (like PPTP, TCP,...)
//              installed and configured
//
//  Arguments   hWndParent          -Window Handle of parent window
//              pszServiceName      - Service Name for title
//              dwComponentsToCheck:- Components to check
//              dwComponentsMissed: - OUT components missed
//              fIgnoreRegKey:      - Whether ignore ComponetsChecked registry key
//                  Default is  FALSE, not check the components whose bit is set
//                  in registry
//              fUnattended: if TRUE, do not do not popup any UI
//
//  Return      ERROR_SUCCESS- system does not need configuration
//              Other - otherwise
//
//  History     5/5/97      VetriV      
//              6/26/97     byao    Modified: update pArgs->dwExitCode when 
//                                  components needed
//              8/11/97     henryt  Performance changes. Added CC_* flags.
//              9/30/97     henryt  added pfPptpNotInstalled
//              11/6/97     fengsun changed parameters, do not pass pArgs
//-----------------------------------------------------------------------------
HRESULT CheckComponents(HWND hWndParent, LPCTSTR pszServiceName, DWORD dwComponentsToCheck, OUT DWORD& dwComponentsMissed, 
                      BOOL fIgnoreRegKey, BOOL fUnattended )
{
    DWORD dwComponentsAlreadyChecked = 0;   // Components already checked, to be saved into registry
    ReadComponentsChecked(&dwComponentsAlreadyChecked);

    CMTRACE1(TEXT("CheckComponents: dwComponentsToCheck = 0x%x"), dwComponentsToCheck);
    CMTRACE1(TEXT("CheckComponents: dwComponentsAlreadyChecked = 0x%x"), dwComponentsAlreadyChecked);

    //
    // If this is NT4 and we have successfully checked RAS installation
    // previously, double-check by examining Reg key. We do this because
    // the user may have removed RAS since our last component check in 
    // which case an unpleasant message is displayed to the user when
    // we try to load RASAPI32.DLL
    // 

    if (dwComponentsAlreadyChecked & CC_RNA)
    {
        if (OS_NT4)
        {
            //
            // RAS was installed properly at some point, but if 
            // we can't open the key, then mark it as un-checked.
            //

            HKEY hKeyCm;
            DWORD dwRes = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                                        c_pszRegRas,
                                        0,
                                        KEY_QUERY_VALUE ,
                                        &hKeyCm);
            if (ERROR_SUCCESS == dwRes)
            {
                RegCloseKey(hKeyCm);            
            }
            else
            {
                dwComponentsAlreadyChecked &= ~CC_RNA;
            }
        }
    }

    if (!fIgnoreRegKey)
    {
        //
        // Do not check those components already marked as checked in the registry
        //
        dwComponentsToCheck &= ~dwComponentsAlreadyChecked;
    }

    CMTRACE1(TEXT("CheckComponents: Now only checking components = 0x%x"), dwComponentsToCheck);


    HRESULT hrRet = S_OK;   // return value
    dwComponentsMissed = 0;   // Components not installed

    //
    // Check for DUN and TCP
    //
    if (dwComponentsToCheck & (CC_RNA | CC_TCPIP | CC_CHECK_BINDINGS))
    {
        BOOL bNeedSystemComponents = FALSE;
        
        if (dwComponentsToCheck & CC_CHECK_BINDINGS)
        {
            //
            // If we to check if PPP is bound to TCP
            //
            hrRet = InetNeedSystemComponents(INETCFG_INSTALLRNA | 
                                                INETCFG_INSTALLTCP,
                                                &bNeedSystemComponents);
        }
        else
        {
            //
            // If we do not want to check if TCP is bound (in case of shims)
            // check just if TCP is installed
            //
            hrRet = InetNeedSystemComponents(INETCFG_INSTALLRNA | 
                                                INETCFG_INSTALLTCPONLY,
                                                &bNeedSystemComponents);
        }
            
        if ((FAILED(hrRet)) || (TRUE == bNeedSystemComponents))
        {
            //
            // Set the Missing components properly - RNA and/or TCP missing
            // whether binding is missing or not depends on 
            // if CC_REVIEW_BINDINGS was set or not
            //
            dwComponentsMissed |= (CC_RNA | CC_TCPIP);
            if (dwComponentsToCheck & CC_CHECK_BINDINGS)
            {
                dwComponentsMissed |= CC_CHECK_BINDINGS;
            }
            
            if (SUCCEEDED(hrRet))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
            }
        }
    }

    //
    // Check for Modem
    // Note: Should not even run the modem check is RNA is not installed
    //
    if (dwComponentsToCheck & CC_MODEM)
    {
        BOOL bNeedModem = FALSE;

        hrRet = InetNeedModem(&bNeedModem);

        if (FAILED(hrRet)) 
        {
            dwComponentsMissed |= (CC_MODEM | CC_RNA);
        }
        else 
        {
            if (TRUE == bNeedModem)
            {
                dwComponentsMissed |= CC_MODEM;
                hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
            }
        }
    }

    //
    // Check if PPTP is installed, IsPPTPInstalled always returns TRUE for NT5
    //
    if (dwComponentsToCheck & CC_PPTP)
    {
        if (FALSE == IsPPTPInstalled())
        {
            dwComponentsMissed |= CC_PPTP;
            hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
        }
    }

    //
    // Check for scripting
    //      if PPTP is installed then we have scripting also
    //      - msdun12.exe (used to install PPTP on Win95 contains scripting)
    if (dwComponentsToCheck & CC_SCRIPTING)
    {
        if ((FALSE == IsScriptingInstalled()) && (FALSE == IsPPTPInstalled()))
        {
            dwComponentsMissed |= CC_SCRIPTING;
            hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
        }
    }

    //
    // Check if RAS services are running 
    // This is basically for NT4 and becomes a NOP on Windows 95 or NT5
    // On NT5, CM is started by Connection Folder.  RAS is automaticlly
    // started when ConnFolder is launched or CM desktop icon is clicked.  If RAS service
    // failed to launch, CM will not be execute at all.
    //
    if  (OS_NT && (dwComponentsToCheck & CC_RASRUNNING))
    {
        if (FALSE == VerifyRasServicesRunning(hWndParent, pszServiceName, !fUnattended))
        {
            //
            // Don't let the user continue if RAS is not running
            //
            dwComponentsMissed |= CC_RASRUNNING;
            DWORD dwRet = ( GetLastError() == ERROR_SUCCESS )? 
                    ERROR_PROTOCOL_NOT_CONFIGURED : GetLastError();

            hrRet = HRESULT_FROM_WIN32(dwRet);
        }
    }

    //
    // Update the components already checked
    //      Plus Components just checked, including those failed
    //      Minus components missed
    //
    DWORD dwComponentsCheckedNew = (dwComponentsAlreadyChecked | dwComponentsToCheck) & ~dwComponentsMissed;

    //
    // Update only if there is some change
    //
    if (dwComponentsCheckedNew != dwComponentsAlreadyChecked)
    {
        MarkComponentsChecked(dwComponentsCheckedNew);
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//  Function    InstallComponents
//
//  Synopsis    Installs all components required for the profile
//                  (PPTP, TCP, DUN, Modem,...)
//
//  Arguments   hWndDlg -   Window Handle of parent window
//              pszServiceName - Name of the service for title
//              dwComponentsToInstall - Componets to install
//
//  Return      FALSE - if system could not be configured
//              TRUE  - otherwise
//
//  History     3/13/97     VetriV  Created 
//              5/5/97      VetriV  Renamed function as InstallComponents
//                                  (used to be ConfigureSystemForDialing)  
//              9/30/97     henryt  added fInstallPptpOnly
//              11/6/97     fengsun changed parameters, do not pass pArgs
//              2/3/98      VetriV  changed code to inform user to reinstall
//                                  service pack if any component was installed
//                                  by this function and user had some SP
//                                  installed in the system
//-----------------------------------------------------------------------------
BOOL InstallComponents(DWORD dwComponentsToInstall, HWND hWndDlg, LPCTSTR pszServiceName)
{
    //
    //  We are not allowed to configure the system at WinLogon because we have
    //  no idea who the user is.  It could be just a random person walking up to the box.
    //
    if (!IsLogonAsSystem())
    {
        BOOL bReboot = FALSE;

        CMTRACE1(TEXT("InstallComponents: dwComponentsToInstall = 0x%x"), dwComponentsToInstall);

        //
        // We can not do any thing if RAS is not running
        //
        MYDBGASSERT(!(dwComponentsToInstall & CC_RASRUNNING));

        //
        // Disable the window, and enable it on return
        // The property sheet also need to be disabled
        //
        CFreezeWindow FreezeWindow(hWndDlg, TRUE);

        DWORD hRes = ERROR_SUCCESS;

        //
        // Do not install modem here. Install modem after reboot
        //
        if (dwComponentsToInstall & (CC_RNA | CC_MODEM | INETCFG_INSTALLTCP | INETCFG_INSTALLTCPONLY))
        {
            DWORD dwInetComponent = 0;

            dwInetComponent |= (dwComponentsToInstall & CC_RNA   ? INETCFG_INSTALLRNA :0) |
                               (dwComponentsToInstall & CC_MODEM ? INETCFG_INSTALLMODEM :0);

            //
            // Only way to check bindings is by installing TCP
            // This case will also cover the more common case of installing TCP
            // and checking for bindings
            //
            if (CC_CHECK_BINDINGS & dwComponentsToInstall)
            {
                dwInetComponent |= INETCFG_INSTALLTCP;
            }
            else if (CC_TCPIP & dwComponentsToInstall)
            {
                    //
                    // If bindings check is not turned on
                    //
                    dwInetComponent |= INETCFG_INSTALLTCPONLY;
            }

            if (dwInetComponent)
            {
                hRes = ConfigSystem(hWndDlg,dwInetComponent, &bReboot);
            }
        }
    

        if (ERROR_SUCCESS == hRes)
        {
            //
            // Check for scripting
            //      if PPTP is installed than we have scripting also
            //      - because msdun12.exe (used to install PPTP on Win95 
            //                              contains scripting)
            // and install if it is needed
            //
            if ((dwComponentsToInstall & CC_SCRIPTING) && 
                !(dwComponentsToInstall & CC_PPTP) )
            {
                LPTSTR pszNoScriptMsg = CmFmtMsg(g_hInst, IDMSG_NO_SCRIPT_INST_MSG_95);

                if (pszNoScriptMsg)
                {
                    MessageBoxEx(hWndDlg, pszNoScriptMsg, pszServiceName, 
                                 MB_OK | MB_ICONSTOP, LANG_USER_DEFAULT);
                    CmFree(pszNoScriptMsg);
                }
                return FALSE;
            }

            //
            // Check if PPTP is required and not already installed install it
            //
            if (dwComponentsToInstall & CC_PPTP)
            {
                if (TRUE == InstallPPTP()) // Note: Always fails on 95 by design
                {
                    //
                    // We have to reboot after installing PPTP
                    //
                    bReboot = TRUE;
                }
                else
                {
                    LPTSTR pszMsg;
                
                    //
                    // Don't let the user continue PPTP is not installed
                    //              
                
                    if (OS_NT) 
                    {
                        if (IsServicePackInstalled())
                        {
                            //
                            // we need to tell the user to re-apply the service pack after manual
                            // install of PPTP.
                            //
                            pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_NT_SP); // NT
                        }
                        else
                        {
                            pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_NT); // NT
                        }
                    }
                    else if (OS_W98)
                    {
                        pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_98); // W98                   
                    }
                    else
                    {
                        pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_95); // default                   
                    }

                    if (pszMsg)
                    {

                        MessageBoxEx(hWndDlg, pszMsg, pszServiceName, 
                                     MB_OK | MB_ICONSTOP, LANG_USER_DEFAULT);
                        CmFree(pszMsg);
                    }
                    return FALSE;
                }
            }
        }

    
        if ((ERROR_SUCCESS == hRes) && bReboot) 
        {
            if (OS_NT && (TRUE == IsServicePackInstalled()))
            {
                //
                // If service pack is installed, then display message asking
                // user to re-install the service pack and exit without rebooting
                // We do this because rebooting after installing RAS, without
                // reinstalling the service pack can cause BlueScreen!
                //
                DisplayMessageToInstallServicePack(hWndDlg, pszServiceName);
                return FALSE;
            }
            else
            {
                //
                // Display reboot message and is user wants reboot the sytem
                //
                LPTSTR pszMsg = CmFmtMsg(g_hInst,IDMSG_REBOOT_MSG);

                int iRes = IDNO;
                 
                if (pszMsg)
                {
                    iRes = MessageBoxEx(hWndDlg,
                                        pszMsg,
                                        pszServiceName,
                                        MB_YESNO | MB_DEFBUTTON1 | 
                                            MB_ICONWARNING | MB_SETFOREGROUND,
                                        LANG_USER_DEFAULT);

                    CmFree(pszMsg);
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("InstallComponents: CmFmtMsg failed to load IDMSG_REBOOT_MSG"));
                }

                if (IDYES == iRes) 
                {
                    //
                    // Shutdown Windows, CM will quit gracefully on 
                    // WM_ENDSESSION message 
                    // What shall we do if MyExitWindowsEx() fialed
                    //
                    DWORD dwReason = OS_NT51 ? (SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_RECONFIG) : 0;
                    MyExitWindowsEx(EWX_REBOOT, dwReason);

                    //
                    // Caller will return failed
                    //
                    return FALSE;
                }
                else
                {
                    //
                    // If user do not want to reboot, shall we quit CM
                    //
                }
            }
        }

        if (ERROR_SUCCESS == hRes)
        {
            return TRUE;
        }
    }
    
    //
    // Configuration check failed message, if install is not canceled
    //
    LPTSTR pszMsg = CmFmtMsg(g_hInst,IDMSG_CONFIG_FAILED_MSG);
    if (pszMsg)
    {
        MessageBoxEx(hWndDlg, pszMsg, pszServiceName, MB_OK|MB_ICONSTOP, 
                                LANG_USER_DEFAULT);
        CmFree(pszMsg);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("InstallComponents: CmFmtMsg failed to load IDMSG_CONFIG_FAILED_MSG"));
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  Function    ConfigSystem
//
//  Synopsis    Use inetcfg.dll to configure system settings, 
//              like install modem, rna etc.
//
//  Arguments   hWndDlg -       Window Handle of parent window
//              dwfOptions -    Components to be configured
//              pbReboot    -   Will be set to true if system has to rebooted
//                                  as result of the configuration
//
//  Returns     ERROR_SUCCESS if successful
//              Failure code otherwise
//
//  History     Old code        
//-----------------------------------------------------------------------------

HRESULT ConfigSystem(HWND hwndParent, 
                     DWORD dwfOptions, 
                     LPBOOL pbReboot) 
{
    HRESULT hRes = ERROR_SUCCESS;


    HINSTANCE hLibrary = NULL;
    HRESULT (WINAPI *pfn)(HWND,DWORD,LPBOOL);

    hLibrary = LoadInetCfg();
    if (!hLibrary) 
    {
        CMTRACE1(TEXT("ConfigSystem() LoadLibrary() failed, GLE=%u."), GetLastError());
        hRes = GetLastError();
        goto done;
    }
        
    pfn = (HRESULT (WINAPI *)(HWND,DWORD,LPBOOL)) GetProcAddress(hLibrary, "InetConfigSystem");
    if (!pfn) 
    {
        CMTRACE1(TEXT("ConfigSystem() GetProcAddress() failed, GLE=%u."), GetLastError());
        hRes = GetLastError();
        goto done;
    }
    
    hRes = pfn(hwndParent,dwfOptions,pbReboot);
#ifdef DEBUG
    if (hRes != ERROR_SUCCESS)
    {
        CMTRACE1(TEXT("ConfigSystem() InetConfigSystem() failed, GLE=%u."), hRes);
    }
#endif
    

done:
    if (hLibrary) 
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    return (hRes);
}



//+----------------------------------------------------------------------------
//  Function    InetNeedSystemComponents
//
//  Synopsis    Use inetcfg.dll to check if we need to configure system settings 
//              like rna etc.
//
//  Arguments   dwfOptions -            Components to be configured
//              pbNeedSysComponents -   Will be set to true if we need to 
//                                          configure system settings
//
//  Returns     ERROR_SUCCESS if successful
//              Failure code otherwise
//
//  History     5/5/97  VetriV  Created     
//-----------------------------------------------------------------------------
HRESULT InetNeedSystemComponents(DWORD dwfOptions, 
                                    LPBOOL pbNeedSysComponents) 
{
    HRESULT hRes = ERROR_SUCCESS;

    HINSTANCE hLibrary = NULL;
    HRESULT (WINAPI *pfnInetNeedSystemComponents)(DWORD, LPBOOL);

    hLibrary = LoadInetCfg();
    if (!hLibrary) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedSystemComponents() LoadLibrary() failed, GLE=%u."), hRes);
        goto done;
    }
        
    pfnInetNeedSystemComponents = (HRESULT (WINAPI *)(DWORD,LPBOOL)) GetProcAddress(hLibrary, "InetNeedSystemComponents");
    if (!pfnInetNeedSystemComponents) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedSystemComponents() GetProcAddress() failed, GLE=%u."), hRes);
        goto done;
    }
    
    hRes = pfnInetNeedSystemComponents(dwfOptions, pbNeedSysComponents);
#ifdef DEBUG
    if (hRes != ERROR_SUCCESS)
    {
        CMTRACE1(TEXT("InetNeedSystemComponents() failed, GLE=%u."), hRes);
    }
#endif

done:
    if (hLibrary) 
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    return (hRes);
}




//+----------------------------------------------------------------------------
//  Function    InetNeedModem
//
//  Synopsis    Use inetcfg.dll to check if we need to install/configure modem
//
//  Arguments   pbNeedModem -   Will be set to true if we need to 
//                                  install/configure modem
//
//  Returns     ERROR_SUCCESS if successful
//              Failure code otherwise
//
//  History     5/5/97  VetriV  Created     
//-----------------------------------------------------------------------------
HRESULT InetNeedModem(LPBOOL pbNeedModem) 
{
    HRESULT hRes = ERROR_SUCCESS;

    HINSTANCE hLibrary = NULL;
    HRESULT (WINAPI *pfnInetNeedModem)(LPBOOL);

    hLibrary = LoadInetCfg();
    if (!hLibrary) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedModem() LoadLibrary() failed, GLE=%u."), hRes);
        goto done;
    }
        
    pfnInetNeedModem = (HRESULT (WINAPI *)(LPBOOL)) GetProcAddress(hLibrary, "InetNeedModem");
    if (!pfnInetNeedModem) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedModem() GetProcAddress() failed, GLE=%u."), hRes);
        goto done;
    }
    
    hRes = pfnInetNeedModem(pbNeedModem);
#ifdef DEBUG
    if (hRes != ERROR_SUCCESS)
    {
        CMTRACE1(TEXT("InetNeedModem() failed, GLE=%u."), hRes);
    }
#endif

done:
    if (hLibrary) 
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    return (hRes);
}

//+----------------------------------------------------------------------------
//  Function    DisplayMessageToInstallServicePack
//
//  Synopsis    Display a message to user informing them to reinstall 
//              Service Pack
//
//  Arguments   hWndParent  - Window handle to parent
//              pszServiceName - Service name for title
//
//  Returns     None
//
//  History     2/4/98  VetriV  Created     
//-----------------------------------------------------------------------------
void DisplayMessageToInstallServicePack(HWND hWndParent, LPCTSTR pszServiceName)
{
    LPTSTR pszMsg = CmFmtMsg(g_hInst,IDMSG_INSTALLSP_MSG);

    if (pszMsg)
    {
        MessageBoxEx(hWndParent, pszMsg, pszServiceName, MB_OK | MB_ICONINFORMATION, 
                                LANG_USER_DEFAULT);
        CmFree(pszMsg);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("DisplayMessageToInstallServicePack: CmFmtMsg failed to load IDMSG_INSTALLSP_MSG"));
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\connect.cpp ===
//+----------------------------------------------------------------------------
//
// File:     connect.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The main code path for establishing a connection. 
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    2/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
// Local includes
//

#include "ConnStat.h"
#include "CompChck.h"
#include "Dialogs.h"
#include "ActList.h"
#include "dial_str.h"
#include "dun_str.h"
#include "dl_str.h"
#include "pwd_str.h"
#include "tunl_str.h"
#include "mon_str.h"
#include "conact_str.h"
#include "pbk_str.h"
#include "stp_str.h"
#include "profile_str.h"
#include "ras_str.h"

#include "cmtiming.h"

#include "cm_eap.cpp"

#include "MemberOfGroup.cpp"
//
//  Include the header for linking to the SafeNet Config APIs
//
#include "cmsafenet.h"

//
// .CMP and .CMS flag used only by connect.cpp
//

const TCHAR* const c_pszCmEntryMonitorCallingProgram= TEXT("MonitorCallingProgram"); 
const TCHAR* const c_pszCmEntryUserNameOptional     = TEXT("UserNameOptional"); 
const TCHAR* const c_pszCmEntryDomainOptional       = TEXT("DomainOptional"); 
const TCHAR* const c_pszCmEntryServiceType          = TEXT("ServiceType");
const TCHAR* const c_pszCmEntryRedialDelay          = TEXT("RedialDelay"); 
const TCHAR* const c_pszCmEntryRedial               = TEXT("Redial");                       
const TCHAR* const c_pszCmEntryIdle                 = TEXT("Idle");                         
const TCHAR* const c_pszCmEntryDialAutoMessage      = TEXT("DialAutoMessage");  
const TCHAR* const c_pszCmEntryCheckOsComponents    = TEXT("CheckOSComponents");     
const TCHAR* const c_pszCmEntryDoNotCheckBindings   = TEXT("DoNotCheckBindings");   
const TCHAR* const c_pszCmEntryIsdnDialMode         = TEXT("IsdnDialMode"); 
const TCHAR* const c_pszCmEntryResetPassword        = TEXT("ResetPassword");
const TCHAR* const c_pszCmEntryCustomButtonText     = TEXT("CustomButtonText");
const TCHAR* const c_pszCmEntryCustomButtonToolTip  = TEXT("CustomButtonToolTip"); 
const TCHAR* const c_pszCmDynamicPhoneNumber        = TEXT("DynamicPhoneNumber"); 
const TCHAR* const c_pszCmNoDialingRules            = TEXT("NoDialingRules"); 

const TCHAR* const c_pszCmEntryHideDialAuto         = TEXT("HideDialAutomatically"); 
const TCHAR* const c_pszCmEntryHideRememberPwd      = TEXT("HideRememberPassword"); 
const TCHAR* const c_pszCmEntryHideRememberInetPwd  = TEXT("HideRememberInternetPassword"); 
const TCHAR* const c_pszCmEntryHideInetUserName     = TEXT("HideInternetUserName"); 
const TCHAR* const c_pszCmEntryHideInetPassword     = TEXT("HideInternetPassword"); 
const TCHAR* const c_pszCmEntryHideUnattended       = TEXT("HideUnattended"); 

const TCHAR* const c_pszCmEntryRegion               = TEXT("Region");
const TCHAR* const c_pszCmEntryPhonePrefix          = TEXT("Phone"); 
const TCHAR* const c_pszCmEntryPhoneCanonical       = TEXT("PhoneCanonical"); 
const TCHAR* const c_pszCmEntryPhoneDunPrefix       = TEXT("DUN"); 
const TCHAR* const c_pszCmEntryPhoneDescPrefix      = TEXT("Description"); 
const TCHAR* const c_pszCmEntryPhoneCountryPrefix   = TEXT("PhoneCountry"); 
const TCHAR* const c_pszCmEntryPhoneSourcePrefix    = TEXT("PhoneSource"); 
const TCHAR* const c_pszCmEntryUseDialingRules      = TEXT("UseDialingRules"); 

const TCHAR* const c_pszCmEntryAnimatedLogo         = TEXT("AnimatedLogo"); 
const TCHAR* const c_pszCmSectionAnimatedLogo       = TEXT("Animated Logo"); 
const TCHAR* const c_pszCmSectionAnimatedActions    = TEXT("Animation Actions"); 
const TCHAR* const c_pszCmEntryAniMovie             = TEXT("Movie"); 
const TCHAR* const c_pszCmEntryAniPsInteractive     = TEXT("Initial"); 
const TCHAR* const c_pszCmEntryAniPsDialing0        = TEXT("Dialing0"); 
const TCHAR* const c_pszCmEntryAniPsDialing1        = TEXT("Dialing1"); 
const TCHAR* const c_pszCmEntryAniPsPausing         = TEXT("Pausing"); 
const TCHAR* const c_pszCmEntryAniPsAuthenticating  = TEXT("Authenticating"); 
const TCHAR* const c_pszCmEntryAniPsOnline          = TEXT("Connected"); 
const TCHAR* const c_pszCmEntryAniPsTunnel          = TEXT("Tunneling"); 
const TCHAR* const c_pszCmEntryAniPsError           = TEXT("Error"); 

const TCHAR* const c_pszCmEntryWriteDialParams      = TEXT("WriteRasDialUpParams"); 

//
// Used for loading EAP identity DLL
//

const TCHAR* const c_pszRasEapRegistryLocation      = TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP");
const TCHAR* const c_pszRasEapValueNameIdentity     = TEXT("IdentityPath");
const TCHAR* const c_pszInvokeUsernameDialog        = TEXT("InvokeUsernameDialog");

//
// Definitions
//

#define MAX_OBJECT_WAIT 30000         // milliseconds to wait for cmmon launch and RNA thread return

//============================================================================

static void LoadPhoneInfoFromProfile(ArgsStruct *pArgs);

HRESULT UpdateTable(ArgsStruct *pArgs, CmConnectState CmState);
HRESULT ConnectMonitor(ArgsStruct *pArgs);
void OnMainExit(ArgsStruct *pArgs);
void ProcessCleanup(ArgsStruct* pArgs);

VOID UpdateError(ArgsStruct *pArgs, DWORD dwErr);

DWORD GetEapUserId(ArgsStruct *pArgs, 
    HWND hwndDlg, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize, 
    DWORD dwCustomAuthKey,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity);

DWORD CmEapGetIdentity(ArgsStruct *pArgs, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity);

void CheckStartupInfo(HWND hwndDlg, ArgsStruct *pArgs);

BOOL InitConnect(ArgsStruct *pArgs);

void ObfuscatePasswordEdit(ArgsStruct *pArgs);

void DeObfuscatePasswordEdit(ArgsStruct *pArgs);

void GetPasswordFromEdit(ArgsStruct *pArgs);

DWORD ReSaveEapCustomAuthData(ArgsStruct *pArgs, CIni *pcini, BOOL fTunnelEntry, LPTSTR pszRasPbk);
HRESULT EraseDunSettingsEapData(LPCTSTR pszSection, LPCTSTR pszCmsFile);
DWORD SaveNewEAPCustomAuthData(LPCTSTR pszCmsFile, LPTSTR pszLoadSection, DWORD cbEapAuthData, PBYTE pbEapAuthData, PBYTE pbEapStruct);

//+----------------------------------------------------------------------------
//
// Function:  GetPasswordFromEdit
//
// Synopsis:  Updates pArgs->szPassword with contents of edit control
//
// Arguments: pArgs  -  Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created     04/13/00
//
//+----------------------------------------------------------------------------
void GetPasswordFromEdit(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    if (NULL == GetDlgItem(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT))
    {
        return;
    }

    //
    // Retrieve the password and update memory based storage.
    //
        
    LPTSTR pszPassword = CmGetWindowTextAlloc(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT);
        
    MYDBGASSERT(pszPassword);

    if (pszPassword)
    {                       
        //
        // Update pArgs with main password. 
        //

        (VOID)pArgs->SecurePW.SetPassword(pszPassword);
    
        CmWipePassword(pszPassword);
        CmFree(pszPassword);
    }
    else
    {
        (VOID)pArgs->SecurePW.SetPassword(TEXT(""));
    }

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  DeObfuscatePasswordEdit
//
// Synopsis:  Undoes the work of ObfuscatePasswordEdit by updating the password
//            edit with the plain text password 
//
// Arguments: pArgs  -  Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created     04/13/00
//
//+----------------------------------------------------------------------------
void DeObfuscatePasswordEdit(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    HWND hwndEdit = GetDlgItem(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT);

    if (NULL == hwndEdit)
    {
        return;
    }

    //
    // Make sure we don't trigger EN_CHANGE notifications
    //

    BOOL bSavedNoNotify = pArgs->fIgnoreChangeNotification;
    pArgs->fIgnoreChangeNotification = TRUE;
    
    //
    // Update the edit control
    //

    LPTSTR pszClearPassword = NULL;
    DWORD cbClearPassword = 0;
    BOOL fRetPassword = FALSE;

    fRetPassword = pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

    if (fRetPassword && pszClearPassword)
    {
        SetWindowTextU(hwndEdit, pszClearPassword);
        
        pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
    }

    //
    // Restore EN_CHANGE notifications
    //

    pArgs->fIgnoreChangeNotification = bSavedNoNotify;   
}

//+----------------------------------------------------------------------------
//
// Function:  ObfuscatePasswordEdit
//
// Synopsis:  Helper routine to mangle password edit contents by replacing 
//            them with an equivalent number of *s
//
// Arguments: pArgs  -  Ptr to global Args struct
//
// Returns:   Nothing
//
// NOTE:      This function assumes that pArgs->szPassword has been previously
//            updated with GetPasswordFromEdit. This assumption is made 
//            because it is critical to the Odfuscate/DeObfuscate sequence, 
//            which will breakdown if the latest password is not cached in 
//            memory (pArgs) before the edit contents are modified.
//
// History:   nickball    Created     04/13/00
//
//+----------------------------------------------------------------------------
void ObfuscatePasswordEdit(ArgsStruct *pArgs)
{   
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    HWND hwndEdit = GetDlgItem(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT);

    if (NULL == hwndEdit)
    {
        return;
    }

    //
    // Generate a buffer of the same length as the current password, but 
    // containing only asterisks.
    //
    
    LPTSTR pszClearPassword = NULL;
    DWORD cbClearPassword = 0;
    BOOL fRetPassword = FALSE;

    fRetPassword = pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

    if (fRetPassword && pszClearPassword)
    {
        //
        // Make sure we don't trigger EN_CHANGE notifications
        //
        BOOL bSavedNoNotify = pArgs->fIgnoreChangeNotification;
        pArgs->fIgnoreChangeNotification = TRUE;

        LPTSTR pszTmp = pszClearPassword;
        
        while (*pszTmp)
        {
            *pszTmp++ = TEXT('*');
        }

        //
        // Update the edit control with the modified buffer
        //
        SetWindowTextU(hwndEdit, pszClearPassword);

        //
        // Restore EN_CHANGE notifications
        //

        pArgs->fIgnoreChangeNotification = bSavedNoNotify; 

        //
        // Clear and Free the clear-text password
        //

        pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  InitConnect
//
// Synopsis:  Init routine for the connection. Assumes that we have the profile
//            initialized and the basic integrity of the profile verified.
//
// Arguments: ArgStruct *pArgs  - Ptr to global Args struct
//
// Returns:   BOOL  - True if init succeeds.
//
// History:   nickball    Created     03/10/00
//
//+----------------------------------------------------------------------------
BOOL InitConnect(ArgsStruct *pArgs)
{
    //
    // If this is an AUTODIAL, add the process ID to the watch list
    //
    
    if ((pArgs->dwFlags & FL_AUTODIAL) && 
        pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMonitorCallingProgram, 1))
    {
        CMTRACE(TEXT("InitConnect() Adding calling process to watch list"));
        AddWatchProcessId(pArgs, GetCurrentProcessId());    
    }
    
    //
    // Do we want tunneling?
    //

    pArgs->fTunnelPrimary = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelPrimary);
    pArgs->fTunnelReferences = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelReferences);

    //
    // Now we can determine our connect type
    //
    
    GetConnectType(pArgs);

    //
    // Set fUseTunneling. If not obvious (eg. direct VPN) then 
    // base the initial value upon the primary phone number.
    //

    if (pArgs->IsDirectConnect())
    {
        pArgs->fUseTunneling = TRUE;
    }
    else
    {
        pArgs->fUseTunneling = UseTunneling(pArgs, 0);
    }

    //
    //  Load the path for the VPN file if we have one
    //

    LPTSTR pszTemp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryTunnelFile);
    
    if (pszTemp && pszTemp[0])
    {
        //
        //  Now expand the relative path to a full path
        //
        pArgs->pszVpnFile = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTemp);

        MYDBGASSERT(pArgs->pszVpnFile && pArgs->pszVpnFile[0]);
    }

    CmFree(pszTemp);

    TCHAR szTmp[MAX_PATH];
    MYVERIFY(GetModuleFileNameU(NULL, szTmp, MAX_PATH));
    pArgs->Log.Log(PREINIT_EVENT, szTmp);
    
     //
    // Run any init time actions that we may have.
    //

    CActionList PreInitActList;
    PreInitActList.Append(pArgs->piniService, c_pszCmSectionPreInit);
    if (!PreInitActList.RunAccordType(pArgs->hwndMainDlg, pArgs))
    {
        //
        // Fail the connection
        //
        
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckStartupInfo
//
// Synopsis:  Sub-routine to initialize startup info if necessary and perform 
//            any other functions specific to this juncture in the init sequence.
//
// Arguments: HWND      hwndDlg - HWND of main dlg
//            ArgStruct *pArgs  - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created     10/28/99
//
//+----------------------------------------------------------------------------

void CheckStartupInfo(IN HWND hwndDlg, IN ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    if (!pArgs->fStartupInfoLoaded)
    {
        //
        // When no one is logged on the IsWindowVisible will not return true when ICS is dialing
        //
        if (IsLogonAsSystem() || IsWindowVisible(hwndDlg))    
        {
            //
            // The code is here to make sure FutureSplash starts with 
            // the frame associated with Initial/Interactive state
            // and not Frame 1
            //

            if (NULL != pArgs->pCtr)
            {
                pArgs->pCtr->MapStateToFrame(PS_Interactive);
            }

            //
            // If we're doing unattended, and the behavior isn't explicitly turned off,
            // hide the UI while we do our unattended dial. Note: Be sure to set hide
            // state before first paint message is processed by system.
            //

            if (pArgs->dwFlags & FL_UNATTENDED)
            { 
                if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideUnattended, TRUE)) 
                {
                    ShowWindow(hwndDlg, SW_HIDE);
                }
            }

            //
            // Post a message to ourselves to begin loading startup info. 
            //

            PostMessageU(hwndDlg, WM_LOADSTARTUPINFO, (WPARAM)0, (LPARAM)0);  
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateError
//
// Synopsis:  Simple sub-routine to update the UI and program state in the 
// event of an error.
//
// Arguments: ArgStruct *pArgs - Ptr to global Args struct
//            DWORD     dwErr - The error code
//
// Returns:   Nothing
//
// History:   nickball    Created     05/31/99
//
//+----------------------------------------------------------------------------
VOID UpdateError(ArgsStruct *pArgs, DWORD dwErr)
{
    MYDBGASSERT(pArgs);

    if (pArgs)
    {
        //
        // Update the status display providing that the special case error code
        // ERROR_INVALID_DLL is not being used. This code is only used by CM to
        // designate that a Connect Action failed. Because the display is 
        // updated by the action list, we must ensure that we don't overwrite.
        // 

        if (ERROR_INVALID_DLL != dwErr)
        {
            CheckConnectionError(pArgs->hwndMainDlg, dwErr, pArgs, IsDialingTunnel(pArgs));
        }

        //
        // Update the logon dialog controls
        //

        SetInteractive(pArgs->hwndMainDlg, pArgs);

        //
        // Update the program state
        //

        pArgs->psState = PS_Error;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateTable
//
// Synopsis:  Encapsulates updating to Connection Table according to our 
//            current state
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//            CmConnectState CmState - The state we are now in.
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created Header    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT UpdateTable(ArgsStruct *pArgs, CmConnectState CmState)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pArgs->pConnTable);

    HRESULT hrRet = E_FAIL;

    //
    // Set the state as appropriate
    //

    switch (CmState)
    {
        case CM_CONNECTING:         
            hrRet = pArgs->pConnTable->AddEntry(pArgs->szServiceName, pArgs->fAllUser);
            break;

        case CM_CONNECTED:                              
            hrRet = pArgs->pConnTable->SetConnected(pArgs->szServiceName, pArgs->hrcRasConn, pArgs->hrcTunnelConn);
            break;
            
        case CM_DISCONNECTING:         
            hrRet = pArgs->pConnTable->SetDisconnecting(pArgs->szServiceName);
            break;

        case CM_DISCONNECTED:       
            hrRet = pArgs->pConnTable->ClearEntry(pArgs->szServiceName);
            break;

        default:
            MYDBGASSERT(FALSE);
            break;
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  EndMainDialog
//
// Synopsis:  Simple helper to encapsulate EndDialog call and associated clean
//            up.
//
// Arguments: HWND hwndDlg - HWND of main dialog 
//            ArgsStruct *pArgs - Ptr to global Args struct
//            int nResult - int to be passed on the EndDialog
//
// Returns:   Nothing
//
// History:   nickball    Created     2/23/98
//
//+----------------------------------------------------------------------------

void EndMainDialog(HWND hwndDlg, ArgsStruct *pArgs, int nResult)
{    
    //
    // Kill timer if we have one
    //

    if (pArgs->nTimerId)
    {
        KillTimer(hwndDlg,pArgs->nTimerId);
        pArgs->nTimerId = 0;
    }

    //
    // Cleanup future splash
    //

    if (pArgs->pCtr)
    {
        CleanupCtr(pArgs->pCtr); 
        pArgs->pCtr = NULL;
    }

    //
    // Release our dialog specific data
    //

    pArgs->fStartupInfoLoaded = FALSE;

    OnMainExit(pArgs); 

    //
    // hasta la vista, final
    //

    EndDialog(hwndDlg, nResult);
}

//+----------------------------------------------------------------------------
//
// Function:  GetWatchCount
//
// Synopsis:  Determines the number of processes in the watch list by searching
//            for the first NULL entry.
//
// Arguments: ArgStruct *pArgs - Ptr to global Args struct
//
// Returns:   DWORD - Number of processes in list
//
// History:   nickball    Created Header    2/10/98
//
//+----------------------------------------------------------------------------
DWORD GetWatchCount(const ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    DWORD dwCnt = 0;

    if (pArgs && pArgs->phWatchProcesses) 
    {
        for (DWORD dwIdx = 0; pArgs->phWatchProcesses[dwIdx]; dwIdx++) 
        {
            dwCnt++;
        }
    }

    return dwCnt;
}
    
//+----------------------------------------------------------------------------
//
// Function:  AddWatchProcess
//
// Synopsis:  Adds the given process handle to our list. The list is allocated
//            and reallocated as needed to accomodate new entries.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//            HANDLE hProcess - The process handle to be added to the list
//
// Returns:   Nothing
//
// History:   nickball    Created Header        2/10/98
//            tomkel      Fixed PREFIX issues   11/21/2000
//
//+----------------------------------------------------------------------------
void AddWatchProcess(ArgsStruct *pArgs, HANDLE hProcess) 
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(hProcess);
        
    if (NULL == hProcess || NULL == pArgs) 
    {
        return;
    }

    //
    // Get count and Allocate room for 2 more, 1 new, 1 NULL
    //

    DWORD dwCnt = GetWatchCount(pArgs);

    HANDLE *phTmp = (HANDLE *) CmMalloc((dwCnt+2)*sizeof(HANDLE));
    
    if (NULL != phTmp)
    {
        //
        // Copy the existing list, and add the new handle
        //
        if (NULL != pArgs->phWatchProcesses)
        {
            CopyMemory(phTmp,pArgs->phWatchProcesses,sizeof(HANDLE)*dwCnt);
        }
    
        phTmp[dwCnt] = hProcess;

        //
        // Fix up the pointers
        //

        CmFree(pArgs->phWatchProcesses);
        pArgs->phWatchProcesses = phTmp;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  AddWatchProcessId
//
// Synopsis:  Given a process Id, adds a handle for the given process to the w
//            atch process list.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct.
//            DWORD dwProcessId - The ID of the process to be added
//
// Returns:   Nothing
//
// History:   nickball    Created Header    2/10/98
//
//+----------------------------------------------------------------------------

void AddWatchProcessId(ArgsStruct *pArgs, DWORD dwProcessId) 
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(dwProcessId);

    if (NULL == pArgs || NULL == dwProcessId)
    {
        return;
    }

    //
    // Open the process Id to obtain handle
    //

    HANDLE hProcess = OpenProcess(SYNCHRONIZE | PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
    
    //
    // Add to the watch process list 
    //
    
    if (hProcess) 
    {
        AddWatchProcess(pArgs,hProcess);
    }
    else
    {
        CMTRACE1(TEXT("AddWatchProcess() OpenProcess() failed, GLE=%u."), GetLastError());
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CleanupConnect
//
// Synopsis:  Helper function encapsulating release of resource allocated duri
//            ng connect.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    9/25/98
//
//+----------------------------------------------------------------------------
void CleanupConnect(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        return;
    }

    pArgs->m_ShellDll.Unload();

    //
    // Unlink RAS and TAPI DLLs
    //

    UnlinkFromRas(&pArgs->rlsRasLink);
    UnlinkFromTapi(&pArgs->tlsTapiLink);
   
    //
    // un-init password encryption, only if it is initialized
    //

    if (pArgs->fInitSecureCalled)
    {
        DeInitSecure();
        pArgs->fInitSecureCalled = FALSE;
    }
        
    //
    // Cleanup WatchProcess handles 
    //

    ProcessCleanup(pArgs);
    
    //
    // Release all paths loaded for connect. 
    //

    if (pArgs->pszRasPbk)
    {
        CmFree(pArgs->pszRasPbk);
        pArgs->pszRasPbk = NULL;
    }

    if (pArgs->pszRasHiddenPbk)
    {
        CmFree(pArgs->pszRasHiddenPbk);
        pArgs->pszRasHiddenPbk = NULL;
    }
    
    if(pArgs->pszVpnFile)
    {
        CmFree(pArgs->pszVpnFile);
        pArgs->pszVpnFile = NULL;        
    }

    if (pArgs->pRasDialExtensions)
    {
        CmFree(pArgs->pRasDialExtensions);
        pArgs->pRasDialExtensions = NULL;
    }

    if (pArgs->pRasDialParams)
    {
        CmFree(pArgs->pRasDialParams);
        pArgs->pRasDialParams = NULL;
    }

    if (pArgs->pszCurrentAccessPoint)
    {
        CmFree(pArgs->pszCurrentAccessPoint);
        pArgs->pszCurrentAccessPoint = NULL;
    }

    //
    // Cleanup Help by killing the help file window if any and releasing the help file
    // string.
    //
    if (pArgs->pszHelpFile)
    {
        CmWinHelp((HWND)NULL, (HWND)NULL, pArgs->pszHelpFile, HELP_QUIT, 0);
        CmFree(pArgs->pszHelpFile);
        pArgs->pszHelpFile = NULL;
    }

    //
    // Release Ini objects
    //
    
    ReleaseIniObjects(pArgs);

    //
    // Release OLE links if any
    //

    if (pArgs->olsOle32Link.hInstOle32 && pArgs->olsOle32Link.pfnOleUninitialize)
    {
        pArgs->olsOle32Link.pfnOleUninitialize();
    }
    
    UnlinkFromOle32(&pArgs->olsOle32Link);

    //
    // Release stats and table classes
    //

    if (pArgs->pConnStatistics)
    {
        delete pArgs->pConnStatistics;
    }

    if (pArgs->pConnTable)
    {
        MYVERIFY(SUCCEEDED(pArgs->pConnTable->Close()));
        delete pArgs->pConnTable;
    }
}

//
// Releases any resources allocated during initialization
//

void OnMainExit(ArgsStruct *pArgs) 
{
    //
    // Release bitmap resources for main dlg.  Make sure to send a STM_SETIMAGE with a NULL
    // bitmap pointer to clear out the window classes pointer to our memory.  Only then is it
    // safe to free it.
    //
    SendDlgItemMessageU(pArgs->hwndMainDlg, IDC_MAIN_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)NULL);
    ReleaseBitmapData(&pArgs->BmpData);

    if (pArgs->hMasterPalette)
    {
        UnrealizeObject(pArgs->hMasterPalette);
        DeleteObject(pArgs->hMasterPalette);
        pArgs->hMasterPalette = NULL;
    }

    //
    // Release icon resources
    //

    if (pArgs->hBigIcon) 
    {
        DeleteObject(pArgs->hBigIcon);
        pArgs->hBigIcon = NULL;
    }
    
    if (pArgs->hSmallIcon) 
    {
        DeleteObject(pArgs->hSmallIcon);
        pArgs->hSmallIcon = NULL;
    }

    if (pArgs->pszResetPasswdExe) 
    {
        CmFree(pArgs->pszResetPasswdExe);
        pArgs->pszResetPasswdExe = NULL;
    }

    if (pArgs->uiCurrentDnsTunnelAddr)
    {
        CmFree(pArgs->pucDnsTunnelIpAddr_list);
        pArgs->pucDnsTunnelIpAddr_list = NULL;
    }
    
    if (pArgs->rgwRandomDnsIndex)
    {
        CmFree(pArgs->rgwRandomDnsIndex);
        pArgs->rgwRandomDnsIndex = NULL;
    }
}

//
// GetPhoneByIdx: get phone number, etc. information from .cmp file
//
LPTSTR GetPhoneByIdx(ArgsStruct *pArgs, 
                     UINT nIdx, 
                     LPTSTR *ppszDesc, 
                     LPTSTR *ppszDUN, 
                     LPDWORD pdwCountryID,
                     LPTSTR *ppszRegionName,
                     LPTSTR *ppszServiceType,
                     LPTSTR *ppszPhoneBookFile,
                     LPTSTR *ppszCanonical,
                     DWORD  *pdwPhoneInfoFlags) 
{
    MYDBGASSERT(ppszCanonical);
    MYDBGASSERT(pdwPhoneInfoFlags);

    //
    // Note: ppszCanonical and pdwPhoneInfoFlags are now required parameters. 
    // While somewhat unfortunate, this is necessary to retain the integrity 
    // of the retrieved data as legacy handling forces us to return data
    // that may not be an exact representation of the profile contents.
    // For example, the ppszCanonical and pdwPhoneInfoFlags value may be modified
    // overridden in certain situations. Please see comments below for details.
    //

    int nMaxPhoneLen = 0;
    BOOL bTmp = FALSE;

    // service profile: .CMP file
    CIni iniTmp(pArgs->piniProfile->GetHInst(),pArgs->piniProfile->GetFile(), pArgs->piniProfile->GetRegPath());

    iniTmp.SetEntryFromIdx(nIdx);
    
    //
    // Set the read flags
    //
    if (pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_READ_ICS_DATA)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);

        if (pszICSDataReg)
        {
            iniTmp.SetReadICSData(TRUE);
            iniTmp.SetICSDataPath(pszICSDataReg);
        }

        CmFree(pszICSDataReg);
    }

    LPTSTR pszTmp = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhonePrefix);

    if (ppszDesc) 
    {
        *ppszDesc = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhoneDescPrefix);
    }
    if (ppszDUN) 
    {
        *ppszDUN = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhoneDunPrefix);
    }
    if (pdwCountryID) 
    {
        *pdwCountryID = iniTmp.GPPI(c_pszCmSection,c_pszCmEntryPhoneCountryPrefix);
    }
    if (ppszPhoneBookFile) 
    {
        LPTSTR pszPb = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhoneSourcePrefix);
        
        //
        // If the value is empty, just store the ptr
        //
        
        if ((!*pszPb)) 
        {
            *ppszPhoneBookFile = pszPb;
        }
        else
        {
            *ppszPhoneBookFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszPb);
            CmFree(pszPb);
        }
    }
    if (ppszRegionName) 
    {
        *ppszRegionName = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryRegion);
    }
    if (ppszServiceType) 
    {
        *ppszServiceType = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryServiceType);
    }

    //
    // Get the extended form of the telephone number.
    //
    
    if (ppszCanonical) 
    {
        *ppszCanonical = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryPhoneCanonical);
    }
    
    //
    // Set the phoneinfo flags
    //

    if (pdwPhoneInfoFlags)
    {
        *pdwPhoneInfoFlags = 0;

        //
        // Get the dial as long distance flag. Check CMS if no value found. 
        //

        int iTmp = iniTmp.GPPI(c_pszCmSection, c_pszCmEntryUseDialingRules, -1);
    
        if (-1 == iTmp)
        {
            iTmp = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryUseDialingRules, 1);                        
        }

        if (iTmp)
        {
            *pdwPhoneInfoFlags |= PIF_USE_DIALING_RULES;
        }
    }
    
    // 
    // Truncate phone string if we have one. 
    // Note: Admin can override our default, but we
    // must stay within RAS_MaxPhoneNumber chars.
    // 

    if (pszTmp && *pszTmp)
    {
        int nDefaultPhoneLen = (OS_NT ? MAX_PHONE_LENNT : MAX_PHONE_LEN95);
    
        nMaxPhoneLen = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPhoneNumber, nDefaultPhoneLen);
    
        nMaxPhoneLen = __min(nMaxPhoneLen, RAS_MaxPhoneNumber);
    
        if ((int)lstrlenU(pszTmp) > nMaxPhoneLen)
        {
            pszTmp[nMaxPhoneLen] = TEXT('\0');
        }
    }

    //
    // Special handling for the case where we have a Phone number
    // but the CanonicalPhone value doesn't exist. This indicates 
    // that its either a legacy profile or a hand-edit. 
    //
        
    if (pszTmp && *pszTmp && ppszCanonical && *ppszCanonical && (!(**ppszCanonical)))
    {   
        //
        // This block is for handling LEGACY numbers only. If we detect a 
        // canonically formatted number (begins with "+"), then we re-format 
        // the number to fit our new scheme. Hand-edits are not modified, 
        // but PIF_USE_DIALING_RULES is turned off, which overrides the 
        // default setting for the flag (if any) specified in
        // the .CMS
        //

        if (pszTmp == CmStrchr(pszTmp, TEXT('+')))
        {
            *pdwPhoneInfoFlags |= PIF_USE_DIALING_RULES;

            if (*ppszCanonical)
            {
                CmFree(*ppszCanonical);
            }

            *ppszCanonical = CmStrCpyAlloc(pszTmp);

            StripCanonical(pszTmp);
        }
        else
        {
            *pdwPhoneInfoFlags &= ~PIF_USE_DIALING_RULES; // #284702
        }

    }

    return (pszTmp);
}


// write phone number dialing options to .CMP file

void PutPhoneByIdx(ArgsStruct *pArgs, 
                   UINT nIdx, 
                   LPCTSTR pszPhone, 
                   LPCTSTR pszDesc, 
                   LPCTSTR pszDUN, 
                   DWORD dwCountryID,
                   LPCTSTR pszRegionName,
                   LPCTSTR pszServiceType,
                   LPCTSTR pszPhoneBookFile,
                   LPCTSTR pszCanonical,
                   DWORD dwPhoneInfoFlags) 
{

    CIni iniTmp(pArgs->piniProfile->GetHInst(), pArgs->piniProfile->GetFile(), pArgs->piniProfile->GetRegPath());

    iniTmp.SetEntryFromIdx(nIdx);
    
    //
    // Set the write flags
    //
    if (pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_WRITE_ICS_DATA)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);

        if (pszICSDataReg)
        {
            iniTmp.SetWriteICSData(TRUE);
            iniTmp.SetICSDataPath(pszICSDataReg);
        }

        CmFree(pszICSDataReg);
    }

    //
    // Store the raw form of the number
    //

    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhonePrefix, pszPhone);

    //
    // Store the canonical form of the number
    //
    
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneCanonical, pszCanonical);

    
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneDescPrefix, pszDesc);
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneDunPrefix, pszDUN);
    iniTmp.WPPI(c_pszCmSection, c_pszCmEntryPhoneCountryPrefix, dwCountryID);
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryRegion, pszRegionName);
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryServiceType, pszServiceType);
    
    //
    // If there is a phonebookfile path, convert it to relative form
    //

    if (pszPhoneBookFile && *pszPhoneBookFile)
    {
        LPTSTR pszTmp = ReducePathToRelative(pArgs, pszPhoneBookFile);    

        if (pszTmp)
        {
            iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneSourcePrefix, pszTmp);
        }

        CmFree(pszTmp);
    }

    iniTmp.WPPB(c_pszCmSection, c_pszCmEntryUseDialingRules, (dwPhoneInfoFlags & PIF_USE_DIALING_RULES));
}

//+----------------------------------------------------------------------------
//
// Function:  LoadPhoneInfoFromProfile
//
// Synopsis:  Load phone number information for profile to the dial info structure
//
// Arguments: ArgsStruct *pArgs - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    3/5/98
//
//+----------------------------------------------------------------------------
void LoadPhoneInfoFromProfile(ArgsStruct *pArgs)
{
    for (int nPhoneIdx=0; nPhoneIdx<MAX_PHONE_NUMBERS; nPhoneIdx++) 
    {
        LPTSTR pszDUN = NULL;
        LPTSTR pszDesc = NULL;
        LPTSTR pszPhoneBookFile = NULL;
        LPTSTR pszRegionName = NULL;
        LPTSTR pszServiceType = NULL;
        LPTSTR pszCanonical = NULL;
        DWORD dwCountryID;
        DWORD dwPhoneInfoFlags;

        //
        // get phone nubmer by index; Phone0, Phone1 , etc...
        //

        LPTSTR pszPhone = GetPhoneByIdx(pArgs, 
                                    nPhoneIdx, 
                                    &pszDesc, 
                                    &pszDUN, 
                                    &dwCountryID, 
                                    &pszRegionName, 
                                    &pszServiceType,
                                    &pszPhoneBookFile,
                                    &pszCanonical,
                                    &dwPhoneInfoFlags);

        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szPhoneNumber, pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szPhoneNumber));

        pArgs->aDialInfo[nPhoneIdx].dwCountryID = dwCountryID;
        
        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDUN, pszDUN, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDUN));

        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szPhoneBookFile,
                pszPhoneBookFile, CELEMS(pArgs->aDialInfo[nPhoneIdx].szPhoneBookFile));
        
        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDesc, pszDesc, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDesc));
        
        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szRegionName, 
                pszRegionName, CELEMS(pArgs->aDialInfo[nPhoneIdx].szRegionName));
        
        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szServiceType,
                pszServiceType, CELEMS(pArgs->aDialInfo[nPhoneIdx].szServiceType));
        
        lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szCanonical,
                pszCanonical, CELEMS(pArgs->aDialInfo[nPhoneIdx].szCanonical));
        
        pArgs->aDialInfo[nPhoneIdx].dwPhoneInfoFlags = dwPhoneInfoFlags;
    
        // Cleanup
        
        CmFree(pszDUN);
        CmFree(pszPhone);
        CmFree(pszDesc);
        CmFree(pszPhoneBookFile);
        CmFree(pszRegionName); 
        CmFree(pszServiceType);
        CmFree(pszCanonical);

    } // for loop
}

//+----------------------------------------------------------------------------
//
// Function:  LoadDialInfo
//
// Synopsis: load dialup information 
//
// Arguments: ArgsStruct *pArgs     - Ptr to glbal Args struct
//            HWND hwndDlg          - HWND of main dialog
//            BOOL fInstallModem    - Whether we should check modem isntall
//            BOOL fAlwaysMunge     - Whether we should munge the phone number
//
// Returns:   DWORD - ERROR_SUCCESS if load successfuly
//                    ERROR_PORT_NOT_AVAILABLE if can not find any modem
//                    ERROR_BAD_PHONE_NUMBER either there is no primary phone #
//                                        or failed to convert it to dialable #
//
// History:   10/24/97  fengsun  Created Header and change return type to DWORD 
//            02/08/99  nickball Added fAlwaysMunge
//
//+----------------------------------------------------------------------------
DWORD LoadDialInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fInstallModem, BOOL fAlwaysMunge) 
{
    DWORD dwRet = ERROR_SUCCESS;

    if (pArgs->bDialInfoLoaded)
    {
        if (pArgs->aDialInfo[0].szDialablePhoneNumber[0] == TEXT('\0') &&
            pArgs->aDialInfo[1].szDialablePhoneNumber[0] == TEXT('\0'))
        {
            return ERROR_BAD_PHONE_NUMBER;
        }
        else
        {            
            //
            // If fAlways munge is set, then stick around.
            //

            if (!fAlwaysMunge)
            {
                return ERROR_SUCCESS;
            }
        }   
    }

    //
    // Don't need to repeat ourselves
    //

    if (!pArgs->bDialInfoLoaded)
    {
        pArgs->fNoDialingRules = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmNoDialingRules);

        //
        // Do a full test on just the modem
        //
   
        if (fInstallModem)
        {
            pArgs->dwExitCode = CheckAndInstallComponents(CC_MODEM, hwndDlg, pArgs->szServiceName, (pArgs->dwFlags & FL_UNATTENDED));

            if (pArgs->dwExitCode != ERROR_SUCCESS)
            {      
                dwRet = ERROR_PORT_NOT_AVAILABLE;
                goto LoadDialInfoExit;
            }
        }

        //
        // Establish TAPI link before we continue
        //

        if (!LinkToTapi(&pArgs->tlsTapiLink, "TAPI32") )
        {
            //
            // Link to TAPI failed.  
            // If unattended, return with failure.
            // Otherwise, try to install components and LinkToTapi again
            //

            pArgs->dwExitCode = ERROR_PORT_NOT_AVAILABLE;

            if (!(pArgs->dwFlags & FL_UNATTENDED))
            {
                pArgs->dwExitCode = CheckAndInstallComponents(CC_MODEM | CC_RNA | CC_RASRUNNING, 
                                                              hwndDlg, pArgs->szServiceName);
            }

            if (pArgs->dwExitCode != ERROR_SUCCESS || !LinkToTapi(&pArgs->tlsTapiLink, "TAPI32"))
            {
                pArgs->szDeviceType[0] = TEXT('\0');
                pArgs->szDeviceName[0] = TEXT('\0');
                dwRet = ERROR_PORT_NOT_AVAILABLE;
                goto LoadDialInfoExit;
            }
        }

        //
        // RasEnumDevice and LineInitialize is SLOW.  It takes 50% of the start-up time
        //
        if (!PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName)) 
        {
            //
            // Because pick modem failed we need to check if we have RAS/Modem installed
            //
            ClearComponentsChecked();

            //
            // No modem is installed.  
            // If unattended or caller does not want to install modem, return with failure.
            // Otherwise, try to install the modem and call pick modem again
            //
            pArgs->dwExitCode = ERROR_PORT_NOT_AVAILABLE;

            if (!(pArgs->dwFlags & FL_UNATTENDED) && fInstallModem)
            {
                pArgs->dwExitCode = CheckAndInstallComponents(CC_MODEM | CC_RNA | CC_RASRUNNING, 
                                                              hwndDlg, pArgs->szServiceName);
            }

            if (pArgs->dwExitCode != ERROR_SUCCESS || 
                    !PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName))
            {
                pArgs->szDeviceType[0] = TEXT('\0');
                pArgs->szDeviceName[0] = TEXT('\0');
                dwRet = ERROR_PORT_NOT_AVAILABLE;
                goto LoadDialInfoExit;
            }
        }
    }

    
    //
    // See if munge is required and Cleanup as needed
    //

    if (!pArgs->bDialInfoLoaded || TRUE == fAlwaysMunge)
    {
        MungeDialInfo(pArgs);

        pArgs->bDialInfoLoaded = TRUE;
    }

    if (pArgs->aDialInfo[0].szDialablePhoneNumber[0] == TEXT('\0') &&
        pArgs->aDialInfo[1].szDialablePhoneNumber[0] == TEXT('\0'))
    {
        dwRet = ERROR_BAD_PHONE_NUMBER;
    }

LoadDialInfoExit:

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Function: MungeDialInfo
//
// Synopsis: Encapsulates the munging of the phone numbers prior to dialing
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing - Check Dialable string and fNeedConfigureTapi
//
// History:   02/08/99 nickball Created - pulled from LoadDialInfo
//
//+----------------------------------------------------------------------------
VOID MungeDialInfo(ArgsStruct *pArgs)
{
    for (int nPhoneIdx=0; nPhoneIdx<MAX_PHONE_NUMBERS; nPhoneIdx++) 
    {
        //
        // If dialing rules is disabled, then just use the NonCanonical #
        //

        if (pArgs->fNoDialingRules)      
        {
            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber,
                        pArgs->aDialInfo[nPhoneIdx].szPhoneNumber, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber));

            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber,
                        pArgs->aDialInfo[nPhoneIdx].szPhoneNumber, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber));

            pArgs->aDialInfo[nPhoneIdx].szCanonical[0] = TEXT('\0');

            continue;
        }
                
        LPTSTR pszDialableString= NULL;

        //
        // Retrieve the number based upon dialing rules and munge it.
        //
        
        LPTSTR pszPhone;
            
        if (pArgs->aDialInfo[nPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
        {
            pszPhone = CmStrCpyAlloc(pArgs->aDialInfo[nPhoneIdx].szCanonical);
        }
        else
        {
            pszPhone = CmStrCpyAlloc(pArgs->aDialInfo[nPhoneIdx].szPhoneNumber);
        }

        if (pszPhone && pszPhone[0])
        {
            //
            // If we can't munge the number, display an error
            // 

            if (pArgs->szDeviceName[0] && 
                ERROR_SUCCESS != MungePhone(pArgs->szDeviceName,
                                            &pszPhone,
                                            &pArgs->tlsTapiLink,
                                            g_hInst,
                                            pArgs->aDialInfo[nPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES,
                                            &pszDialableString,
                                            pArgs->fAccessPointsEnabled))
            {
                CmFree(pszPhone);
                pszPhone = CmStrCpyAlloc(TEXT(""));          // CmFmtMsg(g_hInst,IDMSG_CANTFORMAT);
                pszDialableString = CmStrCpyAlloc(TEXT("")); // CmFmtMsg(g_hInst,IDMSG_CANTFORMAT);
            }
            else if (!pszDialableString || pszDialableString[0] == '\0')
            {                
                //
                // So what happened now? pszPhone is not empty, but after
                // we munge the phone, which means applying TAPI rules, 
                // pszDialbleString becomes empty. This means only one 
                // thing: TAPI isn't intialized.
                //
                // Note: If you uninstall TAPI between launching the app.
                // and pressing connect, all bets are off with the above.
                //
                // This flag will be reset in CheckTapi(), which will put
                // up a TAPI configuration dialog and ask the user to fill
                // up such information
                //
            
                pArgs->fNeedConfigureTapi = TRUE;    
            }
        } 

        // Copy the munged number
        
        //
        // Unless explicitly disabled we always apply TAPI rules
        // in order to pick up TONE/PULSE, etc.
        //

        if (NULL != pszDialableString)
        {
            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber,
                    pszDialableString, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber));

            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber,
                    pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber));
        }
        else
        {
            if (NULL != pszPhone)
            {
                //
                // Just do it on WIN32 because our TAPI checks were done above  
                //

                lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber,
                        pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber));

                lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber,
                        pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber));
            }
        }
        
        CmFree(pszPhone);
        CmFree(pszDialableString);

    } // for loop
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadHelpFileInfo
//
//  Synopsis:   Load the help file name
//
//  Arguments:  pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     3/5/97
//              byao    Modified    3/20/97     to handle empty helpfile string
//----------------------------------------------------------------------------
void LoadHelpFileInfo(ArgsStruct *pArgs) 
{
    MYDBGASSERT(pArgs);
    
    //
    // Look for a custom helpfile name, otherwise use default.
    //

    LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryHelpFile);
   
    if (NULL == pszTmp || 0 == pszTmp[0])
    {
        CmFree(pszTmp);
        pszTmp = CmStrCpyAlloc(c_pszDefaultHelpFile);
    }

    //
    // Make sure that any relative path is converted to full
    //

    pArgs->pszHelpFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);
    
    CmFree(pszTmp);
}

//
// CopyPhone: 
//
void CopyPhone(ArgsStruct *pArgs, 
               LPRASENTRY preEntry, 
               DWORD dwEntry) 
{
    LPTSTR pszPhone = NULL;
    LPTSTR pszCanonical = NULL;
    LPTSTR pszTmp;
    LPTSTR pszDescription = NULL;
    BOOL Setcountry = FALSE;
    DWORD dwPhoneInfoFlags = 0;

    pszPhone = GetPhoneByIdx(pArgs,(UINT) dwEntry, &pszDescription, 
                                NULL, NULL, NULL, 
                                NULL, NULL, &pszCanonical, &dwPhoneInfoFlags);
    //
    // If "Use Dialing Rules" turn of CountryAndAreaCodes option
    // 

    if (dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
    {
        //
        // We want to use dialing rules, so parse the canonical form 
        // of the number to get the country and area codes for the entry
        //
        
        pszTmp = CmStrchr(pszCanonical,TEXT('+'));
        if (pszTmp) 
        {
            preEntry->dwCountryCode = CmAtol(pszTmp+1);
            
            //
            // NOTE: Currently CM uses code and ID interchangeably
            // The countryID value in the .CMP is actually the country
            // code used when constructing the phone number in its
            // canonical format. This is probably not entirely correct
            // but we maitain consistency with it here by using the 
            // country code parsed from the number as the country ID.
            //

            preEntry->dwCountryID = preEntry->dwCountryCode; 

            preEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
            Setcountry = TRUE;
        }
    
        if (Setcountry)
        {
            pszTmp = CmStrchr(pszCanonical,'('); //strip out area code
            if (pszTmp) 
            {
                wsprintfU(preEntry->szAreaCode, TEXT("%u"), CmAtol(pszTmp+1));
            }
            pszTmp = CmStrchr(pszCanonical,')');
            if (pszTmp) 
            {
                ++pszTmp;
                while(*pszTmp == ' ') 
                    ++pszTmp; //remove whitespace
            }
            else
            { 
                // no area code

                preEntry->szAreaCode[0]=TEXT('\0');

                pszTmp = CmStrchr(pszCanonical,' ');
                if (pszTmp)
                {
                    while(*pszTmp == ' ') 
                        ++pszTmp; // skip past space - may need MBCS change
                }
            }
        }
    }
    else
    {
        //
        // Use the straight up phone number and don't apply rules
        //

        preEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;
        pszTmp = pszPhone;
    }

    if ((NULL != pszTmp) && *pszTmp)
    {
        lstrcpynU(preEntry->szLocalPhoneNumber, pszTmp, CELEMS(preEntry->szLocalPhoneNumber));
    }
    else
    {
        lstrcpynU(preEntry->szLocalPhoneNumber, TEXT(" "), CELEMS(preEntry->szLocalPhoneNumber));//prevent zero from appearing
    }

    CmFree(pszPhone);
    CmFree(pszCanonical);
    CmFree(pszDescription);
}


//+----------------------------------------------------------------------------
//
// Function:  AppendStatusPane
//
// Synopsis:  Append the text to the main dialog status window
//
// Arguments: HWND hwndDlg - The main dialog window handle
//            DWORD dwMsgId - The resource id of the message
//
// Returns:   Nothing
//
// History:   Created Header    10/24/97
//
//+----------------------------------------------------------------------------
void AppendStatusPane(HWND hwndDlg, 
                  DWORD dwMsgId) 
{
    LPTSTR pszTmp = CmFmtMsg(g_hInst,dwMsgId);

    if (pszTmp != NULL)
    {
        AppendStatusPane(hwndDlg,pszTmp);
        CmFree(pszTmp);
    }
}

//
// AppendStatusPane: Update the original status, append new message 'pszMsg' 
// at the end
//

void AppendStatusPane(HWND hwndDlg, 
                        LPCTSTR pszMsg) 
{
    size_t nLines;

    //
    // Get the existing message 
    //
    
    LPTSTR pszStatus = CmGetWindowTextAlloc(hwndDlg, IDC_MAIN_STATUS_DISPLAY);
   
    LPTSTR pszTmp = CmStrrchr(pszStatus, TEXT('\n'));
    
    if (!pszTmp) 
    { 
        // empty message, so simply display 'pszMsg'
        CmFree(pszStatus);
        SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY,pszMsg);
        //
        // force an update right away
        //
        UpdateWindow(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY));
        return;
    }

    pszTmp[1] = 0;
    CmStrCatAlloc(&pszStatus,pszMsg); // append pszMsg at the end of old message
    nLines = 0;
    pszTmp = pszStatus + lstrlenU(pszStatus);
    
    while (pszTmp != pszStatus) 
    {
        pszTmp--;
        if (*pszTmp == '\n') 
        {
            if (++nLines == 2) 
            {
                lstrcpyU(pszStatus,pszTmp+1);
                break;
            }
        }
    }
    
    SetDlgItemTextU(hwndDlg,IDC_MAIN_STATUS_DISPLAY,pszStatus);
    SendDlgItemMessageU(hwndDlg,IDC_MAIN_STATUS_DISPLAY,EM_SCROLL,SB_PAGEDOWN,0);
    CmFree(pszStatus);
    //
    // force an update right away
    //
    UpdateWindow(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY));
}

// bitmap logo loading code - took this out of LoadFromFile so it can
// be called in multiple cases - like when the FS OC loading code
// fails, we can degrade gracefully with this.

VOID LoadLogoBitmap(ArgsStruct * pArgs, 
                    HWND hwndDlg)
{
    LPTSTR pszTmp;

    pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryLogo);
    if (*pszTmp) 
    {
        //
        // Make sure we have a full path (if appropriate) and load logo bitmap
        //

        LPTSTR pszFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);

        pArgs->BmpData.hDIBitmap = CmLoadBitmap(g_hInst, pszFile);

        CmFree(pszFile);
    }
    
    CmFree(pszTmp);
    
    if (!pArgs->BmpData.hDIBitmap)
    {
        pArgs->BmpData.hDIBitmap = CmLoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_APP));
    }

    //
    // If we have a handle, create a new Device Dependent bitmap 
    //
    
    if (pArgs->BmpData.hDIBitmap)
    {       
        pArgs->BmpData.phMasterPalette = &pArgs->hMasterPalette;
        pArgs->BmpData.bForceBackground = TRUE; // paint as a background app

        if (CreateBitmapData(pArgs->BmpData.hDIBitmap, &pArgs->BmpData, hwndDlg, TRUE))
        {
            SendDlgItemMessageU(hwndDlg,IDC_MAIN_BITMAP,STM_SETIMAGE,IMAGE_BITMAP,
                                (LPARAM) &pArgs->BmpData);
        }
    }
}

const LONG MAX_SECTION   = 512;

HRESULT LoadFutureSplash(ArgsStruct * pArgs, 
                         HWND hwndDlg)
{
    // set up the Future Splash OC container.
    LPCTSTR pszFile = pArgs->piniBoth->GetFile();
    TCHAR   achSections[MAX_SECTION] = {0};
    HRESULT hr;
    LPTSTR  pszVal = NULL;
    LPTSTR  pszTmp = NULL;
    LPICMOCCtr pCtr;

    HWND hDlgItem = ::GetDlgItem(hwndDlg, IDC_MAIN_BITMAP);

    if (NULL == hDlgItem)
    {
        hr = E_FAIL;
        goto Cleanup;        
    }

    pArgs->pCtr = new CICMOCCtr(hwndDlg, hDlgItem);
    if (!pArgs->pCtr)
    {
        goto MemoryError;
    }

    if (!pArgs->pCtr->Initialized())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pCtr = pArgs->pCtr;

    if (!::GetPrivateProfileStringU(
            c_pszCmSectionAnimatedLogo,
            0,
            TEXT(""),
            achSections,
            NElems(achSections),
            pszFile))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pszVal = (LPTSTR) CmMalloc(INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
    if (NULL == pszVal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pszTmp = achSections;

    while (pszTmp[0])
    {
        // if this fails, we keep on looping, looking for
        // the next one.
        if (::GetPrivateProfileStringU(
               c_pszCmSectionAnimatedLogo,
               pszTmp,
               TEXT(""),
               pszVal,
               INTERNET_MAX_URL_LENGTH, // number of TCHARS in pszVal
               pszFile))
        {
            if (lstrcmpiU(pszTmp, c_pszCmEntryAniMovie) == 0) // is this the 'movie' entry?
            {    
                //
                // Build full path from .CMP and relative path
                //
            
                LPTSTR pszMovieFileName = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszVal);

                if (!pszMovieFileName)
                {
                    hr = S_FALSE;
                    CmFree(pszMovieFileName);
                    goto Cleanup;           
                }

                //
                // Does this file exist?
                //

                if (FALSE == FileExists(pszMovieFileName))
                {
                    hr = S_FALSE;
                    CmFree(pszMovieFileName);
                    goto Cleanup;
                }
                lstrcpyU(pszVal, pszMovieFileName);  // store the full pathname back 
                CmFree(pszMovieFileName);
            }
            hr = pCtr->AddPropertyToBag(pszTmp, pszVal);
            if (S_OK != hr)
                goto Cleanup;
        }
        
        // get the next key name.
        pszTmp += (lstrlenU(pszTmp) + 1);
    }

    // create the Future Splash OC.
    hr = pCtr->CreateFSOC(&pArgs->olsOle32Link);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    // now, do the state mappings, no matter what happens, we won't
    // fail on this.  just keep on going.

    pCtr->SetFrameMapping(PS_Interactive, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsInteractive, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Dialing, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsDialing0, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_RedialFrame, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsDialing1, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Pausing, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsPausing, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Authenticating, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsAuthenticating, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Online, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsOnline, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_TunnelDialing, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsTunnel, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Error, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsError, 
                                                  -1, 
                                                  pszFile));    
Cleanup:
    if (pszVal)
    {
        CmFree(pszVal);
    }
    return hr;                                        

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadProperties
//
//  Synopsis:   This func loads CM Properties from cmp/cms, registry, password
//              cache, etc, into its internal variables.  This func should
//              only be called once.  This should not be specific to the main
//              sign-in dlg.  DO NOT do any icon/bitmap stuff, dlg specific 
//              stuff here.
//
//  Arguments:  pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     5/2/97
//
//              t-urama Modified    08/02/00    Added Access Points
//----------------------------------------------------------------------------
void LoadProperties(
    ArgsStruct  *pArgs
)
{
    LPTSTR  pszTmp = NULL;
    LPTSTR  pszUserName = NULL;
    UINT    nTmp;

    CMTRACE(TEXT("Begin LoadProperties()"));

    //
    // First make sure we can use the RAS CredStore
    // This flag is used in the calls below
    //
    if (OS_NT5)
    {
        pArgs->bUseRasCredStore = TRUE;
    }

    //
    // Upgrade userinfo if necessary.  Note that we have
    // an upgrade from CM 1.0/1.1 cmp data and we also
    // have an upgrade of CM 1.2 registry data to
    // the method used in CM 1.3 on Win2k which uses both
    // the registry and RAS credential storage.
    //
    int iUpgradeType = NeedToUpgradeUserInfo(pArgs);

    if (c_iUpgradeFromRegToRas == iUpgradeType)
    {
        UpgradeUserInfoFromRegToRasAndReg(pArgs);
    }
    else if (c_iUpgradeFromCmp == iUpgradeType)
    {
        UpgradeUserInfoFromCmp(pArgs);
    }

    //
    // Need to refresh Credential support. The TRUE flag also sets the current creds
    // type inside the function. If an error occurs we can keep executing.
    //
    if(FALSE == RefreshCredentialTypes(pArgs, TRUE))
    {
        CMTRACE(TEXT("LoadProperties() - Error refreshing credential types."));
    }


    if (IsTunnelEnabled(pArgs)) 
    { 
        //
        // do we use the same username/password for tunneling?
        // This value is set by ISP, CM does not change it
        //
        pArgs->fUseSameUserName = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseSameUserName);

        //
        // read in inet username
        // Special case where the same user name isn't being used, and internet globals don't exist
        // Then we have to read the user name from the user creds store in order to pre-populate
        //
        DWORD dwRememberedCredType = pArgs->dwCurrentCredentialType;
        pszUserName = NULL;
        if ((FALSE == pArgs->fUseSameUserName) &&
            (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType) &&
            (FALSE == (BOOL)(CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)))
        {
            pArgs->dwCurrentCredentialType = CM_CREDS_USER;
        }

        GetUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszUserName);

        //
        // Restore credential store
        //
        pArgs->dwCurrentCredentialType = dwRememberedCredType;

        if (pszUserName)
        {
            //
            // check username length
            //
            nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
            if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
            {
                CmFree(pszUserName);
                pArgs->szInetUserName[0] = TEXT('\0');
                SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szInetUserName);
            }
            else
            {
                lstrcpyU(pArgs->szInetUserName, pszUserName);
                CmFree(pszUserName);
            }
        }
        else
        {
            *pArgs->szInetUserName = TEXT('\0');
        }
        
        //
        // Read in inet password unless we are reconnecting in which case, we
        // already have the correct password, and we want to use it and dial
        // automatically. 
        //

        if (!(pArgs->dwFlags & FL_RECONNECT))
        {
            LPTSTR pszPassword = NULL;
            GetUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszPassword);
            if (!pszPassword)
            {
                (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));
            }
            else 
            {
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
                if ((UINT)lstrlenU(pszPassword) > __min(PWLEN, nTmp))
                {
                    CmFree(pszPassword);
                    pszPassword = CmStrCpyAlloc(TEXT(""));
                }
                
                (VOID)pArgs->SecureInetPW.SetPassword(pszPassword);

                CmWipePassword(pszPassword);
                CmFree(pszPassword);
            }
        }
    }
    
    //
    // The presence of either lpRasNoUser or lpEapLogonInfo indicates
    // that we retrieved credentials via WinLogon. We ignore cached 
    // creds in this situation.   
    //
    
    if ((!pArgs->lpRasNoUser) && (!pArgs->lpEapLogonInfo))
    {
        //
        // get username, domain, etc. from CMS file
        //

        GetUserInfo(pArgs, UD_ID_USERNAME, (PVOID*)&pszUserName);
        if (pszUserName)
        {
            //
            // check username length
            //
            nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
            if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
            {
                CmFree(pszUserName);
                pszUserName = CmStrCpyAlloc(TEXT(""));
                SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pszUserName);
            }
            lstrcpyU(pArgs->szUserName, pszUserName);
            CmFree(pszUserName);
        }
        else
        {
            *pArgs->szUserName = TEXT('\0');
        }

        //
        // Read in the standard password unless we are reconnecting in which case 
        // we already have the correct password, and we want to use it and dial
        // automatically. 
        //

        if (!(pArgs->dwFlags & FL_RECONNECT))
        {
            pszTmp = NULL;
            GetUserInfo(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp);
            if (pszTmp) 
            {           
                //
                // max length for user password
                //
    
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection,c_pszCmEntryMaxPassword,PWLEN);
                if ((UINT)lstrlenU(pszTmp) > __min(PWLEN,nTmp)) 
                {
                    CmFree(pszTmp);
                    pszTmp = CmStrCpyAlloc(TEXT(""));
                }

                (VOID)pArgs->SecurePW.SetPassword(pszTmp);

                CmWipePassword(pszTmp);
                CmFree(pszTmp);
            }
            else
            {
                (VOID)pArgs->SecurePW.SetPassword(TEXT(""));
            }
        }
    
        //
        // Load domain info
        //
   
        LPTSTR pszDomain = NULL;

        GetUserInfo(pArgs, UD_ID_DOMAIN, (PVOID*)&pszDomain);
        if (pszDomain)
        {
            nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);
        
            if (nTmp <= 0)
            {
                nTmp = DNLEN;
            }
        
            if ((UINT)lstrlenU(pszDomain) > __min(DNLEN, nTmp))
            {
                CmFree(pszDomain);
                pszDomain = CmStrCpyAlloc(TEXT(""));
            }
            lstrcpyU(pArgs->szDomain, pszDomain);
            CmFree(pszDomain);
        }
        else
        {
            *pArgs->szDomain = TEXT('\0');
        }
    } 

    //
    //  fDialAutomatically,
    //  fRememberMainPassword
    //
    if (pArgs->fHideDialAutomatically)
    {
        pArgs->fDialAutomatically = FALSE;
    }
    else
    {
        PVOID pv = &pArgs->fDialAutomatically;
        GetUserInfo(pArgs, UD_ID_NOPROMPT, &pv);
    }

    if (pArgs->fHideRememberPassword)
    {
        pArgs->fRememberMainPassword = FALSE;
    }
    else
    {
        //
        // For Win2K+ this gets trickier because we use the RAS cred store and 
        // we know which creds were saved. Thus we need to modify this flag according
        // to what credentials we actually have, insted of what was retrieved from the registry/file.
        // This needs to be done after calling the function that refreshes credential types (above).
        //
        if (OS_NT5)
        {
            if (CM_CREDS_USER == pArgs->dwCurrentCredentialType)
            {
                pArgs->fRememberMainPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER)? TRUE: FALSE);
            }
            else
            {
                pArgs->fRememberMainPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_GLOBAL)? TRUE: FALSE);
            }
        }
        else
        {
            PVOID pv = &pArgs->fRememberMainPassword;
            GetUserInfo(pArgs, UD_ID_REMEMBER_PWD, &pv);
        }
    }
    
    //
    // remember non-tunnel password?
    //
    if (pArgs->fHideRememberInetPassword)
    {
        pArgs->fRememberInetPassword = FALSE;
    }
    else
    {
        //
        // For Win2K+ this gets trickier because we use the RAS cred store and 
        // we know which creds were saved. Thus we need to modify this flag according
        // to what credentials we actually have, insted of what was retrieved from the registry/file.
        // This needs to be done after calling the function that refreshes credential types (above).
        //
        if (OS_NT5)
        {
            if (CM_CREDS_USER == pArgs->dwCurrentCredentialType)
            {
                pArgs->fRememberInetPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)? TRUE: FALSE);
            }
            else
            {
                pArgs->fRememberInetPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_GLOBAL)? TRUE: FALSE);
            }
        }
        else
        {
            PVOID pv = &pArgs->fRememberInetPassword;
            GetUserInfo(pArgs, UD_ID_REMEMBER_INET_PASSWORD, &pv);
        }
    }

    //
    // Make sure that the passwords are empty if we don't want to remember them
    // unless we are reconnecting in which case we will just use what we have
    // from the previous connection. When the log on type is ICS don't want
    // to clear the passwords either.
    //
    if ((!(pArgs->dwFlags & FL_RECONNECT)) &&
        (!pArgs->lpRasNoUser) &&
        (!pArgs->lpEapLogonInfo) &&
        (CM_LOGON_TYPE_ICS != pArgs->dwWinLogonType))
    {
        //
        // NULL the password if dial-auto is disabled.
        //

        if (!pArgs->fRememberMainPassword)
        {
            (VOID)pArgs->SecurePW.SetPassword(TEXT(""));
        }

        if (!pArgs->fRememberInetPassword)
        {
            (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));
        }
    }
    
    //
    // has references
    //
    pszTmp = pArgs->piniService->GPPS(c_pszCmSectionIsp, c_pszCmEntryIspReferences);
    pArgs->fHasRefs = (pszTmp && *pszTmp ? TRUE : FALSE);
    CmFree(pszTmp);

    //
    // do we have valid pbk's?
    //
    pArgs->fHasValidTopLevelPBK = ValidTopLevelPBK(pArgs);
    if (pArgs->fHasRefs)
    {
        pArgs->fHasValidReferencedPBKs = ValidReferencedPBKs(pArgs);
    }

    //
    // Get idle settings for auto disconnect
    // 1.0 profile has a BOOL flag "Idle", if FALSE, IdleTimeout is ignored
    //

    if (!pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryIdle, TRUE))
    {
        //
        // If this is a 1.0 profile and Idle==0, set IdleTimeout to 0, so CMMOM works correctly
        //
        pArgs->dwIdleTimeout = 0;    // never timeout

        pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryIdle, TRUE); // write back
        pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryIdleTimeout, 0); // write back
    }
    else
    {
        pArgs->dwIdleTimeout = (int) pArgs->piniBothNonFav->GPPI(c_pszCmSection, 
                                                                 c_pszCmEntryIdleTimeout, 
                                                                 DEFAULT_IDLETIMEOUT);
    }

    //
    // get redial count
    // 1.0 profile has a BOOL flag "Redial", if FALSE, RedialCount is ignored
    //
    if (!pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryRedial, TRUE))
    {
        //
        // If this is a 1.0 profile and Redial==0, set RetryCount to 0
        //
        pArgs->nMaxRedials = 0;



        pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryRedialCount, 0); // write back
    }
    else
    {
        pArgs->nMaxRedials = (int) pArgs->piniBothNonFav->GPPI(c_pszCmSection, 
                                                               c_pszCmEntryRedialCount, 
                                                               DEFAULT_REDIALS);

        if (pArgs->nMaxRedials > MAX_NUMBER_OF_REDIALS)
        {
             pArgs->nMaxRedials = MAX_NUMBER_OF_REDIALS;
        }
    }
                   
    //
    // Get the redial delay value
    //
    
    pArgs->nRedialDelay = (int) pArgs->piniService->GPPI(c_pszCmSection,c_pszCmEntryRedialDelay,DEFAULT_REDIAL_DELAY);

    //
    // should we enable ISDN dial on demand?
    //
    pArgs->dwIsdnDialMode = pArgs->piniService->GPPI(c_pszCmSection, 
                                                     c_pszCmEntryIsdnDialMode,
                                                     CM_ISDN_MODE_SINGLECHANNEL);
    // 
    // Get the Tapi location from the registry
    //
    if (pArgs->fAccessPointsEnabled)
    {
        pArgs->tlsTapiLink.dwTapiLocationForAccessPoint = pArgs->piniProfile->GPPI(c_pszCmSection, 
                                                                                   c_pszCmEntryTapiLocation);
    }

    CMTRACE(TEXT("End LoadProperties()"));

}

//+---------------------------------------------------------------------------
//
//  Function:   LoadIconsAndBitmaps
//
//  Synopsis:   This func loads icon and bitmap settings.  It should be part
//              of the main dlg init.
//
//  Arguments:  pArgs [the ptr to ArgsStruct]
//              hwndDlg [the main dlg]
//
//  Returns:    NONE
//
//  History:    henryt  Copied from LoadFromFile()      5/2/97
//
//----------------------------------------------------------------------------
void LoadIconsAndBitmaps(
    ArgsStruct  *pArgs, 
    HWND        hwndDlg
) 
{
    LPTSTR  pszTmp;
    UINT    nTmp;

    // Load large icon name

    pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryBigIcon);
    if (*pszTmp) 
    {
        //
        // Make sure we have a full path (if appropriate) and load big icon
        //

        LPTSTR pszFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);

        pArgs->hBigIcon = CmLoadIcon(g_hInst, pszFile);

        CmFree(pszFile);
    }
    CmFree(pszTmp);

    // Use default (EXE) large icon if no user icon found

    if (!pArgs->hBigIcon) 
    {
        pArgs->hBigIcon = CmLoadIcon(g_hInst, MAKEINTRESOURCE(IDI_APP));
    }

    SendMessageU(hwndDlg,WM_SETICON,ICON_BIG,(LPARAM) pArgs->hBigIcon); 

    // Load small icon name

    pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntrySmallIcon);
    if (*pszTmp) 
    {
        //
        // Make sure we have a full path (if appropriate) and load small icon
        //

        LPTSTR pszFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);

        pArgs->hSmallIcon = CmLoadSmallIcon(g_hInst, pszFile);

        CmFree(pszFile);
    }
    CmFree(pszTmp);

    // Use default (EXE) small icon if no user icon found

    if (!pArgs->hSmallIcon) 
    {
        pArgs->hSmallIcon = CmLoadSmallIcon(g_hInst, MAKEINTRESOURCE(IDI_APP));
    }
    
    SendMessageU(hwndDlg,WM_SETICON,ICON_SMALL,(LPARAM) pArgs->hSmallIcon);
   
    //
    // this is where the Bitmap gets loaded in.  Check to see first if we're doing
    // the Future Splash thang.  if so, no bitmap
    //
    //  Note that we do not load FutureSplash if this is WinLogon.  This is because
    //  Future Splash Animations can have imbedded actions and thus could be used
    //  to launch web pages, etc. from WinLogon as the system account.  Definitely
    //  would be a security hole.
    //

    nTmp = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryAnimatedLogo);
    if (!nTmp  || IsLogonAsSystem())
    {
        //
        // either there was no 'Animated Logo' entry, or it was 0, which means
        // we go ahead and load the bitmap.
        //

        LoadLogoBitmap(pArgs, hwndDlg);
    }
    else
    {
        //
        // if, for any reason, loading FS OC fails, go ahead and
        // degrade and load the logo bitmap.
        //

        if (S_OK != LoadFutureSplash(pArgs, hwndDlg))
        {
            LoadLogoBitmap(pArgs, hwndDlg);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  DoRasHangup
//
// Synopsis:  Hangup the given RAS device handle
//
// Arguments: prlsRasLink       - Ptr to RAS linkage struct
//            hRasConnection    - The RAS device to hangup
//            hwndDlg           - The main dlg to display "Disconnecting .. " msg
//                                Only used if fWaitForComplete is TRUE
//                                Optional, default = NULL
//            fWaitForComplete  - Whether to wait for Hangup to complete on 95
//                                If set to TRUE, will wait until hRasConnection 
//                                is invalid. Optional, default = FALSE
//            pfWaiting         - Ptr to boolean value indicating our wait state
//                                and whether Timer and Ras messages should be 
//                                ignored. Optional, default = NULL
//
// Returns:   DWORD - ERROR_SUCCESS if success or error code
//
// Note:      pArgs is removed so that the Disconnect path can use this function
//            thus concentrating the timing mess in one place.
//
// History:   fengsun   Created Header    10/22/97
//            fengsun   Add fWaitForComplete 12/18/97
//            nickball  Removed pArgs dependency
//
//+----------------------------------------------------------------------------

DWORD DoRasHangup(RasLinkageStruct *prlsRasLink, 
    HRASCONN hRasConnection, 
    HWND hwndDlg, 
    BOOL fWaitForComplete,
    LPBOOL pfWaiting)
{
    
    DWORD dwRes = ERROR_SUCCESS;

    MYDBGASSERT(hRasConnection != NULL);
    MYDBGASSERT(prlsRasLink->pfnHangUp != NULL);

    //
    // Do we need to check the return value 
    // now that RAS is going to disconnect modem too?
    //

    dwRes = prlsRasLink->pfnHangUp(hRasConnection);
    CMTRACE1(TEXT("DoRasHangup() RasHangup() returned %u."), dwRes);
    
    // On Win32 RasHangup returns immediately, so loop until we
    // are certain that the disconnected state had been reached

    if ((dwRes == ERROR_SUCCESS) && prlsRasLink->pfnGetConnectStatus) 
    {
        RASCONNSTATUS rcs;

        CMTRACE(TEXT("DoRasHangup() Waiting for hangup to complete"));

        //
        // On 95 Wait for HANGUP_TIMEOUT seconds
        // On NT wait until the connection is released
        // This will cause this to loop till the connection status 
        // is RASCS_Disconnected
        //

        #define HANGUP_TIMEOUT 60    // timeout for 95 hangup

        if (pfWaiting)
        {
            //
            // Keep the message looping to avoid freezing CM
            // But do not handle WM_TIMER and RAS msg
            //

            MYDBGASSERT(!*pfWaiting);
            *pfWaiting = TRUE;
        }

        if (fWaitForComplete && hwndDlg)
        {
            //
            // Display the disconnecting message, if we have to wait
            //
            LPTSTR pszTmp = CmLoadString(g_hInst,IDMSG_DISCONNECTING);
            SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTmp); 
            CmFree(pszTmp);
        }

        DWORD dwStartWaitTime = GetTickCount(); 

        HCURSOR hWaitCursor = LoadCursorU(NULL,IDC_WAIT);

        ZeroMemory(&rcs,sizeof(rcs));
        rcs.dwSize = sizeof(rcs);

        while ((dwRes = prlsRasLink->pfnGetConnectStatus(hRasConnection,&rcs)) == ERROR_SUCCESS) 
        {
            //
            // If it is NT, or do not need to wait for hangup to complete,
            // RASCS_Disconnected state is considered hangup complete
            //
            if (rcs.rasconnstate == RASCS_Disconnected && 
               (!fWaitForComplete || OS_NT))
            {
                break; 
            }
               
            //
            // We only have time out for 95/98
            //
            if (OS_W9X && (GetTickCount() - dwStartWaitTime >= HANGUP_TIMEOUT * 1000))
            {
                CMTRACE(TEXT("DoRasHangup() Wait timed out"));
                break;
            }

            //
            // Try to dispatch message, however, some time the wait cursor is
            // changed back to arrow
            //

            MSG msg;
            while (PeekMessageU(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message != WM_SETCURSOR)
                {
                    TranslateMessage(&msg);
                    DispatchMessageU(&msg);

                    if (GetCursor() != hWaitCursor)
                    {
                        SetCursor(hWaitCursor);
                    }
                }
            }

            Sleep(500);
        }

        if (dwRes == ERROR_INVALID_HANDLE)
        {
            dwRes = ERROR_SUCCESS;
        }
        else
        {
            CMTRACE1(TEXT("MyRasHangup() RasGetConnectStatus(), GLE=%u."), dwRes);
        }
        
        if (pfWaiting)
        {
            *pfWaiting = FALSE;
        }
    }

    CMTRACE(TEXT("DoRasHangup() completed"));

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Function:  MyRasHangup
//
// Synopsis:  Simple wrapper for DoRasHangup, that takes pArgs as a param.
//
// Arguments: pArgs             - Ptr to global Args struct
//            hRasConnection    - The RAS device to hangup
//            hwndDlg           - The main dlg to display "Disconnecting .. " msg
//                                Only used if fWaitForComplete is TRUE
//                                Optional, default = NULL
//            fWaitForComplete  - Whether to wait for Hangup to complete on 95
//                                If set to TRUE, will wait until hRasConnection 
//                                is invalid. Optional, default = FALSE
//
// Returns:   DWORD - ERROR_SUCCESS if success or error code
//
// History:   nickball  Implemented as wrapper  2/11/98           
//
//+----------------------------------------------------------------------------
DWORD MyRasHangup(ArgsStruct *pArgs, 
    HRASCONN hRasConnection, 
    HWND ,
    BOOL fWaitForComplete)
{
    CMTRACE(TEXT("MyRasHangup() calling DoRasHangup()"));
    return DoRasHangup(&pArgs->rlsRasLink, hRasConnection, NULL, fWaitForComplete, &pArgs->fIgnoreTimerRasMsg);
}    

//+----------------------------------------------------------------------------
//
// Function:  HangupCM
//
// Synopsis:  hangup both dial-up and tunnel connection, if exist
//
// Arguments: ArgsStruct *pArgs - 
//            hwndDlg the main dlg to display "Disconnecting .. " msg
//            fWaitForComplete: Whether to wait for Hangup to complete on 95
//                              If set to TRUE, will wait until hRasConnection 
//                              is invalid.   
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    10/22/97
//            fengsun Add fWaitForComplete 12/18/97
//
//+----------------------------------------------------------------------------
DWORD HangupCM(ArgsStruct *pArgs, 
    HWND hwndDlg,
    BOOL fWaitForComplete,
    BOOL fUpdateTable) 
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(hwndDlg);
    CMTRACE(TEXT("HangupCM()"));

    if (!pArgs) 
    {
        CMTRACE(TEXT("HangupCM() invalid parameter."));
        return (ERROR_INVALID_PARAMETER);
    }

    DWORD dwRes = ERROR_SUCCESS;

    //
    // If change password dialog is up tell it to go away
    //
    if (pArgs->hWndChangePassword)
    {
        CMTRACE(TEXT("HangupCM() Terminating ChangePassword dialog"));
        PostMessage(pArgs->hWndChangePassword, WM_COMMAND, IDCANCEL, 0);
    }

    //
    // If Callback number dialog is up tell it to go away too.
    //

    if (pArgs->hWndCallbackNumber)
    {
        CMTRACE(TEXT("HangupCM() Terminating CallbackNumber dialog"));
        PostMessage(pArgs->hWndCallbackNumber, WM_COMMAND, IDCANCEL, 0);
    }
    
    //
    // If Callback number dialog is up tell it to go away too.
    //

    if (pArgs->hWndRetryAuthentication)
    {
        CMTRACE(TEXT("HangupCM() Terminating RetryAuthentication dialog"));
        PostMessage(pArgs->hWndRetryAuthentication, WM_COMMAND, IDCANCEL, 0);
    }
    
    //
    // If table updates are desired set the entry to the disconnecting state
    // Note: In the case of redial, we don't want to modify the table state
    // even though we are hanging up because technically we are still connecting.
    //
    
    if (fUpdateTable)
    {
        UpdateTable(pArgs, CM_DISCONNECTING);
    }

    //
    // Check the RasLink pointer and hang up the device, tunnel first
    //
#ifdef DEBUG
    if (!pArgs->rlsRasLink.pfnHangUp)
    {
        CMTRACE(TEXT("HangupCM() can't hang up."));
    }
#endif
    //
    // Show wait cursor before hanging up
    //
        
    HCURSOR hPrev;

    if (hwndDlg) 
    {
        hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));
        ShowCursor(TRUE);
    }
    
    //
    // The assumption is that we have been connected, why else would we call 
    // hangup. So release statistics handles, hooks, etc.
    //

    if (pArgs->pConnStatistics)
    {
        pArgs->pConnStatistics->Close();
    }
    
    //
    // Hangup connections
    //

    if (pArgs->rlsRasLink.pfnHangUp && pArgs->hrcTunnelConn) 
    {
        //
        // first, hangup tunnel connection
        //

        CMTRACE(TEXT("HangupCM() calling MyRasHangup() for tunnel connection"));

        dwRes = MyRasHangup(pArgs, pArgs->hrcTunnelConn, hwndDlg, fWaitForComplete);
#ifdef DEBUG
        if (dwRes != ERROR_SUCCESS)
        {
            CMTRACE1(TEXT("MyRasHangup failed, GLE=%u."), GetLastError());
        }
#endif      
        pArgs->hrcTunnelConn = NULL;
    }

    //
    // If we have a valid link and handle, hangup the modem
    //

    if (pArgs->rlsRasLink.pfnHangUp && pArgs->hrcRasConn) 
    {
        CMTRACE(TEXT("HangupCM() calling MyRasHangup() for dial-up connection"));
        dwRes = MyRasHangup(pArgs, pArgs->hrcRasConn);      
    }
    
    // Restore cursor
        
    if (hwndDlg) 
    {
        ShowCursor(FALSE);
        SetCursor(hPrev);
    }

    pArgs->hrcRasConn = NULL;
    
    //
    // Update the Connection table if asked
    //
    
    if (fUpdateTable)
    {
        UpdateTable(pArgs, CM_DISCONNECTED);
    }

    return (dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CleanupZapThread
//
// Synopsis:  Simple helper to deal with signaling an event to stop Zap thread 
//            and waiting for the thread to terminate.
//
// Arguments: HANDLE hEvent - The event handle
//            HANDLE hThread - Handle to the Zap thread.
//
// Returns:   static void - Nothing
//
// History:   nickball    Created    3/5/98
//
//+----------------------------------------------------------------------------
static void CleanupZapThread(HANDLE hEvent,
                             HANDLE hThread)
{
    MYDBGASSERT(hEvent);
    MYDBGASSERT(hThread);

    //
    // If we have an event, then it is assumed that have a Zap thread running
    //

    if (hEvent)
    {       
        //
        // Signal termination to notify thread that we are done
        //
        
        BOOL bRes = SetEvent(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("CleanupZapThread() SetEvent() failed, GLE=%u."), GetLastError());
        }
#endif

        if (hThread)
        {
            //
            // Wait for thread to terminate, but pump messages in the mean time
            //
                        
            BOOL bDone = FALSE;
            DWORD dwWaitCode;

            while (FALSE == bDone)
            {
                dwWaitCode = MsgWaitForMultipleObjects(1, &hThread, FALSE, MAX_OBJECT_WAIT, QS_ALLINPUT);

                switch(dwWaitCode)
                {
                    //
                    // Thread has terminated, or time is up, we're done here
                    //

                    case -1:
                        CMTRACE1(TEXT("CleanupZapThread() MsgWaitForMultipleObjects returned an error GLE=%u."), 
                            GetLastError());

                    case WAIT_TIMEOUT:
                    case WAIT_OBJECT_0:
                        bDone = TRUE;
                        break;

                    //
                    // If there is a message in the queue, process it
                    //

                    case WAIT_OBJECT_0+1:
                    {                        
                        MSG msg;
                        while (PeekMessageU(&msg, 0, 0, 0, PM_REMOVE))
                        {
                            TranslateMessage(&msg);
                            DispatchMessageU(&msg);
                        }
                    
                        break;
                    }                                       
                    
                    //
                    // Unexpected, report, but continue
                    //

                    default:
                        MYDBGASSERT(FALSE);                       
                }
            }

            //
            // We are done with the thread, close the handle
            //
            
            bRes = CloseHandle(hThread);
#ifdef DEBUG
            if (!bRes)
            {
                CMTRACE1(TEXT("CleanupZapThread() CloseHandle(hThread) failed, GLE=%u."), GetLastError());
            }
#endif
        }
        
        //
        // Close our event handle
        //

        bRes = CloseHandle(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("CleanupZapThread() CloseHandle(hEvent) failed, GLE=%u."), GetLastError());
        }
#endif
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnConnectedCM
//
// Synopsis:  Process WM_CONNECTED_CM which indicates that we are connected and
//            connect processing such as connect actions can begin
//
// Arguments: HWND hwndDlg - HWND of main dialog
//            ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball      Created    03/05/98
//
//+----------------------------------------------------------------------------
void OnConnectedCM(HWND hwndDlg, ArgsStruct *pArgs)
{
    HANDLE hEvent = NULL;
    HANDLE hThread = NULL;
    CActionList ConnectActList;
    CActionList AutoActList;

    //
    // Check to see if we are in a valid state to connect. if not just abort.
    //
    MYDBGASSERT(pArgs);

    if (pArgs->hrcRasConn == NULL && pArgs->hrcTunnelConn == NULL)
    {
        CMTRACE(TEXT("Bogus OnConnectCM msg received"));
        goto OnConnectedCMExit;
    }

    //
    // Set state to online
    //

    if (IsDialingTunnel(pArgs))  
    {
        //
        // For Win2K+ this tries to resave the EAP Auth data if there is any present in the .cms for a tunnel
        //
        if (OS_NT5)
        {
            CIni iniFile(g_hInst, pArgs->piniService->GetFile());
            ReSaveEapCustomAuthData(pArgs, &iniFile, TRUE, pArgs->pszRasPbk);
        }

        //
        // This is a patch, it is only a patch - #187202
        // UI should not be tied to RASENTRY type, but it is for now so we
        // have to make sure that it is set back to RASET_Internet once we 
        // have our tunnel connection connected.
        //
        
        if (OS_NT5)
        {            
            LPRASENTRY pRasEntry = MyRGEP(pArgs->pszRasPbk, pArgs->szServiceName, &pArgs->rlsRasLink);

            CMASSERTMSG(pRasEntry, TEXT("OnConnectedCM() - MyRGEP() failed."));
                
            //
            // Set the type back and save the RASENTRY
            //

            if (pRasEntry)
            {
                ((LPRASENTRY_V500)pRasEntry)->dwType = RASET_Internet;

                if (pArgs->rlsRasLink.pfnSetEntryProperties) 
                {
                    DWORD dwTmp = pArgs->rlsRasLink.pfnSetEntryProperties(pArgs->pszRasPbk,
                                                                    pArgs->szServiceName,
                                                                    pRasEntry,
                                                                    pRasEntry->dwSize,
                                                                    NULL,
                                                                    0);
                    CMTRACE2(TEXT("OnConnectedCM() RasSetEntryProperties(*lpszEntry=%s) returns %u."),
                          MYDBGSTR(pArgs->szServiceName), dwTmp);

                    CMASSERTMSG(dwTmp == ERROR_SUCCESS, TEXT("RasSetEntryProperties for VPN failed"));
                }              
            }

            CmFree(pRasEntry);
        }
        pArgs->psState = PS_TunnelOnline;        
    }
    else 
    {   
        //
        // For Win2K+ this tries to resave the EAP Auth data if there is any present in the .cms for 
        // a dial-up connection
        //
        if (OS_NT5) 
        {
            DWORD dwEntry = pArgs->nDialIdx; 
            CIni    *piniService = NULL;
            LPTSTR pszRasPbk = NULL;

            if (OS_NT && pArgs->fUseTunneling)
            {
                if (!pArgs->pszRasHiddenPbk)
                {
                    pArgs->pszRasHiddenPbk = CreateRasPrivatePbk(pArgs);
                }

                pszRasPbk = pArgs->pszRasHiddenPbk; 
            }
            else
            {
                pszRasPbk = pArgs->pszRasPbk;
            }

            //
            //  Need to work with the correct service file(the top-level service
            //  or a referenced service).
            //
            piniService = GetAppropriateIniService(pArgs, dwEntry);
            if (piniService)
            {
                CIni iniFile(g_hInst, piniService->GetFile());
                ReSaveEapCustomAuthData(pArgs, &iniFile, FALSE, pszRasPbk);

                delete piniService;
                piniService = NULL;
            }
        }

        //
        // Set dial index back to primary number
        //
        pArgs->nDialIdx = 0;
        pArgs->psState = PS_Online;

        //
        //  Make sure to update the stored username back to just the Username as RAS has saved the exact username
        //  that we dialed with including realm info.
        //
        if (OS_NT5)
        {
            if (!pArgs->fUseTunneling || pArgs->fUseSameUserName)
            {
                if (0 != lstrcmpi(pArgs->szUserName, pArgs->pRasDialParams->szUserName))
                {
                    MYVERIFY(SaveUserInfo(pArgs, UD_ID_USERNAME, pArgs->szUserName));
                }
            }
            else
            {
                if (0 != lstrcmpi(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName))
                {
                    MYVERIFY(SaveUserInfo(pArgs, UD_ID_INET_USERNAME, pArgs->szInetUserName));
                }
            }
        }
    }
        
    pArgs->dwStateStartTime = GetTickCount();
    // pszMsg = GetDurMsg(g_hInst,pArgs->dwStateStartTime);  // connect duration
    pArgs->nLastSecondsDisplay = (UINT) -1;
    
    //
    // added by byao: for PPTP connection
    //

    if (pArgs->fUseTunneling && pArgs->psState == PS_Online) 
    {
        //
        // Now do the second dial: PPTP dialup
        //

        pArgs->psState = PS_TunnelDialing;
        pArgs->dwStateStartTime = GetTickCount();
        pArgs->nLastSecondsDisplay = (UINT) -1;

        DWORD dwRes = DoTunnelDial(hwndDlg, pArgs);

        if (ERROR_SUCCESS != dwRes)
        {
            HangupCM(pArgs, hwndDlg);
            UpdateError(pArgs, dwRes);
            SetLastError(dwRes);
        }
        
        goto OnConnectedCMExit;
    }

    //
    // If this W95, then we need to Zap the RNA "Connected To" dialog
    //

    if (OS_W95) 
    {
         
        // LPTSTR pszTmp = GetEntryName(pArgs, pArgs->pszRasPbk, pArgs->piniService);
        LPTSTR pszTmp = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
        
        //
        // Create an event for signalling Zap thread to snuff itself out
        //
      
        hEvent = CreateEventU(NULL, TRUE, FALSE, NULL); 
 
        if (hEvent)
        {
            hThread = ZapRNAConnectedTo(pszTmp, hEvent);            
        }

#ifdef DEBUG
        if (!hEvent)
        {
            CMTRACE1(TEXT("OnConnectedCM() CreateEvent failed, GLE=%u."), GetLastError());
        }
#endif
        CmFree(pszTmp);
    }

    pArgs->Log.Log(CONNECT_EVENT);
    //
    // If connection actions are enabled, update the list and run it
    //

    CMTRACE(TEXT("Connect Actions enabled: processsing Run List"));

    ConnectActList.Append(pArgs->piniService, c_pszCmSectionOnConnect);

    if (!ConnectActList.RunAccordType(hwndDlg, pArgs))
    {
        //
        // Connect action failed
        // Run disconnect action
        //
        TCHAR szTmp[MAX_PATH];            
        MYVERIFY(GetModuleFileNameU(g_hInst, szTmp, MAX_PATH));          
        pArgs->Log.Log(DISCONNECT_EVENT, szTmp);
        //
        // Do not let disconnect action description overwrite the failure message
        // Save the status pane text and restore it after disconnect actions
        // 162942: Connect Action failed message is not displayed
        //
        TCHAR szFailedMsg[256] = TEXT("");
        GetWindowTextU(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY), 
                       szFailedMsg, sizeof(szFailedMsg)/sizeof(szFailedMsg[0]));

        CActionList DisconnectActList;
        DisconnectActList.Append(pArgs->piniService, c_pszCmSectionOnDisconnect);

        DisconnectActList.RunAccordType(hwndDlg, pArgs, FALSE);  // fStatusMsgOnFailure = FALSE

        HangupCM(pArgs, hwndDlg);

        //
        // Restore the connect action failure message
        //
        if (szFailedMsg[0] != TEXT('\0'))
        {
            SetWindowTextU(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY),szFailedMsg);
        }
        
        goto OnConnectedCMExit;
    }

    //
    // Always run AutoApps if there are any. Used to only do this in the 
    // non-autodial case, which was un-intuitive to our admin users.
    //

    AutoActList.Append(pArgs->piniService, c_pszCmSectionOnIntConnect);
    AutoActList.RunAutoApp(hwndDlg, pArgs);

    //
    // Connect to the connection monitor
    //

    if (SUCCEEDED(UpdateTable(pArgs, CM_CONNECTED)))
    {
        if (SUCCEEDED(ConnectMonitor(pArgs)))
        {
             EndMainDialog(hwndDlg, pArgs, 0); // TRUE); 
             
             //
             // SUCCESS We're fully connected, update error code
             // as it may contain an interim value such as a 
             // failed primary number dial.
             //

             pArgs->dwExitCode = ERROR_SUCCESS;
        }
        else
        {
            HangupCM(pArgs, hwndDlg);

            AppendStatusPane(hwndDlg,IDMSG_CMMON_LAUNCH_FAIL);
            SetInteractive(hwndDlg,pArgs);
            goto OnConnectedCMExit;
        }
    }
    
    //
    // Update changed password if needed
    //
    
    if (pArgs->fChangedPassword && pArgs->fRememberMainPassword)
    {
        //
        // Note: fRememberMainPassword should never be set in the 
        // WinLogon case. Complain if we have WinLogon specific data. 
        //

        MYDBGASSERT(!pArgs->lpRasNoUser); 
        MYDBGASSERT(!pArgs->lpEapLogonInfo);

        //
        // If the password has changed, then update storage
        // Make sure this isn't a handle we are saving, because it would actually
        // overwrite the correct password.
        //

        if (FALSE == pArgs->SecurePW.IsHandleToPassword())
        {
            LPTSTR pszClearPassword = NULL;
            DWORD cbClearPassword = 0;
            BOOL fRetPassword = FALSE;

            fRetPassword = pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

            if (fRetPassword && pszClearPassword)
            {
                SaveUserInfo(pArgs, UD_ID_PASSWORD, (PVOID)pszClearPassword);
                
                if (pArgs->fUseSameUserName)
                {
                    SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pszClearPassword);

                    //
                    // Make sure to update our pArgs structure
                    //
                    
                    (VOID)pArgs->SecureInetPW.SetPassword(pszClearPassword);
                }
                
                //
                // Clear and Free the clear-text password
                //
                pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
            }
        }
    }

    pArgs->fChangedPassword = FALSE;

    //
    // Update changed Internet password if needed
    //

    if (pArgs->fChangedInetPassword && pArgs->fRememberInetPassword)
    {
        LPTSTR pszClearInetPassword = NULL;
        DWORD cbClearInetPassword = 0;
        BOOL fRetPassword = FALSE;

        fRetPassword = pArgs->SecureInetPW.GetPasswordWithAlloc(&pszClearInetPassword, &cbClearInetPassword);

        if (fRetPassword && pszClearInetPassword)
        {
            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pszClearInetPassword); 

            //
            // Clear and Free the clear-text password
            //

            pArgs->SecureInetPW.ClearAndFree(&pszClearInetPassword, cbClearInetPassword);
        }
    }

    pArgs->fChangedInetPassword = FALSE;

                
OnConnectedCMExit:

    if (hEvent)
    {
        MYDBGASSERT(OS_W9X);
        CleanupZapThread(hEvent, hThread);
    }

    return;
}

#define MAX_BLOB_CHARS_PER_LINE 128
#define MAX_KEY_NAME_LEN 32

//+----------------------------------------------------------------------------
//
// Function:  ReSaveEapCustomAuthData
//
// Synopsis:  This function resaves CustomAuthData key of the EAP settings
//            for the given section in a CMS file. The reason we need to 
//            resave the data is because at connect time the data might
//            actually change (eg. if the  users accepts a new auth cert). If 
//            we don't save the data back to the .cms, the user keeps getting 
//            prompted each time they connect to accept the same cert.
//            This function figures out if there is EAP Custom Auth Data,
//            and if so, it reads the blob from .cms, and the ras API,
//            then it erases the .cms data from the file and calls
//            SaveNewEAPCustomAuthData to construct and write out the new
//            structure to .cms
//
// Arguments: ArgsStruct *pArgs - pointer to Args structure 
//            piniFile - CIni object pointing to .cms file 
//            fTunnelEntry - TRUE if this is a tunnel entry, FALSE otherwise
//            pszRasPhoneBook - RAS Pbk
//
// Returns:   DWORD - ERROR_SUCCESS or error code
//
// History:   tomkel   08/09/2001   Created
//
//+----------------------------------------------------------------------------
DWORD ReSaveEapCustomAuthData(ArgsStruct *pArgs, CIni *piniFile, BOOL fTunnelEntry, LPTSTR pszRasPhoneBook)
{
    int nTmp = 0;
    LPTSTR pszDun = NULL;
    LPTSTR pszIniSection = NULL;
    DWORD dwRetVal = ERROR_SUCCESS;

    //
    // pszRasPhoneBook parameter can be NULL
    // 
    if (NULL == pArgs || NULL == piniFile)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the DUN name
    //
    if ((FALSE == fTunnelEntry) && pArgs->aDialInfo[pArgs->nDialIdx].szDUN[0])
    {
        pszDun = CmStrCpyAlloc(pArgs->aDialInfo[pArgs->nDialIdx].szDUN);
    }
    else
    {
        pszDun = GetDefaultDunSettingName(piniFile, fTunnelEntry);
    }

    pszIniSection = CmStrCpyAlloc(TEXT("&"));
    pszIniSection = CmStrCatAlloc(&pszIniSection, pszDun); //TODO:verify pArgs->aDialInfo[dwEntry].szDUN
    piniFile->SetSection(pszIniSection);

    nTmp = piniFile->GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomAuthKey, -1);

    //
    // If a type ID for EAP is specified, see if there is any EAP Custom Auth data
    //

    if ((-1 != nTmp) && pArgs->rlsRasLink.pfnGetCustomAuthData) 
    {  
        //
        // We have an ID, read the EAP config data
        //
        LPBYTE pbEapStruct = NULL;
        DWORD cbEapStruct = 0;
        PBYTE pbEapData = NULL;
        DWORD dwEapSize = 0;
        PBYTE pbEapAuthData = NULL;
        DWORD cbEapAuthData = 0;
        DWORD dwTmp = 0;
        
        LPWSTR pszLoadSection = NULL;

        cbEapAuthData = 1024;   // some default buffer size
        pbEapAuthData = (PBYTE)CmMalloc(cbEapAuthData);

        if (pbEapAuthData)
        {
            dwTmp = pArgs->rlsRasLink.pfnGetCustomAuthData(pszRasPhoneBook, 
                                         pArgs->pRasDialParams->szEntryName,
                                         pbEapAuthData, 
                                         &cbEapAuthData);

            if (ERROR_BUFFER_TOO_SMALL == dwTmp)
            {   
                CmFree(pbEapAuthData);
                pbEapAuthData = NULL;
                pbEapAuthData = (PBYTE)CmMalloc(cbEapAuthData + 1);
                if (pbEapAuthData)
                {
                    dwTmp = pArgs->rlsRasLink.pfnGetCustomAuthData(pszRasPhoneBook, 
                                                 pArgs->pRasDialParams->szEntryName,
                                                 pbEapAuthData, 
                                                 &cbEapAuthData);
                }
            }
        }

        //
        // Need to check pbEapAuthData in case the second CmMalloc failed above
        //
        if ((ERROR_SUCCESS == dwTmp) && pbEapAuthData)
        {
            BOOL fRead = FALSE;
            
            pszLoadSection = piniFile->LoadSection(c_pszCmSectionDunServer);   
            
            //
            // Read the existing data blob. We don't care about just the
            // EapData. We want the whole Eap structure (EAP_CUSTOM_DATA)
            //
            fRead = ReadDunSettingsEapData(piniFile, &pbEapData, &dwEapSize, nTmp, &pbEapStruct, &cbEapStruct);         

            if (fRead && pbEapStruct && cbEapStruct && pszLoadSection)
            {
                //
                // Erase the existing EAP Auth data from .cms file
                //
                HRESULT hr = EraseDunSettingsEapData(pszLoadSection, piniFile->GetFile());

                //
                // If we weren't able to erase anything (no write access)
                // there is no point in trying to save the blob, otherwise save the new auth data
                //
                if (SUCCEEDED(hr))
                {
                    DWORD dwRC = SaveNewEAPCustomAuthData(piniFile->GetFile(), pszLoadSection, cbEapAuthData, pbEapAuthData, pbEapStruct);
                    if (ERROR_SUCCESS != dwRC)
                    {
                        CMTRACE1(TEXT("ReSaveEapCustomAuthData() - SaveNewEAPCustomAuthData returned error = %u"), dwRC);
                        dwRetVal = dwRC;
                    }
                }
                else
                {
                    CMTRACE1(TEXT("ReSaveEapCustomAuthData() - EraseDunSettingsEapData returned error = 0x%x"), hr);
                    dwRetVal = (0x0000FFFF & hr); // convert HRESULT back to normal Win32 error
                }
            }
        }

        CmFree(pbEapAuthData);
        pbEapAuthData = NULL;
        cbEapAuthData = 0;

        CmFree(pbEapStruct);
        pbEapStruct = NULL;
        cbEapStruct = 0;

        CmFree(pbEapData);
        pbEapData = NULL;
        dwEapSize = 0;

        CmFree(pszLoadSection);
        pszLoadSection = NULL;
    }

    CmFree(pszDun);
    pszDun = NULL;

    CmFree(pszIniSection);        
    pszIniSection = NULL;

    return dwRetVal;
}

//+----------------------------------------------------------------------------
//
// Function:  SaveNewEAPCustomAuthData
//
// Synopsis:  This function resaves CustomAuthData key of the EAP settings
//            for the given section in a CMS file. The reason we need to 
//            resave the data is because at connect time the data might
//            actually change (eg. if the  users accepts a new auth cert). If 
//            we don't save the data back to the .cms, the user keeps getting 
//            prompted each time they connect to accept the same cert.
//
// Arguments: pszCmsFile - filepath to the .cms file
//            pszLoadSection - appropriate section in the file to write to
//            cbEapAuthData - # of bytes in pbEapAuthData
//            pbEapAuthData - buffer with the current eap custom auth data from RAS
//            pbEapStruct - buffer of the existing (from .cms) EAP_CUSTOM_AUTH
//                          structure
//
// Returns:   DWORD - ERROR_SUCCESS or error code
//
// History:   tomkel   08/09/2001   Created
//
//+----------------------------------------------------------------------------
DWORD SaveNewEAPCustomAuthData(LPCTSTR pszCmsFile, LPTSTR pszLoadSection, DWORD cbEapAuthData, PBYTE pbEapAuthData, PBYTE pbEapStruct)
{
    if (NULL == pszCmsFile || NULL == pszLoadSection || NULL == pbEapAuthData || NULL == pbEapStruct)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    DWORD dwRetVal = ERROR_SUCCESS;
    LPSTR pszAnsiSection = WzToSzWithAlloc(pszLoadSection);
    LPSTR pszAnsiCmsFile = WzToSzWithAlloc(pszCmsFile);
    DWORD dwSize = cbEapAuthData + sizeof(EAP_CUSTOM_DATA); // Size for the new EAP_CUSTOM_DATA structure   
    EAP_CUSTOM_DATA *pNewEAPCustomData = (EAP_CUSTOM_DATA*)CmMalloc(dwSize);

    if (pNewEAPCustomData && pszAnsiSection && pszAnsiCmsFile)
    {
        CHAR szOutput[MAX_BLOB_CHARS_PER_LINE+1] = {0};
        CHAR szAnsiKeyName[MAX_KEY_NAME_LEN] = {0}; 
        
        CHAR* pszOutput = NULL;
        int iCount = 0;
        int iLineNum = 0;

        //
        // Replace the data in the strucutre
        //
        LPBYTE pCurrentByte = (LPBYTE)pNewEAPCustomData;
        EAP_CUSTOM_DATA *pEAPExistingCustomData = (EAP_CUSTOM_DATA *)pbEapStruct;
        
        pNewEAPCustomData->dwSignature = pEAPExistingCustomData->dwSignature;
        pNewEAPCustomData->dwCustomAuthKey = pEAPExistingCustomData->dwCustomAuthKey;
        pNewEAPCustomData->dwSize = cbEapAuthData;
        CopyMemory(pNewEAPCustomData->abdata, pbEapAuthData, cbEapAuthData);

        pszOutput = szOutput;

        //
        // Change the buffer to hex and write it out to the file
        //
        while (pCurrentByte < ((LPBYTE)pNewEAPCustomData + dwSize))
        {
            *pszOutput++ = HexChar( (BYTE )(*pCurrentByte / 16) );
            *pszOutput++ = HexChar( (BYTE )(*pCurrentByte % 16) );
            pCurrentByte++;
            iCount = iCount + 2; // keep track of number of chars in ansi output buffer

            if ((MAX_BLOB_CHARS_PER_LINE == iCount) || (pCurrentByte == ((LPBYTE)pNewEAPCustomData + dwSize)))
            {
                *pszOutput = '\0';
                wsprintfA(szAnsiKeyName, "%s%d", c_pszCmEntryDunServerCustomAuthData, iLineNum);

                MYVERIFY(0 != WritePrivateProfileStringA(pszAnsiSection, szAnsiKeyName, szOutput, pszAnsiCmsFile));

                pszOutput = szOutput;
                iCount = 0;
                iLineNum++;
            }
        }

        dwRetVal = ERROR_SUCCESS;
    }
    else
    {
        dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
    }

    CmFree(pNewEAPCustomData);
    CmFree(pszAnsiCmsFile);
    CmFree(pszAnsiSection);
    
    return dwRetVal;
}

/*
//+----------------------------------------------------------------------------
//
// Function:  EraseDunSettingsEapData
//
// Synopsis:  This function erases the CustomAuthData key of the EAP settings
//            for the given section and CMS file
//
// Arguments: LPCTSTR pszSection - section name to erase the CustomAuthData from
//            LPCTSTR pszCmsFile - cms file to erase the data from
//
// Returns:   HRESULT - standard COM style error codes
//
// History:   quintinb Created     03/27/00
//            tomkel   Copied from profwiz  08/09/2001
//
//+----------------------------------------------------------------------------
HRESULT EraseDunSettingsEapData(LPCTSTR pszSection, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSection) || (NULL == pszCmsFile) || 
        (TEXT('\0') == pszSection[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iLineNum = 0;
    DWORD dwRet = -1;
    TCHAR szKeyName[MAX_PATH+1];
    TCHAR szLine[MAX_PATH+1];

    while(0 != dwRet)
    {
        wsprintfU(szKeyName, TEXT("%S%d"), c_pszCmEntryDunServerCustomAuthData, iLineNum);
        dwRet = GetPrivateProfileStringU(pszSection, szKeyName, TEXT(""), szLine, MAX_PATH, pszCmsFile);

        if (dwRet)
        {
            if (0 == WritePrivateProfileStringU(pszSection, szKeyName, NULL, pszCmsFile))
            {
                DWORD dwGLE = GetLastError();
                hr = HRESULT_FROM_WIN32(dwGLE);
                break;
            }
        }
        iLineNum++;
    }

    return hr;
}
*/

//+----------------------------------------------------------------------------
//
// Function:  SetTcpWindowSizeOnWin2k
//
// Synopsis:  This function is basically a wrapper to load the RasSetEntryTcpWindowSize
//            API (which was QFE-ed and shipped in SP3 for Win2k) and call it.
//            It should fail gracefully if the API is not present.
//
// Arguments: HMODULE hInstRas - module handle for Rasapi32.dll
//            LPCTSTR pszConnectoid - name of the connectoid to set the window size for
//            LPCTSTR pszPhonebook - phonebook that the connectoid lives in
//            DWORD dwTcpWindowSize - size to set, note that calling with 0 
//                                    sets it to the system default
//
// Returns:   DWORD - win32 error code or ERROR_SUCCESS if successful
//
// History:   quintinb    Created       02/14/2001
//
//+----------------------------------------------------------------------------
DWORD SetTcpWindowSizeOnWin2k(HMODULE hInstRas, LPCTSTR pszConnectoid, LPCTSTR pszPhonebook, DWORD dwTcpWindowSize)
{
    //
    //  Check inputs, note that pszPhonebook could be NULL
    //
    if ((NULL == hInstRas) || (NULL == pszConnectoid) || (TEXT('\0') == pszConnectoid[0]))
    {
        CMASSERTMSG(FALSE, TEXT("SetTcpWindowSizeOnWin2k -- Invalid arguments passed."));
        return ERROR_BAD_ARGUMENTS;
    }

    //
    //  Check to make sure we are only calling this on Win2k
    //
    if ((FALSE == OS_NT5) || OS_NT51)
    {
        CMASSERTMSG(FALSE, TEXT("SetTcpWindowSizeOnWin2k -- This function should only be called on Win2k."));
        return -1;
    }

    //
    //  See if we can load the new RAS function to set the Window size
    //
    LPCSTR c_pszDwSetEntryPropertiesPrivate = "DwSetEntryPropertiesPrivate";
    typedef DWORD (WINAPI *pfnDwSetEntryPropertiesPrivateSpec)(IN LPCWSTR, IN LPCWSTR, IN DWORD, IN PVOID);
    DWORD dwReturn;

    pfnDwSetEntryPropertiesPrivateSpec pfnDwSetEntryPropertiesPrivate = (pfnDwSetEntryPropertiesPrivateSpec)GetProcAddress(hInstRas, c_pszDwSetEntryPropertiesPrivate);

    if (pfnDwSetEntryPropertiesPrivate)
    {
        RASENTRY_EX_0 PrivateRasEntryExtension;

        PrivateRasEntryExtension.dwTcpWindowSize = dwTcpWindowSize;
        
        dwReturn = (pfnDwSetEntryPropertiesPrivate)(pszPhonebook, pszConnectoid, 0, &PrivateRasEntryExtension); // 0 = struct version num
        if (ERROR_SUCCESS != dwReturn)
        {
            CMTRACE1(TEXT("SetTcpWindowSizeOnWin2k -- DwSetEntryPropertiesPrivate returned %d"), dwReturn);
            CMASSERTMSG(FALSE, TEXT("SetTcpWindowSizeOnWin2k -- DwSetEntryPropertiesPrivate returned something other than success, check the trace file for the error code."));
        }
    }
    else
    {
        dwReturn = GetLastError();
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  DoRasDial
//
// Synopsis:  Call RasDial to dial the PPP connection
//
// Arguments: HWND hwndDlg - Main signon window
//            ArgsStruct *pArgs - 
//            DWORD dwEntry - The index in pArgs->aDialInfo
//
// Returns:   DWORD - 
//              ERROR_SUCCESS if success
//              ERROR_NOT_ENOUGH_MEMORY
//              E_UNEXPECTED, unexpected error, such as tunnel address not found
//              Otherwise, RAS error
//
// History:   fengsun Created Header    3/6/98
//
//+----------------------------------------------------------------------------
DWORD DoRasDial(HWND hwndDlg, 
              ArgsStruct *pArgs, 
              DWORD dwEntry)
{
    LPRASENTRY              preRasEntry = NULL;
    LPRASSUBENTRY           rgRasSubEntry = NULL;
    LPRASEAPUSERIDENTITY    lpRasEapUserIdentity = NULL;

    DWORD   dwSubEntryCount;

    LPTSTR  pszUsername;
    LPTSTR  pszPassword;
    LPTSTR  pszDomain = NULL;
    LPTSTR  pszRasPbk;
    LPTSTR  pszTmp;

    CSecurePassword* pSecPass = NULL;
    LPTSTR pszClearPassword = NULL;
    DWORD cbClearPassword = 0;
    BOOL fRetPassword = FALSE;

    CIni    *piniService = NULL;
    DWORD   dwRes = ERROR_SUCCESS;  // the return value of this function
    DWORD   dwTmp;

    LPBYTE pbEapAuthData = NULL;        // Ptr to Eap Data
    DWORD  dwEapAuthDataSize = 0;           // The size of the EAP blob if any

    MYDBGASSERT(pArgs->hrcRasConn == NULL);
    MYDBGASSERT(!pArgs->IsDirectConnect());
    pArgs->hrcRasConn = NULL;

    if (!pArgs->aDialInfo[dwEntry].szDialablePhoneNumber[0]) 
    {
        CMASSERTMSG(FALSE, TEXT("DoRasDial() szDialablePhoneNumber[0] is empty."));
        return ERROR_BAD_PHONE_NUMBER;
    }

    //
    // set pArgs->fUseTunneling accordingly every time DoRasDial() is called
    // since we can switch from phonenumber0 to phonenumber1 and vice versa.
    //
    pArgs->fUseTunneling = UseTunneling(pArgs, dwEntry);

    //
    //  we need to work with the correct service file(the top-level service
    //  or a referenced service).
    //
    //
    if (!(piniService = GetAppropriateIniService(pArgs, dwEntry)))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    //
    // If it's NT and we're tunneling, we create the connectoid in a hidden ras pbk, not the
    // rasphone.pbk in the system.
    //

    if (OS_NT && pArgs->fUseTunneling)
    {
        if (!pArgs->pszRasHiddenPbk)
        {
            pArgs->pszRasHiddenPbk = CreateRasPrivatePbk(pArgs);
        }
        
        pszRasPbk = pArgs->pszRasHiddenPbk; 
    }
    else
    {
        pszRasPbk = pArgs->pszRasPbk;
    }

    //
    // Setup dial params
    // 

    if (!pArgs->pRasDialParams)
    {
        pArgs->pRasDialParams = AllocateAndInitRasDialParams();

        if (!pArgs->pRasDialParams)
        {
            CMTRACE(TEXT("DoRasDial: failed to alloc a ras dial params"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }        
    }
    else
    {
        InitRasDialParams(pArgs->pRasDialParams);
    }

    //
    // Get the connectoid name.
    //

    LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
    
    if (!pszConnectoid)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcpynU(pArgs->pRasDialParams->szEntryName, pszConnectoid, sizeof(pArgs->pRasDialParams->szEntryName)/sizeof(TCHAR));

    CmFree(pszConnectoid);

    //
    // Generate the default connectoid
    //
    
    preRasEntry = CreateRASEntryStruct(pArgs, 
                        pArgs->aDialInfo[dwEntry].szDUN, 
                        piniService, 
                        FALSE,
                        pszRasPbk,
                        &pbEapAuthData,
                        &dwEapAuthDataSize);
    if (!preRasEntry) 
    {
        dwRes = GetLastError();     
        goto exit;
    }
 
    //
    // Force update of the phone number to make sure that we pick up any manual
    // changes in country, etc.
    //
    
    CopyPhone(pArgs, preRasEntry, dwEntry); 
    
    //
    // Handle NT specifics for Idle Disconnect and IDSN
    //
    
    if (OS_NT || OS_MIL)
    {
        //
        // set NT idle disconnect
        //
        if (OS_NT)
        {
            SetNtIdleDisconnectInRasEntry(pArgs, preRasEntry);
        }
        else
        {
            MYVERIFY(DisableSystemIdleDisconnect(preRasEntry));
        }
        
        //
        // if we're using isdn and we want to dial all channels/on demand, 
        // set isdn dial mode
        //
        if (pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL &&
            !lstrcmpiU(pArgs->szDeviceType, RASDT_Isdn))
        {
            MYVERIFY(SetIsdnDualChannelEntries(pArgs, 
                                               preRasEntry, 
                                               &rgRasSubEntry, 
                                               &dwSubEntryCount));
        }
        else
        {
            //
            //  Delete any additional sub entries since we only need one
            //  

            if (pArgs->rlsRasLink.pfnDeleteSubEntry) // available on NT5 & Millennium currently
            {
                DWORD dwSubEntryIndex = (OS_MIL ? 1 : 2);   // NT & Millennium dual-channel differences

                DWORD dwReturn = pArgs->rlsRasLink.pfnDeleteSubEntry(pszRasPbk,
                                                                     pArgs->pRasDialParams->szEntryName,
                                                                     dwSubEntryIndex);

                CMTRACE1(TEXT("DoRasDial -- Called RasDeleteSubEntry to delete a second sub entry if it exists, dwReturn=%d"), dwReturn);
            }
        }
    }
    else if (OS_W95)
    {
        //
        // fix another Win95 RAS bug    -- byao, 8/16/97
        // The Before and After terminal window options will be switched each
        // time you call RasSetEntryProperties          
        // This is fixed in Memphis, so it's only in Win95 Golden and OSR2
        //
        BOOL fTerminalAfterDial, fTerminalBeforeDial;

        fTerminalBeforeDial = (BOOL) (preRasEntry->dwfOptions & RASEO_TerminalBeforeDial);
        fTerminalAfterDial  = (BOOL) (preRasEntry->dwfOptions & RASEO_TerminalAfterDial);

        //
        // switch them
        //
        if (fTerminalBeforeDial)
        {
            preRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
        }
        else
        {
            preRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;
        }

        if (fTerminalAfterDial)
        {
            preRasEntry->dwfOptions |= RASEO_TerminalBeforeDial;
        }
        else
        {
            preRasEntry->dwfOptions &= ~RASEO_TerminalBeforeDial;
        }
    }


    if (pArgs->rlsRasLink.pfnSetEntryProperties) 
    {

#ifdef DEBUG
        
        LPRASENTRY_V500 lpRasEntry50;
        
        if (OS_NT5)
        {
            lpRasEntry50 = (LPRASENTRY_V500) preRasEntry;
        }
#endif

        //
        // use 1 on Millennium to signify that we want to use the modem cpl settings
        // for the modem speaker such instead of the cached copy that DUN keeps.
        // Note we only do this for a dialup connection and not a tunnel since there
        // is no modem speaker to worry about.  See Millennium bug 127371.
        //
        LPBYTE lpDeviceInfo = OS_MIL ? (LPBYTE)1 : NULL; 

        DWORD dwResDbg = pArgs->rlsRasLink.pfnSetEntryProperties(pszRasPbk, 
                                                                 pArgs->pRasDialParams->szEntryName, 
                                                                 preRasEntry,
                                                                 preRasEntry->dwSize,
                                                                 lpDeviceInfo,
                                                                 0);


        CMTRACE2(TEXT("DoRasDial() RasSetEntryProperties(*pszPhoneBook=%s) returns %u."), 
            MYDBGSTR(pArgs->pRasDialParams->szEntryName), dwResDbg);

        CMASSERTMSG(dwResDbg == ERROR_SUCCESS, TEXT("RasSetEntryProperties failed"));
        
        //
        // set the subentries for isdn dual channel/dial on demand
        //
        if (pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL && 
            rgRasSubEntry && 
            pArgs->rlsRasLink.pfnSetSubEntryProperties)
        {
            UINT  i;
             
            for (i=0; i< dwSubEntryCount; i++)
            {
#ifdef  DEBUG
                dwResDbg = 
#endif
                pArgs->rlsRasLink.pfnSetSubEntryProperties(pszRasPbk,
                                                           pArgs->pRasDialParams->szEntryName,
                                                           i+1,
                                                           &rgRasSubEntry[i],
                                                           rgRasSubEntry[i].dwSize,
                                                           NULL,
                                                           0);

                CMTRACE2(TEXT("DoRasDial: RasSetSubEntryProps(index=%u) returned %u"), i+1, dwResDbg);
                CMASSERTMSG(!dwResDbg, TEXT("RasSetSubEntryProperties failed"));
            }

            CmFree(rgRasSubEntry);
        }
    }

    //
    //  Set the TCP Window size -- the NTT DoCoMo fix for Win2k.  The Win2k version of this fix
    //  must be written through a private RAS API that must be called after the phonebook entry 
    //  exists ie. after we call RasSetEntryProperties ... otherwise it won't work on the first
    //  dial.
    //
    if (OS_NT5 && !OS_NT51)
    {
        //
        //  Figure out the DUN setting name to use and then build up TCP/IP&DunName.
        //
        LPTSTR pszDunSetting = GetDunSettingName(pArgs, dwEntry, FALSE);
        LPTSTR pszSection = CmStrCpyAlloc(c_pszCmSectionDunTcpIp);
        pszSection = CmStrCatAlloc(&pszSection, TEXT("&"));

        if (pszDunSetting && pszSection)
        {
            pszSection = CmStrCatAlloc(&pszSection, pszDunSetting);

            if (pszSection)
            {
                DWORD dwTcpWindowSize = piniService->GPPI(pszSection, c_pszCmEntryDunTcpIpTcpWindowSize, 0);

                (void)SetTcpWindowSizeOnWin2k(pArgs->rlsRasLink.hInstRas, pArgs->szServiceName, pszRasPbk, dwTcpWindowSize);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("DoRasDial -- unable to allocate section name for setting TcpWindowSize"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("DoRasDial -- unable to allocate section name or dun setting name for setting TcpWindowSize"));
        }

        CmFree (pszDunSetting);
        CmFree (pszSection);
    }

    //
    // On NT5, check for EAP configuration and update the connectoid accordingly.
    //

    if (OS_NT5) 
    {
        //
        // pbEapAuthData can be NULL and dwEapAuthDataSize can be 0. The API handles this.
        // By passing in NULL and 0, we make sure that the CustomAuthData in rasphone.pbk
        // gets cleared.
        //
        if (pArgs->rlsRasLink.pfnSetCustomAuthData)
        {
            dwTmp = pArgs->rlsRasLink.pfnSetCustomAuthData(pszRasPbk, 
                                                           pArgs->pRasDialParams->szEntryName,
                                                           pbEapAuthData, 
                                                           dwEapAuthDataSize);

            CMTRACE1(TEXT("DoRasDial() - SetCustomAuthData returns %u"), dwTmp);

            if (ERROR_SUCCESS != dwTmp)
            {                
                dwRes = dwTmp;
                goto exit;
            }
        }
    }

    //
    // Prepare Phone Number
    //
    
    lstrcpynU(pArgs->pRasDialParams->szPhoneNumber,
              pArgs->aDialInfo[dwEntry].szDialablePhoneNumber,
             sizeof(pArgs->pRasDialParams->szPhoneNumber)/sizeof(TCHAR));

    //
    // Prepare user info
    //
    // #165775 - RADIUS/CHAP authentication requires that we omit the 
    // user specified domain from the dial params and pre-pend it to
    // the user name instead when doing same-name logon. - nickball
    //

    if (!pArgs->fUseTunneling || pArgs->fUseSameUserName)
    {
        pszUsername = pArgs->szUserName;
        pszDomain = pArgs->szDomain; 
        pSecPass = &(pArgs->SecurePW);
    }
    else
    {
        //
        // if there's no username or password, we need to ask the user for it.
        //
        BOOL fIsInetPWEmpty = FALSE;

        fIsInetPWEmpty = pArgs->SecureInetPW.IsEmptyString();

        if (!*pArgs->szInetUserName && 
            !pArgs->fHideInetUsername &&
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUserNameOptional) || 
            fIsInetPWEmpty &&
            !pArgs->fHideInetPassword &&
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional))
        {           
            //
            // We need to collect data from user, determine the dlg template ID
            //

            UINT uiTemplateID = IDD_INTERNET_SIGNIN;

            if (pArgs->fHideInetUsername)
            {
                uiTemplateID = IDD_INTERNET_SIGNIN_NO_UID;
            }
            else if (pArgs->fHideInetPassword)
            {
                uiTemplateID = IDD_INTERNET_SIGNIN_NO_PWD;
            }

            //
            // Now load the dialog
            //

            CInetSignInDlg SignInDlg(pArgs);

            if (IDCANCEL == SignInDlg.DoDialogBox(g_hInst, uiTemplateID, hwndDlg))
            {
                dwRes = ERROR_CANCELLED; 
                goto exit;
            }
        }
        pszUsername = pArgs->szInetUserName;
        
        pSecPass = &(pArgs->SecureInetPW);
    }

    //
    // Apply suffix, prefix, to username as necessary
    //
    
    pszTmp = ApplyPrefixSuffixToBufferAlloc(pArgs, piniService, pszUsername);
    MYDBGASSERT(pszTmp);

    if (pszTmp)
    {
        //
        // Apply domain to username as necessary. Note: Reassigns pszUsername
        //

        pszUsername = ApplyDomainPrependToBufferAlloc(pArgs, piniService, pszTmp, (pArgs->aDialInfo[dwEntry].szDUN));
        MYDBGASSERT(pszUsername);
   
        if (pszUsername)
        {
            lstrcpynU(pArgs->pRasDialParams->szUserName, pszUsername, sizeof(pArgs->pRasDialParams->szUserName)/sizeof(TCHAR));
        }
        
        CmFree(pszUsername);
        CmFree(pszTmp);
    }

    pszUsername = NULL;
    pszTmp = NULL;

    //
    // Update RasDialPArams with domain info if we have any
    //
        
    if (pszDomain)
    {
        lstrcpyU(pArgs->pRasDialParams->szDomain, pszDomain);
    }
    
    //
    // Prepare the password
    //
    
    if (pSecPass)
    {
        fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

        if (fRetPassword && pszClearPassword)
        {
            //
            // Convert password: all upper case, all lower case, or no conversion
            //

            ApplyPasswordHandlingToBuffer(pArgs, pszClearPassword);
                        
            (VOID)pSecPass->SetPassword(pszClearPassword);

            //
            // Clear and Free the clear-text password
            //

            pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
            cbClearPassword = 0;
        }
    }
    else
    {
        dwRes = ERROR_INVALID_DATA;
        goto exit;
    }

    if (pArgs->rlsRasLink.pfnDial) 
    {
         LPTSTR pszDunSetting = GetDunSettingName(pArgs, dwEntry, FALSE);
         LPTSTR pszPhoneBook = GetCMSforPhoneBook(pArgs, dwEntry);
 
         pArgs->Log.Log(PREDIAL_EVENT,
                        pArgs->pRasDialParams->szUserName,
                        pArgs->pRasDialParams->szDomain,
                        SAFE_LOG_ARG(pszPhoneBook),
                        SAFE_LOG_ARG(pszDunSetting),
                        pArgs->szDeviceName,
                        pArgs->aDialInfo[dwEntry].szDialablePhoneNumber);

        CmFree(pszDunSetting);
        CmFree(pszPhoneBook);
        //
        // Run pre-dial connect action before calling RasDial
        //

        CActionList PreDialActList;
        PreDialActList.Append(pArgs->piniService, c_pszCmSectionPreDial);

        if (!PreDialActList.RunAccordType(hwndDlg, pArgs))
        {
            //
            // Some pre-tunnel connect action failed
            //
            dwRes = ERROR_INVALID_DLL; // Only used for failed CA
        }
        else
        {
            // 
            // Set state and tick counters.
            //
            
            pArgs->psState = PS_Dialing;
            pArgs->dwStateStartTime = GetTickCount();
            pArgs->nLastSecondsDisplay = (UINT) -1;

            //
            // Record the initial Dial-Up Adapter Statistic info
            // open the registry key for the perfmon data
            //

            if (pArgs->pConnStatistics)
            {
                pArgs->pConnStatistics->InitStatistics();
            }
                        
            if (OS_NT)
            {
                BOOL    fUsePausedStates = TRUE;
                BOOL    fUseCustomScripting = !!(preRasEntry->dwfOptions & RASEO_CustomScript); // OS_NT51 (whistler+) only

                if (OS_NT4)
                {                   
                    //
                    // If a script is specified, then explcitly don't handle 
                    // pause states. This is because we can't handle the script
                    // pause state. On W2K, RAS is smart enough not to send us
                    // the scripting pause state because we have the terminal
                    // option turned off.
                    //
                                   
                    if (preRasEntry->szScript[0] != TEXT('\0'))
                    {
                        fUsePausedStates = FALSE;
                    }
                }

                dwRes = SetRasDialExtensions(pArgs, fUsePausedStates, fUseCustomScripting);
                
                if (dwRes != ERROR_SUCCESS) 
                {
                    goto exit;
                }

                //
                // On NT5, we may be getting credentials via EAP
                //

                if (OS_NT5 && ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey)
                {
                    //
                    // We're using EAP, get credentials from EAP through RAS
                    //

                    dwRes = GetEapUserId(pArgs, 
                                         hwndDlg, 
                                         pszRasPbk, 
                                         pbEapAuthData, 
                                         dwEapAuthDataSize, 
                                         ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey,
                                         &lpRasEapUserIdentity);

                    if (ERROR_SUCCESS != dwRes)
                    {
                        goto exit;
                    }
                }
            }

            CMTRACE1(TEXT("DoRasDial: pArgs->pRasDialParams->szUserName is %s"), pArgs->pRasDialParams->szUserName);
            CMTRACE1(TEXT("DoRasDial: pArgs->pRasDialParams->szDomain is %s"), pArgs->pRasDialParams->szDomain);
            CMTRACE1(TEXT("DoRasDial: pArgs->pRasDialParams->szPhoneNumber is %s"), pArgs->pRasDialParams->szPhoneNumber);
            
            //
            // Decode the password, and fill dial params, then re-encode both the pArgs
            // version of the password and the dial params copy.
            //

            fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

            if (fRetPassword && pszClearPassword)
            {
                lstrcpynU(pArgs->pRasDialParams->szPassword, pszClearPassword, sizeof(pArgs->pRasDialParams->szPassword)/sizeof(TCHAR));

                //
                // Clear and Free the clear-text password
                //

                pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
                cbClearPassword = 0;
            }

            //
            //  Write the RasDialParams if necessary.
            //  We must keep this, even though RasSetEntryDialParams() is expensive.  Inverse uses the
            //  information stored in the DialParams structure.  However, since this can cause problems
            //  with EAP (overwriting the saved PIN for instance) we will make the storing of the 
            //  credential information configurable by a CMS flag.  Specifically, the WriteRasDialParams
            //  flag in the [Connection Manager] section. If the flag is 1, then we will write the 
            //  RasDialParams and otherwise we won't.  Note that the flag defaults to 0.
            //  Please see bug 399976 for reference.
            //
            if (piniService->GPPI(c_pszCmSection, c_pszCmEntryWriteDialParams))
            {
                //
                //  Note that since we throw the connectoid away if we are on NT and
                //  doing a double dial, there is no point in making an expensive set
                //  dial params call on it.
                //
                if ((!pArgs->fUseTunneling && pArgs->fRememberMainPassword) ||
                    (pArgs->fUseTunneling && pArgs->fRememberInetPassword && OS_W9X))
                {
                    DWORD dwResDbg = pArgs->rlsRasLink.pfnSetEntryDialParams(pszRasPbk, pArgs->pRasDialParams, FALSE);
                    CMTRACE1(TEXT("DoRasDial() SetEntryDialParams returns %u."), dwResDbg);
        
                }
                else
                {
                    //
                    // Forget the password, note that the DialParams contain the password but we set the 
                    // fRemovePassword flag to TRUE so the password will be removed anyway.
                    //
                    DWORD dwResDbg = pArgs->rlsRasLink.pfnSetEntryDialParams(pszRasPbk, 
                                                                             pArgs->pRasDialParams, TRUE);
                    CMTRACE1(TEXT("DoRasDial() SetEntryDialParams returns %u."), dwResDbg);
                }
            }
            
            //
            // Do the dial (PPP)
            //

            if (OS_NT)
            {
                lstrcpyU(pArgs->pRasDialParams->szCallbackNumber, TEXT("*"));
            }

            //
            //  check to ensure we're not already in a Cancel operation
            //
            LONG lInConnectOrCancel = InterlockedExchange(&(pArgs->lInConnectOrCancel), IN_CONNECT_OR_CANCEL);
            CMASSERTMSG(((NOT_IN_CONNECT_OR_CANCEL == lInConnectOrCancel) || (IN_CONNECT_OR_CANCEL == lInConnectOrCancel)),
                        TEXT("DoRasDial - synch variable has unexpected value!"));

            if (NOT_IN_CONNECT_OR_CANCEL == lInConnectOrCancel)
            {
                dwRes = pArgs->rlsRasLink.pfnDial(pArgs->pRasDialExtensions, 
                                                  pszRasPbk, 
                                                  pArgs->pRasDialParams, 
                                                  GetRasCallBackType(),               
                                                  GetRasCallBack(pArgs),               
                                                  &pArgs->hrcRasConn);
            }
            else
            {
                // this is a rare stress case - deliberately did not set dwRes to error value.
                CMTRACE(TEXT("DoRasDial() did not dial, we are already in a Cancel operation"));
            }

            (void) InterlockedExchange(&(pArgs->lInConnectOrCancel), NOT_IN_CONNECT_OR_CANCEL);

            //
            // No need for us to hold on to this password in this structure since 
            // we are done using it.
            //
            CmWipePassword(pArgs->pRasDialParams->szPassword);

            CMTRACE1(TEXT("DoRasDial() RasDial() returns %u."), dwRes);
            if (dwRes != ERROR_SUCCESS) 
            {
                pArgs->hrcRasConn = NULL;
                goto exit;
            }
        }
    }

exit:

    if (lpRasEapUserIdentity)
    {
        MYDBGASSERT(OS_NT5); // NO EAP down-level

        //
        // A RasEapUserIdentity struct was allocated, free it via the 
        // appropriate free mechanism. In the WinLogon case we will always
        // perform the allocation, otherwise we have to go through RAS API.
        //

        if (pArgs->lpEapLogonInfo)
        {
            CmFree(lpRasEapUserIdentity);
        }
        else
        {
            if (pArgs->rlsRasLink.pfnFreeEapUserIdentity) 
            {
                pArgs->rlsRasLink.pfnFreeEapUserIdentity(lpRasEapUserIdentity);  
            }       
        }
    }

    CmFree(pbEapAuthData);
    CmFree(preRasEntry);

    delete piniService;

    return dwRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoTunnelDial
//
//  Synopsis:   call RasDial to dial up to the tunnel server
//
//  Arguments:  hwndDlg  [dlg window handle]
//              pargs    pointer to ArgValue structure
//
// Returns:   DWORD - 
//              ERROR_SUCCESS if success
//              ERROR_NOT_ENOUGH_MEMORY
//              E_UNEXPECTED, unexpected error, such as phone entry not found
//              Otherwise, RAS error
//
//  History:    byao        Created     3/1/97
//              fengsun     change return type to DWORD 3/6/98
//
//----------------------------------------------------------------------------
DWORD DoTunnelDial(IN HWND hwndDlg, IN ArgsStruct *pArgs)
{
    LPRASENTRY              preRasEntry = NULL;
    LPRASEAPUSERIDENTITY    lpRasEapUserIdentity = NULL;
    LPTSTR pszVpnSetting        = NULL;

    LPBYTE  pbEapAuthData       = NULL;                 // Ptr to Eap Data 
    DWORD   dwEapAuthDataSize   = 0;                    // The size of the EAP blob if any
    CSecurePassword* pSecPass = &(pArgs->SecurePW);
    LPTSTR pszClearPassword = NULL;
    DWORD cbClearPassword = 0;
    BOOL fRetPassword = FALSE;

    DWORD   dwRes               = (DWORD)E_UNEXPECTED;
    DWORD   dwTmp;

    MYDBGASSERT(pArgs->hrcTunnelConn == NULL);
    pArgs->hrcTunnelConn = NULL;
    
    //
    // What's the tunnel end point? Do this now so that the UI can be updated
    // properly if lana wait or pre-tunnel actions are time consuming.  
    //

    LPTSTR pszTunnelIP = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);
    if (pszTunnelIP)
    {
        if (lstrlenU(pszTunnelIP) > RAS_MaxPhoneNumber) 
        {
            pszTunnelIP[0] = TEXT('\0');
        }

        pArgs->SetPrimaryTunnel(pszTunnelIP);
        CmFree(pszTunnelIP);
    }

    //
    // See if tunnel server was specified
    //

    if (!(pArgs->GetTunnelAddress()[0])) 
    { 
        CMASSERTMSG(FALSE, TEXT("DoTunnelDial() TunnelAddress is invalid."));
        return ERROR_BAD_ADDRESS_SPECIFIED;
    }

    CMTRACE1(TEXT("DoTunnelDial() - TunnelAddress is %s"), pArgs->GetTunnelAddress());
    
    //
    //  Caution should be used when changing this if statement.  We want this to happen both for direct connect
    //  and for double dial connections.  You can still get into the LANA situation with two CM
    //  connections dialed independently (one to the internet and the other a tunnel), doing the lana
    //  wait for direct connections prevents the lana registration problem from occuring in this situation.
    //  Note that the Lana wait isn't necessary on Win98 SE or Win98 Millennium because the DUN bug
    //  is fixed.  Thus we have reversed the default and will only do the LANA wait if the reg key exists
    //  and specifies that the wait should be performed.
    //
    if (OS_W9X) 
    {
        //
        // Sets us up to wait for Vredir to register LANA for connection to internet
        // Note: Returns FALSE if the user hits cancel while we are waiting. In this 
        // event, we should not continue the tunnel dial.
        //

        if (FALSE == LanaWait(pArgs, hwndDlg))
        {
            return ERROR_SUCCESS;
        }
    }

    LPTSTR pszDunSetting = GetDunSettingName(pArgs, -1, TRUE);

    pArgs->Log.Log(PRETUNNEL_EVENT,
                     pArgs->szUserName,
                     pArgs->szDomain,
                     SAFE_LOG_ARG(pszDunSetting),
                     pArgs->szTunnelDeviceName,
                     pArgs->GetTunnelAddress());

    CmFree(pszDunSetting);

    CActionList PreTunnelActList;
    if (PreTunnelActList.Append(pArgs->piniService, c_pszCmSectionPreTunnel))
    {
        CMTRACE(TEXT("DoTunnelDial() - Running Pre-Tunnel actions"));
        
        if (!PreTunnelActList.RunAccordType(hwndDlg, pArgs))
        {
            //
            // Some pre-tunnel connect action failed
            //
            dwRes = ERROR_INVALID_DLL; // Only used for failed CA
            goto exit;
        }

        //
        // Now that pre-tunnel actions have run, what's the tunnel end point?
        // We perform this read again here in the event that the pre-tunnel 
        // action modified the tunnel address. Note: This is an exception to 
        // the rule that the .CMS should not be modified on the client side, 
        // especially by 3rd parties.
        //
// REVIEW:  It probably isn't necessary to re-read this with the new VPN tab.  However, some people might still
//          be using the connect action solution that ITG gave out and we want to be careful not to break them if
//          we haven't already.  Thus we will continue to re-read this for Whistler but we should remove it afterwards.
//          quintinb 11-01-00
        pszTunnelIP = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);
      
        if (pszTunnelIP)
        {
            if (lstrlenU(pszTunnelIP) > RAS_MaxPhoneNumber) 
            {
              pszTunnelIP[0] = TEXT('\0');
            }

            pArgs->SetPrimaryTunnel(pszTunnelIP);
            CmFree(pszTunnelIP);
        }
  
        //
        // See if tunnel server was specified
        //

        if (!(pArgs->GetTunnelAddress()[0])) 
        { 
            CMASSERTMSG(FALSE, TEXT("DoTunnelDial() TunnelAddress is invalid."));
            dwRes = (DWORD)ERROR_BAD_ADDRESS_SPECIFIED;
            goto exit;
        }

        CMTRACE1(TEXT("DoTunnelDial() - TunnelAddress is %s"), pArgs->GetTunnelAddress());
    }

    //
    // Setup dial params
    //

    if (!pArgs->pRasDialParams)
    {
        pArgs->pRasDialParams = AllocateAndInitRasDialParams();

        if (!pArgs->pRasDialParams)
        {
            CMTRACE(TEXT("DoTunnelDial: failed to alloc a ras dial params"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    else
    {
        InitRasDialParams(pArgs->pRasDialParams);
    }

    //
    // Get the connectoid name
    //

    LPTSTR pszConnectoid;
    pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, TRUE);
    
    if (!pszConnectoid)
    {
        dwRes = (DWORD)ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpyU(pArgs->pRasDialParams->szEntryName, pszConnectoid);
    
    CmFree(pszConnectoid);

    //
    // We'll create the RAS connectoid if the RAS connectoid doesn't exist.
    // NOTE: Tunnel settings should always be taken from the top-level CMS.
    // so use it when creating the connectoid.
    //
    
    pszVpnSetting = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelDun, TEXT(""));

    preRasEntry = CreateRASEntryStruct(pArgs,
                        (pszVpnSetting ? pszVpnSetting : TEXT("")),
                        pArgs->piniService,
                        TRUE,
                        pArgs->pszRasPbk,
                        &pbEapAuthData,
                        &dwEapAuthDataSize);

    CmFree(pszVpnSetting);

    if (!preRasEntry) 
    {
        dwRes = GetLastError();
        goto exit;
    }

    //
    //  If this is Millennium we need to disable Idle disconnect so that it doesn't
    //  fight with ours.
    //
    if (OS_MIL)
    {
        MYVERIFY(DisableSystemIdleDisconnect(preRasEntry));
    }

    //
    //  We need to delete a second sub entry if it exists.  See 406637 for details
    //
    if (pArgs->rlsRasLink.pfnDeleteSubEntry) // available on NT5 & Millennium currently
    {
        DWORD dwReturn = pArgs->rlsRasLink.pfnDeleteSubEntry(pArgs->pszRasPbk, 
                                                             pArgs->pRasDialParams->szEntryName, 
                                                             (OS_MIL ? 1 : 2)); // see comment in DoRasDial

        CMTRACE1(TEXT("DoTunnelDial -- Called RasDeleteSubEntry to delete a second sub entry if it exists, dwReturn=%d"), dwReturn);
    }

    //
    // On NT5, we have to set the connection type to VPN instead of Internet
    //

    if (OS_NT5)
    {
        MYDBGASSERT(preRasEntry->dwSize >= sizeof(RASENTRY_V500));
        ((LPRASENTRY_V500)preRasEntry)->dwType = RASET_Vpn;
        ((LPRASENTRY_V500)preRasEntry)->szDeviceName[0] = TEXT('\0');  // let RAS pickup the tunnel device
    }

    if (pArgs->rlsRasLink.pfnSetEntryProperties) 
    {

#ifdef DEBUG
        
        LPRASENTRY_V500 lpRasEntry50;
        
        if (OS_NT5)
        {
            lpRasEntry50 = (LPRASENTRY_V500) preRasEntry;
        }
#endif
        
        dwRes = pArgs->rlsRasLink.pfnSetEntryProperties(pArgs->pszRasPbk,
                                                        pArgs->pRasDialParams->szEntryName,
                                                        preRasEntry,
                                                        preRasEntry->dwSize,
                                                        NULL,
                                                        0);
        CMTRACE2(TEXT("DoTunnelDial() RasSetEntryProperties(*lpszEntry=%s) returns %u."),
              MYDBGSTR(pArgs->pRasDialParams->szEntryName), dwRes);

        CMASSERTMSG(dwRes == ERROR_SUCCESS, TEXT("RasSetEntryProperties for VPN failed"));
    }

    //
    //  Set the TCP Window size -- the NTT DoCoMo fix for Win2k.  The Win2k version of this fix
    //  must be written through a private RAS API that must be called after the phonebook entry 
    //  exists ie. after we call RasSetEntryProperties ... otherwise it won't work on the first
    //  dial.
    //
    if (OS_NT5 && !OS_NT51)
    {
        //
        //  Figure out the DUN setting name to use and then build up TCP/IP&DunName.
        //
        pszDunSetting = GetDunSettingName(pArgs, -1, TRUE);
        LPTSTR pszSection = CmStrCpyAlloc(c_pszCmSectionDunTcpIp);
        pszSection = CmStrCatAlloc(&pszSection, TEXT("&"));

        if (pszDunSetting && pszSection)
        {
            pszSection = CmStrCatAlloc(&pszSection, pszDunSetting);

            if (pszSection)
            {
                DWORD dwTcpWindowSize = pArgs->piniService->GPPI(pszSection, c_pszCmEntryDunTcpIpTcpWindowSize, 0);

                (void)SetTcpWindowSizeOnWin2k(pArgs->rlsRasLink.hInstRas, pArgs->szServiceName, pArgs->pszRasPbk, dwTcpWindowSize);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("DoTunnelDial -- unable to allocate section name for setting TcpWindowSize"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("DoTunnelDial -- unable to allocate section name or dun setting name for setting TcpWindowSize"));
        }

        CmFree (pszDunSetting);
        CmFree (pszSection);
    }
    
    //
    // On NT5, check for EAP configuration and update the connectoid accordingly.
    //

    if (OS_NT5) 
    {
        //
        // pbEapAuthData can be NULL and dwEapAuthDataSize can be 0. The API handles this.
        // By passing in NULL and 0, we make sure that the CustomAuthData in rasphone.pbk
        // gets cleared.
        //
        if (pArgs->rlsRasLink.pfnSetCustomAuthData)
        {
            dwTmp = pArgs->rlsRasLink.pfnSetCustomAuthData(pArgs->pszRasPbk, 
                                                           pArgs->pRasDialParams->szEntryName,
                                                           pbEapAuthData, 
                                                           dwEapAuthDataSize);
            if (ERROR_SUCCESS != dwTmp)
            {
                CMTRACE(TEXT("DoTunnelDial() - SetCustomAuthData failed"));
                dwRes = dwTmp;
                goto exit;
            }
        }
    }

    //
    // Phone Number for PPTP is the DNS name of IP addr of PPTP server
    //
    
    lstrcpynU(pArgs->pRasDialParams->szPhoneNumber,pArgs->GetTunnelAddress(), sizeof(pArgs->pRasDialParams->szPhoneNumber));

    //
    // Prepare User Name and Domain  
    //

    lstrcpyU(pArgs->pRasDialParams->szUserName, pArgs->szUserName);
    lstrcpyU(pArgs->pRasDialParams->szDomain, pArgs->szDomain);
       
    //
    // Prepare the password
    //

    if (pSecPass)
    {
        fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

        if (fRetPassword && pszClearPassword)
        {
            //
            // Convert password: all upper case, all lower case, or no conversion
            //

            ApplyPasswordHandlingToBuffer(pArgs, pszClearPassword);
                        
            (VOID)pSecPass->SetPassword(pszClearPassword);

            //
            // Clear and Free the clear-text password
            //

            pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
            cbClearPassword = 0;
        }
    }
    else
    {
        CMTRACE(TEXT("DoTunnelDial() - CmSecurePassword object (pSecPass) is NULL!"));
        dwRes = ERROR_INVALID_DATA;
        goto exit;
    }

    if (pArgs->rlsRasLink.pfnDial) 
    {
        if (pArgs->IsDirectConnect())
        {
            //
            // Record the initial Dial-Up Adapter Statistic info.
            //

            if (pArgs->pConnStatistics)
            {
                pArgs->pConnStatistics->InitStatistics();
            }
        }            

        if (OS_NT)
        {
            MYDBGASSERT(TEXT('\0') == preRasEntry->szScript[0]); // we should never have a script on a tunnel connection

            dwRes = SetRasDialExtensions(pArgs, TRUE, FALSE); // TRUE == fUsePausedStates, FALSE == fEnableCustomScripting
            
            if (dwRes != ERROR_SUCCESS) 
            {
                goto exit;
            }

            //
            // On NT5, we may be getting credentials via EAP
            //

            if (OS_NT5 && ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey)
            {
                //
                // We're using EAP, get credentials from EAP through RAS
                //

                dwRes = GetEapUserId(pArgs, 
                                     hwndDlg, 
                                     pArgs->pszRasPbk, 
                                     pbEapAuthData, 
                                     dwEapAuthDataSize, 
                                     ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey,
                                     &lpRasEapUserIdentity);

                if (ERROR_SUCCESS != dwRes)
                {
                    goto exit;
                }
            }
        }

        CMTRACE1(TEXT("DoTunnelDial: pArgs->pRasDialParams->szUserName is %s"), pArgs->pRasDialParams->szUserName);
        CMTRACE1(TEXT("DoTunnelDial: pArgs->pRasDialParams->szDomain is %s"), pArgs->pRasDialParams->szDomain);
        CMTRACE1(TEXT("DoTunnelDial: pArgs->pRasDialParams->szPhoneNumber is %s"), pArgs->pRasDialParams->szPhoneNumber);
        
        //
        // Get the password before dialing.
        //

        fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

        if (fRetPassword && pszClearPassword)
        {
            lstrcpyU(pArgs->pRasDialParams->szPassword, pszClearPassword);

            //
            // Clear and Free the clear-text password
            //

            pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
            cbClearPassword = 0;
        }
        

        //
        // Do the dial (PPTP or L2TP)
        //

        dwRes = pArgs->rlsRasLink.pfnDial(pArgs->pRasDialExtensions, 
                                          pArgs->pszRasPbk, 
                                          pArgs->pRasDialParams, 
                                          GetRasCallBackType(),               
                                          GetRasCallBack(pArgs),               
                                          &pArgs->hrcTunnelConn);

        //
        // No need for us to hold on to this password in this structure since 
        // we are done using it.
        //
        CmWipePassword(pArgs->pRasDialParams->szPassword);

        CMTRACE1(TEXT("DoTunnelDial() RasDial() returns %u."), dwRes);

        //
        // NT5 - Reset the connection type so that it will display properly in 
        // the Connections Folder. This is a temporary solution to #187202
        //

        if (OS_NT5)
        {
            MYDBGASSERT(preRasEntry->dwSize >= sizeof(RASENTRY_V500));
            ((LPRASENTRY_V500)preRasEntry)->dwType = RASET_Internet;

            if (pArgs->rlsRasLink.pfnSetEntryProperties) 
            {
                dwTmp = pArgs->rlsRasLink.pfnSetEntryProperties(pArgs->pszRasPbk,
                                                                pArgs->pRasDialParams->szEntryName,
                                                                preRasEntry,
                                                                preRasEntry->dwSize,
                                                                NULL,
                                                                0);

                CMTRACE2(TEXT("DoTunnelDial() RasSetEntryProperties(*lpszEntry=%s) returns %u."),
                         MYDBGSTR(pArgs->pRasDialParams->szEntryName), dwTmp);

                CMASSERTMSG(dwTmp == ERROR_SUCCESS, TEXT("RasSetEntryProperties for VPN failed"));
            }
        }

        if (dwRes != ERROR_SUCCESS) 
        {
            pArgs->hrcTunnelConn = NULL;            
            goto exit;
        }
    }

exit:

    if (lpRasEapUserIdentity)
    {
        MYDBGASSERT(OS_NT5); // NO EAP down-level

        //
        // A RasEapUserIdentity struct was allocated, free it via the 
        // appropriate free mechanism. In the WinLogon case we will always
        // perform the allocation, otherwise we have to go through RAS API.
        //

        if (pArgs->lpEapLogonInfo)
        {
            CmFree(lpRasEapUserIdentity);
        }
        else
        {
            if (pArgs->rlsRasLink.pfnFreeEapUserIdentity) 
            {
                pArgs->rlsRasLink.pfnFreeEapUserIdentity(lpRasEapUserIdentity);  
            }       
        }
    }

    CmFree(preRasEntry); // Now we can release the RAS entry structure. #187202 
    CmFree(pbEapAuthData);

    return dwRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckConnect
//
//  Synopsis:   double check to make sure all required fields are filled in, such
//              as username, password, modem, etc.
//
//  Arguments:  hwndDlg         [dlg window handle]
//              pArgs           pointer to ArgValue structure
//              pnCtrlFocus     The button whose value is missing will have the focus
//              fShowMsg        Whether a message should be shown to the user or not. Default value of FALSE.
//
//  Returns:    True is ready to connect
//
//  History:    byao            Modified        3/7/97
//              nickball        return BOOLEAN  9/9/98
//
//----------------------------------------------------------------------------
BOOL CheckConnect(HWND hwndDlg, 
                  ArgsStruct *pArgs, 
                  UINT *pnCtrlFocus,
                  BOOL fShowMsg) 
{
    LPTSTR pszTmp;
    BOOL bEnable = TRUE;
    int nId = 0;
    UINT nCtrlFocus;
    BOOL bSavedNoNotify = pArgs->fIgnoreChangeNotification;

    pArgs->fIgnoreChangeNotification = TRUE;
    
    MYDBGASSERT(*pArgs->piniProfile->GetFile());

    if (bEnable && IsTunnelEnabled(pArgs)) 
    {
        //
        //  If we already have a device picked, no need to pick a new one...
        //
        if ((pArgs->szTunnelDeviceName[0] == TEXT('\0')) || (pArgs->szTunnelDeviceType[0] == TEXT('\0')))
        {

            lstrcpyU(pArgs->szTunnelDeviceType, RASDT_Vpn);

            //
            // Pick the tunnel device
            //
            if (!PickTunnelDevice(pArgs, pArgs->szTunnelDeviceType, pArgs->szTunnelDeviceName)) 
            {
                //
                // If we can't pick a tunnel device make sure tunneling is installed
                //

                //
                // Disable the connect/setting button during component checking and installation
                //

                EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);                   
                EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_PROPERTIES_BUTTON), FALSE);                   

                //
                // Install the PPTP and pick tunnel device one more time
                //
                DWORD dwComponentsToCheck = CC_PPTP | CC_RNA | CC_RASRUNNING 
                                                | CC_TCPIP| CC_CHECK_BINDINGS;

                if (TRUE == pArgs->bDoNotCheckBindings)
                {
                    dwComponentsToCheck &= ~CC_CHECK_BINDINGS;
                }
            
                //
                // PPTP is not installed.  
                // If not unattended, try to install the PPTP and call PickTunnel again
                //

                pArgs->dwExitCode = ERROR_PORT_NOT_AVAILABLE;

                if (!(pArgs->dwFlags & FL_UNATTENDED))
                {
                    pArgs->dwExitCode = CheckAndInstallComponents(dwComponentsToCheck, 
                                                                  hwndDlg, pArgs->szServiceName);
                }

                if (pArgs->dwExitCode != ERROR_SUCCESS ||
                    !PickTunnelDevice(pArgs, pArgs->szTunnelDeviceType, pArgs->szTunnelDeviceName))
                {
                    bEnable = FALSE;                
                    nId = GetPPTPMsgId();                    
                    nCtrlFocus = IDCANCEL;
                }

                EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_PROPERTIES_BUTTON), TRUE);
            }
        }
    }

    

    //
    // Next, check the username.
    //
    
    if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT))
    {
        if (bEnable && 
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUserNameOptional)) 
        {
            if (!SendDlgItemMessageU(hwndDlg, IDC_MAIN_USERNAME_EDIT, WM_GETTEXTLENGTH, 0, (LPARAM)0))
            {
                bEnable = FALSE;
                nId = IDMSG_NEED_USERNAME;
                nCtrlFocus = IDC_MAIN_USERNAME_EDIT;
            }
        }
    }

    //
    // Next, check the password.
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT))
    {
        if (!pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional)) 
        {
            if (!SendDlgItemMessageU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, WM_GETTEXTLENGTH, 0, (LPARAM)0))
            {
                if (bEnable)
                {
                    bEnable = FALSE;
                    nId = IDMSG_NEED_PASSWORD;
                    nCtrlFocus = IDC_MAIN_PASSWORD_EDIT;
                }

                //
                // Disable "Remember password" check box
                //
                if (!pArgs->fHideRememberPassword)
                {
                    pArgs->fRememberMainPassword = FALSE;
                    CheckDlgButton(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX, FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);

                    if (pArgs->fGlobalCredentialsSupported)
                    {
                        //
                        // Also disable the option buttons
                        //
                        EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);
                        EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
                    }

                }
            
                //
                // disable the "dial automatically..." checkbox
                //
                if (!pArgs->fHideDialAutomatically)
                {
                    pArgs->fDialAutomatically = FALSE;
                    pArgs->fRememberMainPassword = FALSE;
                    CheckDlgButton(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX, FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
                }
            }
            else
            {
                //
                // Enable the "Remember password" checkbox
                //
                if (!pArgs->fHideRememberPassword)
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), TRUE);
                }

                //
                // Enable the "dial automatically..." checkbox
                // if HideDialAutomatically is not set
                // and if Password is not optional, Remember Password must be true
                //
                if ((!pArgs->fHideDialAutomatically) && 
                    (pArgs->fRememberMainPassword ||
                     pArgs->piniService->GPPB(c_pszCmSection, 
                                                c_pszCmEntryPwdOptional)))
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), TRUE);
                }
            }
        }
    }

    //
    // Next, check the domain.
    //
    
    if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT))
    {
        if (bEnable && 
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryDomainOptional, TRUE)) 
        {
            if (!SendDlgItemMessageU(hwndDlg, IDC_MAIN_DOMAIN_EDIT, WM_GETTEXTLENGTH, 0, (LPARAM)0))
            {
                bEnable = FALSE;
                nId = IDMSG_NEED_DOMAIN;
                nCtrlFocus = IDC_MAIN_DOMAIN_EDIT;
            }
        }
    }

    //
    // Check whether primary phone number is empty -- a quick fix for bug 3123  -byao (4/11/97)
    //

    if (!pArgs->IsDirectConnect())
    {
        //
        // Its not a direct connection, so we must check the phonenumber. If both 
        // szPhoneNumber and szCanonical are blank then we don't have a number.
        //
        
        if (bEnable && 
            IsBlankString(pArgs->aDialInfo[0].szPhoneNumber) &&
            IsBlankString(pArgs->aDialInfo[0].szCanonical))
        {
            bEnable = FALSE;
            
            if (pArgs->fNeedConfigureTapi)
            {
                nId = IDMSG_NEED_CONFIGURE_TAPI;
            }
            else
            {
                //
                // If direct and dial-up,the message should include the 
                // possibility of direct connection, otherwise use
                // the standard need a phone number message
                //
                
                if (pArgs->IsBothConnTypeSupported())
                {
                    nId = IDMSG_NEED_PHONE_DIRECT;
                }
                else
                {
                    nId = IDMSG_NEED_PHONE_DIAL;
                }
            }
            
            nCtrlFocus = IDC_MAIN_PROPERTIES_BUTTON;
        }
    }
    
    //
    //  If tunneling is enabled and we are using a VPN file, make sure
    //  the user has selected a tunnel endpoint.
    //
    if (bEnable && IsTunnelEnabled(pArgs) && pArgs->pszVpnFile) 
    {
        LPTSTR pszTunnelAddress = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);

        if ((NULL == pszTunnelAddress) || (TEXT('\0') == pszTunnelAddress[0]))
        {
            bEnable = FALSE;
            nId = IDMSG_PICK_VPN_ADDRESS;
            nCtrlFocus = IDC_MAIN_PROPERTIES_BUTTON;
        }

        CmFree(pszTunnelAddress);
    }

    if (bEnable) 
    {
        //
        // well, now we can set the focus to the 'connect' button
        // Display ready to dial message
        //
        nCtrlFocus = IDOK;
        nId = IDMSG_READY;
    }

    if (pnCtrlFocus) 
    {
        *pnCtrlFocus = nCtrlFocus;
    }

    pszTmp = CmFmtMsg(g_hInst,nId);

    if (NULL == pszTmp)
    {
        return FALSE;
    }
    
    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTmp); 

    //
    // If necessary, throw a message box at the user.
    //

    if (!bEnable && fShowMsg)
    {
        MessageBoxEx(hwndDlg, 
                     pszTmp, 
                     pArgs->szServiceName, 
                     MB_OK|MB_ICONINFORMATION,
                     LANG_USER_DEFAULT);

    }

    CmFree(pszTmp);
    pArgs->fIgnoreChangeNotification = bSavedNoNotify;

    //
    // Something went wrong in the config.  we need to recheck the
    // configs next time we run CM.
    //

    if (GetPPTPMsgId() == nId) // not an assignment, stay left                   
    {
        ClearComponentsChecked();
    }

    return bEnable;
}

void MainSetDefaultButton(HWND hwndDlg, 
                          UINT nCtrlId) 
{
    switch (nCtrlId) 
    {
        case IDCANCEL:
        case IDC_MAIN_PROPERTIES_BUTTON:
            break;

        default:
            nCtrlId = IDOK;
            break;
    }

    SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)nCtrlId, 0);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetMainDlgUserInfo
//
//  Synopsis:   Set user info in the main dlg.  
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//
//  Returns:    NONE
//
//  History:    henryt  Created     5/5/97
//
//----------------------------------------------------------------------------
void SetMainDlgUserInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
) 
{
    HWND hwndTemp = NULL;

    //
    // Fill in the edit controls that exist
    // Set the textbox modification flag. For Win9x compatibily issues we have to explicitly
    // call SendMessageU instead of using the Edit_SetModify macro. The flag is used to see 
    // if the user has manually changed the contents of the edit boxes.
    //
    
    if (pArgs->fAccessPointsEnabled)
    {
        //
        // This fuction populates the combo box passed to it with info from the reg
        //
        ShowAccessPointInfoFromReg(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO);
    }

    hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT);
    if (hwndTemp)
    {
        SetDlgItemTextU(hwndDlg, IDC_MAIN_USERNAME_EDIT, pArgs->szUserName);
        SendMessageU(hwndTemp, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }
    
    hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
    if (hwndTemp)
    {
        LPTSTR pszClearPassword = NULL;
        DWORD cbClearPassword = 0;
        BOOL fRetPassword = FALSE;

        fRetPassword = pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

        if (fRetPassword && pszClearPassword)
        {
            SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, pszClearPassword);
            SendMessageU(hwndTemp, EM_SETMODIFY, (WPARAM)FALSE, 0L);

            //
            // Clear and Free the clear-text password
            //

            pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
        }
    }

    hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT);
    if (hwndTemp) // !pArgs->fHideDomain)
    {
        SetDlgItemTextU(hwndDlg, IDC_MAIN_DOMAIN_EDIT, pArgs->szDomain);
        SendMessageU(hwndTemp, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   OnResetPassword
//
//  Synopsis:   Handle reset password.
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//
//  Returns:    BOOL -- TRUE if SUCCEEDED
//
//  History:    henryt  Created     5/6/97
//
//----------------------------------------------------------------------------
BOOL OnResetPassword(HWND hwndDlg, ArgsStruct *pArgs)
{
    LPTSTR pszArgs = NULL;
    LPTSTR pszCmd = NULL;
    BOOL bReturn = FALSE;

    MYDBGASSERT(pArgs); 
    MYDBGASSERT(pArgs->pszResetPasswdExe);

    //
    // Get the latest password data from the edit control 
    // and obfuscate its contents so that connect actions
    // can't retrieve it.
    //

    GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
    ObfuscatePasswordEdit(pArgs);
   
    if (pArgs && pArgs->pszResetPasswdExe)
    {    
        if (CmParsePath(pArgs->pszResetPasswdExe, pArgs->piniService->GetFile(), &pszCmd, &pszArgs))
        {
            pArgs->Log.Log(PASSWORD_RESET_EVENT, pszCmd);

            SHELLEXECUTEINFO ShellExInfo;

            ZeroMemory(&ShellExInfo, sizeof(SHELLEXECUTEINFO));

            //
            //  Fill in the Execute Struct
            //
            ShellExInfo.cbSize = sizeof(SHELLEXECUTEINFO);
            ShellExInfo.hwnd = hwndDlg;
            ShellExInfo.lpVerb = TEXT("open");
            ShellExInfo.lpFile = pszCmd;
            ShellExInfo.lpParameters = pszArgs;
            ShellExInfo.nShow = SW_SHOWNORMAL;

            bReturn = pArgs->m_ShellDll.ExecuteEx(&ShellExInfo);            
        }

        CmFree(pszCmd);
        CmFree(pszArgs);
    }

#ifdef DEBUG
    CMASSERTMSG(bReturn, TEXT("OnResetPassword() - ShellExecute failed."));
#endif

    DeObfuscatePasswordEdit(pArgs);

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnCustom
//
//  Synopsis:   Handle custom button
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//
//  Returns:    NONE
//
//  History:    t-adnani    Created     6/26/99
//
//----------------------------------------------------------------------------
void OnCustom(
    HWND        hwndDlg,
    ArgsStruct  *pArgs)
{
    MYDBGASSERT(pArgs); 
    
    if (NULL == pArgs)
    {
        return;
    }

    pArgs->Log.Log(CUSTOM_BUTTON_EVENT);
    //
    // Get the latest password data from the edit control 
    // and obfuscate its contents so that connect actions
    // can't retrieve it.
    //

    GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
    ObfuscatePasswordEdit(pArgs);

    //
    // Run the CustomButton actions
    //

    int iTextBoxLength = (int) SendDlgItemMessage(hwndDlg, IDC_MAIN_STATUS_DISPLAY, WM_GETTEXTLENGTH, 0, (LPARAM)0) + 1;
    TCHAR *pszTextBoxContents = (TCHAR *) CmMalloc(iTextBoxLength * sizeof(TCHAR));

    if (pszTextBoxContents)
    {
        GetDlgItemText(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTextBoxContents, iTextBoxLength);
    }
    CActionList CustomActList;
    CustomActList.Append(pArgs->piniService, c_pszCmSectionCustom);

    if (!CustomActList.RunAccordType(hwndDlg, pArgs))
    {
        //
        // Connect action failed
        //
    }
    else
    {
        if (pszTextBoxContents)
        {
            SetDlgItemText(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTextBoxContents); 
        }
    }
    CmFree(pszTextBoxContents);

    DeObfuscatePasswordEdit(pArgs);
}
    
//----------------------------------------------------------------------------
//
//  Function:   SetupInternalInfo
// 
//  Synopsis:   Load system dll's and init ArgsStruct with info from cmp/cms. 
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//              
//  Returns:    NONE
//
//  History:    henryt      created 8/13/97
//
//----------------------------------------------------------------------------
BOOL SetupInternalInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
)
{
    HCURSOR hcursorPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));
    BOOL    fRet = FALSE;

    //
    //  Check to see if the SafeNet Client is available.
    //
    if ((OS_W9X || OS_NT4) && IsSafeNetClientAvailable())
    {
        SafeNetLinkageStruct SnLinkage = {0};

        if (LinkToSafeNet(&SnLinkage))
        {
            UnLinkFromSafeNet(&SnLinkage);
            pArgs->bSafeNetClientAvailable = TRUE;
        }
    }

    //
    //  Should we check if TCP is bound to PPP?  Note that if the SafeNet client is installed, we
    //  automatically don't check bindings because the Deterministic Networks shim is in the way
    //  and bindings checking will fail.
    //
    if (pArgs->bSafeNetClientAvailable)
    {
        pArgs->bDoNotCheckBindings = TRUE;
    }
    else
    {
        pArgs->bDoNotCheckBindings = pArgs->piniService->GPPB(c_pszCmSection, 
                                                              c_pszCmEntryDoNotCheckBindings,
                                                              FALSE);
    }

    DWORD dwComponentsToCheck = CC_RNA | CC_TCPIP | CC_RASRUNNING 
                                | CC_SCRIPTING | CC_CHECK_BINDINGS;

    if (TRUE == pArgs->bDoNotCheckBindings)
    {
        //
        // Do not check if TCP is bound to PPP
        //
        dwComponentsToCheck &= ~CC_CHECK_BINDINGS;
    }

#if 0 // Don't do this until the user gets into the app.
/*    
    //
    // If current connection type is dial-up (not Direct means Dial-up), 
    // then check modem
    //
    if (!pArgs->IsDirectConnect())
    {
        dwComponentsToCheck |= CC_MODEM;
    }
*/
#endif

    if (TRUE == IsTunnelEnabled(pArgs))
    {
        dwComponentsToCheck |= CC_PPTP;
    }

    //
    // should we check OS components, regardless what is in the registry key
    // Default is use the  registry key
    //
    BOOL fIgnoreRegKey = pArgs->piniService->GPPB(c_pszCmSection, 
                                                         c_pszCmEntryCheckOsComponents,
                                                         FALSE);

    //
    // If fIgnoreRegKey is TRUE, Do not bother looking ComponentsChecked from registry.
    // in 'Unattended Dialing' mode, check only, do not try to install
    //
    pArgs->dwExitCode = CheckAndInstallComponents( dwComponentsToCheck,
            hwndDlg, pArgs->szServiceName, fIgnoreRegKey, pArgs->dwFlags & FL_UNATTENDED);

    if (pArgs->dwExitCode != ERROR_SUCCESS )
    {
        goto done;
    }
 
    //
    // If we haven't loaded RAS yet, do so now.
    //
    if (!IsRasLoaded(&(pArgs->rlsRasLink)))
    {
        if (!LinkToRas(&pArgs->rlsRasLink))
        {
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                goto done;
            }

            //
            // Something terrible happened!  We want to check our configs and install
            // necessary components now.  
            //
            dwComponentsToCheck = CC_RNA | CC_RASRUNNING | CC_TCPIP;

            if (TRUE != pArgs->bDoNotCheckBindings)
            {
                dwComponentsToCheck |= CC_CHECK_BINDINGS;
            }

            pArgs->dwExitCode = CheckAndInstallComponents(dwComponentsToCheck, hwndDlg, pArgs->szServiceName);

            if (pArgs->dwExitCode != ERROR_SUCCESS || !LinkToRas(&pArgs->rlsRasLink))
            {
                goto done;
            }
        }
    }
        
    //
    // Load properties data   
    //
   
    LoadProperties(pArgs);

    //
    // Get phone info(phone #'s, etc) 
    // CheckConnect will check for empty phone number
    //

    LoadPhoneInfoFromProfile(pArgs);

    

    fRet = TRUE;

done:
    SetCursor(hcursorPrev);
    return fRet;
}

//----------------------------------------------------------------------------
//
//  Function:   OnMainLoadStartupInfo
// 
//  Synopsis:   Load the startup info for the main dlg(after WM_INITDIALOG).
//              This includes loading system dll's and setting up the UI.
//
//  Arguments:  hwndDlg         - the main dlg
//              pArgs           - the ArgStruct *
//              
//  Returns:    NONE
//
//  History:    henryt      created 8/13/97
//
//----------------------------------------------------------------------------

void OnMainLoadStartupInfo(
    HWND hwndDlg, 
    ArgsStruct *pArgs
) 
{
    UINT    i;
    UINT    nCtrlFocus;
    BOOL    fSaveNoNotify = pArgs->fIgnoreChangeNotification;

    pArgs->fStartupInfoLoaded = TRUE;

    //
    // if failed to load dll's, etc...
    //
    if (!SetupInternalInfo(pArgs, hwndDlg))
    {
        PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL,0);
        return;
    }

    //
    // Set the length limit for the edit controls that exist
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT)) 
    {   
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);

        if (i <= 0)
        {
            i = UNLEN; // username
        }
        
        SendDlgItemMessageU(hwndDlg, IDC_MAIN_USERNAME_EDIT, EM_SETLIMITTEXT, __min(UNLEN, i), 0);
    }
    
    if (GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT)) 
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
    
        if (i <= 0)
        {
            i = PWLEN; // password
        }

        SendDlgItemMessageU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, EM_SETLIMITTEXT, __min(PWLEN, i), 0);
    }

    if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT)) // !pArgs->fHideDomain)
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);
    
        if (i <= 0)
        {
            i = DNLEN; // domain
        }
        
        SendDlgItemMessageU(hwndDlg, IDC_MAIN_DOMAIN_EDIT, EM_SETLIMITTEXT, __min(DNLEN, i), 0);
    }

    //
    // if there's no service msg text, we need to hide and disable the control
    // so that context help doesn't work.
    //
    if (!GetWindowTextLengthU(GetDlgItem(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY)))
    {
        ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY), SW_HIDE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY), FALSE);
    }

    //
    // display the user info
    //
    pArgs->fIgnoreChangeNotification = TRUE;
    SetMainDlgUserInfo(pArgs, hwndDlg);
    pArgs->fIgnoreChangeNotification = fSaveNoNotify;
    

    //
    // init "Remember password"
    //
    if (pArgs->fHideRememberPassword)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        //ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), SW_HIDE);
        //EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);
    }
    else
    {
        CheckDlgButton(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX, 
                            pArgs->fRememberMainPassword);
        
        //
        // Don't care if the pArgs->fRememberMainPassword is set
        // since controls will get disabled later
        // Set the save as option buttons according to what the current
        // deafult is
        //
        SetCredentialUIOptionBasedOnDefaultCreds(pArgs, hwndDlg);
    }

    
    //
    // init "Dial automatically..."
    //
    if (pArgs->fHideDialAutomatically)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        //ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), SW_HIDE);
        //EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
    }
    else
    {
        CheckDlgButton(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX, pArgs->fDialAutomatically);
    }

    //
    // Check the main dlg status and set the default button and focus accordingly
    //
    
    BOOL bReady = CheckConnect(hwndDlg,pArgs,&nCtrlFocus);
    
    MainSetDefaultButton(hwndDlg, nCtrlFocus);   
    SetFocus(GetDlgItem(hwndDlg, nCtrlFocus)); 

    //
    // Check if we want to dial without prompting user
    // if so, send the button click to connect button
    // We also want to dial if the user isn't logged on (ICS case)
    //

    if (bReady) 
    {
        if (pArgs->fDialAutomatically || 
            pArgs->dwFlags & FL_RECONNECT || 
            pArgs->dwFlags & FL_UNATTENDED ||
            ((CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType) && (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseWinLogonCredentials, TRUE))))
        {
            PostMessageU(hwndDlg, WM_COMMAND, IDOK, 0); 
        }   
    }
    else 
    {
        //
        // there are settings missing.
        // silently fail in unattended dial, set exit code
        //

        if (pArgs->dwFlags & FL_UNATTENDED) 
        {
            pArgs->psState = PS_Error;
            pArgs->dwExitCode = ERROR_WRONG_INFO_SPECIFIED;
            PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL,0);
        }
    }

    CM_SET_TIMING_INTERVAL("OnMainLoadStartupInfo - Complete");
}

//+----------------------------------------------------------------------------
//
// Function:  CreateCustomButtonNextToTextBox
//
// Synopsis:  Creates a pushbutton next to the specified text box
//
// Arguments: HWND hwndDlg - Dialog Handle
//            HWND hwndTextBox - TextBox Handle
//            LPTSTR pszTitle - Push Button Title
//            LPTSTR pszToolTip - Push Button Tooltip
//            UINT uButtonID - Control ID of Button to create
//
// Returns:   Nothing
//
// History:   t-adnani    Created Header    6/28/99
//
//+----------------------------------------------------------------------------
void CreateCustomButtonNextToTextBox(
    HWND hwndDlg,               // Dialog Handle
    HWND hwndTextBox,           // TextBox Handle
    LPTSTR pszTitle,            // Caption
    LPTSTR pszToolTip,          // ToolTip Text
    UINT uButtonID                // ButtonID
)
{
    if ((NULL == hwndDlg) || (NULL == hwndTextBox) || (NULL == pszTitle) || (0 == uButtonID))
    {
        CMASSERTMSG(FALSE, TEXT("Invalid parameter passed to CreateCustomButtonNextToTextBox"));
        return;
    }

    RECT    rt;
    POINT   pt1, pt2, ptTextBox1, ptTextBox2;
    HFONT   hfont;
    HWND    hwndButton;

    //
    // Get the rectangle and convert to points before we reduce its size.
    //
    
    GetWindowRect(hwndTextBox, &rt);

    pt1.x = rt.left;
    pt1.y = rt.top;
    pt2.x = rt.right;
    pt2.y = rt.bottom;

    ScreenToClient(hwndDlg, &pt1);
    ScreenToClient(hwndDlg, &pt2);

    //
    // Then calculate the points for reduction
    //
    
    ptTextBox1.x = rt.left;
    ptTextBox1.y = rt.top;
    ptTextBox2.x = rt.right;
    ptTextBox2.y = rt.bottom;

    ScreenToClient(hwndDlg, &ptTextBox1);
    ScreenToClient(hwndDlg, &ptTextBox2);

    //
    // Make the text box smaller
    //

    MoveWindow(hwndTextBox, ptTextBox1.x, ptTextBox1.y, 
               ptTextBox2.x - ptTextBox1.x - CUSTOM_BUTTON_WIDTH - 7,
               ptTextBox2.y - ptTextBox1.y, TRUE);
    
    //
    // Create the button
    //

    hwndButton = CreateWindowExU(0,
                                 TEXT("button"), 
                                 pszTitle, 
                                 BS_PUSHBUTTON|WS_VISIBLE|WS_CHILD|WS_TABSTOP,
                                 pt2.x - CUSTOM_BUTTON_WIDTH, 
                                 ptTextBox1.y, 
                                 CUSTOM_BUTTON_WIDTH, 
                                 ptTextBox2.y-ptTextBox1.y, 
                                 hwndDlg, 
                                 (HMENU)UIntToPtr(uButtonID),
                                 g_hInst, 
                                 NULL);
    if (NULL == hwndButton)
    {
        CMTRACE1(TEXT("CreateCustomButtonNextToTextBox() CreateWindowExU() failed, GLE=%u."),GetLastError());
    }
   
    //
    // Set the font on the button
    //

    hfont = (HFONT)SendMessageU(hwndTextBox, WM_GETFONT, 0, 0);
    
    if (NULL == hfont) 
    {
        CMTRACE1(TEXT("CreateCustomButtonNextToTextBox() WM_GETFONT failed, GLE=%u."),GetLastError());
        return;
    }

    SendMessageU(hwndButton, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE,0));

    //
    // do the tool tip
    //

    if (pszToolTip)
    {
        HWND hwndTT = CreateWindowExU(0, TOOLTIPS_CLASS, TEXT(""), TTS_ALWAYSTIP, 
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
            hwndDlg, (HMENU) NULL, g_hInst, NULL); 

        CMTRACE2(TEXT("CreateCustomButtonNextToTextBox() hwndTT is %u and IsWindow returns %u"),hwndTT, IsWindow(hwndButton));

        if (NULL == hwndTT)
        {
            CMTRACE1(TEXT("CreateCustomButtonNextToTextBox() CreateWindowExU() failed, GLE=%u."),GetLastError());
            MYDBGASSERT(hwndTT);
            return; 
        }

        TOOLINFO ti;    // tool information 

        ti.cbSize = sizeof(TOOLINFO); 
        ti.uFlags = TTF_IDISHWND | TTF_CENTERTIP | TTF_SUBCLASS; 
        ti.hwnd = hwndDlg; 
        ti.hinst = g_hInst; 
        ti.uId = (UINT_PTR) hwndButton; 
        ti.lpszText = pszToolTip; 

        SendMessageU(hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
        CMTRACE2(TEXT("CreateCustomButtonNextToTextBox() hwndTT is %u and IsWindow returns %u"),hwndTT, IsWindow(hwndButton));
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   OnMainInit
// 
//  Synopsis:   Process the WM_INITDIALOG message
//              initialization function for Main dialog box
//
//  Arguments:  hwndDlg         - the main dlg
//              pArgs           - the ArgStruct *
//              
//  Returns:    NONE
//
//  History:    byao        Modified    5/9/97
//                          Added code to handle "Unattended Dial" and "Dial with Connectoid"
//
//----------------------------------------------------------------------------
void OnMainInit(HWND hwndDlg, 
                ArgsStruct *pArgs) 
{
    RECT    rDlg;
    RECT    rWorkArea;
    LPTSTR  pszTitle;

    SetForegroundWindow(hwndDlg);

    //
    // load the icons and bitmaps
    //

    LoadIconsAndBitmaps(pArgs, hwndDlg);

    //
    // Use long sevice name as title text for signin window, 
    //

    pszTitle = CmStrCpyAlloc(pArgs->szServiceName);
    SetWindowTextU(hwndDlg, pszTitle);
    CmFree(pszTitle);

    //
    // Set the msg for the main dlg for profile dialing
    //

    LPTSTR pszMsg = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryServiceMessage);
    SetDlgItemTextU(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY, pszMsg);
    CmFree(pszMsg); 
        
    //
    // Show "remember password" checkbox?
    //

    if (IsLogonAsSystem())
    {
        //
        // If the program is running in the system account, hide the checkbox
        // Bug 196184: big security hole logging onto box with cm
        //

        pArgs->fHideRememberPassword = TRUE;

        //
        //  Another big security hole by launching help files from winlogon.
        //  See NTRAID 429678 for details.
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_HELP_BUTTON), FALSE);

    }
    else
    {        
        pArgs->fHideRememberPassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideRememberPwd);   
    }

    //
    // See if the Internet Password should be hidden, take HideRemember
    // value as the default if no actual value is specified in the .CMS
    // The Internet Password can be saved regardless of the logon context 
    //

    pArgs->fHideRememberInetPassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideRememberInetPwd, pArgs->fHideRememberPassword);

    //
    // show "dial automatically" checkbox?
    //
    // if "hide remember password", then we also want to hide "dial automatically"
    //
    
    pArgs->fHideDialAutomatically = (pArgs->fHideRememberPassword?
                                     TRUE :
                                     pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideDialAuto));

    // Get the dialog rect and the available work area.

    GetWindowRect(hwndDlg,&rDlg);
    
    if (SystemParametersInfoA(SPI_GETWORKAREA,0,&rWorkArea,0))
    {

        MoveWindow(hwndDlg,
                    rWorkArea.left + ((rWorkArea.right-rWorkArea.left)-(rDlg.right-rDlg.left))/2,
                    rWorkArea.top + ((rWorkArea.bottom-rWorkArea.top)-(rDlg.bottom-rDlg.top))/2,
                    rDlg.right-rDlg.left,
                    rDlg.bottom-rDlg.top,
                    FALSE);
    }

    //
    // hide all the hidden controls asap
    //
    if (pArgs->fHideRememberPassword)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), SW_HIDE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);

        //
        // Even though we are hiding the remember password box, 
        // we should not hide these two controls as they might not exist on the
        // dialog. fGlobalCredentialsSupported controls which dialog templates get loaded and
        // if the flag is FALSE then the dialog template doesn't have these controls 
        // thus there is no reason to hide them.
        //
        if (pArgs->fGlobalCredentialsSupported)
        {
            //
            // Also hide the option buttons
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);

            ShowWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
        }
    }
    else
    {
        //
        // Here we don't care if pArgs->fRememberMainPassword is set, because 
        // these controls will get disabled later, but we still need to set 
        // the default option.
        //
        SetCredentialUIOptionBasedOnDefaultCreds(pArgs, hwndDlg );
    }

    if (pArgs->fHideDialAutomatically)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), SW_HIDE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
    }

    //
    // Show the custom button?
    //
    // NT #368810
    // If logged on in the system account, don't do dynamic buttons
    //

    if (!IsLogonAsSystem() && GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT))
    {
        LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryCustomButtonText);
        if (pszTmp && *pszTmp)
        {
            LPTSTR pszToolTip = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryCustomButtonToolTip);
            
            CMTRACE(TEXT("Creating Custom Button"));

            CreateCustomButtonNextToTextBox(hwndDlg, 
                                            GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT), 
                                            pszTmp,
                                            *pszToolTip ? pszToolTip : NULL,
                                            IDC_MAIN_CUSTOM);
            CmFree(pszToolTip);
        }

        CmFree(pszTmp);
    }

    //
    // Show the reset password button?
    //

    if (!IsLogonAsSystem() && GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT))
    {
        LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryResetPassword);
    
        if (pszTmp && *pszTmp)
        {
            DWORD dwTmp;
            DWORD dwLen = (MAX_PATH * 2);

            pArgs->pszResetPasswdExe = (LPTSTR) CmMalloc(sizeof(TCHAR) * dwLen);
        
            if (pArgs->pszResetPasswdExe)
            {
                //
                // Expand any environment strings that may exist
                //

                CMTRACE1(TEXT("Expanding ResetPassword environment string as %s"), pszTmp);

                dwTmp = ExpandEnvironmentStringsU(pszTmp, pArgs->pszResetPasswdExe, dwLen);   
        
                MYDBGASSERT(dwTmp <= dwLen);

                //
                // As long as expansion succeeded, pass along the result
                //

                if (dwTmp <= dwLen)
                {
                    pszTitle = CmLoadString(g_hInst, IDS_RESETPASSWORD);
                    
                    CMTRACE((TEXT("Showing ResetPassword button for %s"), pArgs->pszResetPasswdExe));
                    
                    CreateCustomButtonNextToTextBox(hwndDlg, 
                                                    GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT), 
                                                    pszTitle,
                                                    (LPTSTR)MAKEINTRESOURCE(IDS_NEW_PASSWORD_TOOLTIP),
                                                    IDC_MAIN_RESET_PASSWORD);
                    CmFree(pszTitle);
                }
            }
        }

        CmFree(pszTmp);
    }

    //
    // Notify user that we are intializing
    //
    
    AppendStatusPane(hwndDlg,IDMSG_INITIALIZING);

    //
    // Initialize system menu
    //
    HMENU hMenu = GetSystemMenu(hwndDlg, FALSE);
    MYDBGASSERT(hMenu);

    // Delete size and maximize menuitems. These are
    // not appropriate for a dialog with a no-resize frame.
    
    DeleteMenu(hMenu, SC_SIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);

    EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | MF_GRAYED);

    //
    // See if we are hiding any InetLogon controls
    //

    if (IsTunnelEnabled(pArgs) && !pArgs->fUseSameUserName)
    {
        pArgs->fHideInetUsername = pArgs->piniService->GPPB(c_pszCmSection, 
                                                            c_pszCmEntryHideInetUserName);
        
        pArgs->fHideInetPassword = pArgs->piniService->GPPB(c_pszCmSection, 
                                                            c_pszCmEntryHideInetPassword);
    }

    //
    // set timer
    //
    pArgs->nTimerId = SetTimer(hwndDlg,1,TIMER_RATE,NULL);
}

//
// map state to frame: splash????
//

VOID MapStateToFrame(ArgsStruct * pArgs)
{
    static ProgState psOldFrame = PS_Interactive;

    ProgState psNewFrame = pArgs->psState;

    if (psNewFrame == PS_Dialing || psNewFrame == PS_TunnelDialing)
    {
        //
        // If we are dialing anything other than the primary number
    // switch the state to RedialFrame
    // RedialFrame is a misnomer - this is the frame that is displayed
    // when dialing backup number. It is not used when Redialing the 
        // primary number again
        //

        if (pArgs->nDialIdx > 0)
        {
            psNewFrame = PS_RedialFrame;
        }
    }

    if (pArgs->pCtr && psNewFrame != psOldFrame)
    {
        psOldFrame = psNewFrame;

        //
        // don't check for failure here - nothing we can do.
        //

        pArgs->pCtr->MapStateToFrame(psOldFrame);
    }
}

//
// SetInteractive: enable most of the windows and buttons so user can interact with 
//                 connection manager again 
// 

void SetInteractive(HWND hwndDlg, 
                    ArgsStruct *pArgs) 
{

    if (pArgs->dwFlags & FL_UNATTENDED)
    {
        //
        //  When we are unattended mode we don't want to put the UI into
        //  interactive mode and wait for user input.  Since the unattended
        //  UI is now hidden, this would put up the UI waiting for user
        //  interaction even though the UI was invisible.  Instead we
        //  will set the state to Interactive and post a message to cancel
        //  the dialer.  
        //
        CMTRACE(TEXT("SetInteractive called while in unattended mode, posting a message to cancel"));
        pArgs->psState = PS_Interactive;
        PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL, ERROR_CANCELLED);
    }
    else
    {

        pArgs->psState = PS_Interactive;
        
        MapStateToFrame(pArgs);

        pArgs->dwStateStartTime = GetTickCount();
        EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
        EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PROPERTIES_BUTTON),TRUE);
        
        //
        // Enable edit controls as necessary
        //
        if (GetDlgItem(hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO)) 
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_STATIC),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_COMBO),TRUE);
        }

        if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT)) 
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_EDIT),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_STATIC),TRUE);
        }

        if (GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT)) 
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_EDIT),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_STATIC),TRUE);
        }

        if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT)) // !pArgs->fHideDomain)
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_EDIT),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_STATIC),TRUE);
        }

        if (pArgs->hwndResetPasswdButton)
        {
            EnableWindow(pArgs->hwndResetPasswdButton, TRUE);
        }

        if (!pArgs->fHideRememberPassword)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), TRUE);
            if (pArgs->fGlobalCredentialsSupported && pArgs->fRememberMainPassword)
            {
                //
                // Also enable the option buttons
                //
                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), TRUE);
            }
        }

        if ((!pArgs->fHideDialAutomatically) && 
            (pArgs->fRememberMainPassword ||
             pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional)))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), TRUE);
        }

        //
        //  Set the default button
        //
        SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)IDOK, 0);
        SetFocus(GetDlgItem(hwndDlg,IDOK));
    }

    DeObfuscatePasswordEdit(pArgs);
}  

//+----------------------------------------------------------------------------
//
// Function:  SetWatchHandles
//
// Synopsis:  Handles the messy details of Duplicating each of the Watch 
//            handles so that they can be accessed by the CMMON process.
//            The list of handles is assumed to be NULL terminated.
//
// Arguments: HANDLE *phOldHandles - Ptr to the current handle list.
//            HANDLE *phNewHandles - Ptr to storage for duplicted handles.
//            HWND hwndMon - HWND in the target process.
//
// Returns:   BOOL - TRUE on success
//
// History:   nickball    Created    2/11/98
//
//+----------------------------------------------------------------------------
BOOL
SetWatchHandles(
    IN  HANDLE *phOldHandles,
    OUT HANDLE *phNewHandles,
    IN  HWND hwndMon)
{
    MYDBGASSERT(phOldHandles);
    MYDBGASSERT(phNewHandles);
    MYDBGASSERT(hwndMon);

    BOOL bReturn = TRUE;
    
    if (NULL == phOldHandles || NULL == phNewHandles || NULL == hwndMon)
    {
        return FALSE;
    }
    
    //
    // First we need to get the Handle of our current process
    //
    DWORD dwProcessId = GetCurrentProcessId();
    
    HANDLE hSourceProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);

    //
    // Now the handle of the target process
    //
    GetWindowThreadProcessId(hwndMon, &dwProcessId);

    HANDLE hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
  
    //
    // Loop through our handles list and duplicate
    //

    DWORD dwIdx = 0;

    if (hTargetProcess && hSourceProcess)
    {
        for (dwIdx = 0; phOldHandles[dwIdx]; dwIdx++)
        {
            if (FALSE == DuplicateHandle(hSourceProcess, phOldHandles[dwIdx],  // Val
                                         hTargetProcess, &phNewHandles[dwIdx], // Ptr
                                         NULL, FALSE, DUPLICATE_SAME_ACCESS))
            {
                CMTRACE1(TEXT("SetWatchHandles() - DuplicateHandles failed on item %u"), dwIdx);
                MYDBGASSERT(FALSE);
                bReturn = FALSE;
                break;
            }
        }
    }

    MYDBGASSERT(dwIdx); // Don't call if you don't have handles to duplicate

    //
    //  Cleanup
    //
    if (!bReturn)
    {
        // we failed during Handle Duplication... must clean up
        while (dwIdx > 0)
        {
            CloseHandle(phNewHandles[--dwIdx]);
        }
    }
    CloseHandle(hTargetProcess);
    CloseHandle(hSourceProcess);
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ConnectMonitor
//
// Synopsis:  Encapsulates the details of launching CMMON, waiting for load
//            verification, and providing it with connect data.
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   HRESULT - Failure code
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT ConnectMonitor(ArgsStruct *pArgs)
{
    LRESULT lRes = ERROR_SUCCESS;
    BOOL fMonReady = FALSE;
    HWND hwndMon = NULL;
    TCHAR szDesktopName[MAX_PATH];
    TCHAR szWinDesktop[MAX_PATH];

    //
    // Determine if CMMON is running
    //
       
    if (SUCCEEDED(pArgs->pConnTable->GetMonitorWnd(&hwndMon)))
    {
        fMonReady = IsWindow(hwndMon);
    }

    //
    // If not, launch it
    //
    
    if (FALSE == fMonReady)       
    {
        //
        // Create launch event 
        //
        
        HANDLE hEvent = CreateEventU(NULL, TRUE, FALSE, c_pszCmMonReadyEvent);

        if (NULL == hEvent)
        {
            MYDBGASSERT(FALSE);
            lRes = GetLastError();    
        }
        else
        {
            STARTUPINFO         StartupInfo;
            PROCESS_INFORMATION ProcessInfo;
            TCHAR szCommandLine[2 * MAX_PATH + 3];
            TCHAR szCmmon32Path[MAX_PATH + 1 + 11 + 1]; // 11 == lstrlenU(c_pszCmMonExeName)

            //
            // Launch c_pszCmMonExeName 
            //

            ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
            ZeroMemory(&StartupInfo, sizeof(StartupInfo));
            StartupInfo.cb = sizeof(StartupInfo);

            //
            //  If this is win2k or whistler, then we don't want to launch cmmon32.exe onto the users
            //  desktop since it is a security hole to have a system process with a window on the users
            //  desktop.  This window could be attacked by WM_TIMER and other messages ...
            //  But in case of ICS (no user is logged on), just launch CMMON in normally by leaving 
            //  StartupInfo.lpDesktop = NULL. By leaving this NULL the new process inherits 
            //  the desktop and window station of its parent process.This makes it work with 
            //  ICS when no user is logged-on. Otherwise CM never gets the event back from 
            //  CMMON because it's on a different desktop.
            //
            if (OS_NT5 && IsLogonAsSystem() && (CM_LOGON_TYPE_ICS != pArgs->dwWinLogonType))
            {
                DWORD   cb;
                HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());

                //
                // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
                //  
                szDesktopName[0] = 0;
            
                if (hDesk && GetUserObjectInformation(hDesk, UOI_NAME, szDesktopName, sizeof(szDesktopName), &cb))
                {
                    lstrcpyU(szWinDesktop, TEXT("Winsta0\\"));
                    lstrcatU(szWinDesktop, szDesktopName);
                    
                    StartupInfo.lpDesktop = szWinDesktop;
                    StartupInfo.wShowWindow = SW_SHOW;
                    
                    CMTRACE1(TEXT("ConnectMonitor - running under system account, so launching cmmon32.exe onto Desktop = %s"), MYDBGSTR(StartupInfo.lpDesktop));            
                }
                else
                {
                    //
                    //  If we are here, cmmon32.exe probably isn't going to be able to communicate with
                    //  cmdial32.dll which means the handoff between the two will fail and the call will be
                    //  aborted.
                    //
                    CMASSERTMSG(FALSE, TEXT("ConnectMonitor -- GetUserObjectInformation failed."));
                }
            }
            else if (OS_NT4 && IsLogonAsSystem())
            {
                //
                //  We are less concerned about the security risk on NT4 and more concerned with the loss
                //  of the functionality that cmmon32.exe provides to the user.  Thus we will push the
                //  cmmon32.exe window onto the user's desktop.
                //
                StartupInfo.lpDesktop = TEXT("Winsta0\\Default");
                StartupInfo.wShowWindow = SW_SHOW;
                
                CMTRACE1(TEXT("ConnectMonitor - running on system account on NT4, so launching cmmon32.exe onto Desktop = %s"), MYDBGSTR(StartupInfo.lpDesktop ));
            }
            
            ZeroMemory(&szCmmon32Path[0], sizeof(szCmmon32Path));
            ZeroMemory(&szCommandLine[0], sizeof(szCommandLine));

            if (0 == GetSystemDirectoryU(szCmmon32Path, MAX_PATH))
            {
                lRes = GetLastError();
                CMTRACE1(TEXT("ConnectMonitor() GetSystemDirectoryU(), GLE=%u."), lRes);
                return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            }

            //
            // Since there are no params, Application name is the same as the command line
            //
            szCommandLine[0] = TEXT('"');
            lstrcatU(szCommandLine + 1, szCmmon32Path);
            lstrcatU(szCommandLine, TEXT("\\"));
            lstrcatU(szCommandLine, c_pszCmMonExeName);
            lstrcatU(szCommandLine, TEXT("\""));
            CMTRACE1(TEXT("ConnectMonitor() - Launching %s"), szCommandLine);

            lstrcatU(szCmmon32Path, TEXT("\\"));
            lstrcatU(szCmmon32Path, c_pszCmMonExeName);

            if (NULL == CreateProcessU(szCmmon32Path, szCommandLine, 
                                       NULL, NULL, FALSE, 0, 
                                       NULL, NULL,
                                       &StartupInfo, &ProcessInfo))
            {
                lRes = GetLastError();
                CMTRACE2(TEXT("ConnectMonitor() CreateProcess() of %s failed, GLE=%u."), 
                    c_pszCmMonExeName, lRes);
            }
            else
            {
                //
                // Wait for event to be signaled, that CMMON is up
                //

                DWORD dwWait = WaitForSingleObject(hEvent, MAX_OBJECT_WAIT);

                if (WAIT_OBJECT_0 != dwWait)
                {       
                    if (WAIT_TIMEOUT == dwWait)
                    {
                        lRes = ERROR_TIMEOUT;
                    }
                    else
                    {
                        lRes = GetLastError();
                    }
                }
                else
                {
                    fMonReady = TRUE;
                }

                //
                // Close Process handles. Note, we don't use these handles for 
                // duplicating handles in order to maintain a common code path
                // regardless of whether CMMON was up already.
                //

                CloseHandle(ProcessInfo.hProcess);
                CloseHandle(ProcessInfo.hThread);
            }

            CloseHandle(hEvent);
        }
    }
    
    
    if (fMonReady)
    {
        //
        // Get the hwnd for CMMON. Note: CMMON is expected to set  
        // the hwnd in the table before it signals the ready event.
        //
                
        if (FAILED(pArgs->pConnTable->GetMonitorWnd(&hwndMon)))
        {
            CMTRACE(TEXT("ConnectMonitor() - No Monitor HWND in table"));
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }

        //
        // Make sure the HWND for CMMON is valid before trying to send data.
        //

        if (!IsWindow(hwndMon))
        {                        
            MSG msg;
            HANDLE hHandle = GetCurrentProcess();

            //
            // Sometimes it takes a few ticks for us to get a positive response 
            // from IsWindow, so loop and pump messages while we are waiting.
            //
            while (hHandle && (MsgWaitForMultipleObjects(1, &hHandle, FALSE, 
                                                         MAX_OBJECT_WAIT, 
                                                         QS_ALLINPUT) == (WAIT_OBJECT_0 + 1)))
            {               
                while (PeekMessageU(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    CMTRACE(TEXT("ConnectMonitor() - Waiting for IsWindow(hwndMon) - got Message"));
                    
                    TranslateMessage(&msg);
                    DispatchMessageU(&msg);
                }

                //
                // If the window is valid, we can go. Otherwise, keep pumping.
                //

                if (IsWindow(hwndMon))
                {
                    break;
                }
            }
            
            if (FALSE == IsWindow(hwndMon))
            {
                CMTRACE(TEXT("ConnectMonitor() - Monitor HWND in table is not valid"));
                return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            }
        }

        //
        // Allocate buffer for CONNECTED_INFO, including extension for Watch Process list
        //

        DWORD dwWatchCount = GetWatchCount(pArgs);
        DWORD dwDataSize = sizeof(CM_CONNECTED_INFO) + (dwWatchCount * sizeof(HANDLE));

        LPCM_CONNECTED_INFO pInfo = (LPCM_CONNECTED_INFO) CmMalloc(dwDataSize);

        // 
        // Allocate the COPYDATASTRUCT
        // 

        COPYDATASTRUCT *pCopyData = (COPYDATASTRUCT*) CmMalloc(sizeof(COPYDATASTRUCT));

        if (NULL == pInfo || NULL == pCopyData)
        {
            lRes = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {               
            //
            // Fill in the CONNECTED_INFO
            //

            lstrcpyU(pInfo->szEntryName, pArgs->szServiceName);                                  
            lstrcpyU(pInfo->szProfilePath, pArgs->piniProfile->GetFile());
            
            //
            // Provide any password data that we have
            //
            // Due to security issues we are no longer allowed to keep password in memory.
            //
            
            //
            // And the RAS phonebook
            //

            if (pArgs->pszRasPbk)
            {
                lstrcpynU(pInfo->szRasPhoneBook, pArgs->pszRasPbk,
                    sizeof(pInfo->szRasPhoneBook)/sizeof(pInfo->szRasPhoneBook[0]));            
            }
            else
            {
                pInfo->szRasPhoneBook[0] = L'\0';
            }

            
            pInfo->dwCmFlags = pArgs->dwFlags;                               

            //
            //  Need to know about global creds for Fast User Switching
            //
            if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
            {
                pInfo->dwCmFlags |= FL_GLOBALCREDS;
                CMTRACE(TEXT("ConnectMonitor - we have globalcreds!!"));
            }
            
            //
            // For W95, we must pass initial statistics data to CMMON
            //

            pInfo->dwInitBytesRecv = -1; // default to no stats
            pInfo->dwInitBytesSend = -1; // default to no stats               
            
            if (pArgs->pConnStatistics)
            {
                //
                // Get reg based stat data if available
                //

                if (pArgs->pConnStatistics->IsAvailable())
                {
                    pInfo->dwInitBytesRecv = pArgs->pConnStatistics->GetInitBytesRead(); 
                    pInfo->dwInitBytesSend = pArgs->pConnStatistics->GetInitBytesWrite();
                }

                //
                // Note: Adapter info is good, even if stats aren't available
                //

                pInfo->fDialup2 = pArgs->pConnStatistics->IsDialupTwo();                         
            }

            //
            // Update the watch process list at the end of the CONNECTED_INFO struct
            //

            if (dwWatchCount)
            {               
                if (FALSE == SetWatchHandles(pArgs->phWatchProcesses, &pInfo->ahWatchHandles[0], hwndMon))
                {
                    pInfo->ahWatchHandles[0] = NULL;
                }
            }
            
            //
            // Send CONNECTED_INFO to CMMON
            //
          
            pCopyData->dwData = CMMON_CONNECTED_INFO;
            pCopyData->cbData = dwDataSize;                
            pCopyData->lpData = (PVOID) pInfo;

            SendMessageU(hwndMon, WM_COPYDATA, NULL, (LPARAM) pCopyData);               
        }

        //
        // Release allocations
        //

        if (pInfo)
        {
            CmFree(pInfo);
        }
        
        if (pCopyData)
        {
            CmFree(pCopyData);
        }
    }               
            
    return HRESULT_FROM_WIN32(lRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CreateConnTable
//
// Synopsis:  Initializes our CConnectionTable ptr and creates a new ConnTable
//            or opens an existing one as needed
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct containing.
//
// Returns:   HRESULT - Failure code
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT CreateConnTable(ArgsStruct *pArgs)
{   
    HRESULT hrRet = E_FAIL;
    
    pArgs->pConnTable = new CConnectionTable();

    if (pArgs->pConnTable)
    {
        //
        // We have our class, now create/open the connection table.
        //

        hrRet = pArgs->pConnTable->Open();

        if (FAILED(hrRet))
        {
            hrRet = pArgs->pConnTable->Create();
            
            if (HRESULT_CODE(hrRet) == ERROR_ALREADY_EXISTS)
            {
                CMTRACE1(TEXT("CreateConnTable -- ConnTable creation failed with error 0x%x.  Strange since the Open failed too..."), hrRet);
            }
            else
            {
                CMTRACE1(TEXT("CreateConnTable -- ConnTable creation failed with error 0x%x"), hrRet);
            }
        }  
    }
    else
    {
        hrRet = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
       
    MYDBGASSERT(SUCCEEDED(hrRet));

    return hrRet;
}

#if 0 // NT 301988
/*
//+----------------------------------------------------------------------------
//
// Function:  HandleMainConnectRequest
//
// Synopsis:  Helper routine to handle the possibility that there may be a 
//            connect in progress on this service.
//
// Arguments: HWND hwndDlg - HWND of main dialog
//            ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   BOOL - TRUE if we have fully handled the request 
//                   and it is ok to terminate this instance.
//
// History:   nickball    Created    2/23/98
//
//+----------------------------------------------------------------------------
BOOL HandleMainConnectRequest(HWND hwndDlg, ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    BOOL fResolved = FALSE;

    LPCM_CONNECTION pConnection = GetConnection(pArgs);
        
    //
    // If no conection found, then there is no work to be done here, continue.
    //

    if (pConnection)
    {
        //
        // If we are in any state besides RECONNECT, we can handle it here
        //
        
        if (CM_RECONNECTPROMPT != pConnection->CmState)
        {
            fResolved = TRUE;

            if (pArgs->dwFlags & FL_DESKTOP)
            {
                //
                // Caller is from the desktop, notify the user and we're done
                //

                NotifyUserOfExistingConnection(hwndDlg, pConnection, TRUE);        
            }
            else
            {
                BOOL fSuccess = TRUE;
 
                //
                // We have a programmatic caller, if connected just bump the ref count
                // and return successfully. Otherwise we return failure so that the
                // caller doesn't erroneously believe that there is a connection.
                //
            
                if (CM_CONNECTED != pConnection->CmState)
                {
                    fSuccess = FALSE;
                }
                else
                {                
                    UpdateTable(pArgs, CM_CONNECTING);
                }                                 

                //
                // Terminate this connect instance. 
                //

                EndMainDialog(hwndDlg, pArgs, 0); // fSuccess);
            }
        }
        else
        {
            //
            // We're in reconnect mode and going to connect. 
            //

            if (!(pArgs->dwFlags & FL_RECONNECT))
            {                
                // 
                // This request is not a reconnect request from CMMON, 
                // make that sure the dialog is no longer displayed. 
                //
            
                HangupNotifyCmMon(pArgs->pConnTable, pConnection->szEntry);
            }
            else
            {
                //
                // We are handling a reconnect for CMMON, reduce the usage
                // count so it is in sync when we begin connecting.
                //

                pArgs->pConnTable->RemoveEntry(pConnection->szEntry);
            }
        }
        
        CmFree(pConnection);
    }

    return fResolved;
}
*/
#endif

//
// OnMainConnect: Command Handler when user clicked on 'Connect' Button in 
//                Main Dialog Box
//

void OnMainConnect(HWND hwndDlg, 
                   ArgsStruct *pArgs) 
{
    CM_SET_TIMING_INTERVAL("OnMainConnect - Begin");

    //
    // If we aren't ready to dial, set focus appropriately and bail
    //

    UINT nCtrlFocus;

    if (FALSE == CheckConnect(hwndDlg, pArgs, &nCtrlFocus, !(pArgs->dwFlags & FL_UNATTENDED)))
    {
        MainSetDefaultButton(hwndDlg, nCtrlFocus);   
        SetFocus(GetDlgItem(hwndDlg, nCtrlFocus)); 
        return;
    }

    (void) InterlockedExchange(&(pArgs->lInConnectOrCancel), NOT_IN_CONNECT_OR_CANCEL);

    //
    // Access Points - Disable AP combo box before connecting
    //
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_STATIC),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_COMBO),FALSE);

    //
    // Store the current access point to reg.
    //
    if (pArgs->fAccessPointsEnabled)
    {
        WriteUserInfoToReg(pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID)(pArgs->pszCurrentAccessPoint));
    }
    
    //
    // Assume success unless something contradictory happens
    //

    pArgs->dwExitCode = ERROR_SUCCESS;

    HCURSOR hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));

    LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_WORKING);

    if (pszMsg) 
    {
        SetDlgItemTextA(hwndDlg, IDC_MAIN_STATUS_DISPLAY, ""); 

        AppendStatusPane(hwndDlg,pszMsg);
        CmFree(pszMsg);
    }

    //
    // We're connecting, update the table. 
    //

    UpdateTable(pArgs, CM_CONNECTING);            
   
    //
    // Clear out everything on the status panel
    //

    SetDlgItemTextA(hwndDlg, IDC_MAIN_STATUS_DISPLAY, ""); 

    //
    //  Set the default button to Cancel
    //
    SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
    SetFocus(GetDlgItem(hwndDlg,IDCANCEL));
 
    BOOL fSaveUPD = TRUE;
    BOOL fSaveOtherUserInfo = TRUE;
    
    //
    // We want to save and/or delete credentials only when the user is logged on.
    // This is taken care of by the functions that get called here. As long as 
    // the user is logged on, we try to mark, delete credentials and
    // potentially resave credential info. From this level we shouldn't 
    // worry if we have the ras cred store or how the creds are really stored.
    // 
    if (CM_LOGON_TYPE_USER == pArgs->dwWinLogonType)
    {
        //
        // If this is NT4 or Win9X the GetAndStoreUserInfo takes care of storing
        // the user info w/o the credential store. 
        //
        if (OS_NT5)
        {
            //
            // For Win2K+ we use the RAS API to save the credentials. The call saves 
            // and deletes user and global creds based on the current state and the 
            // user's choices (whether to save a password, etc.)
            //
            TryToDeleteAndSaveCredentials(pArgs, hwndDlg);
            
            //
            // Parameter to GetAndStoreUserInfo() - doesn't save Username, Password, Domain
            //
            fSaveUPD = FALSE; 
        }
    }
    else
    {
        //
        // User isn't logged on, thus we don't want to save anything
        //
        fSaveUPD = FALSE;
        fSaveOtherUserInfo = FALSE;
    }

    //
    // Gets the userinfo from the edit boxes into the pArgs structure ans saves the other 
    // user flags. This is also saves the credentials on NT4 & Win 9x if the 3rd parameter is true
    //
    // 3rd parameter (fSaveUPD) - used to save Username, Domain, Password.
    // 4th param (fSaveOtherUserInfo) - used to save user info flags. (remember password, 
    //                                  dial automatically, etc.)
    //
    GetAndStoreUserInfo(pArgs, hwndDlg, fSaveUPD, fSaveOtherUserInfo);

    //
    // Vars for RAS 
    //

    pArgs->nDialIdx = 0;

    // 
    // Set our redial counter with the maximum. The max value is read 
    // in when we initialize the dialog. It is just a place holder
    // nRedialCnt is the var used/modified to regulate the re-dial process.
    //

    pArgs->nRedialCnt = pArgs->nMaxRedials;

    //
    // Disable username controls before dialing
    //

    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_EDIT),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_STATIC),FALSE);

    
    //
    // Disable password controls before dialing
    //      

    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_EDIT),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_STATIC),FALSE);


    //
    // Disable domain controls before dialing
    //

    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_EDIT),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_STATIC),FALSE);


    //
    // disable all other buttons
    //

    EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PROPERTIES_BUTTON),FALSE);

    if (pArgs->hwndResetPasswdButton)
    {
        EnableWindow(pArgs->hwndResetPasswdButton, FALSE);
    }

    if (!pArgs->fHideRememberPassword)
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);
        
        if (pArgs->fGlobalCredentialsSupported)
        {
            //
            // Also disable the option buttons
            //
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
        }
    }

    if (!pArgs->fHideDialAutomatically)
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
    }

    //
    // Try to check the Advanced Tab settings (ICF/ICS) and see if we need to enable or disable
    // them based on what's configured in the .cms file. This is only on WinXP+ & if the user is logged in
    //
    VerifyAdvancedTabSettings(pArgs);

    //
    // Dial the number
    //

    DWORD dwResult = ERROR_SUCCESS;

    pArgs->Log.Log(PRECONNECT_EVENT, pArgs->GetTypeOfConnection());
    //
    // Run the Pre-Connect actions
    //
    CActionList PreConnActList;
    PreConnActList.Append(pArgs->piniService, c_pszCmSectionPreConnect);

    if (!PreConnActList.RunAccordType(hwndDlg, pArgs))
    {
        //
        // Connect action failed
        //

        UpdateTable(pArgs, CM_DISCONNECTED);
    }
    else
    {
        if (pArgs->IsDirectConnect())
        {
            MYDBGASSERT(pArgs->hrcRasConn == NULL);

            pArgs->fUseTunneling = TRUE;

            pArgs->psState = PS_TunnelDialing;
            pArgs->dwStateStartTime = GetTickCount();
            pArgs->nLastSecondsDisplay = (UINT) -1;

            dwResult = DoTunnelDial(hwndDlg,pArgs);
        }
        else
        {
            //
            // If the DynamicPhoneNumber flag is set, then we need to re-read
            // the phoneinfo from the profile and make sure it re-munged. 
            //
            
            BOOL bDynamicNum = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmDynamicPhoneNumber);

            if (bDynamicNum)
            {
                LoadPhoneInfoFromProfile(pArgs);
            }

            //
            // Load dial info(phone #'s, etc)
            // In the auto-dial case we pass FALSE for fInstallModem so that
            // LoadDialInfo does not try to install a modem because it would
            // require user intervention
            //

            dwResult = LoadDialInfo(pArgs, hwndDlg, !(pArgs->dwFlags & FL_UNATTENDED), bDynamicNum);
            
            if (dwResult == ERROR_SUCCESS)
            {
                dwResult = DoRasDial(hwndDlg,pArgs,pArgs->nDialIdx);
            }

            //
            // If modem is not installed and LoadDialInfo failed to install modem, dwResult will be
            // ERROR_PORT_NOT_AVAILABLE.  Ideally, we should disable the connect button and display
            // a different error message.  
            //                
        }

        if (ERROR_SUCCESS != dwResult) 
        {
            pArgs->dwExitCode = dwResult;
            UpdateError(pArgs, dwResult);
        }
    }

    if (ERROR_SUCCESS != dwResult) 
    { 
        HangupCM(pArgs, hwndDlg);

        if (IsLogonAsSystem() && BAD_SCARD_PIN(dwResult))
        {
            //
            //  Disable the Connect button to avoid smartcard lockout.  Also propagate
            //  the error back to our caller (RAS) so that they can End the 'choose
            //  connectoid' dialog and return to winlogon, where the user can enter
            //  the correct PIN.
            //
            pArgs->dwSCardErr = dwResult;
            EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
            SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
            SetFocus(GetDlgItem(hwndDlg, IDCANCEL));
        }
    
        SetLastError(dwResult);
    }

    SetCursor(hPrev);

    CM_SET_TIMING_INTERVAL("OnMainConnect - End");
}

//+---------------------------------------------------------------------------
//
//  Function:   UseTunneling
//
//  Synopsis:   Check to see if we should do tunneling based on fTunnelPrimary
//              and fTunnelReferences.
//
//  Arguments:  pArgs [the ArgStruct ptr]
//              dwEntry [the phone index]
//
//  Returns:    TRUE if we tunnel, FALSE otherwise.
//
//  History:    henryt  Created     3/5/97
//
//----------------------------------------------------------------------------
BOOL UseTunneling(
    ArgsStruct  *pArgs, 
    DWORD       dwEntry
)
{
    LPTSTR  pszRefPhoneSource = NULL;
    BOOL    fPhoneNumIsFromPrimaryPBK;

    LPTSTR  pszTmp;

    CIni    iniTmp(pArgs->piniProfile->GetHInst(),pArgs->piniProfile->GetFile(), pArgs->piniProfile->GetRegPath());
    BOOL    fUseTunneling = FALSE;

    //
    // Set the read flags
    //
    if (pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_READ_ICS_DATA)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);

        if (pszICSDataReg)
        {
            iniTmp.SetReadICSData(TRUE);
            iniTmp.SetICSDataPath(pszICSDataReg);
        }

        CmFree(pszICSDataReg);
    }

    iniTmp.SetEntryFromIdx(dwEntry);
    pszRefPhoneSource = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryPhoneSourcePrefix);

    //
    // If PhoneSource[0|1] is not empty, verify its existence
    //

    if (*pszRefPhoneSource) 
    {        
        //
        // pszRefPhoneSource is either a relative or full path.
        // CmConvertRelativePath() will do the conversion to a full path properly
        //
        pszTmp = CmConvertRelativePath(pArgs->piniService->GetFile(), pszRefPhoneSource);
        
        if (!pszTmp || FALSE == FileExists(pszTmp))
        {
            
            CmFree(pszRefPhoneSource); 
            CmFree(pszTmp);
            return fUseTunneling;
        }

        //
        // Is the phone # from the primary(top level) phone book?
        //
        
        fPhoneNumIsFromPrimaryPBK = (lstrcmpiU(pszTmp, pArgs->piniService->GetFile()) == 0);
        CmFree(pszTmp);

        fUseTunneling = 
            ((fPhoneNumIsFromPrimaryPBK && pArgs->fTunnelPrimary) ||
             (!fPhoneNumIsFromPrimaryPBK && pArgs->fTunnelReferences));
    }
    else 
    {
        // the phone # is not from a phone book.  the user probably typed it in
        // him/herself.
        fUseTunneling = pArgs->fTunnelPrimary;
    }
    
    CmFree(pszRefPhoneSource);

    return fUseTunneling;
}

//
// OnMainProperties: command handler for 'Properties' button in the main dialog box
//

int OnMainProperties(HWND hwndDlg, 
                     ArgsStruct *pArgs) 
{
    CMTRACE(TEXT("Begin OnMainProperties()"));

    //
    // do the settings dlg.
    //

    BOOL bCachedAccessPointsEnabled = pArgs->fAccessPointsEnabled;

    int iRet = DoPropertiesPropSheets(hwndDlg, pArgs);

    //
    // We need to re-enumerate the access points and re-check connecting because
    // the user may have added or deleted an access point and then hit cancel.
    //

    if (pArgs->hwndMainDlg) 
    {
        if (bCachedAccessPointsEnabled != pArgs->fAccessPointsEnabled)
        {
            CMTRACE(TEXT("Access points state changed, returning to the main dialog which needs to relaunch itself with the proper template."));
            iRet = ID_OK_RELAUNCH_MAIN_DLG;
        }
        else
        {
            //
            //  If the user canceled, then we want to set the accesspoint back to what it was on the main dialog
            //  since the user may have changed it on the properties dialog but then canceled.
            //
            if (pArgs->fAccessPointsEnabled)
            {
                if (0 == iRet) // user hit cancel
                {
                    ChangedAccessPoint(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO);                
                }

                ShowAccessPointInfoFromReg(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO);
            }

            UINT nCtrlFocus;

            CheckConnect(hwndDlg,pArgs,&nCtrlFocus);
            MainSetDefaultButton(hwndDlg,nCtrlFocus);
            SetFocus(GetDlgItem(hwndDlg,nCtrlFocus));
        }
    }

    CMTRACE(TEXT("End OnMainProperties()"));

    return iRet;
}

//
// user pressed the cancel button!!!!!
//
void OnMainCancel(HWND hwndDlg, 
                  ArgsStruct *pArgs) 
{   
    CMTRACE1(TEXT("OnMainCancel(), state is %d"), pArgs->psState);

    //
    //  Re-entrancy protection.  If we're in the middle of a RasDial, wait 2 seconds.
    //  If the "semaphore" is still held, exit.  (This is only likely to happen during
    //  a stress situation, so failing the cancel is acceptable.)
    //
    LONG lInConnectOrCancel;
    int SleepTimeInMilliseconds = 0;
    do
    {
        lInConnectOrCancel = InterlockedExchange(&(pArgs->lInConnectOrCancel), IN_CONNECT_OR_CANCEL);
        CMASSERTMSG(((NOT_IN_CONNECT_OR_CANCEL == lInConnectOrCancel) || (IN_CONNECT_OR_CANCEL == lInConnectOrCancel)),
                    TEXT("OnMainCancel - synch variable has unexpected value!"));

        Sleep(50);
        SleepTimeInMilliseconds += 50;
    }
    while ((IN_CONNECT_OR_CANCEL == lInConnectOrCancel) && (SleepTimeInMilliseconds < 2000));

    if (IN_CONNECT_OR_CANCEL == lInConnectOrCancel)
    {
        CMTRACE(TEXT("OnMainCancel - waited 2 seconds for system for InRasDial mutex to be freed, leaving Cancel"));
        return;
    }

    //
    // Terminate Lana
    //

    if (PS_TunnelDialing == pArgs->psState && pArgs->uLanaMsgId)
    {
        MYDBGASSERT(OS_W9X);
        PostMessageU(hwndDlg, pArgs->uLanaMsgId, 0, 0);
    }

    if (pArgs->psState != PS_Interactive && pArgs->psState != PS_Error)
    {
        pArgs->Log.Log(ONCANCEL_EVENT);

        //
        // Run OnCancel connect actions. If we are dialing, this is a cancel 
        // dialing event. Note: The assumption here is CM never post itself 
        // an IDCANCEL message when dialing
        //

        CActionList OnCancelActList;
        OnCancelActList.Append(pArgs->piniService, c_pszCmSectionOnCancel);

        //
        // fStatusMsgOnFailure = FALSE
        //
        OnCancelActList.RunAccordType(hwndDlg, pArgs, FALSE); 
    }

    switch (pArgs->psState) 
    {
        case PS_Dialing:
        case PS_TunnelDialing:
        case PS_Authenticating:
        case PS_TunnelAuthenticating:
        
            // fall through

        case PS_Pausing:

            //
            // we should also try to hangup for ps_pausing since cm could be
            // in the middle or redialing the tunnel server.  we need to
            // hangup the first ppp connection.
            //

            //
            // Set fWaitForComplete to TRUE.
            // This will cause HangupCM to block until the ras handle is invalid.
            // Otherwise, HangupCM will return while the device is in use.
            //

            HangupCM(pArgs,hwndDlg, TRUE); // fWaitForComplete = TRUE
               
            //
            // Display cancelled message
            //
            
            AppendStatusPane(hwndDlg, IDMSG_CANCELED);
            
            SetInteractive(hwndDlg,pArgs);
            break;

        case PS_Online:
            //
            // If pArgs->fUseTunneling is TRUE, CM actually does not have the PS_Online state
            //
            MYDBGASSERT(!pArgs->fUseTunneling);
            if (pArgs->fUseTunneling) 
            {
                break;
            }

        case PS_TunnelOnline:
        {
            TCHAR szTmp[MAX_PATH];            
            MYVERIFY(GetModuleFileNameU(g_hInst, szTmp, MAX_PATH));          
            pArgs->Log.Log(DISCONNECT_EVENT, szTmp);
            CActionList DisconnectActList;
            DisconnectActList.Append(pArgs->piniService, c_pszCmSectionOnDisconnect);

            //
            // fStatusMsgOnFailure = FALSE
            //
            
            DisconnectActList.RunAccordType(hwndDlg, pArgs, FALSE);

            HangupCM(pArgs,hwndDlg);

            pArgs->dwExitCode = ERROR_CANCELLED;

            // fall through
        }

        case PS_Interactive:
            //
            // Set the error code to tell us the user cancelled and then fall through
            //
            pArgs->dwExitCode = ERROR_CANCELLED;

        case PS_Error:
            EndMainDialog(hwndDlg, pArgs, 0); // FALSE);
            break;

        default:
            MYDBGASSERT(FALSE);
            break;
    }

    //
    // We're definitely not waiting for a callback anymore.
    //

    pArgs->fWaitingForCallback = FALSE;

    //
    // We are exiting Cancel state
    //
    (void)InterlockedExchange(&(pArgs->lInConnectOrCancel), NOT_IN_CONNECT_OR_CANCEL);
}

void OnMainEnChange(HWND hwndDlg, 
                    ArgsStruct *pArgs) 
{
    CheckConnect(hwndDlg, pArgs, NULL);
}

//+----------------------------------------------------------------------------
//
// Function:  OnRasErrorMessage
//
// Synopsis:  Process RAS error message
//
// Arguments: HWND hwndDlg - Main Dialog window handle
//            ArgsStruct *pArgs - 
//            DWORD dwError - RAS error code
//
// Returns:   Nothing
//
// History:   fengsun Created Header    10/24/97
//
//+----------------------------------------------------------------------------
void OnRasErrorMessage(HWND hwndDlg, 
                   ArgsStruct *pArgs,
                   DWORD dwError) 
{
    //
    // Save off whether we are tunneling, before we change state
    //

    BOOL bTunneling = IsDialingTunnel(pArgs);
    
    //
    // Set the progstate to Error if user did not cancel dialing.
    // Note: Set here to ensure that we don't inadvertantly update the status on
    // timer ticks thereby overwriting the error message. Additionally we do this 
    // following SetInteractive in the no-redial case below.
    //
    
    if (ERROR_CANCELLED != dwError)
    {
        CMTRACE(TEXT("OnRasErrorMessage - Entering PS_Error state"));
        pArgs->psState = PS_Error;
    }

    //
    // Set the "ErrorCode" property
    //
    pArgs->dwExitCode = dwError;

    lstrcpyU(pArgs->szLastErrorSrc, TEXT("RAS"));
    
    if (bTunneling && (OS_NT4 || OS_W9X) && IsSafeNetDevice(pArgs->szTunnelDeviceType, pArgs->szTunnelDeviceName))
    {
        //
        //  Okay, if we are using the SafeNet client we want to point the user to the
        //  SafeNet Log file.  Let's get the path and log it out.
        //

        LPTSTR pszFullPathToSafeNetLog = GetPathToSafeNetLogFile();

        if (pszFullPathToSafeNetLog)
        {
            pArgs->Log.Log(ONERROR_EVENT_W_SAFENET, pArgs->dwExitCode, pArgs->szLastErrorSrc, pszFullPathToSafeNetLog);
            CmFree(pszFullPathToSafeNetLog);
            pszFullPathToSafeNetLog = NULL;
        }
    }
    else
    {
        //
        //  Otherwise just log the OnError event normally.
        //
        pArgs->Log.Log(ONERROR_EVENT, pArgs->dwExitCode, pArgs->szLastErrorSrc);
    }

    //
    // Run On-Error connect actions
    //
    CActionList OnErrorActList;
    OnErrorActList.Append(pArgs->piniService, c_pszCmSectionOnError);

    //
    // fStatusMsgOnFailure = FALSE
    //
    OnErrorActList.RunAccordType(hwndDlg, pArgs, FALSE, TRUE);


    LPTSTR  pszRasErrMsg = NULL;

    //
    // See if the error is recoverable (re-dialable)
    // CheckConnectionError also display error msg in the status window
    // Get the ras err msg also.  we'll display it ourself.
    //

    BOOL bDoRedial = !CheckConnectionError(hwndDlg, dwError, pArgs, bTunneling, &pszRasErrMsg);

    //
    // Whether CM get ERROR_PORT_NOT_AVAILABLE because of modem change
    //
    BOOL fNewModem = FALSE;

    if (dwError == ERROR_PORT_NOT_AVAILABLE && !IsDialingTunnel(pArgs))
    {
        //
        // Modem is not avaliable.  See if the modem is changed
        //

        BOOL fSameModem = TRUE;
        if (PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName, &fSameModem))
        {
            if (!fSameModem)
            {
                //
                // If the modem is changed, use the new modem.
                // bDoRedial is still FALSE here so we will not
                // increase redial count or use the backup number
                //

                fNewModem = TRUE;
            }
        }

        // 
        // if PickModem failed, do not try to install modem here
        // cnetcfg return ERROR_CANCELLED, even if modem is intalled 
        //
    }

    //
    // should we try another tunnel dns addr?
    //

    BOOL fTryAnotherTunnelDnsAddr = FALSE;

    if (bDoRedial) 
    {
        //
        // The error is recoverable
        //
        
        CMTRACE1(TEXT("OnRasErrorMessage - Recoverable error %u received."), dwError);

        //
        // If we're dialing a tunnel, try a different IP address on failure.
        //
      
        if (PS_TunnelDialing == pArgs->psState)
        {
            fTryAnotherTunnelDnsAddr = TryAnotherTunnelDnsAddress(pArgs);
        }

        //
        // If we're trying a different IP, then don't count this as a normal 
        // redial. Otherwise, bump the indices and move on to the next number.

        if (!fTryAnotherTunnelDnsAddr)
        {
            //
            // we display the ras error only if:
            // (1) we're not redialing OR
            // (2) we're not redialing a tunnel OR
            // (3) we're redialing a tunnel but NOT redialing with a different 
            //     tunnel dns ip addr.
            //
            if (pszRasErrMsg)
            {
                AppendStatusPane(hwndDlg, pszRasErrMsg);
            }
            
            // should we redial?
            //
            if (pArgs->nRedialCnt)  
            {
                //
                // We get an error message from RAS each time we dial (modem, vpn, ISDN). In case of 
                // dual channel ISDN we get two notification (one per channel), and we need to ignore 
                // one of them. Here we chose to ignore the 2nd one. Thus we want to change the 
                // redial count and change the dial index only if this is NOT the 2nd RasSubEntry 
                // in case of dual channel ISDN.
                //
                if (FALSE == ((CM_ISDN_MODE_DUALCHANNEL_FALLBACK == pArgs->dwIsdnDialMode || 
                               CM_ISDN_MODE_DUALCHANNEL_ONLY == pArgs->dwIsdnDialMode) && 
                               2 == pArgs->dwRasSubEntry))
                {
                    //
                    // We have not reached the retry limit, try to redial
                    //
                    pArgs->nRedialCnt--;   
                    pArgs->nDialIdx++;
                }

                //
                // If ndx now matches count, or if the next number is empty 
                // (not dialable) this our last number to dial on this pass.
                // Adjust the re-dial counter if it applies.
                //

                if (pArgs->nDialIdx == MAX_PHONE_NUMBERS || 
                    !pArgs->aDialInfo[pArgs->nDialIdx].szDialablePhoneNumber[0]) 
                {
                    pArgs->nDialIdx = 0;
                }
            }
            else
            {
                //
                // Last redial try failed
                //
    
                bDoRedial = FALSE;
            }
        }
    }
    else
    {

        CMTRACE1(TEXT("OnRasErrorMessage - Non-recoverable error %u received."), dwError);

        //
        // we display the ras error only if:
        // (1) we're not redialing OR
        // (2) we're not redialing a tunnel OR
        // (3) we're redialing a tunnel but NOT redialing with a different 
        //     tunnel dns ip addr.
        //
        if (pszRasErrMsg)
        {
            AppendStatusPane(hwndDlg, pszRasErrMsg);
        }
    }

    bDoRedial |= fNewModem; // fNewModem only true if not dialing tunnel

    //
    // Perform Hangup here
    //
    if (IsDialingTunnel(pArgs) && bDoRedial)
    {
        //
        // For tunnel dialing, only hangup tunnel connection, Do not hangup 
        // PPP connection before retry.
        //
        MyRasHangup(pArgs,pArgs->hrcTunnelConn);  
        pArgs->hrcTunnelConn = NULL;

        if (pArgs->IsDirectConnect())
        {
            //
            // The statistic is stopped in HangupCM
            // Since we do not call HangupCM, we have to close it here
            //

            if (pArgs->pConnStatistics)
            {
                pArgs->pConnStatistics->Close();
            }
        }
    }
    else
    {
        if (OS_NT)
        {
            HangupCM(pArgs, hwndDlg, FALSE, !bDoRedial);  
        }
        else
        {
            //
            // On win9x, in some PPP case, when CM get Tunnel RAS error message, 
            // RasHangup will not release the PPP RAS handle until this
            // message returns. See bug 39718
            //
            
            PostMessageU(hwndDlg, WM_HANGUP_CM, !bDoRedial, dwError);
        }
    }

    // 
    // If we want re-dial enter pause state, otherwise just SetInteractive
    // 

    if (bDoRedial)
    {
        //
        // If the state is PS_Error, we will use the timer we set before the call.  
        // However we will not check whether the timer expired here.
        //

        if (fTryAnotherTunnelDnsAddr)
        {
            //
            // if we want to try another tunnel dns addr, we don't want to display
            // any error msg or pause, just retry with another addr without the 
            // user realizing it.
            //
            pArgs->dwStateStartTime = GetTickCount() + (pArgs->nRedialDelay * 1000);
        }
        else
        {
            //
            // NT #360488 - nickball
            // 
            // Reset the timer so that we pause for the redial delay before 
            // trying to connect again. ErrorEx (now unused), conditioned this
            // code on the error state not being PS_Error, however, this was 
            // broken when we started setting the state to PS_Error at the 
            // beginning of this function. Because ErrorEx is not longer used, 
            // we can restore the timer reset to all states.
            //

            pArgs->dwStateStartTime = GetTickCount();  
            pArgs->nLastSecondsDisplay = (UINT) -1;     
        }

        pArgs->psState = PS_Pausing;
    }
    else
    {
        SetInteractive(hwndDlg,pArgs);

        if (ERROR_CANCELLED != dwError)
        {
            CMTRACE(TEXT("OnRasErrorMessage - Restoring PS_Error state"));
            pArgs->psState = PS_Error;
        }

        pArgs->dwExitCode = dwError;

        // in 'unattended dial' mode, exit ICM
        if (pArgs->dwFlags & FL_UNATTENDED)
        {
            PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL, dwError);
        }
    }

    if (pszRasErrMsg)
    {
        CmFree(pszRasErrMsg);
    }   
} 

//+----------------------------------------------------------------------------
//
// Function:  OnRasNotificationMessage
//
// Synopsis:  Message handler for RAS status/error messages.
//
// Arguments: HWND hwndDlg      - Main Dialog window handle
//            ArgsStruct *pArgs - Ptr to global Args struct
//            WPARAM wParam     - RAS status message
//            LPARAM lParam     - RAS error message. ERROR_SUCCESS if none.
//
// Returns:   Error code if applicable.
//
// History:   nickball          Created Header      05/19/99
//
//+----------------------------------------------------------------------------
DWORD OnRasNotificationMessage(HWND hwndDlg, 
                               ArgsStruct *pArgs, 
                               WPARAM wParam, 
                               LPARAM lParam)
{
    static BOOL bFirstChannelConnected = -1; // set it to neither connected nor failed
    static BOOL bSecondChannelConnected = -1; // set it to neither connected nor failed

    CMTRACE2(TEXT("OnRasNotificationMessage() wParam=%u, lParam=%u"), wParam, lParam);
    
    if (pArgs->fIgnoreTimerRasMsg)
    {
        CMTRACE(TEXT("OnRasNotificationMessage() ignoring Ras and Timer messages"));
        return ERROR_SUCCESS;
    }

    //
    // If we have an error notification from RAS, handle it.
    //

    if (ERROR_SUCCESS != lParam) 
    {
        //
        //  If one of the subchannels on multilinked ISDN fails, default to single channel if we are configured to do so.
        //

        if (OS_NT5)
        {
            if (CM_ISDN_MODE_DUALCHANNEL_FALLBACK == pArgs->dwIsdnDialMode)
            {
                //
                //  If we are in here then we are doing ISDN dual channel with fallback mode and one of the channels failed.
                //  Since we are in fallback mode, it is okay to continue with only one.  If the other channel has already
                //  connected then go ahead and post the connect message.  If not, then it will be handled below in the
                //  RASCS_SubEntryConnected processing.  Note that RAS doesn't send a RASCS_Connected notification in this case.
                //
                if (1 == pArgs->dwRasSubEntry)
                {
                    bFirstChannelConnected = FALSE;
                }
                else if (2 == pArgs->dwRasSubEntry)
                {
                    bSecondChannelConnected = FALSE;
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("OnRasNotificationMessage -- error on unknown subentry."));
                }

                //
                //  If one of the channels connected already, go ahead and post the connect message.
                //
                if ((TRUE == bFirstChannelConnected) || (TRUE == bSecondChannelConnected))
                {
                    CMTRACE(TEXT("Sending WM_CONNECTED_CM -- one entry succeeded and one failed."));
                    PostMessageU(hwndDlg, WM_CONNECTED_CM, 0, 0);
                    return ERROR_SUCCESS;
                }
            }
        }

        //
        // Skip PENDING notifications 
        //
        
        if (PENDING == lParam)
        {
            CMTRACE(TEXT("OnRasNotificationMessage() Skipping PENDING notification."));       
            return ERROR_SUCCESS;
        }

        //
        // If we're already in the interactive or error state, then
        // ignore any subsequent error notifications from RAS. 
        //
        // For example: RAS often sends a ERROR_USER_DISCONNECTION 
        // notification when we call RasHangup.
        //
        
        if (pArgs->psState == PS_Interactive || pArgs->psState == PS_Error)
        {
            CMTRACE1(TEXT("OnRasNotificationMessage() Ignoring error because pArgs->psState is %u."), pArgs->psState);       
            return ERROR_SUCCESS;
        }

        CMTRACE(TEXT("OnRasNotificationMessage() Handling error message."));
        OnRasErrorMessage(hwndDlg, pArgs, (DWORD)lParam);
    }
    else 
    {
        // We have a RAS status update, act accordingly

        switch (wParam) 
        {
            case RASCS_OpenPort:
            {
                if (OS_NT5 || OS_MIL)
                {
                    //
                    //  Make sure to init the ISDN fallback mode vars just in case
                    //  the state machine is cancelled in the middle somewhere.  We 
                    //  want the next call to have the correct values for these vars.
                    //
                    if (1 == pArgs->dwRasSubEntry)
                    {
                        bFirstChannelConnected = -1;                
                    }
                    else if (2 == pArgs->dwRasSubEntry)
                    {
                        bSecondChannelConnected = -1;        
                    }
                }
            }
            break;

            case RASCS_Authenticate:
            {
                //
                //  Win9x often sends two RASCS_Authenticate messages a few seconds apart.  This has the disconcerting
                //  effect of restarting the authenticating timer that the user sees.  Thus, we now don't reset the time if
                //  we are already in the PS_XXX state that we are going to be setting.
                //
                BOOL bResetAuthTime = FALSE;
                CMTRACE(TEXT("RASCS_Authenticate"));

                if (IsDialingTunnel(pArgs))  // PPTP dialing
                {
                    if (PS_TunnelAuthenticating != pArgs->psState)
                    {
                        bResetAuthTime = TRUE;
                    }

                    pArgs->psState = PS_TunnelAuthenticating;
                }
                else
                {
                    if (PS_Authenticating != pArgs->psState)
                    {
                        bResetAuthTime = TRUE;
                    }

                    pArgs->psState = PS_Authenticating;
                }

                if (bResetAuthTime)
                {
                    pArgs->dwStateStartTime = GetTickCount();
                    pArgs->nLastSecondsDisplay = (UINT) -1;
    
                }
            }
                break;

            case RASCS_SubEntryConnected:
            {
                //
                //  Special handling for the ISDN dual channel case when we are in fallback mode.  Since
                //  RAS doesn't send us a RASCS_Connected notification if some of the channels fail but
                //  not all of them, we must keep track of what happened on the two channels and react
                //  accordingly.
                //
                if (OS_NT5)
                {
                    if (CM_ISDN_MODE_DUALCHANNEL_FALLBACK == pArgs->dwIsdnDialMode)
                    {
                        if (1 == pArgs->dwRasSubEntry)
                        {
                            bFirstChannelConnected = TRUE;
                        }
                        else if (2 == pArgs->dwRasSubEntry)
                        {
                            bSecondChannelConnected = TRUE;
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("OnRasNotificationMessage -- error on unknown subentry. (RASCS_SubEntryConnected)"));
                        }

                        //
                        //  If one of the channels failed already, go ahead and post the connect message.
                        //  Otherwise we will wait for the RASCS_Connected.
                        //
                        if ((TRUE == bFirstChannelConnected) && (FALSE == bSecondChannelConnected) ||
                            (FALSE == bFirstChannelConnected) && (TRUE == bSecondChannelConnected))
                        {
                            CMTRACE(TEXT("Sending WM_CONNECTED_CM -- one entry succeeded and one failed."));
                            PostMessageU(hwndDlg, WM_CONNECTED_CM, 0, 0);
                            return ERROR_SUCCESS;
                        }
                    }
                }            
            }
                break;

            case RASCS_Connected: 
            {
                CMTRACE(TEXT("RASCS_Connected"));

                //
                // Post a message to ourselves to indicate that we are connected
                //

                PostMessageU(hwndDlg, WM_CONNECTED_CM,0,0);
                break;
            }

            //
            // Pause states are dealt with explicity below
            //

            case (RASCS_PAUSED + 4): // 4100 - RASCS_InvokeEapUI   
            case RASCS_Interactive:
            case RASCS_RetryAuthentication:
            case RASCS_CallbackSetByCaller:
            case RASCS_PasswordExpired:
                break;

            //
            // Callback handling states
            //
            case RASCS_PrepareForCallback:
                pArgs->fWaitingForCallback = TRUE;
                pArgs->psState = PS_Pausing;
                break;

            case RASCS_CallbackComplete:
                pArgs->fWaitingForCallback = FALSE;               
                break;

            //
            // The following status codes are not handled explicitly
            //

            case RASCS_Disconnected:
                break;

            case RASCS_SubEntryDisconnected:
                break;

            case RASCS_PortOpened:
                break;

            case RASCS_ConnectDevice:
                break;

            case RASCS_DeviceConnected:
                break;

            case RASCS_AllDevicesConnected:
                break;

            case RASCS_AuthNotify:
                break;

            case RASCS_AuthRetry:
                break;

            case RASCS_AuthCallback:
                break;

            case RASCS_AuthChangePassword:
                break;

            case RASCS_AuthProject:
                break;

            case RASCS_AuthLinkSpeed:
                break;

            case RASCS_AuthAck:
                break;

            case RASCS_ReAuthenticate:
                break;

            case RASCS_Authenticated:
                break;

            case RASCS_WaitForModemReset:
                break;

            case RASCS_WaitForCallback:
                break;

            case RASCS_Projected:
                break;

            case RASCS_StartAuthentication:
                break;

            case RASCS_LogonNetwork:
                break;

            default:  
                CMTRACE(TEXT("OnRasNotificationMessage() - message defaulted"));
                break;
        }
    }
    
    if (wParam & RASCS_PAUSED)
    {
        //
        // Screen out unsupported states
        //

        switch (wParam)
        {
            case RASCS_Interactive: // for scripts -- NTRAID 378224
            case (RASCS_PAUSED + 4): // 4100 - RASCS_InvokeEapUI
            case RASCS_PasswordExpired:
            case RASCS_RetryAuthentication:
            case RASCS_CallbackSetByCaller:
                PostMessageU(hwndDlg, WM_PAUSE_RASDIAL, wParam, lParam);
                break;
                
            default:
                MYDBGASSERT(FALSE);
                return (ERROR_INTERACTIVE_MODE); // unhandled pause state
        }
    } 
    
    return ERROR_SUCCESS;
}

// timer: check the current connection manager status, update the status message
//        on the screen

void OnMainTimer(HWND hwndDlg, 
                 ArgsStruct *pArgs) 
{
    //
    // If timer ID is null, don't process messages
    // 

    if (NULL == pArgs->nTimerId)
    {
        return;
    }

    //
    // Timer is good, check StartupInfoLoad
    //

    LPTSTR pszMsg = NULL;
    DWORD dwSeconds = (GetTickCount() - pArgs->dwStateStartTime) / 1000;

    CheckStartupInfo(hwndDlg, pArgs);

    // CMTRACE1(TEXT("OnMainTimer() pArgs->psState is %u"), pArgs->psState);

    //
    // Update future splash if any
    //
    
    MapStateToFrame(pArgs);

    switch (pArgs->psState) 
    {
        case PS_Dialing:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_DIALING,
                                  pArgs->aDialInfo[pArgs->nDialIdx].szDisplayablePhoneNumber,
                                  pArgs->szDeviceName,
                                  dwSeconds);
                //
                // Clear the status window
                //
                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
            }
            break;
                 
        case PS_TunnelDialing:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_TUNNELDIALING,
                                  pArgs->GetTunnelAddress(),
                                  dwSeconds);
                
                //
                // Clear the status window
                //
                SetDlgItemText(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
           }
           break;
                
        case PS_Pausing:

            //
            // Special case of pausing is when we're waiting for the server to call us back.
            //
            
            if (pArgs->fWaitingForCallback)
            {
                //
                // Notify the user of this fact
                //

                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_WAITING_FOR_CALLBACK, 
                                  (GetTickCount()-pArgs->dwStateStartTime)/1000);                                                  
                //
                // Clear the status window
                //

                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
                break;
            }

            if (GetTickCount()-pArgs->dwStateStartTime <= pArgs->nRedialDelay * 1000) 
            {
                //
                // Update the display if not timeout
                //
                if (pArgs->nLastSecondsDisplay != dwSeconds) 
                {
                    pszMsg = CmFmtMsg(g_hInst,IDMSG_PAUSING,dwSeconds);
                    pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
                }
            }
            else
            {

                DWORD dwRes;

                if (pArgs->IsDirectConnect() || pArgs->hrcRasConn != NULL)
                {
                    //
                    // For the first tunnel try, CM does not hangup ppp connection
                    //
                    MYDBGASSERT(pArgs->fUseTunneling);

                    pArgs->psState = PS_TunnelDialing;
                    pArgs->dwStateStartTime = GetTickCount();
                    pArgs->nLastSecondsDisplay = (UINT) -1;

                    dwRes = DoTunnelDial(hwndDlg,pArgs);
                
                    //
                    // Update the status right away because there are times
                    // that things happen so quickly that the main status 
                    // display doesn't have a chance to display the tunnel
                    // dialing info...
                    //
                    pszMsg = CmFmtMsg(g_hInst,
                                      IDMSG_TUNNELDIALING,
                                      pArgs->GetTunnelAddress(),
                                      0);
                    
                    //
                    // Clear the status window
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                }
                else
                {
                    dwRes = DoRasDial(hwndDlg,pArgs,pArgs->nDialIdx);
                }

                if (dwRes == ERROR_SUCCESS) 
                {
                    MapStateToFrame(pArgs);
                    pArgs->dwStateStartTime = GetTickCount();
                    pArgs->nLastSecondsDisplay = (UINT) -1;
                } 
                else 
                {
                    HangupCM(pArgs, hwndDlg);
                    UpdateError(pArgs, dwRes);
                    SetLastError(dwRes);
                }
            }
            break;

        case PS_Authenticating:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                //
                // Get the appropriate username based on whether we're 
                // tunneling and using the same credentials for dial-up.
                //

                LPTSTR pszTmpUserName;
                    
                if (pArgs->fUseTunneling && (!pArgs->fUseSameUserName))    
                {
                    pszTmpUserName = pArgs->szInetUserName;
                }
                else
                {
                    pszTmpUserName = pArgs->szUserName;
                }

                //
                // If username is still blank, use the RasDialParams as a 
                // backup. This can occur in cases such as EAP
                //

                if (TEXT('\0') == *pszTmpUserName)
                {
                    pszTmpUserName = pArgs->pRasDialParams->szUserName;          
                }                
                                    
                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_CHECKINGPASSWORD, 
                                  pszTmpUserName, 
                                  (GetTickCount()-pArgs->dwStateStartTime)/1000);                                                  
                //
                // Clear the status window
                //

                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
            }
            break;

        case PS_TunnelAuthenticating:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                LPTSTR pszTmpUserName = pArgs->szUserName;
                
                //
                // If username is still blank, use the RasDialParams as a 
                // backup. This can occur in cases such as EAP
                //

                if (TEXT('\0') == *pszTmpUserName)
                {
                    pszTmpUserName = pArgs->pRasDialParams->szUserName;          
                }                

                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_CHECKINGPASSWORD,
                                  pszTmpUserName,
                                  (GetTickCount()-pArgs->dwStateStartTime)/1000);

                //
                // Clear the status window
                //
                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
            }
            break;
    
        case PS_Online:
            
            //
            // If pArgs->fUseTunneling is TRUE, CM actually does not have the PS_Online state
            //
             
            MYDBGASSERT(!pArgs->fUseTunneling); 

        case PS_TunnelOnline:
            
            //
            // The dialog should be ended by now
            //
            
            MYDBGASSERT(!"The dialog should be ended by now"); 
            break;          

        case PS_Error:
        case PS_Interactive:
        default:
            break;
    }
    
    // If we have a status message as a result of the above, display it

    if (pszMsg) 
    {
        AppendStatusPane(hwndDlg,pszMsg);
        CmFree(pszMsg);
    }
}
                
//
// MainDlgProc: main dialog box message processing function
//

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, 
                          UINT uMsg, 
                          WPARAM wParam, 
                          LPARAM lParam) 
{
    ArgsStruct *pArgs = (ArgsStruct *) GetWindowLongU(hwndDlg,DWLP_USER);

    static const DWORD adwHelp[] = {IDC_MAIN_NOPROMPT_CHECKBOX, IDH_LOGON_AUTOCONN,
                              IDC_MAIN_NOPASSWORD_CHECKBOX, IDH_LOGON_SAVEPW,
                              IDC_MAIN_USERNAME_STATIC,IDH_LOGON_NAME,
                              IDC_MAIN_USERNAME_EDIT,IDH_LOGON_NAME,
                              IDC_MAIN_PASSWORD_STATIC,IDH_LOGON_PSWD,
                              IDC_MAIN_PASSWORD_EDIT,IDH_LOGON_PSWD,
                              IDC_MAIN_DOMAIN_STATIC, IDH_LOGON_DOMAIN,
                              IDC_MAIN_DOMAIN_EDIT, IDH_LOGON_DOMAIN,
                              IDC_MAIN_RESET_PASSWORD, IDH_LOGON_NEW,
                              IDC_MAIN_MESSAGE_DISPLAY,IDH_LOGON_SVCMSG,
                              IDC_MAIN_STATUS_LABEL,IDH_LOGON_CONNECT_STAT,
                              IDC_MAIN_STATUS_DISPLAY,IDH_LOGON_CONNECT_STAT,
                              IDOK,IDH_LOGON_CONNECT,
                              IDCANCEL,IDH_LOGON_CANCEL,
                              IDC_MAIN_PROPERTIES_BUTTON,IDH_LOGON_PROPERTIES,
                              IDC_MAIN_HELP_BUTTON,IDH_CMHELP,
                              IDC_MAIN_ACCESSPOINT_COMBO, IDH_LOGON_ACCESSPOINTS,
                              IDC_MAIN_ACCESSPOINT_STATIC, IDH_LOGON_ACCESSPOINTS,
                              IDC_OPT_CREDS_SINGLE_USER, IDH_LOGON_SAVEFORME, 
                              IDC_OPT_CREDS_ALL_USER, IDH_LOGON_SAVEFORALL,
                              0,0};

    //
    // Dialog box message processing 
    //
    switch (uMsg) 
    {
        case WM_PAINT:

            CheckStartupInfo(hwndDlg, pArgs);
            break;

        case WM_INITDIALOG:

            CM_SET_TIMING_INTERVAL("WM_INITDIALOG - Begin");

            UpdateFont(hwndDlg);

            // 
            // Extract args and perform main initialization
            //
            
            pArgs = (ArgsStruct *) lParam;
            
            if (pArgs)
            {
                pArgs->hwndMainDlg = hwndDlg;
            }

            SetWindowLongU(hwndDlg,DWLP_USER, (LONG_PTR) pArgs);
            
            OnMainInit(hwndDlg, pArgs);

            CM_SET_TIMING_INTERVAL("WM_INITDIALOG - End");

            return (FALSE);

        case WM_ENDSESSION:
            
            // 
            // Windows system is shutting down or logging off
            //

            if ((BOOL)wParam == TRUE)
            {               
                //
                // Just cancel
                //

                OnMainCancel(hwndDlg, pArgs);
            }
            return 0;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    OnMainConnect(hwndDlg,pArgs);

                    //
                    // Check if there is an error, and if it's unattended dial,
                    // we just exit silently  -- byao 5/9/97
                    //

                    if ((PS_Interactive == pArgs->psState || PS_Error == pArgs->psState) &&
                        (pArgs->dwFlags & FL_UNATTENDED))
                    {
                        OnMainCancel(hwndDlg, pArgs);
                    }
                    return (TRUE);

                case IDC_MAIN_PROPERTIES_BUTTON:
                    if (ID_OK_RELAUNCH_MAIN_DLG == OnMainProperties(hwndDlg,pArgs))
                    {
                        //
                        //  We want to relaunch the logon UI with Access Points enabled or disabled depending
                        //  on the change the user made in the properties dialog.
                        //
                        EndMainDialog(hwndDlg, pArgs, ID_OK_RELAUNCH_MAIN_DLG);
                    }

                    return (TRUE);

                case IDC_MAIN_HELP_BUTTON: 
                {
                    UINT nCtrlFocus = IsWindowEnabled(GetDlgItem(hwndDlg,IDOK)) ? IDOK : IDCANCEL;
                    CmWinHelp(hwndDlg,hwndDlg,pArgs->pszHelpFile,HELP_FORCEFILE,0);               
                    MainSetDefaultButton(hwndDlg,nCtrlFocus);
                    return (TRUE);
                }

                case IDC_MAIN_NOPROMPT_CHECKBOX:
                    pArgs->fDialAutomatically = !pArgs->fDialAutomatically;  
                    if (TRUE == pArgs->fDialAutomatically)
                    {
                        MYDBGASSERT(!pArgs->fHideDialAutomatically);

                        //
                        // Display message explaining Dial Automatically
                        //
                        LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, 
                                                                 c_pszCmEntryDialAutoMessage);
                        if (pszTmp && *pszTmp)
                        {
                            MessageBoxEx(hwndDlg, 
                                         pszTmp, 
                                         pArgs->szServiceName,
                                         MB_OK|MB_ICONWARNING, 
                                         LANG_USER_DEFAULT);
                        }

                        CmFree(pszTmp);
                    }
                    break;

                case IDC_MAIN_NOPASSWORD_CHECKBOX:
                    pArgs->fRememberMainPassword = !(pArgs->fRememberMainPassword);
                    if (!pArgs->piniService->GPPB(c_pszCmSection,
                                                    c_pszCmEntryPwdOptional))
                    {
                        //
                        // If password is not optional, enable/disable
                        // Dial Automatically according to state of
                        // "Remember password"
                        // 

                        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), 
                                        pArgs->fRememberMainPassword);  
                        if (FALSE == pArgs->fRememberMainPassword) 
                        {
                            //
                            // Reset Dial Automatically if user 
                            // unchecks Save Password and password 
                            // is not optional
                            //
                            CheckDlgButton(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX, FALSE);
                            pArgs->fDialAutomatically = FALSE;

                            if (pArgs->fGlobalCredentialsSupported)
                            {
                                //
                                // Also disable the option buttons
                                //
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
                            }

                            //
                            // Since we aren't remembering the main password
                            // see if we need to not remember Inet passwords
                            //
                            if (pArgs->fUseSameUserName)
                            {
                                pArgs->fRememberInetPassword = FALSE;
                                (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));
                            }

                            //
                            // If the password edit hasn't been edited by the user, then we
                            // mostly likely have 16 *'s which doesn't help the user when
                            // they try to connect. Thus we need to clear the edit box
                            //
                            HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
                            if (hwndPassword)
                            {
                                pArgs->fIgnoreChangeNotification = TRUE;
                                BOOL fPWFieldModified = (BOOL) SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L); 
                                if (FALSE == fPWFieldModified)
                                {
                                    (VOID)pArgs->SecurePW.SetPassword(TEXT(""));
                                    SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, TEXT(""));
                                }

                                pArgs->fIgnoreChangeNotification = FALSE;
                            }
                        }
                        else
                        {
                            // 
                            // Save Password option is Enabled
                            //
                            if (pArgs->fGlobalCredentialsSupported)
                            {
                                //
                                // Also enable the option buttons
                                //
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), TRUE);
                            }

                            HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
                            if (hwndPassword)
                            {
                                BOOL fPWFieldModified = (BOOL) SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L); 

                                if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                                {
                                    //
                                    // Try to reload current creds now that the user has enabled the save
                                    // password option, unless the password field has been edited
                                    //
                                    CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_CHECKED);
                                    CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_UNCHECKED);

                                    if (FALSE == fPWFieldModified)
                                    {
                                        //
                                        // Set the 3rd param to TRUE in order to bypass the check  
                                        // that it's called when we are in the local credential mode.
                                        //
                                    
                                        SwitchToGlobalCreds(pArgs, hwndDlg, TRUE);
                                    }
                                }
                                else
                                {
                                    if (pArgs->fGlobalCredentialsSupported)
                                    {
                                        CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_UNCHECKED);
                                        CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_CHECKED);
                                    }
                                
                                    if (FALSE == fPWFieldModified)
                                    {
                                        //
                                        // Set the 3rd param to TRUE in order to bypass the check  
                                        // that it's called when we are in the global credential mode.
                                        //
                                    
                                        SwitchToLocalCreds(pArgs, hwndDlg, TRUE);
                                    }
                                }
                            }
                        }
                    }
                    break;
                
                case IDC_OPT_CREDS_SINGLE_USER:
                {
                    //
                    // FALSE - allows the function to only execute if we are currently using
                    // the global credential store and the user now wants to switch.
                    //
                    SwitchToLocalCreds(pArgs, hwndDlg, FALSE);
                    break;
                }

                case IDC_OPT_CREDS_ALL_USER:
                {
                    //
                    // FALSE - allows the function to only execute if we are currently using
                    // the local credential store and the user now wants to switch.
                    //
                    SwitchToGlobalCreds(pArgs, hwndDlg, FALSE);
                    break;
                }

                case IDC_MAIN_RESET_PASSWORD:
                    OnResetPassword(hwndDlg, pArgs);
                    break;

                case IDC_MAIN_CUSTOM:
                    OnCustom(hwndDlg, pArgs);
                    break;

                case IDCANCEL:
                    OnMainCancel(hwndDlg,pArgs);
                    return (TRUE);

                case IDC_MAIN_PASSWORD_EDIT:
                case IDC_MAIN_USERNAME_EDIT:
                case IDC_MAIN_DOMAIN_EDIT:
                    if ((HIWORD(wParam) == EN_CHANGE))
                    {
                        if (!pArgs->fIgnoreChangeNotification) 
                        {
                            OnMainEnChange(hwndDlg,pArgs);
                            return (TRUE);
                        }
                    }
                    break;
                case IDC_MAIN_ACCESSPOINT_COMBO:
                    if (CBN_SELENDOK == HIWORD(wParam))
                    {
                        if (ChangedAccessPoint(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO))
                        {
                            UINT nCtrlFocus;

                            CheckConnect(hwndDlg,pArgs,&nCtrlFocus);
                            MainSetDefaultButton(hwndDlg,nCtrlFocus);
                        }
                    }
                default:
                    break;
            }
            break;

        case WM_HELP:
            CmWinHelp((HWND) (((LPHELPINFO) lParam)->hItemHandle),
                    (HWND) (((LPHELPINFO) lParam)->hItemHandle),
                     pArgs->pszHelpFile,
                     HELP_WM_HELP,
                     (ULONG_PTR) (LPSTR) adwHelp);
            return (TRUE);

        case WM_CONTEXTMENU:
            {
                POINT   pt = {LOWORD(lParam), HIWORD(lParam)};
                HWND    hwndCtrl;

                ScreenToClient(hwndDlg, &pt);
                hwndCtrl = ChildWindowFromPoint(hwndDlg, pt);
                if (!hwndCtrl || HaveContextHelp(hwndDlg, hwndCtrl))
                {
                    CmWinHelp((HWND) wParam,
                             hwndCtrl,
                             pArgs->pszHelpFile,
                             HELP_CONTEXTMENU,
                             (ULONG_PTR)adwHelp);
                }
                return (TRUE);
            }

        case WM_SIZE:
            //
            // Dynamicly Enable/Disable system menu
            //
            {
                HMENU hMenu = GetSystemMenu(hwndDlg, FALSE);

                if (hMenu)
                {
                    //
                    // if the dlg is minimized, then disable the minimized menu
                    //

                    if (wParam == SIZE_MINIMIZED)
                    {
                        EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND | MF_GRAYED);
                        EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
                    }
                    else if (wParam != SIZE_MAXHIDE && wParam != SIZE_MAXSHOW)
                    {
                        EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND | MF_ENABLED);
                        EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | MF_GRAYED);
                    }
                }
                MYDBGASSERT(hMenu); // assert if hMenu is NULL

            }
            break;

        case WM_TIMER:

            //
            // Ignore the timer, if a (pre)connect action is running
            //
            
            if (!pArgs->fIgnoreTimerRasMsg)
            {
                OnMainTimer(hwndDlg,pArgs);
            }

            break;
        
        case WM_PALETTEISCHANGING:
            CMTRACE2(TEXT("MainDlgProc() got WM_PALETTEISCHANGING message, wParam=0x%x, hwndDlg=0x%x."), 
                wParam, hwndDlg);

            break;

        case WM_PALETTECHANGED: 
        {       
            //
            // If its not our window that changed the palette, and we have a bitmap
            //

            if (IsWindowVisible(hwndDlg) && (wParam != (WPARAM) hwndDlg) && pArgs->BmpData.hDIBitmap)
            {
                //
                // Handle the palette change.
                //
                // Note: We used to pass a flag indicating whether another 
                // bitmap was being displayed, but given that we select the 
                // paletted as a background app. this is no longer needed
                //
                
                CMTRACE2(TEXT("MainDlgProc() handling WM_PALETTECHANGED message, wParam=0x%x, hwndDlg=0x%x."),
                    wParam, hwndDlg);

                PaletteChanged(&pArgs->BmpData, hwndDlg, IDC_MAIN_BITMAP); 
            }
            
            return TRUE;
        }

        case WM_QUERYNEWPALETTE:
            
            if (IsWindowVisible(hwndDlg))
            {
                CMTRACE2(TEXT("MainDlgProc() handling WM_QUERYNEWPALETTE message, wParam=0x%x, hwndDlg=0x%x."), 
                    wParam, hwndDlg);

                QueryNewPalette(&pArgs->BmpData, hwndDlg, IDC_MAIN_BITMAP);
            }
            return TRUE;

        case WM_LOADSTARTUPINFO:
            OnMainLoadStartupInfo(hwndDlg, pArgs);
            break;

        case WM_HANGUP_CM:
            MYDBGASSERT(OS_W9X);
            HangupCM(pArgs, hwndDlg, FALSE, (BOOL)wParam);
            break;

        case WM_CONNECTED_CM:
            OnConnectedCM(hwndDlg, pArgs);
            break;

        case WM_PAUSE_RASDIAL:
            OnPauseRasDial(hwndDlg, pArgs, wParam, lParam);
            break;
                
        default:
            break;
    }                                
    
    if (pArgs && (uMsg == pArgs->uMsgId)) 
    {
        OnRasNotificationMessage(hwndDlg, pArgs, wParam, lParam);
        return (TRUE);
    }
    
    return (FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessCleanup
//
//  Synopsis:   Helper function to encapsulate closing Watch process handles
//
//  Arguments:  pArgs - pointer to global args struct
//
//  Returns:    Nothing
//
//  History:    a-nichb - Created - 4/30/97
//
//----------------------------------------------------------------------------
void ProcessCleanup(ArgsStruct* pArgs)
{
    BOOL bRes;
    
    if (pArgs->phWatchProcesses) 
    {
        DWORD dwIdx;

        for (dwIdx=0;pArgs->phWatchProcesses[dwIdx];dwIdx++) 
        {
            bRes = CloseHandle(pArgs->phWatchProcesses[dwIdx]);
#ifdef DEBUG
            if (!bRes)
            {
                CMTRACE1(TEXT("ProcessCleanup() CloseHandle() failed, GLE=%u."), GetLastError());
            }
#endif            
        }
        CmFree(pArgs->phWatchProcesses);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckProfileIntegrity
//
//  Synopsis:   Helper function to verify that we have valid profile.
//              Verifies that we have a .CMP file name and that the 
//              .CMS file exists.
//
//  Arguments:  pArgs - pointer to global args struct
//
//  Returns:    TRUE if profile is valid
//
//  History:    a-nichb - Created - 5/8/97
//              byao    - Modified - 6/3/97   Added CMS/CMP file version check
//----------------------------------------------------------------------------

BOOL CheckProfileIntegrity(ArgsStruct* pArgs)
{
    LPTSTR pszTmp = NULL;
    LPCTSTR pszCmsFile = NULL;
    DWORD dwCmsVersion, dwCmpVersion, dwCmVersion;

    int iMsgId = 0;

    if (NULL == pArgs)
    {
        return FALSE;
    }

    //
    // Make sure that we have a profile name and a CMS that exists
    //
    
    if (!(*pArgs->piniProfile->GetFile())) 
    {
        iMsgId = IDMSG_DAMAGED_PROFILE;
        CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run without a .cmp file."));
    }

    //
    // If profile is good, check CMS
    //

    if (0 == iMsgId)
    {   
        pszCmsFile = pArgs->piniService->GetFile();

        if (!*pszCmsFile || FALSE == FileExists(pszCmsFile)) 
        {
            iMsgId = IDMSG_DAMAGED_PROFILE;
            CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run without a valid .cms file."));
        }
    }

    // 
    // Now check the CMS/CMP file version
    //

    if (0 == iMsgId)
    {
        dwCmsVersion = pArgs->piniService->GPPI(c_pszCmSectionProfileFormat, c_pszVersion);
        dwCmpVersion = pArgs->piniProfile->GPPI(c_pszCmSectionProfileFormat, c_pszVersion);


        if ((dwCmsVersion != dwCmpVersion) || 0 == dwCmpVersion || 0 == dwCmsVersion)
        {
            iMsgId = IDMSG_DAMAGED_PROFILE;
            CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run with different version numbers."));                                
        }
                
        if (0 == iMsgId)
        {
            if (dwCmsVersion > PROFILEVERSION || dwCmpVersion > PROFILEVERSION)
            {
                // 
                // CM has older version than either CMS or CMP file
                //

                iMsgId = IDMSG_WRONG_PROFILE_VERSION;
                CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run with a newer CMS/CMP file."));
            }
        }
    }
    
    //
    // Report any problems to the user
    //

    if (iMsgId)
    {
        //
        //  Make sure we aren't in unattended mode before showing UI to the user
        //
        if (0 == (pArgs->dwFlags & FL_UNATTENDED))
        {
            pszTmp = CmFmtMsg(g_hInst, iMsgId);
            MessageBoxEx(NULL, pszTmp, pArgs->szServiceName, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309
            CmFree(pszTmp);
        }

        pArgs->dwExitCode = ERROR_WRONG_INFO_SPECIFIED;
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  GetConnectType
//
// Synopsis:  Encapsulates determination of connect type based upon tunneling,
//            etc.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
void GetConnectType(ArgsStruct *pArgs)
{
    //
    // If tunneling is not enabled, the decision is a simple one
    // 

    if (!IsTunnelEnabled(pArgs))
    {
        //
        // Only support dial-up, if tunnel is not enabled
        //
        pArgs->SetBothConnTypeSupported(FALSE);
        pArgs->SetDirectConnect(FALSE);
    }
    else
    {
        //
        // Load connection type info for CM 1.1, default is support both
        //
        int iSupportDialup = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryDialup, 1);
        int iSupportDirect = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryDirect, 1);

        if (iSupportDialup == TRUE && iSupportDirect == TRUE)
        {
            pArgs->SetBothConnTypeSupported(TRUE);

            if (pArgs->piniBoth->GPPI(c_pszCmSection, c_pszCmEntryConnectionType, 0))
            {
                pArgs->SetDirectConnect(TRUE);
            }
            else
            {
                pArgs->SetDirectConnect(FALSE);
            }
        }
        else
        {
            pArgs->SetBothConnTypeSupported(FALSE);
            pArgs->SetDirectConnect(iSupportDirect == TRUE);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  _ArgsStruct::GetTypeOfConnection
//
// Synopsis:  Figures out what type of connection we are doing (dialup, 
//            double dial, or direct) and returns one of the connection define
//            values listed in icm.h.
//
// Arguments: None
//
// Returns:   DWORD  - value indicating the type of connection, see icm.h for values
//
// History:   quintinb  Created                 04/20/00
//
//+----------------------------------------------------------------------------
DWORD _ArgsStruct::GetTypeOfConnection()
{
    DWORD dwType = 0;

    if (this->IsDirectConnect())
    {
        return DIRECT_CONNECTION;
    }
    else
    {
        //        
        // Its not direct, so see if the primary phone 
        // number is for a tunneling scenario.
        //

        if (this->fUseTunneling) // Ambiguous during Pre-Init action.
        {
            return DOUBLE_DIAL_CONNECTION;
        }
        else
        {
            return DIAL_UP_CONNECTION;
        }
    }

}

//+----------------------------------------------------------------------------
//
// Function:  _ArgsStruct::GetProperty
//
// Synopsis:  get the cm property by name
//            This function is used by connect actions
//
// Arguments: const TCHAR* pszName       - name of the property
//            BOOL  *pbValidPropertyName - ptr to bool to indicate validity of property
//
// Returns:   LPTSTR  - Value of the property.  Caller should use CmFree 
//                      to free the memory
//
// History:   fengsun   Created Header          07/07/98
//            nickball  pbValidPropertyName     07/27/99
//
//+----------------------------------------------------------------------------
LPTSTR  _ArgsStruct::GetProperty(const TCHAR* pszName, BOOL *pbValidPropertyName)   
{
    *pbValidPropertyName = TRUE;

    //
    // This function could be called with in RasCustomHangup.
    // Some information of pArgs may bot be loaded
    //

    MYDBGASSERT(pszName);
    MYDBGASSERT(pszName[0]);

    if (pszName == NULL)
    {
        return NULL;
    }

    //
    // Type - Dial-up only, VPN only, double-dial
    //

    if (lstrcmpiU(pszName, TEXT("ConnectionType")) == 0)
    {
        LPTSTR pszValue = (LPTSTR)CmMalloc(64*sizeof(TCHAR));  // large enough to hold the error code
        MYDBGASSERT(pszValue);

        if (pszValue)
        {
            wsprintfU(pszValue, TEXT("%u"), this->GetTypeOfConnection());
        }

        return pszValue;
    }

    //
    //  UserPrefix
    //
    if (lstrcmpiU(pszName,TEXT("UserPrefix")) == 0)
    {
        LPTSTR pszUsernamePrefix = NULL;
        LPTSTR pszUsernameSuffix = NULL;

        //
        // Retrieve the suffix and prefix as they are a logical pair, 
        // but we only return the allocated PREFIX in this case.
        //

        CIni *piniService = GetAppropriateIniService(this, this->nDialIdx);

        GetPrefixSuffix(this, piniService, &pszUsernamePrefix, &pszUsernameSuffix);               
               
        CmFree(pszUsernameSuffix);
        delete piniService;

        return pszUsernamePrefix;
    }

    //
    // UserSuffix
    //
    if (lstrcmpiU(pszName,TEXT("UserSuffix")) == 0)     
    {
        LPTSTR pszUsernamePrefix = NULL;
        LPTSTR pszUsernameSuffix = NULL;

        //
        // Retrieve the suffix and prefix as they are a logical pair, 
        // but we only return the allocated SUFFIX in this case.
        //

        CIni *piniService = GetAppropriateIniService(this, this->nDialIdx);

        GetPrefixSuffix(this, piniService, &pszUsernamePrefix, &pszUsernameSuffix);               
               
        CmFree(pszUsernamePrefix);
        delete piniService;

        return pszUsernameSuffix;
    }

    //
    // UserName
    //
    if (lstrcmpiU(pszName,TEXT("UserName")) == 0)       
    {
        LPTSTR pszValue = NULL;

        //
        // We want to get the value by calling GetUserInfo so that we don't break 
        // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
        // value directly out of the Args Structure.
        //
        if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
        {
            GetUserInfo(this, UD_ID_USERNAME, (PVOID*)&pszValue);
        }
        else
        {
            pszValue = CmStrCpyAlloc(this->szUserName);
        }


        return pszValue;
    }

    //
    // InetUserName
    //
    if (lstrcmpiU(pszName,TEXT("InetUserName")) == 0)       
    {
        LPTSTR pszValue = NULL;

        //
        //  If we aren't doing a double dial, then the InetUserName doesn't make
        //  sense and thus should be zero.  Also if UseSameUserName is
        //  set then we want to return the UserName and skip trying to
        //  find the InetUserName
        //
        if (this->fUseTunneling && (FALSE == this->IsDirectConnect()))
        {
            if (this->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseSameUserName))
            {
                //
                // We want to get the value by calling GetUserInfo so that we don't break 
                // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
                // value directly out of the Args Structure.
                //
                if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
                {
                    GetUserInfo(this, UD_ID_USERNAME, (PVOID*)&pszValue);
                }
                else
                {
                    pszValue = CmStrCpyAlloc(this->szUserName);
                }
            }
            else
            {
                //
                // We want to get the value by calling GetUserInfo so that we don't break 
                // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
                // value directly out of the Args Structure.
                //
                if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
                {
                    GetUserInfo(this, UD_ID_INET_USERNAME, (PVOID*)&pszValue);
                }
                else
                {
                    pszValue = CmStrCpyAlloc(this->szInetUserName);
                }
            }
        }
        
        return pszValue;
    }

    //
    // Domain
    //
    if (lstrcmpiU(pszName,TEXT("Domain")) == 0)       
    {
        LPTSTR pszValue = NULL;

        //
        // We want to get the value by calling GetUserInfo so that we don't break 
        // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
        // value directly out of the Args Structure.
        //
        if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
        {
            GetUserInfo(this, UD_ID_DOMAIN, (PVOID*)&pszValue);
        }
        else
        {
            pszValue = CmStrCpyAlloc(this->szDomain);
        }

        return pszValue;
    }

    //
    // Profile
    //
    if (lstrcmpiU(pszName,TEXT("Profile")) == 0)      
    {
        return CmStrCpyAlloc(this->piniProfile->GetFile());
    }

    //
    // ServiceDir
    //
    if (lstrcmpiU(pszName, TEXT("ServiceDir")) == 0)      
    {
        LPTSTR pszServiceDir = NULL;

        // start with the file name of the Service
        LPCTSTR pszService = this->piniService->GetFile();
        if (pszService)
        {
            // find out where the filename.cmp portion starts
            LPTSTR pszTmp = CmStrrchr(pszService, TEXT('\\'));

            size_t nSize = pszTmp - pszService + 1;

            // alloc enough space for the directory name (and terminating NULL)
            pszServiceDir = (LPTSTR)CmMalloc( nSize * sizeof(TCHAR));
            if (pszServiceDir)
            {
                lstrcpynU(pszServiceDir, pszService, nSize);
                //
                //  The Win32 lstrcpyN function enforces a terminating NULL,
                //  so the above works without requiring any further code.
                //
            }
        }

        return pszServiceDir;
    }

    //
    // ServiceName
    //
    if (lstrcmpiU(pszName,c_pszCmEntryServiceName) == 0)        
    {
        MYDBGASSERT(this->szServiceName[0]);
        return CmStrCpyAlloc(this->szServiceName);
    }

    //
    // DialRasPhoneBook
    //

    if (lstrcmpiU(pszName, TEXT("DialRasPhoneBook")) == 0)     
    {
        //
        // We want to return NULL if this was a direct connection
        // and we want to return the hidden ras phonebook path if
        // this was a double dial connection (tunnel over a PPP
        // connection that we dialed).
        //
        if (this->IsDirectConnect())
        {
            return NULL;
        }
        else
        {
            if (this->fUseTunneling)
            {
                return CreateRasPrivatePbk(this);
            }
            else
            {
                return CmStrCpyAlloc(this->pszRasPbk);
            }
        }
    }

    //
    // DialRasEntry
    //
    if (lstrcmpiU(pszName, TEXT("DialRasEntry")) == 0)        
    {
        if (this->IsDirectConnect())
        {
            return NULL;
        }
        else
        {
            return GetRasConnectoidName(this, this->piniService, FALSE);
        }
    }

    //
    // TunnelRasPhoneBook
    //
    if (lstrcmpiU(pszName, TEXT("TunnelRasPhoneBook")) == 0) 
    {
        //
        //  If we are not tunneling then we want to make sure that we
        //  return NULL for the tunnel entry name and the tunnel
        //  phonebook
        //
    
        if (this->fUseTunneling)
        {
            CMTRACE1(TEXT("GetProperty - TunnelRasPhoneBook is %s"), this->pszRasPbk);
            return CmStrCpyAlloc(this->pszRasPbk);
        }
        else
        {
            CMTRACE(TEXT("GetProperty - TunnelRasPhoneBook returns NULL"));
            return NULL;
        }
    }

    //
    // TunnelRasEntry
    //
    if (lstrcmpiU(pszName, TEXT("TunnelRasEntry")) == 0)        
    {
        //
        //  If we are not tunneling then we want to make sure that we
        //  return NULL for the tunnel entry name and the tunnel
        //  phonebook
        //
        if (this->fUseTunneling)
        {
            return GetRasConnectoidName(this, this->piniService, TRUE);
        }
        else
        {
            return NULL;
        }
    }

    //
    // AutoRedial, TRUE or FALSE
    ///
    if (lstrcmpiU(pszName, TEXT("AutoRedial")) == 0)        
    {
        //
        // Return TRUE for the first try.
        //
        return CmStrCpyAlloc( this->nRedialCnt != this->nMaxRedials 
            ? TEXT("1") : TEXT("0"));
    }

    if (lstrcmpiU(pszName, TEXT("LastErrorSource")) == 0)        
    {
        return CmStrCpyAlloc(this->szLastErrorSrc);
    }

    //
    // PopName, as the city name in phone-book
    //
    if (lstrcmpiU(pszName, TEXT("PopName")) == 0)        
    {
        if (this->IsDirectConnect())
        {
            //
            // Ensure no POP description on DirectConnect #324951
            //

            return NULL;
        }
        else
        {
            //
            // the szDesc is in the format of "CityName (BaudMin - BaudMax bps)" 
            // We could save the CityNme when we load the phone number from phonebook
            // But we have to change cmpbk code then.
            //
    
            LPTSTR pszDesc = CmStrCpyAlloc(this->aDialInfo[nDialIdx].szDesc);

            //
            // The city name is followed by " ("
            //
            LPTSTR pszEnd = CmStrStr(pszDesc, TEXT(" ("));

            if (pszEnd == NULL)
            {
                CmFree(pszDesc);
                return NULL;
            }

            *pszEnd = TEXT('\0');

            return pszDesc;
        }
    }

    //
    //  The current favorite
    //
    if (lstrcmpiU(pszName, TEXT("CurrentFavorite")) == 0)
    {
        return CmStrCpyAlloc(this->pszCurrentAccessPoint);
    }

    //
    //  The current tunnel server address
    //
    if (lstrcmpiU(pszName, TEXT("TunnelServerAddress")) == 0)
    {
        if (this->fUseTunneling)
        {
            return this->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);
        }
        else
        {
            return NULL;
        }
    }

    //
    //  The canonical number if there is one and if not then the szPhonenumber field itself.
    //
    if (lstrcmpiU(pszName, TEXT("PhoneNumberDialed")) == 0)
    {
        if (this->IsDirectConnect())
        {
            return NULL;
        }
        else
        {
            if (this->aDialInfo[nDialIdx].szCanonical[0])
            {
                return CmStrCpyAlloc(this->aDialInfo[nDialIdx].szCanonical);
            }
            else
            {
                return CmStrCpyAlloc(this->aDialInfo[nDialIdx].szPhoneNumber);            
            }
        }
    }

    //
    // ErrorCode in decimal
    //
    if (lstrcmpiU(pszName, TEXT("ErrorCode")) == 0)       
    {
        LPTSTR pszValue = (LPTSTR)CmMalloc(64*sizeof(TCHAR));  // large enough to hold the error code
        MYDBGASSERT(pszValue);

        if (pszValue)
        {
            wsprintfU(pszValue, TEXT("%d"), this->dwExitCode);
        }

        return pszValue;
    }

    //
    //  The client's or server's IP address
    //
    if (lstrcmpiU(pszName, TEXT("ClientIPAddress")) == 0 || lstrcmpiU(pszName, TEXT("ServerIPAddress")) == 0)
    {
        RASPROJECTION   RasProj = RASP_PppIp;
        RASPPPIP        RasPPPIP;
        DWORD           dwBufSize = sizeof(RASPPPIP);
        DWORD           dwRet = ERROR_SUCCESS;
        HRASCONN        hrcRasConn = NULL;
        // Set a flag based on whether client or server was asked for
        BOOL            fClientIP = ((lstrcmpiU(pszName, TEXT("ClientIPAddress")) == 0) ? TRUE : FALSE);

        if (this->hrcTunnelConn)
        {
            // we have a tunnel handle => we're tunneling
            hrcRasConn = this->hrcTunnelConn;
        }
        else if (this->hrcRasConn)
        {
            // we have a ras handle => we're dialing
            hrcRasConn = this->hrcRasConn;
        }
        else
        {
            // no soup for you
            return NULL;
        }

        ZeroMemory(&RasPPPIP, dwBufSize);
        RasPPPIP.dwSize = dwBufSize;

        dwRet = this->rlsRasLink.pfnGetProjectionInfo(hrcRasConn, RasProj, (PVOID) &RasPPPIP, &dwBufSize);
        if (ERROR_SUCCESS == dwRet)
        {
            if (fClientIP)
            {
                return CmStrCpyAlloc(RasPPPIP.szIpAddress);
            }
            else
            {
                return CmStrCpyAlloc(RasPPPIP.szServerIpAddress);
            }
        }
        else
        {
            CMTRACE1(TEXT("GetProperty - RasGetProjectionInfo returns %d"), dwRet);
        }

        return NULL;
    }
    
    //
    //  Should the customaction interact with the user
    //
    if (lstrcmpiU(pszName, TEXT("Interactive")) == 0)
    {
        LPTSTR pszValue = (LPTSTR) CmMalloc(2 * sizeof(TCHAR)); // this is 0 or 1

        MYDBGASSERT(pszValue);
        if (pszValue)
        {
            wsprintfU(pszValue, TEXT("%u"), (this->dwFlags & FL_UNATTENDED) ? 0 : 1);
        }

        return pszValue;
    }

    CMTRACE1(TEXT("%%%s%% not a macro, may be environment variable"), pszName);
    *pbValidPropertyName = FALSE;

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  GetMainDlgTemplate
//
// Synopsis:  Encapsulates determining which template is to be used
//            for the main dialog.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   UINT - Dlg template ID.
//
// History:   nickball    Created     9/25/98
//            tomkel      01/30/2001  Added support for global credentials UI   
//                                    by using pArgs->fGlobalCredentialsSupported
//
//+----------------------------------------------------------------------------
UINT GetMainDlgTemplate(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return 0;
    }

    UINT uiNewMainDlgID = 0;
    DWORD dwNewTemplateMask = 0;
    UINT i = 0;

    //
    // Currently there are 24 dialogs used in this function. If you add more dialogs
    // make sure to increase the size of the array and the loop. The dialog templates
    // aren't in any particular order, since we loop through all of them
    // comparing the masks until we find the correct one.
    //
    DWORD rdwTemplateIDs[24][2] = { 
            {CMTM_FAVS | CMTM_U_P_D | CMTM_GCOPT,           IDD_MAIN_ALL_USERDATA_FAV_GCOPT},
            {CMTM_FAVS | CMTM_U_P_D,                        IDD_MAIN_ALL_USERDATA_FAV},
            {CMTM_FAVS | CMTM_UID,                          IDD_MAIN_UID_ONLY_FAV},
            {CMTM_FAVS | CMTM_PWD | CMTM_GCOPT,             IDD_MAIN_PWD_ONLY_FAV_GCOPT},
            {CMTM_FAVS | CMTM_PWD,                          IDD_MAIN_PWD_ONLY_FAV},
            {CMTM_FAVS | CMTM_DMN,                          IDD_MAIN_DMN_ONLY_FAV},
            {CMTM_FAVS | CMTM_UID_AND_PWD | CMTM_GCOPT,     IDD_MAIN_UID_AND_PWD_FAV_GCOPT},
            {CMTM_FAVS | CMTM_UID_AND_PWD,                  IDD_MAIN_UID_AND_PWD_FAV},
            {CMTM_FAVS | CMTM_UID_AND_DMN,                  IDD_MAIN_UID_AND_DMN_FAV},
            {CMTM_FAVS | CMTM_PWD_AND_DMN | CMTM_GCOPT,     IDD_MAIN_PWD_AND_DMN_FAV_GCOPT},
            {CMTM_FAVS | CMTM_PWD_AND_DMN,                  IDD_MAIN_PWD_AND_DMN_FAV},
            {CMTM_FAVS,                                     IDD_MAIN_NO_USERDATA_FAV},
            {CMTM_U_P_D | CMTM_GCOPT,                       IDD_MAIN_ALL_USERDATA_GCOPT},
            {CMTM_U_P_D,                                    IDD_MAIN_ALL_USERDATA},
            {CMTM_UID,                                      IDD_MAIN_UID_ONLY},
            {CMTM_PWD | CMTM_GCOPT,                         IDD_MAIN_PWD_ONLY_GCOPT},
            {CMTM_PWD,                                      IDD_MAIN_PWD_ONLY},
            {CMTM_DMN,                                      IDD_MAIN_DMN_ONLY},
            {CMTM_UID_AND_PWD | CMTM_GCOPT,                 IDD_MAIN_UID_AND_PWD_GCOPT},
            {CMTM_UID_AND_PWD,                              IDD_MAIN_UID_AND_PWD},
            {CMTM_UID_AND_DMN,                              IDD_MAIN_UID_AND_DMN},
            {CMTM_PWD_AND_DMN | CMTM_GCOPT,                 IDD_MAIN_PWD_AND_DMN_GCOPT},
            {CMTM_PWD_AND_DMN,                              IDD_MAIN_PWD_AND_DMN},
            {0,                                             IDD_MAIN_NO_USERDATA}};

    //
    // Set the mask according to the pArgs flags for each value.
    //
    if (!pArgs->fHideUserName)
    {
        dwNewTemplateMask |= CMTM_UID;
    }

    //
    // If the password edit is not displayed, there is no need to 
    // check for the global creds flag since there are no such dialogs
    //
    if (!pArgs->fHidePassword)
    {
        dwNewTemplateMask |= CMTM_PWD;

        // 
        // Since we show the password field, lets check if we should display 
        // the global creds option as well.
        // 
        if (pArgs->fGlobalCredentialsSupported)
        {
            dwNewTemplateMask |= CMTM_GCOPT;
        }
    }

    if (!pArgs->fHideDomain)
    {
        dwNewTemplateMask |= CMTM_DMN;
    }

    if (pArgs->fAccessPointsEnabled)
    {
        dwNewTemplateMask |= CMTM_FAVS;
    }

    //
    // Now find the corresponding template id
    //
    for (i = 0; i < 24; i++)
    {
        if (rdwTemplateIDs[i][0] == dwNewTemplateMask)
        {
            uiNewMainDlgID = rdwTemplateIDs[i][1];
            break;
        }
    }

    if (0 == uiNewMainDlgID)
    {
        MYDBGASSERT(FALSE);
        uiNewMainDlgID = IDD_MAIN_NO_USERDATA;
    }

    return uiNewMainDlgID;
}

//+----------------------------------------------------------------------------
//
// Function:  Connect
//
// Synopsis:  The main dialing (connect path) replaces the winmain from the 
//            original CMMGR32.EXE
//
// Arguments: HWND hwndParent - window handle of parent
//            LPCTSTR lpszEntry - Ptr to the name of the connection entry
//            LPTSTR lpszPhonebook - Ptr to the name of the phonebook
//            LPRASDIALDLG lpRasDialDlg - RasDialDlg data - ignored
//            LPRASENTRYDLG lpRasEntryDlg - RasEntryDlg data - ignored
//            LPCMDIALINFO lpCmInfo - CM specific dial info such as flags
//            DWORD dwFlags - Flags for AllUser, SingleUser, EAP, etc.
//            PVOID pvLogonBlob - Ptr to blob passed by RAS at WinLogon on W2K
//
// Returns:   Nothing
//
// Note:      RasDialDlg->hwndOwner and RasDialDlg->hwndOwner are honored, but they
//            are currently passed in via the hwndParent parameter as appropriate by
//            the caller, CmCustomDialDlg.
//
// History:   nickball    Created                                   02/06/98
//            nickball    hwndParent                                11/10/98
//            nickball    Passed down dwFlags instead of BOOL       07/13/99
//
//+----------------------------------------------------------------------------
HRESULT Connect(HWND hwndParent,
    LPCTSTR pszEntry,
    LPTSTR lpszPhonebook,
    LPRASDIALDLG, // lpRasDialDlg,
    LPRASENTRYDLG, // lpRasEntryDlg,
    LPCMDIALINFO lpCmInfo,
    DWORD dwFlags,
    PVOID pvLogonBlob)
{
    MYDBGASSERT(pszEntry);
    MYDBGASSERT(pszEntry[0]);
    MYDBGASSERT(lpCmInfo);

    CMTRACE(TEXT("Connect()"));

    if (NULL == pszEntry || NULL == lpCmInfo)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;   
    }

    HRESULT hrRes = S_OK;
    BOOL fLoggingInitialized = FALSE;  

    //
    // Allocate our args struct from the heap. Not on our stack.
    //
    
    ArgsStruct* pArgs = (ArgsStruct*) CmMalloc(sizeof(ArgsStruct));

    if (NULL == pArgs)
    {
        hrRes = HRESULT_FROM_WIN32(ERROR_ALLOCATING_MEMORY);
        goto done;
    }

    //
    // Clear and init global args struct
    //
    
    hrRes = InitArgsForConnect(pArgs, lpszPhonebook, lpCmInfo, (dwFlags & RCD_AllUsers));

    if (FAILED(hrRes))
    {
        goto done;
    }

    //
    // Setup the connection table
    //

    hrRes = CreateConnTable(pArgs);

    if (FAILED(hrRes))
    {
        goto done;
    }
    

    //
    // Initialize the profile
    //

    hrRes = InitProfile(pArgs, pszEntry);

    if (FAILED(hrRes))
    {
        goto done;
    }

    //
    // Make sure we have a .cmp name and that the specified .cms exists
    //

    if (FALSE == CheckProfileIntegrity(pArgs))
    {
        // CheckProfileIntegrity() will set pArgs->dwExitCode accordingly
        goto done;
    }

    //
    // Initialize logging
    //
    
    (VOID) InitLogging(pArgs, pszEntry, TRUE); // TRUE => write a banner;
    // ignore return value

    fLoggingInitialized = TRUE;

    //
    //  If the SafeNet client is available then let's enable logging.  We won't
    //  know for sure if we are using it till much later and I don't want to miss
    //  it discovering other adapters (dialup adapters coming up for instance).  I
    //  would rather log too much than not enough.
    //
    if ((OS_W9X || OS_NT4) && IsSafeNetClientAvailable())
    {
        SafeNetLinkageStruct SnLinkage = {0};
        BOOL bUseLogFile = pArgs->Log.IsEnabled();

        if (LinkToSafeNet(&SnLinkage))
        {
            if (SnLinkage.pfnSnPolicySet(SN_USELOGFILE, (VOID*)&bUseLogFile))
            {
                MYVERIFY(0 != SnLinkage.pfnSnPolicyReload());
            }
            else
            {
                DWORD dwError = GetLastError();
                CMTRACE1(TEXT("Connect -- unable to toggle the SafeNet log file.  SnPolicySet failed with GLE %d"), dwError);
            }

            UnLinkFromSafeNet(&SnLinkage);
        }
    }


    //
    // Pick up any pre-existing credentials (eg. WinLogon, Reconnect)
    //

    hrRes = InitCredentials(pArgs, lpCmInfo, dwFlags, pvLogonBlob);
    if (S_OK != hrRes)
    {
        goto done;
    }

    //
    // Now that credential support and existance flags are initialized we need
    // to initialize the read/write flags in order to support global user
    // info. This can only be called only after InitCredentials
    //
    SetIniObjectReadWriteFlags(pArgs);

    //
    // Calling InitConnect depends on having the Ini objects read/write flags initialized correctly  
    // thus this calls needs to happen after SetIniObjectReadWriteFlags. This is important in case
    // of ICS where it needs to be able to read data correctly from the ICSData reg key or default to
    // the .cms/.cmp files.
    //
    if (!InitConnect(pArgs))
    {
        goto done;
    }

    //
    // Register Classes
    // 

    RegisterBitmapClass(g_hInst);
    RegisterWindowClass(g_hInst);

    //
    // Get the helpfile path
    //

    LoadHelpFileInfo(pArgs);

    //
    // If we are in FL_PROPERTIES  mode, just get the settings from the 
    // profile. Otherwise go ahead and launch the MainDlgProc
    //
    
    if (pArgs->dwFlags & FL_PROPERTIES) 
    {
        if (*pArgs->piniProfile->GetFile() && SetupInternalInfo(pArgs, NULL)) 
        {
            OnMainProperties(hwndParent, pArgs);
        }
    } 
    else 
    {
        //
        // Need to call OleInitialize()? See if we need FutureSplash.  We don't display
        // animations at WinLogon because of the security implications.
        //
    
        if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryAnimatedLogo) && !IsLogonAsSystem())
        {
            if (!pArgs->olsOle32Link.hInstOle32)
            {    
                if (LinkToOle32(&pArgs->olsOle32Link, "OLE32"))
                {
                    if (pArgs->olsOle32Link.pfnOleInitialize(NULL) != S_OK)
                    {
                        //
                        // Note: it's not fatal to fail OleInitialize().  
                        // We will just load the normal bitmap then.
                        //
                        CMTRACE(TEXT("Connect() OleInitialize failed"));
                    }
                }
                else
                {
                    CMTRACE(TEXT("Connect() LinkToOle32 failed"));
                }
            }
        }       
        
        //
        // Launch main dialog 
        //

        INT_PTR iMainDlgReturn = 0;
        
        do
        {
            iMainDlgReturn = DialogBoxParamU(g_hInst, 
                                             MAKEINTRESOURCE(GetMainDlgTemplate(pArgs)), 
                                             hwndParent,
                                             MainDlgProc, 
                                             (LPARAM) pArgs);

            if (0 != pArgs->dwSCardErr)
            {
                //
                //  User entered a bad smartcard PIN.  We exit immediately to avoid
                //  locking up the smartcard with multiple incorrect retries.
                //
                MYDBGASSERT(BAD_SCARD_PIN(pArgs->dwSCardErr));
                hrRes = pArgs->dwSCardErr;
                goto done;
            }

        } while (ID_OK_RELAUNCH_MAIN_DLG == iMainDlgReturn);
    }

    
done:   

    //
    // Now that we are done, we should clear up all the messes :)
    //

    CleanupConnect(pArgs);

    //
    // Un-initialize logging
    //
 
    if (pArgs && fLoggingInitialized)
    {
        (VOID) pArgs->Log.DeInit();
        // ignore return value
    }

    //
    // Un-initialize Secure password classes
    //

    if (pArgs)
    {
        pArgs->SecurePW.UnInit();
        pArgs->SecureInetPW.UnInit();
    }

    //
    // If hRes isn't already set, use the exitcode value
    //

    if (S_OK == hrRes)
    {
        if (pArgs->dwExitCode > 0x7FFFFFFF)
        {
            hrRes = pArgs->dwExitCode;
        }
        else
        {
            hrRes = HRESULT_FROM_WIN32(pArgs->dwExitCode);
        }
    }
    
    //
    // Release pArgs, and exit completely
    //

    CmFree(pArgs);

    return hrRes;
}

//
// Define funtion prototypes for EAP functions
// that are implemented in the actual EAP dll.
//

typedef DWORD (WINAPI* pfnRasEapGetIdentity)(
    DWORD,
    HWND,
    DWORD,
    const WCHAR*,
    const WCHAR*,
    PBYTE,
    DWORD,
    PBYTE,
    DWORD,
    PBYTE*,
    DWORD*,
    WCHAR**
);

typedef DWORD (WINAPI* pfnRasEapFreeMemory)(
    PBYTE
);


//+----------------------------------------------------------------------------
//
// Function:  CmEapGetIdentity
//
// Synopsis:  Given EapUserData, looks up and calls RasEapGetIdentity for
//            the current EAP. Designed to handle the WinLogon case when we
//            want to use the EapUserData passed to us, rather then letting
//            RasGetEapUserIdentity look it up. Because it is only used in 
//            this case we pass RAS_EAP_FLAG_LOGON this enables other EAPs
//            to disregard the data if necessary. 
// 
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPTSTR lpszPhonebook - Ptr to the RAS phonebook
//            LPBYTE pbEapAuthData - Eap auth data blob 
//            DWORD dwEapAuthDataSize - size of the Eap auth data blob 
//            DWORD dwCustomAuthKey - The EAP identifier
//            LPRASEAPUSERIDENTITY* ppRasEapUserIdentity - Identity data
//
// Returns:   Error Code
//
// History:   nickball    Created                   07/16/99
//            nickball    ppRasEapUserIdentity      07/30/99
//
//+----------------------------------------------------------------------------
static DWORD CmEapGetIdentity(ArgsStruct *pArgs, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize,
    DWORD dwCustomAuthKey,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity)
{
    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(pArgs);
    MYDBGASSERT(ppRasEapUserIdentity);
    MYDBGASSERT(pArgs->lpEapLogonInfo);
    
    if (NULL == pArgs || NULL == pArgs->lpEapLogonInfo || NULL == ppRasEapUserIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }
  
    DWORD dwErr         = ERROR_SUCCESS;
    DWORD dwTmp         = 0;
    DWORD dwSize        = 0;
    DWORD cbDataOut     = 0;
    LPBYTE pbDataOut    = NULL;
    WCHAR* pwszIdentity = NULL;
    HKEY hKeyEap        = NULL;
    HINSTANCE hInst     = NULL;
    LPWSTR pszwPath     = NULL;

    pfnRasEapFreeMemory pfnEapFreeMemory = NULL;
    pfnRasEapGetIdentity pfnEapGetIdentity = NULL;

    //
    // First we have to locate the Identity DLL for our EAP. Step one is to
    // build the reg key name using the base path and EAP number.
    // 

    WCHAR szwTmp[MAX_PATH];
    wsprintfU(szwTmp, TEXT("%s\\%u"), c_pszRasEapRegistryLocation, dwCustomAuthKey);
    
    //
    // Now we can open the EAP key
    // 

    dwErr = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                          szwTmp,
                          0,
                          KEY_QUERY_VALUE ,
                          &hKeyEap);
    
    CMTRACE2(TEXT("CmEapGetIdentity - Opening %s returns %u"), szwTmp, dwErr);
    
    if (ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // See if the EAP supports RasEapGetIdentity
    //

    dwSize = sizeof(dwSize);

    dwErr = RegQueryValueExU(hKeyEap,
                             c_pszInvokeUsernameDialog,
                             NULL,
                             NULL,
                             (BYTE*)&dwTmp,
                             &dwSize);

    CMTRACE2(TEXT("CmEapGetIdentity - Opening %s returns %u"), c_pszInvokeUsernameDialog, dwErr);

    if ((dwErr) || (0 != dwTmp))
    {
        dwErr = ERROR_INVALID_FUNCTION_FOR_ENTRY;
        goto CmEapGetIdentityExit;
    }

    //
    // Next we need to retrieve the path of the EAP's identity DLL
    //
        
    dwSize = sizeof(szwTmp);

    dwErr = RegQueryValueExU(hKeyEap, c_pszRasEapValueNameIdentity, NULL, 
                             NULL, (LPBYTE) szwTmp, &dwSize);

    CMTRACE2(TEXT("CmEapGetIdentity - Opening %s returns %u"), c_pszRasEapValueNameIdentity, dwErr);

    if (ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    pszwPath = (LPWSTR) CmMalloc(MAX_PATH * sizeof(TCHAR));

    if (NULL == pszwPath)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto CmEapGetIdentityExit;   
    }
    
    ExpandEnvironmentStringsU(szwTmp, pszwPath, MAX_PATH);   

    //
    // Finally we have the path to the identity DLL. Now we can load the DLL 
    // and get the address of the RasEapGetIdentity and RasEapFreeMemory funcs.
    //

    CMTRACE1(TEXT("CmEapGetIdentity - Loading EAP Identity DLL %s"), pszwPath);

    hInst = LoadLibraryExU(pszwPath, NULL, 0);

    if (NULL == hInst)
    {
        dwErr = GetLastError();
        goto CmEapGetIdentityExit;
    }

    pfnEapFreeMemory = (pfnRasEapFreeMemory) GetProcAddress(hInst, "RasEapFreeMemory");
    pfnEapGetIdentity = (pfnRasEapGetIdentity) GetProcAddress(hInst, "RasEapGetIdentity"); 

    if (pfnEapGetIdentity && pfnEapFreeMemory)
    {
        dwErr = pfnEapGetIdentity(dwCustomAuthKey,
                                  pArgs->hwndMainDlg,
                                  RAS_EAP_FLAG_LOGON | RAS_EAP_FLAG_PREVIEW,
                                  pszRasPbk,
                                  pArgs->pRasDialParams->szEntryName,
                                  pbEapAuthData,
                                  dwEapAuthDataSize,
                                  (LPBYTE) pArgs->lpEapLogonInfo,
                                  pArgs->lpEapLogonInfo->dwSize,
                                  &pbDataOut,
                                  &cbDataOut,
                                  &pwszIdentity);
        
        CMTRACE3(TEXT("CmEapGetIdentity - RasEapGetIdentity returns %u, cbDataOut is %u, pwszIdentity is %s"), dwErr, cbDataOut, pwszIdentity);

        if (ERROR_SUCCESS == dwErr)
        {
            //
            // If data was returned, use it. Otherwise, use the
            // blob that was given to us by RAS at WinLogon.
            //

            if (cbDataOut)
            {
                dwSize =  cbDataOut;
            }
            else
            {
                CMTRACE(TEXT("CmEapGetIdentity - there was no pbDataOut from the EAP, using lpEapLogonInfo"));
                
                CMTRACE1(TEXT("CmEapGetIdentity - pArgs->lpEapLogonInfo->dwSize is %u"), pArgs->lpEapLogonInfo->dwSize);
                CMTRACE1(TEXT("CmEapGetIdentity - dwLogonInfoSize is %u"), pArgs->lpEapLogonInfo->dwLogonInfoSize);
                CMTRACE1(TEXT("CmEapGetIdentity - dwOffsetLogonInfo is %u"), pArgs->lpEapLogonInfo->dwOffsetLogonInfo);
                CMTRACE1(TEXT("CmEapGetIdentity - dwPINInfoSize is %u"), pArgs->lpEapLogonInfo->dwPINInfoSize);
                CMTRACE1(TEXT("CmEapGetIdentity - dwOffsetPINInfo is %u"), pArgs->lpEapLogonInfo->dwOffsetPINInfo);

                dwSize = pArgs->lpEapLogonInfo->dwSize;
                pbDataOut = (LPBYTE) pArgs->lpEapLogonInfo; // Note: pbDataOut is not our memory
            }
           
            //
            // Allocate the structure.
            //

            *ppRasEapUserIdentity = (LPRASEAPUSERIDENTITY) CmMalloc((sizeof(RASEAPUSERIDENTITY) - 1) + dwSize);

            if (NULL == *ppRasEapUserIdentity)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto CmEapGetIdentityExit;
            }

            if (pbDataOut) // no crashy
            {
                CMTRACE1(TEXT("CmEapGetIdentity - filling *ppRasEapUserIdentity with pbDataOut of size %u"), dwSize);

                lstrcpyn((*ppRasEapUserIdentity)->szUserName, pwszIdentity, UNLEN);
                (*ppRasEapUserIdentity)->szUserName[UNLEN] = 0;

                (*ppRasEapUserIdentity)->dwSizeofEapInfo = dwSize;
            
                CopyMemory((*ppRasEapUserIdentity)->pbEapInfo, pbDataOut, dwSize);                              
            
                CMTRACE1(TEXT("CmEapGetIdentity - *ppRasEapUserIdentity filled with pbDataOut of size %u"), dwSize);
            }
            else
            {
                dwErr = ERROR_INVALID_DATA;
                MYDBGASSERT(FALSE);
                goto CmEapGetIdentityExit;
            }
        }   
    }
    else
    {
        dwErr = GetLastError();
    }

CmEapGetIdentityExit:

    //
    // Cleanup our temporary buffers
    //

    if (NULL != pfnEapFreeMemory)
    {
        //
        // If cbDataOut is 0 then pbDataOut points at 
        // EapLogonInfo, which is not ours to free.
        // 

        if (cbDataOut && (NULL != pbDataOut)) 
        {
            pfnEapFreeMemory(pbDataOut);
        }

        if (NULL != pwszIdentity)
        {
            pfnEapFreeMemory((BYTE*)pwszIdentity);
        }
    }

    if (NULL != hKeyEap)
    {
        RegCloseKey(hKeyEap);
    }

    if (hInst)
    {
        FreeLibrary(hInst);
    }

    CmFree(pszwPath);

    CMTRACE1(TEXT("CmEapGetIdentity - returns %u"), dwErr);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetEapUserId
//
// Synopsis:  Helper func to deal with the details of calling out to RAS for EAP
//            credentials.
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            HWND hwndDlg - Window handle of dialog to own any UI
//            LPTSTR lpszPhonebook - Ptr to the RAS phonebook
//            LPBYTE pbEapAuthData - Eap auth data blob 
//            DWORD dwEapAuthDataSize - Size of the Eap auth data blob.
//            DWORD dwCustomAuthKey - The EAP identifier
//            LPRASEAPUSERIDENTITY* ppRasEapUserIdentity - Ptr to RAS EAP identity
//            struct to be allocated on our behalf.                       
//
// Returns:   Error Code
//
// History:   nickball    Created                   05/22/99
//            nickball    ppRasEapUserIdentity      07/30/99
//
//+----------------------------------------------------------------------------
static DWORD GetEapUserId(ArgsStruct *pArgs, 
    HWND hwndDlg, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize, 
    DWORD dwCustomAuthKey,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity)
{
    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(pArgs);
    MYDBGASSERT(ppRasEapUserIdentity);
    MYDBGASSERT(0 == *ppRasEapUserIdentity); // should always be NULL

    DWORD dwRet = ERROR_SUCCESS;

    if (NULL == pArgs ||         
        NULL == pArgs->rlsRasLink.pfnGetEapUserIdentity ||
        NULL == ppRasEapUserIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppRasEapUserIdentity = 0;

    //
    // If we have data from WinLogon, then use our own version of 
    // GetEapIdentity. Under the covers, RasGetEapUserIdentity calls
    // GetEapUserData (which potentially prompts the user) and then 
    // GetEapIdentity. Because we already have the equivalent 
    // (from WinLogon) of the data retrieved by GetEapUserData, 
    // we can call RasGetEapIdentity directly. This enables us 
    // to prevent an unnecessary prompt for the identity info that 
    // the user already gave at WinLogon.
    //      

    if (pArgs->lpEapLogonInfo)
    {    
        dwRet = CmEapGetIdentity(pArgs, 
                                 pszRasPbk, 
                                 pbEapAuthData, 
                                 dwEapAuthDataSize, 
                                 dwCustomAuthKey, 
                                 ppRasEapUserIdentity);
    }
    else
    {
        DWORD dwEapIdentityFlags = 0;

        //
        // Note: In the case that we are called from WinLogon,
        // but without EAP data, but the connection is configured for EAP
        // we send the RAS_EAP_FLAG_LOGON flag down to the EAP so it knows
        // what to do.
        //
        if (IsLogonAsSystem() && (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType))
        {
            dwEapIdentityFlags |= RAS_EAP_FLAG_LOGON;
        }

        //
        // In case we don't want UI set the - RAS_EAP_FLAG_NON_INTERACTIVE
        // same as RASEAPF_NonInteractive
        //
        if (pArgs->dwFlags & FL_UNATTENDED)
        { 
            dwEapIdentityFlags |= RAS_EAP_FLAG_NON_INTERACTIVE;
        }
        else
        {
            //
            // Always prompt for EAP credentials. Otherwise when the PIN is saved
            // the user has no way of un-saving it because TLS will cache it and
            // won't display the prompt if it has everything it needs.
            //

            dwEapIdentityFlags = RAS_EAP_FLAG_PREVIEW;
        }

        //
        //  Our smartcard PIN retry story:  If called from winlogon with an EAP blob,
        //  we never retry because we have no way to sending the corrected PIN back
        //  to winlogon.  In other cases, we retry once only.
        //  Retrying oftener greatly increases the chance of locking the smartcard.
        //
        DWORD dwMaxTries = 3;       // essentially arbitrary number. (If a smartcard: most do lock you out after 3 tries.)
        DWORD dwCurrentTry = 0;

        do
        {
            dwRet = pArgs->rlsRasLink.pfnGetEapUserIdentity(
                        pszRasPbk,
                        pArgs->pRasDialParams->szEntryName,
                        dwEapIdentityFlags,  // See Note above
                        hwndDlg,  
                        ppRasEapUserIdentity);
        }
        while ((dwCurrentTry++ < dwMaxTries) && (ERROR_SUCCESS != dwRet) && (ERROR_CANCELLED != dwRet));

        //
        // We also clear the password and domain in this case because
        // they become irrelevant and we don't want to mix CAD credentials
        // with smartcard credentials. Specifically, we don't want a clash
        // between the UPN username that EAP usually produces and the 
        // standard username, domain provided with CAD at WinLogon.
        //
        // TODO: BUGBUG 739044 (not fixed - postponed to LH) 
        // In case of EAP-MD5 we shouldn't clear these fields
        //
        CmSecureZeroMemory(pArgs->pRasDialParams->szPassword, sizeof(pArgs->pRasDialParams->szPassword));
        CmSecureZeroMemory(pArgs->pRasDialParams->szDomain, sizeof(pArgs->pRasDialParams->szDomain));
    }

    switch (dwRet)
    {
        case ERROR_FILE_NOT_FOUND:
            //
            //  The EAP package couldn't be loaded or didn't exist.  In order to send back an error message
            //  to the user that's better than "File not found", we send ERROR_INVALID_DATA.  Our error processing
            //  code will translate this to IDMSG_UNSUPPORTED_SETTING.  Hopefully that gives the user enough to go on.
            //
            dwRet = ERROR_INVALID_DATA;
            break;

        //
        // If user id isn't required, succeed
        //

        case ERROR_INVALID_FUNCTION_FOR_ENTRY:
            dwRet = ERROR_SUCCESS;
            break;

        //
        // Retrieve the EAP credential data and store in dial params
        //

        case ERROR_SUCCESS:

            //
            // Copy Eap info to Dial Params and Dial Extensions for dialing
            //

            CMTRACE(TEXT("GetEapUserId() setting dial extension with *ppRasEapUserIdentity->pbEapInfo"));

            lstrcpy(pArgs->pRasDialParams->szUserName, (*ppRasEapUserIdentity)->szUserName);
          
            ((LPRASDIALEXTENSIONS_V500) pArgs->pRasDialExtensions)->RasEapInfo.dwSizeofEapInfo = 
                (*ppRasEapUserIdentity)->dwSizeofEapInfo;
        
            ((LPRASDIALEXTENSIONS_V500) pArgs->pRasDialExtensions)->RasEapInfo.pbEapInfo =
                (*ppRasEapUserIdentity)->pbEapInfo;

            break;

        default:
            break;
    }

    if (ERROR_SUCCESS == dwRet)
    {
        //
        // We have a user (identity) now, update internal and external records
        // so that this information can be reported out. If we're dialing a
        // tunnel, or its not a tunneling profile, store the name in the 
        // UserName cache, otherwise its the dial-up portion of double-dial
        // and we store the identity in the InetUserName cache. #388199
        //

        if ((!UseTunneling(pArgs, pArgs->nDialIdx)) || IsDialingTunnel(pArgs))
        {
            lstrcpy(pArgs->szUserName, pArgs->pRasDialParams->szUserName);
            SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pArgs->pRasDialParams->szUserName);
            SaveUserInfo(pArgs, UD_ID_DOMAIN, (PVOID)pArgs->pRasDialParams->szDomain);
        }
        else
        {
            lstrcpy(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName);
            SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szInetUserName);
        }   
    }    
    
    CMTRACE2(TEXT("GetEapUserId() returns %u (0x%x)"), dwRet, dwRet);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Func:    ShowAccessPointInfoFromReg
//
// Desc:    Get the access points from the registry and populate the combo box
//          passed as input to the function
//
// Args:    ArgsStruct *pArgs - Ptr to global args struct 
//          HWND hwndCombo - Handle to the combo box to puopulate
//
// Return:  BOOL - Success or failure
//
// Notes:   
//
// History: t-urama     07/28/2000  Created
//-----------------------------------------------------------------------------
BOOL ShowAccessPointInfoFromReg(ArgsStruct *pArgs, HWND hwndParent, UINT uiComboID)
{
    MYDBGASSERT(pArgs);

    if ((NULL == pArgs) || (NULL == hwndParent) || (NULL == pArgs->pszCurrentAccessPoint))
    {
        return FALSE;
    }
    
    LPTSTR pszKeyName = NULL;
    DWORD dwTypeTmp;
    DWORD dwSizeTmp = 1;
    HKEY    hKeyCm;
    DWORD   dwRes = 1;
    DWORD dwIndex = 0;
    PFILETIME pftLastWriteTime = NULL;


    LPTSTR pszRegPath = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
        
    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return FALSE;
    }

    CmStrCatAlloc(&pszRegPath, TEXT("\\"));
    CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);

    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return FALSE;
    }
    //
    // Open the sub key under HKCU
    //
    
    dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszRegPath,
                          0,
                          KEY_READ,
                          &hKeyCm);
    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {    
        HWND hwndCombo = GetDlgItem(hwndParent, uiComboID);
        if (hwndCombo)
        {
            SendDlgItemMessageU(hwndParent, uiComboID, CB_RESETCONTENT, 0, 0L);
            do
            {
                dwSizeTmp = 1;
                do
                {
                    CmFree(pszKeyName);
                    dwSizeTmp = dwSizeTmp + MAX_PATH;
                    MYDBGASSERT(dwSizeTmp < 320);
                    if (dwSizeTmp > 320)
                    {
                        RegCloseKey(hKeyCm);
                        goto ShowError;
                    }

                    pszKeyName = (LPTSTR) CmMalloc((dwSizeTmp + 1) * sizeof(TCHAR));
                
                    if (NULL == pszKeyName)
                    {
                        RegCloseKey(hKeyCm);
                        goto ShowError;
                        
                    }

                    dwRes = RegEnumKeyExU(hKeyCm, 
                                          dwIndex,
                                          pszKeyName,
                                          &dwSizeTmp,
                                          NULL, 
                                          NULL, 
                                          NULL, 
                                          pftLastWriteTime);     
                    
      
                } while (ERROR_MORE_DATA == dwRes);

                // now write the name of the sub key to the combo box
                if (ERROR_SUCCESS == dwRes )
                {
                    SendDlgItemMessageU(hwndParent, uiComboID, CB_ADDSTRING,
                                        0, (LPARAM)pszKeyName);
                }
                
                if (ERROR_SUCCESS != dwRes && ERROR_NO_MORE_ITEMS != dwRes)
                {
                    CMTRACE1(TEXT("ShowAccessPointInfoFromReg() failed, GLE=%u."), GetLastError());
                    RegCloseKey(hKeyCm);
                    goto ShowError;
                }
                dwIndex ++;
            } while(ERROR_NO_MORE_ITEMS != dwRes);
           
            DWORD dwIdx = (DWORD)SendDlgItemMessageU(hwndParent,
                                       uiComboID,
                                       CB_FINDSTRINGEXACT,
                                       0,
                                       (LPARAM)pArgs->pszCurrentAccessPoint);
      
            if (dwIdx != CB_ERR) 
            {
                SendDlgItemMessageU(hwndParent, uiComboID, CB_SETCURSEL, (WPARAM)dwIdx, 0L);
            }
            else
            {
                LPTSTR pszDefaultAccessPointName = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);

                CMASSERTMSG(pszDefaultAccessPointName, TEXT("ShowAccessPointInfoFromReg -- CmLoadString of IDS_DEFAULT_ACCESSPOINT failed"));

                if (pszDefaultAccessPointName)
                {
                    dwIdx = (DWORD)SendDlgItemMessageU(hwndParent,
                                                       uiComboID,
                                                       CB_FINDSTRINGEXACT,
                                                       0,
                                                       (LPARAM)pszDefaultAccessPointName);
                    if (dwIdx != CB_ERR) 
                    {
                        SendDlgItemMessageU(hwndParent, uiComboID, CB_SETCURSEL, (WPARAM)dwIdx, 0L);
                        ChangedAccessPoint(pArgs, hwndParent, uiComboID);             
                    }

                    CmFree(pszDefaultAccessPointName);
                }
            }
        }
        
        CmFree(pszKeyName);
        CmFree(pszRegPath);
        RegCloseKey(hKeyCm);
        return TRUE;
    }
   
ShowError:
    
    CmFree(pszRegPath);
    CmFree(pszKeyName);
    return FALSE;
   
}

//+----------------------------------------------------------------------------
//
// Func:    ChangedAccessPoint
//
// Desc:    Changes the values of access point relevant stuff in pArgs
//          if the value of the current access point changes
//
// Args:    ArgsStruct *pArgs - Ptr to global args struct 
//
// Return:  BOOL - True if the access point has changed
//
// Notes:   
//
// History: t-urama     07/28/2000  Created
//-----------------------------------------------------------------------------

BOOL ChangedAccessPoint(ArgsStruct *pArgs, HWND hwndDlg, UINT uiComboID)
{
    BOOL bReturn = FALSE;
    MYDBGASSERT(pArgs);
    MYDBGASSERT(hwndDlg);

    if ((NULL == pArgs) || (NULL == hwndDlg) || (NULL == pArgs->pszCurrentAccessPoint))
    {
        return FALSE;
    }

    HWND hwndCombo = GetDlgItem(hwndDlg, uiComboID);

    if (hwndCombo)
    {
        LPTSTR pszAccessPoint = NULL;
        LRESULT lRes = 0;
        LRESULT lResTextLen = 0;

        // 
        // Need to get the currently selected text from the combobox.
        // Previously we used GetWindowTextU(hwndCombo, szAccessPoint, MAX_PATH+1), but it
        // incorrectly returned the text. 
        // First get the selected index, find out the string length, allocate memory
        //

        lRes = SendMessageU(hwndCombo, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
        if (CB_ERR != lRes)
        {
            lResTextLen = SendMessageU(hwndCombo, CB_GETLBTEXTLEN, (WPARAM)lRes, (LPARAM)0);
            if (CB_ERR != lResTextLen)
            {
                pszAccessPoint = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lResTextLen+1));

                if (NULL != pszAccessPoint)
                {
                    //
                    // Retrieve the text.
                    //
                    lRes = SendMessageU(hwndCombo, CB_GETLBTEXT, (WPARAM)lRes, (LPARAM)pszAccessPoint);
                    if (CB_ERR != lRes)
                    {
                        if (0 != lstrcmpiU(pArgs->pszCurrentAccessPoint, pszAccessPoint))
                        {
                            CmFree(pArgs->pszCurrentAccessPoint);
                            pArgs->pszCurrentAccessPoint = CmStrCpyAlloc(pszAccessPoint);

                            if (pArgs->pszCurrentAccessPoint)
                            {
                                LPTSTR pszRegPath = FormRegPathFromAccessPoint(pArgs);

                                if (pszRegPath)
                                {
                                    pArgs->piniBoth->SetPrimaryRegPath(pszRegPath);
                                    pArgs->piniProfile->SetRegPath(pszRegPath);
                                    CmFree(pszRegPath);

                                    //
                                    // First we determine our connect type
                                    //
                                    GetConnectType(pArgs);

                                    //
                                    // Set fUseTunneling. If not obvious (eg. direct VPN) then 
                                    // base the initial value upon the primary phone number.
                                    //
                                    if (pArgs->IsDirectConnect())
                                    {
                                        pArgs->fUseTunneling = TRUE;
                                    }
                                    else
                                    {
                                        pArgs->fUseTunneling = UseTunneling(pArgs, 0);
                                    }

                                    //
                                    //  Make sure we re-munge the phone number we are about to load.
                                    //
                                    pArgs->bDialInfoLoaded = FALSE;

                                    //
                                    // get new values for redial count, idle timeout, and the tapi location
                                    //
                                    LoadProperties(pArgs);

                                    //
                                    // get new values for phone info
                                    //
                                    LoadPhoneInfoFromProfile(pArgs);
        
                                    PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName);

                                    CMTRACE1(TEXT("ChangedAccessPoint() - Changed Access point to %s"), pArgs->pszCurrentAccessPoint);

                                    bReturn = TRUE;
                                }
                                else
                                {
                                    CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- FormRegPathFromAccessPoint returned NULL"));
                                }
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- CmStrCpyAlloc returned NULL trying to copy the current access point."));
                            }
                        } // else, nothing to do if the favorites are the same
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- SendMessageU(hwndCombo, CB_GETLBTEXT,...) returned CB_ERR"));
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- Unable to allocate memory"));
                }
                CmFree(pszAccessPoint);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- SendMessageU(hwndCombo, CB_GETLBTEXTLEN,...) returned CB_ERR"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- SendMessageU(hwndCombo, CB_GETCURSEL,...) returned CB_ERR"));
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- Unable to get the combo HWND"));
    }

    return bReturn;
}

//----------------------------------------------------------------------------
//
//  Function:   FindEntryCredentialsForCM
// 
//  Synopsis:   The algorithm and most of the code is taken from RAS and modified
//              for use by CM.
//
//              This routine determines whether per-user or per-connection credentials exist or 
//              both. 
// 
//              The logic is a little complicated because RasGetCredentials had to 
//              support legacy usage of the API.
//
//              Here's how it works.  If only one set of credentials is stored for a 
//              connection, then RasGetCredentials will return that set regardless of 
//              whether the RASCM_DefaultCreds flag is set.  If two sets of credentials
//              are saved, then RasGetCredentials will return the per-user credentials
//              if the RASCM_DefaultCreds bit is set, and the per-connection credentials
//              otherwise.
//
//              Here is the algorithm for loading the credentials
//
//              1. Call RasGetCredentials with the RASCM_DefaultCreds bit cleared
//                  1a. If nothing is returned, no credentials are saved
//                  1b. If the RASCM_DefaultCreds bit is set on return, then only
//                      global credentials are saved.
//
//              2. Call RasGetCredentials with the RASCM_DefaultCreds bit set
//                  2a. If the RASCM_DefaultCreds bit is set on return, then 
//                      both global and per-connection credentials are saved.
//                  2b. Otherwise, only per-user credentials are saved.
//
//  Arguments:  pArgs           - pointer to the ArgStruct
//              pszPhoneBook    - path to the phone book. Could be NULL.
//              *pfUser         - out param set true if per user creds found
//              *pfGlobal       - out param set true if global creds found
//              
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
DWORD FindEntryCredentialsForCM(ArgsStruct *pArgs, LPTSTR pszPhoneBook,
                                BOOL *pfUser, BOOL *pfGlobal)
{
    RASCREDENTIALS rc1 = {0};
    RASCREDENTIALS rc2 = {0};
    BOOL fUseLogonDomain = FALSE;
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    LPTSTR pszConnectoid = NULL;

    CMTRACE(TEXT("FindEntryCredentialsForCM() - Begin"));

    if (NULL == pArgs || NULL == pfUser || NULL == pfGlobal)
    {
        MYDBGASSERT(pArgs && pfUser && pfGlobal);
        CMTRACE(TEXT("FindEntryCredentialsForCM() - Error! Invalid Parameter."));
        return dwErr;
    }

    //
    // Initialize the out params
    //
    *pfUser = FALSE;
    *pfGlobal = FALSE;
    
    //
    // After setting the OUT params, check if RAS dll have been loaded and if we can use the ras creds store
    //
    if (NULL == pArgs->rlsRasLink.pfnGetCredentials  || FALSE == pArgs->bUseRasCredStore)
    {
        CMTRACE(TEXT("FindEntryCredentialsForCM() - RAS Creds store not supported on this platform."));
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Set the size of the structures
    // 
    rc1.dwSize = sizeof(rc1);
    rc2.dwSize = sizeof(rc2);

    //
    // The third parameter is used only on Win9x (for tunneling) thus we set it to FALSE
    // since this function is called on Win2K+
    //
    pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
    if (pszConnectoid)
    {
        do 
        {
            //
            // Look up per-user cached username, password, and domain.
            // See comment '1.' in the function header
            //
            rc1.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
            dwErr = pArgs->rlsRasLink.pfnGetCredentials(pszPhoneBook, pszConnectoid, &rc1);
            
            CMTRACE2(TEXT("FindEntryCredentialsForCM() - Per-User RasGetCredentials=%d,m=%d"), dwErr, rc1.dwMask);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            if (0 == rc1.dwMask)
            {
                //
                // See 1a. in the function header comments
                //
                dwErr = ERROR_SUCCESS;
                break;
            }
            else if (rc1.dwMask & RASCM_DefaultCreds)
            {
                //
                // See 1b. in the function header comments
                //
                *pfGlobal = TRUE;

                //
                // Assumed password was not encoded by RasGetCredentials()
                //
                CmEncodePassword(rc1.szPassword);

                dwErr = ERROR_SUCCESS;
                break;
            }

            //
            // Look up global per-user cached username, password, domain.
            // See comment 2. in the function header
            //
            rc2.dwMask =  
                RASCM_UserName | RASCM_Password | RASCM_Domain |  RASCM_DefaultCreds; 

            dwErr = pArgs->rlsRasLink.pfnGetCredentials(pszPhoneBook, pszConnectoid, &rc2);
    
            CMTRACE2(TEXT("FindEntryCredentialsForCM() - Global RasGetCredentials=%d,m=%d"), dwErr, rc2.dwMask);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }

            if (rc2.dwMask & RASCM_DefaultCreds) 
            {
                //
                // See 2a. in the function header comments
                //
                *pfGlobal = TRUE;

                if (rc1.dwMask & RASCM_Password)
                {
                    *pfUser = TRUE;
                }

                //
                // Assumed password was not encoded by RasGetCredentials()
                //
                CmEncodePassword(rc1.szPassword);
                CmEncodePassword(rc2.szPassword);
            }
            else
            {
                //
                // See 2b. in the function header comments
                //
                if (rc1.dwMask & RASCM_Password)
                {
                    *pfUser = TRUE;
                }

                //
                // Assumed password was not encoded by RasGetCredentials()
                //
            
                CmEncodePassword(rc1.szPassword);
            }

        }while (FALSE);
    }

    //
    // Cleanup
    //

    CmSecureZeroMemory(rc1.szPassword, sizeof(rc1.szPassword));
    CmSecureZeroMemory(rc2.szPassword, sizeof(rc2.szPassword));

    CmFree(pszConnectoid);

    CMTRACE(TEXT("FindEntryCredentialsForCM() - End"));
    return dwErr;
}


//----------------------------------------------------------------------------
//
//  Function:   InitializeCredentialSupport
// 
//  Synopsis:   Helper function to initialize user and global credential 
//              support. Some of the flags are redundantly initialized 
//              (to  FALSE). That is done on purpose for clarity.
//
//  Arguments:  pArgs           - the ArgStruct *
//              
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
BOOL InitializeCredentialSupport(ArgsStruct *pArgs)
{
    BOOL fGlobalCreds = FALSE;
    BOOL fGlobalUserSettings = FALSE;

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return FALSE;
    }
    
    //
    // By default the the Internet Connection Sharing & Internet Connection 
    // Firewall (ICS) tab is disabled. 
    //
    pArgs->bShowHNetCfgAdvancedTab = FALSE;
    
    //
    // User profile read/write support when user is logged off or using dial-up
    // This flag determines if the user info needs to be also saved or loaded from
    // the .cmp file
    //
    pArgs->dwGlobalUserInfo = 0;

    //
    // Credential existance flags - here we cannot yet determine which creds exist
    // that is done in a later call to RefreshCredentialTypes
    // 
    pArgs->dwExistingCredentials = 0;

    //
    // Default for which credential store to use - set based on the existance flag so 
    // this will also get set appropriatelly after a call to RefreshCredentialTypes
    // 
    pArgs->dwCurrentCredentialType = CM_CREDS_USER;

    //
    // Deletion flags - used to mark a set of creds for deletion. Since the
    // user can Cancel out of a dialog we don't want to commit the changed
    // until we actually do a dial.
    //
    pArgs->dwDeleteCredentials = 0;

    //
    // Check if this is WindowsXP. We want display the Advanced tab for single-user and
    // all-user profiles
    //
    if (OS_NT51)
    {
        if (IsLogonAsSystem())
        {
            //
            // LocalSystem - winlogon or ICS (in both cases user is logged off)
            // WinLogon - creds are passed through MSGina
            // ICS - need to use glocal creds store
            // pArgs->dwWinLogonType was intialized in InitCredentials()
            // We don't want to read ICSData info if this is a single user profile
            //

            if (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType || FALSE == pArgs->fAllUser)
            {
                pArgs->fGlobalCredentialsSupported = FALSE;
                pArgs->dwCurrentCredentialType = CM_CREDS_USER;
                pArgs->dwGlobalUserInfo = 0;
            }
            else
            {
                pArgs->fGlobalCredentialsSupported = TRUE;
                pArgs->dwCurrentCredentialType = CM_CREDS_GLOBAL;
                pArgs->dwGlobalUserInfo |= CM_GLOBAL_USER_INFO_READ_ICS_DATA ;
            }
            CMTRACE(TEXT("InitializeCredentialSupport() - LocalSystem - Global creds OK."));
        }
        else 
        {
            //
            // User is logged on
            //
            
            //
            // By default we want to we want to display the tab. By negating 
            // this value we can then correctly save it in the Args structure. This 
            // needs to be initialized for everyone
            //            
            const TCHAR* const c_pszCmEntryHideICFICSAdvancedTab = TEXT("HideAdvancedTab");

            pArgs->bShowHNetCfgAdvancedTab = !(pArgs->piniService->GPPB(c_pszCmSection, 
                                                                        c_pszCmEntryHideICFICSAdvancedTab, 
                                                                        FALSE));

            //
            // If this an all-user profile then we want to see if the profile enables 
            // global user settings and displays global credential options.
            // These two features are disabled for single user profiles with the exception of 
            // showing the Advanced (ICS) tab
            //
            if (pArgs->fAllUser)
            {
                //
                // If ICS is enabled then we need to support global user settings.
                // Otherwise we read the setting from the file
                //
                if (pArgs->bShowHNetCfgAdvancedTab)
                {
                    fGlobalUserSettings = TRUE;
                }
                else
                {
                    //
                    // See if we support global user settings. By default is it off except if ICS is enabled
                    // 
                    const TCHAR* const c_pszCmEntryGlobalUserSettings = TEXT("GlobalUserSettings");
                    fGlobalUserSettings = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryGlobalUserSettings, FALSE);
                }

                // 
                // Read the info from the .cms file. By default global credentials are supported
                //
                const TCHAR* const c_pszCmEntryHideGlobalCredentials = TEXT("GlobalCredentials");
                fGlobalCreds = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideGlobalCredentials, TRUE);
            }

            //
            // Check to see if we are going to be hiding the Save Password option, if so then
            // we don't want to support global credentials
            //
            pArgs->fHideRememberPassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideRememberPwd);   

            if (fGlobalCreds && FALSE == pArgs->fHideRememberPassword)
            {
                //
                // Global creds are supported
                //
                
                //
                // Pick a default for creds type - it might change after calling RefreshCredentialTypes
                //
                pArgs->fGlobalCredentialsSupported = TRUE;
                pArgs->dwCurrentCredentialType = CM_CREDS_USER; 
                if (fGlobalUserSettings)
                {
                    pArgs->dwGlobalUserInfo |= CM_GLOBAL_USER_INFO_WRITE_ICS_DATA;
                }
                CMTRACE(TEXT("InitializeCredentialSupport() - User, global creds, show global UI."));
            }
            else
            {
                //
                // Global creds not supported
                //
                pArgs->fGlobalCredentialsSupported = FALSE;
                pArgs->dwCurrentCredentialType = CM_CREDS_USER;
                pArgs->dwGlobalUserInfo = 0;
                CMTRACE(TEXT("InitializeCredentialSupport() - User, no global creds, normal UI."));
            }
        }
    }
    else 
    {
        //
        // Single user or not WindowsXP
        //
        pArgs->fGlobalCredentialsSupported = FALSE;
        pArgs->dwCurrentCredentialType = CM_CREDS_USER;
        pArgs->dwGlobalUserInfo = 0;
        CMTRACE(TEXT("InitializeCredentialSupport() - Single User profile or not WindowsXP. Global creds not supported"));
    }
    
    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function:   RefreshCredentialTypes
// 
//  Synopsis:   This refreshes credential info. If fSetCredsDefault is TRUE 
//              then we also need to set the default type: 
//              pArgs->dwCurrentCredentialType.
//                  
//
//  Arguments:  pArgs           - the ArgStruct *
//              fSetCredsDefault- used to set the default creds type
//
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
BOOL RefreshCredentialTypes(ArgsStruct *pArgs, BOOL fSetCredsDefault)
{
    DWORD dwRC = ERROR_INVALID_PARAMETER;
    LPTSTR pszPrivatePbk = NULL;

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return FALSE;
    }

    //
    // This should be run on Win2K+ whether this is an all user profile or not
    // The call that actually determines which credentials exist makes sure we 
    // can use the ras cred store 
    //
    if (OS_NT5)
    {
        BOOL fUserCredsExist = FALSE;
        BOOL fGlobalCredsExist = FALSE;

        // 
        // See if the main creds exist. Inside the function we determine whether 
        // we can use the RAS cred store
        //
        dwRC = FindEntryCredentialsForCM(pArgs, 
                                         pArgs->pszRasPbk,
                                         &fUserCredsExist, 
                                         &fGlobalCredsExist);
        if (ERROR_SUCCESS == dwRC)
        {
            CMTRACE2(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned: (Main)     User=%d, Global=%d"), 
                     fUserCredsExist, fGlobalCredsExist);
        }
        else
        {
            CMTRACE(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned an error. (Main)"));
        }
    
        //
        // Set the existence flags
        //
        if (fUserCredsExist)
        {
            pArgs->dwExistingCredentials  |= CM_EXIST_CREDS_MAIN_USER;
        }
        else
        {
            pArgs->dwExistingCredentials  &= ~CM_EXIST_CREDS_MAIN_USER;
        }

        if (fGlobalCredsExist)
        {
            pArgs->dwExistingCredentials  |= CM_EXIST_CREDS_MAIN_GLOBAL;
        }
        else
        {
            pArgs->dwExistingCredentials  &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
        }

        fUserCredsExist = FALSE;
        fGlobalCredsExist = FALSE;

        pszPrivatePbk = CreateRasPrivatePbk(pArgs);
        if (pszPrivatePbk)
        {
            //
            // See if the Internet creds exist - by using the private phonebook
            // Inside the function we determine whether we can use the RAS cred store
            //
            dwRC = FindEntryCredentialsForCM(pArgs, 
                                             pszPrivatePbk,
                                             &fUserCredsExist,
                                             &fGlobalCredsExist); 
            if (ERROR_SUCCESS == dwRC)
            {
                CMTRACE2(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned: (Internet) User=%d, Global=%d"), 
                         fUserCredsExist, fGlobalCredsExist);
            }
            else
            {
                CMTRACE(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned an error. (Internet)"));
            }
        }

        //
        // Set the flags whether or not we successfully created a private pbk
        //
        if (fUserCredsExist)
        {
            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_USER;
        }
        else
        {
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
        }

        if (fGlobalCredsExist)
        {
            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_GLOBAL;
        }
        else
        {
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
        }

        //
        // If we don't support Global Creds then explicitly set 
        // the existance to FALSE. This can occur if the .cms flag
        // is set not to support global creds, but there are actually 
        // global creds on the system.
        //
        if (FALSE == pArgs->fGlobalCredentialsSupported)
        {
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
            CMTRACE(TEXT("RefreshCredentialTypes() - Global Credentials are disabled."));
        }
        
        if (fSetCredsDefault)
        {
            pArgs->dwCurrentCredentialType = GetCurrentCredentialType(pArgs);
            CMTRACE1(TEXT("RefreshCredentialTypes() - Set default Credentials = %d"), pArgs->dwCurrentCredentialType);
        }
    }

    CmFree(pszPrivatePbk);

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function:   GetCurrentCredentialType
// 
//  Synopsis:   Gets the default credentials based on which ones exist based 
//              on which flags are set. This function should be called only  
//              after RefreshCredentialTypes since that function actually
//              queries the RAS creds store. This one only looks up the cached
//              status of those creds and determines the default according to
//              what credentials exist.
//
//  Arguments:  pArgs           - the ArgStruct *
//              fSetCredsDefault- used to set the default creds type
//
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
DWORD GetCurrentCredentialType(ArgsStruct *pArgs)
{
    DWORD dwReturn = CM_CREDS_USER;
    
    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return dwReturn;
    }

    //
    // If Global creds aren't supported as in WinLogon case or single-user 
    // profiles or anything below WinXP, the default is User Creds Store
    //
    if (FALSE == pArgs->fGlobalCredentialsSupported)
    {
        return dwReturn;
    }

    //
    // Normal Rules when a user is logged on
    //
    if (CM_LOGON_TYPE_USER == pArgs->dwWinLogonType)
    {
        if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER)
        {
            //
            // Doesn't matter if main global creds exist since main user credentials 
            // have precendence if both exist
            //
            dwReturn = CM_CREDS_USER;
        }
        else if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_GLOBAL)
        {
            dwReturn = CM_CREDS_GLOBAL;
        }
        else 
        {
            // 
            // If none of them exist then we want to default to user creds
            //
            dwReturn = CM_CREDS_USER;
        }
    }
    else
    {
        //
        // In any other case dafult to global creds - (ICS scenario)
        // 
        dwReturn = CM_CREDS_GLOBAL;
    }

    return dwReturn;
}

//----------------------------------------------------------------------------
//
//  Function:   DeleteSavedCredentials
// 
//  Synopsis:   Helper function to delete credentials from the RAS store. 
//
//  Arguments:  pArgs           - the ArgStruct *
//              dwCredsType     - Normal or Internet credentials
//              fDeleteGlobal   - specifies whether to delete global credentials.
//                                If TRUE we delete user, domain name, 
//                                password as well
//              fDeleteIdentity - specifies whether to delete the user and 
//                                domain names in addition to the password
//              
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
BOOL DeleteSavedCredentials(ArgsStruct *pArgs, DWORD dwCredsType, BOOL fDeleteGlobal, BOOL fDeleteIdentity)
{
    RASCREDENTIALS rc;
    BOOL fReturn = FALSE;
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    LPTSTR pszConnectoid = NULL;

    CMTRACE2(TEXT("DeleteSavedCredentials() - Begin: %d %d"), fDeleteGlobal, fDeleteIdentity );

    if (NULL == pArgs)
    {   
        MYDBGASSERT(pArgs);
        return fReturn;
    }

    //
    // Check if globals should be deleted in case globals are not supported.
    // This can be in case of global creds are disabled on WinXP or this is
    // Win2K or the platform < Win2K where RASSetCredentials isn't even supported.
    // Thus we still should return TRUE
    //
    if ((fDeleteGlobal && FALSE == pArgs->fGlobalCredentialsSupported) || 
        (NULL == pArgs->rlsRasLink.pfnSetCredentials) || 
        (FALSE == pArgs->bUseRasCredStore))
    {
        CMTRACE(TEXT("DeleteSavedCredentials() - Global Creds not supported or do not have ras store on this platform."));
        return TRUE;
    }

    //
    // We don't support deleting globals on Win2K (that is caught by the above if since Win2K
    // will not have global credentials supported. Otherwise on Win2K we can delete the main 
    // user creds. On WinXP anything is fine.
    //
    if (OS_NT5)
    {
        ZeroMemory(&rc, sizeof(rc));
        rc.dwSize = sizeof(RASCREDENTIALS);
        rc.dwMask = RASCM_Password;

        if (fDeleteIdentity)
        {
            rc.dwMask |= (RASCM_UserName | RASCM_Domain);
        }

        if (fDeleteGlobal && pArgs->fGlobalCredentialsSupported)
        {
            rc.dwMask |= RASCM_UserName | RASCM_Domain | RASCM_DefaultCreds; 
        }

        //
        // The third parameter is used only on Win9x (for tunneling) thus we set it to FALSE
        // since this function is called on Win2K+
        //
        pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
        if (pszConnectoid)
        {
            if (CM_CREDS_TYPE_INET == dwCredsType)
            {
                LPTSTR pszPrivatePbk = CreateRasPrivatePbk(pArgs);
                if (pszPrivatePbk)
                {
                    dwErr = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePbk, 
                                                                pszConnectoid,
                                                                &rc,
                                                                TRUE );
                    CmFree(pszPrivatePbk);
                }
            }
            else
            {
                dwErr = pArgs->rlsRasLink.pfnSetCredentials(pArgs->pszRasPbk, 
                                                            pszConnectoid,
                                                            &rc,
                                                            TRUE );
            }
            if (ERROR_SUCCESS == dwErr)
            {
                fReturn = TRUE;
            }
        }

        CMTRACE1(TEXT("DeleteSavedCredentials() - End: RasSetCredentials=%d"), dwErr );
    }
    else
    {
        CMTRACE(TEXT("DeleteSavedCredentials() - Platform is less than Win2K"));
    }

    CmFree(pszConnectoid);

    return fReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetCredentialUIOptionBasedOnDefaultCreds 
//
//  Synopsis:   Selects (checks) the appropriate UI option for saving credentials
//              based on the current credential store default.
//
//  Arguments:  pArgs           - ptr to ArgsStruct
//              hwndDlg         - handle to the dialog window
//
//  Returns:    NONE
//
//  History:    02/05/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SetCredentialUIOptionBasedOnDefaultCreds(ArgsStruct *pArgs, HWND hwndDlg)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }
        
    //
    // fGlobalCredentialsSupported controls which dialog templates get loaded and
    // if the flag is FALSE then the dialog template doesn't have these controls 
    // thus there is no reason to set them.
    //

    if (pArgs->fGlobalCredentialsSupported) 
    {
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_UNCHECKED);
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_CHECKED);
        }
        else
        {
            //
            // CM_CREDS_USER
            //
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_CHECKED);
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_UNCHECKED);
        }
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   RefreshCredentialInfo 
//
//  Synopsis:   This is a slimmed down version of LoadProperties. It only
//              loads user info from cmp/cms, registry, password
//              cache, etc, into its internal variables.  
//              
//
//  Arguments:  pArgs           - ptr to ArgsStruct
//              dwCredsType     - type of credentials to refresh
//
//  Returns:    NONE
//
//  History:    02/05/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID RefreshCredentialInfo(ArgsStruct *pArgs, DWORD dwCredsType)
{
    LPTSTR  pszTmp = NULL;
    LPTSTR  pszUserName = NULL;
    UINT    nTmp;

    CMTRACE(TEXT("RefreshCredentialInfo() - Begin"));

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return;
    }

    if (IsTunnelEnabled(pArgs)) 
    { 
        if (CM_CREDS_TYPE_BOTH == dwCredsType || CM_CREDS_TYPE_INET == dwCredsType)
        {
            //
            // read in inet username
            // Special case where the same user name isn't being used, and internet globals don't exist
            // Then we have to read the user name from the user creds store in order to pre-populate
            //
            DWORD dwRememberedCredType = pArgs->dwCurrentCredentialType;
            pszUserName = NULL;

            if ((FALSE == pArgs->fUseSameUserName) &&
                (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType) && 
                (FALSE == (BOOL)(CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)))
            {
                pArgs->dwCurrentCredentialType = CM_CREDS_USER;
            }

            GetUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszUserName);

            //
            // Restore credential store
            //
            pArgs->dwCurrentCredentialType = dwRememberedCredType;

            if (pszUserName)
            {
                //
                // check username length
                //
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
                if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
                {
                    CmFree(pszUserName);
                    pArgs->szInetUserName[0] = TEXT('\0');
                    SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szInetUserName);
                }
                else
                {
                    lstrcpyU(pArgs->szInetUserName, pszUserName);
                    CmFree(pszUserName);
                }
            }
            else
            {
                *pArgs->szInetUserName = TEXT('\0');
            }
        
            //
            // Read in inet password unless we are reconnecting in which case, we
            // already have the correct password, and we want to use it and dial
            // automatically. 
            //

            if (!(pArgs->dwFlags & FL_RECONNECT))
            {
                LPTSTR pszPassword = NULL;
                GetUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszPassword);
                if (!pszPassword)
                {
                    (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));
                }
                else 
                {
                    nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
                    if ((UINT)lstrlenU(pszPassword) > __min(PWLEN, nTmp))
                    {
                        CmFree(pszPassword);
                        pszPassword = CmStrCpyAlloc(TEXT(""));
                    }
    
                    (VOID)pArgs->SecureInetPW.SetPassword(pszPassword);

                    CmWipePassword(pszPassword);
                    CmFree(pszPassword);
                }
            }
        }
    }

    if (CM_CREDS_TYPE_BOTH == dwCredsType || CM_CREDS_TYPE_MAIN == dwCredsType)
    {
        //
        // The presence of either lpRasNoUser or lpEapLogonInfo indicates
        // that we retrieved credentials via WinLogon. We ignore cached 
        // creds in this situation.   
        //
    
        if ((!pArgs->lpRasNoUser) && (!pArgs->lpEapLogonInfo))
        {
            //
            // get username, domain, etc. from CMS file
            //

            GetUserInfo(pArgs, UD_ID_USERNAME, (PVOID*)&pszUserName);
            if (pszUserName)
            {
                //
                // check username length
                //
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
                if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
                {
                    CmFree(pszUserName);
                    pszUserName = CmStrCpyAlloc(TEXT(""));
                    SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pszUserName);
                }
                lstrcpyU(pArgs->szUserName, pszUserName);
                CmFree(pszUserName);
            }
            else
            {
                *pArgs->szUserName = TEXT('\0');
            }

            //
            // Read in the standard password unless we are reconnecting in which case 
            // we already have the correct password, and we want to use it and dial
            // automatically. 
            //

            if (!(pArgs->dwFlags & FL_RECONNECT))
            {
                pszTmp = NULL;
                GetUserInfo(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp);
                if (pszTmp) 
                {           
                    //
                    // max length for user password
                    //
    
                    nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection,c_pszCmEntryMaxPassword,PWLEN);
                    if ((UINT)lstrlenU(pszTmp) > __min(PWLEN,nTmp)) 
                    {
                        CmFree(pszTmp);
                        pszTmp = CmStrCpyAlloc(TEXT(""));
                    }

                    (VOID)pArgs->SecurePW.SetPassword(pszTmp);

                    CmWipePassword(pszTmp);
                    CmFree(pszTmp);
                }
                else
                {
                    (VOID)pArgs->SecurePW.SetPassword(TEXT(""));
                }
            }
    
            //
            // Load domain info
            //
   
            LPTSTR pszDomain = NULL;

            GetUserInfo(pArgs, UD_ID_DOMAIN, (PVOID*)&pszDomain);
            if (pszDomain)
            {
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);
        
                if (nTmp <= 0)
                {
                    nTmp = DNLEN;
                }
        
                if ((UINT)lstrlenU(pszDomain) > __min(DNLEN, nTmp))
                {
                    CmFree(pszDomain);
                    pszDomain = CmStrCpyAlloc(TEXT(""));
                }
                lstrcpyU(pArgs->szDomain, pszDomain);
                CmFree(pszDomain);
            }
            else
            {
                *pArgs->szDomain = TEXT('\0');
            }
        } 
    }

    CMTRACE(TEXT("RefreshCredentialInfo() - End"));
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAndStoreUserInfo 
//
//  Synopsis:   Most of this code existed in the OnMainConnect function.
//              Gets the username, domain, password from the edit boxes and saves them
//              to the internal structure pArgs->szUserName, pArgs->szPassword, pArgs->szDomain
//              if the fSaveOtherUserInfo is TRUE then it also saves them to the appropriate 
//              place (RAS store, reg, etc.)
//
//  Arguments:  pArgs               - ptr to ArgsStruct
//              hwndDlg             - handle to the dialog window
//              fSaveUPD            - save UserName, Password, Domain (U, P, D)
//              fSaveOtherUserInfo  - flag whether to save other userinfo (excluding U, P, D)
//
//  Returns:    NONE
//
//  History:    02/05/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID GetAndStoreUserInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSaveUPD, BOOL fSaveOtherUserInfo)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }

    //
    // Process UserName info, if any
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT))
    {
        LPTSTR pszUsername = CmGetWindowTextAlloc(hwndDlg, IDC_MAIN_USERNAME_EDIT);

        //
        // save the user info
        //
        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pszUsername);
        }

        lstrcpyU(pArgs->szUserName, pszUsername);
        CmFree(pszUsername);

    }
    else
    {
        //
        // In case the user name field is hidden then just re-save what's in the 
        // structure. This needs to be done since all of the credentials might have
        // been deleted from the ras cred store
        //
        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pArgs->szUserName);
        }
    }

    //
    // Update password related flags
    //

    if (!pArgs->fHideRememberPassword)
    {
        //
        // save "Remember password"
        //
        if (fSaveOtherUserInfo)
        {
            SaveUserInfo(pArgs, UD_ID_REMEMBER_PWD, 
                         (PVOID)&pArgs->fRememberMainPassword);
        }
    }

    if (!pArgs->fHideDialAutomatically)
    {
        //
        // save "Dial automatically..."
        //
        if (fSaveOtherUserInfo)
        {
            SaveUserInfo(pArgs, UD_ID_NOPROMPT, 
                         (PVOID)&pArgs->fDialAutomatically);
        }
    }

    //
    // Process Password info, if any. If field is hidden, then don't save anything.
    //
    HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);

    if (hwndPassword)
    {
        BOOL fSavePassword = TRUE;

        //
        // We don't want to copy the password into pArgs structure if fSaveUPD isn't true,
        // because it will be obfuscated in this case. The password is already in the structure
        // on Win2K+
        //
        if (fSaveUPD)
        {
            //
            // Get the latest password data from the edit control 
            // and obfuscate its contents so that connect actions
            // can't retrieve it.
            //

            GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
            ObfuscatePasswordEdit(pArgs);

            //
            // Check if we have 16 *'s
            //

            if ((pArgs->SecurePW.IsHandleToPassword()) && 
                (FALSE == SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L)))
            {
                //
                // We have 16 *'s and the user hasn't modified the editbox. This 
                // password is from the RAS cred store, so we don't want to save the 16 *'s 
                //
                fSavePassword = FALSE;
            }
        }

        //
        // For winlogon we need to take the password from the edit box
        //
        if (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType)
        {
            GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
        }
        
        //
        // Update persistent storage
        // No need to delete the password here as it was done by the calling function
        //

        if (pArgs->fRememberMainPassword)
        {
            //
            // If the password has changed, then update storage
            // Always save password - 303382
            //

            if (fSaveUPD && fSavePassword)
            {
                LPTSTR pszClearPassword = NULL;
                DWORD cbClearPassword = 0;
                BOOL fRetPassword = FALSE;

                fRetPassword = pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

                if (fRetPassword && pszClearPassword)
                {
                    SaveUserInfo(pArgs, UD_ID_PASSWORD, (PVOID)pszClearPassword);
                    
                    //
                    // Clear and Free the clear-text password
                    //

                    pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
                }
            }
        
            //
            // Check DialAutomatically and carry remember state 
            // over to InetPassword if it isn't remembered already.
            //
            // Need to check if this is a double-dial scenario. Also need to check if we are
            // allowed to save UPD, otherwise we don't want to change the state mainly 
            // (pArgs->fRememberInetPassword)
            //
            if (pArgs->fDialAutomatically && fSaveUPD && 
                (DOUBLE_DIAL_CONNECTION == pArgs->GetTypeOfConnection()))
            {
                //
                // Carry remember state from DialAutomatically over to 
                // InetPassword if it isn't already remembered.
                //

                if (!pArgs->fRememberInetPassword)
                {
                    pArgs->fRememberInetPassword = TRUE;

                    if (fSavePassword)
                    {
                        LPTSTR pszClearInetPassword = NULL;
                        DWORD cbClearInetPassword = 0;
                        BOOL fRetPassword = FALSE;

                        fRetPassword = pArgs->SecureInetPW.GetPasswordWithAlloc(&pszClearInetPassword, &cbClearInetPassword);

                        if (fRetPassword && pszClearInetPassword)
                        {
                            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pszClearInetPassword); 

                            //
                            // Clear and Free the clear-text password
                            //

                            pArgs->SecureInetPW.ClearAndFree(&pszClearInetPassword, cbClearInetPassword);
                        }
                    }                            

                }
            }
        }
        else
        {
            //
            // If we don't have the ras cred store then the password wasn't deleted
            // so we must deleted by calling this function
            //
            if (fSavePassword) // No need to check fSaveUPD, taken care of ras creds store check
            {
                if (FALSE == pArgs->bUseRasCredStore)
                {
                    DeleteUserInfo(pArgs, UD_ID_PASSWORD);
                }
            }
        }

        if (fSaveUPD)
        {
            BOOL fSaveInetPassword = TRUE;

            //
            // Check if we have 16 *'s for Internet Password.
            //
            
            if (pArgs->SecureInetPW.IsHandleToPassword())
            {
                //
                // We have 16 *'s This password is from the RAS cred store, so we don't want to save the 16 *'s 
                //
                fSaveInetPassword = FALSE;
            }

            //
            // Check to see if we should re-save Internet creds
            // This needs to be done here in case the user has switched between
            // global and local credentials using the option buttons while having Internet 
            // credentials set in the Internet Login (CInetPage) property sheet. By switching 
            // the options, the user switched the current credential store 
            // (pArgs->dwCurrentCredentialType) so in order not to lose that data, we need to 
            // re-save the internet creds. Re-saving puts them in the correct (global or local) 
            // ras cred store.
            // When the username is the same and we saved the main password (SaveUserInfo)
            // this also saves the password to the Internet creds store
            //
            
            if (pArgs->fUseSameUserName)
            {
                if (fSaveInetPassword)
                {
                    if (pArgs->fRememberMainPassword)
                    {
                        //
                        // Save the UserName into the InetUserName field
                        // Password has been saved when saving UD_ID_PASSWORD. There is a special
                        // case that also saves the main password as the internet password
                        //
                        SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szUserName);
                        pArgs->fRememberInetPassword = TRUE;
                    }
                    else
                    {
                        if (FALSE == pArgs->bUseRasCredStore)
                        {
                            DeleteUserInfo(pArgs, UD_ID_INET_PASSWORD);
                            pArgs->fRememberInetPassword = FALSE;
                        }
                    }
                }
            }
            else
            {
                if (fSaveInetPassword)
                {
                    if(pArgs->fRememberInetPassword)
                    {
                        LPTSTR pszClearInetPassword = NULL;
                        DWORD cbClearInetPassword = 0;
                        BOOL fRetPassword = FALSE;

                        fRetPassword = pArgs->SecureInetPW.GetPasswordWithAlloc(&pszClearInetPassword, &cbClearInetPassword);

                        if (fRetPassword && pszClearInetPassword)
                        {
                            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pszClearInetPassword);

                            //
                            // Clear and Free the clear-text password
                            //

                            pArgs->SecureInetPW.ClearAndFree(&pszClearInetPassword, cbClearInetPassword);
                        }
                    }
                    else
                    {
                        if (FALSE == pArgs->bUseRasCredStore)
                        {
                            DeleteUserInfo(pArgs, UD_ID_INET_PASSWORD);
                        }
                    }
                }

                //
                // Need to save username in either case so we can pre-populate this
                //
                SaveUserInfo(pArgs, UD_ID_INET_USERNAME, 
                             (PVOID)pArgs->szInetUserName);
            }
        }
    }

    // 
    // This should be saved in all cases except ICS
    //
    if (fSaveOtherUserInfo)
    {
        SaveUserInfo(pArgs, UD_ID_REMEMBER_INET_PASSWORD, (PVOID)&pArgs->fRememberInetPassword); 
    }

    //
    // Process Domain info, if any
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT)) // !pArgs->fHideDomain)
    {
        LPTSTR pszDomain = CmGetWindowTextAlloc(hwndDlg,IDC_MAIN_DOMAIN_EDIT);
    
        //
        // save the user info
        //

        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_DOMAIN, (PVOID)pszDomain); 
        }

        lstrcpyU(pArgs->szDomain, pszDomain);
        CmFree(pszDomain);
    }
    else
    {
        //
        // In case the domain field is hidden then just re-save what's in the 
        // structure. This needs to be done since all of the credentials might have
        // been deleted from the ras cred store.
        //
        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_DOMAIN, (PVOID)pArgs->szDomain); 
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetIniObjectReadWriteFlags 
//
//  Synopsis:   If the read or write flags are set we need to enable reading and/or
//              writing to the .CMP file. Each instance of the CIni class may 
//              or may not use the .cmp file. It can also be using the .CMP as either 
//              the primary file or normal file. See InitProfileFromName function 
//              in init.cpp for detailed comments about these instances.
//
//              pArgs->piniProfile      - uses .CMP as a regular file
//              pArgs->piniService      - doesn't use .CMP file at all
//              pArgs->piniBoth         - uses .CMP as a primary file
//              pArgs->piniBothNonFav   - uses .CMP as a primary file
//
//  Arguments:  pArgs           - ptr to ArgsStruct
//
//  Returns:    NONE
//
//  History:    02/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SetIniObjectReadWriteFlags(ArgsStruct *pArgs)
{
    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return;
    }

    BOOL fWriteICSInfo = FALSE;
    BOOL fReadGlobalICSInfo = FALSE;

    //
    // Get the read flag
    //
    fReadGlobalICSInfo = ((BOOL)(pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_READ_ICS_DATA) ? TRUE : FALSE);

    //
    // Get the write flag. 
    //
    fWriteICSInfo = ((BOOL)(pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_WRITE_ICS_DATA) ? TRUE : FALSE);

    if (fReadGlobalICSInfo || fWriteICSInfo)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);
        if (pszICSDataReg)
        {
            //
            // Now that there is a reg key and at least one of the above flags is TRUE,
            // then we want to set the read and write flags in the classes. By default
            // they are set to FALSE in the constructors, so we don't have to 
            // explicitly set them if we don't need this functionality.
            //
            // Set ICSData reg key
            //
            pArgs->piniProfile->SetICSDataPath(pszICSDataReg);
            pArgs->piniBoth->SetICSDataPath(pszICSDataReg);
            pArgs->piniBothNonFav->SetICSDataPath(pszICSDataReg);

            //
            // Set Write flag since we have a reg key
            //
            pArgs->piniProfile->SetWriteICSData(fWriteICSInfo);
            pArgs->piniBoth->SetWriteICSData(fWriteICSInfo);
            pArgs->piniBothNonFav->SetWriteICSData(fWriteICSInfo);

            //
            // Set Read flag since we have a reg key
            //
            pArgs->piniProfile->SetReadICSData(fReadGlobalICSInfo);
            pArgs->piniBoth->SetReadICSData(fReadGlobalICSInfo);
            pArgs->piniBothNonFav->SetReadICSData(fReadGlobalICSInfo);
        }

        CmFree(pszICSDataReg);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function:   TryToDeleteAndSaveCredentials 
//
//  Synopsis:   Used on Win2K and WinXP+. This function uses the RAS Credential 
//              store to save and delete credentials based on user's selection.
//              First we need to determine if the user is saving their password.
//              Then appropriately delete or prompt to delete existing credentials.
//              If we aren't saving any credentials, then delete all of them.
//              The special case is if the user is deleting his local credentials
//              and global credentials exist on the system. Then we have to prompt
//              if we should delete the global creds as well.
//              Toward the botton of the function we get the info from the UI.
//              If the password is 16 *'s then we don't save the password After 
//              getting info from the UI, we save it in the RAS Cred store. 
//              Internet credentials are saved if we are using the same user 
//              name. Otherwise we leave the Internet creds. They were saved
//              on the Inet properties page. There is a scenario where the user
//              saved the internet creds on the property page and then switched 
//              the way credentials should be saved (global vs. local) which might cause
//              the internet password to be stored under in the wrong (global vs. local)
//              ras store. If the passwords are disjoined (pArgs->fUseSameUserName is FALSE)
//              there isn't much we can do.
//              
//              NOTE: We only want to delete credentials if and only if the existence 
//              flag are set! This is to prevent from deleting mainly global credentials 
//              in a certain profile where global credentials are disabled. 
//      
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID TryToDeleteAndSaveCredentials(ArgsStruct *pArgs, HWND hwndDlg)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }

    //
    // Check if this is Win2K+ (That's where RAS Creds store is supported)
    //
    if (!OS_NT5)
    {
        MYDBGASSERT(FALSE);
        return;
    }

    BOOL fSave = FALSE;
    BOOL fResaveInetUserCreds = FALSE;
    RASCREDENTIALS rc = {0};
    RASCREDENTIALS rcInet={0};
    rc.dwSize = sizeof(rc);
    rcInet.dwSize = sizeof(rcInet);
    
    //
    // See if we want to save the credentials
    //
    if (pArgs->fRememberMainPassword)
    {
        //
        // Which password are we saving?
        //
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            //
            // Delete User creds w/o asking. No need to check for existence since these
            // are just user (main & inet) creds.
            //
            DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;
            rc.dwMask = RASCM_DefaultCreds;

            //
            // Delete Internet User creds w/o asking
            // It doesn't matter that we aren't using the same user name
            // If we are saving globals, then user creds must always be deleted! This applies for main and Internet.
            // 
            DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
        }
        else
        {
            //
            // Trying to save User creds. if there is currently no saved per-user password 
            // and the user opts to save the password himself, then ask whether the global
            // password should be deleted if it exists.
            //
            if ((CM_EXIST_CREDS_MAIN_GLOBAL & pArgs->dwExistingCredentials) &&
                !(CM_EXIST_CREDS_MAIN_USER & pArgs->dwExistingCredentials))
            {
                LPTSTR pszTmp = CmLoadString(g_hInst, IDMSG_DELETE_GLOBAL_CREDS);
                if (pszTmp)
                {
                    if (IDYES == MessageBoxEx(hwndDlg, pszTmp, pArgs->szServiceName, 
                                              MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2,
                                              LANG_USER_DEFAULT))
                    {
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;

                        //
                        // Check for existence before deleting. If they don't exist, no need to 
                        // delete them.
                        //
                        if ((CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)) 
                        {
                            //
                            // Delete Internet Global creds if we are using the same creds
                            //
                            if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                            {
                                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                            }
                        }
                    }
                }
                CmFree(pszTmp);            
            }
        }

        //
        // User chose to save password.  Cache username, password, and
        // domain.
        //
        fSave = TRUE;
        rc.dwMask |= RASCM_UserName | RASCM_Password | RASCM_Domain;
    }
    else
    {
        //
        // Don't save password
        //

        //
        // Check which option button is currently selected
        //
        if (CM_CREDS_USER == pArgs->dwCurrentCredentialType)
        {
            //
            // User is trying to delete his local creds. Delete the user creds.
            // No need to check if they exist since these are local user creds.
            //
            DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;

            if (pArgs->fUseSameUserName  || (FALSE == pArgs->fRememberInetPassword))
            {
                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
            }

            //
            // Check if global creds exist and if so prompt the user asking if he wants 
            // to delete the globals as well
            //
            if (CM_EXIST_CREDS_MAIN_GLOBAL & pArgs->dwExistingCredentials)
            {
                int iMsgBoxResult = 0;

                LPTSTR pszTmp = CmLoadString(g_hInst, IDMSG_DELETE_ALL_CREDS);
                if (pszTmp)
                {
                    //
                    // Set the default to the 2nd button (NO), thus the user won't 
                    // accidentally delete the global creds.
                    //
                    iMsgBoxResult = MessageBoxEx(hwndDlg, pszTmp, pArgs->szServiceName, 
                                              MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2,
                                              LANG_USER_DEFAULT);
                
                    if (IDYES == iMsgBoxResult)
                    {
                        //
                        // Delete global creds
                        //
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;

                        if (CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)
                        {
                            if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                            {
                                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                            }
                        }
                    }
                }
                CmFree(pszTmp);
                pszTmp = NULL;
            }

            //
            // We need to resave username or domain info, even if it existed in case the
            // user has updated it.
            //
            fSave = TRUE;
            rc.dwMask |= RASCM_UserName | RASCM_Domain;
        }
        else
        {
            //
            // Delete both sets of credentials
            //

            //
            // Check if we need to resave User Name and Domain. The call that deletes the 
            // user creds doesn't wipe out User Name and Domain so there is no need to re-save.
            //
            if (FALSE == (BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER))
            {
                //
                // Resave the username, and domain since user creds didn't exist
                // and we want to pre-populate this info next time CM is loaded
                //
                fSave = TRUE;
                rc.dwMask |= RASCM_UserName | RASCM_Domain;
            }

            if (CM_EXIST_CREDS_MAIN_GLOBAL & pArgs->dwExistingCredentials)
            {
                //
                // Delete the global credentials.  
                // Note from RAS codebase: Note that we have to delete the global identity 
                // as well because we do not support deleting 
                // just the global password.  This is so that 
                // RasSetCredentials can emulate RasSetDialParams.
                //

                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
            }

            if (CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)
            {
                if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                {
                    DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;

                    //
                    // If we don't have Inet user creds then we need to cache the username for Inet creds
                    //
                    if (FALSE == (BOOL)(CM_EXIST_CREDS_INET_USER & pArgs->dwExistingCredentials))
                    {
                        fResaveInetUserCreds = TRUE;
                    }
                }
            }

            //
            // Delete the password saved per-user.  Keep the user name
            // and domain saved, however.
            //

            if (CM_EXIST_CREDS_MAIN_USER & pArgs->dwExistingCredentials)
            {
                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;
            }

            if (CM_EXIST_CREDS_INET_USER & pArgs->dwExistingCredentials)
            {
                if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                {
                    DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                    pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                }
            }
        }
    }

    //
    // Gets the info from the UI into pArgs and copy them into the RASCREDENTIALS structure
    //
    GetUserInfoFromDialog(pArgs, hwndDlg, &rc);

    //
    // See if we need to save anything
    //
    if (fSave)
    {
        LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
        DWORD dwCurrentMask = rc.dwMask;
        DWORD dwInetCurrentMask = rc.dwMask & ~RASCM_Domain; // Don't need domain info

        if (pszConnectoid && pArgs->rlsRasLink.pfnSetCredentials)
        {
            DWORD dwRet = (DWORD)-1; // Some non ERROR_SUCCESS value
            DWORD dwRetInet = (DWORD)-1; // Some non ERROR_SUCCESS value

            LPTSTR pszPhoneBook = pArgs->pszRasPbk;
            LPTSTR pszPrivatePhoneBook = CreateRasPrivatePbk(pArgs);

            CopyMemory((LPVOID)&rcInet, (LPVOID)&rc, sizeof(rcInet));

            //
            // Save the creds
            //
            dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &rc, FALSE);

            if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwRet)
            {
                //
                //  Then the phonebook entry doesn't exist yet, lets create it.
                //
                LPRASENTRY pRasEntry = (LPRASENTRY)CmMalloc(sizeof(RASENTRY));

                if (pRasEntry && pArgs->rlsRasLink.pfnSetEntryProperties)
                {
                    pRasEntry->dwSize = sizeof(RASENTRY);
                    dwRet = pArgs->rlsRasLink.pfnSetEntryProperties(pszPhoneBook, pszConnectoid, pRasEntry, pRasEntry->dwSize, NULL, 0);

                    //
                    //  Lets try to set the credentials one more time ...
                    //
                    if (ERROR_SUCCESS == dwRet)
                    {
                        //
                        // dwMask needs to be reassigned, the previous call modified it
                        //
                        rc.dwMask = dwCurrentMask;
                        dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &rc, FALSE);
                    }

                    CmFree(pRasEntry);
                }
            }

            //
            // Now try to save Internet creds
            //
            if (ERROR_SUCCESS == dwRet && pszPrivatePhoneBook)
            {
                //
                // If we aren't using the credentials for main and Inet, then there
                // is no need to resave Internet credentials, because they were saved on 
                // the Inet-Dialog page and they weren't deleted above.
                // 
                if (pArgs->fUseSameUserName)
                {
                    //
                    // dwMask needs to be reassigned, the previous call modified it
                    //
                    rcInet.dwMask = dwInetCurrentMask;
                    dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                }
                else
                {
                    if (fResaveInetUserCreds)
                    {
                        rcInet.dwMask = dwInetCurrentMask;
                        dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                    }

                    if (pArgs->fDialAutomatically && 
                        (DOUBLE_DIAL_CONNECTION == pArgs->GetTypeOfConnection())) 
                    {
                        //
                        // Carry remember state from DialAutomatically over to 
                        // InetPassword if it isn't already remembered.
                        //

                        if (FALSE == pArgs->fRememberInetPassword)
                        {
                            pArgs->fRememberInetPassword = TRUE;

                            LPTSTR pszClearInetPassword = NULL;
                            DWORD cbClearInetPassword = 0;
                            BOOL fRetPassword = FALSE;

                            //
                            // Compare to 16 *'s. We don't want to resave if we have 16 *'s
                            // otherwise the user will get an auth-retry.
                            //
                            if (FALSE == pArgs->SecureInetPW.IsHandleToPassword())
                            {
                                fRetPassword = pArgs->SecureInetPW.GetPasswordWithAlloc(&pszClearInetPassword, &cbClearInetPassword);

                                if (fRetPassword && pszClearInetPassword)
                                {
                                    // 
                                    // No need to save the domain
                                    //
                                    rcInet.dwMask = dwInetCurrentMask;
                                    lstrcpyU(rcInet.szUserName, pArgs->szInetUserName);
                                    lstrcpyU(rcInet.szPassword, pszClearInetPassword);
                                    
                                    dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);

                                    //
                                    // Clear and Free the clear-text password
                                    //

                                    pArgs->SecureInetPW.ClearAndFree(&pszClearInetPassword, cbClearInetPassword);
                                }
                            }
                        }
                    }
                }
            }
     
            
            
            if ((ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwRetInet) && pszPrivatePhoneBook)
            {
                //
                //  Then the phonebook entry doesn't exist yet, lets create it.
                //
                LPRASENTRY pRasEntry = (LPRASENTRY)CmMalloc(sizeof(RASENTRY));

                if (pRasEntry && pArgs->rlsRasLink.pfnSetEntryProperties)
                {
                    pRasEntry->dwSize = sizeof(RASENTRY);
                    dwRetInet = pArgs->rlsRasLink.pfnSetEntryProperties(pszPrivatePhoneBook, pszConnectoid, pRasEntry, pRasEntry->dwSize, NULL, 0);

                    //
                    //  Lets try to set the credentials one more time ...
                    //
                    if (ERROR_SUCCESS == dwRetInet)
                    {
                        //
                        // dwMask needs to be reassigned, the previous call modifies the mask
                        //
                        rcInet.dwMask = dwInetCurrentMask;   
                        dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                    }

                    CmFree(pRasEntry);
                }
            }

            if (ERROR_SUCCESS == dwRet)
            {
                //
                // Only set the existance flags if we are saving the password and everything 
                // succeeded
                //
                if (pArgs->fRememberMainPassword)
                {
                    if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                    {
                        pArgs->dwExistingCredentials |= CM_EXIST_CREDS_MAIN_GLOBAL;
                        
                        if (pArgs->fUseSameUserName && (ERROR_SUCCESS == dwRetInet))
                        {
                            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_GLOBAL;
                        }
                    }
                    else
                    {
                        pArgs->dwExistingCredentials |= CM_EXIST_CREDS_MAIN_USER;
                        
                        if (pArgs->fUseSameUserName && (ERROR_SUCCESS == dwRetInet))
                        {
                            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_USER;
                        }
                    }
                }
            }
            CmFree(pszPrivatePhoneBook);
        }
        CmFree(pszConnectoid);
    }

    CmSecureZeroMemory(rc.szPassword, sizeof(rc.szPassword));
    CmSecureZeroMemory(rcInet.szPassword, sizeof(rcInet.szPassword));

    return;
}

//----------------------------------------------------------------------------
//
//  Function:   GetUserInfoFromDialog 
//
//  Synopsis:   Gets the user information from the editboxes into pArgs 
//              structure. Then it copies the info into rascredentials
//              structure. If the password is 16 *'s then we clear
//              the password mask in the rascredentials in order not to save
//              the password.
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              prc                     - [IN/OUT] rascredentials structure 
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID GetUserInfoFromDialog(ArgsStruct *pArgs, HWND hwndDlg, RASCREDENTIALS *prc)
{
    if (NULL == pArgs || NULL == hwndDlg || NULL == prc)
    {
        MYDBGASSERT(pArgs && hwndDlg && prc);
        return;
    }
    
    //
    // Process Password info, if any. 
    //
    HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);

    if (hwndPassword)
    {
        //
        // Get the latest password data from the edit control 
        // and obfuscate its contents so that connect actions
        // can't retrieve it.
        //

        GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
        ObfuscatePasswordEdit(pArgs);   // sets *'s into the password edit box

        //
        // Check if we have 16 *'s
        //
        
        if (pArgs->SecurePW.IsHandleToPassword() && 
            (FALSE == SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L)))
        {
            //
            // We have 16 *'s and the user hasn't modified the editbox. This 
            // password is from the RAS cred store, so we don't want to save the 16 *'s 
            //
            prc->dwMask &= ~RASCM_Password;
        }
    }

    //
    // Process UserName info, if any
    //

    HWND hwndUserName = GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT);
    if (hwndUserName)
    {
        LPTSTR pszUsername = CmGetWindowTextAlloc(hwndDlg, IDC_MAIN_USERNAME_EDIT);

        lstrcpyU(pArgs->szUserName, pszUsername);
        
        CmFree(pszUsername);
    }
    
    //
    // Process Domain info, if any
    //
    HWND hwndDomain = GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT);
    if (hwndDomain) 
    {
        LPTSTR pszDomain = CmGetWindowTextAlloc(hwndDlg,IDC_MAIN_DOMAIN_EDIT);

        lstrcpyU(pArgs->szDomain, pszDomain);
 
        CmFree(pszDomain);
    }

    //
    // This needs to be separate because in some cases 
    // the editboxes will not exist on the dialog, but we still need to save the info
    // from the pArgs structure into RASCREDENTIALS.
    //
    lstrcpyU(prc->szUserName, pArgs->szUserName);
    lstrcpyU(prc->szDomain, pArgs->szDomain);

    LPTSTR pszClearPassword = NULL;
    DWORD cbClearPassword = 0;
    BOOL fRetPassword = FALSE;

    fRetPassword = pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

    if (fRetPassword && pszClearPassword)
    {
        lstrcpyU(prc->szPassword, pszClearPassword);
        
        //
        // Clear and Free the clear-text password
        //

        pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
    }
}

//----------------------------------------------------------------------------
//
//  Function:   SwitchToLocalCreds 
//
//  Synopsis:   Clear the password, but only if it wasn't recently modified
//              only then we can reuse and resave it. That's because when
//              we switch credential stores, the value of the szPassword 
//              is what was read from the RAS cred store (16 *'s). It doesn't 
//              make sense to save this value into a new user RAS creds store. If the 
//              password already existed there, then it's fine.
//              In case the user modified the password text box and then decided
//              to swich, the modification flag will be on, so we'll assume that the
//              user entered a valid password and that it wasn't read in from the 
//              creds store.
//              The actual deletion of credential happnes once the user clicks 
//              the connect button. Here we just clear things out of memory
//              and update the UI. We also need to update the remember Internet
//              flag based on if the Internet credential exist. This is so the
//              UI stays consistent with what credentials are loaded in memory.
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              fSwitchToGlobal         - used to ignore the check which credential
//                                        store is currently active
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SwitchToLocalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToLocal)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        return;   
    }

    //
    // Switching to using Single-User credentials
    //

    //
    // Check that previously the default was the Global creds store
    //
    if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType || fSwitchToLocal)
    {
        pArgs->dwCurrentCredentialType = CM_CREDS_USER;

        HWND hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
        BOOL fPWChanged = FALSE;

        if (hwndTemp)
        {
            //
            // Don't use Edit_GetModify. This needs need to run on Win9x so call
            // SendMessageU
            //
            fPWChanged = (BOOL) SendMessageU(hwndTemp, EM_GETMODIFY, 0L, 0L);
            if (FALSE == fPWChanged)
            {
                pArgs->fIgnoreChangeNotification = TRUE;

                (VOID)pArgs->SecurePW.SetPassword(TEXT(""));

                SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, TEXT(""));
                pArgs->fIgnoreChangeNotification = FALSE;
            }
        }
        
        if (FALSE == fPWChanged)
        {
            //
            // Only if Password field didn't change
            //
            if (OS_NT51)
            {
                //
                // Wipe the Internet password - since we are switching from globals
                // or we are using the same user name the Inet password will get re-populated
                // from the main password, otherwise the user needs to set this password in 
                // the InetDialog.
                //
                (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));

                pArgs->fRememberInetPassword = FALSE;

                //
                // Only reload if main user creds exist
                //
                if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER)
                {
                    if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)
                    {
                        ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_BOTH);
                        pArgs->fRememberInetPassword = TRUE;
                    }
                    else
                    {
                        ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_MAIN);
                    }
                }
                else
                {
                    if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)
                    {
                        ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_INET);
                        pArgs->fRememberInetPassword = TRUE;
                    }
                    else
                    {
                        pArgs->fRememberInetPassword = FALSE;
                    }
                }
            }
            else
            {
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_BOTH);
            }
        }
        else
        {
            if (OS_NT51)
            {
                if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)
                {
                    ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_INET);
                    pArgs->fRememberInetPassword = TRUE;
                }
                else
                {
                    pArgs->fRememberInetPassword = FALSE;
                }
            }
            else
            {
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_INET);
            }
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   SwitchToGlobalCreds 
//
//  Synopsis:   Clear the password and reload the credentials if they exist.
//              Otherwise we clear the password if it hasn't been modified by
//              the user.
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              fSwitchToGlobal         - used to ignore the check which credential
//                                        store is currently active
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SwitchToGlobalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToGlobal)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        return;   
    }

    //
    // This should only be called on WinXP+
    //
    if (!OS_NT51)
    {
        MYDBGASSERT(FALSE);        
        return;
    }

    //
    // Switching to using Global credentials
    //

    //
    // Check that previously the default was the User creds store
    //
    if (CM_CREDS_USER == pArgs->dwCurrentCredentialType || fSwitchToGlobal)
    {
        pArgs->dwCurrentCredentialType = CM_CREDS_GLOBAL;
    
        if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_GLOBAL)
        {
            (VOID)pArgs->SecurePW.SetPassword(TEXT(""));

            (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));

            pArgs->fRememberInetPassword = FALSE;

            //
            // Globals exist 
            //
            if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_GLOBAL)
            {
                //
                // Both exist - reload both
                //
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_BOTH);
                pArgs->fRememberInetPassword = TRUE;
            }
            else
            {
                //
                // User Globals - exist, reload
                // Internet Globals - don't exist, clear password
                //
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_MAIN);
            }
        }
        else
        {
            HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);

            pArgs->fIgnoreChangeNotification = TRUE;

            (VOID)pArgs->SecureInetPW.SetPassword(TEXT(""));

            pArgs->fRememberInetPassword = FALSE;

            if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_GLOBAL)
            {
                //
                // User Globals - don't exist - clear password
                // Internet Globals - exist - reload
                //
                RefreshCredentialInfo(pArgs, CM_CREDS_TYPE_INET);
                
                //
                // In case user inet creds didn't exist, we should 
                //
                pArgs->fRememberInetPassword = TRUE;
            }
            
            //
            // Clear the main password only if it wasn't recently modified
            //
            if (hwndPassword)
            {
                if (FALSE == SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L))
                {
                    (VOID)pArgs->SecurePW.SetPassword(TEXT(""));

                    SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, TEXT(""));
                }
            }

            pArgs->fIgnoreChangeNotification = FALSE;
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   ReloadCredentials 
//
//  Synopsis:   Wrapper to reload credentials into the editboxes
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              dwWhichCredType         - type of credential to reload
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID ReloadCredentials(ArgsStruct *pArgs, HWND hwndDlg, DWORD dwWhichCredType)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }

    pArgs->fIgnoreChangeNotification = TRUE;
    RefreshCredentialInfo(pArgs, dwWhichCredType);
    SetMainDlgUserInfo(pArgs, hwndDlg);
    pArgs->fIgnoreChangeNotification = FALSE;
}

//----------------------------------------------------------------------------
//
//  Function:   VerifyAdvancedTabSettings 
//
//  Synopsis:   Verifies and possibly modifed the connection's ICF/ICS settings
//              based on what was configured in the .cms file. These functions
//              depend on the hnetcfg objects and private/internal interfaces.
//              We got them from the homenet team.
//              Some parts of the code were taken from:
//              nt\net\homenet\config\dll\saui.cpp
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//
//  Returns:    NONE
//
//  History:    04/26/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID VerifyAdvancedTabSettings(ArgsStruct *pArgs)
{

#ifndef _WIN64
    
    HRESULT hr;
    IHNetConnection *pHNetConn = NULL;
    IHNetCfgMgr *pHNetCfgMgr = NULL;
    INetConnectionUiUtilities* pncuu = NULL;
    BOOL fCOMInitialized = FALSE;    
    BOOL fEnableICF = FALSE;
    BOOL fDisableICS = FALSE;
    BOOL fAllowUserToModifySettings = TRUE;
    
    if (OS_NT51) 
    {
        CMTRACE(TEXT("VerifyAdvancedTabSettings()"));
        //
        // Check rights - taken from saui.cpp
        //
        if (FALSE == IsAdmin())
        {
            return;
        }

        fEnableICF = pArgs->piniService->GPPB(c_pszCmSection, 
                                                c_pszCmEntryEnableICF, 
                                                FALSE);

        fDisableICS = pArgs->piniService->GPPB(c_pszCmSection, 
                                                c_pszCmEntryDisableICS, 
                                                FALSE);

        
        if (fEnableICF || fDisableICS)
        {
            hr = CoInitialize(NULL);
            if (S_OK == hr)
            {
                CMTRACE(TEXT("VerifyAdvancedTabSettings - Correctly Initialized COM."));
                fCOMInitialized = TRUE;
            }
            else if (S_FALSE == hr)
            {
                CMTRACE(TEXT("VerifyAdvancedTabSettings - This concurrency model is already initialized. CoInitialize returned S_FALSE."));
                fCOMInitialized = TRUE;
                hr = S_OK;
            }
            else if (RPC_E_CHANGED_MODE == hr)
            {
                CMTRACE1(TEXT("VerifyAdvancedTabSettings - Using different concurrency model. Did not initialize COM - RPC_E_CHANGED_MODE. hr=0x%x"), hr);
                hr = S_OK;
            }
            else
            {
                CMTRACE1(TEXT("VerifyAdvancedTabSettings - Failed to Initialized COM. hr=0x%x"), hr);
            }
    
            if (SUCCEEDED(hr))
            {
                //
                // Check user permissions. Needed to initialize COM first
                // Check if ZAW is denying access to the Shared Access UI - taken from saui.cpp
                //
                hr = HrCreateNetConnectionUtilities(&pncuu);
                if (SUCCEEDED(hr) && pncuu)
                {
                    fEnableICF = (BOOL)(fEnableICF && pncuu->UserHasPermission(NCPERM_PersonalFirewallConfig));
                    fDisableICS = (BOOL)(fDisableICS && pncuu->UserHasPermission(NCPERM_ShowSharedAccessUi));

                    if ((FALSE == fEnableICF) && (FALSE == fDisableICS))
                    {
                        goto done;
                    }
                }

                //
                // Create the home networking configuration manager
                //
                hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_ALL,
                                      IID_IHNetCfgMgr, (void**)&pHNetCfgMgr);
                if (SUCCEEDED(hr))
                {
                    //
                    // Convert the entry to an IHNetConnection
                    //
                    CMTRACE(TEXT("VerifyAdvancedTabSettings - Created CLSID_HNetCfgMgr object."));
                    GUID *pGuid = NULL;

                    LPRASENTRY pRasEntry = MyRGEP(pArgs->pszRasPbk, pArgs->szServiceName, &pArgs->rlsRasLink);

                    if (pRasEntry && sizeof(RASENTRY_V501) >= pRasEntry->dwSize)
                    {
                        //
                        // Get the pGuid value
                        //
                        pGuid = &(((LPRASENTRY_V501)pRasEntry)->guidId);
                
                        hr = pHNetCfgMgr->GetIHNetConnectionForGuid(pGuid, FALSE, TRUE, &pHNetConn);
                        if (SUCCEEDED(hr) && pHNetConn) 
                        {
                            if (fEnableICF)
                            {   
                                EnableInternetFirewall(pHNetConn);
                            }

                            if (fDisableICS)
                            {
                                DisableSharing(pHNetConn);
                            }
                        }
                        else
                        {
                            CMTRACE1(TEXT("VerifyAdvancedTabSettings() - Call to pHNetCfgMgr->GetIHNetConnectionForGuid returned an error. hr=0x%x"), hr);
                        }
                    }
                    else
                    {
                        CMTRACE(TEXT("VerifyAdvancedTabSettings - Failed to LoadRAS Entry."));
                    }
            
                    CmFree(pRasEntry);
                    pRasEntry = NULL;
                }
                else
                {
                    CMTRACE(TEXT("VerifyAdvancedTabSettings - Failed to create CLSID_HNetCfgMgr object."));
                }
            }
        }

done:
        //
        // Clean up and Uninitilize COM
        //
        if (pHNetConn)
        {
            pHNetConn->Release();
            pHNetConn = NULL;
        }

        if (pHNetCfgMgr)
        {
            pHNetCfgMgr->Release();
            pHNetCfgMgr = NULL;
        }

        if (pncuu)
        {
            pncuu->Release();
            pncuu = NULL;    
        }
    
        if (fCOMInitialized)
        {
            CoUninitialize(); 
        }
    }

#endif // _WIN64

}

//----------------------------------------------------------------------------
//
//  Function:   EnableInternetFirewall 
//
//  Synopsis:   Taken from :  CNetSharingConfiguration::EnableInternetFirewall
//              This is part of the internal api.  
//
//  Arguments:  pHNetConn - HNetConnection
//
//  Returns:    None. 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
VOID EnableInternetFirewall(IHNetConnection *pHNetConn)
{
    HRESULT hr = S_FALSE;
    BOOLEAN bEnabled = FALSE;

    if (NULL == pHNetConn)
    {
        return;
    }

    hr = InternalGetFirewallEnabled(pHNetConn, &bEnabled);

    if (SUCCEEDED(hr) && !bEnabled) 
    {
        IHNetFirewalledConnection* pFirewalledConnection = NULL;

        hr = pHNetConn->Firewall(&pFirewalledConnection);

        if (SUCCEEDED(hr))
        {
            if (pFirewalledConnection)
            {
                pFirewalledConnection->Release();
                pFirewalledConnection = NULL;
            }
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   InternalGetFirewallEnabled 
//
//  Synopsis:   Taken from :  CNetSharingConfiguration::EnableInternetFirewall
//
//  Arguments:  pHNetConnection - HNetConnection
//              pbEnabled - [out] whether the Firewall is enabled
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
HRESULT InternalGetFirewallEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled)
{
    HRESULT hr;
    HNET_CONN_PROPERTIES* pProps = NULL;

    if (NULL == pHNetConnection)
    {
        hr = E_INVALIDARG;
    }
    else if (NULL == pbEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;

        hr = pHNetConnection->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (pProps->fFirewalled)
            {
                *pbEnabled = TRUE;
            }

            CoTaskMemFree(pProps);
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   DisableSharing 
//
//  Synopsis:   Taken from :  CNetSharingConfiguration::EnableInternetFirewall
//
//  Arguments:  pHNetConn - HNetConnection 
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
STDMETHODIMP DisableSharing(IHNetConnection *pHNetConn)
{
    HRESULT hr;

    BOOLEAN bEnabled = FALSE;

    SHARINGCONNECTIONTYPE Type;

    if (NULL == pHNetConn)
    {
        return E_INVALIDARG;
    }
    
    hr = InternalGetSharingEnabled(pHNetConn, &bEnabled, &Type);

    if (SUCCEEDED(hr) && bEnabled ) 
    {
        switch(Type)
        {
        case ICSSHARINGTYPE_PUBLIC:
        {
            IHNetIcsPublicConnection* pPublicConnection = NULL;

            hr = pHNetConn->GetControlInterface( 
                            __uuidof(IHNetIcsPublicConnection), 
                            reinterpret_cast<void**>(&pPublicConnection) );

            if (SUCCEEDED(hr))
            {
                hr = pPublicConnection->Unshare();

                if (pPublicConnection)
                {
                    pPublicConnection->Release();
                    pPublicConnection = NULL;
                }
            }
        }
        break;

        case ICSSHARINGTYPE_PRIVATE:
        {
            IHNetIcsPrivateConnection* pPrivateConnection = NULL;

            hr = pHNetConn->GetControlInterface( 
                        __uuidof(IHNetIcsPrivateConnection), 
                        reinterpret_cast<void**>(&pPrivateConnection) );

            if (SUCCEEDED(hr))
            {
                hr = pPrivateConnection->RemoveFromIcs();

                if (pPrivateConnection)
                {
                    pPrivateConnection->Release();
                    pPrivateConnection = NULL;
                }
            }
        }
        break;

        default:
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   InternalGetSharingEnabled 
//
//  Synopsis:   Returns whether sharing is enabled on a given connection
//
//  Arguments:  pHNetConnection - HNetConnection 
//              pbEnabled - [out] returns the value
//              pType - type of connection
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
HRESULT InternalGetSharingEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled, SHARINGCONNECTIONTYPE* pType)
{
    HRESULT               hr;
    HNET_CONN_PROPERTIES* pProps;

    if (NULL == pHNetConnection)
    {
        hr = E_INVALIDARG;
    }
    else if ((NULL == pbEnabled) || (NULL == pType))
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;
        *pType     = ICSSHARINGTYPE_PUBLIC;

        hr = pHNetConnection->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (pProps->fIcsPublic)
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PUBLIC;
            }
            else if (pProps->fIcsPrivate)
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PRIVATE;
            }

            CoTaskMemFree(pProps);
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   HrCreateNetConnectionUtilities 
//
//  Synopsis:   Returns the pointer to the connection ui utilities object
//
//  Arguments:  ppncuu - pointer to INetConnectionUiUtilities object
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\saui.cpp
//
//----------------------------------------------------------------------------
HRESULT APIENTRY HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu)
{
    HRESULT hr = E_INVALIDARG;

    if (ppncuu)
    {
        hr = CoCreateInstance (CLSID_NetConnectionUiUtilities, NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_INetConnectionUiUtilities, (void**)ppncuu);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\ctr.h ===
//+----------------------------------------------------------------------------
//
// File:     ctr.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Header for the Ole Container object to host the future splash 
//           Animation control.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------
#ifndef __CTR_H_DEFINED__
#define __CTR_H_DEFINED__

#include "state.h"

//
// Typedefs for OLE32 APIs
//

typedef HRESULT (STDAPICALLTYPE *pfnOle32Initialize)(LPVOID);
typedef HRESULT (STDAPICALLTYPE *pfnOle32Uninitialize)();
typedef HRESULT (STDAPICALLTYPE *pfnOle32SetContainedObject) (LPUNKNOWN, BOOL);
typedef HRESULT (STDAPICALLTYPE *pfnOle32CoCreateInstance) (REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID *);

typedef struct _Ole32LinkageStruct {
	HINSTANCE hInstOle32;
	union {
		struct {
			pfnOle32Initialize			pfnOleInitialize;
			pfnOle32Uninitialize		pfnOleUninitialize;
			pfnOle32SetContainedObject	pfnOleSetContainedObject;
			pfnOle32CoCreateInstance	pfnCoCreateInstance;
		};
		void *apvPfnOle32[5];  
	};
} Ole32LinkageStruct;

//
// Typedefs for OLEAUT32 APIs
//

typedef HRESULT (STDAPICALLTYPE *pfnOleAutVariantClear) (VARIANTARG FAR*);
typedef HRESULT (STDAPICALLTYPE *pfnOleAutVariantCopy) (VARIANTARG FAR*, VARIANTARG FAR*);
typedef VOID	(STDAPICALLTYPE *pfnOleAutVariantInit) (VARIANTARG FAR*);
typedef HRESULT (STDAPICALLTYPE *pfnOleAutVariantChangeType) (VARIANTARG FAR*, VARIANTARG FAR*, unsigned short, VARTYPE);
typedef BSTR	(STDAPICALLTYPE *pfnOleAutSysAllocString) (OLECHAR FAR*);
typedef VOID	(STDAPICALLTYPE *pfnOleAutSysFreeString) (BSTR);

typedef struct _OleAutLinkageStruct {
	HINSTANCE hInstOleAut;
	union {
		struct {
			pfnOleAutVariantClear       pfnVariantClear;
			pfnOleAutVariantCopy		pfnVariantCopy;
			pfnOleAutVariantInit		pfnVariantInit;
			pfnOleAutVariantChangeType	pfnVariantChangeType;
			pfnOleAutSysAllocString     pfnSysAllocString;
			pfnOleAutSysFreeString      pfnSysFreeString;
		};
		void *apvPfnOleAut[7];  
	};
} OleAutLinkageStruct;

//
// Simple wrapper class for dynamic access to OleAut32 APIs that we care about
//

class CDynamicOleAut
{
public:
    CDynamicOleAut(VOID);
   ~CDynamicOleAut(VOID);
    BOOL Initialized(VOID);

    HRESULT DynVariantClear(VARIANTARG FAR*);
    HRESULT DynVariantCopy(VARIANTARG FAR*, VARIANTARG FAR*);
    VOID DynVariantInit(VARIANTARG FAR*);
    HRESULT DynVariantChangeType(VARIANTARG FAR*, VARIANTARG FAR*, unsigned short, VARTYPE);
    BSTR DynSysAllocString(OLECHAR FAR*);
    VOID DynSysFreeString(BSTR);

private:
    OleAutLinkageStruct m_OleAutLink;
};

//---------------------------------------------------------------
//  IOleObject
//---------------------------------------------------------------

enum OLE_SERVER_STATE
{
    OS_PASSIVE,
    OS_LOADED,                          // handler but no server
    OS_RUNNING,                         // server running, invisible
    OS_INPLACE,                         // server running, inplace-active, no U.I.
    OS_UIACTIVE,                        // server running, inplace-active, w/ U.I.
    OS_OPEN                             // server running, open-edited
};

struct BagProp
{
    BSTR    bstrName;    // name of property
    VARIANT varValue;    // value of property
};

typedef BagProp FAR * LPBAGPROP;

DECLARE_FORMSDATAARY(CAryBagProps, BagProp, LPBAGPROP);



// prototypes for HIMETRIC stuff.
//

void
InitPixelsPerInch(VOID);

int
HPixFromHimetric(long lHi);

int
VPixFromHimetric(long lHi);

long
HimetricFromHPix(int iPix);

long
HimetricFromVPix(int iPix);


class CICMOCCtr;
typedef CICMOCCtr FAR * LPICMOCCtr;

//+---------------------------------------------------------------------------
//
//  Class:      COleContainer ()
//
//  Purpose:    our implementation of IOleContainer.  does nothing.  Not sure
//              if we need it for FutureSplash - needed it for Web Browser
//              OC
//
//----------------------------------------------------------------------------
class COleContainer : public IOleContainer
{
public:
    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

    STDMETHOD(EnumObjects)(DWORD grfFlags, IEnumUnknown **ppenum);
    STDMETHOD(LockContainer)(BOOL fLock);
    STDMETHOD(ParseDisplayName)(
                      IBindCtx *pbc,
                      LPOLESTR pszDisplayName,
                      ULONG *pchEaten,
                      IMoniker **ppmkOut);

    COleContainer(LPICMOCCtr pCtr);

protected:
    LPICMOCCtr  m_pCtr;
};

//+---------------------------------------------------------------------------
//
//  Class:      COleClientSite ()
//
//  Purpose:    our implementation of IOleClientSite
//
//  Interface:  COleClientSite         -- ctor
//              QueryInterface         -- gimme an interface!
//              AddRef                 -- bump up refcount
//              Release                -- bump down refcount
//              SaveObject             -- returns E_FAIL
//              GetMoniker             -- E_NOTIMPL
//              GetContainer           -- returns our COleContainer impl
//              ShowObject             -- just say OK
//              OnShowWindow           -- just say OK
//              RequestNewObjectLayout -- E_NOTIMPL
//
//  Notes:      probably the most important thing our IOleClientSite
//              implementation does is hand off our IOleContainer
//              implementation when GetContainer() is called.
//
//----------------------------------------------------------------------------
class COleClientSite : public IOleClientSite
{
public:
    COleClientSite(LPICMOCCtr pCtr);

    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);


    // IOleClientSite stuff
    STDMETHOD(SaveObject)(VOID);
    STDMETHOD(GetMoniker)(
                 DWORD           dwAssign,
                 DWORD           dwWhichMoniker,
                 LPMONIKER FAR * ppmk);
    STDMETHOD(GetContainer)(LPOLECONTAINER FAR * pOleCtr);
    STDMETHOD(ShowObject)(VOID);
    STDMETHOD(OnShowWindow)(BOOL bShow);
    STDMETHOD(RequestNewObjectLayout)(VOID);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
};

//+---------------------------------------------------------------------------
//
//  Class:      CAdviseSink ()
//
//  Purpose:    IAdviseSink implementation
//
//----------------------------------------------------------------------------
class CAdviseSink : public IAdviseSink
{
public:
    CAdviseSink(LPICMOCCtr pCtr);

   // IUnknown stuff
   STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
   STDMETHOD_(ULONG, AddRef)(VOID);
   STDMETHOD_(ULONG, Release)(VOID);

   // IAdviseSink stuff
   STDMETHOD_(VOID, OnDataChange)(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
   STDMETHOD_(VOID, OnViewChange)(DWORD dwAspect, LONG lIndex);
   STDMETHOD_(VOID, OnRename)(LPMONIKER pmkNew);
   STDMETHOD_(VOID, OnSave)(VOID);
   STDMETHOD_(VOID, OnClose)(VOID);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
    LPUNKNOWN   m_pUnkOuter;  // pointer to CICMOCCtr's IUnknown
};

//+---------------------------------------------------------------------------
//
//  Class:      CInPlaceFrame ()
//
//  Purpose:
//
//  Interface:  CInPlaceFrame        -- ctor
//              QueryInterface       -- gimme an interface!
//              AddRef               -- bump up refcount
//              Release              -- decrement refcount
//              GetWindow            -- from IOleWindow - returns frame hWnd
//              ContextSensitiveHelp -- never implemented by design
//              GetBorder            -- for toolbar negotiation
//              RequestBorderSpace   -- ditto
//              SetBorderSpace       -- ditto
//              SetActiveObject      -- called whenever URL changes
//              InsertMenus          -- menu negotiation
//              SetMenu              -- ditto
//              RemoveMenus          -- ditto
//              SetStatusText        -- called by OC to set status text
//              EnableModeless       -- we have no modeless dlgs.
//              TranslateAccelerator -- calls ::TranslateAccelerator
//
//----------------------------------------------------------------------------
class CInPlaceFrame : public IOleInPlaceFrame
{
public:
    CInPlaceFrame(LPICMOCCtr pCtr);

   // IUnknown stuff
   STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
   STDMETHOD_(ULONG, AddRef)(VOID);
   STDMETHOD_(ULONG, Release)(VOID);

   // IOleWindow stuff
   STDMETHOD(GetWindow)(HWND * phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   // IOleInPlaceUIWindow stuff
   STDMETHOD(GetBorder)(LPRECT lprectBorder);
   STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS pborderwidths);
   STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS pborderwidths);
   STDMETHOD(SetActiveObject)(
        IOleInPlaceActiveObject * pActiveObject,
        LPCOLESTR                 pszObjName);

   // IOleInPlaceFrame stuff
   STDMETHOD(InsertMenus)(
        HMENU                hmenuShared,
        LPOLEMENUGROUPWIDTHS lpMenuWidths);

   STDMETHOD(SetMenu)(
        HMENU    hmenuShared,
        HOLEMENU holemenu,
        HWND     hwndActiveObject);

   STDMETHOD(RemoveMenus)(HMENU hmenuShared);
   STDMETHOD(SetStatusText)(LPCOLESTR pszStatusText);
   STDMETHOD(EnableModeless)(BOOL fEnable);
   STDMETHOD(TranslateAccelerator)(LPMSG lpmsg, WORD wID);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
};

//+---------------------------------------------------------------------------
//
//  Class:      CInPlaceSite ()
//
//  Purpose:    IOleInPlaceSite implementation.
//
//  Interface:  CInPlaceSite         -- ctor
//              QueryInterface       -- get a new interface
//              AddRef               -- bump ref count
//              Release              -- decrement ref count
//              GetWindow            -- returns frame window
//              ContextSensitiveHelp -- never implemented by design
//              CanInPlaceActivate   -- returns S_OK.
//              OnInPlaceActivate    -- caches IOleInPlaceObject ptr
//              OnUIActivate         -- returns S_OK  - sets state
//              GetWindowContext     -- returns IOleInPlaceFrame,
//                                              IOleInPlaceUIWindow,
//                                              PosRect and ClipRect
//              Scroll               -- never implemented by design.
//              OnUIDeactivate       -- obvious
//              OnInPlaceDeactivate  -- releases cached IOleInPlaceObject
//              DiscardUndoState     -- returns S_OK.
//              DeactivateAndUndo    -- deactivates in place active object
//              OnPosRectChange      -- never implemented by design
//
//----------------------------------------------------------------------------
class CInPlaceSite : public IOleInPlaceSite
{
public:
    CInPlaceSite(LPICMOCCtr pCtr);

   // IUnknown stuff
   STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
   STDMETHOD_(ULONG, AddRef)(VOID);
   STDMETHOD_(ULONG, Release)(VOID);

   // IOleWindow stuff
   STDMETHOD(GetWindow)(HWND * phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   // IOleInPlaceSite stuff
   STDMETHOD(CanInPlaceActivate)(VOID);
   STDMETHOD(OnInPlaceActivate)(VOID);
   STDMETHOD(OnUIActivate)(VOID);
   STDMETHOD(GetWindowContext)(
       IOleInPlaceFrame    **ppFrame,
       IOleInPlaceUIWindow **ppDoc,
       LPRECT                prcPosRect,
       LPRECT                prcClipRect,
       LPOLEINPLACEFRAMEINFO pFrameInfo);

   STDMETHOD(Scroll)(SIZE scrollExtant);
   STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
   STDMETHOD(OnInPlaceDeactivate)(VOID);
   STDMETHOD(DiscardUndoState)(VOID);
   STDMETHOD(DeactivateAndUndo)(VOID);
   STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
};

class CPropertyBag : public IPropertyBag
{
public:
    CPropertyBag(LPICMOCCtr pCtr);
   ~CPropertyBag(VOID);

    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

    // IPropertyBag methods.
    STDMETHOD(Read)(LPCOLESTR pszName, LPVARIANT pVar, LPERRORLOG pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszName, LPVARIANT pVar)
    {
        return E_NOTIMPL;
    }

    HRESULT AddPropertyToBag(LPTSTR szName, LPTSTR szValue);

protected:
    CAryBagProps   m_aryBagProps;
    LPICMOCCtr     m_pCtr;
};


//+---------------------------------------------------------------------------
//
//  Class:      CICMOCCtr ()
//
//  Purpose:    This is the one, the big kahuna.  CICMOCCtr is the
//              ICM OLE Controls container that contains a single
//              OLE Control, the FutureSplash OC.  It contains
//              sub-objects which implement the various interfaces
//              we have to support (could have used multiple inheritance,
//              but this seemed more straightforward for our needs).
//
//              Conventions:  Interfaces we implement are contained objects
//                            of a class trivially derived from the interface,
//                            e.g., IOleInPlaceFrame is a contained
//                            instance of CInPlaceFrame called m_IPF.
//
//                            Interfaces we hold on the Future Splash OC
//                            are pointers to the actual OLE interface.
//                            e.g., our pointer to the control's
//                            IOleControl interface is m_pOC.
//
//                            The contained sub-objects are all friends
//                            of the container - they are all conceptually
//                            the same object, but are implemented
//                            separately so as to cause the compiler to
//                            generate the correct vtable.
//
//----------------------------------------------------------------------------
class CICMOCCtr : public IUnknown
{
public:
    friend CInPlaceSite;
    friend CInPlaceFrame;
    friend COleClientSite;
    friend CPropertyBag;

    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

    VOID    Paint(HDC hDC, LPRECT lpr);
    VOID    Paint(VOID);
    HRESULT CreateFSOC(Ole32LinkageStruct *pOle32Link);
    HRESULT GetSize(LPRECT prc);
    HRESULT SetSize(LPRECT prc, BOOL fMoveFrameWindow = TRUE);

    HWND    GetMainWindow(VOID)
    {
        MYDBGASSERT(m_hWndMainDlg && ::IsWindow(m_hWndMainDlg));
        return m_hWndMainDlg;
    }

    HWND    GetFrameWindow(VOID)
    {
        MYDBGASSERT(m_hWndFrame && ::IsWindow(m_hWndFrame));
        return m_hWndFrame;
    }

    LRESULT OnActivateApp(WPARAM wParam, LPARAM lParam);

    //
    //  Whenever we display a modal dialog, we need to let
    //  our embeddings (the WebBrowser OC) know to disable
    //  any modeless dialogs the embedding is displaying.
    //
    VOID    EnableEmbeddingModelessDlgs(BOOL fEnable)
    {
        LPOLEINPLACEACTIVEOBJECT pIPAO = GetIPAObject();
        if (pIPAO)
            pIPAO->EnableModeless(fEnable);
    }

    VOID    DoLayout(INT cxMain, INT cyMain);

    CICMOCCtr(const HWND hWndMainDlg, const HWND hWndFrame);
   ~CICMOCCtr(VOID);
    VOID ShutDown(VOID);

    BOOL Initialized(VOID); 

    OLE_SERVER_STATE GetState(VOID) {return m_state;}
    VOID             SetState(OLE_SERVER_STATE state) {m_state = state;}
    HRESULT          EnableModeless(BOOL fEnable);
    BOOL             ModelessEnabled(VOID){return m_fModelessEnabled;}
    LRESULT          SetFocus(VOID);
    HRESULT          AddPropertyToBag(LPTSTR szName, LPTSTR szValue)
    {
        return m_PB.AddPropertyToBag(szName, szValue);
    }

    VOID MapStateToFrame(ProgState ps);

    HRESULT SetFrame(LONG lFrame);
    VOID    SetFrameMapping(ProgState ps, LONG lFrame)
    {
        m_alStateMappings[ps] = lFrame;
    }

    LPOLEINPLACEACTIVEOBJECT GetIPAObject(VOID) {return m_pActiveObj;}

protected:
    HRESULT _SetExtent(LPRECT prc);
    HRESULT _DisplayStatusText(LPCOLESTR pStrStatusText);
    VOID    _ResetToolSpace(VOID)
    {
        ::memset(&m_rcToolSpace, 0, sizeof m_rcToolSpace);
    }
    VOID    _AdjustForTools(LPRECT prc);

    VOID    _DeactivateControl(VOID);
    HRESULT _TransAccelerator(LPMSG lpmsg, WORD wID);
    VOID    _GetDoVerbRect(LPRECT prc);

                             // map states to frames.
    LONG                     m_alStateMappings[NUMSTATES];
    BORDERWIDTHS             m_rcToolSpace; // for FS OC
    COleClientSite           m_CS;          // clientsite
    CAdviseSink              m_AS;          // advise sink
    CInPlaceFrame            m_IPF;         // inplace frame
    CInPlaceSite             m_IPS;         // inplace site object
    COleContainer            m_OCtr;        // IOleContainer
    CDynamicOleAut           m_DOA;         // Dynamic OLEAUT32   
    CPropertyBag             m_PB;          // IPropertyBag - Must never precede CDynamicOleAut 
    HWND                     m_hWndMainDlg; // hwnd for ICM dialog
    HWND                     m_hWndFrame;   // hWnd that contains OC Site
    LPUNKNOWN                m_pUnk;        // the object itself.
    LPVIEWOBJECT             m_pVO;         // pointer to IViewObject
    LPOLEOBJECT              m_pOO;         // pointer to IOleObject
    LPOLEINPLACEOBJECT       m_pIPO;        // pointer to InPlaceActiveObject
    LPDISPATCH               m_pDisp;       // IDispatch to FS OC
    LPOLEINPLACEACTIVEOBJECT m_pActiveObj;  // current active object
    LPOLECONTROL             m_pOC;         // IOleControl interface for OC
    ULONG                    m_Ref;         // refcount
    OLE_SERVER_STATE         m_state;       // current OLE state of OC
    DWORD                    m_dwMiscStatus;// misc status bits for OC
    BOOL                     m_fModelessEnabled; // OC is putting up modal dlg?
};

extern "C" CLSID const CLSID_FS;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\dialogs.h ===
//+----------------------------------------------------------------------------
//
// File:     dialogs.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This header contains definitions for the dialog UI code.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------
#include "cm_misc.h"
#include "ModalDlg.h"

//+---------------------------------------------------------------------------
//
//  class CInetSignInDlg
//
//  Description: The standalone "Internet Sign-In" dlg
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------


class CInetSignInDlg : public CModalDlg
{
public:
    CInetSignInDlg(ArgsStruct * pArgs);

    virtual void OnOK();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct  *m_pArgs;   // pointer to the huge structure
    static const DWORD m_dwHelp[]; // help id pairs
};

inline CInetSignInDlg::CInetSignInDlg(ArgsStruct * pArgs) : CModalDlg(m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+---------------------------------------------------------------------------
//
//  class CPropertiesPage
//
//  Description: A general properties property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------

class CPropertiesPage : public CWindowWithHelp
{
    friend class CPropertiesSheet;

public:
    CPropertiesPage(UINT nIDTemplate, const DWORD* pHelpPairs = NULL, 
            const TCHAR* lpszHelpFile = NULL); 
    CPropertiesPage(LPCTSTR lpszTemplateName, const DWORD* pHelpPairs = NULL, 
            const TCHAR* lpszHelpFile = NULL); 

    virtual BOOL OnInitDialog();    // WM_INITDIALOG
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam ); // WM_COMMAND

    virtual BOOL OnSetActive();     // PSN_SETACTIVE
    virtual BOOL OnKillActive();    // PSN_KILLACTIVE
    virtual void OnApply();         // PSN_APPLY
    virtual void OnReset();         // PSN_RESET

    // If the derived class need to overwrite thses help function, make this virtual
    void OnPsnHelp(HWND hwndFrom, UINT_PTR idFrom); // PSN_HELP

    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );

protected:
    LPCTSTR m_pszTemplate;  // the resource ID

protected:
    void SetPropSheetResult(DWORD dwResult);
    static INT_PTR CALLBACK PropPageProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
};

//+---------------------------------------------------------------------------
//
//  class CPropertiesSheet
//
//  Description: The properties property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CPropertiesSheet
{
public:
    CPropertiesSheet(ArgsStruct  *pArgs);
    void AddPage(const CPropertiesPage* pPage);
    void AddExternalPage(PROPSHEETPAGE *pPsp);
    BOOL HasPage(const CPropertiesPage* pPage) const;
    int DoPropertySheet(HWND hWndParent, LPTSTR pszCaption,  HINSTANCE hInst);

protected:
    enum {MAX_PAGES = 6};
    enum {CPROP_SHEET_TYPE_INTERNAL = 0, 
        CPROP_SHEET_TYPE_EXTERNAL = 1};
    PROPSHEETHEADER m_psh;  // propertysheet header
    PROPSHEETPAGE m_pages[MAX_PAGES]; // property pages array
    DWORD m_adwPageType[MAX_PAGES]; // property page type
    UINT m_numPages;        // number of property pages
    ArgsStruct  *m_pArgs;

public:
    TCHAR* m_lpszServiceName;  // the profile name, used as the mutex name for OK

protected:
    static LRESULT CALLBACK SubClassPropSheetProc(HWND hwnd, UINT uMsg, WPARAM wParam,LPARAM lParam);
    static int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam);
    static WNDPROC m_pfnOrgPropSheetProc; // Original propertysheet wnd proc before subclass

    // pointer to the property sheet which can be accessed by static function.
    // Not works quite safe, if there are multiple instance of CPropertySheet.
    // Should be protected by CriticalSection.
    static CPropertiesSheet* m_pThis;  
};

//
// Inline functions
//

inline CPropertiesSheet::CPropertiesSheet(ArgsStruct  *pArgs)
{
    m_pArgs = pArgs;
    MYDBGASSERT(m_pArgs);
    ZeroMemory(m_pages, sizeof(m_pages));
    m_numPages = 0;
    ZeroMemory((LPVOID)m_adwPageType, sizeof(m_adwPageType));
}

inline void CPropertiesPage::SetPropSheetResult(DWORD dwResult)
{
    SetWindowLongU(m_hWnd, DWLP_MSGRESULT, (LONG_PTR)dwResult);
}

class CInetPage;
//+---------------------------------------------------------------------------
//
//  class CGeneralPage
//
//  Description: A dialing property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CGeneralPage :public CPropertiesPage
{
public:
    CGeneralPage(ArgsStruct* pArgs, UINT nIDTemplate);
    void SetEventListener(CInetPage* pEventListener) {m_pEventListener = pEventListener;}

protected:
    virtual BOOL OnInitDialog();
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam );
    virtual void OnApply();
    virtual BOOL OnKillActive();    // PSN_KILLACTIVE

    void OnDialingProperties();
    void OnPhoneBookButton(UINT nPhoneIdx);
    BOOL DisplayMungedPhone(UINT uiPhoneIdx);
    BOOL CheckTapi(TapiLinkageStruct *ptlsTapiLink, HINSTANCE hInst);
    DWORD InitDialInfo();
    void EnableDialupControls(BOOL fEnable);
    void ClearUseDialingRules(int iPhoneNdx);
    void UpdateDialingRulesButton(void);
    void UpdateNumberDescription(int nPhoneIdx, LPCTSTR pszDesc);
    
    //
    //  Access Points
    //
    void UpdateForNewAccessPoint(BOOL fSetPhoneNumberDescriptions);
    BOOL AccessPointInfoChanged();
    void DeleteAccessPoint();
    void AddNewAPToReg(LPTSTR pszNewAPName, BOOL fRefreshUiWwithCurrentValues);
    
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );
    enum {WM_INITDIALINFO = WM_USER+1}; // message posted to itself to load dial info

protected:
    ArgsStruct* m_pArgs;    // pointer to the huge structure
    PHONEINFO   m_DialInfo[MAX_PHONE_NUMBERS]; // local copy of dial info, 

    UINT        m_NumPhones;    // Number of phone # to display (1 for connectoid dialing)
    TCHAR       m_szDeviceName[RAS_MaxDeviceName+1];  // modem device name
    TCHAR       m_szDeviceType[RAS_MaxDeviceName+1];  // device type
    CInetPage*  m_pEventListener;           // the object to receive event on this page
    BOOL        m_bDialInfoInit; // whether we have loaded dialing information

    static const DWORD m_dwHelp[]; // help id pairs

    BOOL        m_bAPInfoChanged; // whether Access point information has changed
    
protected:
    static LRESULT CALLBACK SubClassEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static WNDPROC m_pfnOrgEditWndProc;  // the original phone # edit window proc for subclassing
};

//+---------------------------------------------------------------------------
//
//  class CInetPage
//
//  Description: The internet sign-on property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CInetPage :public CPropertiesPage
{
public:
    CInetPage(ArgsStruct* pArgs, UINT nIDTemplate);
    void OnGeneralPageKillActive(BOOL fDirect);

    //
    // The following functions are shared with CInetSignInDlg,
    // For simplicity, we makes them static member function of class CInetPage
    // instead of having another class
    //
    static void OnInetInit(HWND hwndDlg, ArgsStruct *pArgs);
    static void OnInetOk(HWND hwndDlg, ArgsStruct  *pArgs);
    static void AdjustSavePasswordCheckBox(HWND hwndCheckBox, BOOL fEmptyPassword, 
                           BOOL fDialAutomatically, BOOL fPasswordOptional);

protected:
    virtual BOOL OnInitDialog();
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam );
    virtual void OnApply();
    virtual BOOL OnSetActive();     // PSN_SETACTIVE

protected:
    ArgsStruct* m_pArgs;// pointer to the huge structure
    BOOL m_fDirect;     // the current connection type selection in General page
    BOOL m_fPasswordOptional; // whether the PasswordOptional flag is set in 
                              // the profile

    static const DWORD m_dwHelp[]; // help id pairs
};

//+---------------------------------------------------------------------------
//
//  class COptionPage
//
//  Description: The options property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class COptionPage :public CPropertiesPage
{
public:
    COptionPage(ArgsStruct* pArgs, UINT nIDTemplate);

protected:
    virtual BOOL OnInitDialog();
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam ); // WM_COMMAND
    virtual void OnApply();

    void  InitIdleTimeList(HWND hwndList, DWORD dwMinutes);
    DWORD GetIdleTimeList(HWND hwndList);
    BOOL ToggleLogging();

protected:
    ArgsStruct* m_pArgs; // pointer to the huge structure
    BOOL        m_fEnableLog;  // is logging enabled

    static const DWORD m_dwHelp[]; // help id pairs
    static const DWORD m_adwTimeConst[]; // = {0,1, 5, 10, 30, 1*60, 2*60, 4*60, 24*60};
    static const int m_nTimeConstElements;// = sizeof(adwTimeConst)/sizeof(adwTimeConst[0]);

};

//+---------------------------------------------------------------------------
//
//  class CVpnPage
//
//  Description: The VPN property page class
//
//  History:    quintinb Created     10/26/00
//
//----------------------------------------------------------------------------
class CVpnPage :public CPropertiesPage
{
public:
    CVpnPage(ArgsStruct* pArgs, UINT nIDTemplate);

protected:
    virtual BOOL OnInitDialog();
    virtual void OnApply();

protected:
    ArgsStruct* m_pArgs; // pointer to the huge structure

    static const DWORD m_dwHelp[]; // help id pairs
};

//+---------------------------------------------------------------------------
//
//  class CAboutPage
//
//  Description: The about property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CAboutPage :public CPropertiesPage
{
public:
    CAboutPage(ArgsStruct* pArgs, UINT nIDTemplate);

protected:
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive(); 
    virtual BOOL OnKillActive(); 
    virtual void OnApply();
    virtual void OnReset(); 
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct  *m_pArgs;   // pointer to the huge structure
};


//+---------------------------------------------------------------------------
//
//  class CChangePasswordDlg
//
//  Description: The network change password dlg
//
//  History:    v-vijayb    Created   7/3/99
//
//----------------------------------------------------------------------------


class CChangePasswordDlg : public CModalDlg
{
public:
    CChangePasswordDlg(ArgsStruct *pArgs);

    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct *m_pArgs;
};

inline CChangePasswordDlg::CChangePasswordDlg(ArgsStruct *pArgs) : CModalDlg()
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+---------------------------------------------------------------------------
//
//  class CCallbackNumberDlg
//
//  Description: Emulation of the RAS Callback Number dialog
//
//  History:    nickball    Created   3/1/00
//
//----------------------------------------------------------------------------

class CCallbackNumberDlg : public CModalDlg
{
public:
    CCallbackNumberDlg(ArgsStruct *pArgs);

    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct *m_pArgs;
};

inline CCallbackNumberDlg::CCallbackNumberDlg(ArgsStruct *pArgs) : CModalDlg()
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+---------------------------------------------------------------------------
//
//  class CRetryAuthenticationDlg
//
//  Description: Emulation of the RAS Retry authentication dialog
//
//  History:    nickball    Created   3/1/00
//
//----------------------------------------------------------------------------

class CRetryAuthenticationDlg : public CModalDlg
{
public:
    CRetryAuthenticationDlg(ArgsStruct *pArgs); 

    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );
    virtual UINT GetDlgTemplate();

protected:
    ArgsStruct *m_pArgs;
    BOOL        m_fInetCredentials;
    static const DWORD m_dwHelp[]; // help id pairs
};


inline CRetryAuthenticationDlg::CRetryAuthenticationDlg(ArgsStruct *pArgs) 
       : CModalDlg(m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    
    m_pArgs = pArgs;   

    if (m_pArgs)
    {
        //
        // If the phone number calls for a tunnel, and we're not using 
        // UseSameUserName and we're not actively dialing the tunnel,
        // then we must be dialing the Inet portion of the connection.
        //        
        
        m_fInetCredentials = (!m_pArgs->fUseSameUserName &&
                              !IsDialingTunnel(m_pArgs) && 
                              UseTunneling(m_pArgs, m_pArgs->nDialIdx));
    }
}

//+---------------------------------------------------------------------------
//
//	class CNewAccessPointDlg
//
//	Description: Dialog to get the name of a new Access Point from the user
//
//	History:	t-urama    Created   8/2/00
//
//----------------------------------------------------------------------------

class CNewAccessPointDlg : public CModalDlg
{
public:
    CNewAccessPointDlg(ArgsStruct *pArgs, LPTSTR *ppAPName);

    virtual void OnOK();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
	LPTSTR *m_ppszAPName;
	ArgsStruct *m_pArgs;
    static LRESULT CALLBACK SubClassEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static WNDPROC m_pfnOrgEditWndProc;  // the original edit control window proc for subclassing
    
};

inline CNewAccessPointDlg::CNewAccessPointDlg(ArgsStruct *pArgs, LPTSTR *ppszAPName) : CModalDlg()
{
    MYDBGASSERT(pArgs);
    
    m_pArgs = pArgs;   

    m_ppszAPName = ppszAPName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\dialogs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     dialogs.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the code for the implementing the Dialog UI
//           functionality of Connection Manager.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb    Created Header   8/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "dialogs.h"
#include "pnpuverp.h"
#include "dial_str.h"
#include "mon_str.h"
#include "stp_str.h"
#include "ras_str.h"
#include "profile_str.h"
#include "log_str.h"
#include "tunl_str.h"
#include "userinfo_str.h"

#include "cmsafenet.h"

//
//  Get the common function HasSpecifiedAccessToFileOrDir
//
#include "hasfileaccess.cpp"

#include <pshpack1.h>
typedef struct DLGTEMPLATEEX
{
    WORD dlgVer;
    WORD signature;
    DWORD helpID;
    DWORD exStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// Timeout for the write properties mutex, in milliseconds
//
const DWORD WRITE_PROPERTIES_MUTEX_TIMEOUT = 1000*10;

//************************************************************************
// Globals
//************************************************************************

//
// Original edit control and property sheet window procedures
//

WNDPROC CGeneralPage::m_pfnOrgEditWndProc = NULL;
WNDPROC CNewAccessPointDlg::m_pfnOrgEditWndProc = NULL;
WNDPROC CPropertiesSheet::m_pfnOrgPropSheetProc = NULL;            // prop sheet
CPropertiesSheet* CPropertiesSheet::m_pThis = NULL; 

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::UpdateNumberDescription
//
//  Synopsis:   Helper function to deal with updating the description edit,
//              by appending to the Phone Number: and Backup Number: labels
//
//  Arguments:  int nPhoneIdx - index of phone number to which this applies
//
//  Returns:    Nothing
//
//  History:    nickball - Created - 7/17/97
//
//----------------------------------------------------------------------------

void CGeneralPage::UpdateNumberDescription(int nPhoneIdx, LPCTSTR pszDesc)
{
    MYDBGASSERT(pszDesc);
    
    if (NULL == pszDesc)
    {
        return;
    }

    UINT nDescID = !nPhoneIdx ? IDC_GENERAL_P1_STATIC: IDC_GENERAL_P2_STATIC;
    
    LPTSTR pszTmp;

    //
    // Load the appropriate label as a base string
    //

    if (nPhoneIdx)
    {
        pszTmp = CmLoadString(g_hInst, IDS_BACKUP_NUM_LABEL);
    }
    else
    {
        pszTmp = CmLoadString(g_hInst, IDS_PHONE_NUM_LABEL);
    }
    
    MYDBGASSERT(pszTmp);

    if (pszTmp)
    {
        //
        // Append the description and display
        //

        if (*pszDesc)
        {
            pszTmp = CmStrCatAlloc(&pszTmp, TEXT("  "));
            pszTmp = CmStrCatAlloc(&pszTmp, pszDesc);
        }

        SetDlgItemTextU(m_hWnd, nDescID, pszTmp);
    }

    CmFree(pszTmp);
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::ClearUseDialingRules
//
//  Synopsis:   Helper function to deal with disabling the check box and 
//              reseting the state for UseDialingRules.
//
//  Arguments:  iPhoneNdx - index of phone number to which this applies
//
//  Returns:    Nothing
//
//  History:    nickball - Created - 7/17/97
//
//----------------------------------------------------------------------------
void CGeneralPage::ClearUseDialingRules(int iPhoneNdx)
{
    MYDBGASSERT(iPhoneNdx ==0 || iPhoneNdx ==1);
    //
    // Uncheck and disable the appropriate "Use Dialing Rules" checkbox
    //
   
    if (0 == iPhoneNdx)
    {
        CheckDlgButton(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX, FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX), FALSE);
    }
    else
    {
        CheckDlgButton(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX, FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX), FALSE);
    }

    m_DialInfo[iPhoneNdx].dwPhoneInfoFlags &= ~PIF_USE_DIALING_RULES;

    UpdateDialingRulesButton();
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::UpdateDialingRulesButton
//
//  Synopsis:   Helper function to deal with enabling/disabling the 
//              DialingRules button according to whether dialing rules
//              is being applied to either primary or backup number.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  History:    nickball - Created - 12/14/98
//
//----------------------------------------------------------------------------
void CGeneralPage::UpdateDialingRulesButton(void)
{
    BOOL fDialingRules = (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX) && 
                          IsWindowEnabled(GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX))
                         ) ||
                         (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX) && 
                          IsWindowEnabled(GetDlgItem(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX))
                         );

    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON), fDialingRules);
}

//+---------------------------------------------------------------------------
//
//  Function:   DoPropertiesPropSheets
//
//  Synopsis:   Pop up the Properties property sheets.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    PropertySheet return value
//
//  History:    henryt  Created     3/5/97
//
//----------------------------------------------------------------------------
int DoPropertiesPropSheets(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
)
{
    CPropertiesSheet PropertiesSheet(pArgs);
    CInetPage* pInetPage = NULL;
    CAboutPage* pAboutPage = NULL; 
    COptionPage* pOptionPage = NULL;
    CGeneralPage* pGeneralPage = NULL;
    CVpnPage* pVpnPage = NULL;
    HRESULT hr;
    BOOL bCOMInitialized = FALSE;
    HINSTANCE hinstDll = NULL;

    typedef HRESULT (*pfnGetPageFunction) (PROPSHEETPAGEW *, GUID *);

    CMTRACE(TEXT("Begin DoPropertiesPropSheets()"));

    //
    // Always start by adding the General page
    //

    if (pArgs->IsBothConnTypeSupported() || !pArgs->IsDirectConnect())
    {
        //
        // If both dial-up and direct is supported, use the appropriate
        // template for the general property page. 
        //

        UINT uiMainDlgID;  

        //
        // The general page is always access point aware
        //
        uiMainDlgID = pArgs->IsBothConnTypeSupported() ? IDD_GENERAL_DIRECT : IDD_GENERAL;

        pGeneralPage = new CGeneralPage(pArgs, uiMainDlgID);
        
        if (pGeneralPage)
        {
            PropertiesSheet.AddPage(pGeneralPage);

            //
            //  Create the balloon tip object
            //
            pArgs->pBalloonTip = new CBalloonTip();
        }

        //
        // Show the Internet Sign-In tab if we're tunneling and 
        // Inet username/password is different than main sign-on username/password
        // Also, if either the username or password are NOT to be hidden, we 
        // display the tab.
        //

        if (IsTunnelEnabled(pArgs) && !pArgs->fUseSameUserName) 
        {
            if (!pArgs->fHideInetUsername || !pArgs->fHideInetPassword)
            {
                //
                // Determine which template to use based hide flags
                //

                UINT uiTemplateID = IDD_INET_SIGNIN;

                if (pArgs->fHideInetUsername)
                {
                    uiTemplateID = IDD_INET_SIGNIN_NO_UID;
                }
                else if (pArgs->fHideInetPassword)
                {
                    uiTemplateID = IDD_INET_SIGNIN_NO_PWD;
                }
                
                //
                // Create the page
                //

                pInetPage = new CInetPage(pArgs, uiTemplateID);

                if (pInetPage)
                {
                    PropertiesSheet.AddPage(pInetPage);

                    if (pGeneralPage)
                    {
                        //
                        // To receive event from General Page
                        //
                        pGeneralPage->SetEventListener(pInetPage);
                    }
                }
            }
        }
    }

    //
    //  Add the VPN selector tab if we are tunneling and have a VPN phonebook
    //  specified.
    //
    if (IsTunnelEnabled(pArgs) && pArgs->pszVpnFile)
    {
        pVpnPage = new CVpnPage(pArgs, IDD_VPN);

        if (pVpnPage)
        {
            PropertiesSheet.AddPage(pVpnPage);
        }
    }

    //
    // Always include Options page
    //
    pOptionPage = new COptionPage(pArgs, IDD_OPTIONS);
    
    if (pOptionPage)
    {
        PropertiesSheet.AddPage(pOptionPage);
    }

#ifndef _WIN64
    //
    // Add the Advanced (Internet Connection Firewall & Internet Connection
    // Sharing) property page. Display only on WindowsXP and x86. If an error occurs
    // fail gracefully & continue.
    //

    //
    // Check if this is WindowsXP and/or above and if we are allowed to display the tab
    // 
    if (OS_NT51 && pArgs->bShowHNetCfgAdvancedTab && (FALSE == IsLogonAsSystem()))  
    {
        PROPSHEETPAGEW psp;
        
        ZeroMemory (&psp, sizeof(psp));
        psp.dwSize = sizeof(psp); 
        //
        // Make sure COM is initialized on this thread.
        // Win95 can't find an entry in ole32.dll for CoInitializeEx since we statically link 
        // the lib. Need to use CoInitilize because it needs to run on plain vanilla 
        // Win95. Possibly we should dynamically load the dll in this case.
        //
        hr = CoInitialize(NULL);
        if (S_OK == hr)
        {
            CMTRACE(TEXT("DoPropertiesPropSheets - Correctly Initialized COM."));
            bCOMInitialized = TRUE;
        }
        else if (S_FALSE == hr)
        {
            CMTRACE(TEXT("DoPropertiesPropSheets - This concurrency model is already initialized. CoInitialize returned S_FALSE."));
            bCOMInitialized = TRUE;
            hr = S_OK;
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            CMTRACE1(TEXT("DoPropertiesPropSheets - Using different concurrency model. Did not initialize COM - RPC_E_CHANGED_MODE. hr=0x%x"), hr);
            hr = S_OK;
        }
        else
        {
            CMTRACE1(TEXT("DoPropertiesPropSheets - Failed to Initialized COM. hr=0x%x"), hr);
        }
    
        if (SUCCEEDED(hr))
        {
            CMTRACE(TEXT("DoPropertiesPropSheets - Get connection GUID."));
            GUID *pGuid = NULL;
            LPRASENTRY pRasEntry = MyRGEP(pArgs->pszRasPbk, pArgs->szServiceName, &pArgs->rlsRasLink);

            if (pRasEntry && sizeof(RASENTRY_V501) >= pRasEntry->dwSize)
            {
                //
                // Get the pGuid value
                //
                pGuid = &(((LPRASENTRY_V501)pRasEntry)->guidId);
            
                hinstDll = LoadLibrary (TEXT("hnetcfg.dll"));
                if (NULL == hinstDll)
                {
                    CMTRACE1(TEXT("DoPropertiesPropSheets - could not LoadLibray hnetcfg.dll GetLastError() = 0x%x"), 
                             GetLastError());
                }
                else 
                {
                    CMTRACE(TEXT("DoPropertiesPropSheets - Loaded Library hnetcfg.dll"));
                    pfnGetPageFunction pfnGetPage = (pfnGetPageFunction)GetProcAddress (hinstDll, "HNetGetFirewallSettingsPage");

                    if (!pfnGetPage)
                    {
                        CMTRACE1(TEXT("DoPropertiesPropSheets - GetProcAddress for HNetGetFirewallSettingsPage failed! 0x%x"), 
                                 GetLastError());
                    }
                    else
                    {
                        //
                        // Get the actual Property Sheet Page
                        // This function can fail if the user doesn't have the correct 
                        // security settings (eg. is not an Administrator) This is checked
                        // internally in the hnetcfg.dll 
                        //
                        CMTRACE(TEXT("DoPropertiesPropSheets - calling HNetGetFirewallSettingsPage"));
                        
                        hr = pfnGetPage(&psp, pGuid);
                        if (S_OK == hr)
                        {
                            //
                            // Add the Property Sheet Page into our PropertiesSheet object
                            //
                            PropertiesSheet.AddExternalPage(&psp);
                            CMTRACE(TEXT("DoPropertiesPropSheets - Called AddExternalPage() "));
                        }
                        else
                        {
                            //
                            // This error could be ERROR_ACCESS_DENIED which is ok
                            // so just log this. The tab will not be displayed in this case
                            // 
                            if ((HRESULT)ERROR_ACCESS_DENIED == hr)
                            {
                                CMTRACE(TEXT("DoPropertiesPropSheets() - ERROR_ACCESS_DENIED. User does not have the security rights to view this tab."));
                            }
                            else
                            {
                                CMTRACE1(TEXT("DoPropertiesPropSheets() - Failed to get Propery Page. hr=0x%x"), hr);
                            }
                        }
                    }
                }
            }
            else
            {
                CMTRACE(TEXT("DoPropertiesPropSheets - Failed to LoadRAS Entry."));
            }
        
            CmFree(pRasEntry);
            pRasEntry = NULL;
        }
    }
#endif // _WIN64

    //
    // If NOT NT5, set the about page as the last property sheet 
    //

    if (!(OS_NT5))       
    {
        pAboutPage = new CAboutPage(pArgs, IDD_ABOUT); 
        
        if (pAboutPage)
        {
            PropertiesSheet.AddPage(pAboutPage);
        }
    }

    //
    // The service name used as mutex name
    //
    PropertiesSheet.m_lpszServiceName = CmStrCpyAlloc(pArgs->szServiceName);

    //
    // Set the title for the sheet
    //
    LPTSTR pszTitle = GetPropertiesDlgTitle(pArgs->szServiceName);

    if (OS_W9X)
    {
        //
        //  If this is Win9x then we will call the ANSI version of the
        //  property sheet function.  Thus we must pass it an ANSI title.
        //  Since the ANSI and Unicode version of the Prop Sheet Header are
        //  the same size (contains only string pointers not strings) whether
        //  ANSI or Unicode and we only have one Unicode string, lets take
        //  a shortcut and cast the title to an ANSI string and then call the
        //  A version of the API.  This saves us having to have a UtoA function
        //  for the prop sheets when we would only be doing one string conversion.
        //
        LPSTR pszAnsiTitle = WzToSzWithAlloc(pszTitle);        
        CmFree(pszTitle);
        pszTitle = (LPTSTR)pszAnsiTitle;         
    }

    //
    //  Show it!
    //

    int iRet =  PropertiesSheet.DoPropertySheet(hwndDlg, pszTitle, g_hInst);

    CmFree(pszTitle);

    switch(iRet)
    {
    case -1:
        CMTRACE(TEXT("DoPropertiesPropSheets(): PropertySheet() failed"));
        break;

    case IDOK:
        CheckConnectionAndInformUser(hwndDlg, pArgs);
        break;

    case 0 :  // Cancel
        break;

    default:
        MYDBGASSERT(FALSE);
        break;
    }

    delete pInetPage;
    delete pAboutPage;
    delete pOptionPage;
    delete pGeneralPage;
    delete pVpnPage;

    //
    //  Clean up the BalloonTip object if we have one
    //
    delete pArgs->pBalloonTip;
    pArgs->pBalloonTip = NULL;

    CmFree (PropertiesSheet.m_lpszServiceName);
    PropertiesSheet.m_lpszServiceName = NULL;


    //
    // Clean up and Uninitilize COM
    //
    if (hinstDll)
    {
        FreeLibrary (hinstDll);
    }
    
    if (bCOMInitialized)
    {
        CoUninitialize(); 
    }

    CMTRACE(TEXT("End DoPropertiesPropSheets()"));

    return iRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CheckConnectionAndInformUser
//
// Synopsis:  This function is called after the user clicked OK on the 
//            Properties dialog.  The Prop dialog can be up while the same
//            profile is connected and so we need to tell the user that
//            the changes won't be effective until the next time they connect.
//
// Arguments: hwnDlg - hwnd of the main dlg
//            pArgs
//
// Returns:   None
//
//+----------------------------------------------------------------------------

void CheckConnectionAndInformUser(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
)
{
    CM_CONNECTION Connection;

    ZeroMemory(&Connection, sizeof(CM_CONNECTION));

    if (SUCCEEDED(pArgs->pConnTable->GetEntry(pArgs->szServiceName, &Connection)) &&
        Connection.CmState == CM_CONNECTED)
    {
        LPTSTR  pszTmp = CmLoadString(g_hInst, IDMSG_EFFECTIVE_NEXT_TIME);
        MessageBox(hwndDlg, pszTmp, pArgs->szServiceName, MB_OK | MB_ICONINFORMATION);
        CmFree(pszTmp);
    }
}



const DWORD CInetSignInDlg::m_dwHelp[] = {
        IDC_INET_USERNAME_STATIC,   IDH_INTERNET_USER_NAME,
        IDC_INET_USERNAME,          IDH_INTERNET_USER_NAME,
        IDC_INET_PASSWORD_STATIC,   IDH_INTERNET_PASSWORD,
        IDC_INET_PASSWORD,          IDH_INTERNET_PASSWORD,
        IDC_INET_REMEMBER,          IDH_INTERNET_SAVEPASS,
        0,0};



//+----------------------------------------------------------------------------
//
// Function:  CInetSignInDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CInetSignInDlg::OnInitDialog()
{
    //
    // Brand the dialog
    //

    if (m_pArgs->hSmallIcon)
    {
        SendMessageU(m_hWnd, WM_SETICON, ICON_SMALL, (LPARAM) m_pArgs->hSmallIcon);
    }

    if (m_pArgs->hBigIcon)
    {        
        SendMessageU(m_hWnd, WM_SETICON, ICON_BIG, (LPARAM) m_pArgs->hBigIcon); 
        SendMessageU(GetDlgItem(m_hWnd, IDC_INET_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM) m_pArgs->hBigIcon); 
    }

    //
    // Use should not see this dialog, if the password is optional
    //

    MYDBGASSERT(!m_pArgs->piniService->GPPB(c_pszCmSection,c_pszCmEntryPwdOptional));

    UpdateFont(m_hWnd);

    CInetPage::OnInetInit(m_hWnd, m_pArgs);

    //
    // if the username is empty, then we disable the OK button.
    //
    
    if (GetDlgItem(m_hWnd, IDC_INET_USERNAME) &&
        !SendDlgItemMessageU(m_hWnd, IDC_INET_USERNAME, WM_GETTEXTLENGTH, 0, (LPARAM)0))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
    }
        
    if (GetDlgItem(m_hWnd, IDC_INET_PASSWORD) &&
        !SendDlgItemMessageU(m_hWnd, IDC_INET_PASSWORD, WM_GETTEXTLENGTH, 0, (LPARAM)0))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
    }

    //
    // We wouldn't be here unless data was missing, so set focus accordingly
    //

    if (!m_pArgs->fHideInetUsername && !*m_pArgs->szInetUserName)
    {
        SetFocus(GetDlgItem(m_hWnd, IDC_INET_USERNAME));
    }
    else
    {
        SetFocus(GetDlgItem(m_hWnd, IDC_INET_PASSWORD));
    }

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
}



//+----------------------------------------------------------------------------
//
// Function:  CInetSignInDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CInetSignInDlg::OnOK()
{
    CInetPage::OnInetOk(m_hWnd, m_pArgs);   
    EndDialog(m_hWnd, TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CInetSignInDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CInetSignInDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
        case IDC_INET_USERNAME:
        case IDC_INET_PASSWORD:
            //
            // User typed something in username or password
            //
            if (HIWORD(wParam) == EN_CHANGE) 
            {
                BOOL fHasUserName = TRUE;
                
                if (GetDlgItem(m_hWnd, IDC_INET_USERNAME)) 
                {
                    fHasUserName = !!SendDlgItemMessageU(m_hWnd, 
                                                         IDC_INET_USERNAME, 
                                                         WM_GETTEXTLENGTH, 0, 0);
                }

                BOOL fHasPassword = TRUE;
                
                if (GetDlgItem(m_hWnd, IDC_INET_PASSWORD)) 
                {
                    fHasPassword = !!SendDlgItemMessageU(m_hWnd, 
                                                         IDC_INET_PASSWORD,
                                                         WM_GETTEXTLENGTH, 0, 0);
                }

                //
                // Enable OK button only if both user name and password is available
                //
                
                EnableWindow(GetDlgItem(m_hWnd, IDOK), fHasUserName && fHasPassword);
                
                if (!m_pArgs->fHideRememberInetPassword  && !m_pArgs->fHideInetPassword)
                {
                    //
                    // Enable/Disable check/uncheck the "Save Password" accordingly
                    // fPasswordOptional is always FALSE for the dialog
                    //
                    CInetPage::AdjustSavePasswordCheckBox(GetDlgItem(m_hWnd, IDC_INET_REMEMBER), 
                            !fHasPassword, m_pArgs->fDialAutomatically, FALSE);
                }
            }
            break;

    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::SubClassEditProc
//
//  Synopsis:   Proc to subclass the edit controls in the Dial propsheet.
//
//  Arguments:  hwnd [wnd handle]
//              uMsg [wnd msg]
//              lParam [LPARAM]
//              wParam [WPARAM]
//
//  Returns:    NONE
//
//  History:    henryt      Created     3/24/97
//              byao        Modified    4/3/97   Added new code to handle description field,
//                                               phone number field, etc.
//              henryt      Modified    5/1/97   New UI.
//              nickball    Modified    6/18/97  Moved GetParent call and added
//                                               NC_DESTROY handling for CM16
//              nickball    Modified    7/10/97  Commented out removal of description
//              nickball    Modified    7/10/97  Implemented ClearDialAsLongDistance
//              fengsun     Modified    11/3/97  Changed into static member function
//              nickball    Modified    09/16/98 Renamed ClearDialAsLongDistance to ClearUseDialingRules
//----------------------------------------------------------------------------
LRESULT CALLBACK CGeneralPage::SubClassEditProc(HWND hwnd, UINT uMsg, 
                                                WPARAM wParam, LPARAM lParam)
{
    //
    // If user types a non-tapi character Beep and do not accept that character
    //

    if ((uMsg == WM_CHAR)  && (VK_BACK != wParam))
    {
        if (!IsValidPhoneNumChar((TCHAR)wParam))
        {

            Beep(2000, 100);
            return 0;
        }
    }

    // 
    // Call the original window procedure for default processing. 
    //
    LRESULT lres = CallWindowProcU(m_pfnOrgEditWndProc, hwnd, uMsg, wParam, lParam); 

    //
    // if the user is typing a phone # in the edit control, then there is
    // no phone book file associated with the #.
    // make sure we ignore CTRL-C(VK_CANCEL) because the user is just doing a copy.
    //
    if ( ( uMsg == WM_CHAR && wParam != VK_CANCEL ) || 
         ( uMsg == WM_KEYDOWN && wParam == VK_DELETE) ||
         ( uMsg == WM_PASTE)) 
    {
        //
        // Either primary or backup edit control
        // 
        DWORD dwControlId = (DWORD) GetWindowLongU(hwnd, GWL_ID);
        MYDBGASSERT(dwControlId == IDC_GENERAL_PRIMARY_EDIT ||
                    dwControlId == IDC_GENERAL_BACKUP_EDIT);

        //
        // Get the object pointer saved by SetWindowLong
        //
        CGeneralPage* pGeneralPage = (CGeneralPage*)GetWindowLongU(hwnd, GWLP_USERDATA);
        MYDBGASSERT(pGeneralPage);

        pGeneralPage->ClearUseDialingRules(dwControlId == IDC_GENERAL_PRIMARY_EDIT ? 0 : 1);
    }

    return lres;
}

//+---------------------------------------------------------------------------
//
//  Function:   SubClassPropSheetProc
//
//  Synopsis:   Proc to subclass the parent property sheet dlg.
//
//  Arguments:  hwnd [wnd handle]
//              uMsg [wnd msg]
//              lParam [LPARAM]
//              wParam [WPARAM]
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/11/97
//----------------------------------------------------------------------------
LRESULT CALLBACK CPropertiesSheet::SubClassPropSheetProc(HWND hwnd, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
            //
            // If ok is pressed, save the index of the tab
            // So, the next time user comes to properties, the same tab will be displayed
            //

            if (LOWORD(wParam) == IDOK && HIWORD(wParam) == BN_CLICKED)
            {
                CPropertiesSheet* pPropSheet = (CPropertiesSheet*)GetWindowLongU(hwnd, GWLP_USERDATA);
                MYDBGASSERT(pPropSheet);

                //
                // Declare a mutex to prevent multi-instance write to the same profile 
                //
                CNamedMutex propertiesMutex;

                //
                // Use the profile name as the mutex name
                // If we lock timed out, go ahead and save the properties
                // The destructor of the mutex will release the lock
                //
                MYVERIFY(propertiesMutex.Lock(pPropSheet->m_lpszServiceName, TRUE, WRITE_PROPERTIES_MUTEX_TIMEOUT));

                LRESULT dwRes = CallWindowProcU(m_pfnOrgPropSheetProc, hwnd, uMsg, wParam, lParam); 

                return dwRes;
            }
        case WM_MOVING:
            {
                CPropertiesSheet* pPropSheet = (CPropertiesSheet*)GetWindowLongU(hwnd, GWLP_USERDATA);

                if (pPropSheet && pPropSheet->m_pArgs && pPropSheet->m_pArgs->pBalloonTip)
                {
                    pPropSheet->m_pArgs->pBalloonTip->HideBalloonTip();
                }
            }
            break;
    }

    // 
    // Call the original window procedure for default processing. 
    //
    return CallWindowProcU(m_pfnOrgPropSheetProc, hwnd, uMsg, wParam, lParam); 
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::PropSheetProc
//
// Synopsis:  Callback function for the propertysheet. PSCB_INITIALIZED is 
//            called before any page is initialized.  Initialize the property 
//            page here
//
// Arguments: HWND hwndDlg - PropertySheet window handle
//            UINT uMsg - Message id
//            LPARAM - 
//
// Returns:   int CALLBACK - 
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
int CALLBACK CPropertiesSheet::PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    if (uMsg == PSCB_INITIALIZED)
    {
        MYDBGASSERT(hwndDlg);

        //
        // Save the m_pThis pointer, so it can be accessed by SubClassPropSheetProc
        //
        MYDBGASSERT(m_pThis);
        SetWindowLongU(hwndDlg, GWLP_USERDATA, (LONG_PTR)m_pThis);
        m_pThis = NULL;

        //
        // subclass the property sheet
        //
        m_pfnOrgPropSheetProc = (WNDPROC)SetWindowLongU(hwndDlg, GWLP_WNDPROC, (LONG_PTR)SubClassPropSheetProc);
    }

    return 0;
}


//+----------------------------------------------------------------------------
//
//  Function    CGeneralPage::DisplayMungedPhone
//
//  Synopsis    Apply TAPI rules to the phone number, and then display it
//              in the edit control
//
//  Arguments   uiPhoneIdx                  The index of the phone #
//
//  Returns     FALSE if the number can't be munged
//
//  History     4/2/97          byao    Modified to current implementation
//              4/30/97         henryt  added/deleted params
//              5/17/97         VetriV  Added functionality to return
//                                      displayable number
//              11/3/97         fengsun Changed into member function
//
//-----------------------------------------------------------------------------
BOOL CGeneralPage::DisplayMungedPhone(UINT uiPhoneIdx) 
{
    LPTSTR pszPhone;
    LPTSTR pszTmpDialableString = NULL;
    BOOL bRet = TRUE;

    //
    // If DialingRules is turned off, just use what we already have, no munge.
    //
    
    if (m_pArgs->fNoDialingRules)
    {
        lstrcpynU(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber, m_DialInfo[uiPhoneIdx].szPhoneNumber, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber));

        lstrcpynU(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber, m_DialInfo[uiPhoneIdx].szPhoneNumber, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber));
        
        m_DialInfo[uiPhoneIdx].szCanonical[0] = TEXT('\0');

        SetDlgItemTextU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), m_DialInfo[uiPhoneIdx].szPhoneNumber);
        return TRUE;
    }

    //
    // Retrieve the canonical form of the number for munging
    //
    pszPhone = CmStrCpyAlloc(m_DialInfo[uiPhoneIdx].szCanonical); 

    if (pszPhone) 
    {
        if (*pszPhone && m_szDeviceName[0])
        {
            // 
            // Apply tapi rules only when there's a modem selected. We now munge the phone
            // even if there is no description because we want to pick up tone and pulse.
            //
            if (ERROR_SUCCESS != MungePhone(m_szDeviceName, 
                                            &pszPhone, 
                                            &m_pArgs->tlsTapiLink, 
                                            g_hInst,
                                            m_DialInfo[uiPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES, 
                                            &pszTmpDialableString,
                                            m_pArgs->fAccessPointsEnabled)) 
            {
                //
                // Munge failed, make sure that ptrs are valid, albeit empty
                //

                CmFree(pszPhone);
                pszPhone = CmStrCpyAlloc(TEXT(""));             // CmFmtMsg(g_hInst, IDMSG_CANTFORMAT);
                pszTmpDialableString = CmStrCpyAlloc(TEXT(""));  // CmFmtMsg(g_hInst, IDMSG_CANTFORMAT);                    
                bRet = FALSE;
            }
        }
                       
        //
        // Standard procedure. If Dialing rule are applied, then use the 
        // canonical form (eg. pszPhone). Otherwise use the raw number form.
        //
        
        if (m_DialInfo[uiPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
        {
            //
            // Unique situation in which we have read in a legacy hand-edited 
            // phone number and the default dialing-rules state is TRUE/ON. 
            // We fake out the standard procedure by slipping the raw number
            // into the otherwise blank pszPhone. Note: This occurs only the
            // first time the app. is run until a save is made at which time
            // the current storage format is used.
            //
        
            if (!*pszPhone)
            {
                pszPhone = CmStrCatAlloc(&pszPhone, m_DialInfo[uiPhoneIdx].szPhoneNumber);
            }

            //
            // In this case the pszPhone is dynamically allocated and can be very long. In order to
            // fix this, we need to trim the string if it's longer than what should fit in the UI.
            //
            LRESULT lEditLen = SendDlgItemMessageU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), EM_GETLIMITTEXT, 0, 0);

            if (lstrlenU(pszPhone) >= ((INT)lEditLen))
            {
                pszPhone[lEditLen] = TEXT('\0');
            }

            SetDlgItemTextU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), pszPhone);
        }
        else
        {
            //
            // No need to trim anything, since the structure is providing the phone number. Eventully the 
            // number from the UI will go back into the phone number structure and we know it will fit 
            // since it came from there.
            //
            SetDlgItemTextU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), m_DialInfo[uiPhoneIdx].szPhoneNumber);
        }
    }

    //
    // copy the munged phone to the caller's buffer.
    //
    
    if (pszTmpDialableString)
    {
        lstrcpynU(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber, pszTmpDialableString, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber));
    }

    if (pszPhone)
    {
        lstrcpynU(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber, pszPhone, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber));
    }

    CmFree(pszPhone);
    CmFree(pszTmpDialableString);

    return bRet;
}

//+----------------------------------------------------------------------------
//
//  Function    CGeneralPage::OnDialingProperties
//
//  Synopsis    Handler for handling the "Dialing Properties..." button-click
//              in the 'Dialing' tab.
//
//  Arguments   
//
//  History     4/30/97         henryt  modified for new UI
//              11/3/97         fengsun Change the function name and make it 
//                                  a member ffunction
//              01/29/98        cleaned up memory leak, added comments.    
//
//-----------------------------------------------------------------------------
void CGeneralPage::OnDialingProperties() 
{
    LONG   lRes;
    LPTSTR pszPhone = NULL;
  
    //
    // Use primary or backup to seed tapi dialog depending on whether dialing 
    // rules are being applied to the number. We use the check state rather 
    // than the phone-info flag because of the anomolous first time case in 
    // which the flag is set, but the controls aren't checked.
    //  
    
    if (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX))
    {
        pszPhone = CmStrCpyAlloc(m_DialInfo[0].szCanonical);//szPhoneNumber);
    }
    else if (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX))
    {
        pszPhone = CmStrCpyAlloc(m_DialInfo[1].szCanonical);//szPhoneNumber);   
    }
    else
    {
        pszPhone = CmStrCpyAlloc(TEXT(" "));
    }

    //
    // Launch TAPI dialog for DialingRules configuration
    //

    if (!m_pArgs->tlsTapiLink.pfnlineTranslateDialog) 
    {
        return;
    }
    
    if (!SetTapiDevice(g_hInst,&m_pArgs->tlsTapiLink,m_szDeviceName)) 
    {
        MYDBGASSERT(FALSE);
        return;
    }

    if (OS_W9X)
    {
        //
        // On win9x, we are linked to the ANSI version of lineTranslateDialog, thus
        // we need to convert the string.  In order to keep things simpler, we just
        // cast the converted LPSTR as an LPWSTR and pass it on.
        //

        LPSTR pszAnsiPhone = WzToSzWithAlloc(pszPhone);
        CmFree(pszPhone);
        pszPhone = (LPTSTR)pszAnsiPhone;
    }

    lRes = m_pArgs->tlsTapiLink.pfnlineTranslateDialog(m_pArgs->tlsTapiLink.hlaLine,
                                                       m_pArgs->tlsTapiLink.dwDeviceId,
                                                       m_pArgs->tlsTapiLink.dwApiVersion,
                                                       m_hWnd,
                                                       pszPhone);
    CmFree(pszPhone);

    CMTRACE1(TEXT("OnDialingProperties() lineTranslateDialog() returns %u"), lRes);

    
    //
    // We do not know whether user changed anything (WIN32), so re-munge anyway
    //

    if (lRes == ERROR_SUCCESS)
    {        
        DWORD dwCurrentTapiLoc = GetCurrentTapiLocation(&m_pArgs->tlsTapiLink);

        if (-1 != dwCurrentTapiLoc)
        {
            if (dwCurrentTapiLoc != m_pArgs->tlsTapiLink.dwTapiLocationForAccessPoint)
            {
                 m_bAPInfoChanged = TRUE;
            }

            m_pArgs->tlsTapiLink.dwTapiLocationForAccessPoint = dwCurrentTapiLoc;

            for (UINT i = 0; i < m_NumPhones; i++)
            {
                //
                // Only munge if Use Dialing Rules is available
                //
            
                if (m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
                {
                    DisplayMungedPhone(i);
                }
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CGeneralPage::OnPhoneBookButton
//
//  Synopsis    Handler for handling the "Phone Book..." button-click
//              in the 'Dialing' tab.
//
//  Arguments   nPhoneIdx       phone index
//
//  History     4/30/97         henryt  modified for new UI
//              11/3/97         fengsun Change to a member function
//
//-----------------------------------------------------------------------------
void CGeneralPage::OnPhoneBookButton(UINT nPhoneIdx) 
{
    PBArgs sArgs;
    LPTSTR pszTmp;
    UINT nEditID = !nPhoneIdx ? IDC_GENERAL_PRIMARY_EDIT: IDC_GENERAL_BACKUP_EDIT;
    //UINT nDescID = !nPhoneIdx ? IDC_GENERAL_PRIMARYDESC_DISPLAY: IDC_GENERAL_BACKUPDESC_DISPLAY;
    
    UINT nUdrID = !nPhoneIdx? IDC_GENERAL_UDR1_CHECKBOX : IDC_GENERAL_UDR2_CHECKBOX;
    BOOL bRes;
    UINT uiSrc;
    BOOL bBlankPhone = FALSE;

    memset(&sArgs,0,sizeof(sArgs));

    sArgs.pszCMSFile = m_pArgs->piniService->GetFile();
    
    //
    // Update the attributes of the users phone number selection to reflect
    // any interim changes. This ensures that we will default to the correct
    // service, country and region of the current phone number selection. (4397)
    //  

    if (nPhoneIdx && !GetWindowTextLengthU(GetDlgItem(m_hWnd, nEditID)))
    {
        //
        // if we're changing the backup # and currently the backup # is empty,
        // we use the state and country info of the primary #.
        //
        uiSrc = 0;
    }
    else
    {
        uiSrc = nPhoneIdx;
    }

    lstrcpynU(sArgs.szServiceType, m_DialInfo[uiSrc].szServiceType, CELEMS(sArgs.szServiceType));
    
    sArgs.dwCountryId = m_DialInfo[uiSrc].dwCountryID; 
    
    lstrcpynU(sArgs.szRegionName, m_DialInfo[uiSrc].szRegionName, CELEMS(sArgs.szRegionName));

    sArgs.pszMessage = m_pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryPbMessage);

    //
    //  Check to see if the phone number is blank.  We need to save this off for 
    //  balloon tips to use later.
    //

    if(0 == GetWindowTextLengthU(GetDlgItem(m_hWnd,nEditID)))
    {
        bBlankPhone = TRUE;
    }

    //
    // Make sure that bitmap path is complete
    //

    pszTmp = m_pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryPbLogo);  
    if (pszTmp && *pszTmp)
    {
        sArgs.pszBitmap = CmConvertRelativePath(m_pArgs->piniService->GetFile(), pszTmp);
    }
    CmFree(pszTmp);

    //
    // Include the help file name
    //

    sArgs.pszHelpFile = m_pArgs->pszHelpFile;

    //
    // Need the master palette handle also.
    //

    sArgs.phMasterPalette = &m_pArgs->hMasterPalette;

    //
    // Launch the phonebook dlg
    //

    bRes = DisplayPhoneBook(m_hWnd,&sArgs, m_pArgs->fHasValidTopLevelPBK, m_pArgs->fHasValidReferencedPBKs);

    CmFree(sArgs.pszMessage);
    CmFree(sArgs.pszBitmap);

    if (!bRes) 
    {
        return;
    }

    //
    // We have a new phone number selected, update phone number buffers.
    // and configure UI accordingly. If no dialing rules, the its a non
    // issue, leave it as is.
    //
    
    m_bAPInfoChanged = TRUE;
    if (!m_pArgs->fNoDialingRules)
    {
        EnableWindow(GetDlgItem(m_hWnd, nUdrID), TRUE);
        CheckDlgButton(m_hWnd, nUdrID, (m_DialInfo[nPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES));

        //
        // Set TAPI button display according to dialing rules use.
        //
    
        UpdateDialingRulesButton();
    }

    //
    // Copy the new info in the tmp phone info array. First we 
    // Get the new phonebook name, which should be a full path
    //

    MYDBGASSERT(FileExists(sArgs.szPhoneBookFile));

    lstrcpynU(m_DialInfo[nPhoneIdx].szPhoneBookFile, sArgs.szPhoneBookFile, 
              CELEMS(m_DialInfo[nPhoneIdx].szPhoneBookFile));

    lstrcpynU(m_DialInfo[nPhoneIdx].szDUN, sArgs.szDUNFile, 
              CELEMS(m_DialInfo[nPhoneIdx].szDUN));

    //
    // Remove the first element (country code) from the non-canonical number
    //

    StripFirstElement(sArgs.szNonCanonical);
    
    //
    // If there was no area code, then we'll have a leading space, trim it
    //

    CmStrTrim(sArgs.szNonCanonical); 

    //
    // Update our buffers
    //
    
    lstrcpynU(m_DialInfo[nPhoneIdx].szPhoneNumber, sArgs.szNonCanonical, CELEMS(m_DialInfo[nPhoneIdx].szPhoneNumber));
    lstrcpynU(m_DialInfo[nPhoneIdx].szCanonical, sArgs.szCanonical, CELEMS(m_DialInfo[nPhoneIdx].szCanonical));
    lstrcpynU(m_DialInfo[nPhoneIdx].szDesc, sArgs.szDesc, CELEMS(m_DialInfo[nPhoneIdx].szDesc));
    
    m_DialInfo[nPhoneIdx].dwCountryID = sArgs.dwCountryId;

    //
    // Store attributes of user selection (ie.service, country, region) 
    // We will store this data permanently if the user exits with an OK.
    // It is also used if the user returns to the PB dialog (4397)
    // 

    lstrcpynU(m_DialInfo[nPhoneIdx].szServiceType, 
             sArgs.szServiceType, CELEMS(m_DialInfo[nPhoneIdx].szServiceType));
    lstrcpynU(m_DialInfo[nPhoneIdx].szRegionName, 
             sArgs.szRegionName, CELEMS(m_DialInfo[nPhoneIdx].szRegionName));    
    //
    // Display the current phone number and update the description.
    //

    DisplayMungedPhone(nPhoneIdx);

    //
    // Update the description display
    //
        
    UpdateNumberDescription(nPhoneIdx, sArgs.szDesc);

    //SetDlgItemText(m_hWnd, nDescID, sArgs.szDesc);


    
    
    //
    //  Check for and display balloon tips if enabled
    //
    if (m_pArgs->fHideBalloonTips)
    {
        CMTRACE(TEXT("Balloon tips are disabled."));
    }
    else
    {
        RECT rect;
        POINT point = {0,0};
        LPTSTR pszBalloonTitle = NULL; 
        LPTSTR pszBalloonMsg = NULL;

        HWND hwndParent = GetParent(m_hWnd);
        HWND hwndTAPIButton = GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON);
        HWND hwndPrimaryDRCheckbox = GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX);
        HWND hwndNewAPButton = GetDlgItem(m_hWnd, IDC_GENERAL_NEWAP_BUTTON);

        MYDBGASSERT(hwndParent);
        MYDBGASSERT(hwndTAPIButton);
        MYDBGASSERT(hwndPrimaryDRCheckbox);
        MYDBGASSERT(hwndNewAPButton);
 
        if (hwndParent && hwndTAPIButton && hwndPrimaryDRCheckbox && hwndNewAPButton)
        {
            //
            // Get the BalloonTipsDisplayed flags from the registry
            //
            DWORD dwBalloonTipsDisplayed = m_pArgs->piniBothNonFav->GPPI(c_pszCmSection, c_pszCmEntryBalloonTipsDisplayed, NULL);

            //
            //  If the primary button was clicked and the edit control is blank, we will try to display the Dialing Rules balloon tip,
            //  else we will try to display the access point balloon tip.
            //
            if (bBlankPhone)
            {
                //
                //  We only display if the primary Dialing Rules checkbox is enabled. Then if the Dialing Rules button is enabled, 
                //  we point the balloon tip to the button, otherwise we will point it to the checkbox.
                //
                if (IsWindowEnabled(hwndPrimaryDRCheckbox) && !nPhoneIdx)
                {
                    pszBalloonTitle = CmLoadString(g_hInst, IDMSG_BALLOON_TITLE_DIALINGRULES);
                    pszBalloonMsg = CmLoadString(g_hInst, IDMSG_BALLOON_MSG_DIALINGRULES);
            
                    if (IsWindowEnabled(hwndTAPIButton))
                    {
                        if (GetWindowRect(hwndTAPIButton, &rect))
                        {
                            //
                            // Get the coordinates of the Dialing Rules button.  We want the balloon tip to point
                            // to half way up the button and 10px left of the right edge.
                            //
                            point.x = rect.right - 10;                              
                            point.y = ((rect.bottom - rect.top) / 2) + rect.top;   
                        }
                    }
                    else
                    {
                        if (GetWindowRect(hwndPrimaryDRCheckbox, &rect))
                        {
                            //
                            // Get the coordinates of the Primary Dialing Rules checkbox.  We want the balloon tip to point
                            // to the center of the checkbox.
                            //
                            point.x = rect.left + 10;                               
                            point.y = ((rect.bottom - rect.top) / 2) + rect.top;    
                        }    
                    }

                    //
                    // Update the registry flag to reset the Access Point balloon tip if the dialing rules balloon tip is displayed
                    //
                    if (dwBalloonTipsDisplayed & BT_ACCESS_POINTS)
                    {
                        dwBalloonTipsDisplayed = dwBalloonTipsDisplayed & ~BT_ACCESS_POINTS;
                    }   

                }
            }
            else
            {
        
                //  We display only if Access Points are not enabled and the phone number
                //  edit control is not blank.
                //
                if(!m_pArgs->fAccessPointsEnabled && !nPhoneIdx)
                {

                    //
                    // Check to see if we have displayed this balloon tip before.
                    //
                    if (!(dwBalloonTipsDisplayed & BT_ACCESS_POINTS))
                    {
            
                        pszBalloonTitle = CmLoadString(g_hInst, IDMSG_BALLOON_TITLE_ACCESSPOINT);
                        pszBalloonMsg = CmLoadString(g_hInst, IDMSG_BALLOON_MSG_ACCESSPOINT);

                        if (GetWindowRect(hwndNewAPButton, &rect))
                        {
                            //
                            //  Get the coordinates for the New Access Point button.  We want the balloon tip to point
                            //  to half way up the button and 10px left of the right edge.
                            //
                            point.x = rect.right - 10;
                            point.y = ((rect.bottom - rect.top) / 2) + rect.top;

                            //
                            // Update registry value
                            //
                            dwBalloonTipsDisplayed = dwBalloonTipsDisplayed | BT_ACCESS_POINTS;
                        }
                    }
                }
            }

            //
            //  Verify we have the info we need and display the balloon tip
            //    
            if (pszBalloonTitle && pszBalloonMsg && point.x && point.y)
            {
                if (m_pArgs && m_pArgs->pBalloonTip)
                {
                    if (m_pArgs->pBalloonTip->DisplayBalloonTip(&point, TTI_INFO, pszBalloonTitle, pszBalloonMsg, hwndParent))
                    {
                        //
                        //  Write the updated BalloonTipsDisplay flag to the registry
                        //
                        m_pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryBalloonTipsDisplayed, dwBalloonTipsDisplayed);
                    }
                    else
                    {
                        CMTRACE3(TEXT("BalloonTip failed to display - %s; at coordinates{%li,%li}"),pszBalloonTitle,point.x,point.y);
                    }
                }
            }
 
            CmFree(pszBalloonTitle);
            CmFree(pszBalloonMsg);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HaveContextHelp
//
//  Synopsis:   Whether a specific control id has context help
//              This function very easily introducce inconsistance
//              Every dialog should manage its own control, instead having this 
//              function keep track of all the controls.
//
//  Arguments:  hwndDlg     the hwnd of parent dlg
//              hwndCtrl    the hwnd of control
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/26/97
//
//----------------------------------------------------------------------------

BOOL HaveContextHelp(
    HWND    hwndDlg,
    HWND    hwndCtrl
)
{
    //
    // list of controls that we don't provide context help for
    //
    static const int rgiNoContextHelpCtrlId[] = 
    {
        IDC_MAIN_BITMAP,
        IDC_PHONEBOOK_BITMAP,
        IDC_GENERAL_PHONENUMBERS_GROUPBOX,
//        IDC_GENERAL_PRIMARYDESC_DISPLAY,
//        IDC_GENERAL_BACKUPDESC_DISPLAY,
//        IDC_ABOUT_BITMAP,
        IDC_ABOUT_FRAME,
        IDC_ABOUT_VERSION,
        IDC_ABOUT_WARNING,
        IDC_ABOUT_CM_STATIC,
        IDC_ABOUT_VERSION_STATIC,
        IDC_ABOUT_COPYRIGHT_STATIC,
        IDC_ABOUT_SHOCKWAVE_STATIC,
        IDC_INET_ICON,
        IDC_CONNSTAT_ICON,
        IDC_CONNSTAT_DURATION_DISPLAY,
        IDC_CONNSTAT_SPEED_DISPLAY,
        IDC_CONNSTAT_RECEIVED_DISPLAY,
        IDC_CONNSTAT_SENT_DISPLAY,
        IDC_CONNSTAT_DISCONNECT_DISPLAY,
        IDC_DETAILINFO,
        IDC_CONNSTAT_STATIC_CALL_DURATION,
        IDC_CONNSTAT_STATIC_CONNECT_SPEED,
        IDC_CONNSTAT_STATIC_BYTES_RECEIVED,
        IDC_CONNSTAT_STATIC_BYTES_SENT
    };

    UINT    uIdx, uLast;

    MYDBGASSERT(hwndDlg);
    MYDBGASSERT(hwndCtrl);

    for (uIdx=0, uLast=sizeof(rgiNoContextHelpCtrlId)/sizeof(rgiNoContextHelpCtrlId[0]); 
         uIdx < uLast; uIdx++)
    {
        if (GetDlgItem(hwndDlg, rgiNoContextHelpCtrlId[uIdx]) == hwndCtrl)
        {
            break;
        }
    }

    return (uIdx == uLast);
}

// check if TAPI has its information, put up dialog if not
BOOL CGeneralPage::CheckTapi(TapiLinkageStruct *ptlsTapiLink, HINSTANCE hInst) 
{
    LONG lRes;
    LPLINETRANSLATEOUTPUT pltoOutput = NULL;
    DWORD dwLen;
    BOOL bRet = FALSE;

    if (!SetTapiDevice(hInst,ptlsTapiLink,m_szDeviceName)) 
    {
        return bRet;
    }
    
    dwLen = sizeof(*pltoOutput) + (1024 * sizeof(TCHAR));
    pltoOutput = (LPLINETRANSLATEOUTPUT) CmMalloc(dwLen);
    if (NULL == pltoOutput)
    {
        return bRet;
    }
    
    pltoOutput->dwTotalSize = dwLen;

    lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                  ptlsTapiLink->dwDeviceId,
                                                  ptlsTapiLink->dwApiVersion,
                                                  TEXT("1234"),
                                                  0,
                                                  LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                  pltoOutput);                                            
    //
    // If the line translate failed, then execute the Dialing Rules UI by calling
    // lineTranslateDialog (inside OnDialingProperties). Providing that the user 
    // completes the UI, TAPI will be initialized and ready for use.
    //
    
    if (ERROR_SUCCESS != lRes) 
    {
        OnDialingProperties();

        //
        // The user may have canceled, so test again before declaring success
        //
        
        lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                  ptlsTapiLink->dwDeviceId,
                                                  ptlsTapiLink->dwApiVersion,
                                                  TEXT("1234"),
                                                  0,
                                                  LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                  pltoOutput);                                            
    }

    if (ERROR_SUCCESS == lRes) 
    {
        bRet = TRUE;
    }   

    CmFree(pltoOutput);

    m_pArgs->fNeedConfigureTapi = !(bRet);

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::AddExternalPage
//
// Synopsis:  Add a page to the property sheet.
//
// Arguments: PROPSHEETPAGE * pPsp - The page to add
//
// Returns:   Nothing
//
// History:   tomkel Created 01/09/2001
//
//+----------------------------------------------------------------------------
void CPropertiesSheet::AddExternalPage(PROPSHEETPAGE *pPsp)
{
    //
    // This version of AddExternalPage only work before calling DoPropertySheet
    //
    MYDBGASSERT(pPsp);

    if (!pPsp)
    {
        return;
    }
    CMTRACE1(TEXT("CPropertiesSheet::AddExternalPage - sizeof(PROPSHEETPAGE) = %d"),sizeof(PROPSHEETPAGE));
    MYDBGASSERT(m_numPages < MAX_PAGES);
    CopyMemory((LPVOID)&m_pages[m_numPages], (LPVOID)pPsp, sizeof(PROPSHEETPAGE));
    m_adwPageType[m_numPages] = CPROP_SHEET_TYPE_EXTERNAL;
    m_numPages++;

}
//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::AddPage
//
// Synopsis:  Add a page to the property sheet.
//
// Arguments: const CPropertiesPage* pPage - The page to add
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesSheet::AddPage(const CPropertiesPage* pPage)
{
    //
    // This version of AddPage only work before calling DoPropertySheet
    //
    MYDBGASSERT(pPage);
    MYDBGASSERT(pPage->m_pszTemplate);

    if (!pPage)
    {
        return;
    }

    MYDBGASSERT(m_numPages < MAX_PAGES);
    m_pages[m_numPages].pszTemplate = pPage->m_pszTemplate;
    m_pages[m_numPages].lParam = (LPARAM)pPage; // save the property page object
    m_adwPageType[m_numPages] = CPROP_SHEET_TYPE_INTERNAL;
    m_numPages++;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::DoPropertySheet
//
// Synopsis:  Call PropertySheet to create a modal property sheet
//
// Arguments: HWND hWndParent - Parent window
//            LPTSTR pszCaption - Title string
//            HINSTANCE hInst - The resource instance
//            UINT nStartPage - The start page
//
// Returns:   int - return value of PropertySheet()
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
int CPropertiesSheet::DoPropertySheet(HWND hWndParent, LPTSTR pszCaption, HINSTANCE hInst)
{
    for (UINT i=0; i<m_numPages; i++) 
    {
        //
        // Only do this for our CM property pages that are classes
        //
        if (m_adwPageType[i] == CPROP_SHEET_TYPE_INTERNAL)
        {
            m_pages[i].dwSize = sizeof(PROPSHEETPAGE);
            m_pages[i].hInstance = hInst;
            m_pages[i].dwFlags = 0;  // No help button or F1
            m_pages[i].pfnDlgProc = CPropertiesPage::PropPageProc;
        }
    }

    m_psh.dwSize = sizeof(PROPSHEETHEADER);
    m_psh.hwndParent = hWndParent;
    m_psh.hInstance = hInst;
    m_psh.pszIcon = 0;
    m_psh.pszCaption = pszCaption; // MAKEINTRESOURCE(nCaption);
    m_psh.nPages = m_numPages;
    m_psh.nStartPage = 0; 
    m_psh.ppsp = m_pages;
    m_psh.dwFlags = PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW|PSH_USECALLBACK;
    m_psh.pfnCallback = PropSheetProc;

    //
    // Dynamiclly load comctl32.dll
    //
    int iRet = -1;

    HINSTANCE hComCtl = LoadLibraryExA("comctl32.dll", NULL, 0);

    CMASSERTMSG(hComCtl, TEXT("LoadLibrary - comctl32 failed"));

    if (hComCtl != NULL)
    {
        typedef int (*PROPERTYSHEETPROC)(LPCPROPSHEETHEADER lppsph); 
        typedef void (*INITCOMMONCONTROLSPROC)(VOID);


        PROPERTYSHEETPROC fnPropertySheet;
        INITCOMMONCONTROLSPROC fnInitCommonControls;
    
        LPSTR pszPropSheetFuncName = OS_NT ? "PropertySheetW" : "PropertySheetA";
        fnPropertySheet = (PROPERTYSHEETPROC)GetProcAddress(hComCtl, pszPropSheetFuncName);
        fnInitCommonControls = (INITCOMMONCONTROLSPROC)GetProcAddress(hComCtl, "InitCommonControls");


        if (fnPropertySheet == NULL || fnInitCommonControls == NULL)
        {
            CMTRACE(TEXT("GetProcAddress of comctl32 failed"));
        }
        else
        {
            fnInitCommonControls();

            //
            // Set m_pThis right before we call PropertySheet
            // It will be used by PropSheetProc. 
            // Note: this is not multi-thread safe.  However, there is very little chance
            // that another thread is trying to bring up settings at the same time, and 
            // a context switch happens before PropSheetProc got called
            //

            MYDBGASSERT(m_pThis == NULL);
            m_pThis = this;

            if ((iRet = fnPropertySheet(&m_psh)) == -1)
            {
                CMTRACE(TEXT("DoPropertySheet: PropertySheet() failed"));
            }
        }

        FreeLibrary(hComCtl);
    }

    return iRet;
}

//
// Implementation of class CPropertiesPage
//



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::CPropertiesPage
//
// Synopsis:  Constructor
//
// Arguments: UINT nIDTemplate - Resource ID of the page
//            const DWORD* pHelpPairs - The pairs of ControlID/HelpID
//            const TCHAR* lpszHelpFile - The help file name
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CPropertiesPage::CPropertiesPage(UINT nIDTemplate, const DWORD* pHelpPairs, const TCHAR* lpszHelpFile )
    :CWindowWithHelp(pHelpPairs, lpszHelpFile)
{
    m_pszTemplate = MAKEINTRESOURCE(nIDTemplate);
}

CPropertiesPage::CPropertiesPage(LPCTSTR lpszTemplateName, const DWORD* pHelpPairs, 
                             const TCHAR* lpszHelpFile)
    :CWindowWithHelp(pHelpPairs, lpszHelpFile)
{
    m_pszTemplate = lpszTemplateName;
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnInitDialog
//
// Synopsis:  Virtual function. Called upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CPropertiesPage::OnInitDialog()
{
    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CPropertiesPage::OnCommand(WPARAM , LPARAM  )
{
    return 0;
}


//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnSetActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_SETACTIVE
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CPropertiesPage::OnSetActive()
{
    return 0;
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnKillActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_KILLACTIVE
//            Notifies a page that it is about to lose activation either because 
//            another page is being activated or the user has clicked the OK button.
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CPropertiesPage::OnKillActive()
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnApply
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_APPLY
//            Indicates that the user clicked the OK or Apply Now button 
//            and wants all changes to take effect. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesPage::OnApply()
{
    SetPropSheetResult(PSNRET_NOERROR);
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnReset
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_RESET
//            Notifies a page that the user has clicked the Cancel button and 
//            the property sheet is about to be destroyed. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesPage::OnReset()
{
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnPsnHelp
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_HELP
//
// Arguments: HWND - Window handle to the control sending a message
//            UINT - Identifier of the control sending a message
//
// Returns:   Nothing
//
// History:   Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesPage::OnPsnHelp(HWND , UINT_PTR)
{
    if (m_lpszHelpFile && m_lpszHelpFile[0])
    {
        CmWinHelp(m_hWnd, m_hWnd, m_lpszHelpFile, HELP_FORCEFILE, 0);
    }
}




//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnOtherMessage
//
// Synopsis:  Callup opun message other than WM_INITDIALOG and WM_COMMAND
//
// Arguments: UINT - Message Id
//            WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CPropertiesPage::OnOtherMessage(UINT , WPARAM , LPARAM  )
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::PropPageProc
//
// Synopsis:  The call back dialog procedure for all the property pages
//
// Arguments: HWND hwndDlg - Property page window handle
//            UINT uMsg - Message ID
//            WPARAM wParam - wParam of the message
//            LPARAM lParam - lParam of the message
//
// Returns:   BOOL  - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
INT_PTR CALLBACK CPropertiesPage::PropPageProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    CPropertiesPage* pPage;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    //
    // Save the object pointer on the first message,
    // The first message is not necessarily WM_INITDIALOG
    //
    if (uMsg == WM_INITDIALOG)
    {
        pPage = (CPropertiesPage*) ((PROPSHEETPAGE *)lParam)->lParam;

        //
        // Save the object pointer, this is implementation detail
        // The user of this class should not be aware of this
        //
        ::SetWindowLongU(hwndDlg, DWLP_USER, (LONG_PTR)pPage);

        MYDBGASSERT(pPage);
        MYDBGASSERT(pPage->m_hWnd == NULL);

        pPage->m_hWnd = hwndDlg;
    }
    else
    {
        pPage = (CPropertiesPage*) GetWindowLongU(hwndDlg,DWLP_USER);

        if (pPage == NULL)
        {
            return FALSE;
        }

        MYDBGASSERT(pPage->m_hWnd == hwndDlg);
    }

    ASSERT_VALID(pPage);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        return pPage->OnInitDialog();

    case WM_COMMAND:
        return (BOOL)pPage->OnCommand(wParam, lParam);

    case WM_NOTIFY:
        {    
            if (NULL == pnmHeader)
            {
                return FALSE;
            }            

            switch (pnmHeader->code) 
            {
                case PSN_SETACTIVE:
                    pPage->OnSetActive();
                    break;

                case PSN_KILLACTIVE:
                    pPage->OnKillActive();
                    break;  

                case PSN_APPLY:
                    pPage->OnApply();
                    return TRUE;

                case PSN_RESET:
                    pPage->OnReset();
                    break;

                case PSN_HELP:
                    pPage->OnPsnHelp(pnmHeader->hwndFrom , pnmHeader->idFrom);
                    break;

                default:
                    break;
            }

            break;
        } // WM_NOTIFY

        case WM_HELP:
            pPage->OnHelp((LPHELPINFO)lParam);
            return TRUE;

        case WM_CONTEXTMENU:
            {
                POINT   pos = {LOWORD(lParam), HIWORD(lParam)};
                
                CMTRACE3(TEXT("\r\nPropPageProc() - WM_CONTEXTMENU wParam = %u pos.x = %u, pos.y = %u"),
                    wParam, pos.x, pos.y);

                pPage->OnContextMenu((HWND) wParam, pos);
                return TRUE;
            }

        default:
             return (BOOL)pPage->OnOtherMessage(uMsg, wParam, lParam);
    }

    return (FALSE);
}

//
// Help id pairs for dialing page
//
const DWORD CGeneralPage::m_dwHelp[] = {
        IDC_GENERAL_PHONENUMBERS_GROUPBOX,  IDH_GENERAL_PHONENUM,
        IDC_RADIO_DIRECT,                   IDH_GENERAL_ALREADY,
        IDC_RADIO_DIALUP,                   IDH_GENERAL_DIALTHIS,
        IDC_GENERAL_P1_STATIC,              IDH_GENERAL_PHONENUM,
        IDC_GENERAL_PRIMARY_EDIT,           IDH_GENERAL_PHONENUM,
        IDC_GENERAL_PRIMARYPB_BUTTON,       IDH_GENERAL_PHONEBOOK,
        IDC_GENERAL_UDR1_CHECKBOX,          IDH_GENERAL_USE_DIAL_RULE,
        IDC_GENERAL_P2_STATIC,              IDH_GENERAL_BACKUPNUM,
        IDC_GENERAL_BACKUP_EDIT,            IDH_GENERAL_BACKUPNUM,
        IDC_GENERAL_BACKUPPB_BUTTON,        IDH_GENERAL_PHONEBOOKB,
        IDC_GENERAL_UDR2_CHECKBOX,          IDH_GENERAL_USE_DIAL_RULEB,
        IDC_GENERAL_TAPI_BUTTON,            IDH_GENERAL_DIALRULE,
        IDC_GENERAL_MODEM_COMBO,            IDH_GENERAL_CONNECT_MODEM,
        IDC_CONNECT_USING,                  IDH_GENERAL_CONNECT_MODEM,
        IDC_GENERAL_ACCESSPOINT_COMBO,       IDH_GENERAL_ACCESSPOINTS,
        IDC_GENERAL_ACCESSPOINT_STATIC,      IDH_GENERAL_ACCESSPOINTS,
        IDC_GENERAL_NEWAP_BUTTON,            IDH_GENERAL_NEWAP,
        IDC_GENERAL_DELETEAP_BUTTON,         IDH_GENERAL_DELETEAP,
        0,0};
        
//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::CGeneralPage
//
// Synopsis:  Constructor
//
// Arguments: ArgsStruct* pArgs - Information needed for the page
//            UINT nIDTemplate - Resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CGeneralPage::CGeneralPage(ArgsStruct* pArgs, UINT nIDTemplate) 
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
    m_pEventListener = NULL;

    m_NumPhones = MAX_PHONE_NUMBERS;

    m_szDeviceName[0] = TEXT('\0');
    m_szDeviceType[0] = TEXT('\0');

    m_bDialInfoInit = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::OnInitDialog
//
//  Synopsis:   Init the General properties property sheet.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/12/97     - disable backup phone no. in
//                                                'Dialing with Connectoid' mode
//----------------------------------------------------------------------------

BOOL CGeneralPage::OnInitDialog()
{
    UpdateFont(m_hWnd);

    //
    // Load the Access Points from the registry
    //
    if (FALSE == ShowAccessPointInfoFromReg(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
    {
        // 
        // If the above function fails then there is no Access Point in the registry. 
        // Need to figure out if this is the default access point.
        //
        LPTSTR pszTempDefaultAccessPointName = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);
        if (pszTempDefaultAccessPointName)
        {
            if (0 == lstrcmpiU(m_pArgs->pszCurrentAccessPoint, pszTempDefaultAccessPointName))
            {
                // 
                // This must be an old (1.0 or 1.2) profile since it's the default Access Point and it isn't 
                // in the registry yet. Need to properly display the Access Point combobox and 
                // create the reg key. Calling AddNewAPToReg does that.
                //
                AddNewAPToReg(m_pArgs->pszCurrentAccessPoint, TRUE);

                //
                // Need to clear the AccessPointEnabled Flag. This is a side effect of calling AddNewAPToReg
                // thus it needs to be cleared (set to FALSE) since we only have one Access Point and
                // the this flag is only set if we have 1+ Access Points
                //
                m_pArgs->fAccessPointsEnabled = FALSE;
                WriteUserInfoToReg(m_pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID) &m_pArgs->fAccessPointsEnabled);
            }
            CmFree(pszTempDefaultAccessPointName);
        }
    }

    //
    // Set phone number descriptions
    //    
    UpdateForNewAccessPoint(TRUE);
    
    //
    // Subclass the Phone Number edit controls
    //
    HWND hwndPrimary = GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARY_EDIT);
    HWND hwndBackup = GetDlgItem(m_hWnd, IDC_GENERAL_BACKUP_EDIT);

    MYDBGASSERT(hwndPrimary && hwndBackup);

    if (hwndPrimary && hwndBackup)
    {
        m_pfnOrgEditWndProc = (WNDPROC)SetWindowLongU(hwndPrimary, GWLP_WNDPROC, (LONG_PTR)SubClassEditProc);
        WNDPROC lpEditProc = (WNDPROC)SetWindowLongU(hwndBackup, GWLP_WNDPROC, (LONG_PTR)SubClassEditProc);

        MYDBGASSERT(lpEditProc == m_pfnOrgEditWndProc);

        //
        // Save the object with the window handle
        //

        SetWindowLongU(hwndPrimary, GWLP_USERDATA, (LONG_PTR)this);
        SetWindowLongU(hwndBackup, GWLP_USERDATA, (LONG_PTR)this);
    }
    
    return (TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::UpdateForNewAccessPoint
//
//  Synopsis:   Set the phone number description from pArgs. 
//
//  Notes:      This function was originally part of OnInitDialog. 
//              It was made into a separate function for access points
//
//  Arguments:  fSetPhoneNumberDescriptions [update phone numbers as well]
//
//  Returns:    NONE
//
//  History:    t-urama  Created     07/31/2000
//----------------------------------------------------------------------------    
void CGeneralPage::UpdateForNewAccessPoint(BOOL fSetPhoneNumberDescriptions)
{
    m_bAPInfoChanged = FALSE;
    LPTSTR pszDefaultAccessPointName = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);

    if (pszDefaultAccessPointName && m_pArgs->pszCurrentAccessPoint)
    {
        if (!lstrcmpiU(m_pArgs->pszCurrentAccessPoint, pszDefaultAccessPointName))
        {
            EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_DELETEAP_BUTTON), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_DELETEAP_BUTTON), TRUE);
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("UpdateForNewAccessPoint -- either CmLoadString of IDS_DEFAULT_ACCESSPOINT failed or pszCurrentAccessPoint is NULL."));
    }

    CmFree(pszDefaultAccessPointName);

    if (fSetPhoneNumberDescriptions)
    {
        UpdateNumberDescription(0, m_pArgs->aDialInfo[0].szDesc);
        UpdateNumberDescription(1, m_pArgs->aDialInfo[1].szDesc);

        if (m_pArgs->IsBothConnTypeSupported())
        {
            //
            // Set radio button according to AlwaysOn state
            //
            if (m_pArgs->IsDirectConnect())
            {              
                CheckDlgButton(m_hWnd, IDC_RADIO_DIRECT, BST_CHECKED); 
                CheckDlgButton(m_hWnd, IDC_RADIO_DIALUP, BST_UNCHECKED);
                EnableDialupControls(FALSE);
            }
            else
            {
                CheckDlgButton(m_hWnd, IDC_RADIO_DIALUP, BST_CHECKED); 
                CheckDlgButton(m_hWnd, IDC_RADIO_DIRECT, BST_UNCHECKED);
                PostMessageU(m_hWnd, WM_INITDIALINFO, 0,0);
            }
        }
        else
        {
            //
            // Note: It is assumed that this page will never be loaded in a pure direct
            // case, thus the deduction that NOT IsBothConnTypeSupported means dial only.
            //
            MYDBGASSERT(!m_pArgs->IsDirectConnect());
            PostMessageU(m_hWnd, WM_INITDIALINFO, 0,0);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::EnableDialupControls
//
// Synopsis:  Sets the enabled state of ALL the dialup controls on the tab
//
// Arguments: BOOL fEnable - flag indicating enable state of dial-up controls
//
// Returns:   Nothing
//
// History:   nickball  Created     04/21/98
//
//+----------------------------------------------------------------------------
void CGeneralPage::EnableDialupControls(BOOL fEnable)
{
    BOOL fState = fEnable;

    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_P1_STATIC), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARY_EDIT), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_P2_STATIC), fState);   
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_BACKUP_EDIT), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_CONNECT_USING), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_MODEM_COMBO), fState);    

    //
    // We are enabling controls check PB buttons
    //

    fState = FALSE;

    if (fEnable)
    {
        //
        // No phonebooks, no button access
        //

        if (m_pArgs->fHasValidTopLevelPBK || m_pArgs->fHasValidReferencedPBKs) 
        {
            fState = TRUE;
        }
    }
            
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARYPB_BUTTON), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_BACKUPPB_BUTTON), fState);

    //
    // Examine the canonical phone number, we must have a canonical form 
    // of the number available for Use Dailing Rules to be enabled.
    //
   
    if (fEnable && *m_DialInfo[0].szCanonical)
    {
        fState = TRUE;
    }
    else
    {
        fState = FALSE;
    }
    
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX), fState);            

    //
    // Examine the canonical phone number, we must have a canonical form 
    // of the number available for Use Dailing Rules to be enabled.
    //

    if (fEnable && *m_DialInfo[1].szCanonical)
    {
        fState = TRUE;
    }
    else
    {
        fState = FALSE;
    }
    
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX), fState);     

    //
    // Update dialing rules state
    //
       
    if (fEnable)
    {
        UpdateDialingRulesButton();
    }
    else
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON), fEnable);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::OnOtherMessage
//
// Synopsis:  Callup opun message other than WM_INITDIALOG and WM_COMMAND
//
// Arguments: UINT - Message Id
//            WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CGeneralPage::OnOtherMessage(UINT uMsg, WPARAM , LPARAM )
{
    if (uMsg == WM_INITDIALINFO)
    {
        InitDialInfo();
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  IsUniqueIsdnDevice
//
// Synopsis:  Checks to see if this is an ISDN device and if it was already added
//            to the ComboBox control identified by hWnd and nId
//
// Arguments: None
//
// Returns:   BOOL - Returns TRUE if a Unique ISDN Device
//
// History:   quintinb 7/14/99 created
//
//+----------------------------------------------------------------------------
BOOL IsUniqueIsdnDevice(HWND hWnd, UINT nId, LPRASDEVINFO pRasDevInfo)
{
    BOOL bReturn = FALSE;

    if (hWnd && nId && pRasDevInfo)
    {
        //
        //  First lets check to make sure that this is even an ISDN device
        //
        if (0 == lstrcmpiU(pRasDevInfo->szDeviceType, RASDT_Isdn))
        {
            //
            //  Okay, it is an ISDN device, do we have one with that name already?
            //
            if (CB_ERR == SendDlgItemMessageU(hWnd, nId, CB_FINDSTRINGEXACT,
                                              -1, (LPARAM)pRasDevInfo->szDeviceName))
            {
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::InitDialInfo
//
// Synopsis:  The dialing page can not call LoadDialInfo directly on WM_INITDIALOG
//            LoadDialInfo might popup some UI to install modem.  The property 
//            sheet and the property page will not be disabled, if a dialog is 
//            poped up on WM_INITDIALOG message.  Instead, we post a message
//            on WM_INITDIALOG and call LoadDialInfo here.
//            On a slow machine, there might be a period that all the control
//            are gray.
//
// Arguments: None
//
// Returns:   DWORD - Return code from LoadDialInfo
//
// History:   fengsun    2/26/98    Created Header   
//            nickball   4/24/98    Added return code
//
//+----------------------------------------------------------------------------
DWORD CGeneralPage::InitDialInfo()
{
    /*if (m_bDialInfoInit)
    {
        return ERROR_SUCCESS;    
    }*/

    HCURSOR hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));

    //
    // Make sure the dial info is loaded
    //
    
    DWORD dwRet = LoadDialInfo(m_pArgs, m_hWnd);
      
    if (dwRet == ERROR_PORT_NOT_AVAILABLE)
    {
        //
        // No modem avaliable, update direct/dial controls if any 
        //

        if (m_pArgs->IsBothConnTypeSupported())
        {
            CheckDlgButton(m_hWnd, IDC_RADIO_DIALUP, BST_UNCHECKED); 
            CheckDlgButton(m_hWnd, IDC_RADIO_DIRECT, BST_CHECKED);          
            SetFocus(GetDlgItem(m_hWnd, IDC_RADIO_DIRECT));
        }
        else
        {
            //
            // Make sure user can exit using keyboard by explicitly
            // setting cancel button as default and giving it focus.
            //
            
            HWND hwndParent = GetParent(m_hWnd);

            MYDBGASSERT(hwndParent);

            if (hwndParent)
            {
                SendMessageU(hwndParent, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
                SetFocus(GetDlgItem(hwndParent, IDCANCEL));
            }
        }

        //
        // Disable everything dial-up
        //

        EnableDialupControls(FALSE);
        
        SetCursor(hPrev);

        return dwRet;
    }
    
    lstrcpynU(m_szDeviceName, m_pArgs->szDeviceName, CELEMS(m_szDeviceName));

    //
    // Init the tmp phone array, it'll possibly be modified
    //
    m_DialInfo[0] = m_pArgs->aDialInfo[0];
    m_DialInfo[1] = m_pArgs->aDialInfo[1];

    EnableDialupControls(TRUE);

    //
    // Check TAPI before translating address
    //
    
    CheckTapi(&m_pArgs->tlsTapiLink, g_hInst);
    
    //
    // Set limit for phone # length. Use OS to determine intial default, but 
    // allow admin override. 
    //
    
    UINT i = (OS_NT ? MAX_PHONE_LENNT : MAX_PHONE_LEN95);
    
    i = (int) m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPhoneNumber, i);

    //
    // Even override is limited, in this case by our storage at RAS_MaxPhoneNumber
    //

    i = __min(i, RAS_MaxPhoneNumber);

    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_PRIMARY_EDIT, EM_SETLIMITTEXT, i, 0);
    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_BACKUP_EDIT, EM_SETLIMITTEXT, i, 0);

    //
    // display the munged phone #'s
    //

    for (i = 0; i < m_NumPhones; i++)
    {       
        DisplayMungedPhone(i);

        int iCtrl = (i? IDC_GENERAL_UDR2_CHECKBOX : IDC_GENERAL_UDR1_CHECKBOX);
       
        //
        // Set "Use Dialing Rules". If there is a canonical value then honor 
        // the USE_DIALING_RULES flag. Otherwise, its a hand edited number, 
        // so we disable the check for dialing rules. Note: this logic is also
        // used in EnableDialupControls().
        //
        
        if (!m_DialInfo[i].szCanonical[0]) 
        {
            EnableWindow(GetDlgItem(m_hWnd, iCtrl), FALSE);
        }
        else
        {
            CheckDlgButton(m_hWnd, 
                           iCtrl, 
                           (m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES));
        }        
    }

    //
    // Set TAPI button display according to dialing rules use.
    //  

    UpdateDialingRulesButton();

    //
    // Standard dial: If we have no phone books, disable the buttons
    //

    if (!m_pArgs->fHasValidTopLevelPBK && !m_pArgs->fHasValidReferencedPBKs) 
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARYPB_BUTTON), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_BACKUPPB_BUTTON), FALSE);
    }
  
    DWORD           dwCnt;
    DWORD dwIdx;

    if (!m_bDialInfoInit)
    {
        // Initialize the modem combo box only once. This does not use any of the 
        // access point info.
        //
        //
        // Init the modem combo box.  ISDN devices are a special case because they
        // have two channels and thus usually enumerate each channel as a device.
        // The old style handling was to only show the first ISDN device on the machine.
        // This worked but won't allow a user to use a second ISDN device with CM should
        // they have one.  We will keep the old behavior on legacy platforms but on NT5
        // we will try to do the right thing and only not enumerate a second device if
        // we already have one of those in the list.  This will filter out second channels
        // and will give the user access to another ISDN device as long as it isn't of the same
        // name as the first.  Definitely not a great solution but this close to ship it is the
        // best we can do.  Note that for ISDN devices we want to only show
        // one device even though RAS may enumerate two (one for each channe
        //
    
        SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_RESETCONTENT, 0, 0L);

        LPRASDEVINFO    prdiRasDevInfo;
        

        if (GetRasModems(&m_pArgs->rlsRasLink, &prdiRasDevInfo, &dwCnt)) 
        {
            
            //
            // add modem list to modem-combo
            // 
            for (dwIdx=0; dwIdx < dwCnt; dwIdx++) 
            {
                //
                // filter out tunnel device, IRDA, and Parallel ports.
                //
                if (!lstrcmpiU(prdiRasDevInfo[dwIdx].szDeviceType, RASDT_Modem)                  || // a modem
                    !lstrcmpiU(prdiRasDevInfo[dwIdx].szDeviceType, RASDT_Atm)                    || // an ATM device
                    IsUniqueIsdnDevice(m_hWnd, IDC_GENERAL_MODEM_COMBO, &prdiRasDevInfo[dwIdx]))    // an ISDN modem, note we 
                                                                                                    // filter out the channels
                                                                                                    // and show only one device 
                {
                    //
                    //  Add the device to the Device Combo Box
                    //
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_ADDSTRING,
                                        0, (LPARAM)prdiRasDevInfo[dwIdx].szDeviceName);
                }
            }
        }
        
        CmFree(prdiRasDevInfo);
    }

    dwCnt = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_GETCOUNT, 0, 0);
    if (dwCnt == 0) 
    {
       dwIdx = (DWORD)CB_ERR;
    } 
    else if (dwCnt == 1) 
    {
        dwIdx = 0;
    } 
    else 
    {
        dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd,
                                   IDC_GENERAL_MODEM_COMBO,
                                   CB_FINDSTRINGEXACT,
                                   0,
                                   (LPARAM)m_szDeviceName);
    }
        
    if (dwIdx != CB_ERR) 
    {
        SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_SETCURSEL, (WPARAM)dwIdx, 0L);
    

        //
        // Reset the tmp modem var
        //

        GetDlgItemTextU(m_hWnd, IDC_GENERAL_MODEM_COMBO, m_szDeviceName, RAS_MaxDeviceName+1);

        //
        // GetDeviceType will fill the szDeviceType according to szDeviceName
        //
        if (!GetDeviceType(m_pArgs, m_szDeviceType, m_szDeviceName))
        {
            //
            // if GetDeviceType() failed, something's wrong.  just use the devicetype
            // that we've been using.
            //
            lstrcpynU(m_szDeviceType, m_pArgs->szDeviceType, CELEMS(m_szDeviceType));
        }
    }

    

    //
    // Disable DialingProperties button if no modem selected
    //
    
    if (IsWindowEnabled(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON)))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON), m_szDeviceName[0] != 0);
    }

    m_bDialInfoInit = TRUE;

    SetCursor(hPrev);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CGeneralPage::OnCommand(WPARAM wParam, LPARAM)
{
    //
    //  Hide any open balloon tips
    //
    if (m_pArgs->pBalloonTip)
    {
        m_pArgs->pBalloonTip->HideBalloonTip();
    }

    switch (LOWORD(wParam)) 
    {
        case IDC_GENERAL_UDR1_CHECKBOX:
        case IDC_GENERAL_UDR2_CHECKBOX:
        {
            int i = (LOWORD(wParam) == IDC_GENERAL_UDR1_CHECKBOX? 0 : 1);
            
            if (IsDlgButtonChecked(m_hWnd, LOWORD(wParam)))
            {
                int iEditID = i ? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT;

                m_DialInfo[i].dwPhoneInfoFlags |= PIF_USE_DIALING_RULES;
            }
            else
            {
                m_DialInfo[i].dwPhoneInfoFlags &= ~PIF_USE_DIALING_RULES;       
            }

            //
            // If neither dialing rule is on, disable button.
            //

            UpdateDialingRulesButton();

            DisplayMungedPhone(i);
            m_bAPInfoChanged = TRUE;
            return TRUE;
        }

        case IDC_GENERAL_PRIMARYPB_BUTTON:
        case IDC_GENERAL_BACKUPPB_BUTTON:       
            OnPhoneBookButton(LOWORD(wParam) == IDC_GENERAL_PRIMARYPB_BUTTON ? 0 : 1);
            return (TRUE);

        case IDC_GENERAL_TAPI_BUTTON:
            OnDialingProperties();
            return (TRUE);

        case IDC_RADIO_DIRECT:
            MYDBGASSERT(m_pArgs->IsBothConnTypeSupported());
            m_bAPInfoChanged = TRUE;
            if (BN_CLICKED == HIWORD(wParam)) // notification code 
            {
                EnableDialupControls(FALSE);
            }
            
            return TRUE;
            
        case IDC_RADIO_DIALUP:

            MYDBGASSERT(m_pArgs->IsBothConnTypeSupported());
            m_bAPInfoChanged = TRUE;
            if (BN_CLICKED == HIWORD(wParam)) // notification code 
            {           
                //
                // NT #356821 - nickball
                //
                // Make sure we don't respond until the click is fully 
                // registered as we only want to respond once and in 
                // the case of keyboard navigation a BN_CLICKED 
                // notification is sent before the button takes the 
                // click and afterwards. Mouse navigation causes 
                // one notification once the button already has the 
                // click. Responding to both clicks get us into a nasty
                // little re-entrancy in IntiDialInfo, so we filter out
                // the first notification
                //
                
                if (IsDlgButtonChecked(m_hWnd, IDC_RADIO_DIALUP))
                {                                                                         
                    //
                    // Load dialing information, and enable dial-up controls
                    //
            
                    if (ERROR_PORT_NOT_AVAILABLE != InitDialInfo())
                    {
                        EnableDialupControls(TRUE);
                        SetFocus(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARY_EDIT));
                    }
                }
            }
            
            return TRUE;
        
        case IDC_GENERAL_DELETEAP_BUTTON:
        {
            if (m_pArgs->pszCurrentAccessPoint)
            {
                LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_DELETE_ACCESSPOINT, m_pArgs->pszCurrentAccessPoint);

                if (pszMsg)
                {
                    if (IDYES == MessageBox(m_hWnd, 
                                            pszMsg, 
                                            m_pArgs->szServiceName, 
                                            MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2 | MB_APPLMODAL))
                    {
                        this->DeleteAccessPoint();
                    }
                }

                CmFree(pszMsg);
            }
            return TRUE;
        }

        case IDC_GENERAL_NEWAP_BUTTON:
        {
            //
            //  We need to allow for the case where the user has made a change
            //  to a phone number and has now decided to save this to a *new*
            //  Access Point (AP).  The dialog below asks the user if he/she wants
            //  to save the current changes to the "old" AP (i.e. the AP we're
            //  just leaving).  If the user says No, this means they want to
            //  use these settings for the new AP (the one we're about to ask
            //  them to name).  For this case, we apply all the current phone
            //  number information to the new AP, i.e we _don't_ clear out the
            //  old phone number settings.  See NT bug 301054 for more.
            //
            BOOL bClearOldPhoneNumberSettings = TRUE;

            BOOL bRes = AccessPointInfoChanged();
            if (bRes && m_pArgs->pszCurrentAccessPoint)
            {
                LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_SAVE_ACCESSPOINT, m_pArgs->pszCurrentAccessPoint);
                if (pszMsg)
                {
                    int iRet = MessageBox(m_hWnd, 
                                          pszMsg, 
                                          m_pArgs->szServiceName, 
                                          MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON1 | MB_APPLMODAL);
                    if (IDYES == iRet)
                    {
                        OnApply();
                    }
                    else if (IDNO == iRet)
                    {
                        bClearOldPhoneNumberSettings = FALSE;
                    }
                    else
                    {
                        MYDBGASSERT(0);
                    }
                }
                
                CmFree(pszMsg);
            }

            LPTSTR pszAPName = NULL;
            CNewAccessPointDlg NewAccessPointDlg(m_pArgs, &pszAPName);

            if (IDOK == NewAccessPointDlg.DoDialogBox(g_hInst, IDD_NEW_ACCESSPOINT, m_hWnd))
            {
                MYDBGASSERT(pszAPName);
                AddNewAPToReg(pszAPName, bClearOldPhoneNumberSettings);
                
                if (FALSE == bClearOldPhoneNumberSettings)
                {
                    //
                    //  Since we didn't clear the phone number settings, we've
                    //  left them in place as initial values for the new AP.  We
                    //  need to mark the new AP as 'dirty' so that when the current
                    //  AP changes, the UI will ask the user to save changes.
                    //  (there's no significance attached to choosing IDC_GENERAL_PRIMARY_EDIT, I
                    //  could just as well have used the other edit control.)
                    //
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_PRIMARY_EDIT, EM_SETMODIFY, TRUE, 0);
                }
            }

            CmFree(pszAPName);

            return TRUE;
        }

        default:
            break;
    }
    
    switch (HIWORD(wParam)) 
    {
        case CBN_SELENDOK:

            if (IDC_GENERAL_MODEM_COMBO == LOWORD(wParam))
            {
                TCHAR   szModem[RAS_MaxDeviceName+1];
                TCHAR   szDeviceType[RAS_MaxDeviceType+1];

                MYDBGASSERT(IDC_GENERAL_MODEM_COMBO == LOWORD(wParam));

                GetWindowTextU(GetDlgItem(m_hWnd, IDC_GENERAL_MODEM_COMBO), 
                    szModem, RAS_MaxDeviceName+1);

                if (lstrcmpU(m_szDeviceName, szModem) == 0)
                {
                    // there's no change in the modem
                    return FALSE;
                }
            
                m_bAPInfoChanged = TRUE;
                // 
                // If GetDeviceType fails we won't in fact change the
                // modem even though the user thinks that we did.
                // Logic could possibly be added to notify the user
                // and refresh the device list, but this is a fair
                // amount of work for little gain.
                //

                if (GetDeviceType(m_pArgs, szDeviceType, szModem))
                { 
                    lstrcpyU(m_szDeviceName, szModem);
                    lstrcpyU(m_szDeviceType, szDeviceType);

                    //
                    // CheckTapi will check (m_szDeviceName)
                    //
                    CheckTapi(&m_pArgs->tlsTapiLink, g_hInst);
                }
            }
            else
            {
                //
                // The selection in the Access Point combo box
                // has changed. Now we have to load the dialing information for
                // the newly selected Access Point
                //
                MYDBGASSERT(IDC_GENERAL_ACCESSPOINT_COMBO == LOWORD(wParam));
                BOOL bRes = AccessPointInfoChanged();
                if (bRes && m_pArgs->pszCurrentAccessPoint)
                {
                    //
                    // If the dialing info. for the previous Access Point has changed, ask the
                    // user if he wants to save the changes
                    //
                    LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_SAVE_ACCESSPOINT, m_pArgs->pszCurrentAccessPoint);
                    if (pszMsg)
                    {
                        if (IDYES == MessageBox(m_hWnd, 
                                                pszMsg, 
                                                m_pArgs->szServiceName, 
                                                MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON1 | MB_APPLMODAL))
                        {
                            OnApply();
                        }
                    }
                    
                    CmFree(pszMsg);
                }

                //
                // Now call the function to change the Access Point in the combo box
                // and load its parameters into pArgs
                //

                if (ChangedAccessPoint(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
                {
                    //
                    // Load new dialing info. into controls on the general page
                    //
                    this->UpdateForNewAccessPoint(TRUE);
                }
            }
                                
            break;

        default:
            break;
    }

   return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckAccessToCmpAndRasPbk
//
//  Synopsis:   Check to see if the user has the necessary security permissions
//              to make changes to properties. Notifies user if they do not.
//
//  Arguments:  HWND hwndDlg        - The hwnd of the calling app.
//              ArgsStruct *pArgs   - Ptr to our global args struct.
//
//  Returns:    HRESULT - indicating the particular success or failure.
//
//  History:    nickball    03/14/00    Created header 
//
//----------------------------------------------------------------------------
HRESULT CheckAccessToCmpAndRasPbk(HWND hwndDlg, ArgsStruct *pArgs)
{

    MYDBGASSERT(pArgs); // hwndDlg can be NULL

    if (NULL == pArgs)
    {
        return E_INVALIDARG;
    }

    //
    //  Check the cmp, note this could be locked with NTFS perms or just with
    //  attrib.  HasSpecifiedAccessToFileOrDir should catch both as appropriate.
    //
    LPTSTR pszCmp = CmStrCpyAlloc(pArgs->piniProfile->GetFile());
    LPTSTR pszHiddenRasPbk = NULL;
    LPTSTR pszRasPbk = NULL;
    DWORD dwDesiredAccess = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    BOOL bHasMainRasPbkAccess = FALSE;
    BOOL bHasHiddenRasPbkAccess = FALSE;

    if (pszCmp && pszCmp[0])
    {
        //
        //  Now check the RAS phonebook
        //
        if (OS_W9X)
        {
            //
            //  No phonebook on 9x so skip this check
            //
            bHasMainRasPbkAccess = TRUE;
            bHasHiddenRasPbkAccess = TRUE;
        }
        else
        {
            pszRasPbk = GetPathToPbk((LPCTSTR)pszCmp, pArgs);
            MYDBGASSERT(pszRasPbk);
            CmStrCatAlloc(&pszRasPbk, c_pszRasPhonePbk);
            MYDBGASSERT(pszRasPbk);
        
          
            if (pszRasPbk && pszRasPbk[0])
            {
                bHasMainRasPbkAccess = HasSpecifiedAccessToFileOrDir(pszRasPbk, dwDesiredAccess);

                if ((FALSE == bHasMainRasPbkAccess) && (FALSE == FileExists(pszRasPbk)))
                {
                    //
                    //  if the file doesn't exist, give them the
                    //  benefit of the doubt.  We won't get very far if
                    //  the file doesn't exist and they don't have permissions
                    //  to create it.
                    //
                    bHasMainRasPbkAccess = TRUE;
                }
            }

            //
            //  Now check the hidden RAS phonebook
            //
            if (DOUBLE_DIAL_CONNECTION == pArgs->GetTypeOfConnection())
            {
                pszHiddenRasPbk = CreateRasPrivatePbk(pArgs);

                if (pszHiddenRasPbk && HasSpecifiedAccessToFileOrDir(pszHiddenRasPbk, dwDesiredAccess))
                {
                    bHasHiddenRasPbkAccess = TRUE;
                }
            }
            
            else
            {
                bHasHiddenRasPbkAccess = TRUE;            
            }
        }
    }

    //
    //  Only set hr to success if we have access to both
    //
    HRESULT hr;

    if (bHasMainRasPbkAccess && bHasHiddenRasPbkAccess)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
        LPTSTR pszProblemFile = NULL;

        if (!bHasMainRasPbkAccess)
        {
            pszProblemFile = pszRasPbk;        
        }
        else if (!bHasHiddenRasPbkAccess)
        {
            pszProblemFile = pszHiddenRasPbk;
        }

        if (NULL != pszProblemFile)
        {
            LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NO_CMP_PBK_ACCESS, pszProblemFile);
            if (pszMsg)
            {
                MessageBox(hwndDlg, pszMsg, pArgs->szServiceName, MB_OK | MB_ICONERROR);
                CmFree(pszMsg);
            }        
        }
    }
    //
    //  Cleanup
    //
    CmFree(pszCmp);
    CmFree(pszRasPbk);
    CmFree(pszHiddenRasPbk);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::OnApply()
//
//  Synopsis:   Save the data associated with the 'Dialing' property sheet.
//              when the user clicks OK.
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/23/97
//                                  Always update modem when user selected OK from
//                                  'Properties' button
//----------------------------------------------------------------------------
void CGeneralPage::OnApply()
{
    BOOL fDirect = IsDlgButtonChecked(m_hWnd, IDC_RADIO_DIRECT);
    LPTSTR pszTmp = NULL;

    //
    // If access points are enabled save the current access point to the registry
    //
    if (m_pArgs->fAccessPointsEnabled)
    {  
        WriteUserInfoToReg(m_pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID)(m_pArgs->pszCurrentAccessPoint));
    }

    if (!fDirect)
    {
        //
        // Before we go anywhere, make sure that the device is acceptable
        // otherwise, we won't be able to munge the phone number
        //
        if (!SetTapiDevice(g_hInst, &m_pArgs->tlsTapiLink, m_szDeviceName)) 
        {
            pszTmp = CmFmtMsg(g_hInst, IDMSG_UNSUPPORTED_DEVICE);
                        
            MessageBoxEx(m_hWnd, pszTmp, m_pArgs->szServiceName, 
                         MB_OK | MB_ICONINFORMATION, LANG_USER_DEFAULT);
            CmFree(pszTmp);
            SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
            return;
        }

        //
        // Device is ok, see if TAPI is properly intialized. 
        // Don't proceed unless it is.
        //
        
        if (!CheckTapi(&m_pArgs->tlsTapiLink, g_hInst))
        {
            SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
            return;
        }   
    }

    //
    // Save connection type information
    //
    
    m_pArgs->SetDirectConnect(fDirect);
    m_pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryConnectionType, fDirect);
    

    //
    // If dial-up data was not initialized, there 
    // is no need to update phone number info.
    //

    if (m_bDialInfoInit)
    {

        //
        //   Store the current TAPI location
        //
        DWORD dwCurrentTapiLoc = GetCurrentTapiLocation(&m_pArgs->tlsTapiLink);
        if (-1 != dwCurrentTapiLoc)
        {
            m_pArgs->tlsTapiLink.dwTapiLocationForAccessPoint = dwCurrentTapiLoc;
            m_pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryTapiLocation, dwCurrentTapiLoc);
        }

        //
        // Update device name and type
        //

        lstrcpynU(m_pArgs->szDeviceName, m_szDeviceName, CELEMS(m_pArgs->szDeviceName));
        lstrcpynU(m_pArgs->szDeviceType, m_szDeviceType, CELEMS(m_pArgs->szDeviceType));

        //
        // Update the CMP
        //
    
        m_pArgs->piniProfile->WPPS(c_pszCmSection, 
                                 c_pszCmEntryDialDevice, 
                                 m_pArgs->szDeviceName);

        //
        // Check each number to see if we need to update CMP or connectoids
        //
        
        for (UINT i = 0; i < m_NumPhones; i++) 
        {   
            int iEditID = i ? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT;
        
            //
            // If Dialing Rules aren't used, it is likely that the user has 
            // modified the phone number, get number and munge it. In the 
            // case of fNoDialingRules we skip this test to be certain that 
            // we pick up any user changes.
            //
    
            if (!(m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES))           
            {                       
                pszTmp = CmGetWindowTextAlloc(m_hWnd, iEditID);
          
                if (*pszTmp) 
                {                                           
                    //
                    // Ensure that phone number doesn't exceed storage size
                    // Note: On W2K the edit limits prevent pasting an excess 
                    // amount of data, but we truncate to be positive across
                    // all versions of Windows.
                    //
                    
                    if (lstrlenU(pszTmp) > RAS_MaxPhoneNumber)
                    {
                        pszTmp[RAS_MaxPhoneNumber] = TEXT('\0');
                    }

                    //
                    // If we're ignoring dialing rules, just get our data directly
                    //

                    if (m_pArgs->fNoDialingRules)
                    {
                       lstrcpynU(m_DialInfo[i].szPhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szPhoneNumber));
                       lstrcpynU(m_DialInfo[i].szDisplayablePhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szDisplayablePhoneNumber));
                       lstrcpynU(m_DialInfo[i].szDialablePhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szDialablePhoneNumber));
                       m_DialInfo[i].szCanonical[0] = TEXT('\0');
                    }
                    else
                    {
                        LPTSTR pszPhone = CmStrCpyAlloc(pszTmp);
                        LPTSTR pszDialable = NULL;

                        MYDBGASSERT(m_szDeviceName[0]);

                        //
                        // Munge the number to ensure that we have the correct dialable
                        //
                        if (ERROR_SUCCESS != MungePhone(m_szDeviceName, 
                                             &pszPhone, 
                                             &m_pArgs->tlsTapiLink,
                                             g_hInst, 
                                             m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES,
                                             &pszDialable,
                                             m_pArgs->fAccessPointsEnabled))
                        {
                            CmFree(pszTmp);

                            //
                            // Can't format the number, notify user of the problem
                            //
                        
                            pszTmp = CmFmtMsg(g_hInst, IDMSG_CANTFORMAT);                                               
                            MessageBoxEx(m_hWnd, pszTmp, m_pArgs->szServiceName, 
                                         MB_OK | MB_ICONINFORMATION, LANG_USER_DEFAULT);
                            CmFree(pszTmp);
                            CmFree(pszPhone);
                            SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
                            return;                                 
                        }

                        //
                        // Update buffers
                        //
                        if (pszDialable)
                        {
                            lstrcpynU(m_DialInfo[i].szDialablePhoneNumber, pszDialable, CELEMS(m_DialInfo[i].szDialablePhoneNumber));
                        }

                        if (pszPhone)
                        {
                            lstrcpynU(m_DialInfo[i].szDisplayablePhoneNumber, pszPhone, CELEMS(m_DialInfo[i].szDisplayablePhoneNumber));
                        }
                    
                        //
                        // If we find a plus in the first char, assume that the user is
                        // attempting canonical format by hand and treat as a dialing 
                        // rules number. Either way, update the szPhoneNumber buffer.
                        //

                        if (pszTmp == CmStrchr(pszTmp, TEXT('+')))
                        {               
                            //
                            // Its hand-edited canonical. Store the canonical
                            // form in szCanonical, then strip the canonical 
                            // formatting before we store the number normally
                            //              
                        
                            m_DialInfo[i].dwPhoneInfoFlags |= PIF_USE_DIALING_RULES;
                    
                            lstrcpynU(m_DialInfo[i].szCanonical, pszTmp, CELEMS(m_DialInfo[i].szCanonical));
                            StripCanonical(pszTmp);         
                        }
                        else
                        {
                            //
                            // If UDR check is disabled, then its a hand edited number,
                            // so remove canonical form of the number - as an indicator.
                            // 
   
                            if (!IsWindowEnabled(GetDlgItem(m_hWnd, i ? 
                                                           IDC_GENERAL_UDR2_CHECKBOX : 
                                                           IDC_GENERAL_UDR1_CHECKBOX)))
                            {
                                m_DialInfo[i].szCanonical[0] = TEXT('\0');
                            }
                        }
                
                        lstrcpynU(m_DialInfo[i].szPhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szPhoneNumber));          
                        CmFree(pszDialable);
                        CmFree(pszPhone);
                    }
                }
                else
                {
                    //
                    // No number, clear everything
                    //

                    ZeroMemory(&m_DialInfo[i], sizeof(PHONEINFO));              
                }

                CmFree(pszTmp);
            }   
        
            //
            // Copy the new phone #'s back to our global struct
            //

            lstrcpynU(m_pArgs->aDialInfo[i].szPhoneBookFile, 
                     m_DialInfo[i].szPhoneBookFile, CELEMS(m_pArgs->aDialInfo[i].szPhoneBookFile));
            
            lstrcpynU(m_pArgs->aDialInfo[i].szDUN, 
                     m_DialInfo[i].szDUN, CELEMS(m_pArgs->aDialInfo[i].szDUN));
        
            lstrcpynU(m_pArgs->aDialInfo[i].szPhoneNumber, 
                     m_DialInfo[i].szPhoneNumber, CELEMS(m_pArgs->aDialInfo[i].szPhoneNumber));
            
            //
            // Always store canonical as canonical
            //

            lstrcpynU(m_pArgs->aDialInfo[i].szCanonical, 
                     m_DialInfo[i].szCanonical, CELEMS(m_pArgs->aDialInfo[i].szCanonical));

            lstrcpynU(m_pArgs->aDialInfo[i].szDialablePhoneNumber, 
                     m_DialInfo[i].szDialablePhoneNumber, CELEMS(m_pArgs->aDialInfo[i].szDialablePhoneNumber));
            
            lstrcpynU(m_pArgs->aDialInfo[i].szDisplayablePhoneNumber, 
                     m_DialInfo[i].szDisplayablePhoneNumber, CELEMS(m_pArgs->aDialInfo[i].szDisplayablePhoneNumber));

            lstrcpynU(m_pArgs->aDialInfo[i].szDesc, m_DialInfo[i].szDesc, CELEMS(m_pArgs->aDialInfo[i].szDesc));
            
            m_pArgs->aDialInfo[i].dwCountryID = m_DialInfo[i].dwCountryID;
            
            lstrcpynU(m_pArgs->aDialInfo[i].szServiceType,
                     m_DialInfo[i].szServiceType, CELEMS(m_pArgs->aDialInfo[i].szServiceType));
            
            lstrcpynU(m_pArgs->aDialInfo[i].szRegionName,
                     m_DialInfo[i].szRegionName, CELEMS(m_pArgs->aDialInfo[i].szRegionName));
        
            m_pArgs->aDialInfo[i].dwPhoneInfoFlags = m_DialInfo[i].dwPhoneInfoFlags;

            //
            // Write them out to cmp
            //
        
            PutPhoneByIdx(m_pArgs,
                          i, 
                          m_pArgs->aDialInfo[i].szPhoneNumber, 
                          m_pArgs->aDialInfo[i].szDesc,
                          m_pArgs->aDialInfo[i].szDUN,
                          m_pArgs->aDialInfo[i].dwCountryID, 
                          m_pArgs->aDialInfo[i].szRegionName,
                          m_pArgs->aDialInfo[i].szServiceType,
                          m_pArgs->aDialInfo[i].szPhoneBookFile,
                          m_pArgs->aDialInfo[i].szCanonical,
                          m_pArgs->aDialInfo[i].dwPhoneInfoFlags);

        } // for {}
    }

    //
    // Update fUseTunneling by examining first phonenumber.
    //
    
    if (fDirect)
    {
        m_pArgs->fUseTunneling = TRUE;
    }
    else
    {
        m_pArgs->fUseTunneling = UseTunneling(m_pArgs, 0);
    }

    if (FAILED(CheckAccessToCmpAndRasPbk(m_hWnd, m_pArgs)))
    {
        SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
        return;
    }
    else
    {
        SetPropSheetResult(PSNRET_NOERROR);
    }    

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::OnKillActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_KILLACTIVE
//            Notifies a page that it is about to lose activation either because 
//            another page is being activated or the user has clicked the OK button.
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CGeneralPage::OnKillActive()
{
    //
    // Notify the event listener for the current connection type selection
    //
    if (m_pEventListener)
    {
        m_pEventListener->OnGeneralPageKillActive(
            IsDlgButtonChecked(m_hWnd, IDC_RADIO_DIRECT));
    }

    //
    //  Hide any open balloon tips
    //
    if (m_pArgs->pBalloonTip)
    {
        m_pArgs->pBalloonTip->HideBalloonTip();
    }

    return 0;
}

//
// Help id pairs for the page
//
const DWORD CInetPage::m_dwHelp[] = {
        IDC_INET_USERNAME_STATIC,   IDH_INTERNET_USER_NAME,
        IDC_INET_USERNAME,          IDH_INTERNET_USER_NAME,
        IDC_INET_PASSWORD_STATIC,   IDH_INTERNET_PASSWORD,
        IDC_INET_PASSWORD,          IDH_INTERNET_PASSWORD,
        IDC_INET_REMEMBER,          IDH_INTERNET_SAVEPASS,
        0,0};

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::CInetPage
//
// Synopsis:  Constructor
//
// Arguments: ArgsStruct* pArgs - Information needed for the page
//            UINT nIDTemplate - Resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CInetPage::CInetPage(ArgsStruct* pArgs, UINT nIDTemplate) 
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
    m_fDirect = pArgs->IsDirectConnect();
}

//+---------------------------------------------------------------------------
//
//  Function:   OnInetInit
//
//  Synopsis:   Init the 'Internet Sign-In' properties property sheet.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//
//----------------------------------------------------------------------------
void CInetPage::OnInetInit(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
)
{
    //
    // The inet dialog/page is displayed only if fUseSameUserName is FALSE
    //
    MYDBGASSERT( pArgs->fUseSameUserName == FALSE);

    //
    // set the length limit for the edit controls
    //
    UINT i;
    
    HWND hwndUserName = GetDlgItem(hwndDlg, IDC_INET_USERNAME);
    if (hwndUserName)
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
        SendDlgItemMessageU(hwndDlg, IDC_INET_USERNAME, EM_SETLIMITTEXT, __min(UNLEN, i), 0);
        SetDlgItemTextU(hwndDlg, IDC_INET_USERNAME, pArgs->szInetUserName);
        SendMessageU(hwndUserName, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }

    HWND hwndInetPassword = GetDlgItem(hwndDlg, IDC_INET_PASSWORD);
    if (hwndInetPassword)
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
        SendDlgItemMessageU(hwndDlg, IDC_INET_PASSWORD, EM_SETLIMITTEXT, __min(PWLEN, i), 0);

        LPTSTR pszClearInetPassword = NULL;
        DWORD cbClearInetPassword = 0;
        BOOL fRetPassword = FALSE;

        fRetPassword = pArgs->SecureInetPW.GetPasswordWithAlloc(&pszClearInetPassword, &cbClearInetPassword);

        if (fRetPassword && pszClearInetPassword)
        {
            SetDlgItemTextU(hwndDlg, IDC_INET_PASSWORD, pszClearInetPassword);

            //
            // Clear and Free the clear-text password
            //

            pArgs->SecureInetPW.ClearAndFree(&pszClearInetPassword, cbClearInetPassword);
        }

        SendMessageU(hwndInetPassword, EM_SETMODIFY, (WPARAM)FALSE, 0L);

        //
        // hide and the "remember password checkbox if needed
        //
        if (pArgs->fHideRememberInetPassword)
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_INET_REMEMBER), SW_HIDE);
        }
        else
        {
            //
            // Check the button first, then adjust it.
            //
            CheckDlgButton(hwndDlg, IDC_INET_REMEMBER, pArgs->fRememberInetPassword);

            BOOL fPasswordOptional = pArgs->piniService->GPPB(c_pszCmSection,c_pszCmEntryPwdOptional);
            BOOL fEmptyPassword = pArgs->SecureInetPW.IsEmptyString();

            //
            // Enable/Disable check/uncheck the "Save Password" accordingly
            // fPasswordOptional is always FALSE for the dialog
            //
            AdjustSavePasswordCheckBox(GetDlgItem(hwndDlg, IDC_INET_REMEMBER), 
                    fEmptyPassword, pArgs->fDialAutomatically, fPasswordOptional);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnInetOk
//
//  Synopsis:   Save the data associated with the 'Internet Sign-In' property sheet.
//              when the user clicks OK.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//
//----------------------------------------------------------------------------
void CInetPage::OnInetOk(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
) 
{
    LPTSTR pszTmp = NULL;
 

    //
    // update password
    //
    
    if (GetDlgItem(hwndDlg, IDC_INET_PASSWORD))
    {       
        pszTmp = CmGetWindowTextAlloc(hwndDlg, IDC_INET_PASSWORD);

        if (!pArgs->fHideRememberInetPassword)
        {
            pArgs->fRememberInetPassword = IsDlgButtonChecked(hwndDlg, IDC_INET_REMEMBER);
            SaveUserInfo(pArgs,                      
                         UD_ID_REMEMBER_INET_PASSWORD, 
                         (PVOID)&pArgs->fRememberInetPassword); 
        }

        //
        // If don't remember password, then store an empty string, but keep
        // the existing one in memory. Otherwise, save the user's password.
        //

        if (pArgs->fRememberInetPassword)
        {
            if (OS_NT5)
            {
                //
                // If we are saving user creds, we can leave globals
                //
                if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                {
                    //
                    // Delete local/user since we are saving global credentials
                    //
                    DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                }
            }

            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pszTmp);
        }
        else
        {
            if (OS_NT5)
            {
                if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                {
                    //
                    // Deleting Internet Globals
                    //
                    if (CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                    }
                }
                else
                {
                    //
                    // Deleting Internet User
                    //
                    if (CM_EXIST_CREDS_INET_USER & pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                    }
                }
            }
            else
            {
                DeleteUserInfo(pArgs, UD_ID_INET_PASSWORD);
            }
        }
    
        //
        // Update pArgs
        //

        (VOID)pArgs->SecureInetPW.SetPassword(pszTmp);
        
        CmWipePassword(pszTmp);
        CmFree(pszTmp);
        pszTmp = NULL;
    }


    DWORD dwCurrentCreds = pArgs->dwCurrentCredentialType;

    //
    // If the user isn't saving his password and the credential
    // store is global, then we need to switch to the user
    // credential store in order to cache the user name for next use
    //
    if ((FALSE == pArgs->fRememberInetPassword) && 
        (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType))
    {
            pArgs->dwCurrentCredentialType = CM_CREDS_USER;
    }

    //
    // Get User name
    //
    if (GetDlgItem(hwndDlg, IDC_INET_USERNAME))
    {
        pszTmp = CmGetWindowTextAlloc(hwndDlg, IDC_INET_USERNAME);
        lstrcpyU(pArgs->szInetUserName, pszTmp);

        //
        // update username if we are saving credentials or
        // we are saving to the user/local credential store.
        //
        if ((pArgs->fRememberInetPassword) || (CM_CREDS_USER == pArgs->dwCurrentCredentialType))
        {
            SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pszTmp);
        }
        CmFree(pszTmp);
        pszTmp = NULL;
    }

    //
    // In case the current credential store was changed to user, we now
    // need to switch it back to global.
    //
    pArgs->dwCurrentCredentialType = dwCurrentCreds;

    //
    // Need to refresh to see which creds now exist since we could have saved or deleted some
    //
    BOOL fReturn = RefreshCredentialTypes(pArgs, FALSE);

    CmWipePassword(pszTmp);
    CmFree(pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::AdjustSavePasswordCheckBox
//
// Synopsis:  Enable/Disable, Check/Uncheck the "save Password" check box
//            according to other information
//
// Arguments: HWND hwndCheckBox - The window handle of "Save Password" check box
//            BOOL fEmptyPassword - Whether the password edit box is empty
//            BOOL fDialAutomatically - Whether dial automatically is checked
//            BOOL fPasswordOptional - Whether the password is optional
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/24/98
//
//+----------------------------------------------------------------------------
void CInetPage::AdjustSavePasswordCheckBox(HWND hwndCheckBox, BOOL fEmptyPassword, 
                           BOOL fDialAutomatically, BOOL fPasswordOptional)
{
    MYDBGASSERT(IsWindow(hwndCheckBox)); // if password hidden, no need to adjust

    //
    // Enable/Disable the check box
    //
    if (fDialAutomatically)
    {
        EnableWindow(hwndCheckBox, FALSE);
    }
    else if (fEmptyPassword && !fPasswordOptional)
    {
        EnableWindow(hwndCheckBox, FALSE);
    }
    else
    {
        EnableWindow(hwndCheckBox, TRUE);
    }

    //
    // Check/Uncheck the check box
    //
    if (fEmptyPassword && !fPasswordOptional)
    {
        //
        // If there is no password and password is not optional,
        // uncheck the checkbox
        //
        SendMessageU(hwndCheckBox, BM_SETCHECK, BST_UNCHECKED, 0);
    }
    else if (fDialAutomatically)
    {
        //
        // If dial automaticly, which means the checkbox is disabled,
        // check the box if has password or password is optional
        //
        SendMessageU(hwndCheckBox, BM_SETCHECK, BST_CHECKED, 0);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnInitDialog
//
// Synopsis:  Virtual function. Called upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CInetPage::OnInitDialog()
{
    UpdateFont(m_hWnd);

    m_fPasswordOptional = m_pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional);

    //
    // Initialize all the controls
    //
    OnInetInit(m_hWnd, m_pArgs);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CInetPage::OnCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
        case IDC_INET_PASSWORD:
            if ((HIWORD(wParam) == EN_CHANGE)) 
            {
                if (!m_pArgs->fHideRememberInetPassword && !m_pArgs->fHideInetPassword)
                {
                    //
                    // if there's no password, disable and uncheck "remember password"
                    //
                    BOOL fEmptyPassword = !SendDlgItemMessageU(m_hWnd, IDC_INET_PASSWORD, 
                        WM_GETTEXTLENGTH, 0, (LPARAM)0);

                    //
                    // Enable/Disable check/uncheck the "Save Password" accordingly
                    // fPasswordOptional is always FALSE for the dialog
                    //
                    AdjustSavePasswordCheckBox(GetDlgItem(m_hWnd, IDC_INET_REMEMBER), 
                            fEmptyPassword, m_pArgs->fDialAutomatically, m_fPasswordOptional);

                    return TRUE;
                }
            }
            break;

        case IDC_INET_REMEMBER:
            {
                // 
                // If the password wasn't modified by the user we want to clear
                // the edit box. Once the password edit box is empty the 
                // Save Password option is disabled, thus we don't ever need to 
                // reload the password from memory like on the main dialog.
                //
                BOOL fSavePW = IsDlgButtonChecked(m_hWnd, IDC_INET_REMEMBER);

                HWND hwndInetPW = GetDlgItem(m_hWnd, IDC_INET_PASSWORD);
                if (hwndInetPW)
                {
                    BOOL fInetPWChanged = (BOOL)SendMessageU(hwndInetPW, EM_GETMODIFY, 0L, 0L); 

                    if (FALSE == fSavePW && FALSE == fInetPWChanged)
                    {
                        //
                        // Didn't change thus clear the edit box
                        // 
                        SetDlgItemTextU(m_hWnd, IDC_INET_PASSWORD, TEXT(""));
                    }
                }
            }
            break;
        default:
            break;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnApply
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_APPLY
//            Indicates that the user clicked the OK or Apply Now button 
//            and wants all changes to take effect. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CInetPage::OnApply()
{
    //
    // Save information only if user chose dial-up
    //
    OnInetOk(m_hWnd, m_pArgs);

    SetPropSheetResult(PSNRET_NOERROR);
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnGeneralPageKillActive
//
// Synopsis:  Receive the KillActive event from General page
//
// Arguments: BOOL fDirect - Whehter the current connection type selection in
//                  General page is Direct
//
// Returns:   Nothing
//
// History:   Created Header    4/24/98
//
//+----------------------------------------------------------------------------
void CInetPage::OnGeneralPageKillActive(BOOL fDirect)
{
    m_fDirect = fDirect;
}


//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnSetActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_SETACTIVE
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CInetPage::OnSetActive()
{
    //
    // Enable/Disable the control according to the current connection type
    //
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_USERNAME_STATIC), !m_fDirect);
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_USERNAME), !m_fDirect);
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_PASSWORD_STATIC), !m_fDirect);
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_PASSWORD), !m_fDirect);

    if (m_fDirect)
    {
        EnableWindow(GetDlgItem(m_hWnd,IDC_INET_REMEMBER), FALSE);
    }
    else if (!m_pArgs->fHideRememberInetPassword && !m_pArgs->fHideInetPassword)
    {
        BOOL fEmptyPassword = !SendDlgItemMessageU(m_hWnd, 
                                                   IDC_INET_PASSWORD, 
                                                   WM_GETTEXTLENGTH, 
                                                   0, 
                                                   (LPARAM)0);
        //
        // Enable/Disable check/uncheck the "Save Password" accordingly
        // fPasswordOptional is always FALSE for the dialog
        //

        AdjustSavePasswordCheckBox(GetDlgItem(m_hWnd, IDC_INET_REMEMBER), 
                fEmptyPassword, m_pArgs->fDialAutomatically, m_fPasswordOptional);
    }

    return 0;
}


//
// Help id pairs
//
const DWORD COptionPage::m_dwHelp[] = {
        IDC_OPTIONS_IDLETIME_LIST,    IDH_OPTIONS_IDLEDIS,
        IDC_STATIC_MINUTES,           IDH_OPTIONS_IDLEDIS,
        IDC_OPTIONS_REDIALCOUNT_SPIN, IDH_OPTIONS_REDIAL,
        IDC_OPTIONS_REDIALCOUNT_EDIT, IDH_OPTIONS_REDIAL,
        IDC_STATIC_TIMES,             IDH_OPTIONS_REDIAL,
        IDC_OPTIONS_LOGGING,          IDH_OPTIONS_LOGGING,
        IDC_OPTIONS_CLEAR_LOG,        IDH_OPTIONS_CLEAR_LOG,
        IDC_OPTIONS_VIEW_LOG,        IDH_OPTIONS_VIEW_LOG,
        0,0};

const DWORD COptionPage::m_adwTimeConst[] = {0,1, 5, 10, 30, 1*60, 2*60, 4*60, 8*60, 24*60};
const int COptionPage::m_nTimeConstElements = sizeof(m_adwTimeConst)/sizeof(m_adwTimeConst[0]);

//+----------------------------------------------------------------------------
//
// Function:  COptionPage::COptionPage
//
// Synopsis:  Constructor
//
// Arguments: ArgsStruct* pArgs - Information needed for the page
//            UINT nIDTemplate - Resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
COptionPage::COptionPage(ArgsStruct* pArgs, UINT nIDTemplate) 
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
    m_fEnableLog = FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  COptionPage::InitIdleTimeList
//
// Synopsis:  Populate the IdleTime combo box and set the initial selection
//
// Arguments: HWND hwndList - Combo box window handle
//            DWORD dwMinutes - Time in minutes
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/22/98
//
//+----------------------------------------------------------------------------
void COptionPage::InitIdleTimeList(HWND hwndList, DWORD dwMinutes)
{
    MYDBGASSERT(hwndList);
    MYDBGASSERT(IsWindow(hwndList));

    //
    // Load the string from resource and populate the idle timeout list
    //
    MYDBGASSERT(IDS_IDLETIME_24HOURS - IDS_IDLETIME_NEVER == m_nTimeConstElements-1);
    for (int i= IDS_IDLETIME_NEVER; i<= IDS_IDLETIME_24HOURS; i++)
    {
        LPTSTR pszText = CmLoadString(g_hInst, i);
        MYDBGASSERT(pszText);
        SendMessageU(hwndList, CB_ADDSTRING, 0, (LPARAM)pszText);
        CmFree(pszText);
    }

    //
    // Value are round down for 1.0 profile
    // Note 0 means never.  We are safe, since there is no gap between 0 and 1 minute.
    //

    int nSel;   // the initial selection

    for (nSel=m_nTimeConstElements-1; nSel>=0;nSel--)
    {
        if (dwMinutes >= m_adwTimeConst[nSel])
        {
            break;
        }
    }

    SendMessageU(hwndList, CB_SETCURSEL, nSel, 0);
}



//+----------------------------------------------------------------------------
//
// Function:  COptionPage::GetIdleTimeList
//
// Synopsis:  Retrieve the IdleTime value selected
//
// Arguments: HWND hwndList - Combo box window handle
//
// Returns:   DWORD - User selected timeout value in minutes
//
// History:   fengsun Created Header    4/22/98
//
//+----------------------------------------------------------------------------
DWORD COptionPage::GetIdleTimeList(HWND hwndList)
{
    //
    // Get the current selection and convert it into minutes
    //

    DWORD dwSel = (DWORD)SendMessageU(hwndList, CB_GETCURSEL, 0, 0);

    MYDBGASSERT(dwSel < m_nTimeConstElements);
    if (dwSel >= m_nTimeConstElements)  // in case of CB_ERR
    {
        dwSel = 0;
    }

    return m_adwTimeConst[dwSel];
}



//+---------------------------------------------------------------------------
//
//  Function:   COptionPage::OnInitDialog()
//
//  Synopsis:   Init the Options property sheet.
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/12/97   - disable all controls in 
//                                              'Dialing with connectoid' mode
//----------------------------------------------------------------------------
BOOL COptionPage::OnInitDialog()
{
    UpdateFont(m_hWnd);

    //
    // init the "Idle timeout before hangup" 
    //
    InitIdleTimeList(GetDlgItem(m_hWnd, IDC_OPTIONS_IDLETIME_LIST), m_pArgs->dwIdleTimeout);

    //
    // init the "Number of redial attempt" 
    // Limit Redial edit field to 2 characters, redial spin 0-99
    //

    SendDlgItemMessageU(m_hWnd, IDC_OPTIONS_REDIALCOUNT_EDIT, EM_SETLIMITTEXT, MAX_REDIAL_CHARS, 0);
    SendDlgItemMessageU(m_hWnd, IDC_OPTIONS_REDIALCOUNT_SPIN, UDM_SETRANGE ,  0, MAKELONG(MAX_NUMBER_OF_REDIALS,0));
    SetDlgItemInt(m_hWnd, IDC_OPTIONS_REDIALCOUNT_EDIT, m_pArgs->nMaxRedials,  FALSE);
    
    //
    // set logging state
    //
    m_fEnableLog = m_pArgs->Log.IsEnabled();
    CheckDlgButton(m_hWnd, IDC_OPTIONS_LOGGING, m_fEnableLog);

    if (IsLogonAsSystem() || (FALSE == m_fEnableLog))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_VIEW_LOG), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_CLEAR_LOG), FALSE);
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  COptionPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   SumitC  Created  7/18/00
//
//+----------------------------------------------------------------------------
DWORD COptionPage::OnCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
    case IDC_OPTIONS_LOGGING:
        {
            BOOL fEnabled = ToggleLogging();

            if (FALSE == IsLogonAsSystem())
            {
                EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_VIEW_LOG), fEnabled);
                EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_CLEAR_LOG), fEnabled);
            }

            //
            //  Also, toggle the SafeNet log setting if we are using it...
            //
            if (ConfiguredToDialWithSafeNet(m_pArgs))
            {
                SafeNetLinkageStruct SnLinkage = {0};

                if (LinkToSafeNet(&SnLinkage))
                {
                    if (SnLinkage.pfnSnPolicySet(SN_USELOGFILE, (VOID*)&fEnabled))
                    {
                        MYVERIFY(0 != SnLinkage.pfnSnPolicyReload());
                    }
                    else
                    {
                        DWORD dwError = GetLastError();
                        CMTRACE1(TEXT("COptionPage::OnCommand -- unable to toggle the SafeNet log file.  SnPolicySet failed with GLE %d"), dwError);
                    }

                    UnLinkFromSafeNet(&SnLinkage);
                }
            }
        }
        break;

    case IDC_OPTIONS_CLEAR_LOG:
        MYDBGASSERT(FALSE == IsLogonAsSystem());
        if (FALSE == IsLogonAsSystem())
        {
            m_pArgs->Log.Clear();
            m_pArgs->Log.Log(CLEAR_LOG_EVENT);

            //
            //  Also, clear the SafeNet log if we are using it...
            //
            if (ConfiguredToDialWithSafeNet(m_pArgs))
            {
                SafeNetLinkageStruct SnLinkage = {0};
                BOOL bUseLogFile = FALSE;

                if (LinkToSafeNet(&SnLinkage))
                {
                    if (SnLinkage.pfnSnPolicySet(SN_USELOGFILE, (VOID*)&bUseLogFile) && SnLinkage.pfnSnPolicyReload())
                    {
                        LPTSTR pszFullPathToSafeNetLogFile = GetPathToSafeNetLogFile();

                        if (pszFullPathToSafeNetLogFile)
                        {
                            DWORD dwCount = 0;

                            //
                            //  Unfortunately, the SafeNet log file isn't always ready to be deleted when the
                            //  policy reload function returns.  Thus I have added this nasty little loop to
                            //  check to see if the file exists and then try to delete it.  If it fails to delete it
                            //  (usually with a last error of 0 in my testing), then we sleep for a second and try
                            //  again.  Usually it works the first or second time but we will try up to five times.
                            //  if it doesn't work by then not a huge loss...
                            //
                            while (FileExists(pszFullPathToSafeNetLogFile) && (dwCount <= 5))
                            {
                                if (0 == DeleteFileU(pszFullPathToSafeNetLogFile))
                                {
                                    CMTRACE(TEXT("COptionPage::OnCommand -- unable to delete the SafeNet log file.  Sleeping 1 second..."));
                                    Sleep(1000);
                                }

                                dwCount++;
                            }

                            CmFree(pszFullPathToSafeNetLogFile);

                            bUseLogFile = TRUE;
                            MYVERIFY(0 != SnLinkage.pfnSnPolicySet(SN_USELOGFILE, (VOID*)&bUseLogFile));
                            MYVERIFY(0 != SnLinkage.pfnSnPolicyReload());
                        }
                    }
                    else
                    {
                        DWORD dwError = GetLastError();
                        CMTRACE1(TEXT("COptionPage::OnCommand -- unable to clear the log file.  SnPolicySet failed with GLE %d"), dwError);
                    }

                    UnLinkFromSafeNet(&SnLinkage);
                }
            }
        }
        break;

    case IDC_OPTIONS_VIEW_LOG:
        MYDBGASSERT(FALSE == IsLogonAsSystem());
        if (FALSE == IsLogonAsSystem())
        {
            LPCTSTR pszLogFile = m_pArgs->Log.GetLogFilePath();

            HANDLE hFile = CreateFile(pszLogFile, 0,  
                                      FILE_SHARE_READ,
                                      NULL, OPEN_EXISTING, 
                                      FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                BOOL                bReturn;
                SHELLEXECUTEINFO    sei;

                ZeroMemory(&sei, sizeof(SHELLEXECUTEINFO));

                //
                //  Fill in the Execute Struct
                //
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.hwnd            = NULL;
                sei.lpVerb          = TEXT("open");
                sei.lpFile          = TEXT("notepad.exe");
                sei.lpParameters    = pszLogFile;
                sei.nShow           = SW_SHOWNORMAL;

                bReturn = m_pArgs->m_ShellDll.ExecuteEx(&sei);

                if (FALSE == bReturn)
                {
                    CMTRACE1(TEXT("COptionPage::OnCommand, failed to View Log, GLE=%d"), GetLastError());
                    
                    LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_CANT_VIEW_LOG, pszLogFile);
                    if (pszMsg)
                    {
                        MessageBox(m_hWnd, pszMsg, m_pArgs->szServiceName, MB_OK | MB_ICONERROR);
                        CmFree(pszMsg);
                    }        
                }

                CloseHandle(hFile);
            }
            else
            {
                CMTRACE(TEXT("COptionPage::OnCommand, no log file, nothing to view"));
                LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NO_LOG_FILE);
                if (pszMsg)
                {
                    MessageBox(m_hWnd, pszMsg, m_pArgs->szServiceName, MB_OK | MB_ICONERROR);
                    CmFree(pszMsg);
                }        
            }
        }

        break;
    }
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   COptionPage::OnApply()
//
//  Synopsis:   Save the data associated with the 'Options' property sheet.
//              when the user clicks OK.
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//
//----------------------------------------------------------------------------
void COptionPage::OnApply()
{   
    //
    // Accessing RedialCount and IdleTimeout.  Make sure to use piniBothNonFav 
    // because these settings are per user, per profile.
    //

    //
    // save the "Idle timeout before hangup"
    //
    m_pArgs->dwIdleTimeout = GetIdleTimeList(GetDlgItem(m_hWnd, IDC_OPTIONS_IDLETIME_LIST));
    m_pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryIdleTimeout, m_pArgs->dwIdleTimeout);

    //
    // save the redial settings
    //

    m_pArgs->nMaxRedials = GetDlgItemInt(m_hWnd, IDC_OPTIONS_REDIALCOUNT_EDIT, NULL, FALSE);
    m_pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryRedialCount, m_pArgs->nMaxRedials);

    //
    //  NOTE: Logging is enabled/disabled immediately when the logging checkbox
    //        is clicked.  Thus there is no code here to handle the Apply.
    //

    SetPropSheetResult(PSNRET_NOERROR);
}


//+----------------------------------------------------------------------------
//
// Function:  COptionPage::ToggleLogging
//
// Synopsis:  Helper function, responds to logging being enabled/disabled.
//
// Arguments: none
//
// Returns:   BOOL - Is logging now enabled or disabled?
//
// History:   SumitC  Created  11/07/00
//
//+----------------------------------------------------------------------------
BOOL COptionPage::ToggleLogging()
{
    //
    // save the Logging settings
    //

    BOOL fEnableLog = IsDlgButtonChecked(m_hWnd, IDC_OPTIONS_LOGGING);

    m_pArgs->piniBothNonFav->WPPB(c_pszCmSection, c_pszCmEntryEnableLogging, fEnableLog);
    
    if ((!!fEnableLog != !!m_fEnableLog))
    {
        // if the value has changed
        if (fEnableLog)
        {
            DWORD dwMaxSize  = m_pArgs->piniService->GPPI(c_pszCmSectionLogging, c_pszCmEntryMaxLogFileSize, c_dwMaxFileSize);
            LPTSTR pszFileDir = m_pArgs->piniService->GPPS(c_pszCmSectionLogging, c_pszCmEntryLogFileDirectory, c_szLogFileDirectory);

            m_pArgs->Log.SetParams(TRUE, dwMaxSize, pszFileDir); // TRUE == fEnabled

            CmFree(pszFileDir);

            m_pArgs->Log.Start(TRUE);   // TRUE => write a banner as well
            m_pArgs->Log.Log(LOGGING_ENABLED_EVENT);
        }
        else
        {
            m_pArgs->Log.Log(LOGGING_DISABLED_EVENT);
            m_pArgs->Log.Stop();
        }

        m_fEnableLog = fEnableLog;
    }

    return m_fEnableLog;
}


//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::CAboutPage
//
// Synopsis:  Constructor
//
// Arguments: UINT nIDTemplate - Dialog resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CAboutPage::CAboutPage(ArgsStruct* pArgs, UINT nIDTemplate)
    : CPropertiesPage(nIDTemplate)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;    
}

//+---------------------------------------------------------------------------
//
//  Function:   CAboutPage::OnInitDialog()
//
//  Synopsis:   Init the About property sheet.
//
//  Arguments:  m_hWnd [dlg window handle]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/12/97   - disable all controls in 
//                                              'Dialing with connectoid' mode
//----------------------------------------------------------------------------
BOOL CAboutPage::OnInitDialog()
{
    UpdateFont(m_hWnd);
                
    LPTSTR  pszTmp;
    LPTSTR  pszExt;
  
    //
    // Set the warning text.  We can't put it the dialog template because it's 
    // longer than 256 chars.
    //

    if (!(pszTmp = CmLoadString(g_hInst, IDMSG_ABOUT_WARNING_PART1)))
    {
        pszTmp = CmStrCpyAlloc(NULL);
    }

    if (!(pszExt = CmLoadString(g_hInst, IDMSG_ABOUT_WARNING_PART2)))
    {
        pszExt = CmStrCpyAlloc(NULL);
    }

    pszTmp = CmStrCatAlloc(&pszTmp, pszExt);

    SetDlgItemTextU(m_hWnd, IDC_ABOUT_WARNING, pszTmp);
    CmFree(pszTmp);
    CmFree(pszExt);

    //#150147
    
    LPTSTR pszVersion = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lstrlenA(VER_PRODUCTVERSION_STR) + 1));

    if (pszVersion)
    {
        wsprintfU(pszVersion, TEXT("%S"), VER_PRODUCTVERSION_STR);

        if (!(pszTmp = CmFmtMsg(g_hInst, IDMSG_ABOUT_BUILDVERSION, pszVersion)))
        {
            pszTmp = CmStrCpyAlloc(pszVersion);
        }

        CmFree(pszVersion);

        if (pszTmp)
        {
            SetDlgItemTextU(m_hWnd, IDC_ABOUT_VERSION, pszTmp);
            CmFree(pszTmp);
        }
    }

    return (TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnOtherMessage
//
// Synopsis:  Callup opun message other than WM_INITDIALOG and WM_COMMAND
//
// Arguments: UINT - Message Id
//            WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CAboutPage::OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM )
{
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CAboutPage::OnSetActive()
//
//  Synopsis:   Creates DI bitmap, etc. for about tab bitmap
//
//  Arguments:  None
//              
//
//  Returns:    NONE
//
//  History:    nickball    Created     7/14/97
//
//----------------------------------------------------------------------------

BOOL CAboutPage::OnSetActive()
{
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnKillActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_KILLACTIVE
//            Notifies a page that it is about to lose activation either because 
//            another page is being activated or the user has clicked the OK button.
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CAboutPage::OnKillActive()
{
    return 0;
}


//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnApply
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_APPLY
//            Indicates that the user clicked the OK or Apply Now button 
//            and wants all changes to take effect. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CAboutPage::OnApply()
{
    SetPropSheetResult(PSNRET_NOERROR);
}

//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnReset
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_RESET
//            Notifies a page that the user has clicked the Cancel button and 
//            the property sheet is about to be destroyed. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CAboutPage::OnReset()
{
    //nothing
}

//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   v-vijayb Created Header    7/3/99
//
//+----------------------------------------------------------------------------
BOOL CChangePasswordDlg::OnInitDialog()
{
    DWORD cMaxPassword;

    SetForegroundWindow(m_hWnd);

    m_pArgs->hWndChangePassword = m_hWnd;   
    UpdateFont(m_hWnd);

    int iMaxPasswordFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);

    if (InBetween(0, iMaxPasswordFromCMS, PWLEN))
    {
        cMaxPassword = iMaxPasswordFromCMS;    
    }
    else
    {
        cMaxPassword = PWLEN;
    }

    SendDlgItemMessageU(m_hWnd, IDC_NEW_PASSWORD, EM_SETLIMITTEXT, cMaxPassword, 0);
    SendDlgItemMessageU(m_hWnd, IDC_CONFIRMNEWPASSWORD, EM_SETLIMITTEXT, cMaxPassword, 0);
    SetFocus(GetDlgItem(m_hWnd, IDC_NEW_PASSWORD));

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
}



//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   v-vijayb Created Header    7/3/99
//
//+----------------------------------------------------------------------------
void CChangePasswordDlg::OnOK()
{
    TCHAR           szNewConfirmPassword[PWLEN+1];
    TCHAR           szNewPassword[PWLEN+1];

    GetDlgItemText(m_hWnd, IDC_NEW_PASSWORD, szNewPassword, PWLEN+1);
    GetDlgItemText(m_hWnd, IDC_CONFIRMNEWPASSWORD, szNewConfirmPassword, PWLEN+1);
    
    //
    // Both must match exactly
    //

    if (lstrcmpU(szNewPassword, szNewConfirmPassword) == 0)
    {
        //
        // Process password according to our handling rules
        //

        ApplyPasswordHandlingToBuffer(m_pArgs, szNewPassword);         
        
        //
        // Now we need to figure which credentials these are.
        // This used to work because we were directly using RASDIALPARAMS,
        // but by removing it, we need to figure out the type of password
        // we need to save.
        //
        BOOL fUsingInetCredentials = (!m_pArgs->fUseSameUserName &&
                                      !IsDialingTunnel(m_pArgs) && 
                                      UseTunneling(m_pArgs, m_pArgs->nDialIdx));

        if (fUsingInetCredentials)
        {
            (VOID)m_pArgs->SecureInetPW.SetPassword(szNewPassword);
            m_pArgs->fChangedInetPassword = TRUE;
        }
        else
        {
            // 
            // Securely store password in memory.
            // 

            (VOID)m_pArgs->SecurePW.SetPassword(szNewPassword);
            m_pArgs->fChangedPassword = TRUE;
        }

        m_pArgs->hWndChangePassword = NULL;

        m_pArgs->Log.Log(PASSWORD_EXPIRED_EVENT, TEXT("ok"));
        
        EndDialog(m_hWnd, TRUE);
    }
    else
    {
        HWND    hWnd = GetDlgItem(m_hWnd, IDC_NEW_PASSWORD);
        MYDBGASSERT(hWnd);

        if (hWnd)
        {
            TCHAR   *pszTmp;
                
        
            pszTmp = CmFmtMsg(g_hInst, IDMSG_NOMATCHPASSWORD);                                              
            MYDBGASSERT(pszTmp);
            if (pszTmp)
            {
                MessageBoxEx(m_hWnd, pszTmp, m_pArgs->szServiceName, MB_OK | MB_ICONERROR, LANG_USER_DEFAULT);
                CmFree(pszTmp);
            }
        
            SetFocus(hWnd);
            SendMessageU(hWnd, EM_SETSEL, 0, MAKELONG(0, -1));
        }
    }

    CmWipePassword(szNewConfirmPassword);
    CmWipePassword(szNewPassword);
}

//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnCancel
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   v-vijayb Created Header    7/16/99
//
//+----------------------------------------------------------------------------
void CChangePasswordDlg::OnCancel()
{
    m_pArgs->fChangedPassword = FALSE;
    m_pArgs->fChangedInetPassword = FALSE;
    m_pArgs->hWndChangePassword = NULL;
    m_pArgs->Log.Log(PASSWORD_EXPIRED_EVENT, TEXT("cancel"));
    EndDialog(m_hWnd, FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   v-vijayb Created Header    7/3/99
//
//+----------------------------------------------------------------------------
DWORD CChangePasswordDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
BOOL CCallbackNumberDlg::OnInitDialog()
{
    SetForegroundWindow(m_hWnd);

    //
    // Store window handle globally and setup edit control
    //

    m_pArgs->hWndCallbackNumber = m_hWnd;   
    UpdateFont(m_hWnd);

    SendDlgItemMessageU(m_hWnd, IDC_CALLBACK_NUM_EDIT, EM_SETLIMITTEXT, RAS_MaxCallbackNumber , 0);

    //
    // See if we have anything from previous use. If so, add it to the control.
    //

    SetWindowTextU(GetDlgItem(m_hWnd, IDC_CALLBACK_NUM_EDIT), m_pArgs->pRasDialParams->szCallbackNumber);   

    //
    // Set focus, must return FALSE when doing so.
    //

    SetFocus(GetDlgItem(m_hWnd, IDC_CALLBACK_NUM_EDIT));

    return FALSE; 
}

//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//            Retrieves the number for callback and stores in dial params.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CCallbackNumberDlg::OnOK()
{
    TCHAR szNumber[RAS_MaxCallbackNumber+1];

    GetDlgItemText(m_hWnd, IDC_CALLBACK_NUM_EDIT, szNumber, RAS_MaxCallbackNumber);

    // 
    // Although one would expect that the length of the number would be 
    // verified, this is not the case with RAS. In the interests of
    // behavioral parity we will allow an empty number field. 
    //
  
    //
    // We're good to go, fill in Dial Params and ski-dadle.
    //

    lstrcpyU(m_pArgs->pRasDialParams->szCallbackNumber, szNumber);

    //
    // Succesful callback, store the number in the .CMP
    // 

    m_pArgs->piniProfile->WPPS(c_pszCmSection, c_pszCmEntryCallbackNumber, m_pArgs->pRasDialParams->szCallbackNumber);
                
    m_pArgs->hWndCallbackNumber = NULL;

    m_pArgs->Log.Log(CALLBACK_NUMBER_EVENT, TEXT("ok"), m_pArgs->pRasDialParams->szCallbackNumber);

    EndDialog(m_hWnd, TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnCancel
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CCallbackNumberDlg::OnCancel()
{
    m_pArgs->fWaitingForCallback = FALSE;
    m_pArgs->hWndCallbackNumber = NULL;
    m_pArgs->Log.Log(CALLBACK_NUMBER_EVENT, TEXT("cancel"), TEXT("none"));
    EndDialog(m_hWnd, FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
DWORD CCallbackNumberDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    return FALSE;
}

//
// No help on OK or Cancel button
//
const DWORD CRetryAuthenticationDlg::m_dwHelp[] = {
        IDC_RETRY_REMEMBER,         IDH_RETRY_REMEMBER,
        IDC_RETRY_USERNAME_STATIC,  IDH_RETRY_USERNAME_STATIC,
        IDC_RETRY_USERNAME,         IDH_RETRY_USERNAME,
        IDC_RETRY_PASSWORD_STATIC,  IDH_RETRY_PASSWORD_STATIC,
        IDC_RETRY_PASSWORD,         IDH_RETRY_PASSWORD,
        IDC_RETRY_DOMAIN_STATIC,    IDH_RETRY_DOMAIN_STATIC,
        IDC_RETRY_DOMAIN,           IDH_RETRY_DOMAIN,
        IDOK,                       IDH_RETRY_OK,
        IDCANCEL,                   IDH_RETRY_CANCEL,
        0,0};

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message to intialize
//            the dialog.
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
BOOL CRetryAuthenticationDlg::OnInitDialog()
{   
    DWORD dwMax = MAX_PATH;

    m_pArgs->Log.Log(RETRY_AUTH_EVENT);

    SetForegroundWindow(m_hWnd);
    
    //
    // Brand the dialog
    //

    if (m_pArgs->hSmallIcon)
    {
        SendMessageU(m_hWnd, WM_SETICON, ICON_SMALL, (LPARAM) m_pArgs->hSmallIcon); 
    }

    if (m_pArgs->hBigIcon)
    {        
        SendMessageU(m_hWnd, WM_SETICON, ICON_BIG, (LPARAM) m_pArgs->hBigIcon); 
        SendMessageU(GetDlgItem(m_hWnd, IDC_INET_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM) m_pArgs->hBigIcon); 
    }

    //
    // Store window handle globally and setup edit control
    //

    m_pArgs->hWndRetryAuthentication = m_hWnd;  
    UpdateFont(m_hWnd);
    
    //
    // If not Inet dial, then use the service as the title
    //

    if (!m_fInetCredentials)
    {
        LPTSTR pszTitle = CmStrCpyAlloc(m_pArgs->szServiceName);
        SetWindowTextU(m_hWnd, pszTitle);
        CmFree(pszTitle);
    }
    
    //
    // Fill password as appropriate to the template and dial type.
    //

    HWND hwndPassword = GetDlgItem(m_hWnd, IDC_RETRY_PASSWORD);

    if (hwndPassword)
    {
        //
        // Limit user entry according to current config.
        // 
        int iMaxPasswordFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);

        if (InBetween(0, iMaxPasswordFromCMS, PWLEN))
        {
            dwMax = iMaxPasswordFromCMS;    
        }
        else
        {
            dwMax = PWLEN;
        }

        SendDlgItemMessageU(m_hWnd, IDC_RETRY_PASSWORD, EM_SETLIMITTEXT, dwMax, 0);
        MYDBGASSERT(dwMax <= PWLEN && dwMax > 0);
                      
        //
        // Do we have any data to display?
        //
        
        BOOL fHasPassword = FALSE;

        if (m_fInetCredentials)           
        {            
            if (FALSE == m_pArgs->SecureInetPW.IsEmptyString())
            {
                LPTSTR pszClearInetPassword = NULL;
                DWORD cbClearInetPassword = 0;
                BOOL fRetPassword = FALSE;

                fRetPassword = m_pArgs->SecureInetPW.GetPasswordWithAlloc(&pszClearInetPassword, &cbClearInetPassword);

                if (fRetPassword && pszClearInetPassword)
                {
                    SetDlgItemTextU(m_hWnd, IDC_RETRY_PASSWORD, pszClearInetPassword);
                    fHasPassword = TRUE;

                    //
                    // Clear and Free the clear-text password
                    //

                    m_pArgs->SecureInetPW.ClearAndFree(&pszClearInetPassword, cbClearInetPassword);
                }
            }
        }        
        else
        {
            if (FALSE == m_pArgs->SecurePW.IsEmptyString())
            {
                LPTSTR pszClearPassword = NULL;
                DWORD cbClearPassword = 0;
                BOOL fRetPassword = FALSE;

                fRetPassword = m_pArgs->SecurePW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

                if (fRetPassword && pszClearPassword)
                {
                    SetDlgItemTextU(m_hWnd, IDC_RETRY_PASSWORD, pszClearPassword);
                    fHasPassword = TRUE;
                    
                    //
                    // Clear and Free the clear-text password
                    //

                    m_pArgs->SecurePW.ClearAndFree(&pszClearPassword, cbClearPassword);
                }
            }
        }

        //
        // Decide what to do with "Save Password" check-box
        //
        
        HWND hwndSavePassword = GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER);

        if (hwndSavePassword)
        {
            // 
            // We have a save password control, see if we should hide it. 
            //

            if ((m_fInetCredentials && m_pArgs->fHideRememberInetPassword) ||
                (!m_fInetCredentials && m_pArgs->fHideRememberPassword))
            {
                ShowWindow(hwndSavePassword, SW_HIDE);
            }
            else
            {
                //
                // We're not hiding, so adjust its state as needed. If no data
                // then disable the control. Otherwise check according to current
                // user setting.
                //

                if (!fHasPassword)
                {
                    EnableWindow(GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER), FALSE);
                }
                else
                {
                    if ((m_fInetCredentials && m_pArgs->fRememberInetPassword) ||
                        (!m_fInetCredentials && m_pArgs->fRememberMainPassword))
                    {
                        SendMessageU(hwndSavePassword, BM_SETCHECK, BST_CHECKED, 0);
                    }
                }
            }
        }
    }

    //
    // Fill username as appropriate to the template and dial type.
    //
    
    HWND hwndUsername = GetDlgItem(m_hWnd, IDC_RETRY_USERNAME);

    if (hwndUsername)
    {
        int iMaxUserNameFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);

        if (InBetween(0, iMaxUserNameFromCMS, UNLEN))
        {
            dwMax = iMaxUserNameFromCMS;    
        }
        else
        {
            dwMax = UNLEN;
        }

        SendDlgItemMessageU(m_hWnd, IDC_RETRY_USERNAME, EM_SETLIMITTEXT, dwMax, 0);
        MYDBGASSERT(dwMax <= UNLEN);
               
        if (m_fInetCredentials)           
        {            
            if (lstrlenU(m_pArgs->szInetUserName))
            {
                SetDlgItemTextU(m_hWnd, IDC_RETRY_USERNAME, m_pArgs->szInetUserName);
            }
        }        
        else
        {
            if (lstrlenU(m_pArgs->szUserName))
            {
                SetDlgItemTextU(m_hWnd, IDC_RETRY_USERNAME, m_pArgs->szUserName);
            }
        }
    }

    //
    // Fill domain as appropriate to the template.
    //

    HWND hwndDomain = GetDlgItem(m_hWnd, IDC_RETRY_DOMAIN);
    
    if (hwndDomain)
    {
        int iMaxDomainFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);

        if (InBetween(0, iMaxDomainFromCMS, DNLEN))
        {
            dwMax = iMaxDomainFromCMS;    
        }
        else
        {
            dwMax = DNLEN;
        }

        SendDlgItemMessageU(m_hWnd, IDC_RETRY_DOMAIN, EM_SETLIMITTEXT, dwMax, 0);
        MYDBGASSERT(dwMax <= DNLEN);       
       
        if (lstrlenU(m_pArgs->szDomain))
        {
            SetDlgItemTextU(m_hWnd, IDC_RETRY_DOMAIN, m_pArgs->szDomain);
        }
    }

    //
    // Drop focus in the first available control
    //

    HWND hwndFocus = hwndUsername;
    
    if (!hwndFocus)
    {
        hwndFocus = hwndPassword ? hwndPassword : hwndDomain;   
    }
    
    SetFocus(hwndFocus);

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//            Retrieves the cerdentials and stores them in dial params.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CRetryAuthenticationDlg::OnOK()
{
    LPTSTR pszBuf = NULL;
    BOOL fSave = FALSE;

    //
    // Check Save Password (if any) to see how we should proceed
    //
    
    BOOL fSwitchToUserCredentials = FALSE;
    BOOL fNeedToResaveUserName = FALSE;
    BOOL fNeedToResaveDomain = FALSE;
    BOOL fChecked = FALSE;
    
    HWND hwndMainDlgSavePW = GetDlgItem(m_pArgs->hwndMainDlg, IDC_MAIN_NOPASSWORD_CHECKBOX);
    HWND hwndMainDlgDialAutomatically = GetDlgItem(m_pArgs->hwndMainDlg, IDC_MAIN_NOPROMPT_CHECKBOX);
    BOOL fMainDlgSavePWEnabled = FALSE;
    BOOL fMainDlgDialAutoEnabled = FALSE;

    //
    // In order not to trigger change notification when updating Main dialog controls.
    // This is set back to FALSE at the bottom of the funtion.
    //
    m_pArgs->fIgnoreChangeNotification = TRUE;


    //
    // Gets the inital state of the checkboxes
    //
    if (hwndMainDlgSavePW)
    {
        fMainDlgSavePWEnabled = IsWindowEnabled(hwndMainDlgSavePW);
    }

    if (hwndMainDlgDialAutomatically)
    {
        fMainDlgDialAutoEnabled = IsWindowEnabled(hwndMainDlgDialAutomatically);
    }

    if (GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER))
    {
        fChecked = IsDlgButtonChecked(m_hWnd, IDC_RETRY_REMEMBER);


        if (m_fInetCredentials)
        {
            if (m_pArgs->fRememberInetPassword != fChecked)
            {          

                if (fChecked && (FALSE == m_pArgs->fRememberInetPassword))
                {
                    //
                    // This time around the user wants to save credentials,
                    // but before (in main dialog) he didn't want to save anything.
                    // Thus we should resave username and domain
                    //
                    fNeedToResaveUserName = TRUE;
                }

                m_pArgs->fRememberInetPassword = fChecked;             

                //
                // Even at winlogon the user should be able to save the RememberInternet Password
                // checkbox. Plus we don't want to be saving the password for ICS, although
                // this case should not happen.
                //
                if (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType)
                {
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_REMEMBER_INET_PASSWORD, 
                                 (PVOID)&m_pArgs->fRememberInetPassword);

                }
            }
        }
        else
        {
            if (m_pArgs->fRememberMainPassword != fChecked)
            {          
                if (fChecked && (FALSE == m_pArgs->fRememberMainPassword))
                {
                    //
                    // This time around the user wants to save credentials,
                    // but before (in main dialog) he didn't want to save anything.
                    // Thus we should resave username and domain
                    //
                    fNeedToResaveUserName = TRUE;
                    fNeedToResaveDomain = TRUE;
                }

                m_pArgs->fRememberMainPassword = fChecked;        

                if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                {
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_REMEMBER_PWD, 
                                 (PVOID)&m_pArgs->fRememberMainPassword);               
                }

                //
                // There has been a change to main creds, update main display
                //
                CheckDlgButton(m_pArgs->hwndMainDlg, 
                           IDC_MAIN_NOPASSWORD_CHECKBOX, 
                           m_pArgs->fRememberMainPassword);
            }
        }
    }
    
    

    //
    // If the password field is enabled & the save pw checkbox is unchecked then delete creds.
    // But not for ICS case.
    //
    HWND hwndPassword = GetDlgItem(m_hWnd, IDC_RETRY_PASSWORD);

    if (hwndPassword && OS_NT51 && (FALSE == fChecked) && (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType))
    {
        if (CM_CREDS_GLOBAL == m_pArgs->dwCurrentCredentialType)
        {
            //
            // Since the user has unchecked the 'Save Password' flag and the current credential type is global,
            // we are deleting globals, but we need to save the userinfo into the USER (local) credential store 
            // in order for CM to correctly pick up the username and password on next launch.
            //
            fSwitchToUserCredentials = TRUE;
        }

        if (m_fInetCredentials)
        {
            //
            // Unsaving Internet credentials
            // Even if we are using the same username, we shouldn't delete main credentials
            // on this dialog, since we are re-authing for Internet credentials
            //
            if (CM_CREDS_GLOBAL == m_pArgs->dwCurrentCredentialType)
            {
                //
                // Unsaving Internet Global
                //

                //
                // Local Inet shouldn't exist in this case, so we shouldn't delete the Identity,
                // but for globals, we don't support just deleting password. This is from the RAS
                // code base and the delete function actually enforces this.
                //
                if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                {
                    DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                }
            }
            else
            {
                //
                // Unsaving Internet local (user)
                // Even if we are using the same username, we shouldn't delete main credentials
                // on this dialog, since we are just re-authing for Internet password
                //
                if (CM_EXIST_CREDS_INET_USER & m_pArgs->dwExistingCredentials)
                {
                    //
                    // Internet user credentials exist, so now delete the identity based on if the 
                    // global inet creds exist
                    //
                    if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    }
                    else
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                    }
                    
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                }
            }
        }
        else
        {
            //
            // ReAuth for Main credentials & Delete main set of credentials
            // Most of this code is taken from a section in TryToDeleteAndSaveCredentials
            // since most of the logic remains the same if the user unchecks the 'Save Password' 
            // option on the main dialog, except that here we don't prompt the user.
            // If the user got promted it happened on the main dialog and the creds were either
            // kept or deleted according to his selection. Thus we don't need to ask here.
            //
       
            //
            // Check which option button is currently selected
            //
            if (CM_CREDS_GLOBAL == m_pArgs->dwCurrentCredentialType)
            {
                //
                // Since global is selected then we actually want to delete both sets of credentials
                //

                if (CM_EXIST_CREDS_MAIN_GLOBAL & m_pArgs->dwExistingCredentials)
                {
                    //
                    // Delete the global credentials.  
                    // Note from RAS codebase: Note that we have to delete the global identity 
                    // as well because we do not support deleting 
                    // just the global password.  This is so that 
                    // RasSetCredentials can emulate RasSetDialParams.
                    //

                    DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
                }

                if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                {
                    if (m_pArgs->fUseSameUserName || (FALSE == m_pArgs->fRememberInetPassword))
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                    }
                }
            }
            else
            {
                //
                // Delete the password saved per-user.  Keep the user name
                // and domain saved, however unless global credentials exist.
                // Whenever global credential exist, and we are deleting user credentials
                // we must always delete all of the information (identity + password) associated
                // with the user credentials. 
                //

                if (CM_EXIST_CREDS_MAIN_USER & m_pArgs->dwExistingCredentials)
                {
                    if (CM_EXIST_CREDS_MAIN_GLOBAL & m_pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    }
                    else
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                    }
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;
                }

                if (CM_EXIST_CREDS_INET_USER & m_pArgs->dwExistingCredentials)
                {
                    if (m_pArgs->fUseSameUserName || (FALSE == m_pArgs->fRememberInetPassword))
                    {
                        if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                        {
                            DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        }
                        else
                        {
                            DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                        }
                        m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                    }
                }
            }
        }
    }

    if (fSwitchToUserCredentials)
    {
        //
        // Since this flag was set when we deleted global credentials, we need 
        // to save the userinfo into the USER (local) credential store 
        // in order for CM to correctly pick up the username and password on next launch.
        // We cannnot store userinfo w/o a password in the global store, because the RAS API 
        // doesn't support that. (From rasdlg code).
        //

        m_pArgs->dwCurrentCredentialType = CM_CREDS_USER;
    }


    if (hwndPassword)
    {       
        pszBuf = CmGetWindowTextAlloc(m_hWnd, IDC_RETRY_PASSWORD);

        if (pszBuf)
        {
            //
            // Process password according to our handling and encoding rules. 
            //

            ApplyPasswordHandlingToBuffer(m_pArgs, pszBuf);         

            //
            // Password is prepped, update our memory based storage.
            //

            if (m_fInetCredentials)
            {
                (VOID)m_pArgs->SecureInetPW.SetPassword(pszBuf);
            }
            else
            {
                (VOID)m_pArgs->SecurePW.SetPassword(pszBuf);
            }

            //
            // Make sure we set the persistent user info store correctly. 
            // Blank if save password is not checked or if we aren't using ras
            // cred store. On Win2K+ the creds we marked and deleted so passwords
            // doesn't need to be set to blank.
            //

            if (m_fInetCredentials)
            {
                if (OS_NT5 && m_pArgs->bUseRasCredStore)
                {
                    // 
                    // For Win2K+ we have the ras store. If the checkbox is checked 
                    // and a user is logged in then we want to save it.
                    // To fix a bug and stay consistent, at winlogon the user
                    // is allowed to save the Internet Password. We don't want to
                    // save the password for ICS although this case should not happen.
                    //
                    if (fChecked && (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType))
                    {
                        SaveUserInfo(m_pArgs, 
                                     UD_ID_INET_PASSWORD, 
                                     (PVOID)pszBuf);
                    }
                }
                else
                {
                    //
                    // We don't have to ras cred store so we either save the password
                    // or set it to an empty string since deleting marked credentials 
                    // doesn't do anything on no Win2K+ platforms
                    //
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_INET_PASSWORD, 
                                 (PVOID) (fChecked ? pszBuf : TEXT("")));
                }
            }
            else
            {
                if (OS_NT5 && m_pArgs->bUseRasCredStore)
                {
                    // 
                    // For Win2K+ we have the ras store. If the checkbox is checked 
                    // and a user is logged in then we want to save it.
                    //
                    if (fChecked && CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                    {
                        SaveUserInfo(m_pArgs, 
                                     UD_ID_PASSWORD, 
                                     (PVOID)pszBuf);
                    }
                }
                else
                {
                    //
                    // We don't have to ras cred store so we either save the password
                    // or set it to an empty string since deleting marked credentials 
                    // doesn't do anything on no Win2K+ platforms
                    //
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_PASSWORD, 
                                 (PVOID) (fChecked ? pszBuf : TEXT("")));
                }
                //
                // If there's been a change to main creds, update main display.
                //

                if (SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L))
                {
                    SetDlgItemTextU(m_pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT, pszBuf);
                }
            }

            CmWipePassword(pszBuf); // Clear before release
            CmFree(pszBuf);
        }
    }   
 

    //
    // Retrieve Domain and copy to CM data store and RasDialParams. We process
    // the domain first because the construction of the username that we hand
    // to RAS depends on it.
    //
    // Note: RAS updates its store whenever the users selects OK. We will too.
    //

    HWND hwndDomain = GetDlgItem(m_hWnd, IDC_RETRY_DOMAIN);

    //
    // If the checkbox is false, the creds were
    // deleted above so we now need to re-save the domain.
    //
    if ((hwndDomain && SendMessageU(hwndDomain, EM_GETMODIFY, 0L, 0L)) || 
        (hwndDomain && FALSE == fChecked) ||
        (hwndDomain && fNeedToResaveDomain))
    {
        pszBuf = CmGetWindowTextAlloc(m_hWnd, IDC_RETRY_DOMAIN);
    
        if (pszBuf)
        {
            lstrcpyU(m_pArgs->szDomain, pszBuf);
            lstrcpyU(m_pArgs->pRasDialParams->szDomain, pszBuf);

            if (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType)
            {
                SaveUserInfo(m_pArgs, UD_ID_DOMAIN, (PVOID)pszBuf);          
            }

            //
            // There has been a change to main creds, update main display
            //

            SetDlgItemTextU(m_pArgs->hwndMainDlg, IDC_MAIN_DOMAIN_EDIT, pszBuf);        

            CmFree(pszBuf);
        }
    }

    if (NULL == hwndDomain && FALSE == m_fInetCredentials)
    {
        //
        // The domain field is hidden, but we still need to save the domain info from the
        // pArgs structure in order for us to pre-populate later if it's not internet creds.
        // 
        if (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType)
        {
            SaveUserInfo(m_pArgs, UD_ID_DOMAIN, (PVOID)m_pArgs->szDomain);          
        }
    }
    //
    // Retrieve UserName and copy to CM data store and the RasDialParams struct
    //
    HWND hwndUsername = GetDlgItem(m_hWnd, IDC_RETRY_USERNAME);
    
    //
    // If the checkbox is false, the creds were
    // deleted above so we now need to re-save the username.
    //
    if ((hwndUsername && SendMessageU(hwndUsername, EM_GETMODIFY, 0L, 0L)) ||
        (hwndUsername && FALSE == fChecked) ||
        (hwndUsername && fNeedToResaveUserName))
    {
        pszBuf = CmGetWindowTextAlloc(m_hWnd, IDC_RETRY_USERNAME);

        if (pszBuf)
        {
            if (m_fInetCredentials)
            {
                lstrcpyU(m_pArgs->szInetUserName, pszBuf);
                SaveUserInfo(m_pArgs, UD_ID_INET_USERNAME, (PVOID)pszBuf);
            }
            else
            {
                lstrcpyU(m_pArgs->szUserName, pszBuf);
                if (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType)
                {
                    SaveUserInfo(m_pArgs, UD_ID_USERNAME, (PVOID)pszBuf);
                }

                //
                // There has been a change to main creds, update main display
                //

                SetDlgItemTextU(m_pArgs->hwndMainDlg, IDC_MAIN_USERNAME_EDIT, pszBuf);        
            }

            //
            // We'll need the service file for the current number. If we're actively
            // tunneling, make sure that we get the top-level service files, so we
            // don't pick up any settings from a referenced dial-up service.
            //
            
            CIni *piniService = NULL;
            BOOL bNeedToFree = FALSE;
            
            if (IsDialingTunnel(m_pArgs))
            {
                piniService = m_pArgs->piniService;
            }
            else
            {
                piniService = GetAppropriateIniService(m_pArgs, m_pArgs->nDialIdx);
                bNeedToFree = TRUE;
            }

            MYDBGASSERT(piniService);
       
            if (piniService)
            {
                //
                // Apply suffix, prefix, to username as necessary
                //

                LPTSTR pszTmp = ApplyPrefixSuffixToBufferAlloc(m_pArgs, piniService, pszBuf);
  
                if (pszTmp)
                {
                    //
                    // Apply domain to username as necessary. Note that we only want to do this on modem calls,
                    // not tunnels.
                    //
                    LPTSTR pszUsername = NULL;

                    if (IsDialingTunnel(m_pArgs))
                    {
                        lstrcpynU(m_pArgs->pRasDialParams->szUserName, pszTmp, sizeof(m_pArgs->pRasDialParams->szUserName)/sizeof(TCHAR));
                    }
                    else
                    {
                        pszUsername = ApplyDomainPrependToBufferAlloc(m_pArgs, piniService, pszTmp, (m_pArgs->aDialInfo[m_pArgs->nDialIdx].szDUN));
   
                        if (pszUsername)
                        {
                            lstrcpynU(m_pArgs->pRasDialParams->szUserName, pszUsername, sizeof(m_pArgs->pRasDialParams->szUserName)/sizeof(TCHAR));
                        }                        
                    }
        
                    CmFree(pszUsername);
                    CmFree(pszTmp);
                }

                if (bNeedToFree)
                {
                    delete piniService;
                }
            }       
        }
 
        CmFree(pszBuf);
    }
  
    if (NULL == hwndUsername)
    {
        //
        // The username field is hidden, but we still need to save it
        // in order for us to pre-populate later.
        //
        if (CM_LOGON_TYPE_ICS != m_pArgs->dwWinLogonType)
        {
            SaveUserInfo(m_pArgs, UD_ID_USERNAME, (PVOID)m_pArgs->szUserName);
        }
    }


    m_pArgs->fIgnoreChangeNotification = FALSE;
    
    if (fSwitchToUserCredentials)
    {
        //
        // Now that we saved the user name to the local/user cred store
        // we need to switch the credential type back to global in order
        // to maintain the correct state.
        //
        m_pArgs->dwCurrentCredentialType = CM_CREDS_GLOBAL;
    }

    //
    // Resets the state of the checkboxes
    //
    if (hwndMainDlgSavePW)
    {
        EnableWindow(hwndMainDlgSavePW, fMainDlgSavePWEnabled);
    }

    if (hwndMainDlgDialAutomatically)
    {
        EnableWindow(hwndMainDlgDialAutomatically, fMainDlgDialAutoEnabled);
    }

    //
    // Need to refresh to see which creds exist
    //
    BOOL fReturn = RefreshCredentialTypes(m_pArgs, FALSE);

    //
    // Cleanup state and go.
    //

    m_pArgs->hWndRetryAuthentication = NULL;

    EndDialog(m_hWnd, TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnCancel
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CRetryAuthenticationDlg::OnCancel()
{
    m_pArgs->hWndRetryAuthentication = NULL;
    EndDialog(m_hWnd, FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
DWORD CRetryAuthenticationDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{   
    switch (LOWORD(wParam)) 
    {
        case IDC_RETRY_PASSWORD:
        {  
            if (HIWORD(wParam) == EN_CHANGE) 
            {
                //
                // There has been a change to the password edit control, see
                // if there is any text and set the check-box accordingly.
                // 
                HWND hwndSavePassword = GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER);

                MYDBGASSERT(hwndSavePassword);
   
                if (hwndSavePassword)
                {
                    if (0 == SendDlgItemMessageU(m_hWnd, IDC_RETRY_PASSWORD, WM_GETTEXTLENGTH, 0, 0))
                    {
                        //
                        // No text. If the control is checked, then uncheck it. 
                        // Also, disable it.
                        //
                    
                        if (IsDlgButtonChecked(m_hWnd, IDC_RETRY_REMEMBER))
                        {
                            SendMessageU(hwndSavePassword, BM_SETCHECK, BST_UNCHECKED, 0);
                        }

                        EnableWindow(hwndSavePassword, FALSE);
                    }
                    else
                    {
                        // 
                        // There is data, if disabled, then enable appropriately
                        //

                        if (FALSE == IsWindowEnabled(GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER)))
                        {
                            EnableWindow(hwndSavePassword, TRUE);
                        }
                    }
                }
            
                break;
            }
        }          
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::GetDlgTemplate
//
// Synopsis:  Encapsulates determining which template is to be used
//            for the Retry dialog. Same model a MainDlg, but the 
//            determinants are slightly different as the dialog proc
//            and templates serve double-duty for Inet and VPN.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   UINT - Dlg template ID.
//
// History:   nickball    Created     03/04/00
//
//+----------------------------------------------------------------------------
UINT CRetryAuthenticationDlg::GetDlgTemplate()
{
    MYDBGASSERT(m_pArgs);
    
    //
    // First set the mask according to the .CMS flags for each value.
    //

    UINT uiMainDlgID = 0;
    DWORD dwTemplateMask = 0;

    //
    // If Inet and not UseSameUserName, then honor Inet flags for Username
    //

    if (m_fInetCredentials)
    {
        if (!m_pArgs->fHideInetUsername) 
        {
            dwTemplateMask |= CMTM_UID;
        }
    }
    else
    {
        //
        // Otherwise, the main Username display rules apply.
        //

        if (!m_pArgs->fHideUserName) 
        {
            dwTemplateMask |= CMTM_UID;
        }   
    }

    //
    // If Inet and not UseSameUserName, then honor Inet flags for password
    //

    if (m_fInetCredentials)
    {
        if (!m_pArgs->fHideInetPassword)
        {
            dwTemplateMask |= CMTM_PWD;
        }
    }
    else
    {
        //
        // Otherwise, the main password display rules apply.
        //

        if (!m_pArgs->fHidePassword)
        {
            dwTemplateMask |= CMTM_PWD;
        }   
    }

    //
    // Previously, the OS was the determinant for domain display. 
    // Nowadays, we want to display a domain when:
    //
    //  a) Its not a straight Inet dial 
    //
    //      AND
    //
    //  b) The domain field is not explicitly hidden
    //



    if (!m_fInetCredentials && !m_pArgs->fHideDomain)  
    {
        dwTemplateMask |= CMTM_DMN;
    }

    switch (dwTemplateMask)
    {
        case CMTM_U_P_D:
            uiMainDlgID = IDD_RETRY_UID_PWD_DMN;
            break;

        case CMTM_UID:
            uiMainDlgID = IDD_RETRY_UID_ONLY;
            break;

        case CMTM_PWD:
            uiMainDlgID = IDD_RETRY_PWD_ONLY;
            break;

        case CMTM_DMN:
            uiMainDlgID = IDD_RETRY_DMN_ONLY;
            break;

        case CMTM_UID_AND_PWD:
            uiMainDlgID = IDD_RETRY_UID_AND_PWD;
            break;

        case CMTM_UID_AND_DMN:
            uiMainDlgID = IDD_RETRY_UID_AND_DMN;
            break;

        case CMTM_PWD_AND_DMN:
            uiMainDlgID = IDD_RETRY_PWD_AND_DMN;
            break;
                                
        default:
             MYDBGASSERT(FALSE);
             uiMainDlgID = 0;
             break; 
    }       
    
    return uiMainDlgID;
}


//+----------------------------------------------------------------------------
//
// Func:    AccessPointInfoChanged
//
// Desc:    Checks all the controls to determine if any changes have been made
//
// Args:    NONE 
//
// Return:  BOOL - True if any information has changed
//
// Notes:   
//
// History: t-urama     07/31/2000  Created
//-----------------------------------------------------------------------------

BOOL CGeneralPage::AccessPointInfoChanged()
{
    if (m_bAPInfoChanged)
    {
        return TRUE;
    }

    if (0 != SendDlgItemMessageU(m_hWnd, IDC_GENERAL_PRIMARY_EDIT, EM_GETMODIFY, 0, 0))
    {
        return TRUE;
    }

    if (0 != SendDlgItemMessageU(m_hWnd, IDC_GENERAL_BACKUP_EDIT, EM_GETMODIFY, 0, 0))
    {
        return TRUE;
    }

    
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Func:    CGeneralPage::DeleteAccessPoint
//
// Desc:    Handler for the delete Access Point button
//
// Args:    NONE 
//
// Return:  NONE
//
// Notes:   
//
// History: t-urama     07/31/2000  Created
//-----------------------------------------------------------------------------

void CGeneralPage::DeleteAccessPoint()
{
   
    // Now try to delete the key for the access point from the registry

    LPTSTR pszRegPath = BuildUserInfoSubKey(m_pArgs->szServiceName, m_pArgs->fAllUser);
        
    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return;
    }

    CmStrCatAlloc(&pszRegPath, TEXT("\\"));
    CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);
    CmStrCatAlloc(&pszRegPath, TEXT("\\"));

    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return;
    }

    CmStrCatAlloc(&pszRegPath, m_pArgs->pszCurrentAccessPoint);
    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return;
    }

    if (pszRegPath)
    {
        DWORD dwRes;
        HKEY hKeyCm;

        dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszRegPath,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyCm);

        if (ERROR_SUCCESS == dwRes)
        {
            RegCloseKey(hKeyCm);
            dwRes = RegDeleteKeyU(HKEY_CURRENT_USER, pszRegPath);

            if (ERROR_SUCCESS != dwRes)
            {
                CMTRACE1(TEXT("Delete AP failed, GLE=%d"), GetLastError());
            }
            else
            {
                CMTRACE1(TEXT("Deleted Access Point - %s"), m_pArgs->pszCurrentAccessPoint);
            }

             // First delete the Accesspoint from the combo box and load the new settings

            DWORD dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_GETCURSEL, 0, 0);
            
            if (CB_ERR != dwIdx)
            {
                if (0 == dwIdx)
                {
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_SETCURSEL, dwIdx+1, 0);
                }
                else
                {
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_SETCURSEL, dwIdx-1, 0);
                }
    
                if (ChangedAccessPoint(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
                {
                    UpdateForNewAccessPoint(TRUE);
                }

                SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_DELETESTRING, dwIdx, 0);
            }
            
            //
            // If the number of APs becomes 1, then make the AccessPointsEnabled Flag FAlSE
            //

            DWORD dwCnt = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_GETCOUNT, 0, 0);
            if (dwCnt == 1) 
            {
               m_pArgs->fAccessPointsEnabled = FALSE;
               WriteUserInfoToReg(m_pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID) &m_pArgs->fAccessPointsEnabled);
               WriteUserInfoToReg(m_pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID) m_pArgs->pszCurrentAccessPoint);
            } 

        }

        CmFree(pszRegPath);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message to intialize
//            the dialog.
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   t-urama      created         08/02/00
//
//+----------------------------------------------------------------------------
BOOL CNewAccessPointDlg::OnInitDialog()
{   
   
    SetForegroundWindow(m_hWnd);

    //
    // Brand the dialog
    //

    LPTSTR pszTitle = CmStrCpyAlloc(m_pArgs->szServiceName);
    MYDBGASSERT(pszTitle);
    if (pszTitle)
    {
        SetWindowTextU(m_hWnd, pszTitle);
    }

    CmFree(pszTitle);
    if (m_pArgs->hSmallIcon)
    {
        SendMessageU(m_hWnd, WM_SETICON, ICON_SMALL, (LPARAM) m_pArgs->hSmallIcon); 
    }

    if (m_pArgs->hBigIcon)
    {        
        SendMessageU(m_hWnd, WM_SETICON, ICON_BIG, (LPARAM) m_pArgs->hBigIcon); 
        SendMessageU(GetDlgItem(m_hWnd, IDC_INET_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM) m_pArgs->hBigIcon); 
    }

    UpdateFont(m_hWnd);
    
    EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
    
    HWND hwndEdit = GetDlgItem(m_hWnd, IDC_NEWAP_NAME_EDIT);
    
    if (hwndEdit)
    {
        //
        // Subclass the edit control
        //
        m_pfnOrgEditWndProc = (WNDPROC)SetWindowLongU(hwndEdit, GWLP_WNDPROC, (LONG_PTR)SubClassEditProc);

        //
        //  Set focus to the edit control
        //
        SetFocus(hwndEdit);

        //
        //  Limit the text length of the control
        //
        SendMessageU(hwndEdit, EM_SETLIMITTEXT, MAX_ACCESSPOINT_LENGTH, 0);
    }

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
 
}

//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::SubClassEditProc
//
// Synopsis:  Subclassed edit proc so that back slash chars can be prevented from
//            being entered into the new access point name edit control.
//
// Arguments: standard win32 window proc params
//
// Returns:   standard win32 window proc return value
//
// History:   quintinb      created         08/22/00
//
//+----------------------------------------------------------------------------
LRESULT CALLBACK CNewAccessPointDlg::SubClassEditProc(HWND hwnd, UINT uMsg, 
                                                      WPARAM wParam, LPARAM lParam)
{
    //
    // If user types a back slash character, Beep and do not accept that character
    //

    if ((uMsg == WM_CHAR)  && (VK_BACK != wParam))
    {
        if (TEXT('\\') == (TCHAR)wParam)
        {
            Beep(2000, 100);
            return 0;
        }
    }

    // 
    // Call the original window procedure for default processing. 
    //
    return CallWindowProcU(m_pfnOrgEditWndProc, hwnd, uMsg, wParam, lParam); 
}

//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::OnOK
//
// Synopsis:  Virtual function. Call when user hits the OK button
//
// Arguments: None
//
// Returns:   None
//
// History:   t-urama      created         08/02/00
//
//+----------------------------------------------------------------------------
void CNewAccessPointDlg::OnOK()
{
    LPTSTR pszNewAPName = CmGetWindowTextAlloc(m_hWnd, IDC_NEWAP_NAME_EDIT);
    MYDBGASSERT(pszNewAPName);

    if (pszNewAPName && TEXT('\0') != pszNewAPName[0])
    {
        if (m_ppszAPName)
        {
            CmFree(*m_ppszAPName);
            *m_ppszAPName = pszNewAPName;
        } 
        EndDialog(m_hWnd, TRUE);
    }
    else
    {
        CmFree(pszNewAPName);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Enables the OK button once the user enters 
//            a name for the Access Point
//
// Arguments: None
//
// Returns:   None
//
// History:   t-urama      created         08/02/00
//
//+----------------------------------------------------------------------------
DWORD CNewAccessPointDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
        case IDC_NEWAP_NAME_EDIT:
        {
            HWND hwndEdit = GetDlgItem(m_hWnd, IDC_NEWAP_NAME_EDIT);
            HWND hwndOK = GetDlgItem(m_hWnd, IDOK);

            if (hwndEdit && hwndOK)
            {
                size_t nLen = GetWindowTextLengthU(hwndEdit);

                if (nLen > 0)
                {
                    EnableWindow(hwndOK, TRUE);
                }
                else
                {
                    EnableWindow(hwndOK, FALSE);
                }
            }
        }
        break;
   }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Func:    CGeneralPage::AddNewAPToReg
//
// Desc:    Adds an AP under the Access Points key in the registry and also to the 
//          combo box
//
// Args:    LPTSTR pszNewAPName - New access point name to add
//          BOOL fRefreshUiWwithCurrentValues - overwrite the values currently in UI dlg boxes
//
// Return:  Nothing
//
// Notes:   
//
// History: t-urama     07/31/2000  Created
//-----------------------------------------------------------------------------
void CGeneralPage::AddNewAPToReg(LPTSTR pszNewAPName, BOOL fRefreshUiWwithCurrentValues)
{
    MYDBGASSERT(pszNewAPName);

    if (!pszNewAPName)
    {
        return;
    }

    LPTSTR pszNewAPNameTmp = CmStrCpyAlloc(pszNewAPName);
    

    DWORD dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd,
                                   IDC_GENERAL_ACCESSPOINT_COMBO,
                                   CB_FINDSTRINGEXACT,
                                   0,
                                   (LPARAM)pszNewAPName);
    if (CB_ERR != dwIdx)
    {
        UINT iSuffix = 1;
        TCHAR szAPNameTemp[MAX_PATH + 10];  
        do
        {
            wsprintfU(szAPNameTemp, TEXT("%s%u"), pszNewAPNameTmp, iSuffix);
             
            dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd,
                                       IDC_GENERAL_ACCESSPOINT_COMBO,
                                       CB_FINDSTRINGEXACT,
                                       0,
                                       (LPARAM)szAPNameTemp);
            iSuffix++;
        } while(dwIdx != CB_ERR);

        CmFree(pszNewAPNameTmp);
        pszNewAPNameTmp = CmStrCpyAlloc(szAPNameTemp);
    }

    MYDBGASSERT(pszNewAPNameTmp);
    if (pszNewAPNameTmp)
    {
    
        LPTSTR pszRegPath = BuildUserInfoSubKey(m_pArgs->szServiceName, m_pArgs->fAllUser);
        
        MYDBGASSERT(pszRegPath);

        if (NULL == pszRegPath)
        {
            return;
        }

        CmStrCatAlloc(&pszRegPath, TEXT("\\"));
        CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);
        CmStrCatAlloc(&pszRegPath, TEXT("\\"));

        MYDBGASSERT(pszRegPath);

        if (NULL == pszRegPath)
        {
            return;
        }

        CmStrCatAlloc(&pszRegPath,pszNewAPNameTmp);
    
        MYDBGASSERT(pszRegPath);

        if (NULL == pszRegPath)
        {
            return;
        }

        if (pszRegPath)
        {
            DWORD dwRes;
            HKEY hKeyCm;
            DWORD dwDisposition;
        
        
            dwRes = RegCreateKeyExU(HKEY_CURRENT_USER,
                                    pszRegPath,
                                    0,
                                    TEXT(""),
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKeyCm,
                                    &dwDisposition);
            if (ERROR_SUCCESS == dwRes)
            {
            
               dwRes = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_ADDSTRING,
                                                0, (LPARAM)pszNewAPNameTmp);
               if (CB_ERR != dwRes)
               {
                   CMTRACE1(TEXT("Added new Access point - %s"), pszNewAPNameTmp);
                   SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_SETCURSEL, (WPARAM)dwRes, 0L);
                   if (ChangedAccessPoint(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
                   {
                       this->UpdateForNewAccessPoint(fRefreshUiWwithCurrentValues);
                   }

                   //
                   // if access points are enabled for the first time, make the AccessPointsEnabled flag TRUE
                   //

                   if (!m_pArgs->fAccessPointsEnabled)
                   {
                       m_pArgs->fAccessPointsEnabled = TRUE;
                       WriteUserInfoToReg(m_pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID) &m_pArgs->fAccessPointsEnabled);
                   }
               }
               RegCloseKey(hKeyCm);
            }
        }
        CmFree(pszRegPath);
    }
   
    CmFree(pszNewAPNameTmp);
    
}

//
// Help id pairs
//
const DWORD CVpnPage::m_dwHelp[] = {
        IDC_VPN_SEL_COMBO,            IDH_VPN_SELECTOR,
        0,0};


//+----------------------------------------------------------------------------
//
// Func:    CVpnPage::CVpnPage
//
// Desc:    Constructor for the CVpnPage class.
//
// Args:    ArgsStruct* pArgs - pointer to the Args structure
//          UINT nIDTemplate - template ID of the VPN page, passed to its parent
//
// Return:  Nothing
//
// Notes:   
//
// History: quintinb     11/01/2000  Created
//-----------------------------------------------------------------------------
CVpnPage::CVpnPage(ArgsStruct* pArgs, UINT nIDTemplate)
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+----------------------------------------------------------------------------
//
// Func:    CVpnPage::OnInitDialog
//
// Desc:    Handles the WM_INITDLG processing for the VPN page of the CM
//          property sheet.  Basically fills the VPN message text, fills the
//          VPN selector combo and selects an item in the list as necessary.
//
// Args:    None
//
// Return:  BOOL - TRUE if it initialized successfully.
//
// Notes:   
//
// History: quintinb     11/01/2000  Created
//-----------------------------------------------------------------------------
BOOL CVpnPage::OnInitDialog()
{
    if (m_pArgs->pszVpnFile)
    {
        //
        //  Add the VPN friendly names to the combo  
        //
        AddAllKeysInCurrentSectionToCombo(m_hWnd, IDC_VPN_SEL_COMBO, c_pszCmSectionVpnServers, m_pArgs->pszVpnFile);
        
        //
        //  Now we need to select a friendly name in the combo box if the user has already selected something or
        //  if the user has yet to select something but their Admin specified a default.
        //
        LPTSTR pszDefault = m_pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelDesc);

        if ((NULL == pszDefault) || (TEXT('\0') == pszDefault[0]))
        {
            CmFree(pszDefault);
            pszDefault = GetPrivateProfileStringWithAlloc(c_pszCmSectionSettings, c_pszCmEntryVpnDefault, TEXT(""), m_pArgs->pszVpnFile);
        }

        if (pszDefault && pszDefault[0])
        {
            LONG_PTR lPtr = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszDefault);
        
            if (CB_ERR != lPtr)
            {
                SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_SETCURSEL, (WPARAM)lPtr, (LPARAM)0);
            }
        }        

        CmFree(pszDefault);

        //
        //  If the Admin specified a message, let's read that and set the static text control
        //
        LPTSTR pszMessage = GetPrivateProfileStringWithAlloc(c_pszCmSectionSettings, c_pszCmEntryVpnMessage, TEXT(""), m_pArgs->pszVpnFile);

        if (pszMessage && pszMessage[0])
        {
            SendDlgItemMessageU(m_hWnd, IDC_VPN_MSG, WM_SETTEXT, (WPARAM)0, (LPARAM)pszMessage);
        }

        CmFree(pszMessage);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Func:    CVpnPage::OnApply
//
// Desc:    Called when the user hits the OK button for the CM property sheet.
//          Handles saving the VPN server address and DUN setting name.
//
// Args:    None
//
// Return:  Nothing
//
// Notes:   
//
// History: quintinb     11/01/2000  Created
//-----------------------------------------------------------------------------
void CVpnPage::OnApply()
{
    //
    //  Okay, let's figure out what the user selected in the combo
    //
    LONG_PTR lPtr = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

    if (CB_ERR != lPtr)
    {
        LONG_PTR lTextLen = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_GETLBTEXTLEN, (WPARAM)lPtr, (LPARAM)0);

        if (CB_ERR != lTextLen)
        {
            LPTSTR pszFriendlyName = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lTextLen+1));

            if (pszFriendlyName)
            {                
                lPtr = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_GETLBTEXT, (WPARAM)lPtr, (LPARAM)pszFriendlyName);

                if (CB_ERR != lPtr)
                {
                    //
                    //  Write the friendly name as the TunnelDesc
                    //
                    m_pArgs->piniBothNonFav->WPPS(c_pszCmSection, c_pszCmEntryTunnelDesc, pszFriendlyName);

                    //
                    //  Now get the actual data and write it
                    //
                    LPTSTR pszVpnAddress = GetPrivateProfileStringWithAlloc(c_pszCmSectionVpnServers, pszFriendlyName, TEXT(""), m_pArgs->pszVpnFile);

                    //
                    //  Now parse the line into the server name/IP and the DUN name if it exists.
                    //
                    if (pszVpnAddress)
                    {
                        LPTSTR pszVpnSetting = CmStrchr(pszVpnAddress, TEXT(','));

                        if (pszVpnSetting)
                        {
                            *pszVpnSetting = TEXT('\0');
                            pszVpnSetting++;
                            CmStrTrim(pszVpnSetting);
                        } // else it is NULL and we want to clear the existing key if it exists.

                        m_pArgs->piniBothNonFav->WPPS(c_pszCmSection, c_pszCmEntryTunnelDun, pszVpnSetting);

                        CmStrTrim(pszVpnAddress);
                        m_pArgs->piniBothNonFav->WPPS(c_pszCmSection, c_pszCmEntryTunnelAddress, pszVpnAddress);

                        //
                        //  Since we may have changed the Network settings from PPTP to L2TP (or vice versa) on downlevel
                        //  clients using the SafeNet client we will need to re-pick our tunnel device.
                        //
                        if (IsSafeNetClientAvailable())
                        {
                            MYVERIFY(PickTunnelDevice(m_pArgs, m_pArgs->szTunnelDeviceType, m_pArgs->szTunnelDeviceName));
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("CVpnPage::OnApply -- GetPrivateProfileStringWithAlloc failed for pszVpnAddress"));
                    }

                    CmFree(pszVpnAddress);
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("CVpnPage::OnApply -- CmMalloc failed for pszFriendlyName"));
            }

            CmFree(pszFriendlyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\himetric.cpp ===
//+----------------------------------------------------------------------------
//
// File:     himetric.cpp     
//
// Module:   Connection Manager
//
// Synopsis: Routines to convert Pixels to Himetric and vice versa
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created   02/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#pragma hdrstop


#define HIMETRIC_PER_INCH 2540L

SIZE g_sizePixelsPerInch;

//+------------------------------------------------------------------------
//
//  Function:   InitPixelsPerInch
//
//  Synopsis:   Initializing coordinate mapping for screen pixels
//
//  Returns:    HRESULT; S_OK on success, E_OUTOFMEMORY otherwise
//
//-------------------------------------------------------------------------

void
InitPixelsPerInch(VOID)
{
    HDC     hdc;

    hdc = GetDC(NULL);
    if (!hdc)
        goto Error;

    g_sizePixelsPerInch.cx = GetDeviceCaps(hdc, LOGPIXELSX);
    g_sizePixelsPerInch.cy = GetDeviceCaps(hdc, LOGPIXELSY);

    ReleaseDC(NULL, hdc);

Cleanup:
    return;

Error:
    g_sizePixelsPerInch.cx = 96;
    g_sizePixelsPerInch.cy = 96;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Function:   HimetricFromHPix
//
//  Synopsis:   Converts horizontal pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromHPix(int iPix)
{
    if (!g_sizePixelsPerInch.cx)
        InitPixelsPerInch();

    return MulDiv(iPix, HIMETRIC_PER_INCH, g_sizePixelsPerInch.cx);
}

//+---------------------------------------------------------------
//
//  Function:   HimetricFromVPix
//
//  Synopsis:   Converts vertical pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromVPix(int iPix)
{
    if (!g_sizePixelsPerInch.cy)
        InitPixelsPerInch();

    return MulDiv(iPix, HIMETRIC_PER_INCH, g_sizePixelsPerInch.cy);
}

//+---------------------------------------------------------------
//
//  Function:   HPixFromHimetric
//
//  Synopsis:   Converts himetric units to horizontal pixel units.
//
//----------------------------------------------------------------

int
HPixFromHimetric(long lHi)
{
    if (!g_sizePixelsPerInch.cx)
        InitPixelsPerInch();

    return MulDiv(g_sizePixelsPerInch.cx, lHi, HIMETRIC_PER_INCH);
}

//+---------------------------------------------------------------
//
//  Function:   VPixFromHimetric
//
//  Synopsis:   Converts himetric units to vertical pixel units.
//
//----------------------------------------------------------------

int
VPixFromHimetric(long lHi)
{
    if (!g_sizePixelsPerInch.cy)
        InitPixelsPerInch();

    return MulDiv(g_sizePixelsPerInch.cy, lHi, HIMETRIC_PER_INCH);
}

//+---------------------------------------------------------------------------
//
//  Function:   PixelFromHMRect
//
//  Synopsis:   Converts a Himetric RECTL to a Pixel RECT
//
//----------------------------------------------------------------------------

void
PixelFromHMRect(RECT *prcDest, RECTL *prcSrc)
{
    prcDest->left = HPixFromHimetric(prcSrc->left);
    prcDest->top = VPixFromHimetric(prcSrc->top);
    prcDest->right = HPixFromHimetric(prcSrc->right);
    prcDest->bottom = VPixFromHimetric(prcSrc->bottom);
}

//+---------------------------------------------------------------------------
//
//  Function:   HMFromPixelRect
//
//  Synopsis:   Converts a Pixel RECT to a Himetric RECTL
//
//----------------------------------------------------------------------------

void
HMFromPixelRect(RECTL *prcDest, RECT *prcSrc)
{
    prcDest->left = HimetricFromHPix(prcSrc->left);
    prcDest->top = HimetricFromVPix(prcSrc->top);
    prcDest->right = HimetricFromHPix(prcSrc->right);
    prcDest->bottom = HimetricFromVPix(prcSrc->bottom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\dial_str.h ===
//+----------------------------------------------------------------------------
//
// File:     dial_str.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Header file for CMS and .CMP flags used among various cmdial modules
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created    10/15/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DIAL_STR
#define _CM_DIAL_STR

const TCHAR* const c_pszCmEntryMaxUserName    = TEXT("MaxUserName");
const TCHAR* const c_pszCmEntryMaxPassword    = TEXT("MaxPassword");
const TCHAR* const c_pszCmEntryMaxDomain      = TEXT("MaxDomain");
const TCHAR* const c_pszCmEntryMaxPhoneNumber = TEXT("MaxPhoneNumber");

const TCHAR* const c_pszCmEntryRedialCount    = TEXT("RedialCount");
const TCHAR* const c_pszCmEntryPwdOptional    = TEXT("PasswordOptional");
const TCHAR* const c_pszCmEntryDialDevice     = TEXT("Modem");

const TCHAR* const c_pszCmEntryCallbackNumber = TEXT("CallbackNumber");
 
#endif // _CM_DIAL_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\icm.h ===
//+----------------------------------------------------------------------------
//
// File:     icm.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Main header file for cmdial32.dll
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------
#ifndef _ICM_INC
#define _ICM_INC

#include <stddef.h>
#include <stdlib.h>
#include <limits.h>
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <stdio.h>
#include <errno.h>
#include <olectl.h>
#include <ctype.h>
#include <wininet.h>
#include <wchar.h>

// #undef WINVER
// #define WINVER        0x0401

#include <commctrl.h>
#include <ras.h>
#include <raserror.h>
#include <tapi.h>
#include <mbstring.h>
#include <wininet.h>
#include <rasdlg.h>
#include <olectl.h>
#include <ntsecapi.h>  // for LSA stuff
#include "wincrypt.h" // for SafeNet specific cert

#include "cmglobal.h"
#include "cm_def.h"
#include "reg_str.h"
#include "cmmgr32.h" // help IDs
#include "cm_phbk.h"
#include "cmdial.h"
#include "cmutil.h"
#include "cm_misc.h"
#include "cmlog.h"
#include "state.h"
#include "cmsecure.h"
#include "cmdebug.h"
#include "contable.h"
#include "ary.hxx"
#include "ctr.h"
#include "resource.h"
#include "cmfmtstr.h"
#include "base_str.h"
#include "mgr_str.h" 
#include "ShellDll.h"
#include "mutex.h"
#include "cmras.h"
#include "userinfo.h"
#include "lanawait.h"
#include "linkdll.h" // LinkToDll and BindLinkage
#include "uapi.h"
#include "bmpimage.h" // Common bitmap processing code
#include "pwutil.h"
#include "stp_str.h"
#include "dial_str.h"
#include "mon_str.h"
#include "tooltip.h"
#include "gppswithalloc.h"
#include "hnetcfg.h"
#include "netconp.h"

//************************************************************************
// define's
//************************************************************************

#define TIMER_RATE              1000        // 1 second
#define PAUSE_DELAY             3
#define PWHANDLE_NONE           0
#define PWHANDLE_LOWER          1
#define PWHANDLE_UPPER          2

#define CE_PASSWORD_NOT_PRESENT 1223

#define CUSTOM_BUTTON_WIDTH 88
//#define DEFAULT_MAX_DOMAIN_LENGTH   256

//
// User defined msg for telling CM itself to start loading startup info
//
#define WM_LOADSTARTUPINFO      (WM_USER + 6)

//
// Delayed hangup of CM for W9x
// wParam indicates if entry should be removed from table.
// lParam is the RAS error code for hangup or ERROR_CANCELLED (currently unused)

#define WM_HANGUP_CM            (WM_USER + 7)

//
// Connected CM - CM is connected, do connect processing
//

#define WM_CONNECTED_CM         (WM_USER + 8)

//
// Pause RasDial - Resume dialing after pause state.
//

#define WM_PAUSE_RASDIAL         (WM_USER + 9)

// Duration message flags

#define DMF_NUL 0x0000
#define DMF_H   0x0001  // Hours
#define DMF_M   0x0002  // Minutes
#define DMF_S   0x0004  // Seconds
#define DMF_HM  0x0003  // Hours, Minutes
#define DMF_HS  0x0005  // Hours, Seconds
#define DMF_MS  0x0006  // Minutes, Seconds
#define DMF_HMS 0x0007  // Hours, Minutes, Seconds

// for NT RasSetEntryProperties() 
#define SCRIPT_PATCH_BUFFER_SIZE    2048
#define SIZEOF_NULL 1

#define MIN_TAPI_VERSION        0x10003
#define MAX_TAPI_VERSION        0x10004

#define NElems(a)  (sizeof a / sizeof a[0])

#define INETCFG_INSTALLMODEM        0x00000002
#define INETCFG_INSTALLRNA          0x00000004
#define INETCFG_INSTALLTCP          0x00000008
#define INETCFG_SUPPRESSINSTALLUI   0x00000080
//
// Check to see if TCP is installed regardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000

//
// Components Checked flags
//
#define CC_RNA                      0x00000001  // RNA installed
#define CC_TCPIP                    0x00000002  // TCPIP installed
#define CC_MODEM                    0x00000004  // Modem installed
#define CC_PPTP                     0x00000008  // PPTP installed
#define CC_SCRIPTING                0x00000010  // Scripting installed
#define CC_RASRUNNING               0X00000020  // RAS services is running
                                                //  on NT
#define CC_CHECK_BINDINGS           0x00000040  // Check if PPP is bound to TCP



#define DT_CMMON                    0x00000001
#define DT_EXPLORER                 0x00000002
#define DT_CMMGR                    0x00000004
#define DT_CMSTP                    0x00000008
#define DT_RUNDLL32                 0x00000010
#define DT_RASAUTOU                 0x00000020
#define DT_USER                     (DT_CMMGR | DT_CMMON | DT_EXPLORER | DT_CMSTP | DT_RUNDLL32 | DT_RASAUTOU)

#define MAX_PHONE_NUMBERS       2

#define MAX_PHONE_LEN95         36 //Win 95 has 36 char phone limit
#define MAX_PHONE_LENNT         80 //NT has 80 char phone limit

//
// Country list limits and defines
//

#define DEF_COUNTRY_INFO_SIZE   1024
#define MAX_COUNTRY_NAME        36

#define DEFAULT_COUNTRY_CODE    1
#define DEFAULT_COUNTRY_ID      1 // US
//
// Default settings values
//

#define DEFAULT_IDLETIMEOUT    10    // # of minutes to wait before idle disconnect

#define DEFAULT_DIALEXTRAPERCENT        80   // see ArgsStruct dwDialExtraPercent
#define DEFAULT_DIALEXTRASAMPLESECONDS  30   // see ArgsStruct dwDialExtraSampleSeconds
#define DEFAULT_HANGUPEXTRAPERCENT        40   // see ArgsStruct dwHangupExtraPercent
#define DEFAULT_HANGUPEXTRASAMPLESECONDS  300   // see ArgsStruct dwHangupExtraSampleSeconds


#define DEFAULT_REDIAL_DELAY    5
#define DEFAULT_REDIALS         3
#define MAX_REDIAL_CHARS        2
#define MAX_NUMBER_OF_REDIALS   99


#define NT4_BUILD_NUMBER        1381

//
// isdn dial mode
//
#define CM_ISDN_MODE_SINGLECHANNEL          0
#define CM_ISDN_MODE_DUALCHANNEL_ONLY       1
#define CM_ISDN_MODE_DUALCHANNEL_FALLBACK   2

//
// len for the var lasterror string
//
#define MAX_LASTERR_LEN             128

//
// Flags for manipulating dialog template mask
//
#define CMTM_UID            0x00000001  // Username to be displayed
#define CMTM_PWD            0x00000002  // Password to be displayed
#define CMTM_DMN            0x00000004  // Domain to be displayed
#define CMTM_FAVS           0x00000008  // Favorite enbabled dialogs
#define CMTM_GCOPT          0x00000010  // Global Credential Options


#define CMTM_UID_AND_PWD    CMTM_UID | CMTM_PWD             // 0x00000003 // No domain displayed   
#define CMTM_UID_AND_DMN    CMTM_UID | CMTM_DMN             // 0x00000005 // No Password displayed 
#define CMTM_PWD_AND_DMN    CMTM_PWD | CMTM_DMN             // 0x00000006 // No Username displayed 
#define CMTM_U_P_D          CMTM_UID | CMTM_PWD | CMTM_DMN  // 0x00000007 // All userinfo displayed  

//
// Access point names should be no longer than 32 chars (not counting the NULL terminator)
//
#define MAX_ACCESSPOINT_LENGTH 32
#define ID_OK_RELAUNCH_MAIN_DLG 123174

//
// Balloon Tip Flags
//
#define BT_ACCESS_POINTS    0x00000001 // Access Point balloon tip has already been displayed

//
//  Connection Types
//
#define DIAL_UP_CONNECTION 0
#define DIRECT_CONNECTION 1
#define DOUBLE_DIAL_CONNECTION 2

class CConnStatistics;

//
//  Special-case some smart-card PIN errors
//
#define BAD_SCARD_PIN(x) ((SCARD_W_WRONG_CHV == (x)) || (SCARD_E_INVALID_CHV == (x)))


//************************************************************************
// structures, typdef's
//************************************************************************

//
// Function prototypes for entrypoints into RAS.  We will link to RAS using LoadLibary()/GetProcAddress(),
// so that we can be flexible concerning how we load (for example, if RAS is not installed on the machine,
// we can print a polite message, instead of just having Windows put up an ugly dialog about RASAPI32.DLL
// not being found.
//

#include "raslink.h"

//
// Function prototypes for entrypoints into TAPI.  We will link to TAPI using LoadLibary()/GetProcAddress(),
// so that we can be flexible concerning how we load (for example, if TAPI is not installed on the machine,
// we can print a polite message, instead of just having Windows put up an ugly dialog about TAPI32.DLL
// not being found.
//

typedef LONG (WINAPI *pfnTapilineInitialize)(LPHLINEAPP, HINSTANCE, LINECALLBACK, LPCTSTR, LPDWORD);
typedef LONG (WINAPI *pfnTapilineNegotiateAPIVersion)(HLINEAPP, DWORD, DWORD, DWORD, LPDWORD, LPLINEEXTENSIONID);
typedef LONG (WINAPI *pfnTapilineGetDevCaps)(HLINEAPP, DWORD, DWORD, DWORD, LPLINEDEVCAPS);
typedef LONG (WINAPI *pfnTapilineShutdown)(HLINEAPP);
typedef LONG (WINAPI *pfnTapilineTranslateAddress)(HLINEAPP, DWORD, DWORD, LPCTSTR, DWORD, DWORD, LPLINETRANSLATEOUTPUT);
typedef LONG (WINAPI *pfnTapilineTranslateDialog)(HLINEAPP, DWORD, DWORD, HWND, LPCTSTR);
typedef LONG (WINAPI *pfnTapilineGetDevConfig)(DWORD, LPVARSTRING, LPCSTR);

//typedef LONG (WINAPI *pfnTapilineGetID)(HLINE, DWORD, HCALL, DWORD, LPVARSTRING, LPCTSTR);
//typedef LONG (WINAPI *pfnTapitapiGetLocationInfo)(LPCTSTR, LPCTSTR);

typedef LONG (WINAPI *pfnTapilineGetTranslateCaps)(HLINEAPP, DWORD, LPLINETRANSLATECAPS);
typedef LONG (WINAPI *pfnTapilineSetCurrentLocation)(HLINEAPP, DWORD);

//
// function prototypes for LSA stuff.
//
typedef NTSTATUS (NTAPI *pfnLsaOpenPolicy)(PLSA_UNICODE_STRING, PLSA_OBJECT_ATTRIBUTES, ACCESS_MASK, PLSA_HANDLE);
typedef NTSTATUS (NTAPI *pfnLsaRetrievePrivateData)(LSA_HANDLE, PLSA_UNICODE_STRING, PLSA_UNICODE_STRING *);
typedef NTSTATUS (NTAPI *pfnLsaStorePrivateData)(LSA_HANDLE, PLSA_UNICODE_STRING, PLSA_UNICODE_STRING);
typedef ULONG    (NTAPI *pfnLsaNtStatusToWinError)(NTSTATUS);
typedef NTSTATUS (NTAPI *pfnLsaClose)(LSA_HANDLE);
typedef NTSTATUS (NTAPI *pfnLsaFreeMemory)(PVOID);

//
//  Connect Action Function Prototype
//
typedef DWORD (WINAPI *pfnCmConnectActionFunc)(HWND, HINSTANCE, LPCSTR, int);

//
// Structure used to describe the linkage to TAPI.  NOTE:  Changes to this structure
// will probably require changes to LinkToTapi() and UnlinkFromTapi().
//
typedef struct _TapiLinkageStruct {
    HINSTANCE hInstTapi;
    union {
        struct {
            pfnTapilineInitialize pfnlineInitialize;
            pfnTapilineNegotiateAPIVersion pfnlineNegotiateAPIVersion;
            pfnTapilineGetDevCaps pfnlineGetDevCaps;
            pfnTapilineGetDevConfig pfnlineGetDevConfig;
            pfnTapilineShutdown pfnlineShutdown;
            pfnTapilineTranslateAddress pfnlineTranslateAddress;
//          pfnTapitapiGetLocationInfo pfntapiGetLocationInfo;
            pfnTapilineTranslateDialog pfnlineTranslateDialog;
//          pfnTapilineGetID pfnlineGetID;
            pfnTapilineGetTranslateCaps pfnlineGetTranslateCaps;
            pfnTapilineSetCurrentLocation pfnlineSetCurrentLocation;
        };
        void *apvPfnTapi[10];   // see comment for RasLinkageStruct for 10.
    };
    HLINEAPP hlaLine;
    DWORD dwDevCnt;
    BOOL bOpen;
    BOOL bDevicePicked;
    TCHAR szDeviceName[RAS_MaxDeviceName + 1];
    DWORD dwDeviceId;
    DWORD dwApiVersion;
    BOOL bModemSpeakerOff;
    DWORD dwTapiLocationForAccessPoint;   // Tapi location for current access point
    DWORD dwOldTapiLocation;        // Tapi location when CM is started, restored when CM exits
} TapiLinkageStruct;

typedef struct _LsaLinkageStruct {
    HINSTANCE hInstLsa;
    union {
        struct {
            pfnLsaOpenPolicy            pfnOpenPolicy;
            pfnLsaRetrievePrivateData   pfnRetrievePrivateData;
            pfnLsaStorePrivateData      pfnStorePrivateData;
            pfnLsaNtStatusToWinError    pfnNtStatusToWinError;
            pfnLsaClose                 pfnClose;
            pfnLsaFreeMemory            pfnFreeMemory;
        };
        void *apvPfnLsa[7];  
    };
} LsaLinkageStruct;

#define PHONE_DESC_LEN  80
#define PB_MAX_SERVICE  256
#define PB_MAX_REGION   256

//
// Phone Info Flags
//

#define PIF_USE_DIALING_RULES       0x00000001

typedef struct _PHONEINFO
{
    DWORD dwCountryID;
    TCHAR szPhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR szCanonical[RAS_MaxPhoneNumber+1];
    TCHAR szDUN[MAX_PATH+1];
    TCHAR szPhoneBookFile[MAX_PATH+1];      // the service file associate with the phone #
    TCHAR szDialablePhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR szDisplayablePhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR szDesc[PHONE_DESC_LEN];
    DWORD dwPhoneInfoFlags;

    //
    // The following 2 vars are set by the phone book dlg(OnGeneralPhoneChange).
    // We need to save them and then write them out when the user clicks OK.
    //
    TCHAR       szServiceType[PB_MAX_SERVICE];
    TCHAR       szRegionName[PB_MAX_REGION];

} PHONEINFO, *PPHONEINFO;

//
// Structure for all of the program's data.  Basically, the program doesn't have any
// global variables - everything is stored in this structure.
//
typedef struct _ArgsStruct 
{
public:
    LPICMOCCtr   pCtr;                          // OC ctr for FS OC
    UINT uMsgId;                                // message ID used for driving the dialing state machine
    DWORD dwFlags;                              // any flags from the command line  -- see IniArgs
    RasLinkageStruct rlsRasLink;                // linkade to RAS
    HRASCONN hrcRasConn;                        // the handle of the RAS connection
    TapiLinkageStruct tlsTapiLink;              // linkage to TAPI
    LsaLinkageStruct llsLsaLink;                // linkage to LSA
    BOOL fIgnoreChangeNotification;             // TRUE if EN_CHANGE messages should be ignored
    TCHAR szLastErrorSrc[MAX_LASTERR_LEN];      // the source of last err(either RAS or a connect action name)
    TCHAR szDeviceName[RAS_MaxDeviceName+1];    // device being used
    TCHAR szDeviceType[RAS_MaxDeviceName+1];    // device type of the device being used
    TCHAR szUserName[UNLEN+1];                  // username for corp account
    CSecurePassword SecurePW;                   // encrypted password for corp account 
    TCHAR szDomain[DNLEN+1];                    // domain for corp account
    TCHAR szConnectoid[RAS_MaxEntryName];       // connectoid name
    TCHAR szServiceName[RAS_MaxEntryName];      // top-level long service name
    // added for tunneling
    HRASCONN hrcTunnelConn;                 // the handle of the tunnel connection
    TCHAR szTunnelDeviceType[RAS_MaxDeviceType+1]; // device type
    TCHAR szTunnelDeviceName[RAS_MaxDeviceName+1]; // device being used for tunneling
    TCHAR szInetUserName[UNLEN+1];              // username for internet(isp)
    CSecurePassword SecureInetPW;               // encrypted internet(isp) password
    BOOL  fUseSameUserName;                     // TRUE if will use the same password for dialup
    BOOL  fHideDialAutomatically;               // don't show 'dial automatically..." checkbox
    BOOL  fHideRememberPassword;                // don't show 'remember password" checkbox
    BOOL  fHideRememberInetPassword;            // don't show 'remember Internet password" checkbox
    BOOL  fDialAutomatically;                   // dial automatically upon start?
    BOOL  fRememberInetPassword;                // remember the internet password
    BOOL  fRememberMainPassword;                // remember the password in the main dialog box
    BOOL  fHideUserName;                        // Hide the username on the main logon tab
    BOOL  fHidePassword;                        // Hide the password on the main logon tab
    BOOL  fHideDomain;                          // Hide the domain on the main logon tab
    BOOL  fHideInetUsername;                    // Hide the username on the Inet logon tab
    BOOL  fHideInetPassword;                    // Hide the password on the Inet logon tab
    BOOL  fTunnelPrimary;                       // if TRUE, we'll tunnel only if the user selects a phone #
                                                //     from the pbk associated with the primary service profile
    BOOL  fTunnelReferences;                    // if TRUE, we'll tunnel only if the user selects a phone #     
                                                //     from the pbk associated with the referenced service profile 
    BOOL  fUseTunneling;                        // TRUE if use tunneling for dial-up networking(it is NOT the same 
                                                //     as (fTunnel|fTunnelReferences)!!!  It's determined by 
                                                //     looking at the above 3 flags plus more.
    BOOL bSafeNetClientAvailable;               // TRUE if the downlevel SafeNet L2TP/IPSec client is available
    BOOL bUseRasCredStore;                      // TRUE if this profile uses RasSetCredentials and RasGetCredentials
                                                // to store creds on win2k+.  Will be FALSE on legacy platforms
    BOOL bShowHNetCfgAdvancedTab;               // displays the ICF & ICS (Advanced) tab
                                                //      Internet Connection Sharing & Internet Connection Firewall tab
                                                //      TRUE by default
    DWORD dwSCardErr;                           // special case handling for SmartCard errors

    LPTSTR GetProperty(const TCHAR* pszName, BOOL *pbValidPropertyName);   // get the cm property by name
    DWORD GetTypeOfConnection();                // is the connection dialup, direct, or double dial?
protected:
    //
    // Encapsulate the tunnel address
    //

    // IP(or DNS name) in the profile for tunnel server
    TCHAR szPrimaryTunnelIP[RAS_MaxPhoneNumber+1];

public:

    const TCHAR* GetTunnelAddress()
        {return szPrimaryTunnelIP;}

    void SetPrimaryTunnel(LPCTSTR pszTunnelIP)
        {lstrcpynU(szPrimaryTunnelIP, pszTunnelIP, sizeof(szPrimaryTunnelIP)/sizeof(TCHAR));}       

public:
    UINT_PTR nTimerId;                          // ID of the timer
    ProgState psState;                                                      // the program's state
    DWORD dwStateStartTime;                     // the time that the state started
    UINT nRedialDelay;                          // the number of seconds to wait between redial attempts
    UINT nMaxRedials;                           // the maximum number of times to redial
    UINT nRedialCnt;                            // number of re-dial attempts remaining
    UINT nLastSecondsDisplay;                   // the last seconds count which was displayed
    UINT nDialIdx;                              // zero-based index of current phone number
    PHONEINFO aDialInfo[MAX_PHONE_NUMBERS]; // actual phone number that's to be dialed
    CIni *piniProfile;
    CIni *piniService;
    CIni *piniBoth;
    CIni *piniBothNonFav;
    LPTSTR pszHelpFile;                         // file name of help file
    BMPDATA BmpData;                            // bitmap handles for main sign-in dialog
    HPALETTE hMasterPalette;                    // the current palette for the app
    HICON hBigIcon;                             // icon for Alt-Tab task bar
    HICON hSmallIcon;                           // icon for main title bar and task bar
    DWORD dwExitCode;
    DWORD dwIdleTimeout;                        // Idle time out in minutes, 0 means never time out
    HWND hwndResetPasswdButton;
    HWND hwndTT;                // tooltip
    HANDLE  *phWatchProcesses;
    LPTSTR  pszResetPasswdExe;
    LPTSTR pszCurrentAccessPoint;               // String to store the current access point
    BOOL fAccessPointsEnabled;                  // Are Access Points enabled?
    BOOL fHideBalloonTips;                   // Are Balloon Tips enabled?
    CBalloonTip *pBalloonTip;                   // pointer to the Balloon tip class

    // for references
    BOOL    fHasRefs;
    BOOL    fHasValidTopLevelPBK;
    BOOL    fHasValidReferencedPBKs;

    //
    // for IdleThreshold  -- byao 5/30/97
    //

    CConnStatistics  *pConnStatistics;
    CConnectionTable *pConnTable;

    // idle threshold value
        
    BOOL    fCheckOSComponents;         // should we check OS components?
    BOOL    bDoNotCheckBindings;        // Check if TCP is bound to PPP?
    Ole32LinkageStruct olsOle32Link;    // links to Ole32 DLL for future splashing
    BOOL    fFastEncryption;            // Whether we want a faster encryption or a more secure one
    DWORD   bDialInfoLoaded;            // Whether the dial info is loaded
    BOOL    fStartupInfoLoaded;         // have we loaded Startup info? (OnMainLoadStartupInfo())
    BOOL    fNeedConfigureTapi;         // need to configure TAPI location info
    BOOL    fIgnoreTimerRasMsg;         // Whether to ignore WM_TIMER and RAS messages
    BOOL    fInFastUserSwitch;          // Are we in the process of doing a fast user switch (FUS)
    CShellDll m_ShellDll;                // The link to Shell dll

public:
    BOOL   IsDirectConnect() const;
    void   SetDirectConnect(BOOL fDirect) ; // set the connection type direct or dial-up
    BOOL   IsBothConnTypeSupported() const;
    void   SetBothConnTypeSupported(BOOL fBoth);

protected:
    BOOL    m_fBothConnTypeSupported;     // Whether the profile support both direct connect an dial-up
    BOOL    m_fDirectConnect;             // Whether the current configuration is using direct connection
public:
    LPTSTR  pszRasPbk;                  // Ras phonebook path
    LPTSTR  pszRasHiddenPbk;            // Hidden Ras phonebook path for dial-up portion of wholesale dial
    LPTSTR  pszVpnFile;
    //
    // ISDN dual channel support(dial all initially, dial on demand)
    //
    // Dial-on-demand:
    // CM dials an additional channel when the total bandwidth used exceeds 
    // dwDialExtraPercent percent of the available bandwidth for at least 
    // dwDialExtraSampleSeconds seconds. 
    //
    BOOL    dwIsdnDialMode;             // see CM_ISDN_MODE*
    DWORD   dwDialExtraPercent;         // used when dialmode = dialasneeded
    DWORD   dwDialExtraSampleSeconds;   // used when dialmode = dialasneeded
    DWORD   dwHangUpExtraPercent;       // used when dialmode = dialasneeded
    DWORD   dwHangUpExtraSampleSeconds; // used when dialmode = dialasneeded
    BOOL    fInitSecureCalled;          // whether InitSecure() is called for password Encryption

    //
    // pucDnsTunnelIpAddr_list:
    //      the h_addr_list of a HOSTENT - a list of ip addrs obtained by resolving the
    //      tunnel server DNS name.
    // uiCurrentTunnelAddr
    //      the index for h_TunnelIpAddr_list.  Points to the currently used ip addr address.
    // rgwRandomDnsIndex
    //      an array of random index to index into the tunnel addr list
    //
    unsigned char   *pucDnsTunnelIpAddr_list;
    UINT    uiCurrentDnsTunnelAddr;
    DWORD   dwDnsTunnelAddrCount;
    PWORD   rgwRandomDnsIndex;
    BOOL    fAllUser;
    UINT    uLanaMsgId; // Window handle of Lana window if any    
    LPRASDIALPARAMS pRasDialParams;
    LPRASDIALEXTENSIONS pRasDialExtensions;
    DWORD dwRasSubEntry;
    HWND hwndMainDlg;
    BOOL fNoDialingRules;
    LPRASNOUSER lpRasNoUser;        
    PEAPLOGONINFO lpEapLogonInfo;  
    //
    // Note: RAS will pass either a LPRASNOUSER or LPEAPLOGONINFO ptr through the 
    // RasCustomDialDlg interface when calling CM from WinLogon. RAS will 
    // differentiate them by the RCD_Eap flag, which will be set if the 
    // LPEAPLOGONINFO is passed. When not running in WinLogon, neither 
    // will be sent. 
    //
    BOOL  fChangedPassword;                     // User changed password during logon
    BOOL  fChangedInetPassword;                 // User changed Inet password during logon
    HWND  hWndChangePassword;                   // Hwnd of change passwor dialog
    BOOL  fWaitingForCallback;                  // We're waiting for RAS to call us back
    HWND  hWndCallbackNumber;                   // Hwnd of callback number dialog
    HWND  hWndRetryAuthentication;              // Hwnd of Retry Authentication dialog
    //
    // Support for global credentials
    //
    BOOL fGlobalCredentialsSupported;           // enables/disables support for global creds
    DWORD dwCurrentCredentialType;              // Which credentials are currently selected
    DWORD dwExistingCredentials;                // uses bit flags to mark if credentials exist
    DWORD dwDeleteCredentials;                  // uses bit flag to mark creds for deletion
    DWORD dwWinLogonType;                       //  0 - User logged on
                                                //  1 - Winlogon: dial-up
                                                //  2 - Winlogon: ICS (no one is logged on)
    DWORD dwGlobalUserInfo;                     // uses bit flags to load/save global user info

    LONG lInConnectOrCancel;                    // to protect against Cancel during Connect processing, and vice-versa

    CmLogFile Log;
} ArgsStruct;

//
// Global Credential Support
//

// Used to identify the current RAS credential store being used. 
// Used with ArgsStruct.dwCurrentCredentialType
#define CM_CREDS_USER   1
#define CM_CREDS_GLOBAL 2

// Identifies which type of credentials want to be use used
#define CM_CREDS_TYPE_MAIN      0
#define CM_CREDS_TYPE_INET      1
#define CM_CREDS_TYPE_BOTH      2

// Used to identify who is logged on. 
// Used with ArgsStruct.dwWinLogonType
#define CM_LOGON_TYPE_USER      0     // User is logged on
#define CM_LOGON_TYPE_WINLOGON  1     // Dial-up, winlogon, reconnect user initiated logon
#define CM_LOGON_TYPE_ICS       2     // No user is logged on, but need to dial unattended (ICS)

// Used with ArgsStruct.dwGlobalUserInfo
#define CM_GLOBAL_USER_INFO_READ_ICS_DATA       0x0001  // used to load user settings for ICS
#define CM_GLOBAL_USER_INFO_WRITE_ICS_DATA      0x0002  // used to save user settings for ICS


// Used with ArgsStruct.dwExistingCredentials
#define CM_EXIST_CREDS_MAIN_GLOBAL                  0x0001  // set if RAS credential store has main global creds
#define CM_EXIST_CREDS_MAIN_USER                    0x0002  // set if RAS credential store has main user creds
#define CM_EXIST_CREDS_INET_GLOBAL                  0x0004  // set if RAS credential store has Internet global creds
#define CM_EXIST_CREDS_INET_USER                    0x0008  // set if RAS credential store has Internet user creds

// Used with ArgsStruct.dwDeleteCredentials
#define CM_DELETE_CREDS_MAIN_GLOBAL                 0x0001  // set to delete main global creds
#define CM_DELETE_CREDS_MAIN_USER                   0x0002  // set to delete main user creds
#define CM_DELETE_CREDS_INET_GLOBAL                 0x0004  // set to delete Internet global creds
#define CM_DELETE_CREDS_INET_USER                   0x0008  // set to delete Internet user creds


//
// RasNumEntry - phone number subset of RASENTRY
//

typedef struct tagRasNumEntry
{
  DWORD      dwSize;
  DWORD      dwfOptions;
  DWORD      dwCountryID;
  DWORD      dwCountryCode;
  TCHAR      szAreaCode[ RAS_MaxAreaCode + 1 ];
  TCHAR      szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
} RASNUMENTRY, *LPRASNUMENTRY;

//
// EditNumData struct used to pass data to/from EditNum dialog.
//

typedef struct tagEditNumData
{
    ArgsStruct *pArgs;
    RASNUMENTRY RasNumEntry;

} EDITNUMDATA, *LPEDITNUMDATA;


//************************************************************************
// string constants
//************************************************************************

//
// CMMON exe name, expected to be local
//
const TCHAR* const c_pszCmMonExeName = TEXT("CMMON32.EXE");

//************************************************************************
// function prototypes
//************************************************************************

// init.cpp

HRESULT InitProfileFromName(ArgsStruct *pArgs, 
                         LPCTSTR pszArg);

HRESULT InitProfile(ArgsStruct *pArgs, 
                    LPCTSTR pszEntry);

HRESULT InitArgsForDisconnect(ArgsStruct *pArgs, BOOL fAllUser);

HRESULT InitArgsForConnect(ArgsStruct *pArgs, 
                           LPCTSTR pszRasPhoneBook,
                           LPCMDIALINFO lpCmInfo,
                           BOOL fAllUser);

HRESULT InitCredentials(ArgsStruct *pArgs,
                        LPCMDIALINFO lpCmInfo, 
                        DWORD dwFlags,
                        PVOID pvLogonBlob);

HRESULT InitLogging(ArgsStruct *pArgs, 
                    LPCTSTR pszEntry,
                    BOOL fBanner);

LRESULT CreateIniObjects(ArgsStruct *pArgs);

void ReleaseIniObjects(ArgsStruct *pArgs);

DWORD RegisterBitmapClass(HINSTANCE hInst);

HRESULT WriteCmpInfoToReg(LPCTSTR pszSubKey, 
                          LPCTSTR pszEntryName, 
                          PVOID pEntryValue, 
                          DWORD dwType, 
                          DWORD dwSize);

LPTSTR GetEntryFromCmp(const TCHAR *pszSectionName, 
                      LPTSTR pszEntryName, 
                      LPCTSTR pszCmpPath);

void ReplaceCmpFile(LPCTSTR pszCmpPath);

LPTSTR FormRegPathFromAccessPoint(ArgsStruct *pArgs);

        


// disconn.cpp

DWORD Disconnect(CConnectionTable *pConnTable, 
    LPCM_CONNECTION pConnection,
    BOOL fIgnoreRefCount,
    BOOL fPersist);

DWORD HangupNotifyCmMon(CConnectionTable *pConnTable,
    LPCTSTR pszEntry);

BOOL InFastUserSwitch(DWORD *pdwSessions);

// connect.cpp

HRESULT Connect(HWND hwndParent,
                LPCTSTR lpszEntry,
                LPTSTR lpszPhonebook,
                LPRASDIALDLG lpRasDialDlg,
                LPRASENTRYDLG lpRasEntryDlg,
                LPCMDIALINFO lpCmInfo,
                DWORD dwFlags,
                LPVOID lpvLogonBlob);

#define NOT_IN_CONNECT_OR_CANCEL    0
#define IN_CONNECT_OR_CANCEL        1

void GetConnectType(ArgsStruct *pArgs);

void AddWatchProcessId(ArgsStruct *pArgs, DWORD dwProcessId);
void AddWatchProcess(ArgsStruct *pArgs, HANDLE hProcess);

DWORD DoRasHangup(RasLinkageStruct *prlsRasLink, 
    HRASCONN hRasConnection, 
    HWND hwndDlg = NULL, 
    BOOL fWaitForComplete = FALSE,
    LPBOOL pfWaiting = NULL);

DWORD MyRasHangup(ArgsStruct *pArgs, 
    HRASCONN hRasConnection, 
    HWND hwndDlg = NULL, 
    BOOL fWaitForComplete = FALSE);

DWORD HangupCM(
    ArgsStruct *pArgs, 
    HWND hwndDlg, 
    BOOL fWaitForComplete = FALSE,
    BOOL fUpdateTable = TRUE);

BOOL UseTunneling(
    ArgsStruct  *pArgs, 
    DWORD       dwEntry
);

void SetMainDlgUserInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
);

BOOL OnResetPassword(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
);

void AppendStatusPane(HWND hwndDlg, 
                  DWORD dwMsgId);

void AppendStatusPane(HWND hwndDlg, 
                  LPCTSTR pszMsg);

LPTSTR GetPhoneByIdx(ArgsStruct *pArgs, 
                     UINT nIdx, 
                     LPTSTR *ppszDesc, 
                     LPTSTR *ppszDUN, 
                     LPDWORD pdwCountryID,
                     LPTSTR *ppszRegionName,
                     LPTSTR *ppszServiceType,
                     LPTSTR *ppszPhoneBookFile,
                     LPTSTR *ppszCanonical,
                     DWORD  *pdwPhoneInfoFlags); 

void PutPhoneByIdx(ArgsStruct *pArgs, 
                   UINT nIdx, 
                   LPCTSTR pszPhone, 
                   LPCTSTR pszDesc, 
                   LPCTSTR pszDUN, 
                   DWORD dwCountryID, 
                   LPCTSTR pszRegionName,
                   LPCTSTR pszServiceType,
                   LPCTSTR pszPhoneBookFile, 
                   LPCTSTR ppszCanonical,
                   DWORD   dwPhoneInfoFlags);

DWORD LoadDialInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fInstallModem = TRUE, BOOL fAlwaysMunge = FALSE); 
VOID MungeDialInfo(ArgsStruct *pArgs);
 
void LoadHelpFileInfo(ArgsStruct *pArgs);

void CopyPhone(ArgsStruct *pArgs, 
               LPRASENTRY preEntry, 
               DWORD dwEntry); 
 
VOID LoadLogoBitmap(ArgsStruct * pArgs, 
                    HWND hwndDlg);

HRESULT LoadFutureSplash(ArgsStruct * pArgs, 
                         HWND hwndDlg);

void LoadProperties(
    ArgsStruct  *pArgs
);

void LoadIconsAndBitmaps(
    ArgsStruct  *pArgs, 
    HWND        hwndDlg
);

DWORD DoRasDial(HWND hwndDlg, 
              ArgsStruct *pArgs, 
              DWORD dwEntry); 

DWORD DoTunnelDial(HWND hwndDlg, 
                 ArgsStruct *pArgs);

BOOL CheckConnect(HWND hwndDlg, 
                  ArgsStruct *pArgs, 
                  UINT *pnCtrlFocus,
                  BOOL fShowMsg = FALSE); 

void MainSetDefaultButton(HWND hwndDlg, 
                          UINT nCtrlId); 

VOID MapStateToFrame(ArgsStruct * pArgs);

void SetInteractive(HWND hwndDlg, 
                    ArgsStruct *pArgs);

void OnMainLoadStartupInfo(
    HWND hwndDlg, 
    ArgsStruct *pArgs
);

BOOL SetupInternalInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
);

void OnMainInit(HWND hwndDlg, 
                ArgsStruct *pArgs);

void OnMainConnect(HWND hwndDlg, 
                   ArgsStruct *pArgs);

int OnMainProperties(HWND hwndDlg, 
                     ArgsStruct *pArgs); 

void OnMainCancel(HWND hwndDlg, 
                  ArgsStruct *pArgs); 

void OnMainEnChange(HWND hwndDlg, 
                    ArgsStruct *pArgs); 

DWORD OnRasNotificationMessage(HWND hwndDlg, 
                               ArgsStruct *pArgs, 
                               WPARAM wParam, 
                               LPARAM lParam);

void OnRasErrorMessage(HWND hwndDlg, 
                       ArgsStruct *pArgs,
                       DWORD dwError);

void OnMainTimer(HWND hwndDlg, 
                 ArgsStruct *pArgs); 

void OnConnectedCM(HWND hwndDlg, 
                ArgsStruct *pArgs);

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, 
                          UINT uMsg, 
                          WPARAM wParam, 
                          LPARAM lParam); 

BOOL ShowAccessPointInfoFromReg(ArgsStruct *pArgs, 
                                HWND hwndParent, 
                                UINT uiComboID);

BOOL ChangedAccessPoint(ArgsStruct *pArgs, 
                           HWND hwndDlg,
                           UINT uiComboID);

// dialogs.cpp

int DoPropertiesPropSheets(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
);

void CheckConnectionAndInformUser(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
);

BOOL HaveContextHelp(
     HWND    hwndDlg,
     HWND    hwndCtrl
);

// refs.cpp

BOOL ValidTopLevelPBK(
    ArgsStruct  *pArgs
);

BOOL ValidReferencedPBKs(
    ArgsStruct  *pArgs
);

CIni* GetAppropriateIniService(
    ArgsStruct  *pArgs,
    DWORD       dwEntry
);



// ctr.cpp

VOID CleanupCtr(LPICMOCCtr pCtr);

BOOL LinkToOle32(
    Ole32LinkageStruct *polsOle32Link,
    LPCSTR pszOle32); 

void UnlinkFromOle32(
    Ole32LinkageStruct *polsOle32Link); 

// util.cpp

BOOL InBetween(int iLowerBound, int iNumber, int iUpperBound);

void GetPrefixSuffix
(
    ArgsStruct *pArgs, 
    CIni* piniService, 
    LPTSTR *ppszUsernamePrefix, 
    LPTSTR *ppszUsernameSuffix
);

LPTSTR ApplyPrefixSuffixToBufferAlloc
(
    ArgsStruct *pArgs, 
    CIni *piniService, 
    LPTSTR pszBuffer
);

LPTSTR ApplyDomainPrependToBufferAlloc
(
    ArgsStruct *pArgs, 
    CIni *piniService, 
    LPTSTR pszBuffer,
    LPCTSTR pszDunName
);

void ApplyPasswordHandlingToBuffer
(
    ArgsStruct *pArgs,
    LPTSTR pszBuffer
);

BOOL IsActionEnabled(CONST WCHAR *pszProgram, 
                     CONST WCHAR *pszServiceName, 
                     CONST WCHAR *pszServiceFileName, 
                     LPDWORD lpdwLoadType);

BOOL IsLogonAsSystem();

BOOL UnRegisterWindowClass(HINSTANCE hInst);

DWORD RegisterWindowClass(HINSTANCE hInst);

LPCM_CONNECTION GetConnection(ArgsStruct *pArgs);

void NotifyUserOfExistingConnection(
    HWND hwndParent, 
    LPCM_CONNECTION pConnection,
    BOOL fStatus);

BOOL FileExists(LPCTSTR pszFullNameAndPath);

LPTSTR  CmGetWindowTextAlloc(
    HWND hwndDlg, 
    UINT nCtrl);

LPTSTR GetServiceName(CIni *piniService); 

LPTSTR GetTunnelSuffix();

LPTSTR GetDefaultDunSettingName(CIni* piniService, BOOL fTunnelEntry);

LPTSTR GetDunSettingName(ArgsStruct * pArgs, DWORD dwEntry, BOOL fTunnelEntry);

LPTSTR GetCMSforPhoneBook(ArgsStruct * pArgs, DWORD dwEntry);

BOOL ReadMappingByRoot(
    HKEY    hkRoot,
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwMapping,
    BOOL bExpandEnvStrings
);

BOOL ReadMapping(
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwMapping,
    BOOL fAllUser,
    BOOL bExpandEnvStrings
);

LPTSTR ReducePathToRelative(
    ArgsStruct *pArgs, 
    LPCTSTR pszFullPath);

BOOL IsBlankString(LPCTSTR pszString);

BOOL IsValidPhoneNumChar(TCHAR tChar);

LPTSTR StripPath(LPCTSTR pszFullNameAndPath);

void SingleSpace(LPTSTR pszStr);

void Ip_GPPS(CIni *pIni, 
    LPCTSTR pszSection, 
    LPCTSTR pszEntry, 
    RASIPADDR *pIP);

void CopyGPPS(CIni *pIni, 
    LPCTSTR pszSection, 
    LPCTSTR pszEntry,
    LPTSTR pszBuffer, 
    size_t nLen); 

BYTE HexValue(IN CHAR ch);
CHAR HexChar(IN BYTE byte);

void StripCanonical(LPTSTR pszSrc);
void StripFirstElement(LPTSTR pszSrc);

BOOL FrontExistingUI
(
    CConnectionTable *pConnTable,
    LPCTSTR pszServiceName, 
    BOOL fConnect
);


LPTSTR GetPropertiesDlgTitle(
    LPCTSTR pszServiceName
);

int GetPPTPMsgId(void);

BOOL IsServicePackInstalled(void);

// pb.cpp

#define CPBMAP_ERROR    -1

class CPBMap {
        public:
                CPBMap();
                ~CPBMap();
                DWORD Open(LPCSTR pszISP, DWORD dwParam=0);
                DWORD ToCookie(DWORD_PTR dwPB, DWORD dwIdx, DWORD *pdwParam=NULL);
                DWORD_PTR PBFromCookie(DWORD dwCookie, DWORD *pdwParam=NULL);
                DWORD IdxFromCookie(DWORD dwCookie, DWORD *pdwParam=NULL);
                DWORD_PTR GetPBByIdx(DWORD_PTR dwIdx, DWORD *pdwParam=NULL);
                DWORD GetCnt();
        private:
                UINT m_nCnt;
                void *m_pvData;
};

#define PB_MAX_PHONE    (RAS_MaxPhoneNumber+1)
#define PB_MAX_DESC             256

typedef struct tagPBArgs {
        LPCTSTR pszCMSFile;
        TCHAR szServiceType[PB_MAX_SERVICE];
        DWORD dwCountryId;
        TCHAR szRegionName[PB_MAX_REGION];
        TCHAR szNonCanonical[PB_MAX_PHONE];
        TCHAR szCanonical[PB_MAX_PHONE];
        TCHAR szDesc[PB_MAX_DESC];
        LPTSTR pszMessage;
        TCHAR szPhoneBookFile[MAX_PATH+1];
        LPTSTR pszBitmap;
        LPCTSTR pszHelpFile;
        TCHAR szDUNFile[MAX_PATH+1];
        HPALETTE *phMasterPalette;
} PBArgs;


BOOL DisplayPhoneBook(HWND hwndDlg, PBArgs *pArgs, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs);

// rnawnd.cpp

HANDLE ZapRNAConnectedTo(LPCTSTR pszDUN, HANDLE hEvent);

// userinfo.cpp

BOOL GetUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       *ppvData
);

BOOL SaveUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       pvData
);

BOOL DeleteUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry
);

int NeedToUpgradeUserInfo(
    ArgsStruct  *pArgs
);

BOOL UpgradeUserInfoFromCmp(
    ArgsStruct  *pArgs
);

BOOL UpgradeUserInfoFromRegToRasAndReg(
    ArgsStruct  *pArgs
);

BOOL ReadUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       *ppvData);

LPTSTR BuildUserInfoSubKey(
    LPCTSTR pszServiceKey, 
    BOOL fAllUser);

LPTSTR BuildICSDataInfoSubKey(
    LPCTSTR pszServiceKey);

BOOL WriteUserInfoToReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData);

// ntlsa.cpp

DWORD LSA_ReadString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPTSTR      pszStr,
    DWORD       dwStrLen
);

DWORD LSA_WriteString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPCTSTR     pszStr
);

BOOL InitLsa(
    ArgsStruct  *pArgs
);

BOOL DeInitLsa(
    ArgsStruct  *pArgs
);



// ras.cpp
BOOL ConfiguredToDialWithSafeNet(ArgsStruct *pArgs);
BOOL IsSafeNetDevice(LPCTSTR pszDeviceType, LPCTSTR pszDeviceName);
BOOL IsRasLoaded(const RasLinkageStruct * const prlsRasLink);
BOOL LinkToRas(RasLinkageStruct *prlsRasLink);
void UnlinkFromRas(RasLinkageStruct *prlsRasLink);
BOOL GetRasModems(const RasLinkageStruct *prlsRasLink, 
                  LPRASDEVINFO *pprdiRasDevInfo, 
                  LPDWORD pdwCnt);

BOOL PickModem(IN const ArgsStruct *pArgs, 
               OUT LPTSTR pszDeviceType, 
               OUT LPTSTR pszDeviceName, 
               OUT BOOL* pfSameModem = NULL); 

BOOL GetDeviceType(ArgsStruct *pArgs, 
                   LPTSTR pszDeviceType, 
                   LPTSTR pszDeviceName);

BOOL PickTunnelDevice(ArgsStruct *pArgs, LPTSTR pszDeviceType, LPTSTR pszDeviceName);

void CopyAutoDial(LPRASENTRY preEntry); 
                           
LPRASENTRY MyRGEP(LPCTSTR pszRasPbk,
                  LPCTSTR pszEntryName, 
                  RasLinkageStruct *prlsRasLink);
                  
BOOL CheckConnectionError(HWND hwndDlg, 
                   DWORD dwErr, 
                   ArgsStruct *pArgs,
                   BOOL    fTunneling,
                   LPTSTR   *ppszRasErrMsg = NULL);

LPTSTR GetRasConnectoidName(
    ArgsStruct  *pArgs, 
    CIni*       piniService, 
    BOOL        fTunnelEntry
);

LPRASENTRY CreateRASEntryStruct(
    ArgsStruct  *pArgs, 
    LPCTSTR     pszDUN, 
    CIni*       piniService, 
    BOOL        fTunnelEntry,
    LPTSTR      pszRasPbk,
    LPBYTE      *ppbEapData,
    LPDWORD     pdwEapSize  
);

LRESULT ReadDUNSettings(
    ArgsStruct *pArgs,
    LPCTSTR pszFile, 
    LPCTSTR pszDunName, 
    LPVOID pvBuffer,
    LPBYTE      *ppbEapData,
    LPDWORD     pdwEapSiz,
    BOOL        fTunnel
);

BOOL ValidateDialupDunSettings(LPCTSTR pszCmsFile, 
    LPCTSTR pszDunName,
    LPCTSTR pszTopLevelCms);

LPTSTR CreateRasPrivatePbk(
    ArgsStruct  *pArgs);

LPTSTR GetPathToPbk(
    LPCTSTR pszCmp, ArgsStruct *pArgs);

void DisableWin95RasWizard(
    void
);

BOOL SetIsdnDualChannelEntries(
    ArgsStruct      *pArgs,
    LPRASENTRY      pre,
    LPRASSUBENTRY   *pprse,
    PDWORD          pdwSubEntryCount
);

BOOL SetNtIdleDisconnectInRasEntry(
    ArgsStruct      *pArgs,
    LPRASENTRY      pre
);

BOOL DisableSystemIdleDisconnect(LPRASENTRY pre);

DWORD WINAPI RasDialFunc2(
    ULONG_PTR dwCallbackId,    // user-defined value specified in RasDial 
                           // call
    DWORD dwSubEntry,      // subentry index in multilink connection
    HRASCONN hrasconn,     // handle to RAS connection
    UINT unMsg,            // type of event that has occurred
    RASCONNSTATE rascs,    // connection state about to be entered
    DWORD dwError,         // error that may have occurred
    DWORD dwExtendedError  // extended error information for some 
                           // errors
);

LPRASENTRY AllocateRasEntry();

LPRASDIALEXTENSIONS AllocateAndInitRasDialExtensions();
DWORD InitRasDialExtensions(LPRASDIALEXTENSIONS lpRasDialExtensions);
DWORD SetRasDialExtensions(ArgsStruct* pArgs, BOOL fEnablePausedStates, BOOL fEnableCustomScripting);

LPVOID GetRasCallBack(ArgsStruct* pArgs);
DWORD GetRasCallBackType();

#if 0
/*
void InitDefaultRasPhoneBook();
LPTSTR GetRasSystemPhoneBookPath();
*/
#endif

LPRASDIALPARAMS AllocateAndInitRasDialParams();
DWORD InitRasDialParams(LPRASDIALPARAMS lpRasDialParams);


LPTSTR GetRasPbkFromNT5ProfilePath(LPCTSTR pszProfile);

DWORD OnPauseRasDial(HWND hwndDlg, ArgsStruct *pArgs, WPARAM wParam, LPARAM lParam);   

BOOL ReadDunSettingsEapData(CIni *pIni, 
        LPBYTE* ppbEapData,
        LPDWORD pdwEapSize,
        const DWORD dwCustomAuthKey,
        LPBYTE* ppbEapStruct,
        LPDWORD pdwEapStructSize);

// tapi.cpp

BOOL OpenTapi(HINSTANCE hInst, TapiLinkageStruct *ptlsTapiLink);
void CloseTapi(TapiLinkageStruct *ptlsTapiLink);
BOOL LinkToTapi(TapiLinkageStruct *ptlsTapiLink, LPCSTR pszTapi);
void UnlinkFromTapi(TapiLinkageStruct *ptlsTapiLink);
BOOL SetTapiDevice(HINSTANCE hInst, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   LPCTSTR pszModem);

LRESULT MungePhone(LPCTSTR pszModem, 
                   LPTSTR *ppszPhone, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   HINSTANCE hInst,
                   BOOL fDialingRulesEnabled,
                   LPTSTR *ppszDial,
                   BOOL fAccessPointsEnabled);

DWORD GetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink);

DWORD SetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink, DWORD dwLocation);

void RestoreOldTapiLocation(TapiLinkageStruct *ptlsTapiLink);

HANDLE HookLights(ArgsStruct *pArgs);

inline BOOL IsTunnelEnabled(const ArgsStruct* pArgs)
{
    return (pArgs->fTunnelPrimary || pArgs->fTunnelReferences);
}

inline BOOL IsDialingTunnel(const ArgsStruct* pArgs)
{
    return pArgs->psState == PS_TunnelDialing 
        || pArgs->psState == PS_TunnelAuthenticating;
}

inline BOOL _ArgsStruct::IsDirectConnect() const
{
    return m_fDirectConnect;
}

inline void _ArgsStruct::SetDirectConnect(BOOL fDirect)
{
    m_fDirectConnect = fDirect;
}

inline BOOL _ArgsStruct::IsBothConnTypeSupported() const
{
    return m_fBothConnTypeSupported;
}

inline void _ArgsStruct::SetBothConnTypeSupported(BOOL fBoth)
{
    m_fBothConnTypeSupported = fBoth;    
}

// wsock.cpp

BOOL TryAnotherTunnelDnsAddress(
    ArgsStruct  *pArgs
);

// main.cpp

BOOL WhoIsCaller(
    DWORD   dwCaller = DT_USER
);


// lanawait.cpp

BOOL LanaWait(
    ArgsStruct *pArgs,
    HWND       hwndMainDlg
);

//
// Credential helper functions
//

#define CM_DELETE_SAVED_CREDS_KEEP_GLOBALS              FALSE
#define CM_DELETE_SAVED_CREDS_DELETE_GLOBALS            TRUE
#define CM_DELETE_SAVED_CREDS_KEEP_IDENTITY             FALSE
#define CM_DELETE_SAVED_CREDS_DELETE_IDENTITY           TRUE

BOOL InitializeCredentialSupport(ArgsStruct *pArgs);
BOOL RefreshCredentialTypes(ArgsStruct *pArgs, BOOL fSetCredsDefault);
VOID RefreshCredentialInfo(ArgsStruct *pArgs, DWORD dwCredsType);
DWORD FindEntryCredentialsForCM(ArgsStruct *pArgs, LPTSTR pszPhoneBook, BOOL *pfUser, BOOL *pfGlobal);
DWORD GetCurrentCredentialType(ArgsStruct *pArgs);
BOOL DeleteSavedCredentials(ArgsStruct *pArgs, DWORD dwCredsType, BOOL fDeleteGlobal, BOOL fDeleteIdentity);
VOID SetCredentialUIOptionBasedOnDefaultCreds(ArgsStruct *pArgs, HWND hwndDlg);
VOID GetAndStoreUserInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSaveUPD, BOOL fSaveOtherUserInfo);
VOID TryToDeleteAndSaveCredentials(ArgsStruct *pArgs, HWND hwndDlg);
VOID GetUserInfoFromDialog(ArgsStruct *pArgs, HWND hwndDlg, RASCREDENTIALS *prc);
VOID SwitchToLocalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToLocal);
VOID SwitchToGlobalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToGlobal);
VOID ReloadCredentials(ArgsStruct *pArgs, HWND hwndDlg, DWORD dwWhichCredType);

//
// Global User Info help functions
//
VOID SetIniObjectReadWriteFlags(ArgsStruct *pArgs);

VOID VerifyAdvancedTabSettings(ArgsStruct *pArgs);
HRESULT InternalGetSharingEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled, SHARINGCONNECTIONTYPE* pType);
HRESULT InternalGetFirewallEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled);
STDMETHODIMP DisableSharing(IHNetConnection *pHNetConn);
VOID EnableInternetFirewall(IHNetConnection *pHNetConn);
BOOL IsAdmin(VOID);
BOOL IsMemberOfGroup(DWORD dwGroupRID, BOOL bUseBuiltinDomainRid);

HRESULT APIENTRY HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu);

#endif // _ICM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\disconn.cpp ===
//+----------------------------------------------------------------------------
//
// File:     disconn.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The main code path for terminating a connection. 
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    2/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "actlist.h"
#include "tunl_str.h"
#include "conact_str.h"

// The following block is copied from wtsapi32.h (we compile with
// _WIN32_WINNT set to less than 5.01, so we can't get these values via a #include)
//
#include "WtsApi32.h"
#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8


//+----------------------------------------------------------------------------
//
// Function:    InFastUserSwitch
//
// Synopsis:    Are we in a Fast User switch
//
// Argsuments:  OUT DWORD* pdwSessions - if pointer is supplied it sets # of 
//                                       current TS sessions
//
// Return:      BOOL (TRUE if yes, FALSE if not)
//
// History: 18-Jul-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
InFastUserSwitch(DWORD *pdwSessions)
{
    BOOL fReturn = FALSE;

    if (OS_NT51)
    {
        HINSTANCE hInstLib = LoadLibraryExU(TEXT("WTSAPI32.DLL"), NULL, 0);
        if (hInstLib)
        {
            typedef BOOL (WINAPI *pfnWTSQuerySessionInformationW_TYPE) (HANDLE, DWORD, WTS_INFO_CLASS, LPWSTR*, DWORD*);
            typedef VOID (WINAPI *pfnWTSFreeMemory_TYPE) (PVOID);
            typedef BOOL (WINAPI *pfnWTSEnumerateSessionsW_TYPE) (HANDLE, DWORD, DWORD, PWTS_SESSION_INFO*, DWORD*);

            pfnWTSQuerySessionInformationW_TYPE pfnWTSQuerySessionInformationW;
            pfnWTSFreeMemory_TYPE               pfnWTSFreeMemory;
            pfnWTSEnumerateSessionsW_TYPE       pfnpfnWTSEnumerateSessionsW;

            pfnWTSQuerySessionInformationW = (pfnWTSQuerySessionInformationW_TYPE) GetProcAddress(hInstLib, "WTSQuerySessionInformationW");
            pfnWTSFreeMemory =               (pfnWTSFreeMemory_TYPE)               GetProcAddress(hInstLib, "WTSFreeMemory");
            pfnpfnWTSEnumerateSessionsW =   (pfnWTSEnumerateSessionsW_TYPE)        GetProcAddress(hInstLib, "WTSEnumerateSessionsW");

            if (pfnWTSQuerySessionInformationW && pfnWTSFreeMemory && pfnpfnWTSEnumerateSessionsW)
            {
                DWORD cb;
                WTS_CONNECTSTATE_CLASS * pConnectState = NULL;
                ULONG   *puSessionId = NULL;

                if (pfnWTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE,
                                                   WTS_CURRENT_SESSION,
                                                   WTSSessionId,
                                                   (LPTSTR* )&puSessionId,
                                                   &cb))
                {
                    if (puSessionId)
                    {
                        CMTRACE1(TEXT("InFastUserSwitch() - SessionId = 0x%x"), *puSessionId);
                    
                        pfnWTSFreeMemory(puSessionId);
                    }
                }

                PWTS_SESSION_INFO ppSessionInfo = NULL;
                DWORD dwSessionCount = 0;

                (VOID)pfnpfnWTSEnumerateSessionsW(WTS_CURRENT_SERVER_HANDLE, 0, 1, &ppSessionInfo, &dwSessionCount);

                if (ppSessionInfo)
                {
                    pfnWTSFreeMemory(ppSessionInfo);
                }

                CMTRACE1(TEXT("InFastUserSwitch() - Number of Sessions = %d"), dwSessionCount);

                //
                // Set the out variable
                //
                if (pdwSessions)
                {
                    *pdwSessions = dwSessionCount;
                }

                if (2 < dwSessionCount)
                {
                    fReturn = TRUE;
                }
            }
            else
            {
                CMTRACE(TEXT("InFastUserSwitch() - GetProcAddress failed. Either: pfnWTSQuerySessionInformationW, pfnWTSFreeMemory, pfnpfnWTSEnumerateSessionsW"));
            }

            FreeLibrary(hInstLib);
        }
    }

    CMTRACE1(TEXT("InFastUserSwitch() - returns %d"), (DWORD)fReturn);
    return fReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CleanupDisconnect
//
// Synopsis:  Helper function encapsulating release of resource allocated duri
//            ng disconnect.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    8/14/98
//
//+----------------------------------------------------------------------------
void CleanupDisconnect(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        return;
    }

    UnlinkFromRas(&pArgs->rlsRasLink);

    ReleaseIniObjects(pArgs);

    if (pArgs->pszRasPbk)
    {
        CmFree(pArgs->pszRasPbk);
        pArgs->pszRasPbk = NULL;
    }

    if (pArgs->pszCurrentAccessPoint)
    {
        CmFree(pArgs->pszCurrentAccessPoint);
        pArgs->pszCurrentAccessPoint = NULL;
    }

    if (pArgs->pszRasHiddenPbk)
    {
        CmFree(pArgs->pszRasHiddenPbk);
        pArgs->pszRasHiddenPbk = NULL;
    }

    if (pArgs->pszVpnFile)
    {
        CmFree(pArgs->pszVpnFile);
        pArgs->pszVpnFile = NULL;
    }

    CmFree(pArgs);
}

//+----------------------------------------------------------------------------
//
// Function:  HangupNotifyCmMon
//
// Synopsis:  Sends a hangup message to CmMon via WM_COPYDATA
//
// Arguments: CConnectionTable *pConnTable - Ptr to the Connection table.
//            LPCTSTR pszEntry - The name of the entry.
//
// Returns:   DWORD - Failure code
//
// History:   nickball    Created    2/11/98
//
//+----------------------------------------------------------------------------
DWORD HangupNotifyCmMon(CConnectionTable *pConnTable,
    LPCTSTR pszEntry)
{
    MYDBGASSERT(pConnTable);
    MYDBGASSERT(pszEntry);
    
    if (NULL == pConnTable || NULL == pszEntry || 0 == pszEntry[0])
    {
        return ERROR_INVALID_PARAMETER;
    }
       
    //
    // Update CMMON if present
    //

    HWND hwndMon;
   
    if (SUCCEEDED(pConnTable->GetMonitorWnd(&hwndMon)) && IsWindow(hwndMon))
    {
        CMTRACE1(TEXT("HangupNotifyCmMon() - Notifying CMMON that we are disconnecting %s"), pszEntry);

        //
        // Stash the entry name in HangupInfo 
        //

        CM_HANGUP_INFO HangupInfo;

        lstrcpyU(HangupInfo.szEntryName, pszEntry);

        //
        // Send Hangup info to CMMON via COPYDATA
        //

        COPYDATASTRUCT CopyData;

        CopyData.dwData = CMMON_HANGUP_INFO;
        CopyData.cbData = sizeof(CM_HANGUP_INFO);                
        CopyData.lpData = (PVOID) &HangupInfo;

        SendMessageU(hwndMon, WM_COPYDATA, NULL, (LPARAM) &CopyData);
    }

#ifdef DEBUG
    if (!hwndMon)
    {
        CMTRACE(TEXT("HangupNotifyCmMon() - CMMON hwnd is NULL"));
    }
#endif
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  DoDisconnect
//
// Synopsis:  Encapulates initialization of pArgs with profile, service, etc. 
//            Runs disconnect actions and terminates the connection.
//
// Arguments: LPCM_CONNECTION pConnection - Ptr to a CM_CONNECTION struct containing 
//            connection info such as entry name and RAS handles.
//            BOOL fActions - Flag indicating that disconnect actions should be run
//
// Returns:   DWORD - Failure code
//
// History:   nickball    Created Header    2/12/98
//
//+----------------------------------------------------------------------------
DWORD DoDisconnect(LPCM_CONNECTION pConnection, BOOL fActions)
{
    MYDBGASSERT(pConnection);
    CMTRACE(TEXT("DoDisconnect() - Start"));
    HRESULT hrLog = E_FAIL;

    if (NULL == pConnection)
    {
        return ERROR_INVALID_PARAMETER;
    }   

    //
    // Allocate and initialize pArgs
    //

    ArgsStruct* pArgs = (ArgsStruct*) CmMalloc(sizeof(ArgsStruct));

    if (NULL == pArgs)
    {
        return ERROR_ALLOCATING_MEMORY;
    }

    //
    // Clear and init global args struct
    //
    
    HRESULT hrRet = InitArgsForDisconnect(pArgs, pConnection->fAllUser);
    
    if (FAILED(hrRet))
    {
        CMTRACE(TEXT("DoDisconnect() - InitArgsForDisconnect() failed. Exiting function."));
        return HRESULT_CODE(hrRet);
    }

    //
    //  If we are in a Fast User Switch, set the flag so that we can skip customactions
    //  that might block the disconnect (by bringing up UI etc)
    //
    pArgs->fInFastUserSwitch = InFastUserSwitch(NULL);

    //
    // Initialize the profile
    //

    hrRet = InitProfile(pArgs, pConnection->szEntry);

    //
    // If InitProfile() succeeds, it's either an all-user profile or the user is logged in (not logged in as system)
    //
    if (SUCCEEDED(hrRet))
    {
        if ((FALSE == IsLogonAsSystem()) || (FALSE == pArgs->fInFastUserSwitch))
        {
            CMTRACE(TEXT("DoDisconnect() - InitProfile() succeeded. Not Logged in as system or not FUS"));

            //
            // Do we want tunneling?  If this was a tunnel connection, then the connection table
            // will have a non-NULL value for the hTunnel field of that connection entry.
            //

            pArgs->fTunnelPrimary = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelPrimary);
            pArgs->fTunnelReferences = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelReferences);
            pArgs->fUseTunneling = pConnection->hTunnel ? TRUE : FALSE;

            //
            // Determine our connect type
            //
            
            GetConnectType(pArgs);
            //
            //  Initialize the path to the phonebook if this is NT5 so that disconnect
            //  actions can use it if they want to.  Note that the temporary phonebook
            //  has already been deleted at this point so we will return NULL so that
            //  it doesn't confuse the disconnect actions.
            //
            if (OS_NT5)
            {
                pArgs->pszRasPbk = GetRasPbkFromNT5ProfilePath(pArgs->piniProfile->GetFile());
            }    

            //
            // Initialize logging and log the disconnect event.
            //

            hrLog = InitLogging(pArgs, pConnection->szEntry, FALSE); // FALSE => no banner
            if (SUCCEEDED(hrLog))
            {
                TCHAR szTmp[MAX_PATH + 1] = {0};            
                MYVERIFY(GetModuleFileNameU(NULL, szTmp, MAX_PATH));          
                pArgs->Log.Log(DISCONNECT_EVENT, szTmp);
            }

            //
            // If we are connected, run Disconnect Actions before we actually terminate
            //

            if (fActions)
            {
                CActionList DisconnectActList;
                DisconnectActList.Append(pArgs->piniService, c_pszCmSectionOnDisconnect);

                DisconnectActList.RunAccordType(NULL, pArgs, FALSE); 
            }
        }
        else
        {
            CMTRACE(TEXT("DoDisconnect() - IsLogonAsSystem() and FUS. Just disconnect."));
        }
    }
    else
    {
        //
        // We don't want to return an error. This case happens for a single user profile
        // on Home Edtion and Pro not joined to a Domain when doing a FUS. But we still want
        // to try to disconnect.
        //
        CMTRACE(TEXT("DoDisconnect() - InitProfile() failed. Most likely Single User profile and FUS. Just disconnect."));
    }

    //
    // Initialize Data and links for Hangup
    //
   
    if (FALSE == LinkToRas(&pArgs->rlsRasLink))
    {
        MYDBGASSERT(FALSE);
        return ERROR_NOT_READY; 
    }

    //
    // Linkage is good, hangup 
    // 

    if (pArgs->rlsRasLink.pfnHangUp)
    {
        //
        // Test the connection status of each connection handle. If not 
        // connected, then there is no reason for us to call Hangup
        //
        
        RASCONNSTATUS rcs;             
        
        if (pConnection->hTunnel) 
        {
            ZeroMemory(&rcs,sizeof(rcs));
            rcs.dwSize = sizeof(rcs);

            if (ERROR_SUCCESS == pArgs->rlsRasLink.pfnGetConnectStatus(pConnection->hTunnel,&rcs) &&
                rcs.rasconnstate == RASCS_Connected)
            {
                if (IsLogonAsSystem())
                {
                    //
                    // Don't want to bring up any UI
                    //
                    DoRasHangup(&pArgs->rlsRasLink, pConnection->hTunnel);
                }
                else
                {
                    MYVERIFY(ERROR_SUCCESS == DoRasHangup(&pArgs->rlsRasLink, pConnection->hTunnel));
                }
            }
        }

        if (pConnection->hDial)
        {
            ZeroMemory(&rcs,sizeof(rcs));
            rcs.dwSize = sizeof(rcs);

            if (ERROR_SUCCESS == pArgs->rlsRasLink.pfnGetConnectStatus(pConnection->hDial,&rcs) &&
                rcs.rasconnstate == RASCS_Connected)
            {
                if (IsLogonAsSystem())
                {
                    //
                    // Don't want to bring up any UI
                    //
                    DoRasHangup(&pArgs->rlsRasLink, pConnection->hDial);
                }
                else
                {
                    DWORD dwRet = DoRasHangup(&pArgs->rlsRasLink, pConnection->hDial);
                    if (ERROR_SUCCESS != dwRet)
                    {
                        CMTRACE1(TEXT("DoDisconnect: DoRasHangup failed with error code with %d"), dwRet);
                    }
                }
            }
        }
    }

    
    if (SUCCEEDED(hrLog))
    {
        //
        // Un-initialize logging, if it was initialized
        //
        (VOID)pArgs->Log.DeInit();
    }

    //
    // Cleanup linkage and memory
    //

    CleanupDisconnect(pArgs);
    
    CMTRACE(TEXT("DoDisconnect() - End"));

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  Disconnect
//
// Synopsis:  Disconnects the connection with the name pszEntry.
//
// Arguments: CConnectionTable *pConnTable - Ptr to connection table
//            LPCM_CONNECTION pConnection - The current table data for the entry.
//            BOOL fIgnoreRefCount - Flag to override ref count
//            BOOL fPersist - Flag indicating that entry should be persistent
//
// Returns:   DWORD - Failure code
//
// History:   nickball    Created    2/11/98
//
//+----------------------------------------------------------------------------
DWORD Disconnect(CConnectionTable *pConnTable, LPCM_CONNECTION pConnection, BOOL fIgnoreRefCount, BOOL fPersist)
{
    MYDBGASSERT(pConnection);
    MYDBGASSERT(pConnTable);
    
    CMTRACE(TEXT("Disconnect()"));

#ifdef DEBUG
    IsLogonAsSystem(); // Traces user name
#endif

    if (NULL == pConnection || NULL == pConnTable)
    {
        return ERROR_INVALID_PARAMETER;
    }

//    MYDBGASSERT(!(fIgnoreRefCount && fPersist)); // mutually exclusive flags
    MYDBGASSERT(CM_CONNECTING != pConnection->CmState); 

    if (!fIgnoreRefCount)
    {
        //
        // The hangup is not forced, check usage
        //

        if (pConnection->dwUsage > 1)
        {
            //
            // As long as fPersist is false, adjust the usage count
            //

            if (!fPersist)
            {
                pConnTable->RemoveEntry(pConnection->szEntry);
            }
            
            return ERROR_SUCCESS;                                
        }
        else
        {
            //
            // If we are already disconnecting, just succeed
            //

            if (CM_DISCONNECTING == pConnection->CmState)
            {
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Looks like we are comitted to getting to a usage of zero, tell CMMON
    // to stop monitoring this connection unless we are in persist state.
    // 
    
    if (!fPersist)
    {
        HangupNotifyCmMon(pConnTable, pConnection->szEntry);
    }

    LRESULT lRes = ERROR_SUCCESS;

    //
    // Usage is down <= 1, or being ignored. If we are in reconnect prompt 
    // state, then there is nothing to disconnect so don't call hangup.
    //

    if (CM_RECONNECTPROMPT != pConnection->CmState)
    {
        //
        // We are committed to a real disconnect, so set the entry
        // to the disconnecting state while we hangup.
        //

        BOOL fActions = (CM_CONNECTED == pConnection->CmState); 
    
        pConnTable->SetDisconnecting(pConnection->szEntry);

        lRes = DoDisconnect(pConnection, fActions);

        //
        // If persisting, just set the state to reconnect prompt
        //

        if (fPersist)
        {
            //
            // Set entry to limbo state of reconnect prompt
            //

            pConnTable->SetPrompting(pConnection->szEntry);
            return (DWORD)lRes;
        }
    }

    //
    // If forced connect, removed entry completely
    //

    if (fIgnoreRefCount)
    {
        pConnTable->ClearEntry(pConnection->szEntry);           
    }
    else
    {
        pConnTable->RemoveEntry(pConnection->szEntry);     
    }
 
    return (DWORD)lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\image.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 image.cpp
//
// Module:	 CMDIAL32.DLL
//
// Synopsis:  Imaging support routines
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 nickball   Created Header   3/30/98
//		     quintinb   modified to use common\source\bmpimage.cpp 8-6-98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//  Include the shared bitmap handling code. (see common\source\bmpimage.cpp)
//
#include "bmpimage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\lanawait.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 lanawait.cpp
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Implementation for the workaround to make CM wait for DUN to 
//           register its LANA for an internet connection before beginning 
//           the tunnel portion of a double dial connection.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:	 quintinb   Created Header    08/17/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

const TCHAR* const c_pszCmEntryLanaTimeout = TEXT("LanaTimeout"); 

//+---------------------------------------------------------------------------
//
//	Function:	LanaWait
//
//	Synopsis:	Peform the LANA wait/timeout.
//
//	Arguments:	pArgs [the ptr to ArgsStruct]
//              hwndMainDlg - hwnd of the main dlg
//
//	Returns:	BOOL    TRUE=succes, FALSE=wait not performed.
//
//----------------------------------------------------------------------------
BOOL LanaWait(
    ArgsStruct *pArgs,
    HWND       hwndMainDlg
)
{
    BOOL    fLanaDone = FALSE;
    BOOL    fLanaAbort = FALSE;

    if (IsLanaWaitEnabled())
    {
        CMTRACE(TEXT("Performing Lana Wait!!"));

        WNDCLASSEX WndClass;
        HWND     hWnd;
    
        ZeroMemory(&WndClass, sizeof(WNDCLASSEX));

        WndClass.cbSize        = sizeof(WNDCLASSEX);
        WndClass.lpfnWndProc   = LanaWaitWndProc;
        WndClass.hInstance     = g_hInst;
        WndClass.hIcon         = LoadIconU(NULL, IDI_APPLICATION);
        WndClass.hCursor       = LoadCursorU(NULL, IDC_ARROW);
        WndClass.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH);
        WndClass.lpszClassName = LANAWAIT_CLASSNAME;

        MYVERIFY(RegisterClassExU(&WndClass));

        if (!(hWnd = CreateWindowExU(0,
                                     LANAWAIT_CLASSNAME,
                                     LANAWAIT_WNDNAME,
                                     WS_OVERLAPPEDWINDOW,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     (HWND)NULL,
                                     NULL,
                                     g_hInst,
                                     (LPVOID)pArgs)))
        {
            CMTRACE1(TEXT("CreateWindow LANA failed, LE=0x%x"), GetLastError());
        }
        else
        {
            MSG msg;
            ZeroMemory(&msg, sizeof(MSG));

            while (GetMessageU(&msg, NULL, 0, 0))
            {
                //
                // Since we have no accelerators, no need to call
                // TranslateAccelerator here.
                //

                TranslateMessage(&msg);
                DispatchMessageU(&msg);

                //
                // If we received a msg from the top-level
                // window, then the dial is being canceled
                //

                if (pArgs->uLanaMsgId == msg.message)
                {
                    fLanaAbort = TRUE;
                    DestroyWindow(hWnd); //break;
                }
            }
        
            UnregisterClassU(LANAWAIT_CLASSNAME, g_hInst);
            SetActiveWindow(hwndMainDlg);

            //
            // once we've run it once, we don't need to run it again 
            // until after reboot or switch to a different domain.
            // it's safe to just run it every time.
            //

            if (!fLanaAbort)
            {   
                fLanaDone = TRUE;
            }
       }
    }
    else
    {
        CMTRACE(TEXT("Lana Wait is disabled"));
        fLanaDone = TRUE;
    }

    return fLanaDone;
}



//+----------------------------------------------------------------------------
//  Function    LanaWaitWndProc
//
//  Synopsis    Window function for the main app.  Waits for device change
//              message. This funcion will time out if device change is
//              not recieived in LANA_TIMEOUT_DEFAULT secs.
//
//-----------------------------------------------------------------------------

LRESULT APIENTRY LanaWaitWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (message)
    {
        case WM_CREATE:
            {
            UINT    uiTimeout = ((ArgsStruct *)((CREATESTRUCT *)lParam)->lpCreateParams)
                                    ->piniService->GPPI(c_pszCmSection, c_pszCmEntryLanaTimeout, LANA_TIMEOUT_DEFAULT);

            CMTRACE1(TEXT("Lana timeout time = %u ms"), uiTimeout*1000);
            //
            // set up the timer
            //
	        SetTimer(hWnd, LANA_TIME_ID, uiTimeout*1000, (TIMERPROC)NULL);
            }
			break;

        //
		// This is the message we are waiting for the LANA is registered
        //
        case WM_DEVICECHANGE:
            {
            PDEV_BROADCAST_HDR   pDev;
            PDEV_BROADCAST_NET   pNetDev;
               
            CMTRACE(TEXT("Lana - WM_DEVICECHANGE"));

			if (wParam == DBT_DEVICEARRIVAL)
            {
		        pDev = (PDEV_BROADCAST_HDR) lParam;
				if (pDev->dbch_devicetype != DBT_DEVTYP_NET)
                {
					break;
				}

				pNetDev = (PDEV_BROADCAST_NET) pDev;
				if (!(pNetDev->dbcn_flags & DBTF_SLOWNET))
                {
					break;
				}

                CMTRACE(TEXT("Got Lana registration!!!"));
                //
				// Must wait for Broadcast to propigate to all windows. 
                //
                KillTimer(hWnd, LANA_TIME_ID);

                CMTRACE1(TEXT("Lana propagate time = %u ms"), LANA_PROPAGATE_TIME_DEFAULT*1000);

                SetTimer(hWnd, LANA_TIME_ID, LANA_PROPAGATE_TIME_DEFAULT*1000, (TIMERPROC)NULL);
			}
            }
			break;	 


			//  If we get this message we timed out on the device change

        case WM_TIMER:  
            if (wParam == LANA_TIME_ID)
            {
                CMTRACE(TEXT("Killing LANA window..."));
                DestroyWindow(hWnd); 		            
	        }
		    break;
	  
        case WM_DESTROY:
			KillTimer(hWnd, LANA_TIME_ID);
            PostQuitMessage(0);
            break;
       
        default:
            return DefWindowProcU(hWnd, message, wParam, lParam);
    }

    return 0;
}



//+----------------------------------------------------------------------------
//  Function    IsLanaWaitEnabled
//
//  Synopsis    Check to see if the lana wait is enabled.  It's enabled if 
//              reg key value has a non-zero value.
//
//  Arguments   NONE
//
//  Return      TRUE - enabled
//              FALSE  - disabled
//
//-----------------------------------------------------------------------------

BOOL IsLanaWaitEnabled()
{
    BOOL fLanaWaitEnabled = FALSE;
    HKEY hKeyCm;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    if (RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                      c_pszRegCmRoot,
                      0,
                      KEY_QUERY_VALUE ,
                      &hKeyCm) == ERROR_SUCCESS)
    {
        LONG lResult = RegQueryValueExU(hKeyCm, ICM_REG_LANAWAIT, NULL, &dwType, (BYTE*)&fLanaWaitEnabled, &dwSize);

        if ((lResult == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwSize == sizeof(DWORD)) && fLanaWaitEnabled)
        {
            fLanaWaitEnabled = TRUE;
        }

        RegCloseKey(hKeyCm);
    }

    return fLanaWaitEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\init.cpp ===
//+----------------------------------------------------------------------------
//
// File:     init.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The various initialization routines live here.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    2/11/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ConnStat.h"
#include "profile_str.h"
#include "log_str.h"
#include "dial_str.h"
#include "userinfo_str.h"
#include "pwd_str.h"

const TCHAR* const c_pszCmEntryHideUserName             = TEXT("HideUserName"); 
const TCHAR* const c_pszCmEntryHidePassword             = TEXT("HidePassword"); 
const TCHAR* const c_pszCmEntryDisableBalloonTips       = TEXT("HideBalloonTips");

//+----------------------------------------------------------------------------
//
// Function:  RegisterBitmapClass
//
// Synopsis:  Helper function to encapsulate registration of our bitmap class
//
// Arguments: HINSTANCE hInst - HINSTANCE to associate registration with
//
// Returns:   DWORD - error code 
//
// History:   nickball    Created Header    2/9/98
//
//+----------------------------------------------------------------------------
DWORD RegisterBitmapClass(HINSTANCE hInst) 
{
    //
    // Register Bitmap class
    //

    WNDCLASSEX wcClass;

    ZeroMemory(&wcClass,sizeof(WNDCLASSEX));
    wcClass.cbSize = sizeof(WNDCLASSEX);
    wcClass.lpfnWndProc = BmpWndProc;
    wcClass.cbWndExtra = sizeof(HBITMAP) + sizeof(LPBITMAPINFO);
    wcClass.hInstance = hInst;
    wcClass.lpszClassName = ICONNMGR_BMP_CLASS;
    
    if (!RegisterClassExU(&wcClass)) 
    {
        DWORD dwError = GetLastError();

        CMTRACE1(TEXT("RegisterBitmapClass() RegisterClassEx() failed, GLE=%u."), dwError);

        //
        // Only fail if the class does not already exist
        //

        if (ERROR_CLASS_ALREADY_EXISTS != dwError)
        {
            return dwError;
        }
    }      

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  ReleaseIniObjects
//
// Synopsis:  Encapsulates freeing of ini objects
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    2/12/98
//
//+----------------------------------------------------------------------------
void ReleaseIniObjects(ArgsStruct *pArgs)
{
    if (pArgs->piniProfile)
    {
        delete pArgs->piniProfile;
        pArgs->piniProfile = NULL;
    }

    if (pArgs->piniService)
    {
        delete pArgs->piniService;
        pArgs->piniService = NULL;
    }

    if (pArgs->piniBoth)
    {
        delete pArgs->piniBoth;
        pArgs->piniBoth = NULL;
    }

    if (pArgs->piniBothNonFav)
    {
        delete pArgs->piniBothNonFav;
        pArgs->piniBothNonFav = NULL;
    }
}    

//+----------------------------------------------------------------------------
//
// Function:  CreateIniObjects
//
// Synopsis:  Encapsulates creation of ini objects
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   LRESULT - Failure code
//
// History:   nickball    Created    2/12/98
//
//+----------------------------------------------------------------------------
LRESULT CreateIniObjects(ArgsStruct *pArgs)
{ 
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return ERROR_INVALID_PARAMETER;
    }

    LRESULT lRes = ERROR_SUCCESS;

    //
    // Try to create each ini object
    //
    
    pArgs->piniProfile = new CIni; // &iniProfile;

    if (NULL == pArgs->piniProfile)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    pArgs->piniService = new CIni; // &iniService;

    if (NULL == pArgs->piniService)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    pArgs->piniBoth = new CIni; // &iniBoth;

    if (NULL == pArgs->piniBoth)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    pArgs->piniBothNonFav = new CIni; //&iniBothNonFav

    if (NULL == pArgs->piniBothNonFav)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    //
    // If something failed, release CIni classes
    //

    if (ERROR_SUCCESS != lRes)
    {
        if (pArgs->piniProfile)
        {
            delete pArgs->piniProfile;
        }

        if (pArgs->piniService)
        {
            delete pArgs->piniService;
        }

        if (pArgs->piniBoth)
        {
            delete pArgs->piniBoth;
        }

        if (pArgs->piniBothNonFav)
        {
            delete pArgs->piniBothNonFav;
        }
    }

    return lRes;
}

//+----------------------------------------------------------------------------
//
// Function:  InitProfile
//
// Synopsis:  Initialize the profile based upon the entry name.  
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct           
//            LPCTSTR  pszEntry - Ptr to name of Ras entry
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT InitProfile(ArgsStruct *pArgs, LPCTSTR pszEntry)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEntry);
    
    if (NULL == pArgs || NULL == pszEntry)
    {
        return E_POINTER;
    }
    
    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    HRESULT hrRes = S_OK;

    LPTSTR pszProfileName = (LPTSTR) CmMalloc(sizeof(TCHAR) * (MAX_PATH + 1));

    if (pszProfileName)
    {
        if (FALSE == ReadMapping(pszEntry, pszProfileName, MAX_PATH, pArgs->fAllUser, TRUE)) // TRUE == bExpandEnvStrings
        {
            //
            // No mappings key, report failure
            //

            // Don't want to display UI when this is called from winlogon (FUS case - single user profile)
            if ((0 == (pArgs->dwFlags & FL_UNATTENDED)) && (FALSE == IsLogonAsSystem()))
            {
                LPTSTR pszTmp = CmFmtMsg(g_hInst,IDMSG_DAMAGED_PROFILE);
                MessageBoxEx(NULL, pszTmp, pszEntry, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);
                CmFree(pszTmp);
            }

            hrRes = E_FAIL;
        }
        else
        {
            MYDBGASSERT(!(*pArgs->piniProfile->GetFile())); // can't have a profile yet
            //
            // Migration code is called here because this is the first place where 
            // we get the path to the cmp. The migration code moves the cmp entries 
            // to the registry and then replaces the cmp file
            //
            
            /*
            //
            // This was commented out because it created some issues when trying to import old
            // profiles. It migrated some values into the wrong sections of the registry.
            //
            // MoveCmpEntriesToReg(pszEntry, pszProfileName, pArgs->fAllUser);
            //
            */
            
            hrRes = InitProfileFromName(pArgs, pszProfileName);

            // Don't want to display UI when this is called from winlogon (FUS case - single user profile)
            if (FAILED(hrRes) && (FALSE == IsLogonAsSystem()))
            {
                LPTSTR pszTmp = CmFmtMsg(g_hInst,IDMSG_DAMAGED_PROFILE);
                MessageBoxEx(NULL, pszTmp, pszEntry, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);
                CmFree(pszTmp);
            }
        }
    }
    else
    {
        hrRes = E_OUTOFMEMORY;
        CMASSERTMSG(FALSE, TEXT("InitProfile -- Unable to allocate memory for the profile name."));
    }

    CmFree(pszProfileName);
    
    return hrRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitProfileFromName
//
//  Synopsis:   Helper function to intialize the service 
//              profile based upon a service name
//
//  Arguments:  ArgsStruct *pArgs - Pointer to global args struct
//              LPCTSTR pszArg     - Full path to .CMP file
//
//  Returns:    HRESULT 
//
//  History:    a-nichb - Created - 4/22/97
//----------------------------------------------------------------------------

HRESULT InitProfileFromName(ArgsStruct *pArgs, 
                            LPCTSTR pszArg)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszArg);
    HRESULT hr = S_OK;

    LPTSTR pszFullServiceName = NULL;
    LPTSTR pszService = NULL;

    if (NULL == pArgs || NULL == pszArg)
    {
        return E_INVALIDARG;
    }

    //
    // Clear INI objects to make sure there are no misunderstandings about
    // there viability should we be forced to make an early return.
    //

    pArgs->piniProfile->Clear();
    pArgs->piniService->Clear();
    pArgs->piniBoth->Clear();
    pArgs->piniBothNonFav->Clear();

    //
    // Verify the existence of the file 
    //

    if (FALSE == FileExists(pszArg)) 
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    //
    // Initialize the profile INI object with the filename
    //
    
    pArgs->piniProfile->SetHInst(g_hInst);
    pArgs->piniProfile->SetFile(pszArg);

    //
    // Check the service name
    //

    pszService = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryCmsFile);

    if (pszService && *pszService)        
    {
        //
        // We have a service file, build the full path to the file
        //

        pszFullServiceName = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszService);

        if (pszFullServiceName)
        {
            MYDBGASSERT(*pszFullServiceName); // should be something there

            if (FALSE == FileExists(pszFullServiceName))
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                goto done;
            }

            pArgs->piniService->SetHInst(pArgs->piniProfile->GetHInst());
            pArgs->piniService->SetFile(pszFullServiceName);

            //
            // Get the service name, we use this throughout
            //

            LPTSTR pszTmp = GetServiceName(pArgs->piniService);
                
            MYDBGASSERT(pszTmp && *pszTmp);

            if (pszTmp)
            {
                lstrcpyU(pArgs->szServiceName, pszTmp);
            }

            CmFree(pszTmp);

            //
            // Both: The .CMP file takes precedence over the .CMS 
            // file, so specify the .CMP file as the primary file
            //

            pArgs->piniBoth->SetHInst(pArgs->piniProfile->GetHInst());
            pArgs->piniBoth->SetFile(pArgs->piniService->GetFile());
            pArgs->piniBoth->SetPrimaryFile(pArgs->piniProfile->GetFile());

            pArgs->piniBothNonFav->SetHInst(pArgs->piniProfile->GetHInst());
            pArgs->piniBothNonFav->SetFile(pArgs->piniService->GetFile());
            pArgs->piniBothNonFav->SetPrimaryFile(pArgs->piniProfile->GetFile());

            //
            // Get whether balloon tips are enabled
            //
            pArgs->fHideBalloonTips = pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryDisableBalloonTips);

            //
            // Get the values of the current access point and a flag to say if
            // access points are enabled
            //
            PVOID pv = &pArgs->fAccessPointsEnabled;
            if ((ReadUserInfoFromReg(pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID*)&pv)) && (pArgs->fAccessPointsEnabled))
            {
                LPTSTR pszCurrentAccessPoint = NULL;
                ReadUserInfoFromReg(pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID*)&pszCurrentAccessPoint);
                if (pszCurrentAccessPoint)
                {
                    pArgs->pszCurrentAccessPoint = CmStrCpyAlloc(pszCurrentAccessPoint);
                    CmFree(pszCurrentAccessPoint);
                }
                else
                {
                    pArgs->fAccessPointsEnabled = FALSE;
                    pArgs->pszCurrentAccessPoint = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);
                }
            }
            else
            {
                pArgs->pszCurrentAccessPoint = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);
            }

            //
            // piniProfile, piniBoth, and piniBothNonFav all access the cmp and reg, set the reg path by default
            // to the one with the current access point except the piniBothNonFav which uses the base favorites
            // registry path.
            //

            //
            // Okay, here is how this all works ...
            // CIni classes have a reg path, a primary reg path, a file path, and a primary file path.
            // The reg path and the file path are checked first (the registry is accessed and if empty, then the file is checked), and
            // then the primary reg path and the primary file path are checked (again the registry is checked first and if the
            // setting doesn't exist then it checks the file).  This allows settings in the primary file/reg to override settings in the
            // file/reg.  This allows us to have cmp settings override settings in the cms by accessing the cms settings first and
            // then overwriting the setting with the value from the cmp if it exists or keeping the cms setting if the cmp is empty.
            //
            // The four CIni objects break out like this:
            // piniProfile -    reg = current favorite reg path
            //                  file = cmp file
            //                  primary reg = (nothing)
            //                  primary file = (nothing)
            //                  For direct access to the cmp settings.
            //
            // piniService -    reg = none (cms settings not in the registry).
            //                  file = cms file
            //                  primary reg = (nothing)
            //                  primary file = (nothing)
            //                  For direct access to the cms settings.
            //
            // piniBoth -       reg = none (cms settings not in the registry)
            //                  file = cms file
            //                  primary reg = current favorite reg path
            //                  primary file = cmp file
            //                  For access to any settings that can be overridden from the "cmp" and are favorites enabled (phone number
            //                  settings, which device to use, etc).
            //
            // piniBothNonFav - reg = non-favorite registry path (Software\Microsoft\Connection Manager\UserInfo\<LongService>)
            //                  file = cms file
            //                  primary reg = non-favorite registry path (Software\Microsoft\Connection Manager\UserInfo\<LongService>)
            //                  primary file = cmp file
            //                  For access to any settings that can be overridden from the "cmp" and are NOT favorites enabled
            //                  (tunnel settings, idle disconnect, logging enabled, etc.)
            //                  NOTE that the reg path and the primary reg path are the same.  That is because on writing on the
            //                  regpath value is used and I only wanted one ini object to handle non favorites settings instead of two.
            //

            LPTSTR pszRegPath = FormRegPathFromAccessPoint(pArgs);
            pArgs->piniProfile->SetRegPath(pszRegPath);
            pArgs->piniBoth->SetPrimaryRegPath(pszRegPath);
            CmFree(pszRegPath);

            pszRegPath = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
            MYDBGASSERT(pszRegPath);
            pArgs->piniBothNonFav->SetPrimaryRegPath(pszRegPath); // For reads
            pArgs->piniBothNonFav->SetRegPath(pszRegPath); // For writes
            CmFree(pszRegPath);

            hr = S_OK;
        }
    }
    
done:

    CmFree(pszFullServiceName);
    CmFree(pszService);

    return hr;
}           


//+----------------------------------------------------------------------------
//
// Function:  GetEntryFromCmp
//
// Synopsis:  Helper function to read a value from the cmp
//
// Arguments: LPTSTR pszSectionName - The section to be accessed
//            LPTSTR pszCmpPath - The complete path to the cmp
//            LPTSTR pszEntryName - The entry to be accessed in the cmp
//
// Returns:   PVOID - Pointer to the result of cmp access
//
// History:   t-urama   Created Header  07/11/00
//
//+----------------------------------------------------------------------------
LPTSTR GetEntryFromCmp(const TCHAR *pszSectionName, LPTSTR pszEntryName, LPCTSTR pszCmpPath)
{
    BOOL bExitLoop = TRUE;
    DWORD dwSize = (MAX_PATH + 1);
    LPTSTR pszEntryBuffer = NULL;
    DWORD dwRet;
    LPCTSTR c_pszDefault = TEXT("");
    do
    {
        pszEntryBuffer = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));
        if (pszEntryBuffer)
        {
            dwRet = GetPrivateProfileStringU(pszSectionName, pszEntryName, c_pszDefault, pszEntryBuffer, dwSize, pszCmpPath);
            if (dwRet)
            {   
                if (dwRet > dwSize)
                {
                    dwSize = dwRet + 1;
                    bExitLoop = FALSE;  //  we didn't get all of the string, try again
                    free(pszEntryBuffer);
                }
            }
            else
            {
                CmFree(pszEntryBuffer);
                return NULL;
            }

        }
        else
        {
            CmFree(pszEntryBuffer);
            return NULL;
        }
    } while (!bExitLoop);

    return pszEntryBuffer;
}

//+----------------------------------------------------------------------------
//
// Function:  ReplaceCmpFile
//
// Synopsis:  Helper function to delete the existing cmp and replace it with 
//            one which has entries for Version and CMSFile
//
// Arguments: LPTSTR pszCmpPath - The complete path to the cmp
//
// Returns:   None
//
// History:   t-urama   Created Header  07/11/00
//
//+----------------------------------------------------------------------------
void ReplaceCmpFile(LPCTSTR pszCmpPath)
{
    LPTSTR pszCMSFileEntry = (LPTSTR) GetEntryFromCmp(c_pszCmSection, (LPTSTR) c_pszCmEntryCmsFile, pszCmpPath);

    if (NULL != pszCMSFileEntry && *pszCMSFileEntry)
    {
        //
        //  Clear the CM section
        //
        WritePrivateProfileStringU(c_pszCmSection, NULL, NULL, pszCmpPath);

        //
        //  Now write back the cms file entry
        //
        WritePrivateProfileStringU(c_pszCmSection, c_pszCmEntryCmsFile, pszCMSFileEntry, pszCmpPath);
    }

    CmFree(pszCMSFileEntry);
}   

//+----------------------------------------------------------------------------
//
// Function:  FormRegPathFromAccessPoint
//
// Synopsis:  Function to create a path to the current access point in the registry
//
// Arguments: ArgsStruct *pArgs - ptr to global args structure
//
// Returns:   LPTSTR - The path to the access point. It is the caller's responsibility to free this
//
// History:   t-urama   Created Header  07/11/00
//
//+----------------------------------------------------------------------------
LPTSTR FormRegPathFromAccessPoint(ArgsStruct *pArgs)
{
    LPTSTR pszRegPath = NULL;
    
    pszRegPath = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
    MYDBGASSERT(pszRegPath);
    if (NULL == pszRegPath)
    {
        return NULL;
    }

    CmStrCatAlloc(&pszRegPath, TEXT("\\"));
    CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);
    CmStrCatAlloc(&pszRegPath, TEXT("\\"));

    CmStrCatAlloc(&pszRegPath, pArgs->pszCurrentAccessPoint);

    return pszRegPath;
}



//+----------------------------------------------------------------------------
//
// Function:  InitArgsForConnect
//
// Synopsis:  Encapsulates initialization of pArgs members necessary to begin dial
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPCTSTR pszRasPhoneBook - RAS phonebook containing entry
//            LPCMDIALINFO lpCmInfo - Ptr to dial info for this dial attempt
//            BOOL fAllUser - The All User attribute of the profile
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created Header    02/09/98
//            nickball    pszRasPhoneBook   08/14/98
//
//+----------------------------------------------------------------------------
HRESULT InitArgsForConnect(ArgsStruct *pArgs, 
                           LPCTSTR pszRasPhoneBook,
                           LPCMDIALINFO lpCmInfo,
                           BOOL fAllUser)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return E_POINTER;
    }

    //
    // Get the flags first
    //

    pArgs->dwFlags = lpCmInfo->dwCmFlags;

    // 
    // Get the RAS phonebook for the entry, and set user mode accordngly
    //

    if (pszRasPhoneBook && *pszRasPhoneBook)
    {
        pArgs->pszRasPbk = CmStrCpyAlloc(pszRasPhoneBook);
    }

    pArgs->fAllUser = fAllUser;
  
    // 
    // Initialize pArgs->tlsTapiLink.dwOldTapiLocation to -1
    //
    pArgs->tlsTapiLink.dwOldTapiLocation = -1;

    //
    // Create stats class 
    //

    if (!OS_NT4)
    {
        pArgs->pConnStatistics = new CConnStatistics();

        if (NULL == pArgs->pConnStatistics)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (OS_W9X)
    {
        pArgs->uLanaMsgId = RegisterWindowMessageU(TEXT("ConnectionManagerLanaMsg"));
        CMTRACE1(TEXT("InitArgsForConnect() RegisterWindowMessage(\"ConnectionManagerLanaMsg\") uLanaMsgId is %d"), pArgs->uLanaMsgId);
    }
    
    if (!OS_NT5) 
    {
        //
        // Register Window Messages
        //

        pArgs->uMsgId = RegisterWindowMessageU(TEXT(RASDIALEVENT));
        if (!pArgs->uMsgId) 
        {
            CMTRACE1(TEXT("InitArgsForConnect() RegisterWindowMessage(\"InternetConnectionManager\") failed, GLE=%u."), GetLastError());
            pArgs->uMsgId = WM_RASDIALEVENT;
        }
    }

    pArgs->fChangedPassword = FALSE;
    pArgs->fChangedInetPassword = FALSE;
    pArgs->fWaitingForCallback = FALSE;
    
    //
    // Create new CIni classes, and set initial exit code
    //

    pArgs->dwExitCode = (DWORD)CreateIniObjects(pArgs);

    return HRESULT_FROM_WIN32(pArgs->dwExitCode);
}

//+----------------------------------------------------------------------------
//
// Function:  InitCredentials
//
// Synopsis:  Transfers credentials from either WinLogon or Reconnect
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct.
//            LPCMDIALINFO lpCmInfo - Ptr to CmInfo struct.
//            DWORD dwFlags - Flags from RasDialDlg, if any.
//            PVOID pvLogonBlob - Ptr to WinLogon blob, if any.
//            
//
// Returns:   Nothing
//
// History:   nickball    Created    09/21/99
//
//+----------------------------------------------------------------------------
HRESULT InitCredentials(ArgsStruct *pArgs, 
                        LPCMDIALINFO lpCmInfo, 
                        DWORD dwFlags,
                        PVOID pvLogonBlob)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pArgs->piniService);

    if (NULL == pArgs || NULL == pArgs->piniService)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Need to initialize this instance. The constructor of this class doesn't get called,
    // because it's part of pArgs memory block and the instance isn't created using new.
    //
    pArgs->SecurePW.Init();
    pArgs->SecureInetPW.Init();

    //
    // Get credential display flags as they can dictate how we manage creds
    //

    pArgs->fHideUserName = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideUserName);            
    pArgs->fHidePassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHidePassword);            

    //
    // If its a non-tunneling profile, the domain display default is false.
    //

    pArgs->fHideDomain = pArgs->piniService->GPPB(c_pszCmSection, 
                                                  c_pszCmEntryHideDomain, 
                                                  !IsTunnelEnabled(pArgs));   
    //
    // Handle special credential scenarios such as reconnect or WinLogon
    // (note that pvLogonBlob can be NULL if the user did a ctrl-alt-del
    // and typed a password but then used an EAP profile to connect.)
    //

    if ((OS_NT5 && !OS_NT51 && pvLogonBlob) || (OS_NT51 && (dwFlags & RCD_Logon)))
    {                     
        CMTRACE(TEXT("InitCredentials - we have been called from Winlogon"));
    
        //
        // Set the type of logon. Assert if we aren't logged on as system
        //
        pArgs->dwWinLogonType = CM_LOGON_TYPE_WINLOGON;
        MYDBGASSERT(IsLogonAsSystem());

        //
        // First make sure that integration is not explicitly disabled
        //
        if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseWinLogonCredentials, TRUE))
        {        
            if (pvLogonBlob)
            {
                if (dwFlags & RCD_Eap) 
                {            
                    pArgs->lpEapLogonInfo = (PEAPLOGONINFO) pvLogonBlob;                
                }
                else 
                {
                    //
                    // We have a RASNOUSER struct to play with. 
                    // FYI: If the dwFlags member is set with RASNOUSER_SmartCard
                    // then the user initiated a logon with a SmartCard, but then 
                    // chose a connection that was not configured for EAP. RAS 
                    // handles that situation by setting the flag and passing an
                    // empty RASNOUSER struct. The flag is currently unused by CM.
                    //

                    pArgs->lpRasNoUser = (LPRASNOUSER) pvLogonBlob;   

                    MYDBGASSERT(sizeof(RASNOUSER) == pArgs->lpRasNoUser->dwSize);
                    CMTRACE1(TEXT("InitCredentials - pArgs->lpRasNoUser->dwFlags is 0x%x"), pArgs->lpRasNoUser->dwFlags);
                }
            }
            // else here is the ctrl-alt-del case with an EAP profile
        }
        else
        {
            CMTRACE1(TEXT("InitCredentials - pvLogonBlob ignored because %s=0"), c_pszCmEntryUseWinLogonCredentials);

            // 
            // We still need to wipe the password in case RASNOUSER structure is being used and is not needed
            // Lets wipe the password in the passed in RASNOUSER structure
            // RasCustomDialDlg actually kept an encrypted copy of this password
            // so before CM exits we can restore the original memory, because it's not ours.
            //
            if (pvLogonBlob)
            {
                if (0 == (dwFlags & RCD_Eap))
                {
                    CmWipePassword(((LPRASNOUSER)pvLogonBlob)->szPassword);
                }
            }
        }
    }
    else
    {
        if (IsLogonAsSystem() && OS_NT51)
        {
            //
            // ICS case where a user isn't logged it
            //
            pArgs->dwWinLogonType = CM_LOGON_TYPE_ICS;
        }
        else
        {
            //
            // User is logged in
            //
            pArgs->dwWinLogonType = CM_LOGON_TYPE_USER;
        }
    }

    if (pArgs->dwFlags & FL_RECONNECT)
    {         
        //
        // CM doesn't support the automatic reconnect case. This is because
        // CM used to hold credentials in memory throughout the connection. In addition
        // the password wasn't begin stored securely.
        //
    }
    else
    {
        if (pArgs->lpRasNoUser)
        {
            //
            // Filter credential integration.

            if (!pArgs->fHideUserName)            
            {
                lstrcpyU(pArgs->szUserName, pArgs->lpRasNoUser->szUserName);
            }

            if (!pArgs->fHidePassword)           
            {
                CmDecodePassword(pArgs->lpRasNoUser->szPassword); // password is already encoded from RasCustomDialDlg
                
                (VOID)pArgs->SecurePW.SetPassword(pArgs->lpRasNoUser->szPassword);
            }

            //
            // Lets wipe the password in the passed in RASNOUSER structure
            // RasCustomDialDlg actually kept an encrypted copy of this password
            // so before CM exits we can restore the original memory, because it's not ours.
            //
            CmWipePassword(pArgs->lpRasNoUser->szPassword);

            if (!pArgs->fHideDomain)            
            {
                lstrcpyU(pArgs->szDomain, pArgs->lpRasNoUser->szDomain);
            }

            CMTRACE1(TEXT("InitCredentials: pArgs->szUserName is %s"), pArgs->szUserName);
            CMTRACE1(TEXT("InitCredentials: pArgs->szDomain is %s"), pArgs->szDomain);
        }    
    }

    CMTRACE1(TEXT("InitCredentials: pArgs->dwWinLogonType is %d"), pArgs->dwWinLogonType);
    // 
    // This is to setup (global or user) credential support. Since 
    // RAS dll isn't loaded, we don't get the credentials yet so 
    // in LoadProperties we actually get to see which creds exist.
    //
    if (FALSE == InitializeCredentialSupport(pArgs))
    {
        return S_FALSE;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  InitArgsForDisconnect
//
// Synopsis:  Encapsulates initialization of pArgs members necessary to hangup
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            BOOL fAllUser - All User flag
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created Header    02/11/98
//            nickball    pszRasPhoneBook   08/14/98
//            nickball    fAllUser          10/28/98
//
//+----------------------------------------------------------------------------
HRESULT InitArgsForDisconnect(ArgsStruct *pArgs,
                              BOOL fAllUser)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return E_POINTER;
    }
    
    //
    // Set the All User attribute of the profile
    //

    pArgs->fAllUser = fAllUser;
    
    //
    // Create new CIni classes, and set initial exit code
    //

    pArgs->dwExitCode = (DWORD)CreateIniObjects(pArgs);

    return HRESULT_FROM_WIN32(pArgs->dwExitCode);
}


//+----------------------------------------------------------------------------
//
// Function:  InitLogging
//
// Synopsis:  Initialize the logging functionality for this profile.  
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct           
//            LPCTSTR  pszEntry - Ptr to name of Ras entry
//            BOOL     fBanner  - do we want a banner for this?
//
// Returns:   HRESULT - Failure code.
//
// History:   20-Jul-2000   SumitC      Created
//
//+----------------------------------------------------------------------------
HRESULT InitLogging(ArgsStruct *pArgs, LPCTSTR pszEntry, BOOL fBanner)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEntry);

    BOOL fEnabled           = FALSE;
    DWORD dwMaxSize         = 0;
    LPTSTR pszFileDir       = NULL;
    LPTSTR pszRegPath       = NULL;
    LPTSTR pszTempRegPath   = NULL;

    //
    //  Check the params
    //

    if (NULL == pArgs || NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  Initialize the logging object (the order is important)
    //
    hr = pArgs->Log.Init(g_hInst, pArgs->fAllUser, pArgs->szServiceName);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    //
    // Accessing EnableLogging, make sure to use piniBothNonFav as this setting is
    // not favorites enabled.
    //
    fEnabled = pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryEnableLogging, c_fEnableLogging);

    //
    //  Now get the Max log file size and the log file directory.
    //
    dwMaxSize   = pArgs->piniService->GPPI(c_pszCmSectionLogging, c_pszCmEntryMaxLogFileSize, c_dwMaxFileSize);
    pszFileDir  = pArgs->piniService->GPPS(c_pszCmSectionLogging, c_pszCmEntryLogFileDirectory, c_szLogFileDirectory);

    hr = pArgs->Log.SetParams(fEnabled, dwMaxSize, pszFileDir);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    if (pArgs->Log.IsEnabled())
    {
        hr = pArgs->Log.Start(fBanner);
        if (S_OK != hr)
        {
            CMTRACE(TEXT("cmdial32 InitLogging - failed to start log, no logging for this connectoid"));
            goto Cleanup;
        }
    }

    CMASSERTMSG(S_OK == hr, TEXT("cmdial32 InitLogging - at end"));

Cleanup:

    CmFree(pszFileDir);

    CMTRACEHR("InitLogging", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\makefile.inc ===
$(O)\cmdial32.def: cmdial32.src
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Mutex class implementation.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\lanawait.h ===
//+----------------------------------------------------------------------------
//
// File:     lanawait.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Definitions for the workaround to make CM wait for DUN to 
//           register its LANA for an internet connection before beginning 
//           the tunnel portion of a double dial connection.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------
#ifdef  LANA_WAIT
#ifndef _LANAWAIT_H_ 
#define _LANAWAIT_H_ 

#include <dbt.h>

//----------------------------------------------------------------------

#define ICM_REG_LANAWAIT            TEXT("Lana")
#define LANAWAIT_CLASSNAME          TEXT("CmLana")
#define LANAWAIT_WNDNAME            TEXT("CmLanaWnd")

#define LANA_TIMEOUT_DEFAULT        20          // 20 secs
#define LANA_PROPAGATE_TIME_DEFAULT 3           // 3 secs
#define LANA_TIME_ID                2233

//----------------------------------------------------------------------

LRESULT APIENTRY LanaWaitWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

BOOL IsLanaWaitEnabled();

#endif // _LANAWAIT_H_
#endif // LANA_WAIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\modaldlgclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     modaldlgclass.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Modal Dialog Class implementation.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created    10/05/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//	Please see pnpu\common\source for the actual source here.
//

#include "modaldlg.h"
#include "modaldlg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\pwfuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwfuncs.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This source file pound includes the password utility functions, 
//           see common\source\pwutil.cpp for specifics.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   nickball   created         08/04/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//	Please see pnpu\cm\common\source for the actual source here.
//

#include "pwutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\ntlsa.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ntlsa.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the functions to allow Connection Manager to
//           interact with the NT LSA security system.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt     created	        02/23/98
//           quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------
#include	"cmmaster.h"

///////////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////////

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

#define InitializeLsaObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( LSA_OBJECT_ATTRIBUTES );       \
    (p)->RootDirectory = r;                              \
    (p)->Attributes = a;                                 \
    (p)->ObjectName = n;                                 \
    (p)->SecurityDescriptor = s;                         \
    (p)->SecurityQualityOfService = NULL;                \
    }


///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
// func prototypes
///////////////////////////////////////////////////////////////////////////////////

void InitLsaString(
    PLSA_UNICODE_STRING pLsaString,
    LPWSTR              pszString
);


///////////////////////////////////////////////////////////////////////////////////
// globals
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//	Function:	LSA_ReadString
//
//	Synopsis:	Read a string from the NT Local Security Authority (LSA) 
//				store.
//
//	Arguments:	pszKey          The key to identify the string.
//              pszStr          The buffer in which the string is to be
//                              written to.
//              dwStrLen        The length of the string buffer in bytes.
//
//	Returns:	DWORD   0 for SUCCES
//                      GetLastError() for FAILURE
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

DWORD LSA_ReadString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPTSTR      pszStr,
    DWORD       dwStrLen
)
{
    DWORD                   dwErr;
    LSA_OBJECT_ATTRIBUTES   oaObjAttr;
    LSA_HANDLE              hPolicy = NULL;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    LSA_UNICODE_STRING      unicodeKey;
    PLSA_UNICODE_STRING     punicodeValue = NULL;

#if !defined(_UNICODE) && !defined(UNICODE)
    LPWSTR                  pszUnicodeKey = NULL;
#endif
    
    if (!pszKey || !pszStr)
    {
        CMASSERTMSG(FALSE, TEXT("LSA_ReadString -- Invalid Parameter passed."));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the LSA secret space for writing.
    //
    InitializeLsaObjectAttributes(&oaObjAttr, NULL, 0L, NULL, NULL);
    ntStatus = pArgs->llsLsaLink.pfnOpenPolicy(NULL, &oaObjAttr, POLICY_READ, &hPolicy);

    if (ntStatus == STATUS_SUCCESS)
    {

#if !defined(_UNICODE) && !defined(UNICODE)

        //
        // need to convert the ANSI key to unicode
        //

        if (!(pszUnicodeKey = (LPWSTR)CmMalloc((lstrlenA(pszKey)+1)*sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!MultiByteToWideChar(CP_ACP, 0, pszKey, -1, pszUnicodeKey, (lstrlenA(pszKey)+1)*sizeof(WCHAR)))
        {
            CmFree(pszUnicodeKey);
            dwErr = ERROR_INVALID_DATA;
            goto exit;
        }
        
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszUnicodeKey);
        CmFree(pszUnicodeKey);
#else
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszKey);
#endif
        //
        // get it
        //
        ntStatus = pArgs->llsLsaLink.pfnRetrievePrivateData(hPolicy, &unicodeKey, &punicodeValue);        
    }

    if (ntStatus != STATUS_SUCCESS) 
    {
        dwErr = pArgs->llsLsaLink.pfnNtStatusToWinError(ntStatus);

#ifdef DEBUG        
        if (ERROR_SUCCESS != dwErr)
        {
            if (ERROR_FILE_NOT_FOUND == dwErr)
            {
                CMTRACE(TEXT("LSA_ReadPassword() NT password not found."));
            }
            else
            {
                CMTRACE1(TEXT("LSA_ReadPassword() NT failed, err=%u"), dwErr);
            }
        }
#endif

    }
    else
    {   
        if (dwStrLen < punicodeValue->Length)
        {
            dwErr = ERROR_BUFFER_OVERFLOW;
            goto exit;
        }

#if !defined(_UNICODE) && !defined(UNICODE)

        if (!WideCharToMultiByte(CP_ACP, 0, punicodeValue->Buffer, -1, 
                                 pszStr, dwStrLen, NULL, NULL))
        {
            dwErr = ERROR_INVALID_DATA;
            goto exit;
        }

#else
        
        CopyMemory((PVOID)pszStr, (CONST PVOID)punicodeValue->Buffer, punicodeValue->Length);

#endif
        
        dwErr = 0;
    }

exit:

    if (punicodeValue)
    {
        pArgs->llsLsaLink.pfnFreeMemory(punicodeValue);
    }

    if (hPolicy)
    {
        pArgs->llsLsaLink.pfnClose(hPolicy);
    }

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//	Function:	LSA_WriteString
//
//	Synopsis:	Write a string to the NT Local Security Authority (LSA) 
//				store.
//
//	Arguments:	pszKey          The key to identify the string.
//              pszStr          The string.  This function deletes the
//                              string if this param is NULL.
//
//	Returns:	DWORD   0 for SUCCES
//                      GetLastError() for FAILURE
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

DWORD LSA_WriteString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPCTSTR     pszStr
)
{
    DWORD                   dwErr = 0;
    LSA_OBJECT_ATTRIBUTES   oaObjAttr;
    LSA_HANDLE              hPolicy = NULL;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    LSA_UNICODE_STRING      unicodeKey;
    LSA_UNICODE_STRING     unicodeValue;
#if !defined(_UNICODE) && !defined(UNICODE)
    LPWSTR  pszUnicodeKey = NULL;
    LPWSTR  pszUnicodePassword = NULL;
#endif
    
    if (!pszKey)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the LSA secret space for writing.
    //
    InitializeLsaObjectAttributes(&oaObjAttr, NULL, 0L, NULL, NULL);
    ntStatus = pArgs->llsLsaLink.pfnOpenPolicy(NULL, &oaObjAttr, POLICY_WRITE, &hPolicy);
    if (ntStatus == STATUS_SUCCESS)
    {

#if !defined(_UNICODE) && !defined(UNICODE)

        //
        // need to convert the ANSI key to unicode
        //

        if (!(pszUnicodeKey = (LPWSTR)CmMalloc((lstrlenA(pszKey)+1)*sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        if (!MultiByteToWideChar(CP_ACP, 0, pszKey, -1, pszUnicodeKey, (lstrlenA(pszKey)+1)*sizeof(WCHAR)))
        {
            dwErr = ERROR_INVALID_DATA;
            goto exit;
        }

        if (pszStr)
        {
            if (!(pszUnicodePassword = (LPWSTR)CmMalloc((lstrlenA(pszStr)+1)*sizeof(WCHAR))))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
            if (!MultiByteToWideChar(CP_ACP, 0, pszStr, -1, pszUnicodePassword, (lstrlenA(pszStr)+1)*sizeof(WCHAR)))
            {
                dwErr = ERROR_INVALID_DATA;
                goto exit;
            }
        }
        
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszUnicodeKey);

        if (pszStr)
        {
            //
            // set the data
            //
            unicodeValue.Length = (lstrlenU(pszUnicodePassword)+1)*sizeof(WCHAR);
            unicodeValue.Buffer = (PWSTR)pszUnicodePassword;
        }

#else
        
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszKey);

        if (pszStr)
        {
            //
            // set the data
            //
            unicodeValue.Length = (lstrlenU(pszStr)+1)*sizeof(TCHAR);
            unicodeValue.Buffer = (PWSTR)pszStr;
        }

#endif

        //
        // save it
        //
        ntStatus = pArgs->llsLsaLink.pfnStorePrivateData(hPolicy, &unicodeKey, pszStr? &unicodeValue : NULL);
    }

    if (ntStatus != STATUS_SUCCESS) 
    {
        dwErr = pArgs->llsLsaLink.pfnNtStatusToWinError(ntStatus);

#ifdef DEBUG        
        if (ERROR_SUCCESS != dwErr)
        {
            if (ERROR_FILE_NOT_FOUND == dwErr)
            {
                CMTRACE(TEXT("LSA_WritePassword() NT password not found."));
            }
            else
            {
                CMTRACE1(TEXT("LSA_WritePassword() NT failed, err=%u"), dwErr);
            }
        }
#endif

    }

    if (hPolicy)
    {
        pArgs->llsLsaLink.pfnClose(hPolicy);
    }

#if !defined(_UNICODE) && !defined(UNICODE)

    if (pszUnicodeKey)
    {
        CmFree(pszUnicodeKey);
    }

    if (pszUnicodePassword)
    {
        CmFree(pszUnicodePassword);
    }

#endif

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//	Function:	InitLsaString
//
//	Synopsis:	Init a LSA string.
//
//	Arguments:	pLsaString      A LSA unicode string.
//              pszString       An unicode string.
//
//	Returns:	None
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

void InitLsaString(
    PLSA_UNICODE_STRING pLsaString,
    LPWSTR              pszString
)
{
    DWORD dwStringLength;

    if (pszString == NULL) 
    {
        pLsaString->Buffer = NULL;
        pLsaString->Length = 0;
        pLsaString->MaximumLength = 0;
        return;
    }

    dwStringLength = lstrlenU(pszString);
    pLsaString->Buffer = pszString;
    pLsaString->Length = (USHORT) dwStringLength * sizeof(WCHAR);
    pLsaString->MaximumLength=(USHORT)(dwStringLength+1) * sizeof(WCHAR);
}




//+---------------------------------------------------------------------------
//
//	Function:	InitLsa
//
//	Synopsis:	Basically does GetProcAddress()'s for all the LSA API's that
//              we need since these API's don't exist in the Windows95 version
//              of advapi32.dll.
//
//	Arguments:	NONE
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

BOOL InitLsa(
    ArgsStruct  *pArgs
) 
{
    LPCSTR apszLsa[] = {
        "LsaOpenPolicy",
        "LsaRetrievePrivateData",
        "LsaStorePrivateData",
        "LsaNtStatusToWinError",
        "LsaClose",
        "LsaFreeMemory",
        NULL
    };

	MYDBGASSERT(sizeof(pArgs->llsLsaLink.apvPfnLsa)/sizeof(pArgs->llsLsaLink.apvPfnLsa[0]) == 
                sizeof(apszLsa)/sizeof(apszLsa[0]));

    ZeroMemory(&pArgs->llsLsaLink, sizeof(pArgs->llsLsaLink));

	return (LinkToDll(&pArgs->llsLsaLink.hInstLsa, 
                      "advapi32.dll",
                      apszLsa,
                      pArgs->llsLsaLink.apvPfnLsa));
}


//+---------------------------------------------------------------------------
//
//	Function:	DeInitLsa
//
//	Synopsis:	The reverse of InitLsa().
//
//	Arguments:	NONE
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

BOOL DeInitLsa(
    ArgsStruct  *pArgs
) 
{
	if (pArgs->llsLsaLink.hInstLsa) 
	{
		FreeLibrary(pArgs->llsLsaLink.hInstLsa);
	}

    ZeroMemory(&pArgs->llsLsaLink, sizeof(pArgs->llsLsaLink));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The main module implementing interfaces to external (RAS, 
//           InetDialHandler and internal modules (CmCustomDialDlg).
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   Dondu      Created    96'
//
// History: 
//              5/05/97     Modified    byao
//                                      added 'InetDialHandler()' for IE4
//              1/26/98     Modified    quintinb
//                                      Added RasCustomDialDlg, RasCustomEntryDlg,
//                                      RasCustomHangUp, and RasCustomDial stubs.
//              02/10/98    Modified    Heavily refvised for 1.2 architectural shift
//
//+----------------------------------------------------------------------------

#include <windows.h>

//#ifdef  WIN32_LEAN_AND_MEAN
//#include <shellapi.h>
//#endif

#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>

#include "cmmaster.h"
#include <wininet.h>
#include "cmtiming.h"
#include "DynamicLib.h"

#include "shelldll.cpp"

//
// Globals
//

HINSTANCE g_hInst;

const TCHAR* const c_pszCmmgrExe = TEXT("CMMGR32.EXE");
const TCHAR* const c_pszExplorerExe = TEXT("EXPLORER.EXE");
const TCHAR* const c_pszCmstpExe = TEXT("CMSTP.EXE");
const TCHAR* const c_pszRunDll32Exe = TEXT("RUNDLL32.EXE");
const TCHAR* const c_pszRasAutoUExe = TEXT("RASAUTOU.EXE");

const TCHAR* const c_pszConnectMutex = TEXT("Connection Manager Connect - "); // Root only

#define RASDDFLAG_Reserved1 0x10000000

//+---------------------------------------------------------------------------
//
//  struct CmRasDialDlg
//
//  Description: Append CM reconnect infor mation to the end of RASDIALDLG
//
//  History:    fengsun Created     11/14/97
//
//----------------------------------------------------------------------------
struct CmRasDialDlg
{
    RASDIALDLG RasDialDlgInfo;  
    struct CmRasDialDlg* pSelf; // point to itself, used to verify CmReConnect
    DWORD  dwSignature;         // verify CmReConnect
    CMDIALINFO CmInfo;          // Reconnect information

    enum {CM_RECONNECT_SIGNATURE = 0xC6687DB5};  // To verify dwSignature
};

//+----------------------------------------------------------------------------
//
// Function:  StripTunnelSuffixW
//
// Synopsis:  Determines if a connection name string contains a suffix of 
//            " (for advanced use only)" and removes it if found.
//
// Arguments: LPWSTR pszwConnectionName - The string (connectoid name).
//
// Returns:   Nothing
//
// History:   nickball      created     1/11/00
//
//+----------------------------------------------------------------------------
void StripTunnelSuffixW(LPWSTR pszwConnectionName)
{
    MYDBGASSERT(pszwConnectionName);

    if (NULL == pszwConnectionName)
    {
        return;
    }

    //
    // On 9X we have to resolve the tunnel connectoid name to the 
    // service name by removing " (for advanced use only)" if it.
    // exists. 
    //

    if (OS_W9X)
    {
        LPWSTR pszwSuffix = GetTunnelSuffix();

        //
        // Search for suffix and truncate as necessary.
        // Note: Assumes that the service name does not match our suffix.
        //

        if (pszwSuffix)
        {           
            LPWSTR pszwTmp = CmStrStrW(pszwConnectionName, pszwSuffix); 
           
            if (pszwTmp)
            {
                CMTRACE1(TEXT("StripTunnelSuffixW - found suffix of %s"), pszwTmp);
                *pszwTmp = L'\0';
                CMTRACE1(TEXT("StripTunnelSuffixW - long service name is %s"), pszwConnectionName);
            }
        }       

        CmFree(pszwSuffix);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  IsStringWithInBuffer
//
// Synopsis:  Verify whether a string go beyond the buffer.
//            
//
// Arguments: const TCHAR* pszStr - the string to be tested
//            DWORD dwSize - the size of the buffer
//
// Returns:   BOOL - TRUE if is
//
// History:   fengsun Created Header    5/22/98
//
//+----------------------------------------------------------------------------
BOOL IsStringWithInBuffer(const TCHAR* pszStr, DWORD dwSize)
{
    MYDBGASSERT(pszStr);

    //
    // Can not do strlen here.  If the data in pszStr is garbage
    // strlen can cause access voilation
    //
    for (DWORD i =0; i<dwSize; i++)
    {
        if (pszStr[i] == TEXT('\0'))
        {
            return TRUE;
        }
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  IsCmReconnectRequest
//
// Synopsis:  Check whether CM reconnect information is appended to RASDIALDLG
//
// Arguments: const RASDIALDLG* lpInfo - the structure to check
//
// Returns:   BOOL - TRUE if is
//
// History:   fengsun Created Header    5/22/98
//
//+----------------------------------------------------------------------------
BOOL IsCmReconnectRequest(const RASDIALDLG* lpInfo)
{
    MYDBGASSERT(lpInfo);

    if (NULL == lpInfo)
    {
        return FALSE;
    }

    CMTRACE1(TEXT("IsCmReconnectRequest - RASDIALDLG.dwFlags is 0x%x"), ((LPRASDIALDLG)lpInfo)->dwFlags);
    
    //
    // See its our reconnect case by examining the dwFlags of lpInfo
    //

    if (((LPRASDIALDLG)lpInfo)->dwFlags & RASDDFLAG_Reserved1)
    {
        //
        // Test whether we can read beyond RASDIALDLG to avoid access violation
        //

        if (!IsBadReadPtr(lpInfo, sizeof(CmRasDialDlg)) )
        {
            CmRasDialDlg* const pCmDlgInfo = (CmRasDialDlg* const)lpInfo;

            //
            // Test whether it has the flag we added
            //

            if (pCmDlgInfo->pSelf == pCmDlgInfo && 
                pCmDlgInfo->dwSignature == CmRasDialDlg::CM_RECONNECT_SIGNATURE)
            {
                //
                // Whether the reconnect information is valid
                //

                //
                // Does password seem ok?  Whether the password go beyond CmIndo.szPassword
                // We can not do strlen here.  If we have some garbage here, strlen can 
                // cauce access violation.
                //

                //
                // We no longer support reconnect due to security issues. The password is 
                // not being kept in memory any longer.
                //
            }
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CmReConnect
//
// Synopsis:  Used specificly for CMMON to call upon reconnect
//      This function is added to fix bug 169128: RasCustomHangup not called 
//          when hangup reconnected connection.
//      In order for RAS to call RasCustomHangup, we have to call RasDialDlg.
//      CMMON calls CmReConnect with reconnect information.  CmReconnect append 
//      CM specific information to the RASDIALDLG structure then calls RasDialDlg.
//      RasCustomHangup then figures out it is a reconnect request.
//
// Arguments: LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPCMDIALINFO lpCmInfo - The reconnect information
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C" 
BOOL CmReConnect(LPTSTR lpszPhonebook, 
    LPTSTR lpszEntry, 
    LPCMDIALINFO lpCmInfo)
{
    CMTRACE(TEXT("CmReconnect"));

    if (OS_NT5)
    {
        //
        // Call RasDialDlg for NT5
        //
        CmRasDialDlg CmDlgInfo;
        ZeroMemory(&CmDlgInfo, sizeof(CmDlgInfo));

        CmDlgInfo.RasDialDlgInfo.dwSize = sizeof(CmDlgInfo.RasDialDlgInfo);
        CmDlgInfo.RasDialDlgInfo.dwFlags = RASDDFLAG_Reserved1;
        CmDlgInfo.CmInfo = *lpCmInfo;
        CmDlgInfo.pSelf = &CmDlgInfo;
        CmDlgInfo.dwSignature = (DWORD)CmRasDialDlg::CM_RECONNECT_SIGNATURE;

        //
        // Load rasdlg.dll
        //

        CDynamicLibrary libRasDlg(TEXT("rasdlg.dll"));

        MYDBGASSERT(libRasDlg.IsLoaded());
        typedef BOOL (WINAPI* fnRasDialDlgTYPE)(
            LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPTSTR lpszPhoneNumber,
            LPRASDIALDLG lpInfo );

#ifndef UNICODE
        LPSTR pszRasDialDlgText = {"RasDialDlgA"};
#else
        LPSTR pszRasDialDlgText = {"RasDialDlgW"};
#endif

        fnRasDialDlgTYPE fnRasDialDlg = (fnRasDialDlgTYPE)libRasDlg.GetProcAddress(pszRasDialDlgText);
        if (fnRasDialDlg)
        {
            //
            // We base on the assumption that RasDialDlg passes the same pointer to RasCustomDialDlg.
            //
            if (lpszPhonebook != NULL && lpszPhonebook[0] == TEXT('\0'))
            {
                return fnRasDialDlg(NULL, lpszEntry, NULL, (RASDIALDLG*)&CmDlgInfo);
            }

            return fnRasDialDlg(lpszPhonebook, lpszEntry, NULL, (RASDIALDLG*)&CmDlgInfo);
        }

        return FALSE;
    }
    else
    {
        //
        // For non-NT5 platform, call CmCustomDialDlg directly
        //
        
        return CmCustomDialDlg(NULL,        // hwndParent
                               RCD_AllUsers, // dwFlags
                               lpszPhonebook, 
                               lpszEntry, 
                               NULL,       // lpszPhoneNumber
                               NULL,       // lpRasDialDlg,
                               NULL,       // lpRasEntryDlg,
                               lpCmInfo);

    }
}

//+----------------------------------------------------------------------------
//
// Function:  WhoIsCaller
//
// Synopsis:  Helper function to determine if we were called manually from the
//            desktop or programmatically.
//
// Arguments: dwCaller - which desktop caller.
//
// Returns:   BOOL - TRUE if the caller matches one of those specified in dwCaller.
//
// History:   nickball    Created Header    3/17/98
//
//+----------------------------------------------------------------------------
BOOL WhoIsCaller(DWORD dwCaller)
{
    BOOL bRet = FALSE;

    TCHAR szTmp[MAX_PATH + 1];
    ZeroMemory(szTmp, sizeof(szTmp));

    //
    // Get the path of the calling process
    //

    MYVERIFY(GetModuleFileNameU(GetModuleHandleA(NULL), szTmp, MAX_PATH));      

    CMTRACE1(TEXT("WhoIsCaller() - Calling process is %s"), szTmp);

    //
    // Locate the filename part
    //

    LPTSTR pszName = StripPath(szTmp);
       
    MYDBGASSERT(pszName);

    if (pszName)
    {
        //
        // Compare against CM and Shell
        //

        if (dwCaller & DT_CMMGR)
        {
            bRet = (lstrcmpiU(pszName, c_pszCmmgrExe) == 0);
        }

        if (!bRet && dwCaller & DT_CMMON)
        {
            bRet |= (lstrcmpiU(pszName, c_pszCmMonExeName) == 0);
        }

        if (!bRet && dwCaller & DT_EXPLORER)
        {
            bRet |= (lstrcmpiU(pszName, c_pszExplorerExe) == 0);
        }
        
        if (!bRet && dwCaller & DT_CMSTP)
        {
            bRet |= (lstrcmpiU(pszName, c_pszCmstpExe) == 0);
        }

        if (!bRet && dwCaller & DT_RUNDLL32)
        {
            bRet |= (lstrcmpiU(pszName, c_pszRunDll32Exe) == 0);
        }

        if (!bRet && dwCaller & DT_RASAUTOU)
        {
            bRet |= (lstrcmpiU(pszName, c_pszRasAutoUExe) == 0);
        }

        CmFree(pszName);
    }

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  HandleCustomConnectRequest
//
// Synopsis:  Attempts to resolve a connect request for the specified entry by
//            examining the current state if any of that connection.
//
// Arguments: HWND hwndParent               - HWND of parent for user notification messages
//            CConnectionTable *pConnTable  - Ptr to the connection table - assumed open
//            LPCTSTR pszEntry              - The name of the service entry
//            DWORD dwFlags                 - The application flags FL_...
//            LPBOOL pfSuccess              - Ptr to flag indicating that the request was
//                                            both 1) resolved and 2) already connected
//
// Returns:   BOOL - TRUE if the request was resolved against the existing table data
//
// History:   nickball    Created     3/18/98
//
//+----------------------------------------------------------------------------
BOOL HandleCustomConnectRequest(
    HWND hwndParent,
    CConnectionTable *pConnTable,
    LPCTSTR pszEntry,
    DWORD dwFlags,
    LPBOOL pfSuccess)
{
    BOOL fResolvedInTable = FALSE;
        
    CM_CONNECTION Connection;
    ZeroMemory(&Connection, sizeof(CM_CONNECTION));

    //
    // Only if there is an existing entry do we have any work here
    //

    if (SUCCEEDED(pConnTable->GetEntry(pszEntry, &Connection)))
    {
        *pfSuccess = TRUE; // assume the best

        //
        // There is a connection entry for this service, examine state.
        //
        
        if (CM_RECONNECTPROMPT != Connection.CmState)
        {
            fResolvedInTable = TRUE; // we can handle it here
            
            //
            // The entry is connecting, connected, or disconnecting. If its a manual
            // connection just notify the user, otherwise check the exact state.
            //
            
            if (dwFlags & FL_DESKTOP) // Set in CMMGR
            {
                if (!(dwFlags & FL_UNATTENDED))
                {
                    NotifyUserOfExistingConnection(hwndParent, &Connection, FALSE);
                }
            }
            else
            {                       
                //
                // Only if we are actually connected can we safely succeed.
                //
                
                if (CM_CONNECTED != Connection.CmState)
                {
                    *pfSuccess = FALSE;
                }
                else
                {
                    MYVERIFY(SUCCEEDED(pConnTable->AddEntry(Connection.szEntry, Connection.fAllUser))); // just bump ref
                }
            }
        }
        else
        {
            //
            // We must be in RECONNECT mode, if this connect request is 
            // from another source, tell CMMON to stop its monitoring. 
            // 

            if (!(dwFlags & FL_RECONNECT))
            {
                //
                // Its not a reconnect, so notify CMMON
                //

                HangupNotifyCmMon(pConnTable, Connection.szEntry);
            }
        }
    }

    return fResolvedInTable;
}

//+---------------------------------------------------------------------------
//
//  Function:   InetDialHandler
//
//  Synopsis:   Ansi and only form of the AutoDial handler . 
//
//  Arguments:  hwndParent[IN]      Handle to parent window. No longer ignored.
//              pszConnectoid[IN]   Connectoid name
//              dwFlags[IN]         Custom dial handler execution flags
//                                  Current the following flags are supported
//                                          INTERNET_CUSTOMDIAL_CONNECT 
//                                          INTERNET_CUSTOMDIAL_UNATTENDED
//                                          INTERNET_CUSTOMDIAL_DISCONNECT
//                                  These flags will be passed from WININET
//              lpdwRasError[OUT]   RasError code returned from ICM
//
//              Returns: The return type is different than one defined in wininet.h
//              TRUE:    This handler handled the dial request (connected or not)
//              FALSE:   This handler didn't handle the dial request
//
//              When returning TRUE, lpdwRasError is set to:
//                  ERROR_SUCCESS:              Call completed
//                  ERROR_USER_DISCONNECTION:   User cancelled dial request
//                  <other ras error>           Dial attempt failed.
//
//              This is a synchronous call. It should not return until the operation is complete.
//
//  Note:       We do not provide a wide form of this API as it is stored in 
//              the szAutoDialfunc member of the RASENTRY downlevel. If the 
//              wide form were avialable, RASAUTOU.EXE would call the function
//              (it appends A or W to the name that it finds in AutoDialFunc),
//              which would be inappropriate because the semantics of the 
//              parameters differ even though the function prototypes match.
//
//  History:    byao        Created                                                 - 05/05/97
//              quintinb    Rewrote to use InetDialHandlerW                         - 03/09/99
//              nickball    Removed InetDialHandlerW as it confuses RasAuto on NT4  - 07/28/99
//              quintinb    Always return true if connect request handled #390890   - 08/19/99
//
//----------------------------------------------------------------------------
extern "C" DWORD WINAPI InetDialHandler(HWND hwndParent, 
    LPCSTR pszConnectoid,
    DWORD dwFlags, 
    LPDWORD lpdwRasError) 
{
    MYDBGASSERT(pszConnectoid);
    MYDBGASSERT(lpdwRasError);
    CMTRACE(TEXT("InetDialHandler"));

    TCHAR           szProfilePath[MAX_PATH+1];
    LPWSTR          pszwConnectionName              = NULL;
    LPTSTR          pszRasPhoneBook                 = NULL;
    LPCMDIALINFO    lpCmInfo                        = NULL;
    BOOL            bRet                            = TRUE; // Read all comments before modifying this init value.
    BOOL            bAllUser;

    //
    // Check whether the parameters are valid
    //
    if (lpdwRasError)
    {
        if (! ((INTERNET_CUSTOMDIAL_CONNECT == dwFlags) ||
               (INTERNET_CUSTOMDIAL_UNATTENDED == dwFlags) ||
               (INTERNET_CUSTOMDIAL_DISCONNECT == dwFlags) ||
               (INTERNET_CUSTOMDIAL_SHOWOFFLINE== dwFlags) ))
        {
            CMASSERTMSG(FALSE, TEXT("InetDialHandler called with invalid flag"));
            *lpdwRasError = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        if (!pszConnectoid || TEXT('\0') == pszConnectoid[0])
        {
            *lpdwRasError = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
    }
    else
    {
        return FALSE;   
    }
    
    //
    // Make a wide copy of the connectoid name. We also want a copy so 
    // that we can modify if necessary. On 9x we will resolve tunnel
    // entry names down to the base connectoid/service name.
    //

    pszwConnectionName = SzToWzWithAlloc(pszConnectoid);

    MYDBGASSERT(pszwConnectionName);

    if (!pszwConnectionName)
    {
        *lpdwRasError = GetLastError();
        bRet = FALSE;
        goto InetDialHandlerExit;
    }
   
    StripTunnelSuffixW(pszwConnectionName);

    //
    // Handle the Hangup case 
    //

    if (INTERNET_CUSTOMDIAL_DISCONNECT == dwFlags)
    {   
        *lpdwRasError = CmCustomHangUp(NULL, pszwConnectionName, TRUE, FALSE);
        bRet = (ERROR_SUCCESS == *lpdwRasError);
        goto InetDialHandlerExit;       
    }
    
    //
    // Its a connect request, setup CmInfo flags and call
    // 
    
    lpCmInfo = (LPCMDIALINFO) CmMalloc(sizeof(CMDIALINFO));
    
    if (NULL == lpCmInfo)
    {
        *lpdwRasError = ERROR_NOT_ENOUGH_MEMORY;
        bRet = FALSE;
        goto InetDialHandlerExit;       
    }

    if (INTERNET_CUSTOMDIAL_UNATTENDED == dwFlags ) 
    {
        //
        // Unattended dialing mode has been requested
        //

        lpCmInfo->dwCmFlags |= FL_UNATTENDED;
    }

    //
    // Note: Treat INTERNET_CUSTOMDIAL_SHOWOFFLINE the same as INTERNET_CUSTOMDIAL_CONNECT
    //

    bAllUser = ReadMapping(pszwConnectionName, szProfilePath, (sizeof(szProfilePath)/sizeof(TCHAR)), TRUE, TRUE); // TRUE == fAllUser, TRUE == bExpandEnvStrings

    if (FALSE == bAllUser)
    {
        if (FALSE == ReadMapping(pszwConnectionName, szProfilePath, (sizeof(szProfilePath)/sizeof(TCHAR)), FALSE, TRUE)) // FALSE == fAllUser, TRUE == bExpandEnvStrings
        {
            //
            // No mapping, no connection
            //
        
            *lpdwRasError = ERROR_INVALID_PARAMETER;
            bRet = FALSE;
            goto InetDialHandlerExit;
        }
        
        //
        // We have a single user profile path. If this is NT5, build a phonebook path
        //
        
        MYDBGASSERT(OS_NT5);

        if (OS_NT5)
        {
            pszRasPhoneBook = GetRasPbkFromNT5ProfilePath(szProfilePath);
            MYDBGASSERT(pszRasPhoneBook);
        }
    }
    
    //
    // InetDialHandler is usually an auto-dial case. 
    // Exceptions are:
    //      1) When called from WinLogon.exe on NT4.          NT #370311
    //      2) When called from Rundll32.exe.on any platform. 9x #127217
    //

    if ((FALSE == IsLogonAsSystem()) && (FALSE == WhoIsCaller(DT_RUNDLL32)))
    {
        lpCmInfo->dwCmFlags |= FL_AUTODIAL;
    }

    //
    // We set the error code based on whether or not we connected. However, 
    // we should always return TRUE to indicate to WININET, etc. that we 
    // handled the connection request (if we did actually handle it). 
    // Otherwise the caller (eg.IE) will try to dial its own dialer. #390890
    //

    if (CmCustomDialDlg(hwndParent, 
                        bAllUser ? RCD_AllUsers : RCD_SingleUser, 
                        pszRasPhoneBook, 
                        pszwConnectionName, 
                        NULL, 
                        NULL, 
                        NULL,
                        lpCmInfo))
    {
        *lpdwRasError = ERROR_SUCCESS;
    }
    else
    {
        *lpdwRasError = ERROR_USER_DISCONNECTION;
    }

InetDialHandlerExit:

    CmFree(pszRasPhoneBook);
    CmFree(lpCmInfo);
    CmFree(pszwConnectionName);

    CMTRACE2(TEXT("InetDialHandler returns %u with *lpdwRasError %u"), bRet, *lpdwRasError);

    return bRet; 
}

//+----------------------------------------------------------------------------
//
// Function:  AutoDialFunc
//
// Synopsis:  The original AutoDial callback function, provided for backward 
//            compatibility.
//
// Arguments: HWND hwndParent - The hwnd of the caller.
//            LPCTSTR pszEntry - The name of the connection to be dialed
//            DWORD dwFlags - Specific behaviour for the dial session.
//            LPDWORD pdwRetCode - Buffer for return code.
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    Created Header    2/5/98
//
// Note:      This is used by RAS on NT4 SP6
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI AutoDialFunc(HWND hwndParent, 
    LPCSTR pszEntry, 
    DWORD dwFlags,
    LPDWORD pdwRetCode) 
{
    CMTRACE(TEXT("AutoDialFunc()"));

    MYDBGASSERT(OS_NT4);

    //
    //  InetDialHandler always returns TRUE, thus we must determine success or
    //  failure from the pdwRetCode.  If this is ERROR_SUCCESS then we should
    //  return TRUE, otherwise FALSE.
    //
    InetDialHandler(hwndParent, pszEntry, dwFlags, pdwRetCode);

    BOOL bRet = (ERROR_SUCCESS == *pdwRetCode);
        
    //
    // Always override pdwRetCode to ERROR_SUCCESS or RAS will throw an 
    // unpleasant error. RAS is only interested in success or failure.
    //

    *pdwRetCode = ERROR_SUCCESS;

    CMTRACE2(TEXT("AutoDialFunc returns %u with *pdwRetCode %u"), bRet, *pdwRetCode);

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CopyRasInput
//
// Synopsis:  Simple wrapper function to make copies of the parameters we
//            receive from RAS.
//
// Arguments: LPTSTR* ppszOurCopy - pointer to the string pointer to hold the return string
//            LPWSTR pszwStringFromRas - String from RAS
//
// Returns:   BOOL - returns TRUE on Success, FALSE otherwise
//
// History:   quintinb Created     4/13/99
//
//+----------------------------------------------------------------------------
BOOL CopyRasInput(LPTSTR* ppszOurCopy, LPWSTR pszwStringFromRas)
{
    if (pszwStringFromRas)
    {
#ifndef _UNICODE
        *ppszOurCopy = WzToSzWithAlloc(pszwStringFromRas);
#else
        *ppszOurCopy = CmStrCpyAllocW (pszwStringFromRas);
#endif
        return (NULL != *ppszOurCopy);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function: RasCustomDialDlg
//
// Synopsis:  Our implementation of RasCustomDialDlg extension, analogous to 
//            RasDialDlg, but providing custom functionality.
//
// Arguments: HINSTANCE hInstDll - The HINSTANCE of the caller.
//            DWORD dwFlags - Dial flags
//            LPTSTR lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPTSTR lpszPhoneNumber - Ptr toi replacement phone number
//            LPRASDIALDLG lpInfo - Ptr to structure for additional parameters
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------

extern "C" BOOL WINAPI RasCustomDialDlg(HINSTANCE hInstDll, 
    DWORD dwFlags, 
    LPWSTR lpszwPhonebook, 
    LPWSTR lpszwEntry, 
    LPWSTR lpszwPhoneNumber, 
    LPRASDIALDLG lpInfo,
    PVOID pVoid)
{
    MYDBGASSERT(lpszwEntry);
    MYDBGASSERT(lpszwEntry[0]);
    MYDBGASSERT(lpInfo);

    CMTRACE1(TEXT("RasCustomDialDlg() - dwFlags = 0x%x"), dwFlags);
    if (lpInfo)
    {
        CMTRACE1(TEXT("RasCustomDialDlg() - (RASDIALDLG)lpInfo->dwFlags = 0x%x"), lpInfo->dwFlags);
    }

    if (NULL == lpszwEntry || 0 == lpszwEntry[0] || NULL == lpInfo)
    {
        return FALSE;
    }

    //
    // We have the minimum requirement of an entry name, get to work
    //

    BOOL fSuccess = TRUE;
    LPTSTR pszEntry = NULL;
    LPTSTR pszPhonebook = NULL;

    //
    // If we have a Phonebook name make a copy
    //
    fSuccess = CopyRasInput(&pszPhonebook, lpszwPhonebook);

    if (fSuccess)
    {
        //
        // If we have an entry name (always do), make a copy to work with
        //
        fSuccess = CopyRasInput(&pszEntry, lpszwEntry);

        if (fSuccess)
        {
            //
            // Its always a simple connect request, no flags, no caller ids
            // 

            CMDIALINFO CmInfo;
            ZeroMemory(&CmInfo, sizeof(CMDIALINFO));

            //
            // If this is a reconnect request from CMMON, copy the information
            //
            if (lpInfo && IsCmReconnectRequest(lpInfo))
            {
                CmInfo = ((CmRasDialDlg* )lpInfo)->CmInfo;
            }
            else
            {
                //
                // If running under the system account its never an autodial
                //

                if (FALSE == IsLogonAsSystem())
                {
                    //
                    // See where the call originated. If not a desktop scenario
                    // then set the AUTODIAL flag so that we do the right thing
                    // down the line. This is ugly, but we have no other way of
                    // making the determination. Note: That this entry point 
                    // only exists on NT5 and is only called by RAS so the perf 
                    // hit is contained and CMMGR is not a valid desktop scenario
                    // so we don't have to check for it.
                    //
                    // DT_RASAUTOU - When ICS is enabled, rasauto starts the 
                    // rasautou.exe process to dial a connection. CM used to add
                    // rasautou in the process watch list. The issue was that 
                    // it goes away after connecting, so cmmon32 thought it needed
                    // to disconnected. Now, RASAUTOU is not a watched process 
                    // and cmmon32 does not disconnect.
                    //
                    if (FALSE == WhoIsCaller(DT_EXPLORER | DT_CMSTP | DT_RASAUTOU))
                    {
                        CmInfo.dwCmFlags |= FL_AUTODIAL;
                    }
                }  

                //
                //  Note that we want to set the Unattended flag if RASDDFLAG_NoPrompt is set
                //
                if (lpInfo && (lpInfo->dwFlags & RASDDFLAG_NoPrompt))
                {
                    CmInfo.dwCmFlags |= FL_UNATTENDED;
                    CMTRACE(TEXT("RasCustomDialDlg - Setting CmInfo.dwCmFlags |= FL_UNATTENDED"));
                }
            }

            //
            //  If we have a RASNOUSER struct, make sure to encode the password
            //
            LPRASNOUSER lpRasNoUser = NULL;
            CSecurePassword secureRasNoUserPW;

            if (NULL != pVoid)
            {
                if (0 == (dwFlags & RCD_Eap))
                {
                    lpRasNoUser = (LPRASNOUSER) pVoid;
                    
                    //
                    // Need to securely store the password from RASNOUSER structure so that 
                    // we don't leave it just encoded and sitting around for the duration of CM.
                    // InitCredentials() will end up clearing it out of this structure after it
                    // puts it into pArgs. Before CM exits, we need to copy the password back because it's
                    // not our memory.
                    //
                    (VOID)secureRasNoUserPW.SetPassword(lpRasNoUser->szPassword);
                    CmEncodePassword(lpRasNoUser->szPassword);
                }
            }

            fSuccess = CmCustomDialDlg(lpInfo ? lpInfo->hwndOwner : NULL,
                                       dwFlags, 
                                       pszPhonebook, 
                                       pszEntry, 
                                       NULL, 
                                       lpInfo,
                                       NULL,
                                       &CmInfo,
                                       pVoid);

            //
            //  If we have a RASNOUSER struct, decode the password to make it plain text again
            //
            if (NULL != lpRasNoUser)
            {
                //
                // This should have already been wiped by InitCredentials()
                //
                CMASSERTMSG(0 == lstrlenU(lpRasNoUser->szPassword), TEXT("RasCustomDialDlg - RASNOUSER->szPassword isn't blank."));
                
                //
                // Now we need to copy the password back into RASNOUSER structure
                // because it was wiped by InitCredentials()
                //
                LPTSTR pszClearPassword = NULL;
                DWORD cbClearPassword = 0;
                BOOL fRetPassword = FALSE;

                fRetPassword = secureRasNoUserPW.GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

                if (fRetPassword && pszClearPassword)
                {
                    lstrcpynU(lpRasNoUser->szPassword, pszClearPassword, CELEMS(lpRasNoUser->szPassword));
                    secureRasNoUserPW.ClearAndFree(&pszClearPassword, cbClearPassword);
                }
            }
        }
    }

    //
    // Cleanup and go home
    //

    CmFree(pszPhonebook);       
    CmFree(pszEntry);      

    CMTRACE1(TEXT("RasCustomDialDlg returning %d"), fSuccess);

    return fSuccess;
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomEntryDlg
//
// Synopsis:  Our implementation of RasCustomEntryDlg extension, analogous to 
//            RasEntryDlg, but providing custom functionality.
//
// Arguments: HINSTANCE hInstDll - The HINSTANCE of the caller.
//            LPTSTR lpszPhonebook - Ptr to the full path and name of the phonebook to be edited.
//            LPTSTR lpszEntry - Ptr to the name of the entry to be edited.
//            LPRASENTRYDLG lpInfo - Ptr to structure containing additional parameters.
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    2/5/98    Created Header    
//            nickball    1/11/00   Now used on 9x, added use of function
//                                  StripTunnelSuffixW() to resolve 9x tunnel
//                                  connectoid names.
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI RasCustomEntryDlg(HINSTANCE hInstDll, 
    LPWSTR lpszwPhonebook, 
    LPWSTR lpszwEntry, 
    LPRASENTRYDLG lpInfo,
    DWORD dwFlags)
{
    MYDBGASSERT(lpszwEntry);
    MYDBGASSERT(lpszwEntry[0]);

    CMTRACE1(TEXT("RasCustomEntryDlg() - dwFlags = 0x%x"), dwFlags);

    if (NULL == lpszwEntry || 0 == lpszwEntry[0])
    {
        return FALSE;
    }

    //
    // We have the minimum requirement of an entry name, get to work
    //

    BOOL fSuccess = TRUE;
    LPTSTR pszEntry = NULL;
    LPTSTR pszPhonebook = NULL;

    //
    // If we have a Phonebook name, make a copy to work with
    //
    fSuccess = CopyRasInput(&pszPhonebook, lpszwPhonebook);

    if (fSuccess)
    {
        //
        // If we have an entry name (always do), make a copy to work with
        //

        fSuccess = CopyRasInput(&pszEntry, lpszwEntry);

        if (fSuccess)
        {
            StripTunnelSuffixW(pszEntry); // Assumes we'll always compile Unicode

            //
            // Its always a properties request, set the flag and dial
            // 

            LPCMDIALINFO lpCmInfo = (LPCMDIALINFO) CmMalloc(sizeof(CMDIALINFO));

            if (lpCmInfo)
            {
                lpCmInfo->dwCmFlags |= FL_PROPERTIES;
                    
                fSuccess = CmCustomDialDlg(lpInfo ? lpInfo->hwndOwner : NULL, 
                                          dwFlags, 
                                          pszPhonebook, 
                                          pszEntry, 
                                          NULL, 
                                          NULL, 
                                          lpInfo,
                                          lpCmInfo);
            }
            else
            {
                fSuccess = FALSE;
            }

            CmFree(lpCmInfo);
        }
    }

    //
    // Cleanup and go home
    //

    CmFree(pszPhonebook);
    CmFree(pszEntry);
   
    return fSuccess;
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomHangUp
//
// Synopsis:  Our implementation of the RasCustomHangUp extension, analogous to 
//            RasHangup, but providing custom functionality. This function is
//            only called on NT5
//
// Arguments: HRASCONN hRasConn - The handle of the connection to be terminated.
//
// Returns:   DWORD WINAPI - Return code
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI RasCustomHangUp(HRASCONN hRasConn)
{    
    //
    // If someone is calling this function on a system other then NT5, assert.
    //

    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(hRasConn);

    CMTRACE(TEXT("RasCustomHangup()"));

    DWORD dwRes = ERROR_SUCCESS;  
 
    // 
    // First try to open the table, if none found then succeed.
    //
    
    CConnectionTable ConnTable;

    if (FAILED(ConnTable.Open()))
    {
        CMTRACE(TEXT("RasCustomHangup() - ConnTable.Open() Failed."));
        return dwRes;
    }
      
    //
    // If we have an entry, do the Disconnect
    //

    CM_CONNECTION Connection;
    ZeroMemory(&Connection, sizeof(CM_CONNECTION));
   
    if (SUCCEEDED(ConnTable.GetEntry(hRasConn, &Connection)))
    {
        MYDBGASSERT(hRasConn == Connection.hDial || hRasConn == Connection.hTunnel);
        // 
        // Check connect state of entry. 
        // If we are already in the DISCONNECTING state, perform a simple hangup.
        //
              
        if (CM_DISCONNECTING == Connection.CmState)
        {
            //
            // Set up RAS linkage
            //
        
            RasLinkageStruct rlsRasLink;
            ZeroMemory(&rlsRasLink, sizeof(RasLinkageStruct));

            if (TRUE == LinkToRas(&rlsRasLink) && rlsRasLink.pfnHangUp)
            {
                //
                // Linkage is good, make the hangup call
                //
                dwRes = DoRasHangup(&rlsRasLink, hRasConn);
            }
            else
            {
                MYDBGASSERT(FALSE);
                dwRes = ERROR_NOT_READY;             
            }

            //
            // Cleanup
            // 

            UnlinkFromRas(&rlsRasLink);
        }        
        else
        {
            //
            // If we're still here then we are not in the middle of an existing
            // disconnect, handle disconnect as we otherwise would.
            //
            dwRes = Disconnect(&ConnTable, &Connection, FALSE, FALSE);         
        }
    }
    else
    {
        dwRes = ERROR_NOT_FOUND;
    }
    
    //
    // We are done with the table, close it now. 
    //

    MYVERIFY(SUCCEEDED(ConnTable.Close()));    
    return dwRes;     
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomDial
//
// Synopsis:  Our implementation of RasCustomDial which we don't support.
//            Provided so that we can return E_NOTIMPL to indicate our lack of 
//            support for this extension.
//
// Arguments: N/A
//
// Returns:   DWORD WINAPI - E_NOTIMPL
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------

extern "C" DWORD WINAPI RasCustomDial(
    HINSTANCE hInstDll, 
    LPRASDIALEXTENSIONS lpRasDialExtensions, 
    LPWSTR lpszPhonebook, 
    LPRASDIALPARAMSW lpRasDialParams, 
    DWORD dwNotifierType, 
    LPVOID lpvNotifier, 
    LPHRASCONN lphRasConn, 
    DWORD dwFlags)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomDeleteEntryNotify
//
// Synopsis:  Our implementation of RasCustomDeleteEntry.
//
// Arguments: 
//
// Returns:   DWORD WINAPI - 
//
// History:   quintinb    Created Header    2/5/98
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI RasCustomDeleteEntryNotify(LPWSTR pszPhonebook, LPWSTR pszEntry, DWORD dwFlags)
{
    CDynamicLibrary UserEnv(L"userenv.dll");
    CDynamicLibrary Advapi32(L"advapi32.dll");
    DWORD dwReturn = ERROR_INVALID_PARAMETER;
    HANDLE hImpersonationToken = NULL;   // The token of the thread
    HANDLE hPrimaryToken = NULL;         // The primary token for the new process
    LPWSTR pszShortServiceName = NULL;
    LPWSTR pszCmDirpath = NULL;
    PROCESS_INFORMATION ProcessInfo = {0};
    STARTUPINFO StartupInfo = {0};
    WCHAR szCmpPath[MAX_PATH+1] = {0};
    WCHAR szInfPath[MAX_PATH+1];
    WCHAR szParams[2*MAX_PATH+1];
    WCHAR szExactCmstpLocation[MAX_PATH + 10 + 1];  // 10 = length of "\cmstp.exe"

    typedef BOOL (WINAPI* pfnCreateEnvironmentBlockSpec)(LPVOID*, HANDLE, BOOL);
    typedef BOOL (WINAPI* pfnDestroyEnvironmentBlockSpec)(LPVOID);
    typedef BOOL (WINAPI* pfnDuplicateTokenExSpec)(HANDLE, DWORD, LPSECURITY_ATTRIBUTES, SECURITY_IMPERSONATION_LEVEL, TOKEN_TYPE, PHANDLE);
 
    pfnCreateEnvironmentBlockSpec pfnCreateEnvironmentBlock = NULL;
    pfnDestroyEnvironmentBlockSpec pfnDestroyEnvironmentBlock = NULL;
    pfnDuplicateTokenExSpec pfnDuplicateTokenEx = NULL;

    //
    //  Are we deleting an All User or a Single User Connection
    //
    BOOL bAllUser = (RCD_AllUsers & dwFlags);

    //
    //  Assume we are impersonating until we know otherwise.  Profiles deleted from the
    //  IE Connections Tab will not be impersonating, whereas delete requests from the
    //  folder go through Netman.dll in svchost.exe and are thus impersonating.
    //
    BOOL bImpersonatingProfile = TRUE;

    //
    //  Check the params, note that pszPhoneBook could be NULL
    //
    if ((NULL == pszEntry) || (L'\0' == pszEntry[0]) || 
        ((NULL != pszPhonebook) && (L'\0' == pszPhonebook[0])))
    {
        goto exit;
    }

    //
    //  Next lets setup the impersonation Token
    //
    if (OpenThreadToken(GetCurrentThread(), 
                        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                        TRUE, &hImpersonationToken))
    {
        //
        // Okay, we have an impersonation token.  Lets get it, duplicate it and then
        // we can use it to call CreateProcessAsUser
        //

        pfnDuplicateTokenEx = (pfnDuplicateTokenExSpec)Advapi32.GetProcAddress("DuplicateTokenEx");

        if (NULL == pfnDuplicateTokenEx)
        {
            dwReturn = GetLastError();
            CMTRACE1(TEXT("RasCustomDeleteEntry -- Unable get proc address for DuplicateTokenEx, GLE %d"), GetLastError());
            goto exit;        
        }

        if (!pfnDuplicateTokenEx(hImpersonationToken,
                                TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE,
                                NULL, SecurityImpersonation, TokenPrimary, &hPrimaryToken))
        {
            dwReturn = GetLastError();
            CMTRACE1(TEXT("RasCustomDeleteEntry -- DuplicateTokenEx Failed, GLE %d"), GetLastError());
            goto exit;
        }
    }
    else
    {
        bImpersonatingProfile = FALSE;
    }

    //
    //  First let's read the Mappings Key, note that we don't expand the environment strings
    //  if it is an impersonating profile.  ExpandEnvironmentStrings doesn't have the correct
    //  environment loaded sometimes when we are impersonating.  We are launching cmstp.exe
    //  with a full environment block via CreateProcessAsUser, this will take care of the
    //  expansion so there is no need.
    //
    if (FALSE == ReadMapping(pszEntry, szCmpPath, MAX_PATH, bAllUser, !bImpersonatingProfile)) // !bImpersonatingProfile == bExpandEnvStrings
    {
        //
        // No mappings key, return failure
        //
        CMASSERTMSG(FALSE, TEXT("RasCustomDeleteEntry -- ReadMapping returned FALSE, unable to find the profile."));
        dwReturn = ERROR_FILE_NOT_FOUND;
        goto exit;
    }   

    //
    //  At this point we should have a mappings value.  We need to convert that into the INF
    //  path.  CM 1.0/1.1 profiles stored their INF files in the system(32) dir.
    //  CM 1.2  Profiles store this file in the Profile directory.  Since
    //  a user could install an old profile we must try the Legacy location
    //  if the current location fails.
    //

    pszShortServiceName = CmStripPathAndExt(szCmpPath);
    pszCmDirpath = CmStripFileName(szCmpPath, TRUE); // bKeepSlash == TRUE

    if (pszShortServiceName && pszCmDirpath)
    {
        //
        //  Build the new inf location
        //
        wsprintfW(szInfPath, L"%s%s\\%s.inf", pszCmDirpath, pszShortServiceName, pszShortServiceName);

        if (!FileExists(szInfPath) && bAllUser) // if the doesn't file exists and we are all user then try the sys dir
        {
            //
            //  Looks like this is an old style profile with the inf in the system directory.
            //  Now build the old style path and see if it exists.  Note that 1.0 profiles were All User only
            //
            if (0 != GetSystemDirectoryU(szInfPath, MAX_PATH))
            {
                lstrcatU(szInfPath, L"\\");
                lstrcatU(szInfPath, pszShortServiceName);
                lstrcatU(szInfPath, L".inf");
                
                if (!FileExists(szInfPath))
                {
                    CMASSERTMSG(FALSE, TEXT("RasCustomDeleteEntry -- Unable to locate profile inf."));
                    dwReturn = ERROR_FILE_NOT_FOUND;
                    goto exit;                
                }
            }
            else
            {
                dwReturn = GetLastError();
                goto exit;
            }
        }
    } 
    else
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    
    (void) GetSystemDirectory(szExactCmstpLocation, MAX_PATH);
    lstrcatU(szExactCmstpLocation, TEXT("\\cmstp.exe"));

    lstrcpyU(szParams, L"cmstp.exe /u /s \"");
    lstrcatU(szParams, szInfPath);
    lstrcatU(szParams, L"\"");
    if (bImpersonatingProfile)
    {
        //
        //  Fill in the environment block
        //
        WCHAR* pszEnvBlock;

        pfnCreateEnvironmentBlock = (pfnCreateEnvironmentBlockSpec)UserEnv.GetProcAddress("CreateEnvironmentBlock");
        pfnDestroyEnvironmentBlock = (pfnDestroyEnvironmentBlockSpec)UserEnv.GetProcAddress("DestroyEnvironmentBlock");

        if ((NULL == pfnCreateEnvironmentBlock) || (NULL == pfnDestroyEnvironmentBlock))
        {
            dwReturn = ERROR_PROC_NOT_FOUND;
            CMTRACE(TEXT("RasCustomDeleteEntry -- Unable to load pfnCreateEnvironmentBlock Or pfnDestroyEnvironmentBlock."));
            goto exit;
        }    

        if (pfnCreateEnvironmentBlock((void**)&pszEnvBlock, hPrimaryToken, TRUE))
        {
            if (CreateProcessAsUser(hPrimaryToken,
                                    szExactCmstpLocation,         // lpApplicationName
                                    szParams,                     // lpCommandLine
                                    NULL,                         // pProcessAttributes
                                    NULL,                         // lpThreadAttributes
                                    FALSE,                        // bInheritHandles
                                    CREATE_UNICODE_ENVIRONMENT,   // dwCreationFlags
                                    pszEnvBlock,                  // lpEnvironment
                                    NULL,                         // lpCurrentDirectory
                                    &StartupInfo,
                                    &ProcessInfo))
            {
                CloseHandle(ProcessInfo.hProcess);
                CloseHandle(ProcessInfo.hThread);
                dwReturn = ERROR_SUCCESS;
            }
            else
            {
                dwReturn = GetLastError();
                CMTRACE1(TEXT("RasCustomDeleteEntry -- CreateProcessAsUser Failed, GLE %d"), GetLastError());
            }

            pfnDestroyEnvironmentBlock(pszEnvBlock);
        }
        else
        {
            CMTRACE1(L"Unable to Create the Environment block, GLE %d", GetLastError());
        }
    }
    else
    {
        //
        //  We aren't impersonating just use regular CreateProcess, we could use CreateProcessU here but it isn't necessary as
        //  this only runs on win2k and CreateProcessW exists (although isn't implemented) all the way back to win95.
        //
        if (CreateProcess(NULL,                        // lpApplicationName
                          szParams,                    // lpCommandLine
                          NULL,                        // pProcessAttributes
                          NULL,                        // lpThreadAttributes
                          FALSE,                       // bInheritHandles
                          CREATE_UNICODE_ENVIRONMENT,  // dwCreationFlags
                          NULL,                        // lpEnvironment
                          NULL,                        // lpCurrentDirectory
                          &StartupInfo,
                          &ProcessInfo))
        {
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            dwReturn = ERROR_SUCCESS;
        }
        else
        {
            dwReturn = GetLastError();
            CMTRACE1(TEXT("RasCustomDeleteEntry -- CreateProcessAsUser Failed, GLE %d"), GetLastError());
        }
    }
    
exit:

    if (hImpersonationToken)
    {
        CloseHandle(hImpersonationToken);
    }

    if (hPrimaryToken)
    {
        CloseHandle(hPrimaryToken);
    }

    CmFree(pszCmDirpath);
    CmFree(pszShortServiceName);
    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Synopsis:  Main entry point into the DLL.
//
// Arguments: HINSTANCE  hinstDLL - Our HINSTANCE
//            DWORD  fdwReason - The reason we are being called.
//            LPVOID  lpvReserved - Reserved
//
// Returns:   BOOL WINAPI - TRUE - always
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HINSTANCE  hInstDLL, 
    DWORD  fdwReason, 
    LPVOID  lpvReserved) 
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            if (!InitUnicodeAPI())
            {
               //
               //  Without our U api's we are going no where.  Bail.
               //
                CMTRACE(TEXT("Cmdial32.dll Initialization Error:  Unable to initialize Unicode to ANSI conversion layer, exiting."));
                return FALSE;
            }

            CMTRACE(TEXT("====================================================="));
            CMTRACE1(TEXT(" CMDIAL32.DLL - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
            CMTRACE(TEXT("====================================================="));
        
#ifdef DEBUG        
            TCHAR szTmp[MAX_PATH];            
            MYVERIFY(GetModuleFileNameU (GetModuleHandleA(NULL), szTmp, MAX_PATH));      
            CMTRACE1(TEXT("Calling process is %s"), szTmp);
#endif

            // 
            // Setup global instance data
            //

            g_hInst = hInstDLL;

            //
            // Disable thread attach notification
            //

            MYVERIFY(DisableThreadLibraryCalls(hInstDLL));

            break;

        case DLL_PROCESS_DETACH:
        
            CMTRACE(TEXT("====================================================="));
            CMTRACE1(TEXT(" CMDIAL32.DLL - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
            CMTRACE(TEXT("====================================================="));

            if (!UnInitUnicodeAPI())
            {
                CMASSERTMSG(FALSE, TEXT("cmdial32 dllmain UnInitUnicodeAPI failed - we are probably leaking a handle"));
            }
            
            //
            // Unlike Windows 95, on Windows NT, Windows classes 
            // that a DLL registers are NOT unregistered when the DLL is unloaded. 
            // Bug 168251:First launch of profile from connections UI causes access violation,
            // after copy new CM bits
            //

            if (OS_NT)
            {
                //
                // Unregister the bitmap class. The new CM bits will re-register the class with
                // correct wnd proc address.
                //
                UnregisterClassU(ICONNMGR_BMP_CLASS, g_hInst);
                UnRegisterWindowClass(g_hInst);
            }

            break;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function: CmCustomDialDlg
//
// Synopsis:  Our CM specific variation on RasCustomDialDlg.  
//
// Arguments: HWND          hwndParent - The HWND of the parent if deemed necessary by the caller
//            DWORD         dwFlags - Dial flags
//            LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//                          NULL = RAS system phone book
//                          "something" = user-defined RAS phonebook
//                          "" = has not been determined yet
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPTSTR        lpszPhoneNumber - Ptr to replacement phone number [IGNORED]
//            LPRASDIALDLG  lpRasDialDlg - Ptr to RASDIALDLG struct
//            LPRASENTRYDLG lpRasEntryDlg - Ptr to RASENTRYDLG struct
//            LPCMDIALINFO  lpCmInfo - Ptr to CMDIALINFO struct containing CM dial info such as flags.
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------

extern "C" BOOL WINAPI CmCustomDialDlg(HWND hwndParent,
    DWORD dwFlags,
    LPTSTR lpszPhonebook, 
    LPCTSTR lpszEntry, 
    LPTSTR,                         // lpszPhoneNumber
    LPRASDIALDLG lpRasDialDlg,
    LPRASENTRYDLG lpRasEntryDlg,
    LPCMDIALINFO lpCmInfo,
    PVOID pvLogonBlob)
{
    MYDBGASSERT(lpCmInfo);
    MYDBGASSERT(lpszEntry);
    MYDBGASSERT(lpszEntry[0]);

    //DebugBreak();

    CMTRACE1(TEXT("CmCustomDialDlg() - dwFlags = 0x%x"), dwFlags);
    CMTRACE1(TEXT("CmCustomDialDlg() - lpszPhonebook = %s"), MYDBGSTR(lpszPhonebook));
    CMTRACE1(TEXT("CmCustomDialDlg() - lpszEntry = %s"), MYDBGSTR(lpszEntry));

    //
    // lpszPhonebook can be NULL, because we are called by our own modules, CMMGR, CMMON, etc.
    //

    if (NULL == lpszEntry || NULL == lpszEntry[0] || NULL == lpCmInfo)
    {
        return FALSE;
    }

    CM_SET_TIMING_INTERVAL("CmCustomDialDlg - Begin");

#ifdef DEBUG
    //
    // Here we don't care whether we are in FUS, but need to know how many TS sessions are on the machine
    // currently. This is for debugging issues only to make sure ICS works and there is always at least one session.
    //
    DWORD dwSessionCount = 0;
    (VOID)InFastUserSwitch(&dwSessionCount);
    CMTRACE1(TEXT("CmCustomDialDlg() - TS Session Count = %d"), dwSessionCount);
#endif

    CNamedMutex ConnectMutex;  
    CConnectionTable ConnTable;
    BOOL fConnTableExists = FALSE;
    BOOL fMultiInst = FALSE;
    
    if (!(lpCmInfo->dwCmFlags & FL_PROPERTIES))
    {
        //
        // Try to acquire connect mutex
        //
   
        LPTSTR pszTmp = CmStrCpyAlloc(c_pszConnectMutex);
        pszTmp = CmStrCatAlloc(&pszTmp, lpszEntry);

        if (FALSE == ConnectMutex.Lock(pszTmp, FALSE))
        {            
            if (FALSE == IsLogonAsSystem())
            {
                //
                // Another connect instance exists, try to front it
                //

                FrontExistingUI(NULL, lpszEntry, TRUE);

                // 
                // Now wait for Mutex to be released.
                //


                ConnectMutex.Lock(pszTmp, TRUE, INFINITE, TRUE);

                //
                // Mutex was released by the other instance, we'll handle the connect
                // request in the main path. If there is no table, we know that the 
                // instance which previously owned the mutex terminated without 
                // connecting and we follow suit by returning failure. Otherwise, we 
                // have to take a closer look. 
                //                                             

                fMultiInst = TRUE;
            }
            else
            {
                // 
                // No one is logged on and we don't need to be waiting for the mutex.
                //
                CmFree(pszTmp);
                return FALSE;
            }
       }
       

       CmFree(pszTmp);      
    }

    CMTRACE(TEXT("CmCustomDialDlg - Connect mutex acquired. Examining connection table."));
  
    fConnTableExists = SUCCEEDED(ConnTable.Open());

    if ((!fConnTableExists) && fMultiInst) 
    {
        //
        // If we're a secondary thread that was released from the mutex and
        // there is no connection table, then the user canceled, so bail.
        //

        CMTRACE(TEXT("CmCustomDialDlg - returning connect failure post mutex wait"));
        return FALSE;
    }
  
    //
    // If this is a connect request, see if connection exists. 
    //
    
    if (!(lpCmInfo->dwCmFlags & FL_PROPERTIES))
    {
        if (fConnTableExists)
        {
            //
            // Examine the connection table and try to resolve the connect request
            //

            BOOL fSuccess = FALSE;
            BOOL fDone = HandleCustomConnectRequest(NULL, 
                                                    &ConnTable, 
                                                    lpszEntry, 
                                                    lpCmInfo->dwCmFlags, 
                                                    &fSuccess);
            //
            // If we resolved the request, or we're in fMultiInst mode
            // then we can we can bail with the given success code. If  
            // fMultInst, we know we can bail because there is no entry
            // in the table, from which we infer that the previous owner
            // of the mutex failed and we return this out to our caller.
            //
            // NOTE: There is a theoretical corner case here in the multi-inst 
            // request case. If a succesful connection was established by the 
            // first thread, there is a window between the moment that the mutex 
            // lock is cleared above (releasing the waiting thread), and when 
            // the newly release thread reaches here. The logic is fouled if, 
            // and only if, the connection were dropped and entered the 
            // reconnect prompt state during this window. This is because the
            // second thread would dismiss the CMMON reconnect prompt UI during 
            // the call to HandleCustomConnectRequest, but would then return
            // despite fDone being FALSE. The correct behavior would be to 
            // continue, and honor the connect request. This state could be 
            // identified by an fDone of FALSE coupled with an fSuccess of TRUE.
            //
            
            if (fDone || fMultiInst)
            {
                MYVERIFY(SUCCEEDED(ConnTable.Close()));
                return fSuccess;            
            }           
        }
    }
    else
    {
        //
        // Its a properties request, front any UI that might exist
        //

        if (TRUE == FrontExistingUI(fConnTableExists? &ConnTable : NULL, lpszEntry, FALSE))
        {
            if (fConnTableExists)
            {
                MYVERIFY(SUCCEEDED(ConnTable.Close()));
            }
            return TRUE;       
        }
    }

    if (fConnTableExists)
    {
        MYVERIFY(SUCCEEDED(ConnTable.Close()));
    }
    
    //
    // Make a connection attempt
    //

    HRESULT hrRes = Connect(hwndParent,
                          lpszEntry, 
                          lpszPhonebook, 
                          lpRasDialDlg, 
                          lpRasEntryDlg, 
                          lpCmInfo,                           
                          OS_NT5 ? dwFlags : RCD_AllUsers, // Always AllUser downlevel
                          pvLogonBlob);

    //
    // Make sure we push error codes back out
    //
    BOOL bReturn = SUCCEEDED(hrRes);
    DWORD dwError = 0;

    if (lpRasDialDlg)
    {
        if (ERROR_CANCELLED == HRESULT_CODE(hrRes))
        {
            //
            //  If the user canceled then RasDialDlg returns a false to indicate failure
            //  but sets the dwError value to 0.  In order to match the way RAS does
            //  things we need to do this too.
            //
            lpRasDialDlg->dwError = 0;
        }
        else
        {
            //
            //  If the user entered the wrong PIN, we pass the error up to RAS unchanged
            //  so that RAS knows to take down its 'choose connectoid' dialog and drop
            //  the user back to winlogon
            //
            lpRasDialDlg->dwError = (BAD_SCARD_PIN(hrRes) ? hrRes : HRESULT_CODE(hrRes));
        }

        dwError = lpRasDialDlg->dwError;
    }

    if (lpRasEntryDlg)
    {
        if (ERROR_CANCELLED == HRESULT_CODE(hrRes))
        {
            //
            //  If the user canceled then RasEntryDlg returns a false to indicate failure
            //  but sets the dwError value to 0.  In order to match the way RAS does
            //  things we need to do this too.
            //
            lpRasEntryDlg->dwError = 0;
        }
        else
        {
            lpRasEntryDlg->dwError = HRESULT_CODE(hrRes);
        }

        dwError = lpRasEntryDlg->dwError;
    }
   
    //
    // Let go of the connect mutex and go home to papa.
    //

    CMTRACE(TEXT("CmCustomDialDlg - Releasing mutex")); 
    ConnectMutex.Unlock();

    CMTRACE2(TEXT("CmCustomDialDlg() returning with bReturn = %d, dwError = 0x%x"), bReturn, dwError);
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CmCustomHangUp
//
// Synopsis:  Our CM specific variation on RasCustomHangUp. Optionally, the entry
//            name may be given instead of the RAS handle.
//
// Arguments: HRASCONN hRasConn - The handle of the connection to be terminated.
//            LPCTSTR pszEntry - Ptr to the name of the entry to be terminated.
//            BOLL fPersist - Preserve the entry and its usage count.
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI CmCustomHangUp(HRASCONN hRasConn,
    LPCTSTR pszEntry,
    BOOL fIgnoreRefCount,
    BOOL fPersist)
{
    CMTRACE(TEXT("CmCustomHangUp"));
    MYDBGASSERT(hRasConn || (pszEntry && pszEntry[0]));

    DWORD dwRes = ERROR_SUCCESS;

    //
    // Must have a handle or an entry name
    //

    if (NULL == hRasConn && (NULL == pszEntry || 0 == pszEntry[0]))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // 
    // First try to open the table, if none found then succeed.
    //
    
    CConnectionTable ConnTable;

    if (FAILED(ConnTable.Open()))
    {
        return ERROR_NOT_FOUND;
    }

    //
    // Look up the specified entry
    //

    HRESULT hrRes;

    CM_CONNECTION Connection;
    ZeroMemory(&Connection, sizeof(CM_CONNECTION));
        
    if (hRasConn)
    {
        hrRes = ConnTable.GetEntry(hRasConn, &Connection);
    }
    else
    {
        hrRes = ConnTable.GetEntry(pszEntry, &Connection);
    }
    
    //
    // We have an entry, do the Disconnect
    //

    if (SUCCEEDED(hrRes))
    {               
        if (CM_CONNECTING == Connection.CmState)
        {
            dwRes = ERROR_NOT_FOUND;
        }
        else
        {
            //
            // If the persist flag is not set and the caller is from the desktop
            // then ignore the ref count and do a complete hangup.
            //

//            BOOL fIgnoreRefCount = ((!fPersist) && WhoIsCaller(DT_CMMON | DT_EXPLORER));

            dwRes = Disconnect(&ConnTable, &Connection, fIgnoreRefCount, fPersist);            
        }
    }

    MYVERIFY(SUCCEEDED(ConnTable.Close()));
    
    return dwRes;
}

BOOL IsCustomPropertyEnabled();
BOOL GetCMPFile(LPCWSTR pszEntryName, LPWSTR pszCMP);
BOOL GetCMPFileFromMappingsKey(HKEY hBaseKey, LPCWSTR szEntryName, HANDLE hPrimaryToken, LPWSTR pszCmpFile);
BOOL GetCMSFile(LPWSTR pszCmpFile, LPWSTR pszCmsFile);
DWORD GetCMProperty(LPWSTR pszCmpFile, LPWSTR pszCMSFile, LPWSTR szSection, LPCWSTR pszProperty, PBYTE *ppbValue, DWORD *pdwValueLen, BOOL fAlloc);
DWORD GetMenuItems(LPWSTR pszCmpFile, LPWSTR pszCmsFile, CON_TRAY_MENU_DATA** ppMenuData);
BOOL GetShortName(LPWSTR pszCmpFile, LPWSTR pszSvcName);
BOOL GetProfileDir(LPWSTR pszCmpFile, LPWSTR pszProfDir);

HRESULT HrGetMenuNameAndCmdLine(PWSTR pszString,
                                PWSTR szName, UINT uNameLen,
                                PWSTR szProgram, UINT uProgramLen,
                                PWSTR szParams, UINT uParamsLen);

HRESULT HrFillInConTrayMenuEntry (LPTSTR pszCmpFile, 
    PCWSTR szName,
    PCWSTR szCmdLine,
    PCWSTR szParams,
    CON_TRAY_MENU_ENTRY* pMenuEntry);

HRESULT HrCoTaskMemAlloc(ULONG cb, VOID **ppv);



//+---------------------------------------------------------------------------
//
//  Function:   GetCustomProperty
//
//  Purpose:    This function returns custom properties (Icon and Tray Menu).
//              It is used by the NetCon folder so that we abstract our design
//              from their code.
//
//  Arguments:  pszRasPhoneBook - Ras phone book for this entry. Not used currently,
//                                 but it might be in the future. 
//              pszEntryName - Profile name
//              pszProperty - property to retrieve
//              ppbValue - pointer to a buffer
//              cbValue - if 0, we must allocate memory otherwise the caller
//                          supplied a buffer of this size.
//  
//  Returns:    TRUE or FALSE
//
//+---------------------------------------------------------------------------
extern "C" BOOL WINAPI GetCustomProperty(LPCWSTR pszRasPhoneBook, LPCWSTR pszEntryName, LPWSTR pszProperty, PBYTE *ppbValue, DWORD *cbValue)
{
    BOOL fRetVal = FALSE;
    BOOL fAlloc = FALSE;

    WCHAR szCMP[(MAX_PATH*2)+1]={0};
    WCHAR szCMS[(MAX_PATH*2)+1]={0};

    DWORD dwRes = ERROR_SUCCESS;
    CMTRACE(TEXT("GetCustomProperty - BEGIN ----------------")); 
    
    //
    // Make sure we have all the params that we need
    //
    if (!ppbValue || !pszProperty || !cbValue || !pszEntryName)
    {
        return FALSE;
    }

    if (!OS_NT5)
    {
        return FALSE;
    }
    //
    // Check if the reg key is set in the registry.
    // If it's not set or doesn't exist, then we can proceed and the
    // function returns TRUE.
    //
    if (FALSE == IsCustomPropertyEnabled())
    {
        CMTRACE(TEXT("GetCustomProperty - IsCustomPropertyEnabled() is returning FALSE. Exiting")); 
        return FALSE;
    }

    CMTRACE2(TEXT("GetCustomProperty - Entry Name: %s  Property: %s"), pszEntryName, pszProperty); 

    //
    // Should we alloc? If a buffer has size already, then don't alloc,
    // because the caller supplied their own buffer. (As in the current case of the NetCon folders - for Icons only)
    // Menu we have to allocate
    //
    fAlloc = (((BOOL)*cbValue)? FALSE : TRUE);
    
    //
    // First Get the CMP filename
    //
    if (GetCMPFile((LPCTSTR)pszEntryName, szCMP))
    {
        //CMTRACE(TEXT("GetCustomProperty - After GetCMPFile"));
        //
        // Get the CMS filename
        //
        if (GetCMSFile(szCMP, szCMS))
        {
            //CMTRACE(TEXT("GetCustomProperty - After GetCMSFile"));
            //
            // Figure out which property the caller wants
            //
            if ((0 == lstrcmpiU(L"Icon", pszProperty)) || 
                (0 == lstrcmpiU(L"HideTrayIcon", pszProperty)) || 
                (0 == lstrcmpiU(L"TrayIcon", pszProperty)))
            {
                //CMTRACE(TEXT("GetCustomProperty - ICONS")); 
                
                PBYTE pbValue = NULL;
                DWORD dwValueLen = 0;

                if (FALSE == fAlloc)
                {
                    dwValueLen = *cbValue; // Pass down the buffer size
                    dwRes = GetCMProperty(szCMP, szCMS, TEXT("Connection Manager"), pszProperty, ppbValue, &dwValueLen, fAlloc);
                    if (ERROR_SUCCESS == dwRes)
                    {
                        *cbValue = dwValueLen;

                        fRetVal = TRUE;
                    }
                }
                else
                {
                    dwRes = GetCMProperty(szCMP, szCMS, TEXT("Connection Manager"), pszProperty, &pbValue, &dwValueLen, fAlloc);
                    if (ERROR_SUCCESS == dwRes)
                    {
                        *ppbValue = pbValue;
                        *cbValue = dwValueLen;
                    
                        fRetVal = TRUE;
                    }
                }
            }
            else if (0 == lstrcmpiU(L"Menu Items", pszProperty))
            {
                //CMTRACE(TEXT("GetCustomProperty - MENUS")); 
                CON_TRAY_MENU_DATA *pConTrayMenuData = NULL;
                
                //
                // Currently we don't suppport if users want to allocate their buffers themselves
                // for Tray Menu Items
                //
                if (fAlloc)
                {
                    dwRes = GetMenuItems(szCMP, szCMS, &pConTrayMenuData);
        
                    if (ERROR_SUCCESS == dwRes)
                    {
                        *ppbValue = (PBYTE)pConTrayMenuData;
                        fRetVal = TRUE;
                    }
                }
            }
        }
    }
    
    CMTRACE(TEXT("GetCustomProperty - END ------------------"));
    return fRetVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCMPFile
//
//  Purpose:    This function returns the CMP file path.
//              Need to take a guess and look into the HKLM (Mappings key) first.
//              If the call returns FALSE, we try HKCU to get the CMP path. Since
//              We are being called from a system process, we need to impersonate
//              the user in order to open the HKCU key.
//
//  Arguments:  szEntryName - profile entry name
//              pszCMP - [OUT] .CMP file
//
//  Returns:    TRUE or FALSE
//
//+---------------------------------------------------------------------------
BOOL GetCMPFile(LPCWSTR pszEntryName, LPWSTR pszCMP)
{
    BOOL fRetCode = FALSE;
    LPWSTR pszCmpFile = NULL;
    BOOL fIsAllUser = FALSE;
    HANDLE hImpersonationToken = NULL;   // The token of the thread
    HANDLE hPrimaryToken = NULL;         // The primary token for the new process
    DWORD dwSize = MAX_PATH;
    HKEY hKey;
    HANDLE hBaseKey = NULL;
    HANDLE hFile;
    HRESULT hr = E_FAIL;
    HRESULT hrImpersonate = E_FAIL;
    DWORD dwRes = 0;
    HMODULE hNTDll = NULL;
    HMODULE hAdvapi32 = NULL;
    HMODULE hOle32Dll = NULL;

    if (!OS_NT5)
    {
        return FALSE;
    }

    if (!pszCMP)
    {
        return FALSE;
    }

    typedef HRESULT (WINAPI* pfnCoImpersonateClientSpec)();
    pfnCoImpersonateClientSpec pfnCoImpersonateClient = NULL;

    typedef HRESULT (WINAPI* pfnCoRevertToSelfSpec)();
    pfnCoRevertToSelfSpec pfnCoRevertToSelf = NULL;


    //
    // Check the HKLM key to see if this profile is All-User
    // If not, we'll need to impersonate the logged on user and use HKCU since we are being called
    // from a system account.
    //
    fIsAllUser = GetCMPFileFromMappingsKey(HKEY_LOCAL_MACHINE, pszEntryName, NULL, pszCMP);
    if (FALSE == fIsAllUser) 
    {
        //
        //  Then we have a private profile.  Since netman runs as a system account, and we were called by netman
        //  we must impersonate the client and then make an RTL call to get
        //  the current users HKCU hive before querying the registry for the
        //  cmp path.  We also need to get the user token so that we can expand the
        //  cmp string in the single user case.
        //
        
        hOle32Dll = LoadLibrary(TEXT("ole32.dll"));

        if (hOle32Dll)
        {
            pfnCoRevertToSelf = (pfnCoRevertToSelfSpec)GetProcAddress(hOle32Dll, "CoRevertToSelf");
            pfnCoImpersonateClient = (pfnCoImpersonateClientSpec)GetProcAddress(hOle32Dll, "CoImpersonateClient");
            
            MYDBGASSERT(pfnCoRevertToSelf);
            MYDBGASSERT(pfnCoImpersonateClient);

            if (pfnCoImpersonateClient && pfnCoRevertToSelf)
            {
                hrImpersonate = pfnCoImpersonateClient();
                if (SUCCEEDED(hrImpersonate))
                {
                    //
                    // load ntdll.dll
                    //
                    hNTDll = LoadLibrary(TEXT("ntdll.dll"));
                    hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));

                    MYDBGASSERT(hNTDll);
                    MYDBGASSERT(hAdvapi32);

                    if (hNTDll && hAdvapi32)
                    {
                        typedef NTSTATUS (WINAPI* pfnRtlOpenCurrentUserSpec)(ULONG, PHANDLE);
                        pfnRtlOpenCurrentUserSpec pfnRtlOpenCurrentUser = NULL;
                        pfnRtlOpenCurrentUser = (pfnRtlOpenCurrentUserSpec)GetProcAddress(hNTDll, "RtlOpenCurrentUser");

                        typedef BOOL (WINAPI* pfnDuplicateTokenExSpec)(HANDLE, DWORD, LPSECURITY_ATTRIBUTES, SECURITY_IMPERSONATION_LEVEL, TOKEN_TYPE, PHANDLE);
                        pfnDuplicateTokenExSpec pfnDuplicateTokenEx = NULL;
                        pfnDuplicateTokenEx = (pfnDuplicateTokenExSpec)GetProcAddress(hAdvapi32, "DuplicateTokenEx");

                        typedef BOOL (WINAPI* pfnOpenThreadTokenSpec)(HANDLE, DWORD, BOOL, PHANDLE);
                        pfnOpenThreadTokenSpec pfnOpenThreadToken = NULL;
                        pfnOpenThreadToken = (pfnOpenThreadTokenSpec)GetProcAddress(hAdvapi32, "OpenThreadToken");

                        MYDBGASSERT(pfnRtlOpenCurrentUser);
                        MYDBGASSERT(pfnDuplicateTokenEx);
                        MYDBGASSERT(pfnOpenThreadToken);

                        if (pfnRtlOpenCurrentUser && pfnDuplicateTokenEx && pfnOpenThreadToken)
                        {
                            NTSTATUS ntstat = pfnRtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hBaseKey);
                            hr = HRESULT_FROM_NT(ntstat);

                            if (SUCCEEDED(hr))
                            {
                                //
                                // Create a primary token
                                //
                                if (!pfnOpenThreadToken(
                                        GetCurrentThread(),
                                        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                                        TRUE,
                                        &hImpersonationToken))
                                {
                                    hr = HRESULT_FROM_WIN32(GetLastError()); 
                                }
                                else
                                {
                                    if(!pfnDuplicateTokenEx(hImpersonationToken,
                                        TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE,
                                        NULL,
                                        SecurityImpersonation,
                                        TokenPrimary,
                                        &hPrimaryToken
                                        ))
                                    {
                                        hr = HRESULT_FROM_WIN32(GetLastError()); 
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    hr = hrImpersonate;
                }
            }
        }
        //
        //  Now Open the mappings key and get the cmp file path for a Single User Profile
        //
        if (SUCCEEDED(hr) && hBaseKey)
        {
            fRetCode = GetCMPFileFromMappingsKey((HKEY)hBaseKey, pszEntryName, hPrimaryToken, pszCMP);
        }
    }
    
    if (fIsAllUser)
    {
        fRetCode = TRUE;
    }

    if (SUCCEEDED(hrImpersonate) && pfnCoRevertToSelf)
    {
        hr = pfnCoRevertToSelf();
    }

    if (FALSE == fIsAllUser)
    {
        if (hImpersonationToken)
        {
            CloseHandle(hImpersonationToken);
            hImpersonationToken = NULL;
        }

        if (hPrimaryToken)
        {
            CloseHandle(hPrimaryToken);
            hPrimaryToken = NULL;
        }

        // If it's a valid key that is not NULL then we can close it because we opened it.
        if (hBaseKey && hNTDll)
        {
            typedef NTSTATUS (WINAPI* pfnNtCloseFunc)(HANDLE);
            pfnNtCloseFunc pfnNtClose = NULL;

            pfnNtClose = (pfnNtCloseFunc)GetProcAddress(hNTDll, "NtClose");
            if (pfnNtClose)
            {
                (VOID)pfnNtClose(hBaseKey);
                hBaseKey = NULL;
            }
        }

        if (hNTDll)
        {
            FreeLibrary(hNTDll);
            hNTDll = NULL;
        }

        if (hAdvapi32)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
        }

        if (hOle32Dll)
        {
            FreeLibrary(hOle32Dll);
            hOle32Dll = NULL;
        }
    }


    return fRetCode;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCMProperty
//
//  Purpose:    This function retrieves a property from the .cms file 
//
//  Arguments:  pszCmpFile - .cmp filepath
//              pszCMSFile - .cms filepath
//              szSection - section
//              pszProperty - property to get
//              ppbValue - [IN/OUT] buffer
//              pdwValueLen [IN/OUT] size of buffer
//
//  Returns:    ERROR_SUCCESS or an error code
//
//+---------------------------------------------------------------------------
DWORD GetCMProperty(LPWSTR pszCmpFile, LPWSTR pszCMSFile, LPWSTR szSection, LPCWSTR pszProperty, PBYTE *ppbValue, DWORD *pdwValueLen, BOOL fAlloc)
{
    DWORD dwRet = ERROR_NOT_FOUND;
    WCHAR szIconPath[(2*MAX_PATH) + 1]={0};
    PBYTE pbBuf = NULL;

    if (!pszCmpFile || !pszCMSFile || !szSection || !pszProperty || !ppbValue || !pdwValueLen)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (fAlloc)
    {
        //
        // Only want to clear the incoming variables if we are going to allocate memory,
        // because *pdwValueLen is used to make sure the buffer is big enough if the 
        // caller has allocated it himself
        //
        *ppbValue = NULL;
        *pdwValueLen = 0;
    }

    dwRet = GetPrivateProfileStringU(szSection, pszProperty, TEXT(""), szIconPath, 2*MAX_PATH, pszCMSFile);
    if (0 == dwRet)
    {
        //
        // Failed - This happens when it can't find that property in the section.
        // Since we don't have a default, the caller needs to handle the error.
        //
        dwRet = ERROR_NOT_FOUND; 
    }
    else if (((2*MAX_PATH) - 1) == dwRet)
    {
        //
        // Buffer Too small - for the icons we are using hardcoded buffers from the netcon folder
        // so this shouldn't occur.
        //
        dwRet = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        //
        // Get the CM Dir and append the icon dir
        //
        WCHAR szwDrive[MAX_PATH+1];
        WCHAR szwDir[MAX_PATH+1];
        WCHAR szwFileName[MAX_PATH+1];
        WCHAR szwExtension[MAX_PATH+1];

        _wsplitpath(pszCmpFile, szwDrive, szwDir, szwFileName, szwExtension);   

        //
        // Can't use CmStrCpyAlloc(szwDrive), because this memory is freed by the caller
        // after this DLL get unloaded. CmStrCpyAlloc uses CmMalloc internally and in debug mode
        // CmMalloc checks for memory leaks by increasing an internal counter. 
        // 
        
        DWORD dwDriveLen = lstrlenU(szwDrive) + lstrlenU(szwDir) + lstrlenU(szIconPath);

        if (fAlloc)
        {
            // Alloc
            HRESULT hr = HrCoTaskMemAlloc((dwDriveLen + 1)*sizeof(WCHAR), (LPVOID*)&pbBuf);
            if (pbBuf)
            {
                lstrcpyU((LPTSTR)pbBuf, szwDrive);
                lstrcatU((LPTSTR)pbBuf, szwDir);
                lstrcatU((LPTSTR)pbBuf, szIconPath);

                *ppbValue = pbBuf;
                *pdwValueLen = (dwDriveLen + 1)* sizeof(WCHAR);
                dwRet = ERROR_SUCCESS;
            }
        }
        else
        {
            LPTSTR pszBuf = (LPTSTR)ppbValue;
            
            if (dwDriveLen < *pdwValueLen)
            {
                UINT nNumChars = wsprintfW(pszBuf, L"%s%s%s", szwDrive, szwDir, szIconPath);
                *pdwValueLen = (dwDriveLen+1) * sizeof(WCHAR);
                dwRet = ERROR_SUCCESS;
            }
        }
    }

    return dwRet;
}



BOOL GetCMSFile(LPWSTR pszCmpFile, LPWSTR pszCmsFile)
{
    WCHAR szwDrive[MAX_PATH+1]={0};
    WCHAR szwDir[MAX_PATH+1]={0};
    WCHAR szwFileName[MAX_PATH+1]={0};
    WCHAR szwExtension[MAX_PATH+1]={0};
    WCHAR szwCmDir[MAX_PATH+1]={0};
    
    WCHAR szCmsPathFromCmp[MAX_PATH+1]={0};
    LPWSTR pszActualCmsPath = NULL;

    if (!pszCmpFile || !pszCmsFile)
    {
        return FALSE;
    }

    //  Now split the path
    //
    _wsplitpath(pszCmpFile, szwDrive, szwDir, szwFileName, szwExtension);

    DWORD dwRet = GetPrivateProfileStringU(L"Connection Manager", L"CMSFile", L"", szCmsPathFromCmp, MAX_PATH, pszCmpFile);
    if (dwRet)
    {
        if ((lstrlenU(szwDrive) + lstrlenU(szwDir) + lstrlenU(szCmsPathFromCmp)) < MAX_PATH)
        {
            UINT nNumChars = wsprintfW(pszCmsFile, L"%s%s%s", szwDrive, szwDir, szCmsPathFromCmp);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL GetShortName(LPWSTR pszCmpFile, LPWSTR pszSvcName)
{
    LPTSTR pszShortName = NULL;
    if (!pszCmpFile || !pszSvcName)
    {
        return FALSE;
    }

    WCHAR szwDrive[MAX_PATH+1] = {0};
    WCHAR szwDir[MAX_PATH+1] = {0};
    WCHAR szwFileName[MAX_PATH+1] = {0};
    WCHAR szwExtension[MAX_PATH+1] = {0};

    //  Now split the path
    //
    _wsplitpath(pszCmpFile, szwDrive, szwDir, szwFileName, szwExtension);
            
    if (lstrlenU(szwFileName) < MAX_PATH)
    {
        lstrcpyU(pszSvcName, szwFileName);
        return TRUE;
    }

    return FALSE;
}

BOOL GetProfileDir(LPWSTR pszCmpFile, LPWSTR pszProfDir)
{
    LPWSTR pszProfileDir = NULL;
    WCHAR szProfDir[(2*MAX_PATH)+1] = {0};

    if (!pszCmpFile || !pszProfDir)
    {
        return FALSE;
    }

    WCHAR szwDrive[MAX_PATH+1];
    WCHAR szwDir[MAX_PATH+1];
    WCHAR szwFileName[MAX_PATH+1];
    WCHAR szwExtension[MAX_PATH+1];
    
    //  Now split the path
    //
    _wsplitpath(pszCmpFile, szwDrive, szwDir, szwFileName, szwExtension);
    
    if ((lstrlenU(szwDrive) + lstrlenU(szwDir) + lstrlenU(szwFileName)) < MAX_PATH)
    {
        UINT nNumChars = wsprintfW(pszProfDir, L"%s%s%s\\", szwDrive, szwDir, szwFileName);

        return TRUE;
    }

    return FALSE;
}

BOOL IsCustomPropertyEnabled()
{
    BOOL fRetVal = TRUE; // By default always return TRUE unless the key is set
    HKEY hKey = NULL;
    LONG lRes = 0;
    lRes = RegOpenKeyExU(HKEY_LOCAL_MACHINE, c_pszRegCmRoot, 0, KEY_READ, &hKey);
    
    if (ERROR_SUCCESS == lRes)
    {
        DWORD dwType = REG_DWORD;
        DWORD dwValue = 0;
        DWORD dwSize = sizeof(dwValue);

        lRes = RegQueryValueExU(hKey, L"DisableCustomProperty", 0, &dwType, (LPBYTE)&dwValue, &dwSize);
        if (ERROR_SUCCESS == lRes)
        {
            if (dwValue)
            {
                fRetVal = FALSE;
            }
        }

        RegCloseKey(hKey);
    }

    return fRetVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCMPFileFromMappingsKey
//
//  Purpose:    This function returns the CMP file path from the Mappings key.
//
//  Arguments:  hBaseKey - determines whether it's HKLM or HKCU
//              szEntryName - profile entry name
//              hPrimaryToken - in case of single user profile we use environment
//                              variables, this is used to expand those.
//              pszCmpFile - [OUT] .CMP file
//
//  Returns:    ERROR_SUCCESS or an error code
//
//+---------------------------------------------------------------------------
BOOL GetCMPFileFromMappingsKey(HKEY hBaseKey, LPCWSTR szEntryName, HANDLE hPrimaryToken, LPWSTR pszCmpFile)
{
    HKEY hKey = NULL;
    BOOL fRetVal = FALSE;
    LONG lRes = 0;

    if (!szEntryName || !pszCmpFile)
    {
        return FALSE;
    }

    //
    // Now Open the mappings key and see if this entry name is under HKLM 
    // If yes, then get the cmp file path as well.
    //
    lRes = RegOpenKeyExU(hBaseKey, c_pszRegCmMappings, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == lRes)
    {
        DWORD dwSize = MAX_PATH;
        WCHAR szTemp[(2*MAX_PATH)+1] = {0};
        WCHAR szExpandedTemp[(2*MAX_PATH)+1] = {0};
        DWORD dwType = REG_SZ;

        lRes = RegQueryValueExU(hKey, szEntryName, 0, &dwType, (LPBYTE)&szTemp[0], &dwSize);
        if (ERROR_SUCCESS == lRes)
        {
            HMODULE hUserEnvDll = LoadLibrary(L"userenv.dll");

            if (hUserEnvDll)
            {
                BOOL fRetCode = FALSE;
                typedef BOOL (WINAPI* pfnExpandEnvironmentStringsForUserFunc)(HANDLE, LPCTSTR, LPTSTR, DWORD);

                pfnExpandEnvironmentStringsForUserFunc pfnExpandEnvironmentStringsForUser = NULL;
                
#ifdef UNICODE
                pfnExpandEnvironmentStringsForUser = (pfnExpandEnvironmentStringsForUserFunc)GetProcAddress(hUserEnvDll, "ExpandEnvironmentStringsForUserW");
#else
                pfnExpandEnvironmentStringsForUser = (pfnExpandEnvironmentStringsForUserFunc)GetProcAddress(hUserEnvDll, "ExpandEnvironmentStringsForUserA");
#endif
                
                if (pfnExpandEnvironmentStringsForUser)
                {
                    fRetCode = pfnExpandEnvironmentStringsForUser(hPrimaryToken, szTemp, szExpandedTemp, MAX_PATH);
                    if (fRetCode)
                    {
                        lstrcpyU(pszCmpFile, szExpandedTemp);
                        fRetVal = TRUE;
                    }
                }

                FreeLibrary(hUserEnvDll);
                hUserEnvDll = NULL;
            }

            if (FALSE == fRetVal)
            {
                // 
                // Let's just try copying the actual value we got from the registry. In most cases (All-User) 
                // profiles it shouldn't contain an environment string anyway.
                //
                lstrcpyU(pszCmpFile, szTemp);
                fRetVal = TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    
    return fRetVal;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetPrivateProfileSectionWithAlloc
//
//  Purpose:    This function gets the 'Menu Options' from the .CMS file
//
//  Arguments:  pszCmsFile - .CMS file path
//              pszSection - [OUT] returns the 'Menu Options' section
//              pnSize - [OUT] the size of the returned buffer
//
//  Returns:    ERROR_SUCCESS or an error code
//
//+---------------------------------------------------------------------------
DWORD GetPrivateProfileSectionWithAlloc(LPWSTR pszCmsFile, WCHAR **pszSection, int *pnSize)
{
    DWORD dwRetVal = ERROR_SUCCESS;

    if (!pszSection || !pnSize || !pszCmsFile)
    {
        return ERROR_INVALID_PARAMETER;
    }
    if (!OS_NT5)
    {
        return ERROR_INVALID_PARAMETER;
    }

    const int c_64K= 64*1024;
    int nAllocated = 1024;
    *pnSize = nAllocated - 2;

    while ((nAllocated <= c_64K) && ((*pnSize) == (nAllocated - 2)))
    {
        //      Should never need more than the 4-5 lines we already allocated
        //      but someone might want lots of menu options.
        //
        if (NULL != *pszSection)
        {
            delete (*pszSection);
        }

        *pszSection = new WCHAR[nAllocated];

        if (*pszSection)
        {
            //
            // This will only be executed on Win2K + so we shouldn't need a 'U' function
            //
            *pnSize = GetPrivateProfileSection(L"Menu Options", *pszSection, nAllocated, pszCmsFile);
        }
        else
        {
            dwRetVal = E_OUTOFMEMORY;
            break;
        }

        nAllocated = 2*nAllocated;
    }

    if (nAllocated > c_64K)
    {
        dwRetVal = E_UNEXPECTED;
    }
    if (nAllocated > c_64K || 0 == *pnSize)
    {
        // We need to free this in both cases, because if the size is 0, then the callers don't free this.
        delete *pszSection;
    }
    
    return dwRetVal;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetMenuItems
//
//  Purpose:    This function does the work of reading in the menu items and
//              allocating the structures apporpiately.
//
//  Arguments:  pszCmpFile - .CMP file path
//              pszCmsFile - .CMS file path
//              ppMenuData - [OUT] pointer to contain the menu items
//
//  Returns:    ERROR_SUCCESS or an error code
//
//+---------------------------------------------------------------------------
DWORD GetMenuItems(LPWSTR pszCmpFile, LPWSTR pszCmsFile, CON_TRAY_MENU_DATA** ppMenuData)
{
    HRESULT hr = S_OK;
    DWORD dwRetVal = ERROR_SUCCESS;

    if (!ppMenuData || !pszCmpFile || !pszCmsFile)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppMenuData = NULL;

    CON_TRAY_MENU_DATA * pMenuData = NULL;

    //
    //  Get the menu item section
    //
    WCHAR* pszMenuItemsSection = NULL;
    int nSize;

    hr = GetPrivateProfileSectionWithAlloc(pszCmsFile, &pszMenuItemsSection, &nSize);

    //  Process the menu items
    //
    if (SUCCEEDED(hr) && (nSize>0))
    {
        //  We have menu items to process.  First make a copy of the data
        //  and figure out a line count.
        //
        hr = HrCoTaskMemAlloc(sizeof(CON_TRAY_MENU_DATA), (LPVOID*)&pMenuData);
        if (SUCCEEDED(hr))
        {
            DWORD dwCount = 0;
            WCHAR *pszLine = NULL;
            WCHAR szName[MAX_PATH+1]={0};
            WCHAR szCmdLine[MAX_PATH+1]={0};
            WCHAR szParams[MAX_PATH+1]={0};

            pszLine = pszMenuItemsSection;

            while ((NULL != pszLine) && (0 != *pszLine))
            {
                if (SUCCEEDED(HrGetMenuNameAndCmdLine(pszLine, szName, CELEMS(szName),
                        szCmdLine, CELEMS(szCmdLine), szParams, CELEMS(szParams))))
                {
                    dwCount++;
                }
                pszLine = pszLine + lstrlenW(pszLine) + 1;
            }

            // Now that we have an accurate count, lets
            // allocate the memory for the marshalling and
            // reparse the items.
            //
            hr = HrCoTaskMemAlloc(dwCount*sizeof(CON_TRAY_MENU_ENTRY),
                                  (LPVOID*)&pMenuData->pctme);

            if (SUCCEEDED(hr))
            {
                pMenuData->dwCount = dwCount;

                DWORD dwNumAdded = 0;
                pszLine = pszMenuItemsSection;
                while ((NULL != pszLine) && (0 != *pszLine) && SUCCEEDED(hr))
                {
                    if (SUCCEEDED(HrGetMenuNameAndCmdLine(pszLine, szName, CELEMS(szName), 
                                                          szCmdLine, CELEMS(szCmdLine), 
                                                          szParams, CELEMS(szParams))) && 
                       (dwNumAdded <= dwCount))
                    {
                        hr = HrFillInConTrayMenuEntry(pszCmpFile, szName, szCmdLine, szParams,
                            &(pMenuData->pctme[dwNumAdded]));

                        if (FAILED(hr))
                        {
                            CoTaskMemFree(&pMenuData->pctme);
                        }

                        dwNumAdded++;
                    }
                    pszLine = pszLine + lstrlenW(pszLine) + 1;
                }
            }
            else
            {
                delete pMenuData;
            }
        }
        delete (pszMenuItemsSection);
    }
    
    // Fill in the out param struct if we succeeded, otherwise leave it alone so it will still
    // marshall.
    //
    if (SUCCEEDED(hr))
    {
        *ppMenuData = pMenuData;
    }

    return dwRetVal;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetMenuNameAndCmdLine
//
//  Purpose:    Given a menu item line from a CMS file parses out the Menu item name,
//                              Menu executable, and Menu item parameters.
//
//  Arguments:  pMenuData -- Pointer to a Tray Menu Data struct
//
//  Returns:    S_OK or an error code
//
//+---------------------------------------------------------------------------
HRESULT HrGetMenuNameAndCmdLine(PWSTR pszString,
                                PWSTR szName, UINT uMaxNameLen,
                                PWSTR szProgram, UINT uMaxProgramLen,
                                PWSTR szParams, UINT uMaxParamsLen)
{
    WCHAR*      pszPtr1 = NULL;
    WCHAR*      pszPtr2 = NULL;
    WCHAR       szLine[MAX_PATH+1]={0};
    BOOL        fLong = FALSE;
    HRESULT hr;

    if (!pszString || !szName || !szProgram || !szParams || !uMaxNameLen || !uMaxProgramLen || !uMaxParamsLen)
    {
        return E_INVALIDARG;
    }

    ZeroMemory(szName, uMaxNameLen * sizeof(WCHAR));
    ZeroMemory(szProgram, uMaxProgramLen * sizeof(WCHAR));
    ZeroMemory(szParams, uMaxParamsLen * sizeof(WCHAR));

    lstrcpynW(szLine, pszString, CELEMS(szLine));

    // Process the first portion, the "Name=" part
    //
    pszPtr1 = wcsstr(szLine, L"=");

    if (pszPtr1)
    {
        *pszPtr1 = 0;
        lstrcpynW(szName, szLine, uMaxNameLen);

        // Process next portion, the program name
        //
        pszPtr1++;

        if (pszPtr1)
        {
            // Look for "+" or " " marking end of program portion
            //
            if (*pszPtr1 == L'+')
            {
                pszPtr1++;
                pszPtr2 = wcsstr(pszPtr1, L"+");
                fLong = TRUE;
            }
            else
            {
                // If not a long filename then we have two choices,
                // either a short program name and params or just a
                // short program name.
                //
                pszPtr2 = wcsstr(pszPtr1, L" ");
                fLong = FALSE;
            }

            // Terminate program name and copy
            //
            if (pszPtr2)
            {
                if (*pszPtr2 != 0)
                {
                    *pszPtr2 = 0;
                    pszPtr2++;
                }

                lstrcpynW(szProgram, pszPtr1, uMaxProgramLen);

                // Process final portion, the params
                //
                if (fLong)
                {
                    pszPtr2++; // skip blank
                }

                // Now we are have the param string
                //
                if (pszPtr2)
                {
                    lstrcpynW(szParams, pszPtr2, uMaxParamsLen);
                }
            }
            else
            {
                // Just a program with no params and no space seperator
                // (this happens on memphis)
                //
                lstrcpynW(szProgram, pszPtr1, uMaxProgramLen);
            }
        }
        hr = S_OK;
    }
    else
    {
        //  No entries
        //
        hr =  E_UNEXPECTED;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrFillInConTrayMenuEntry
//
//  Purpose:    Given the elements of a ConTrayMenuEntry struct, the function
//              allocs the memory necessary and copies of the given elements.
//
//  Arguments:  szwName - Display name of the command to show in the tray context menu
//              szwCmdLine - actual command to run for this menu entry
//              szwParams - command params for this command
//              pMenuEntry - pointer to the struct to fill in and execute
//
//  Returns:    S_OK or an error code
//
//+---------------------------------------------------------------------------
HRESULT HrFillInConTrayMenuEntry (LPWSTR pszCmpFile, 
    PCWSTR szName,
    PCWSTR szCmdLine,
    PCWSTR szParams,
    CON_TRAY_MENU_ENTRY* pMenuEntry)
{
    HRESULT hr;

    WCHAR szProfileDir[(2*MAX_PATH)+1]={0};
    WCHAR szSvcName[(2*MAX_PATH)+1]={0};
    
    ZeroMemory(pMenuEntry, sizeof(CON_TRAY_MENU_ENTRY));

    (VOID)GetShortName(pszCmpFile, szSvcName);
    (VOID)GetProfileDir(pszCmpFile, szProfileDir);

    hr = HrCoTaskMemAlloc ((lstrlenW(szName)+1)*sizeof(WCHAR),
                               (LPVOID*)&(pMenuEntry->szwMenuText));
    if (SUCCEEDED(hr))
    {
        lstrcpyW(pMenuEntry->szwMenuText, szName);
        hr = HrCoTaskMemAlloc ((lstrlenW(szParams)+1)*sizeof(WCHAR),
                                                   (LPVOID*)&(pMenuEntry->szwMenuParams));
        if (S_OK == hr)
        {
            lstrcpyW(pMenuEntry->szwMenuParams, szParams);
            if (0 == wcsncmp(szSvcName, szCmdLine,
                    lstrlenW(szSvcName)))
            {
                //
                //      Then we have an included file.  Add the profile dir path
                //
                // Take out the "short service name" because it's already included in the path
                PCWSTR pszFileName = szCmdLine + lstrlenW(szSvcName) + 1;
                hr = HrCoTaskMemAlloc ((lstrlenW(pszFileName)+lstrlenW(szProfileDir)+1)*sizeof(WCHAR),
                                                           (LPVOID*)&(pMenuEntry->szwMenuCmdLine));
                if (S_OK == hr)
                {
                    lstrcpyW(pMenuEntry->szwMenuCmdLine, szProfileDir);
                    lstrcatW(pMenuEntry->szwMenuCmdLine, pszFileName);
                }
            }
            else
            {
                hr = HrCoTaskMemAlloc ((lstrlenW(szCmdLine)+1)*sizeof(WCHAR),
                                                           (LPVOID*)&(pMenuEntry->szwMenuCmdLine));
                if (S_OK == hr)
                {
                    lstrcpyW(pMenuEntry->szwMenuCmdLine, szCmdLine);
                }
            }
        }
    }
    if (FAILED(hr))
    {
        //
        //      We Failed so free the memory
        //
        CoTaskMemFree(pMenuEntry->szwMenuText);
        CoTaskMemFree(pMenuEntry->szwMenuCmdLine);
        CoTaskMemFree(pMenuEntry->szwMenuParams);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCoTaskMemAlloc
//
//  Purpose:    Call CoTaskMemAlloc but return an HRESULT.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Returned pointer to bytes.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   31 May 1997
//
//  Notes:
//
HRESULT
HrCoTaskMemAlloc (
    ULONG   cb,
    VOID**  ppv)
{
    HRESULT hr = S_OK;
    *ppv = CoTaskMemAlloc (cb);
    if (!*ppv)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\pbmap.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 pbmap.cpp
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Implementation of CPBMap. Phonebook mapping object
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 nickball   Created    03/12/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
// Definitions
//

#define CPBMAP_BITS_FOR_PB			10
#define CPBMAP_BITS_FOR_IDX			((sizeof(DWORD)*8)-CPBMAP_BITS_FOR_PB)
#define CPBMAP_PB_CNT				(1L<<CPBMAP_BITS_FOR_PB)
#define CPBMAP_IDX_CNT				(1L<<CPBMAP_BITS_FOR_IDX)
#define CPBMAP_ENCODE_PB(pb)		((pb)<<CPBMAP_BITS_FOR_IDX)
#define CPBMAP_ENCODE_IDX(idx)		(idx)
#define CPBMAP_DECODE_PB(cookie)	((cookie)>>CPBMAP_BITS_FOR_IDX)
#define CPBMAP_DECODE_IDX(cookie)	((cookie)&(CPBMAP_IDX_CNT-1))

extern "C" HRESULT WINAPI PhoneBookLoad(LPCSTR pszISP, DWORD_PTR *pdwPB);
extern "C" HRESULT WINAPI PhoneBookUnload(DWORD_PTR dwPB);

//
// Types
//

typedef struct tagCPBData 
{
	DWORD_PTR dwPB;
	DWORD dwParam;
} CPBD, *PCPBD;


//
// Implementation
// 

CPBMap::CPBMap() 
{

	m_nCnt = 0;
	m_pvData = NULL;
}


CPBMap::~CPBMap() 
{
	UINT nIdx;

	for (nIdx=0;nIdx<m_nCnt;nIdx++) 
	{
		PhoneBookUnload(((PCPBD) m_pvData)[nIdx].dwPB);
	}
	m_nCnt = 0;
	CmFree(m_pvData);
	m_pvData = NULL;
}


DWORD CPBMap::Open(LPCSTR pszISP, DWORD dwParam) 
{
	PCPBD pData;
	HRESULT hr;

	if (m_nCnt == CPBMAP_PB_CNT) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	
    pData = (PCPBD) CmMalloc((m_nCnt+1)*sizeof(*pData));

    if (pData)
    {
        hr = PhoneBookLoad(pszISP, &pData[m_nCnt].dwPB);

        if (hr == ERROR_SUCCESS) 
        {
            pData[m_nCnt].dwParam = dwParam;
            CopyMemory(pData, m_pvData, m_nCnt*sizeof(*pData));
            CmFree(m_pvData);
            m_pvData = pData;
            m_nCnt++;
        } 
        else 
        {
            CmFree(pData);
            SetLastError(hr);
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("CPBMap::Open -- unable to allocate pData"));
        hr = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError(hr);
    }

	return ((hr == ERROR_SUCCESS) ? (m_nCnt-1) : CPBMAP_ERROR);
}


DWORD CPBMap::ToCookie(DWORD_PTR dwPB, DWORD dwIdx, DWORD *pdwParam) 
{
	DWORD dwPBIdx;

#ifdef DEBUG
	DWORD dwTmp = CPBMAP_IDX_CNT;
#endif
	
	if (dwIdx >= CPBMAP_IDX_CNT) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}

	for (dwPBIdx=0; dwPBIdx < m_nCnt; dwPBIdx++) 
	{
		if (dwPB == ((PCPBD) m_pvData)[dwPBIdx].dwPB) 
		{
			break;
		}
	}
	
    if (dwPBIdx == m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	
    if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwPBIdx].dwParam;
	}
	
    return (CPBMAP_ENCODE_PB(dwPBIdx)|CPBMAP_ENCODE_IDX(dwIdx));
}


DWORD_PTR CPBMap::PBFromCookie(DWORD dwCookie, DWORD *pdwParam) 
{
	DWORD dwPBIdx;

	dwPBIdx = CPBMAP_DECODE_PB(dwCookie);
	if (dwPBIdx >= m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwPBIdx].dwParam;
	}
	return (((PCPBD) m_pvData)[dwPBIdx].dwPB);
}


DWORD CPBMap::IdxFromCookie(DWORD dwCookie, DWORD *pdwParam) 
{
	DWORD dwPBIdx;

	dwPBIdx = CPBMAP_DECODE_PB(dwCookie);
	if (dwPBIdx >= m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwPBIdx].dwParam;
	}
	return (CPBMAP_DECODE_IDX(dwCookie));
}


DWORD_PTR CPBMap::GetPBByIdx(DWORD_PTR dwIdx, DWORD *pdwParam) 
{
	if (dwIdx >= m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}

	if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwIdx].dwParam;
	}

	return (((PCPBD) m_pvData)[dwIdx].dwPB);
}


DWORD CPBMap::GetCnt() 
{

	return (m_nCnt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\pb.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pb.cpp 
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Handle the phone book dialog and call cmpbk32.dll.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created Header   1/14/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#define MAX_PB_WAIT 30000       // max miliiseconds to wait for PB mutex     

//+----------------------------------------------------------------------------
//
// Function:  ExtendArray
//
// Synopsis:  Increase the array for one element as the size nSize
//            Reallocate and copy *ppvArray and increase *pnCount
//
// Arguments: void **ppvArray - the point to the array pointer
//            size_t nSize - the size of one element
//            UINT *pnCount - the number of element currently in the array
//
// Returns:   
//
// History:   feng sun Created Header    1/14/98
//
//+----------------------------------------------------------------------------
static void ExtendArray(IN OUT void **ppvArray, size_t nSize, IN OUT UINT *pnCount) 
{
    void *pvTmp;

    if (NULL != ppvArray && NULL != pnCount)
    {
        pvTmp = CmMalloc(nSize*(*pnCount+1));
        if (NULL != pvTmp)
        {
            CopyMemory(pvTmp,*ppvArray,nSize*(*pnCount));
            CmFree(*ppvArray);
            *ppvArray = pvTmp;
            (*pnCount)++;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  struct ServiceInfo
//
//  Synopsis:   Save the information of a service under .cms [Service Types]
//
//  History:    fengsun created     1/14/97
//
//----------------------------------------------------------------------------

typedef struct tagServiceInfo 
{
    DWORD_PTR dwPB;
    UINT nServiceString;  
    PPBFS pFilter;
    PPBFS pFilterA;
    PPBFS pFilterB;
    LPTSTR pszFile;
} ServiceInfo;


class CPhoneBookInfo 
{
    public:
        CPhoneBookInfo();
        ~CPhoneBookInfo();
        BOOL Load(LPCTSTR pszFile, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs);
        void LoadServiceTypes(HWND hwndDlg, UINT nIdServiceType, LPCTSTR pszServiceType);
        void LoadCountries(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId);
        void LoadRegions(HWND hwndDlg, UINT nIdRegion, LPCTSTR pszRegionName);
        void LoadNumbers(HWND hwndDlg,
                         UINT nIdNumberA,
                         UINT nIdNumberB,
                         UINT nIdMore,
                         LPCTSTR pszPhoneNumber,
                         LPCTSTR pszPhoneBookFile);
        //BOOL GetDisp(DWORD dwCookie, LPTSTR pszDisp, DWORD *pdwDisp);
        BOOL GetDesc(DWORD dwCookie, LPTSTR pszDesc, DWORD *pdwDesc);
        BOOL HasMoreNumbers();
        BOOL GetCanonical(DWORD dwCookie, LPTSTR pszCanonical, DWORD *pdwCanonical);
        BOOL GetNonCanonical(DWORD dwCookie, LPTSTR pszNonCanonical, DWORD *pdwNonCanonical);
        LPCTSTR GetFile(DWORD dwCookie);
        BOOL GetDUN(DWORD dwCookie, LPTSTR pszDUN, DWORD *pdwDUN);
    private:
        BOOL LoadFile(LPCTSTR pszFile, PPBFS pFilterA, PPBFS pFilterB);
        BOOL ServiceCB(LPCTSTR pszSvc,
                       PPBFS pFilter,
                       PPBFS pFilterA,
                       PPBFS pFilterB,
                       DWORD dwPB,
                       LPCTSTR pszFile);
        void LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam);
        void LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam);
        void LoadCountriesA(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId);
        void LoadCountriesW(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId);

        CPBMap m_Map;
        UINT m_nServiceString;
        LPTSTR *m_ppszServiceString;
        UINT m_nServiceInfo;            // the number of elements in m_psiServiceInfo
        ServiceInfo *m_psiServiceInfo;  // a array to save the information of all the services
                                        // under [Service Types]
        UINT m_nIdServiceType;
        UINT m_nIdCountry;
        UINT m_nIdRegion;
        UINT *m_pnRegionIdx;
        UINT m_nRegionIdx;
        typedef struct {
            CPhoneBookInfo *pInfo;
            PPBFS pFilterA;
            PPBFS pFilterB;
            DWORD dwPB;
            LPCSTR pszFile;
        } SCBS;
        friend BOOL WINAPI _ServiceCB(LPCSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam);

        friend BOOL WINAPI _ReferenceCB(LPCSTR pszFile,
                                        LPCSTR pszURL,
                                        PPBFS pFilterA,
                                        PPBFS pFilterB,
                                        DWORD_PTR dwParam);
        friend void WINAPI _LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam);
        friend void WINAPI _LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam);
};


LPCTSTR CPhoneBookInfo::GetFile(DWORD dwCookie) 
{
    DWORD dwParam;

    CMTRACE(TEXT("CPhoneBookInfo::GetFile"));

    DWORD_PTR dwPB = m_Map.PBFromCookie(dwCookie, &dwParam);

    if (dwPB == CPBMAP_ERROR) 
    {
        return (TEXT(""));
    }

    MYDBGASSERT(dwParam < m_nServiceInfo);
    
    return (m_psiServiceInfo[dwParam].pszFile);
}

/*
BOOL CPhoneBookInfo::GetDisp(DWORD dwCookie, LPTSTR pszDisp, DWORD *pdwDisp) 
{

    MYDBG(("CPhoneBookInfo::GetDisp"));

    return (PhoneBookGetPhoneDisp(m_Map.PBFromCookie(dwCookie),m_Map.IdxFromCookie(dwCookie),pszDisp,pdwDisp));
}
*/

BOOL CPhoneBookInfo::GetDesc(DWORD dwCookie, LPTSTR pszDesc, DWORD *pdwDesc) 
{
#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwDesc;
    LPSTR pszAnsiDesc = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiDesc)
    {
        bReturn = PhoneBookGetPhoneDesc(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), pszAnsiDesc, pdwDesc);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiDesc, -1, pszDesc, dwSize));

        CmFree(pszAnsiDesc);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneDesc(m_Map.PBFromCookie(dwCookie),m_Map.IdxFromCookie(dwCookie),pszDesc,pdwDesc));
#endif
    
}


BOOL CPhoneBookInfo::GetCanonical(DWORD dwCookie, LPTSTR pszCanonical, DWORD *pdwCanonical) 
{

#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwCanonical;
    LPSTR pszAnsiCanonical = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiCanonical)
    {
        bReturn = PhoneBookGetPhoneCanonical(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
            pszAnsiCanonical, pdwCanonical);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiCanonical, -1, pszCanonical, dwSize));

        CmFree(pszAnsiCanonical);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneCanonical(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
        pszCanonical, pdwCanonical));
#endif

}

BOOL CPhoneBookInfo::GetNonCanonical(DWORD dwCookie, LPTSTR pszNonCanonical, DWORD *pdwNonCanonical) 
{

#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwNonCanonical;
    LPSTR pszAnsiNonCanonical = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiNonCanonical)
    {
        bReturn = PhoneBookGetPhoneNonCanonical(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
            pszAnsiNonCanonical, pdwNonCanonical);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiNonCanonical, -1, pszNonCanonical, dwSize));

        CmFree(pszAnsiNonCanonical);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneNonCanonical(m_Map.PBFromCookie(dwCookie),m_Map.IdxFromCookie(dwCookie),pszNonCanonical,pdwNonCanonical));
#endif

}

BOOL CPhoneBookInfo::GetDUN(DWORD dwCookie, LPTSTR pszDUN, DWORD *pdwDUN) 
{

#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwDUN;
    LPSTR pszAnsiDUN = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiDUN)
    {
        bReturn = PhoneBookGetPhoneDUN(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
            pszAnsiDUN, pdwDUN);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiDUN, -1, pszDUN, dwSize));

        CmFree(pszAnsiDUN);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneDUN(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
        pszDUN, pdwDUN));
#endif

}


CPhoneBookInfo::CPhoneBookInfo() 
{

    m_nServiceString = 0;
    m_ppszServiceString = NULL;
    m_nServiceInfo = 0;
    m_psiServiceInfo = NULL;
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
}


CPhoneBookInfo::~CPhoneBookInfo() 
{

    while (m_nServiceString) 
    {
        CmFree(m_ppszServiceString[--m_nServiceString]);
    }
    
    CmFree(m_ppszServiceString);
    m_ppszServiceString = NULL;
    
    while (m_nServiceInfo) 
    {
        PhoneBookFreeFilter(m_psiServiceInfo[m_nServiceInfo-1].pFilter);
        PhoneBookFreeFilter(m_psiServiceInfo[m_nServiceInfo-1].pFilterA);
        PhoneBookFreeFilter(m_psiServiceInfo[m_nServiceInfo-1].pFilterB);
        CmFree(m_psiServiceInfo[m_nServiceInfo-1].pszFile);
        m_nServiceInfo--;
    }
    
    CmFree(m_psiServiceInfo);
    m_psiServiceInfo = NULL;
    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
}

BOOL PhoneBookParseInfoWrapper(LPCTSTR pszFile, PhoneBookParseInfoStruct* piInfo)
{
#ifdef UNICODE
    BOOL bReturn;

    LPSTR pszAnsiFile = WzToSzWithAlloc(pszFile);

    if (NULL == pszAnsiFile)
    {
        return FALSE;
    }
    else
    {
        bReturn = PhoneBookParseInfo(pszAnsiFile, piInfo);
        CmFree(pszAnsiFile);
    }

    return bReturn;
#else
    return PhoneBookParseInfo(pszFile, piInfo);
#endif

}

BOOL CPhoneBookInfo::Load(LPCTSTR pszFile, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs) 
{
    PhoneBookParseInfoStruct iInfo;
    BOOL bRes = FALSE;

    CMTRACE(TEXT("CPhoneBookInfo::Load"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    if (!pszFile) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
    ZeroMemory(&iInfo,sizeof(iInfo));
    iInfo.dwSize = sizeof(iInfo);

    if (fHasValidTopLevelPBK) 
    {
        if (!PhoneBookParseInfoWrapper(pszFile,&iInfo)) 
        {
            return (FALSE);
        }
        bRes = LoadFile(pszFile,iInfo.pFilterA,iInfo.pFilterB);
        PhoneBookFreeFilter(iInfo.pFilterA);
        PhoneBookFreeFilter(iInfo.pFilterB);
        if (!bRes) 
        {
            return (FALSE);
        }
    }

    if (fHasValidReferencedPBKs) 
    {
        iInfo.pfnRef = _ReferenceCB;
        iInfo.dwRefParam = (DWORD_PTR) this;
        if (!PhoneBookParseInfoWrapper(pszFile,&iInfo)) 
        {
            return (FALSE);
        }
        PhoneBookFreeFilter(iInfo.pFilterA);
        PhoneBookFreeFilter(iInfo.pFilterB);
    }
    
    return (TRUE);
}


void CPhoneBookInfo::LoadServiceTypes(HWND hwndDlg, UINT nIdServiceType, LPCTSTR pszServiceType) 
{
    UINT nIdx;
    UINT nTmpIdx;

    CMTRACE(TEXT("CPhoneBookInfo::LoadServiceTypes"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdServiceType = nIdServiceType;
    SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_RESETCONTENT,0,0);

    for (nIdx=0; nIdx < m_nServiceString; nIdx++) 
    { 
        nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_ADDSTRING, 0, (LPARAM) m_ppszServiceString[nIdx]);
        SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_SETITEMDATA, nTmpIdx, nIdx);
    }
    
    if (SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_GETCOUNT, 0, 0) > 1) 
    {
        LPTSTR pszDesc = NULL;

        EnableWindow(GetDlgItem(hwndDlg, nIdServiceType), TRUE);

        //
        // If the service type is empty, select the first type as a default
        //

        if ((!pszServiceType) || pszServiceType[0] == '\0')
        {
            pszDesc = CmStrCpyAlloc(m_ppszServiceString[0]); 
        }
        else
        {
            pszDesc = CmStrCpyAlloc(pszServiceType);
        }
            
        //
        // Search for the specified default and if found, make it the current
        // selection. Previously, we did this in the loop above, but 16-bit 
        // combos, don't remember the CURSEL when strings are added.
        //

        nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg, 
                                             nIdServiceType, 
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM) -1,
                                             (LPARAM) pszDesc);
        if (nTmpIdx == CB_ERR) 
        {
            nTmpIdx = 0;
        }

        SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_SETCURSEL, nTmpIdx, 0);

        CmFree(pszDesc);
    } 
    else 
    {
        EnableWindow(GetDlgItem(hwndDlg, nIdServiceType), FALSE);
    }
}


typedef struct tagLoadCountriesCBStruct 
{
    DWORD_PTR dwPB;
    HWND hwndDlg;
    UINT nId;
    DWORD dwCountryId;
} LoadCountriesCBStruct;


//
//  Note: this function and its mirror function _LoadCountriesCBW must stay in sync
//
static void WINAPI _LoadCountriesCBA(unsigned int nIdx, DWORD_PTR dwParam) 
{
    LoadCountriesCBStruct *pParam = (LoadCountriesCBStruct *) dwParam;
    CHAR szCountry[256];
    UINT nTmpIdx;
    DWORD dwCountryId = PhoneBookGetCountryId(pParam->dwPB, nIdx);
    DWORD dwLen;

    szCountry[0] = '\0';

    dwLen = sizeof(szCountry) / sizeof(CHAR);
    PhoneBookGetCountryNameA(pParam->dwPB, nIdx, szCountry, &dwLen);
    wsprintfA(szCountry + lstrlenA(szCountry), " (%u)", dwCountryId);

    nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM)szCountry);
    
    if (nTmpIdx != CB_ERR) 
    {
        return;
    }
    
    nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_ADDSTRING, 0, (LPARAM) szCountry);
    
    SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETITEMDATA, nTmpIdx, dwCountryId);
    
    if (pParam->dwCountryId && (dwCountryId == pParam->dwCountryId)) 
    {
        SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETCURSEL, nTmpIdx, 0);
    }
}

//
//  Note: this function and its mirror function _LoadCountriesCBA must stay in sync
//
static void WINAPI _LoadCountriesCBW(unsigned int nIdx, DWORD_PTR dwParam) 
{
    LoadCountriesCBStruct *pParam = (LoadCountriesCBStruct *) dwParam;
    WCHAR szCountry[256];
    UINT nTmpIdx;
    DWORD dwCountryId = PhoneBookGetCountryId(pParam->dwPB, nIdx);
    DWORD dwLen;

    szCountry[0] = L'\0';

    dwLen = sizeof(szCountry) / sizeof(WCHAR);
    PhoneBookGetCountryNameW(pParam->dwPB, nIdx, szCountry, &dwLen);
    wsprintfW(szCountry + lstrlenW(szCountry), L" (%u)", dwCountryId);

    nTmpIdx = (UINT) SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM)szCountry);
    
    if (nTmpIdx != CB_ERR) 
    {
        return;
    }
    
    nTmpIdx = (UINT) SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_ADDSTRING, 0, (LPARAM) szCountry);

    SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_SETITEMDATA, nTmpIdx, dwCountryId);
    
    if (pParam->dwCountryId && (dwCountryId == pParam->dwCountryId)) 
    {
        SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_SETCURSEL, nTmpIdx, 0);
    }
}


void CPhoneBookInfo::LoadCountries(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId) 
{
    CMTRACE(TEXT("CPhoneBookInfo::LoadCountries"));

    if (OS_NT51)
    {
        return LoadCountriesW(hwndDlg, nIdCountry, dwCountryId);
    }
    else
    {
        return LoadCountriesA(hwndDlg, nIdCountry, dwCountryId);
    }
}

//
//  Note: this function and its mirror function LoadCountriesW must stay in sync
//
void CPhoneBookInfo::LoadCountriesA(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId) 
{
    UINT nIdx;
    DWORD_PTR nServiceType;

    CMTRACE(TEXT("CPhoneBookInfo::LoadCountriesA"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdCountry = nIdCountry;
    SendDlgItemMessageA(hwndDlg, nIdCountry, CB_RESETCONTENT, 0, 0);
    
    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETCURSEL, 0, 0);

    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    nServiceType = SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETITEMDATA, nIdx, 0);
    MYDBGASSERT(nServiceType<m_nServiceInfo);
    
    for (nIdx=0; nIdx < m_nServiceInfo; nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == nServiceType) 
        {
            LoadCountriesCBStruct sParam = {m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                            hwndDlg,
                                            nIdCountry,
                                            dwCountryId?dwCountryId:PhoneBookGetCurrentCountryId()};

            PhoneBookEnumCountries(m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                   _LoadCountriesCBA,
                                   m_psiServiceInfo[nIdx].pFilter,
                                   (DWORD_PTR) &sParam);
        }
    }
    
    if ((SendDlgItemMessageA(hwndDlg,nIdCountry,CB_GETCURSEL,0,0) == CB_ERR) &&
        (SendDlgItemMessageA(hwndDlg,nIdCountry,CB_GETCOUNT,0,0) != 0)) 
    {
        SendDlgItemMessageA(hwndDlg,nIdCountry,CB_SETCURSEL,0,0);
    }
}


//
//  Note: this function and its mirror function LoadCountriesA must stay in sync
//
void CPhoneBookInfo::LoadCountriesW(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId) 
{
    UINT nIdx;
    DWORD_PTR nServiceType;

    CMTRACE(TEXT("CPhoneBookInfo::LoadCountriesW"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdCountry = nIdCountry;
    SendDlgItemMessageW(hwndDlg, nIdCountry, CB_RESETCONTENT, 0, 0);
    
    nIdx = (UINT) SendDlgItemMessageW(hwndDlg, m_nIdServiceType, CB_GETCURSEL, 0, 0);

    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    nServiceType = SendDlgItemMessageW(hwndDlg, m_nIdServiceType, CB_GETITEMDATA, nIdx, 0);
    MYDBGASSERT(nServiceType<m_nServiceInfo);
    
    for (nIdx=0; nIdx < m_nServiceInfo; nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == nServiceType) 
        {
            LoadCountriesCBStruct sParam = {m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                            hwndDlg,
                                            nIdCountry,
                                            dwCountryId?dwCountryId:PhoneBookGetCurrentCountryId()};

            PhoneBookEnumCountries(m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                   _LoadCountriesCBW,
                                   m_psiServiceInfo[nIdx].pFilter,
                                   (DWORD_PTR) &sParam);
        }
    }
    
    if ((SendDlgItemMessageW(hwndDlg,nIdCountry,CB_GETCURSEL,0,0) == CB_ERR) &&
        (SendDlgItemMessageW(hwndDlg,nIdCountry,CB_GETCOUNT,0,0) != 0)) 
    {
        SendDlgItemMessageW(hwndDlg,nIdCountry,CB_SETCURSEL,0,0);
    }
}


typedef struct tagLoadRegionsCBStruct 
{
    CPhoneBookInfo *pPhoneBook;
    DWORD_PTR dwPB;
    HWND hwndDlg;
    UINT nId;
    LPCSTR pszRegionName;
    UINT nServiceInfo;
} LoadRegionsCBStruct;


void CPhoneBookInfo::LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam) 
{
    UINT nTmpIdx;

    LoadRegionsCBStruct *pParam = (LoadRegionsCBStruct *) dwParam;
    CHAR szRegionName[256];
    DWORD dwLen;

    dwLen = sizeof(szRegionName) / sizeof(CHAR);
    PhoneBookGetRegionNameA(pParam->dwPB, nIdx, szRegionName, &dwLen);
    ExtendArray((void **) &m_pnRegionIdx, sizeof(*m_pnRegionIdx)*m_nServiceInfo, &m_nRegionIdx);
    
    for (nTmpIdx = 0; nTmpIdx < m_nServiceInfo; nTmpIdx++) 
    {
        m_pnRegionIdx[m_nServiceInfo*(m_nRegionIdx-1) + nTmpIdx] = UINT_MAX;
    }
    
    nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_FINDSTRINGEXACT, 0, (LPARAM) szRegionName);
    
    if (nTmpIdx == CB_ERR) 
    {
        nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_ADDSTRING, 0, (LPARAM) szRegionName);
        
        SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETITEMDATA, nTmpIdx, m_nRegionIdx - 1);

        if (pParam->pszRegionName && (lstrcmpA(szRegionName, pParam->pszRegionName) == 0)) 
        {
            SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETCURSEL, nTmpIdx, 0);
        }

        m_pnRegionIdx[m_nServiceInfo*(m_nRegionIdx-1) + pParam->nServiceInfo] = nIdx;

    } 
    else 
    {
        DWORD_PTR dwTmp = SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_GETITEMDATA, nTmpIdx, 0);
        m_pnRegionIdx[m_nServiceInfo*dwTmp + pParam->nServiceInfo] = nIdx;
    }
}

static void WINAPI _LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam) 
{

    ((LoadRegionsCBStruct *) dwParam)->pPhoneBook->LoadRegionsCB(nIdx,dwParam);
}


void CPhoneBookInfo::LoadRegions(HWND hwndDlg, UINT nIdRegion, LPCTSTR pszRegionName) 
{
    UINT nIdx;
    DWORD dwServiceType;
    DWORD dwCountryID;

    CMTRACE(TEXT("CPhoneBookInfo::LoadRegions"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdRegion = nIdRegion;
    SendDlgItemMessageU(hwndDlg,nIdRegion,CB_RESETCONTENT,0,0);
    
    nIdx = (UINT) SendDlgItemMessageU(hwndDlg,m_nIdServiceType,CB_GETCURSEL,0,0);
    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    dwServiceType = (DWORD)SendDlgItemMessageU(hwndDlg,m_nIdServiceType,CB_GETITEMDATA,nIdx,0);
    MYDBGASSERT(dwServiceType<m_nServiceInfo);
    
    nIdx = (UINT) SendDlgItemMessageU(hwndDlg,m_nIdCountry,CB_GETCURSEL,0,0);
    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    dwCountryID = (DWORD)SendDlgItemMessageU(hwndDlg,m_nIdCountry,CB_GETITEMDATA,nIdx,0);
    for (nIdx=0;nIdx<m_nServiceInfo;nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == dwServiceType) 
        {

#ifdef UNICODE
            LPSTR pszAnsiRegionName = WzToSzWithAlloc(pszRegionName);

            if (NULL == pszAnsiRegionName)
            {
                return;
            }
#endif
            LoadRegionsCBStruct sParam = {this,
                                          m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                          hwndDlg,
                                          nIdRegion,
#ifdef UNICODE
                                          pszAnsiRegionName,
#else
                                          pszRegionName,
#endif
                                          nIdx};

            PhoneBookEnumRegions(sParam.dwPB,
                                 _LoadRegionsCB,
                                 dwCountryID,
                                 m_psiServiceInfo[nIdx].pFilter,
                                 (DWORD_PTR) &sParam);
#ifdef UNICODE
            CmFree(pszAnsiRegionName);
#endif
        }
    }
    
    if (SendDlgItemMessageU(hwndDlg,nIdRegion,CB_GETCOUNT,0,0) != 0)
    {
        EnableWindow(GetDlgItem(hwndDlg,nIdRegion),TRUE); /* 10763 */
        EnableWindow(GetDlgItem(hwndDlg, IDC_PHONEBOOK_REGION_STATIC), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg,nIdRegion),FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_PHONEBOOK_REGION_STATIC), FALSE);
    }

    if ((SendDlgItemMessageU(hwndDlg,nIdRegion,CB_GETCURSEL,0,0) == CB_ERR) &&
        (SendDlgItemMessageU(hwndDlg,nIdRegion,CB_GETCOUNT,0,0) != 0)) 
    {
        SendDlgItemMessageU(hwndDlg,nIdRegion,CB_SETCURSEL,0,0);
    }
}


typedef struct tagLoadNumbersCBStruct 
{
    CPhoneBookInfo *pPhoneBook;
    DWORD_PTR dwPB;
    HWND hwndDlg;
    UINT nIdA;
    UINT nIdB;
    UINT nIdMore;
    PPBFS pFilterA;
    PPBFS pFilterB;
    LPCSTR pszPhoneNumber;
    LPCSTR pszPhoneBookFile;
} LoadNumbersCBStruct;


void CPhoneBookInfo::LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam) 
{
    UINT nTmpIdx;

    LoadNumbersCBStruct *pParam = (LoadNumbersCBStruct *) dwParam;
    CHAR szPhoneNumber[256];
    DWORD dwType = PhoneBookGetPhoneType(pParam->dwPB, nIdx);
    UINT nId;
    UINT nOtherId;
    DWORD dwLen;
    BOOL bMatch = FALSE;
    DWORD dwCookie = m_Map.ToCookie(pParam->dwPB, nIdx);
    LPSTR pszAnsiPhoneBookFile;

#ifdef UNICODE
    pszAnsiPhoneBookFile = WzToSzWithAlloc(GetFile(dwCookie));

    if (NULL == pszAnsiPhoneBookFile)
    {
        CMASSERTMSG(FALSE, TEXT("CPhoneBookInfo::LoadNumbersCB -- Insufficient memory for Wide to Ansi conversion."));
        goto exit;
    }
#else
    pszAnsiPhoneBookFile = GetFile(dwCookie);
#endif


    if (PhoneBookMatchFilter(pParam->pFilterA,dwType)) 
    {
        nId = pParam->nIdA;
        nOtherId = pParam->nIdB;
    } 
    else if (PhoneBookMatchFilter(pParam->pFilterB,dwType)) 
    {
        nId = pParam->nIdB;
        nOtherId = pParam->nIdA;
    } 
    else 
    {
        goto exit;
    }
    
    if (pParam->pszPhoneNumber && pParam->pszPhoneBookFile) 
    {
        dwLen = sizeof(szPhoneNumber) / sizeof(TCHAR);

        PhoneBookGetPhoneCanonical(pParam->dwPB, nIdx, szPhoneNumber, &dwLen);

        if ((lstrcmpA(szPhoneNumber, pParam->pszPhoneNumber) == 0) &&
            (lstrcmpA(pszAnsiPhoneBookFile, pParam->pszPhoneBookFile) == 0)) 
        {
            bMatch = TRUE;
        }
    }
    
    if (GetDlgItem(pParam->hwndDlg,nId)) 
    {

        dwLen = sizeof(szPhoneNumber) / sizeof(TCHAR);

        PhoneBookGetPhoneDisp(pParam->dwPB, nIdx, szPhoneNumber, &dwLen);
        nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, nId, LB_FINDSTRINGEXACT, (WPARAM) -1, 
            (LPARAM) szPhoneNumber);

        if (nTmpIdx != LB_ERR) 
        {
            goto exit;
        }

        nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, nId, LB_ADDSTRING, 0, (LPARAM) szPhoneNumber);

        DWORD_PTR dwSet = SendDlgItemMessageA(pParam->hwndDlg, nId, LB_SETITEMDATA, nTmpIdx, (LPARAM) dwCookie);

#ifdef DEBUG
        if (LB_ERR == dwSet)
        {
            CMTRACE(TEXT("PBDlgProc() LB_SETITEMDATA failed"));
        }
#endif

    } 
    else 
    {
        EnableWindow(GetDlgItem(pParam->hwndDlg,pParam->nIdMore),TRUE);
    
        if (bMatch) 
        {
            SendMessageA(pParam->hwndDlg, WM_COMMAND, pParam->nIdMore, 0);
        }
    }

exit:

#ifdef UNICODE
    CmFree(pszAnsiPhoneBookFile);
#endif

    return;
}

static void WINAPI _LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam) 
{
    ((LoadNumbersCBStruct *) dwParam)->pPhoneBook->LoadNumbersCB(nIdx,dwParam);
}


void CPhoneBookInfo::LoadNumbers(HWND hwndDlg,
                                 UINT nIdNumberA,
                                 UINT nIdNumberB,
                                 UINT nIdMore,
                                 LPCTSTR pszPhoneNumber,
                                 LPCTSTR pszPhoneBookFile) 
{
    UINT nIdx;
    DWORD dwServiceType;
    DWORD dwCountryID;
    DWORD dwRegionIdx = UINT_MAX;

    CMTRACE(TEXT("CPhoneBookInfo::LoadNumbers"));

    LPSTR pszAnsiPhoneNumber = NULL;
    LPSTR pszAnsiPhoneBookFile = NULL;

#ifdef UNICODE
    pszAnsiPhoneNumber = WzToSzWithAlloc(pszPhoneNumber);

    if (NULL == pszAnsiPhoneNumber)
    {
        CMTRACE(TEXT("CPhoneBookInfo::LoadNumbers -- Insufficient Memory to convert from Wide to MBCS for pszPhoneNumber"));
        goto exit;
    }

    pszAnsiPhoneBookFile = WzToSzWithAlloc(pszPhoneBookFile);

    if (NULL == pszAnsiPhoneBookFile)
    {
        CMTRACE(TEXT("CPhoneBookInfo::LoadNumbers -- Insufficient Memory to convert from Wide to MBCS for pszPhoneBookFile"));
        goto exit;
    }

#else
    pszAnsiPhoneNumber = (LPSTR)pszPhoneNumber;
    pszAnsiPhoneBookFile = (LPSTR)pszPhoneBookFile;
#endif


    SendDlgItemMessageA(hwndDlg, nIdNumberA, LB_RESETCONTENT, 0, 0);
    SendDlgItemMessageA(hwndDlg, nIdNumberB, LB_RESETCONTENT, 0, 0);

#if 0
//  EnableWindow(GetDlgItem(hwndDlg,nIdMore),FALSE); Note: More button is now obsolete
#endif
    
    //
    // Get the current service type
    //

    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETCURSEL, 0, 0);

    if (nIdx == CB_ERR) 
    {
        goto exit;
    }

    dwServiceType = (DWORD)SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETITEMDATA, nIdx, 0);
    MYDBGASSERT(dwServiceType < m_nServiceInfo);
    
    //
    // Get the current country code
    //

    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdCountry, CB_GETCURSEL, 0, 0);
    
    if (nIdx == CB_ERR) 
    {
        goto exit;
    }

    dwCountryID = (DWORD)SendDlgItemMessageA(hwndDlg, m_nIdCountry, CB_GETITEMDATA, nIdx, 0);
    
    //
    // Get the current region ID
    //
    
    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdRegion, CB_GETCURSEL, 0, 0);

    if (nIdx != CB_ERR) 
    {
        dwRegionIdx = (DWORD)SendDlgItemMessageA(hwndDlg, m_nIdRegion, CB_GETITEMDATA, nIdx, 0);
    } 
    
    for (nIdx=0; nIdx < m_nServiceInfo; nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == dwServiceType) 
        {
            if ((dwRegionIdx == UINT_MAX) || 
                (m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx] != UINT_MAX)) 
            {
                LoadNumbersCBStruct sParam = {this,
                                              m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                              hwndDlg,
                                              nIdNumberA,
                                              nIdNumberB,
                                              nIdMore,
                                              m_psiServiceInfo[nIdx].pFilterA,
                                              m_psiServiceInfo[nIdx].pFilterB,
                                              pszAnsiPhoneNumber,
                                              pszAnsiPhoneBookFile};

                PhoneBookEnumNumbers(sParam.dwPB,
                                     _LoadNumbersCB,
                                     dwCountryID,
                                     (dwRegionIdx == UINT_MAX) ? UINT_MAX : m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx],
                                     m_psiServiceInfo[nIdx].pFilter,
                                     (DWORD_PTR) &sParam);
            }
            else 
            {
                //
                // Multiple PBKs (especially if one has no regions) can create a 
                // situation in which we have a valid region selection in the combo
                // but the m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx] is 
                // UINT_MAX. What we do in this situation is enumerate the 
                // numbers such that only those without regions are added to the 
                // list by enumerating phone numbers with region 0.
                //

                if ((dwRegionIdx != UINT_MAX) && 
                    (m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx] == UINT_MAX))
                {
                    LoadNumbersCBStruct sParam = {this,
                                                  m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                                  hwndDlg,
                                                  nIdNumberA,
                                                  nIdNumberB,
                                                  nIdMore,
                                                  m_psiServiceInfo[nIdx].pFilterA,
                                                  m_psiServiceInfo[nIdx].pFilterB,
                                                  pszAnsiPhoneNumber,
                                                  pszAnsiPhoneBookFile};

                    PhoneBookEnumNumbersWithRegionsZero(sParam.dwPB,
                                                         _LoadNumbersCB,
                                                         dwCountryID,
                                                         m_psiServiceInfo[nIdx].pFilter,
                                                         (DWORD_PTR) &sParam);
                }
            }
        }
    }

exit:

#ifdef UNICODE
    CmFree(pszAnsiPhoneNumber);
    CmFree(pszAnsiPhoneBookFile);
#endif

    return;
}

BOOL CPhoneBookInfo::HasMoreNumbers()
{
    //
    // Filters are stored by service type, so examine each one.
    //

    for (UINT nIdx = 0; nIdx < m_nServiceInfo; nIdx++) 
    {       
        if (PhoneBookHasPhoneType(m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB), m_psiServiceInfo[nIdx].pFilterB))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CPhoneBookInfo::LoadFile(LPCTSTR pszFile, PPBFS pFilterA, PPBFS pFilterB) 
{
    CMTRACE(TEXT("CPhoneBookInfo::LoadFile"));

    LPSTR pszAnsiFile = NULL;
    BOOL bRes = TRUE;

#ifdef UNICODE
    pszAnsiFile = WzToSzWithAlloc(pszFile);
    if (!pszAnsiFile)
    {
        return FALSE;
    }
#else
    pszAnsiFile = (LPSTR)pszFile;
#endif

    SCBS sSvc = {this,pFilterA,pFilterB,0,pszAnsiFile};
    PhoneBookParseInfoStruct iInfo;

    sSvc.dwPB = m_Map.Open(pszAnsiFile, m_nServiceInfo);
    
    if (sSvc.dwPB == CPBMAP_ERROR) 
    {
        bRes = FALSE;
        goto exit;
    }

    ZeroMemory(&iInfo, sizeof(iInfo));
    iInfo.dwSize = sizeof(iInfo);
    iInfo.pfnSvc = _ServiceCB; 
    iInfo.dwSvcParam = (DWORD_PTR) &sSvc;

    CMTRACE(TEXT("CPhoneBookInfo::LoadFile - ParseInfo"));

    bRes = PhoneBookParseInfo(pszAnsiFile, &iInfo);

    PhoneBookFreeFilter(iInfo.pFilterA);
    PhoneBookFreeFilter(iInfo.pFilterB);

exit:

#ifdef UNICODE
        CmFree(pszAnsiFile);
#endif

    return (bRes);
}


BOOL CPhoneBookInfo::ServiceCB(LPCTSTR pszSvc,
                               PPBFS pFilter,
                               PPBFS pFilterA,
                               PPBFS pFilterB,
                               DWORD dwPB,
                               LPCTSTR pszFile) 
{
    ServiceInfo *psiInfo;
    UINT nIdx;

    CMTRACE(TEXT("CPhoneBookInfo::ServiceCB"));

    //
    // Extended m_psiServiceInfo and set up the new element
    //

    ExtendArray((void **) &m_psiServiceInfo,sizeof(*m_psiServiceInfo),&m_nServiceInfo);
    psiInfo = &m_psiServiceInfo[m_nServiceInfo-1];
    psiInfo->dwPB = dwPB;
    psiInfo->pFilter = pFilter;
    psiInfo->pFilterA = PhoneBookCopyFilter(pFilterA);
    psiInfo->pFilterB = PhoneBookCopyFilter(pFilterB);
    psiInfo->pszFile = CmStrCpyAlloc(pszFile);
    
    for (nIdx=0;nIdx<m_nServiceString;nIdx++) 
    {
        if (lstrcmpU(pszSvc,m_ppszServiceString[nIdx]) == 0) 
        {
            psiInfo->nServiceString = nIdx;
            break;
        }
    }
    
    if (nIdx == m_nServiceString) 
    {
        ExtendArray((void **) &m_ppszServiceString,sizeof(*m_ppszServiceString),&m_nServiceString);
        m_ppszServiceString[m_nServiceString-1] = CmStrCpyAlloc(pszSvc);
        psiInfo->nServiceString = m_nServiceString - 1;
    }
    return (TRUE);
}

static BOOL WINAPI _ReferenceCB(LPCSTR pszFile,
                                LPCSTR pszURL,
                                PPBFS pFilterA,
                                PPBFS pFilterB,
                                DWORD_PTR dwParam) 
{
    CPhoneBookInfo *pParam = (CPhoneBookInfo *) dwParam;

#ifdef UNICODE
    LPWSTR pszwFile = NULL;
    pszwFile = SzToWzWithAlloc(pszFile);
    BOOL bReturn = FALSE;

    if (NULL != pszwFile)
    {
        bReturn = pParam->LoadFile(pszwFile, pFilterA, pFilterB);
        CmFree(pszwFile);       
    }
    else
    {
        CMTRACE(TEXT("_ReferenceCB -- CmMalloc returned a NULL pointer."));
    }

    return bReturn;

#else
    return (pParam->LoadFile(pszFile, pFilterA, pFilterB));
#endif
}


static BOOL CALLBACK _ServiceCB(LPCSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam) 
{
    CPhoneBookInfo::SCBS *pParam = (CPhoneBookInfo::SCBS *) dwParam;

#ifdef UNICODE
    BOOL bReturn = FALSE;
    LPWSTR pszwSvc = SzToWzWithAlloc(pszSvc);
    LPWSTR pszwFile = SzToWzWithAlloc(pParam->pszFile);

    if ((NULL != pszwFile) && (NULL != pszwSvc))
    {
        bReturn = (pParam->pInfo->ServiceCB)(pszwSvc,
                                             pFilter,
                                             pParam->pFilterA,
                                             pParam->pFilterB,
                                             pParam->dwPB,
                                             pszwFile);
    }

    CmFree(pszwSvc);    
    CmFree(pszwFile);    

    return bReturn;

#else
    return (pParam->pInfo->ServiceCB(pszSvc,
                                     pFilter,
                                     pParam->pFilterA,
                                     pParam->pFilterB,
                                     pParam->dwPB,
                                     pParam->pszFile));
#endif

}


typedef struct tagPBDlgArgs 
{
    PBArgs *pPBArgs;
    CPhoneBookInfo cPB;
    BMPDATA BmpData;
} PBDlgArgs;


static BOOL PBDlgFillData(HWND hwndDlg, PBArgs *pPBArgs, CPhoneBookInfo *pPB, BOOL fValidateDun) 
{
    UINT nTmpIdx;
    UINT nId;
    DWORD dwLen;

    GetDlgItemTextU(hwndDlg,IDC_PHONEBOOK_SERVICETYPE_COMBO,pPBArgs->szServiceType,sizeof(pPBArgs->szServiceType)/sizeof(TCHAR)-1);
    
    nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,CB_GETCURSEL,0,0);
    if (nTmpIdx != CB_ERR) 
    {
        pPBArgs->dwCountryId = (DWORD)SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,CB_GETITEMDATA,nTmpIdx,0);
    } 
    else 
    {
        pPBArgs->dwCountryId = PhoneBookGetCurrentCountryId();
    }
    
    GetDlgItemTextU(hwndDlg,IDC_PHONEBOOK_REGION_COMBO,pPBArgs->szRegionName,sizeof(pPBArgs->szRegionName)/sizeof(TCHAR)-1);
    nId = IDC_PHONEBOOK_PHONE_LIST;
    
    nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg,nId,LB_GETCURSEL,0,0);
    if (nTmpIdx == LB_ERR) 
    {
        if (GetDlgItem(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST)) 
        {
            nId = IDC_PHONEBOOKEX_PHONE_LIST;
            nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg,nId,LB_GETCURSEL,0,0);

            UINT nTmpCount = (UINT) SendDlgItemMessageU(hwndDlg,nId,LB_GETCOUNT,0,0);

        }
    }
    
    if (nTmpIdx != LB_ERR) 
    {
        DWORD dwIdx = (DWORD)SendDlgItemMessageU(hwndDlg,nId,LB_GETITEMDATA,nTmpIdx,0);
        
        if (dwIdx != LB_ERR)
        {
            dwLen = sizeof(pPBArgs->szNonCanonical) / sizeof(TCHAR);
            pPB->GetNonCanonical(dwIdx,pPBArgs->szNonCanonical,&dwLen);

            dwLen = sizeof(pPBArgs->szCanonical) / sizeof(TCHAR);
            pPB->GetCanonical(dwIdx,pPBArgs->szCanonical,&dwLen);

            dwLen = sizeof(pPBArgs->szDesc) / sizeof(TCHAR);
            pPB->GetDesc(dwIdx,pPBArgs->szDesc,&dwLen);
            lstrcpynU(pPBArgs->szPhoneBookFile,pPB->GetFile(dwIdx),sizeof(pPBArgs->szPhoneBookFile)/sizeof(TCHAR));
            dwLen = sizeof(pPBArgs->szDUNFile) / sizeof(TCHAR);
            pPB->GetDUN(dwIdx,pPBArgs->szDUNFile,&dwLen);
            
            if (fValidateDun)
            {
                //
                // Make sure we can support any DUN settings associated with the number
                //
                
                if (FALSE == ValidateDialupDunSettings(pPBArgs->szPhoneBookFile, pPBArgs->szDUNFile, pPBArgs->pszCMSFile))
                {           
                    return FALSE;
                }       
            }
        }
#ifdef DEBUG
        if (LB_ERR == dwIdx)
        {
            CMTRACE(TEXT("PBDlgProc() LB_GETITEMDATA failed"));
        }
#endif
    }

    return TRUE;
}


INT_PTR CALLBACK PBDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    PBDlgArgs *pArgs = (PBDlgArgs *) GetWindowLongU(hwndDlg,DWLP_USER);
    static DWORD adwHelp[] = {IDC_PHONEBOOK_SERVICETYPE_COMBO,IDH_PHONEBOOK_SERVICETYP,
                              IDC_PHONEBOOK_COUNTRY_COMBO,IDH_PHONEBOOK_COUNTRY,
                              IDC_PHONEBOOK_REGION_COMBO,IDH_PHONEBOOK_STATEREG,
                              IDC_PHONEBOOK_REGION_STATIC,IDH_PHONEBOOK_STATEREG,
                              IDC_PHONEBOOK_PHONE_LIST,IDH_PHONEBOOK_ACCESSNUMS,
                              IDC_PHONEBOOK_HELP_BUTTON, IDH_CMHELP,
                              //IDC_PHONEBOOK_MORE_BUTTON,IDH_PHONEBOOK_MORE,
                              IDC_PHONEBOOKEX_MESSAGE_DISPLAY,IDH_PHONEBOOK_SVCMSG,
                              IDC_PHONEBOOKEX_MORE_STATIC,IDH_PHONEBOOK_MORENUMS,
                              IDC_PHONEBOOKEX_PHONE_LIST,IDH_PHONEBOOK_MORENUMS,
                              0,0};
    switch (uMsg) 
    {
        case WM_INITDIALOG:

            CMTRACE(TEXT("PBDlgProc - WM_INITDIALOG"));
            
            UpdateFont(hwndDlg);

            pArgs = (PBDlgArgs *) lParam;
            SetWindowLongU(hwndDlg,DWLP_USER,(LONG_PTR) pArgs);
            SetDlgItemTextU(hwndDlg,IDC_PHONEBOOKEX_MESSAGE_DISPLAY,pArgs->pPBArgs->pszMessage);
            pArgs->cPB.LoadServiceTypes(hwndDlg,IDC_PHONEBOOK_SERVICETYPE_COMBO,pArgs->pPBArgs->szServiceType);
            pArgs->cPB.LoadCountries(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,pArgs->pPBArgs->dwCountryId);
            pArgs->cPB.LoadRegions(hwndDlg,IDC_PHONEBOOK_REGION_COMBO,pArgs->pPBArgs->szRegionName);
            pArgs->cPB.LoadNumbers(hwndDlg,
                                   IDC_PHONEBOOK_PHONE_LIST,
                                   IDC_PHONEBOOKEX_PHONE_LIST,
                                   IDC_PHONEBOOK_MORE_BUTTON,
                                   pArgs->pPBArgs->szCanonical,
                                   pArgs->pPBArgs->szPhoneBookFile);

            if ((SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR) &&
                (!GetDlgItem(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST) ||
                 (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR))) 
            {
                EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);
            }
            
            SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_BITMAP,STM_SETIMAGE,IMAGE_BITMAP,(LPARAM) &pArgs->BmpData);

            if (IsLogonAsSystem())
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_PHONEBOOK_HELP_BUTTON), FALSE);
            }

            return (FALSE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    if (PBDlgFillData(hwndDlg, pArgs->pPBArgs, &pArgs->cPB, TRUE))
                    {
                        EndDialog(hwndDlg,1);
                    }
                    return (TRUE);

                case IDC_PHONEBOOK_HELP_BUTTON:
                    CmWinHelp(hwndDlg, hwndDlg, pArgs->pPBArgs->pszHelpFile,HELP_FORCEFILE,ICM_TRB);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hwndDlg,0);
                    return (TRUE);

                case IDC_PHONEBOOK_MORE_BUTTON:
                    MYDBGASSERT(FALSE); // Now obsolete
                    PBDlgFillData(hwndDlg, pArgs->pPBArgs, &pArgs->cPB, FALSE);
                    EndDialog(hwndDlg,2);
                    return (TRUE);

                default:
                    if ((HIWORD(wParam) == CBN_SELCHANGE) || (HIWORD(wParam) == LBN_SELCHANGE)) 
                    {
                        switch (LOWORD(wParam)) 
                        {                              
                            case IDC_PHONEBOOK_SERVICETYPE_COMBO:

                                PBDlgFillData(hwndDlg, pArgs->pPBArgs, &pArgs->cPB, FALSE);
                                pArgs->cPB.LoadCountries(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,pArgs->pPBArgs->dwCountryId);

                                // fall through
                            case IDC_PHONEBOOK_COUNTRY_COMBO:

                                pArgs->cPB.LoadRegions(hwndDlg,IDC_PHONEBOOK_REGION_COMBO,pArgs->pPBArgs->szRegionName);
                                // fall through
                            case IDC_PHONEBOOK_REGION_COMBO:

                                pArgs->cPB.LoadNumbers(hwndDlg,
                                                       IDC_PHONEBOOK_PHONE_LIST,
                                                       IDC_PHONEBOOKEX_PHONE_LIST,
                                                       IDC_PHONEBOOK_MORE_BUTTON,
                                                       pArgs->pPBArgs->szCanonical,
                                                       pArgs->pPBArgs->szPhoneBookFile);

                                if ((SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR) &&
                                    (!GetDlgItem(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST) ||
                                     (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR))) 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);
                                } 
                                else 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
                                }

                                return (TRUE);

                            case IDC_PHONEBOOK_PHONE_LIST:
                                if (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_GETCURSEL,0,0) != LB_ERR) 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
                                    SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_SETCURSEL,(WPARAM) -1,0);
                                }
                                return (TRUE);

                            case IDC_PHONEBOOKEX_PHONE_LIST:
                                if (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_GETCURSEL,0,0) != LB_ERR) 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
                                    SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_SETCURSEL,(WPARAM) -1,0);
                                }
                                return (TRUE);

                            default:
                                break;
                        }
                    }
                    if (HIWORD(wParam) == LBN_DBLCLK) 
                    {
                        switch (LOWORD(wParam)) 
                        {
                            case IDC_PHONEBOOK_PHONE_LIST:
                            case IDC_PHONEBOOKEX_PHONE_LIST:
                                if (SendDlgItemMessageU(hwndDlg,LOWORD(wParam),LB_GETCURSEL,0,0) != LB_ERR) 
                                {
                                    SendMessageU(hwndDlg, WM_COMMAND, IDOK, 0);
                                }
                                break;

                            default:
                                break;
                        }
                    }
                    break;
            }
            break;

        case WM_HELP:
        {
            LPHELPINFO lpHelpInfo = (LPHELPINFO) lParam;

            CmWinHelp((HWND) (lpHelpInfo->hItemHandle), 
                    (HWND) (lpHelpInfo->hItemHandle),
                    pArgs->pPBArgs->pszHelpFile,
                    HELP_WM_HELP, 
                    (ULONG_PTR) ((LPTSTR) adwHelp));

            return (TRUE);
        }

        case WM_CONTEXTMENU:
            {

                POINT   pt = {LOWORD(lParam), HIWORD(lParam)};
                HWND    hWndItem;
                
                ScreenToClient(hwndDlg, &pt);
                hWndItem = ChildWindowFromPoint(hwndDlg, pt);
                if (hWndItem != NULL && 
                    HaveContextHelp(hwndDlg, hWndItem))
                {
                    CmWinHelp((HWND) wParam, hWndItem,pArgs->pPBArgs->pszHelpFile,HELP_CONTEXTMENU,(ULONG_PTR) (LPSTR) adwHelp);
                    return (TRUE);
                }
                //
                // 170599: Assertion when right click phone book dialog title bar
                // Return FALSE, DefaultWindowProc will handle this message then.
                //
                return (FALSE);
            }

        case WM_PALETTEISCHANGING:
            CMTRACE2(TEXT("PBDlgProc() got WM_PALETTEISCHANGING message, wParam=0x%x, hwndDlg=0x%x."), wParam, hwndDlg);
            break;

        case WM_PALETTECHANGED: 
        {                       
            if ((wParam != (WPARAM) hwndDlg) && pArgs->BmpData.hDIBitmap) 
            {
                PaletteChanged(&pArgs->BmpData, hwndDlg, IDC_PHONEBOOK_BITMAP);
            }
            else
            {
                CMTRACE2(TEXT("PBDlgProc().WM_PALETTECHANGED not changing palette, wParam=0x%x, hwndDlg=0x%x."), 
                    wParam, hwndDlg);
            }
            break;
        }

        case WM_QUERYNEWPALETTE:

            QueryNewPalette(&pArgs->BmpData, hwndDlg, IDC_PHONEBOOK_BITMAP);        
            break;

        default:
            break;
    }
    return (FALSE);
}


BOOL DisplayPhoneBook(HWND hwndDlg, PBArgs *pPBArgs, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs) 
{
    PBDlgArgs sDlgArgs;
    BOOL bRes = FALSE;
    HWND hwndParent = NULL;
    CNamedMutex PbMutex;

    memset(&sDlgArgs,0,sizeof(sDlgArgs));
    sDlgArgs.pPBArgs = pPBArgs;

    //
    // Show wait cursor and attempt to grab PB access mutex
    //

    HCURSOR hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));
    
    if (PbMutex.Lock(c_pszCMPhoneBookMutex, TRUE, MAX_PB_WAIT))
    {       
        sDlgArgs.cPB.Load(pPBArgs->pszCMSFile, fHasValidTopLevelPBK, fHasValidReferencedPBKs);
        PbMutex.Unlock();
    }
    else
    {
        SetCursor(hPrev);
        CMTRACE(TEXT("DisplayPhoneBook() - Unable to grab PB access mutex."));
        return bRes;   
    }

    //
    //  We have a phonebook to display, setup graphics
    //
    
    if (pPBArgs->pszBitmap && *pPBArgs->pszBitmap) 
    {
        sDlgArgs.BmpData.hDIBitmap = CmLoadBitmap(g_hInst, pPBArgs->pszBitmap);
    }
    
    if (!sDlgArgs.BmpData.hDIBitmap) 
    {
        sDlgArgs.BmpData.hDIBitmap = CmLoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_PB));
    }
    
    if (sDlgArgs.BmpData.hDIBitmap) 
    {
        //
        // Create a new Device Dependent bitmap 
        //
       
        sDlgArgs.BmpData.phMasterPalette = pPBArgs->phMasterPalette;
        sDlgArgs.BmpData.bForceBackground = TRUE; // paint as a background app

        CreateBitmapData(sDlgArgs.BmpData.hDIBitmap, &sDlgArgs.BmpData, hwndDlg, TRUE);
    }

    //
    // Determine the template to be used, if the aggregate PB contains any 
    // surcharge numbers then use the EX template for displaying more numbers.
    //

    LPCTSTR pszDlgBox = NULL;
    
    if (sDlgArgs.cPB.HasMoreNumbers())
    {
        pszDlgBox = MAKEINTRESOURCE(IDD_PHONEBOOKEX);
    }
    else
    {
        pszDlgBox = MAKEINTRESOURCE(IDD_PHONEBOOK); 
    }

    MYDBGASSERT(pszDlgBox);

    //
    // Restore cursor and display the PB dialog
    //

    SetCursor(hPrev);

    hwndParent = hwndDlg;

#if 0
/*
    //
    // Previously, the user drove the template decision by electing to see 
    // More numbers via the More button. The return code from the proc would
    // dictate if we should simply call it a again with a different template.
    // Hence this loop and switch.
    //
      
        
    while (1) 
    {
        switch (DialogBoxParam(g_hInst, pszDlgBox, hwndParent, PBDlgProc,  (LPARAM) &sDlgArgs)) 
        {
            case 1:
                bRes = TRUE;
                break;

            case 2:
                pszDlgBox = MAKEINTRESOURCE(IDD_PHONEBOOKEX);
                continue;

            case 0:
            default:
                break;
        }
        //
        // Release bitmap resources for dlg
        //

        ReleaseBitmapData(&sDlgArgs.BmpData);
            
        return (bRes);
    }
*/
#else
        bRes = (BOOL) DialogBoxParamU(g_hInst, pszDlgBox, hwndParent, PBDlgProc,  (LPARAM) &sDlgArgs);

        ReleaseBitmapData(&sDlgArgs.BmpData);
            
        return (bRes);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\refs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     refs.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The module contains the code for profile referencing.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#include "pbk_str.h"

//+---------------------------------------------------------------------------
//
//	Function:	ValidTopLevelPBK()
//
//	Synopsis:	Checks to see if the toplevel phone book is valid.
//
//	Arguments:	pArgs [the ptr to ArgsStruct]
//
//	Returns:	BOOL    [True if there are valid phone books]
//
//	History:	henryt	Created		4/7/97
//										
//----------------------------------------------------------------------------
BOOL ValidTopLevelPBK(
    ArgsStruct  *pArgs
)
{
    LPTSTR pszTmp;
    LPTSTR pszFullPath;
    BOOL fValid = TRUE;

    //
    //  First check the top level service profile pbk
    //
	
    pszTmp = pArgs->piniService->GPPS(c_pszCmSectionIsp, c_pszCmEntryIspPbFile);

    if (!*pszTmp)
    {
        fValid = FALSE;
    }
    else
    {
        pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);

        if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
        {
            fValid = FALSE;
        }
        CmFree(pszFullPath);  
    }

    CmFree(pszTmp);

    //
    // If PBK failed, we're done
    //

    if (FALSE == fValid)
    {
        return fValid;
    }

    //
    // Now check the region file
    //

    pszTmp = pArgs->piniService->GPPS(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile);

    if (!*pszTmp)
    {
        fValid = FALSE;
    }
    else
    {
        pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);

        if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
        {
            fValid = FALSE;
        }
        CmFree(pszFullPath);  
    }

    CmFree(pszTmp);

    return fValid;
}
	

//+---------------------------------------------------------------------------
//
//	Function:	ValidReferencedPBKs()
//
//	Synopsis:	Checks to see if the phone books used by the referenced 
//              service profile(s) exist.
//
//	Arguments:	pArgs [the ptr to ArgsStruct]
//
//	Returns:	BOOL    [True if there are valid phone books]
//
//	History:	henryt	Created		4/7/97
//										
//----------------------------------------------------------------------------
BOOL ValidReferencedPBKs(
    ArgsStruct  *pArgs
)
{
    LPTSTR  pszTmp, pszTmp2;
    LPTSTR  pszRef, pszNext;
    CIni    iniRef(g_hInst);
    CIni    iniFile(g_hInst, pArgs->piniService->GetFile());
    LPTSTR  pszRefFile;
    BOOL    fValid = TRUE;
	BOOL	fValidPairFound = FALSE;
    LPTSTR pszFullPath;
    
    //
    //  Now check the references.
    //

    pszTmp2 = iniFile.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspReferences);
    pszRef = NULL;
    pszNext = pszTmp2;
    
	while (1) 
	{
        if (!(pszRef = CmStrtok(pszNext, TEXT(" \t,"))))
		{
            break;
		}

		fValid = TRUE;
        
		pszNext = pszRef + lstrlenU(pszRef) + 1;

        iniFile.SetEntry(pszRef);

        //
        //  Make sure that each referenced service has a valid pbk and pbr
        //

        pszRefFile = iniFile.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspCmsFile);
        if (*pszRefFile) 
		{
            //
            // Ensure a full path to the RefFile
            //

            pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszRefFile);
            
            if (!pszFullPath)
            {
                fValid = FALSE;
            }
            else
            {
                iniRef.SetFile(pszFullPath);
            }
            
            CmFree(pszFullPath);

            if (fValid)
            {
                //
                // Test existence of phonebook
                //

                pszTmp = iniRef.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspPbFile);

                if (!*pszTmp)
                {
                    fValid = FALSE;
                }
                else
                {
                    pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);
                    if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
                    {
                        fValid = FALSE;               
                    }
                    CmFree(pszFullPath);
                }
            
			    CmFree(pszTmp);

                //
                // Now check the region file
                //

                pszTmp = iniRef.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile);

                if (!*pszTmp)
                {
                    fValid = FALSE;
                }
                else
                {
                    pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);
                    if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
                    {
                        fValid = FALSE;               
                    }
                    CmFree(pszFullPath);
                }

   			    CmFree(pszTmp);
            }
        } 
		else 
		{
            fValid = FALSE;
        }
        
		CmFree(pszRefFile);

        if (fValid)
		{
            fValidPairFound = TRUE;
			break;
		}
    }
    
	CmFree(pszTmp2);

    return fValidPairFound;
}

//+---------------------------------------------------------------------------
//
//	Function:	GetAppropriateIniService
//
//	Synopsis:	Depending on:
//              1. whether we're referencing or not, 
//              2. the pbk from which the user selected the phone #
//
//              this func creates a CIni obj with the correct cms file
//
//	Arguments:	pArgs		Pointer to ArgsStruct
//              dwEntry     phone index
//
//	Returns:	CIni* - the ptr to the new object
//
//	History:	henryt	Created		5/14/97
//----------------------------------------------------------------------------

CIni* GetAppropriateIniService(
    ArgsStruct  *pArgs,
    DWORD       dwEntry
)
{   
    CIni*   piniService = new CIni(g_hInst);

    if (!piniService) 
    {
        CMTRACE(TEXT("GetAppropriateIniService() : alloc mem failed"));
        return NULL;
    }

    //
    //  we need to work with the correct service file(the top-level service
    //  or a referenced service).
    //
    //  according to the spec, we will always use the DUN settings from the cms 
    //  associated w/ the phone book from which the user selected the POP.  i.e.
    //  if the user switches the picked from a different pbk, we need to update
    //  the RAS connectoid.
    //
    
    if (IsBlankString(pArgs->aDialInfo[dwEntry].szPhoneBookFile) || 
        lstrcmpiU(pArgs->aDialInfo[dwEntry].szPhoneBookFile, pArgs->piniService->GetFile()) == 0)
	{
        //
        //  the user either typed in the phone # or selected a phone # from the
        //  top level phone book
        //
        piniService->SetFile(pArgs->piniService->GetFile());
    }
    else 
	{
        //
        //  the user picked the phone # from a referenced phone book.
        //
        piniService->SetFile(pArgs->aDialInfo[dwEntry].szPhoneBookFile);
    }

    return piniService;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\ras.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ras.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the functions to allow Connection Manager to
//           interact with RAS.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   byao       created         04/29/97
//           quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "compchck.h"
#include "dial_str.h"
#include "dun_str.h"
#include "tunl_str.h"
#include "stp_str.h"
#include "ras_str.h"
#include "dialogs.h"

#include <cmdefs.h> // located in net\inc

//
//  Include the header and code for linking to the SafeNet Config APIs
//
#include "cmsafenet.h"
#include "cmsafenet.cpp"

//
//  For AllowAccessToWorld
//
#include "allowaccess.h"
#include "allowaccess.cpp"

//
// CMS flags use to specify DUN settings. These entries are specific
// to this code module, shared entries are stored on dun_str.h
//

const TCHAR* const c_pszCmSectionDunPhone                   = TEXT("Phone");
const TCHAR* const c_pszCmEntryDunPhoneDialAsIs             = TEXT("Dial_As_Is");
const TCHAR* const c_pszCmEntryDunPhonePhoneNumber          = TEXT("Phone_Number");
const TCHAR* const c_pszCmEntryDunPhoneAreaCode             = TEXT("Area_Code");
const TCHAR* const c_pszCmEntryDunPhoneCountryCode          = TEXT("Country_Code");
const TCHAR* const c_pszCmEntryDunPhoneCountryId            = TEXT("Country_ID");
const TCHAR* const c_pszCmSectionDunDevice                  = TEXT("Device");
const TCHAR* const c_pszCmEntryDunDeviceType                = TEXT("Type");
const TCHAR* const c_pszCmEntryDunDeviceName                = TEXT("Name");
const TCHAR* const c_pszCmEntryHideTrayIcon                 = TEXT("HideTrayIcon");
const TCHAR* const c_pszCmEntryInternetConnection           = TEXT("InternetConnection");

//
// the following reg key and value control whether Dial-Up Networking on Win95
// will start the Wizard.  Note that these are explicitly chars instead of TCHARs
//
const CHAR* const c_pszRegRemoteAccess = "RemoteAccess";
const CHAR* const c_pszRegWizard       = "wizard";

#define ICM_RAS_REG_WIZARD_VALUE        0x00000080

//
// .CMS flags used only by ras.cpp
//

const TCHAR* const c_pszCmEntryDialExtraPercent         = TEXT("DialExtraPercent"); 
const TCHAR* const c_pszCmEntryDialExtraSampleSeconds   = TEXT("DialExtraSampleSeconds"); 
const TCHAR* const c_pszCmEntryHangUpExtraPercent         = TEXT("HangUpExtraPercent"); 
const TCHAR* const c_pszCmEntryHangUpExtraSampleSeconds   = TEXT("HangUpExtraSampleSeconds"); 

//
//  This file includes the definitions of c_ArrayOfRasFuncsW and c_ArrayOfRasFuncsUA below
//
#include "raslink.cpp"

//
//  Function prototypes
//
BOOL IsTerminalWindowSupportedOnWin2kPlus();

//+----------------------------------------------------------------------------
//
// Function:  LinkToRas
//
// Synopsis: Establishes the RAS linkage by populating the inputted RAS Linkage structure
//           with function pointers from Rasapi32.dll (on NT) or from cmutoa.dll (Unicode
//           to ANSI wrapper functions used on win9x).  Most of the actual work is done
//           in LinkToDll, this function just does setup work to make sure the correct
//           entry points are searched for and that Cmutoa.dll is initialized properly (since it
//           needs to link to rasapi32.dll itself to get the actual ANSI RAS API's to work with).
//
// Arguments: RasLinkageStruct *prlsRasLink - pointer to a RAS Linkage structure.  This
//                                            structure contains storage for pointers to
//                                            the RAS dll and all of the needed RAS
//                                            function pointers.
//
// Returns:   BOOL - FALSE if *any* entry point is still not resolved.
//
// History:   quintinb Created Header    01/04/2000
//
//+----------------------------------------------------------------------------
BOOL LinkToRas(RasLinkageStruct *prlsRasLink) 
{
    BOOL bReturn = TRUE;

    //
    //  Check inputs
    //
    if (NULL == prlsRasLink)
    {
        return FALSE;
    }

    if (OS_NT)
    {
        //
        //  On NT we get our RAS APIs from rasapi32.dll and we ask for the W version
        //  of the API.
        //
        if (OS_NT4) 
        {
            c_ArrayOfRasFuncsW[12] = NULL; //RasDeleteSubEntry
            c_ArrayOfRasFuncsW[13] = NULL; //RasSetCustomAuthData
            c_ArrayOfRasFuncsW[14] = NULL; //RasGetEapUserIdentity
            c_ArrayOfRasFuncsW[15] = NULL; //RasFreeEapUserIdentity
            c_ArrayOfRasFuncsW[16] = NULL; //RasInvokeEapUI
            c_ArrayOfRasFuncsW[17] = NULL; //pfnGetCredentials
            c_ArrayOfRasFuncsW[18] = NULL; //pfnSetCredentials
            c_ArrayOfRasFuncsW[19] = NULL; //pfnGetCustomAuthData
        }
        else if (OS_W2K)
        {
            //
            //  Special-casing for APIs that changed after Windows2000 shipped
            //
            c_ArrayOfRasFuncsW[12] = "DwDeleteSubEntry";   //RasDeleteSubEntry is DwDeleteSubEntry on Win2k
        }

        bReturn = LinkToDll(&prlsRasLink->hInstRas, "RASAPI32.DLL", c_ArrayOfRasFuncsW,
                            prlsRasLink->apvPfnRas);
    }
    else
    {
        //
        //  On Win9x we still want the W version of the API but since it isn't available we
        //  call the wrappers in cmutoa.dll instead.  Thus we use cmutoa.dll as our RAS API dll
        //  and call the UA APIs.  We also have an extra step because we want to make sure 
        //  that cmutoa.dll can actually initialize the RAS dll's that it uses for the UA 
        //  conversion functions.  Thus we call cmutoa's InitCmRasUtoA function to set up 
        //  its internal RAS linkage.  If this function fails, we must fail the RAS link.

        typedef BOOL (WINAPI *pfnInitCmRasUtoASpec)(void);

        pfnInitCmRasUtoASpec InitCmRasUtoA;
        HMODULE hCmUtoADll = LoadLibraryExA("cmutoa.DLL", NULL, 0); // REVIEW: this should use getmodulehandle so as not to change the refcount on the dll.
        
        if (!hCmUtoADll)
        {            
            return FALSE;
        }

        // Get Initialization routine from the DLL
        InitCmRasUtoA = (pfnInitCmRasUtoASpec) GetProcAddress(hCmUtoADll, "InitCmRasUtoA") ;

        if (InitCmRasUtoA)
        {
            bReturn = InitCmRasUtoA();
            if (bReturn)
            {
                if (!OS_MIL)
                {
                    c_ArrayOfRasFuncsUA[11] = NULL; //RasSetSubEntryProperties
                    c_ArrayOfRasFuncsUA[12] = NULL; //RasDeleteSubEntry
                }

                bReturn = LinkToDll(&prlsRasLink->hInstRas, "CMUTOA.DLL", c_ArrayOfRasFuncsUA, 
                                    prlsRasLink->apvPfnRas);
            }
        }

        FreeLibrary(hCmUtoADll); // we want this to stay in memory but the refcount should also be correct
    }

    return bReturn;
}

BOOL IsRasLoaded(const RasLinkageStruct * const prlsRasLink)
{
    UINT uIndex = 0;

    //
    //  Did we get a valid pointer passed in and does that
    //  struct contain a pointer to a RAS dll?
    //
    BOOL bReturn = (NULL != prlsRasLink) && (NULL != prlsRasLink->hInstRas);

    //
    //  The list of functions we are checking for is different on NT
    //  and Win9x.  Note that we also assume that LinkToRas has already
    //  been called so that the list of functions we are expecting will
    //  have been modified for the exact platform that we are one.  If
    //  LinkToRas hasn't been called then the hInstRas param should be
    //  NULL.
    //
    if (OS_NT)
    {
        while (bReturn && (NULL != c_ArrayOfRasFuncsW[uIndex]))
        {
            //
            //  Check for a NULL function pointer when we have
            //  a valid function name.
            //
            if (NULL == prlsRasLink->apvPfnRas[uIndex])
            {
                bReturn = FALSE;
            }

           uIndex++;
        }
    }
    else
    {
        while (bReturn && (NULL != c_ArrayOfRasFuncsUA[uIndex]))
        {
            //
            //  Check for a NULL function pointer when we have
            //  a valid function name.
            //
            if (NULL == prlsRasLink->apvPfnRas[uIndex])
            {
                bReturn = FALSE;
            }

           uIndex++;
        }    
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UnlinkFromRas
//
// Synopsis:  This function tears down the linkage with RAS by freeing RAS dll's, calling
//           the cmutoa unklinkage function (if necessary), and zeroing the RAS Linkage
//           structure passed in.
//
// Arguments: RasLinkageStruct *prlsRasLink - pointer to a RAS Linkage structure.  This
//                                        structure contains storage for pointers to
//                                        the RAS dll and all of the needed RAS
//                                        function pointers.
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/04/2000
//
//+----------------------------------------------------------------------------
void UnlinkFromRas(RasLinkageStruct *prlsRasLink) 
{
    if (!OS_NT)
    {
        HMODULE hCmUtoADll = LoadLibraryExA("cmutoa.dll", NULL, 0);
        
        if (!hCmUtoADll)
        {         
            CMASSERTMSG(FALSE, TEXT("UnlinkFromRas -- Unable to load cmutoa."));
            return;
        }

        FARPROC FreeCmRasUtoA = GetProcAddress(hCmUtoADll, "FreeCmRasUtoA");

        if (FreeCmRasUtoA)
        {
            FreeCmRasUtoA();
        }

        FreeLibrary(hCmUtoADll);
    }

    if (prlsRasLink->hInstRas) 
    {
        FreeLibrary(prlsRasLink->hInstRas);
    }

    memset(prlsRasLink,0,sizeof(RasLinkageStruct));
}

//
// GetRasModems: get a list of modem devices from RAS
//
//+----------------------------------------------------------------------------
//
// Function:  GetRasModems
//
// Synopsis:  Enumerates the available RAS devices.  The device list is allocated and passed
//           back to the caller through the pprdiRasDevInfo pointer.  This allocated memory
//           must be freed by the caller.  The count of available devices is stored in the
//           pdwCnt input parameter.
//
// Arguments: RasLinkageStruct *prlsRasLink - pointer to the RAS Linkage structure
//            LPRASDEVINFO *pprdiRasDevInfo - pointer to hold the RAS device list
//            LPDWORD pdwCnt - pointer to hold the count of devices
//
// Returns:   BOOL - FALSE if unable to return the enumerated device list.
//
// History:   quintinb Created Header    01/04/2000
//
//+----------------------------------------------------------------------------

BOOL GetRasModems(const RasLinkageStruct *prlsRasLink, 
                                  LPRASDEVINFO *pprdiRasDevInfo, 
                                  LPDWORD pdwCnt) 
{
    DWORD dwLen;
    DWORD dwRes;
    DWORD dwCnt;

    if (pprdiRasDevInfo) 
    {
        *pprdiRasDevInfo = NULL;
    }
        
    if (pdwCnt) 
    {
        *pdwCnt = 0;
    }
        
    if (!prlsRasLink->pfnEnumDevices) 
    {
        return (FALSE);
    }
        
    dwLen = 0;
    dwRes = prlsRasLink->pfnEnumDevices(NULL,&dwLen,&dwCnt);

    CMTRACE3(TEXT("GetRasModems() RasEnumDevices(NULL,pdwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), 
        dwRes, dwLen, dwCnt);
        
    if (((dwRes != ERROR_SUCCESS) && (dwRes != ERROR_BUFFER_TOO_SMALL)) || (dwLen < sizeof(**pprdiRasDevInfo))) 
    {
        return (FALSE);
    }

    if (!pprdiRasDevInfo) 
    {
        if (pdwCnt)
        {
            *pdwCnt = dwCnt;
        }
        return (TRUE);
    }
        
    *pprdiRasDevInfo = (LPRASDEVINFO) CmMalloc(__max(dwLen,sizeof(**pprdiRasDevInfo)));

    if (*pprdiRasDevInfo)
    {
        (*pprdiRasDevInfo)->dwSize = sizeof(**pprdiRasDevInfo);
        dwRes = prlsRasLink->pfnEnumDevices(*pprdiRasDevInfo,&dwLen,&dwCnt);

        CMTRACE3(TEXT("GetRasModems() RasEnumDevices(*pprdiRasDevInfo,&dwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), 
                 dwRes, dwLen, dwCnt);

        if (dwRes != ERROR_SUCCESS) 
        {
            CmFree(*pprdiRasDevInfo);
            *pprdiRasDevInfo = NULL;
            return (FALSE);
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("GetRasModems -- CmMalloc failed to allocate memory for *pprdiRasDevInfo."));
        return (FALSE);
    }
    
    if (pdwCnt)
    {
        *pdwCnt = dwCnt;
    }

    return (TRUE);
}


//+----------------------------------------------------------------------------
//
// Function:  PickModem
//
// Synopsis:  
//
// Arguments: const pArgs, the pArgs->pIniProfile contains the modem name
//            OUT pszDeviceType, the device type if not NULL
//            OUT pszDeviceName, the device name if not NULL
//            OUT pfSameModem,   Whether the modem found is the same as 
//                               the one in profile
//
// Returns:   TRUE, is modem is found
//
// History:   fengsun Created Header    10/24/97
//
//+----------------------------------------------------------------------------
BOOL PickModem(IN const ArgsStruct *pArgs, OUT LPTSTR pszDeviceType, 
               OUT LPTSTR pszDeviceName, OUT BOOL* pfSameModem) 
{
    LPRASDEVINFO prdiModems;
    DWORD dwCnt;
    LPTSTR pszModem;
    DWORD dwIdx;
    BOOL bFound = FALSE;

    //
    // First, get a list of modems from RAS
    //
    
    if (!GetRasModems(&pArgs->rlsRasLink,&prdiModems,&dwCnt) || dwCnt == 0) 
    {
        return (FALSE);
    }

    if (pfSameModem)
    {
        *pfSameModem = FALSE;
    }

    //
    // Get the name of the current modem from the service profile and 
    // try to find a match against non-tunnel RAS devices in the list 
    //
    pszModem = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryDialDevice);

    if (*pszModem) 
    {
        CMTRACE1(TEXT("PickModem() - looking for match with %s"), pszModem);

        for (dwIdx=0; dwIdx < dwCnt; dwIdx++) 
        {               
            CMTRACE2(TEXT("PickModem() - examining device (%s) of type (%s)"), prdiModems[dwIdx].szDeviceName, prdiModems[dwIdx].szDeviceType);

            // 
            // we'll take only ISDN and modem devices
            //
            if (lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Isdn) &&
                lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Modem) &&
                lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Atm))
            {
                continue;
            }

            // 
            // If we have a match, we're done here
            //

            if (lstrcmpiU(pszModem,prdiModems[dwIdx].szDeviceName) == 0) 
            {
                CMTRACE(TEXT("PickModem() - match found."));
                bFound = TRUE;
                if (pfSameModem)
                {
                    *pfSameModem = TRUE;
                }
                break;
            }
        }
    }

    if (FALSE == bFound)
    {
        //
        // No match, find the first non-tunnel device and use it by default.
        //

        CMTRACE(TEXT("PickModem() - enumerating devices for default match against type RASDT_Isdn, RASDT_Modem or RASDT_Atm")); 
        
        for (dwIdx=0; dwIdx < dwCnt; dwIdx++) 
        {
            CMTRACE2(TEXT("PickModem() - examining device (%s) of type (%s)"), prdiModems[dwIdx].szDeviceName, prdiModems[dwIdx].szDeviceType); 
            
            //
            // we'll take only ISDN and modem devices
            //

            if (!lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Isdn) ||
                 !lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Modem) ||
                 !lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Atm)) 
            {
                CMTRACE2(TEXT("PickModem() - default device (%s) of type (%s) selected."), prdiModems[dwIdx].szDeviceName, prdiModems[dwIdx].szDeviceType);
                bFound = TRUE;
                break;
            }
        }
    }

    // 
    // If we have a match, fill device name and device type
    //

    if (bFound)
    {
        if (pszDeviceType) 
        {
            lstrcpyU(pszDeviceType,prdiModems[dwIdx].szDeviceType);
        }
        
        if (pszDeviceName) 
        {
            lstrcpyU(pszDeviceName,prdiModems[dwIdx].szDeviceName);
        }
    }

    CmFree(pszModem);
    CmFree(prdiModems);
    return (bFound);
}

//+----------------------------------------------------------------------------
//
// Function:  GetDeviceType
//
// Synopsis:  Get the deviceType for a chosen device name
//
// Arguments: pArgs - Pointer to ArgsStruct
//            pszDeviceType[OUT] - pointer to buffer where device 
//                                 type will be returned
//            pszDeviceName[IN] - device name
//
// Returns:   TRUE on success, FALSE otherwise
//
// History:   byao  Created  03/21/97
//-----------------------------------------------------------------------------
BOOL GetDeviceType(ArgsStruct *pArgs, LPTSTR pszDeviceType, LPTSTR pszDeviceName)
{
    LPRASDEVINFO prdiModems;
    DWORD dwCnt, dwIdx;

    if (!pszDeviceType)
    {
        return FALSE;
    }

    // first, get a list of modems from RAS
    if (!GetRasModems(&pArgs->rlsRasLink,&prdiModems,&dwCnt)) 
    {
        return (FALSE);
    }

    // choose the device that has the same name as pszDeviceName
    for (dwIdx=0;dwIdx<dwCnt;dwIdx++) 
    {
        if (lstrcmpiU(pszDeviceName,prdiModems[dwIdx].szDeviceName) == 0) 
        {
            lstrcpyU(pszDeviceType, prdiModems[dwIdx].szDeviceType);
            break;
        }
    }

    CmFree(prdiModems);

    if (dwIdx == dwCnt)  // not found in the modem list -- strange things happened
    {
        return FALSE; 
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//      Function        ConfiguredToDialWithSafeNet
//
//      Synopsis        Figures out if the current Tunnel DUN setting is configured
//                      to use the SafeNet client.
//
//      Arguments       pArgs           Pointer to ArgsStruct
//
//      Returns         TRUE - if the current Tunnel DUN setting should use SafeNet
//
//      History         09/24/01          quintinb        Created
//
//-----------------------------------------------------------------------------
BOOL ConfiguredToDialWithSafeNet(ArgsStruct *pArgs)
{
    BOOL bUseSafeNet = FALSE;

    if (OS_NT4 || OS_W9X)
    {
        LPTSTR pszDunSetting = GetDunSettingName(pArgs, -1, TRUE); // -1 for index as not needed, TRUE for is Tunneling

        if (pszDunSetting)
        {
            //
            //  Create an Ini File object so that we can access the UseDownLevelL2TP setting
            //
            CIni iniFile(g_hInst, pArgs->piniService->GetFile());

            LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));   
            if (pszSection)
            {
                pszSection = CmStrCatAlloc(&pszSection, pszDunSetting);
                if (pszSection)
                {
                    iniFile.SetSection(pszSection);  
                    CmFree(pszSection);

                    //
                    //  If we are supposed to be using the SafeNet downlevel L2TP client, then we need to make
                    //  sure to pick it as the adapter name.  We can only use the SafeNet client if it is available,
                    //  however.
                    //
                    if (iniFile.GPPB(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingUseDownLevelL2TP))
                    {
                        bUseSafeNet = pArgs->bSafeNetClientAvailable;
                    }
                }
            }

            CmFree(pszDunSetting);
        }
    }

    return bUseSafeNet;
}

//+----------------------------------------------------------------------------
//
//      Function        IsSafeNetDevice
//
//      Synopsis        Figures out if the passed in device name and device type
//                      correspond to a SafeNet device.
//
//      Arguments       LPCTSTR pszDeviceType - type of device to check
//                      LPCTSTR pszDeviceName - name of device to check
//
//      Returns         TRUE - if the device is a SafeNet device
//
//      History         09/24/01          quintinb        Created
//
//-----------------------------------------------------------------------------
BOOL IsSafeNetDevice(LPCTSTR pszDeviceType, LPCTSTR pszDeviceName)
{
    BOOL bReturn = FALSE;

    if (pszDeviceType && pszDeviceName)
    {
        //
        //  First check the existing names...
        //
        if (OS_NT4 &&
            (0 == lstrcmpiU(pszDeviceType, c_pszSafeNetAdapterType_Winnt4_old)) && 
            (0 == lstrcmpiU(pszDeviceName, c_pszSafeNetAdapterName_Winnt4_old)))
        {
            bReturn = TRUE;
        }                
    
        if (!bReturn && OS_W9X &&
            (0 == lstrcmpiU(pszDeviceType, c_pszSafeNetAdapterType_Win9x_old)) && 
            (0 == lstrcmpiU(pszDeviceName, c_pszSafeNetAdapterName_Win9x_old)))
        {
            bReturn = TRUE;
        }

        //
        //  Now check the names that are supposed to exist in the future...
        //
        if (!bReturn && OS_NT4 &&
            (0 == lstrcmpiU(pszDeviceType, RASDT_Vpn)) && 
            (0 == lstrcmpiU(pszDeviceName, c_pszSafeNetAdapterName_Winnt4)))
        {
            bReturn = TRUE;
        }                
    
        if (!bReturn && OS_W9X && (0 == lstrcmpiU(pszDeviceType, RASDT_Vpn)))
        {
            //
            //  If SafeNet doesn't fix the problem on win9x where the adapter is named "XXX 1",
            //  then we are going to need to match adapters that might or might not have this
            //  extra suffix.  Thus lets check the first lstrlenU(c_pszSafeNetAdapterName_Win9x)
            //  letters and if we have a match we will call it good.
            //
            DWORD dwLen = lstrlenU(c_pszSafeNetAdapterName_Win9x);

            if (dwLen <= (DWORD)lstrlenU(pszDeviceName))
            {
                LPTSTR pszString = (LPTSTR)CmMalloc((dwLen+1)*sizeof(TCHAR));

                if (pszString)
                {
                    lstrcpynU(pszString, pszDeviceName, dwLen+1);

                    if (0 == lstrcmpiU(pszString, c_pszSafeNetAdapterName_Win9x))
                    {
                        bReturn = TRUE;
                    }

                    CmFree (pszString);
                }
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
//      Function        PickTunnelDevice
//
//      Synopsis        pick a tunnel device used to dial out
//
//      Arguments       pArgs           Pointer to ArgsStruct
//                      pszDeviceType   Tunnel device type. --  RASDT_Vpn
//                      pszDeviceName   Tunnel device name
//
//      Returns         TRUE - scripting has been installed
//
//      History         03/01/97          byao            Created
//                      09/05/01          quintinb        Rewrote to handle the SafeNet Adapter
//
//-----------------------------------------------------------------------------
BOOL PickTunnelDevice(ArgsStruct *pArgs, LPTSTR pszDeviceType, LPTSTR pszDeviceName) 
{
    //
    //  Check input parameters
    //
    if ((NULL == pArgs) || (NULL == pszDeviceType) || (NULL == pszDeviceName))
    {
        CMASSERTMSG(FALSE, TEXT("PickTunnelDevice -- invalid parameters passed!"));
        return FALSE;
    }

    LPRASDEVINFO prdiModems = NULL;
    BOOL bReturn = FALSE;
    DWORD dwCnt;
    DWORD dwIdx;

    //
    //  Clear the output param
    //
    pszDeviceName[0] = TEXT('\0');
    pszDeviceType[0] = TEXT('\0');

    //
    // First, get the list of devices from RAS
    //
    if (GetRasModems(&pArgs->rlsRasLink, &prdiModems, &dwCnt) && dwCnt) 
    {
        //
        //  Okay, let's pick an MS tunnel adapter first
        //
        for (dwIdx = 0; dwIdx < dwCnt; dwIdx++) 
        {
            if (0 == lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Vpn))
            {
                //
                //  Okay, if this is Win2k+ then any VPN device will do.  RAS will figure out what
                //  we mean by looking at the VpnStrategy.
                //
                if (OS_NT5)
                {
                    break;
                }
                else
                {
                    //
                    //  For downlevel platforms we either need to pick the SafeNet device or make sure
                    //  we aren't picking it if we are doing PPTP.
                    //
                    BOOL bSafeNetDeviceName = IsSafeNetDevice(prdiModems[dwIdx].szDeviceType, prdiModems[dwIdx].szDeviceName);

                    if (!bSafeNetDeviceName)
                    {
                        break;
                    }
                }
            }
        }

        if (dwIdx != dwCnt)
        {
            lstrcpyU(pszDeviceName, prdiModems[dwIdx].szDeviceName);
            lstrcpyU(pszDeviceType, prdiModems[dwIdx].szDeviceType);
            bReturn = TRUE;
        }

        //
        //  If we are configured to dial with SafeNet then we actually want to pick
        //  the SafeNet adapter.  However, if we cannot find their adapter then we will
        //  use the one we picked before...
        //

        BOOL bUseSafeNet = ConfiguredToDialWithSafeNet(pArgs);

        if (bUseSafeNet)
        {            
            for (dwIdx = 0; dwIdx < dwCnt; dwIdx++) 
            {
                if (IsSafeNetDevice(prdiModems[dwIdx].szDeviceType, prdiModems[dwIdx].szDeviceName))
                {
                    break;
                }                
            }

            //
            //  Note that if we find a SafeNet device it will override the device we found in the
            //  first for loop.  However, if we don't find a SafeNet device then we will go ahead
            //  and use the MS adapter assuming we found one...
            //
            if (dwIdx != dwCnt)
            {
                lstrcpyU(pszDeviceName, prdiModems[dwIdx].szDeviceName);
                lstrcpyU(pszDeviceType, prdiModems[dwIdx].szDeviceType);
                bReturn = TRUE;
            }
        }
    }

    CmFree(prdiModems);

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CopyAutoDial
//
// Synopsis:  Sets the szAutodialDll and szAutodialFunc members of the 
//            specified RAS entry structure with our module name and
//            InetDialHandler repectively. Not on NT5.
//
// Arguments: LPRASENTRY preEntry - Ptr to the Ras entry structure.
//
// Returns:   Nothing
//
// History:   nickball    Created Header    03/16/98
//            nickball    Removed from NT5  11/17/98
//
//+----------------------------------------------------------------------------
void CopyAutoDial(LPRASENTRY preEntry) 
{
    MYDBGASSERT(preEntry);

    //
    // Don't set these on NT5, they are no longer used by IE and the 
    // InetDialHandler prototype differs from that used by RAS
    //

    if (OS_NT5 || NULL == preEntry)
    {
        return;
    }

    memset(preEntry->szAutodialDll,0,sizeof(preEntry->szAutodialDll));

    //
    // Set szAutodialDll with our Module name
    //

    GetModuleFileNameU(g_hInst, preEntry->szAutodialDll, sizeof(preEntry->szAutodialDll)/sizeof(TCHAR));    

    //
    // Set szAutodialFunc with the mangled form of InetDialHandler
    //

    memset(preEntry->szAutodialFunc,0,sizeof(preEntry->szAutodialFunc));
    lstrcpyU(preEntry->szAutodialFunc, c_pszInetDialHandler);
}

//+----------------------------------------------------------------------------
//
//      Function        MyRGEP
//
//      Synopsis        Call RasGetEntryProperties()
//                              
//      Arguments       
//
//      Returns         
//
//      Histroy         Revised to improve performance  08/7/97 fengsun
//-----------------------------------------------------------------------------
LPRASENTRY MyRGEP(LPCTSTR pszRasPbk, LPCTSTR pszEntryName, RasLinkageStruct *prlsRasLink) 
{
    LPRASENTRY preRasEntry;
    DWORD dwRes;

    if (!(preRasEntry = AllocateRasEntry()))
    {
        MYDBGASSERT(0);
        return NULL;
    }

    DWORD dwRasEntry = preRasEntry->dwSize;

    dwRes = prlsRasLink->pfnGetEntryProperties(pszRasPbk,
                                               pszEntryName,
                                               preRasEntry,
                                               &dwRasEntry,
                                               NULL,  // lpbDeviceInfo
                                               NULL); // lpdwDeviceInfoSize

    CMTRACE2(TEXT("MyRGEP() - dwRasEntry = %u : sizeof(*preRasEntry) = %u"), dwRasEntry, sizeof(*preRasEntry));
    
    if ((dwRes == ERROR_BUFFER_TOO_SMALL) && (dwRasEntry >= sizeof(*preRasEntry))) 
    {
        //
        // If the memory if not large enough, realloc one
        //
        CmFree(preRasEntry);

        preRasEntry = (LPRASENTRY) CmMalloc(dwRasEntry);

        if (NULL != preRasEntry)
        {
            //
            // dwSize has to be set to sizeof(RASENTRY)
            // because dwRasEntry contains the additional
            // bytes required for this connectoid (alternative
            // phone numbers, etc.
            //
            preRasEntry->dwSize = sizeof(RASENTRY); // Specifies version

            dwRes = prlsRasLink->pfnGetEntryProperties (pszRasPbk,
                                                        pszEntryName,
                                                        preRasEntry,
                                                        &dwRasEntry,
                                                        NULL,
                                                        NULL);
        }
        else
        {
            MYDBGASSERT(0);
            return NULL;
        }
    }

    if (dwRes != ERROR_SUCCESS) 
    {
        CMTRACE3(TEXT("MyRGEP(*pszRasPbk=%s, *pszEntryName=%s) RasGetEntryProperties returned %u"), pszRasPbk, pszEntryName, dwRes);
        CmFree(preRasEntry);
        preRasEntry = NULL;
    }

    SetLastError(dwRes);
    return (preRasEntry);
}

//+----------------------------------------------------------------------------
//
//  Function    IsConnectErrorFatal
//
//  Synopsis    Determine if an error is recoverable, (ie. we should re-dial). 
//
//  Arguments   DWORD dwErr             - The RAS error code
//              ArgsStruct* pArgs       - Ptr to global args struct
//
//  Returns     TRUE if error is fatal
//
//  Histroy     nickball    Created header  05/21/99     
//    
//-----------------------------------------------------------------------------
BOOL IsConnectErrorFatal(DWORD dwErr, ArgsStruct *pArgs)
{
    switch (dwErr)
    {
        //
        // The following cases are W9x ISDN error returns that actually mean
        // different things on WinNT.  Since we use the NT header files, we don't
        // have an include file that contains these errors.  We have to special
        // case these so that we recognize them as ISDN errors, and reconnect as
        // appropriate.
        //
        // The 9x errors are listed below along with the NT equivalents.
        //

    case 751:       // 9x.ERROR_BAD_DEST_ADDRESS    == NT.ERROR_INVALID_CALLBACK_NUMBER 
    case 752:       // 9x.ERROR_UNREACHABLE_DEST    == NT.ERROR_SCRIPT_SYNTAX
    case 753:       // 9x.ERROR_INCOMPATIBLE_DEST   == NT.ERROR_HANGUP_FAILED
    case 754:       // 9x.ERROR_NETWORK_CONGESTION  == NT.ERROR_BUNDLE_NOT_FOUND
    case 755:       // 9x.ERROR_CALL_BLOCKED        == NT.ERROR_CANNOT_DO_CUSTOMDIAL
    case 756:       // 9x.ERROR_NETWORK_TEMPFAILURE == NT.ERROR_DIAL_ALREADY_IN_PROGRESS
        if (OS_W9X)
        {
            //
            // On W9x, if you have an invalid ISDN number, the error codes
            // returned by Millennium RAS are different from the NT ones.
            // We have to special-case these by number so that we reconnect
            //
            CMTRACE1(TEXT("IsConnectErrorFatal : handled Win9x ISDN error %d"), dwErr);
            return FALSE;
        }
        break;

    case ERROR_PPP_TIMEOUT:             // Timed out waiting for a valid response from the remote PPP peer.%0
    case ERROR_PPP_REMOTE_TERMINATED:   // PPP terminated by remote machine.%0
    case ERROR_PPP_INVALID_PACKET:      // The PPP packet is invalid.%0
    case ERROR_PPP_NO_RESPONSE:         // Remote PPP peer is not responding
    case ERROR_SERVER_NOT_RESPONDING:
    case ERROR_LINE_BUSY:
    case ERROR_NO_CARRIER:
    case ERROR_REMOTE_DISCONNECTION:
    case ERROR_BAD_ADDRESS_SPECIFIED:
    case ERROR_AUTOMATIC_VPN_FAILED:    // New ras error for VPN
    case ERROR_NO_ANSWER: 
        return FALSE;
        break;

    case ERROR_PORT_DISCONNECTED:
        {
            if (0 == lstrcmpiU(pArgs->szDeviceType, RASDT_Isdn))
            {
                if ((CM_ISDN_MODE_DUALCHANNEL_ONLY == pArgs->dwIsdnDialMode) || (CM_ISDN_MODE_DUALCHANNEL_FALLBACK == pArgs->dwIsdnDialMode))
                {
                    OutputDebugString(TEXT("IsConnectErrorFatal -- Got a ERROR_PORT_DISCONNECTED error.  Ignoring because it is dual channel ISDN."));
                    CMTRACE(TEXT("IsConnectErrorFatal -- Got a ERROR_PORT_DISCONNECTED error.  Ignoring because it is dual channel ISDN."));
                    return FALSE;
                }
            }

            return TRUE;
            break;
        }

        
    default:
        break;
    }

    return TRUE;
}



//+----------------------------------------------------------------------------
//
//  Function    IsRasError
//
//  Synopsis    Simple function to determine if an error falls in the RAS range
//
//  Arguments   DWORD dwErr - The error code
//
//  Returns     TRUE if error is within RAS range
//
//  Histroy     nickball    Created header  05/21/99     
//    
//-----------------------------------------------------------------------------
inline BOOL IsRasError(DWORD dwErr)
{
   return ((dwErr >= RASBASE) && (dwErr <= RASBASEEND));
}

//+----------------------------------------------------------------------------
//
//  Function    CheckConnectionError
//
//  Synopsis    Determine if a RAS error is recoverable. If not recoverable, 
//              retrieves the appropriate error message for display.
//
//  Arguments   DWORD dwErr             - The RAS error code
//              ArgsStruct* pArgs       - Ptr to global args struct
//              BOOL   fTunneling       - Flag indicating whether we're tunneling
//              LPTSTR *ppszRasErrMsg   - Pointer to pointer for message string
//
//  Returns     TRUE if error is fatal
//
//  Histroy     nickball    Created header  05/21/99     
//    
//-----------------------------------------------------------------------------
BOOL CheckConnectionError(HWND hwndDlg, 
    DWORD dwErr, 
    ArgsStruct *pArgs,
    BOOL    fTunneling,
    LPTSTR   *ppszRasErrMsg)
{
    DWORD dwIdMsg = 0;
    LPTSTR pszMsg = NULL;
    LPTSTR pszTmp = NULL;

    //
    // Examine the error more closely. Note: For W2K, we skip RAS 
    // errors and query RAS for a displayable error string below.
    //

    if ((!OS_NT5) || (!IsRasError(dwErr)))
    {  
        switch (dwErr) 
        {
            case ERROR_PPP_TIMEOUT:             // Timed out waiting for a valid response from the remote PPP peer.%0
            case ERROR_PPP_REMOTE_TERMINATED:   // PPP terminated by remote machine.%0
            case ERROR_PPP_INVALID_PACKET:      // The PPP packet is invalid.%0
            case ERROR_PPP_NO_RESPONSE:         // Remote PPP peer is not responding
            case ERROR_SERVER_NOT_RESPONDING:
                dwIdMsg = IDMSG_PPPPROBLEM;
                break;

            case ERROR_LINE_BUSY:
                if ((pArgs->nDialIdx+1 == MAX_PHONE_NUMBERS || 
                    !pArgs->aDialInfo[pArgs->nDialIdx+1].szDialablePhoneNumber[0]) &&
                    !pArgs->nRedialCnt)
                    dwIdMsg = IDMSG_LINEBUSY;
                else
                    dwIdMsg = IDMSG_LINEBUSYREDIAL;

                break;

            case ERROR_NO_ANSWER:
            case ERROR_NO_CARRIER:
                if ((pArgs->nDialIdx+1 == MAX_PHONE_NUMBERS || 
                    !pArgs->aDialInfo[pArgs->nDialIdx+1].szDialablePhoneNumber[0]) &&
                    !pArgs->nRedialCnt)
                    dwIdMsg = fTunneling ? IDMSG_TUNNEL_NOANSWER : IDMSG_NOANSWER ;
                else
                    dwIdMsg = fTunneling ? IDMSG_TUNNEL_NOANSWERREDIAL : IDMSG_NOANSWERREDIAL;
                break;

            case ERROR_REMOTE_DISCONNECTION:
                dwIdMsg = IDMSG_REMOTEDISCONNECTED;
                break;

            case ERROR_BAD_ADDRESS_SPECIFIED:
                dwIdMsg = IDMSG_TUNNEL_NOANSWERREDIAL;
                break;

            case ERROR_PPP_NO_PROTOCOLS_CONFIGURED: // No PPP control protocols configured.%0
                dwIdMsg = IDMSG_TCPIPPROBLEM;
                break;

            case ERROR_PORT_ALREADY_OPEN:
                dwIdMsg = fTunneling ? IDMSG_TUNNELINUSE : IDMSG_PORTINUSE ;
                break;

            case ERROR_FROM_DEVICE:
                dwIdMsg = IDMSG_DEVICEERROR;
                break;

            case ERROR_HARDWARE_FAILURE:
            case ERROR_PORT_OR_DEVICE: //11694
            case ERROR_DEVICE_NOT_READY:
                dwIdMsg = IDMSG_NOTRESPONDING;
                break;

            case ERROR_NO_DIALTONE:
                dwIdMsg = IDMSG_NODIALTONE;
                break;

            case ERROR_CANCELLED:
            case ERROR_USER_DISCONNECTION:
                dwIdMsg = IDMSG_CANCELED;                
                break;

            case ERROR_AUTHENTICATION_FAILURE:
            case ERROR_ACCESS_DENIED: // 13795 // WINDOWS ERROR
                dwIdMsg = IDMSG_BADPASSWORD;
                break;

            case ERROR_VOICE_ANSWER:
                dwIdMsg = IDMSG_VOICEANSWER;
                break;
           
            case ERROR_PORT_NOT_AVAILABLE:
                if (IsDialingTunnel(pArgs))
                {
                    dwIdMsg = IDMSG_TUNNELNOTAVAILABLE;
                }
                else
                {
                    dwIdMsg = IDMSG_PORTNOTAVAILABLE;
                }
                break;

            case ERROR_PORT_NOT_CONFIGURED:
                dwIdMsg = IDMSG_PORTNOTCONFIGURED;
                break;

            case ERROR_RESTRICTED_LOGON_HOURS:
                dwIdMsg = IDMSG_RESTRICTEDLOGONHOURS;
                break;
    
            case ERROR_ACCT_DISABLED:
            case ERROR_ACCT_EXPIRED:
                dwIdMsg = IDMSG_ACCTDISABLED;
                break;

            case ERROR_PASSWD_EXPIRED:
                dwIdMsg = IDMSG_PASSWDEXPIRED;
                break;
    
            case ERROR_NO_DIALIN_PERMISSION:
                dwIdMsg = IDMSG_NODIALINPERMISSION;
                break;

            case ERROR_PROTOCOL_NOT_CONFIGURED:
                dwIdMsg = IDMSG_PROTOCOL_NOT_CONFIGURED;
                break;

            case ERROR_INVALID_DATA: // WINDOWS ERROR

                //
                // The specific case in which we encountered DUN settings
                // that aren't supported on the current platform
                //

                CMTRACE(TEXT("CheckConnectionError - Unsupported DUN setting detected"));
                dwIdMsg = IDMSG_UNSUPPORTED_SETTING;
                break;
        
            case ERROR_BAD_PHONE_NUMBER: // TBD - drop through to default
            default: 
                break;
        }
    }

    if (0 == dwIdMsg)
    {
        //
        // If no message ID was picked up, then try to get one from RAS
        //

        if (pArgs->rlsRasLink.pfnGetErrorString) 
        {
            DWORD dwRes;
            DWORD dwFmtMsgId;

            pszTmp = (LPTSTR) CmMalloc(256 * sizeof(TCHAR)); // Docs say 256 chars is always enough.
            
            if (pszTmp)
            {
                dwRes = pArgs->rlsRasLink.pfnGetErrorString((UINT) dwErr, pszTmp, (DWORD) 256);
 
                if (ERROR_SUCCESS == dwRes)
                {
                    pszMsg = CmFmtMsg(g_hInst, IDMSG_RAS_ERROR, pszTmp, dwErr);
                }
            }

            CmFree(pszTmp);
        }
        
        if (NULL == pszMsg)
        {
            //
            // Still no message, try to get description from system (on NT)
            // Note: HRESULTS are displayed in Hex, Win errors are decimal.
            
            if (OS_NT)
            {                
                if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS + FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL, dwErr, 0, (LPTSTR) &pszTmp, 1, NULL))
                {
                    if (pszTmp)
                    {
                        pszMsg = CmFmtMsg(g_hInst, (dwErr > 0x7FFFFFFF) ? IDMSG_SYS_ERROR_HEX : IDMSG_SYS_ERROR_DEC, pszTmp, dwErr);
                        LocalFree(pszTmp);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("CheckConnectionError -- FormatMessage failed to allocate pszTmp."));
                    }
                }
            }
            
            if (NULL == pszMsg)
            {
                //
                // Still no message, go with default
                //
                
                pszMsg = CmFmtMsg(g_hInst, (dwErr > 0x7FFFFFFF) ? IDMSG_CM_ERROR_HEX : IDMSG_CM_ERROR_DEC, dwErr);       
            }
        }
    }

    //
    // If we have a message ID format it for display
    //

    if (dwIdMsg) 
    {
        MYDBGASSERT(!pszMsg);
        pszMsg = CmFmtMsg(g_hInst,dwIdMsg);
    }

    if (pszMsg) 
    {
        if (!ppszRasErrMsg)
        {
            AppendStatusPane(hwndDlg,pszMsg);
            CmFree(pszMsg);
        }
        else
        {
            //
            // pass the msg to the caller.  the caller needs to free it.
            //
            *ppszRasErrMsg = pszMsg;
        }
    }

    BOOL bCancel = IsConnectErrorFatal(dwErr, pArgs);

    if (bCancel && dwErr != ERROR_CANCELLED && 
        dwErr != ERROR_AUTHENTICATION_FAILURE &&
        dwErr != ERROR_ACCESS_DENIED)
    {
        //
        // if we're canceling redial, then there might be something
        // seriously wrong.  We want to recheck our configs the next
        // time CM is run.
        //
        ClearComponentsChecked();
    }
    
    return (bCancel);
}

//+----------------------------------------------------------------------------
//
//  Function    GetRasConnectoidName
//
//  Synopsis    Construct a RAS connectoid name.
//
//              The connectoid name is "<long service name>-[Primary|Backup]".
//              or "<long service name>&Tunnel" for the case of tunnel entry.
//
//  Arguments   pArgs               Pointer to ArgsStruct
//              piniService[IN]     the service obj
//              fTunnelEntry[IN]    TRUE:  This connectoid is for tunneling
//                                  FALSE: otherwise
//
//  Returns     LPTSTR              The connectoid name.
//
//-----------------------------------------------------------------------------
LPTSTR GetRasConnectoidName(
    ArgsStruct  *pArgs, 
    CIni*       piniService, 
    BOOL        fTunnelEntry
)
{
    LPTSTR  pszConnectoid = GetServiceName(piniService);
    
    if (pszConnectoid)
    {       
        //
        // If tunneling 9X connectoid, append the Tunnel 
        // Suffix - e.g. "Tunnel (for advanced use only)"
        //

        if (OS_W9X && fTunnelEntry) 
        {
            LPTSTR pszSuffix = GetTunnelSuffix();       
   
            if (pszSuffix)
            {
                pszConnectoid = CmStrCatAlloc(&pszConnectoid, pszSuffix); 
            }
   
            CmFree(pszSuffix);
        }
    }   

    return pszConnectoid;
}

//+----------------------------------------------------------------------------
//
//  Function    CreateRASEntryStruct
//
//  Synopsis    Create a connectoid with the settings specified in the cms.
//              If a parameter does NOT exist in the cms file, the corresponding 
//              value is used.
//
//              The connectoid name is "<long service name>-[Primary|Backup]".
//              or "<long service name>&Tunnel" for the case of tunnel entry.
//
//  Arguments   pArgs               Pointer to ArgsStruct
//              pszDUN              DUN name
//              piniService[IN]     the service file obj
//              fTunnelEntry[IN]    TRUE:  This connectoid is for tunneling
//                                  FALSE: otherwise
//              pszRasPbk           the RAS phonebook in which the connectoid is located
//              ppbEapData[OUT]     Address of pointer to store EapData, allocated here.
//              pdwEapSize[OUT]     Ptr to a DWORD to record the size of the data blob.
//
//  Returns     LPRASENTRY          The new RAS connectoid
//
//  History     5/12/97     henryt      created
//              5/23/97     byao        Modified: added fSkipProfile flag
//              6/9/97      byao        Modified: use DUN= field when the 
//                                      phone number has no DUN name associated
//              7/28/97     byao        Added change for #10459
//              4/13/97     nickball    Renamed, return LPRASENTRY
//-----------------------------------------------------------------------------
LPRASENTRY CreateRASEntryStruct(
    ArgsStruct  *pArgs,
    LPCTSTR     pszDUN, 
    CIni*       piniService, 
    BOOL        fTunnelEntry,
    LPTSTR      pszRasPbk,
    LPBYTE              *ppbEapData,
    LPDWORD         pdwEapSize
)
{
    LPTSTR      pszDunEntry = NULL;
    DWORD       dwErr = NOERROR;
    BOOL        bTmp;

    //
    // first we need to create a RAS entry in memory with default values
    //

    LPRASENTRY  preBuffer = AllocateRasEntry();

    if (!preBuffer)
    {
        return NULL;
    }

    MYDBGASSERT(preBuffer->dwSize >= sizeof(*preBuffer));

    //
    // Set up the preBuffer to defaults value
    //

    preBuffer->dwFramingProtocol = RASFP_Ppp;

    //
    // Allow only TCP/IP by default
    //
    preBuffer->dwfNetProtocols |= RASNP_Ip;

    //
    // Set default RASEO settings.  
    //

    if (!fTunnelEntry)
    {
        preBuffer->dwfOptions |= RASEO_UseCountryAndAreaCodes   |
                                 RASEO_IpHeaderCompression      |
                                 RASEO_RemoteDefaultGateway     |
                                 RASEO_SwCompression;
                                 //RASEO_SecureLocalFiles;      // NT 427042
                                 //RASEO_DisableLcpExtensions;  //13059 Olympus + 289461 NT 
        //
        //  We want to honor the HideTrayIcon flag.  If it is not NT5, then
        //  we always set this flag.  If it is NT5, then we should only set
        //  this flag if HideTrayIcon is false.
        //

        if (!OS_NT5 || !(pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryHideTrayIcon)))
        {
            preBuffer->dwfOptions |= RASEO_ModemLights;
        }

        //
        //  In order for users to be able to specify device settings on Whistler,
        //  they have to do it from the control panel and we have to set the
        //  RASEO2_UseGlobalDeviceSettings flag in dwfOptions2.
        //
        if (OS_NT51)
        {
            ((LPRASENTRY_V501)preBuffer)->dwfOptions2 |= RASEO2_UseGlobalDeviceSettings;
        }

        //
        // We should have the devicename/devicetype by now.
        // (PickModem should be called)
        //
        
        MYDBGASSERT(pArgs->szDeviceType[0]);
        MYDBGASSERT(pArgs->szDeviceName[0]);

        lstrcpynU(preBuffer->szDeviceType, pArgs->szDeviceType, 
                    sizeof(preBuffer->szDeviceType)/sizeof(TCHAR));
        
        lstrcpynU(preBuffer->szDeviceName, pArgs->szDeviceName, 
                    sizeof(preBuffer->szDeviceName)/sizeof(TCHAR));
    }
    else
    {              
        preBuffer->dwfOptions = RASEO_IpHeaderCompression       |
                                RASEO_RemoteDefaultGateway      |
                                RASEO_NetworkLogon              |
                                RASEO_SwCompression;            
                                //RASEO_SecureLocalFiles        // NT 427042
                                //RASEO_DisableLcpExtensions    
        //
        //  Always set Modem lights on direct connection, unless HideTrayIcon
        //  flag is explicitly set in the .CMS. #262825, #262988
        //

        if (!(pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryHideTrayIcon)))
        {           
            preBuffer->dwfOptions |= RASEO_ModemLights;
        }
   
        MYDBGASSERT(pArgs->szTunnelDeviceType[0]);
        MYDBGASSERT(pArgs->szTunnelDeviceName[0]);

        lstrcpynU(preBuffer->szDeviceType, pArgs->szTunnelDeviceType, 
                    sizeof(preBuffer->szDeviceType)/sizeof(TCHAR));
                
        lstrcpynU(preBuffer->szDeviceName, pArgs->szTunnelDeviceName, 
                    sizeof(preBuffer->szDeviceName)/sizeof(TCHAR));

        lstrcpyU(preBuffer->szLocalPhoneNumber, pArgs->GetTunnelAddress());
    }

    //
    //  Check to see if we need to tell RAS that this connection has Internet Connectivity or not
    //
    if (OS_NT51)
    {
        //
        //  Note that we use the top level service profile on purpose here (pArgs->pIniService directly)
        //  as this is a profile global setting.
        //
        if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryInternetConnection,
                                     (BOOL) ((LPRASENTRY_V501)preBuffer)->dwfOptions2 & RASEO2_Internet)) 
        {
            ((LPRASENTRY_V501)preBuffer)->dwfOptions2 |= RASEO2_Internet;
        } 
        else 
        {
            ((LPRASENTRY_V501)preBuffer)->dwfOptions2 &= ~RASEO2_Internet;
        }
    }

    //
    // If we have a specific DUN name to use, then 
    // use it instead of the default DUN setting in the .CMS.
    //

    if (pszDUN && *pszDUN)
    {
        pszDunEntry = CmStrCpyAlloc(pszDUN);
    }
    else
    {
        pszDunEntry = GetDefaultDunSettingName(piniService, fTunnelEntry);
    }

    //
    // If we have a DUN setting name, read the settings from cms
    //

    if (pszDunEntry && *pszDunEntry)
    {
        dwErr = (DWORD)ReadDUNSettings(pArgs, piniService->GetFile(), pszDunEntry, preBuffer, ppbEapData ,pdwEapSize, fTunnelEntry);

        if (ERROR_SUCCESS != dwErr)
        {
            CMTRACE(TEXT("UpdateRASConnectoid: ReadDUNSettings failed"));
            CmFree(preBuffer);
            preBuffer = NULL;
            goto exit;
        }
    }

    //
    // Get autodial information, store in preBuffer
    //

    CopyAutoDial(preBuffer); 
        
    //
    // disable the RAS wizard on Win95
    //
    if (OS_W9X)
    {
        DisableWin95RasWizard();
    }

exit:
    if (pszDunEntry)
    {
        CmFree(pszDunEntry);
    }
      
    SetLastError(dwErr);

    return preBuffer;
}

//+----------------------------------------------------------------------------
//
//  Function    CreateRasPrivatePbk
//
//  Synopsis    Create the private RAS phone book and returns the full path.
//
//  Arguments   pArgs       Pointer to global Args struct
//
//  Returns     LPTSTR      The full path name of the newly created private pbk
//
//  History     ??/??/97    henryt      created
//
//              01/15/99    Jeffspr     Changed the GetTempFileName pattern,
//                                      as it was using more than the allowed/
//                                      used 3 chars, plus made the failure 
//                                      case use the same pattern (we will 
//                                      filter on this in the connection 
//                                      enumerator to ignore these entries).
//
//              05/21/99    nickball    Added allocation, removed input buf
//              04/10/00    quintinb    Removed GetTempFileName as we no longer
//                                      want this file to be temporary.  Changed
//                                      the function to create a file named _cmphone.pbk
//                                      in the profile directory.
//                                      Please see Whistler bug 15812 for details.
//              07/05/00    t-urama     Changed the path to the hidden pbk to point
//                                      to the RAS pbk.
//
//-----------------------------------------------------------------------------

LPTSTR CreateRasPrivatePbk(ArgsStruct  *pArgs)
{   
    //
    //  No private PBK on win9x, everything is in the registry.
    //
    if (OS_W9X)
    {
        return NULL;
    }

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return NULL;
    }

    LPTSTR pszHiddenPbkPath = NULL;
    LPCTSTR pszCmp = pArgs->piniProfile->GetFile();

    //
    // This version of the function uses the function GetPathToPbk in connect.cpp to find the path
    // to the phone book. The hidden phone book also has to be created in the same directory.
    //
    if (pszCmp)
    {
        LPTSTR pszRasPbkDir = GetPathToPbk(pszCmp, pArgs);
        MYDBGASSERT(pszRasPbkDir);

        if (pszRasPbkDir)
        {
            pszHiddenPbkPath = (LPTSTR) CmMalloc((lstrlen(pszRasPbkDir) + lstrlen(CM_PBK_FILTER_PREFIX) + 7) * sizeof(TCHAR));

            if (pszHiddenPbkPath)
            {
                wsprintfU(pszHiddenPbkPath, TEXT("%s\\%sphone"), pszRasPbkDir, CM_PBK_FILTER_PREFIX);
                MYDBGASSERT(pszHiddenPbkPath);
                
                HANDLE hFile = INVALID_HANDLE_VALUE;
               
                hFile = CreateFileU(pszHiddenPbkPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

                if (hFile == INVALID_HANDLE_VALUE)
                {
                    DWORD dwLastError = GetLastError();
                    MYDBGASSERT(hFile != INVALID_HANDLE_VALUE);
                    CMTRACE1(TEXT("CreateRasPrivatePbk - CreateFileU failed. GetLastError = %d"), dwLastError);
                }
                else if (OS_NT5 && pArgs->fAllUser)
                {
                    //
                    //  Set the file permissions on the hidden pbk file so that everyone has write access to it.
                    //
                    MYVERIFY(AllowAccessToWorld(pszHiddenPbkPath));
                }                

                CloseHandle(hFile);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("CreateRasPrivatePbk -- CmMalloc returned NULL for pszHiddenPbkPath"));
            }

            CmFree(pszRasPbkDir);
        }
    }
    
    return pszHiddenPbkPath;
}



//+----------------------------------------------------------------------------
//
//      Function        GetPathToPbk
//
//      Synopsis        This function is a helper function called by 
//                      CheckAccessToCmpAndPbk in connect.cpp and by 
//                      CreateRasPrivatePbk. It returns the path to the RAS
//                      phonebook.
//
//      Arguments       LPTSTR pszCmp       - The path to the cmp file
//                      LPTSTR pszRasPbk    - The string to store the result
//                      ArgsStruct *pArgs   - pArgs
//
//      Returns         NONE
//
//      History         07/05/00                        t-urama         created
//----------------------------------------------------------------------------- 
LPTSTR GetPathToPbk(LPCTSTR pszCmp, ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs); 
    if (NULL == pArgs)
    {
        return NULL;
    }

    MYDBGASSERT(pszCmp); 
    if (NULL == pszCmp)
    {
        return NULL;
    }

    LPTSTR pszRasPbk = NULL;

    //
    //  pszRasPbk could be NULL if we are on NT4 or we are using the
    //  all user default phonebook.
    //
    if (NULL == pArgs->pszRasPbk)
    {
        if (OS_NT4)
        {
            DWORD dwSize = (MAX_PATH + 1);
            DWORD dwRet;
            BOOL bExitLoop = TRUE;

            do
            {
                pszRasPbk = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));

                if (pszRasPbk)
                {
                    dwRet = GetSystemDirectoryU(pszRasPbk, dwSize);
                    if (dwRet)
                    {
                        if (dwRet > dwSize)
                        {
                            dwSize = dwRet + 1;
                            bExitLoop = FALSE;  //  we didn't get all of the string, try again
                            CmFree(pszRasPbk);
                        }
                        else
                        {
                            bExitLoop = TRUE;
                            CmStrCatAlloc(&pszRasPbk, c_pszRasDirRas);
                        }
                    }
                    else
                    {
                        CmFree(pszRasPbk);
                        pszRasPbk = NULL;
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- CmMalloc failed!"));
                    return NULL;
                }
            } while (!bExitLoop);
        }
        else
        {
            pszRasPbk = CmStrCpyAlloc(pszCmp);

            if (pszRasPbk)
            {
                LPTSTR pszSlash = CmStrrchr(pszRasPbk, TEXT('\\'));
                if (pszSlash)
                {
                    *pszSlash = TEXT('\0'); // remove <shortservicename>.cmp

                    pszSlash = CmStrrchr(pszRasPbk, TEXT('\\'));

                    if (pszSlash)
                    {
                        *pszSlash = TEXT('\0');

                        CmStrCatAlloc(&pszRasPbk, TEXT("\\"));
                        CmStrCatAlloc(&pszRasPbk, c_pszPbk);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- unable to convert cmp path to pbk path."));
                        CmFree(pszRasPbk);
                        pszRasPbk = NULL;
                    }

                
                }
                 
                else
                {
                    CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- unable to convert cmp path to pbk path!"));
                    CmFree(pszRasPbk);
                    pszRasPbk = NULL;
                }
            }
        }
    }
    else
    {
        pszRasPbk = CmStrCpyAlloc(pArgs->pszRasPbk);
        LPTSTR pszSlash = CmStrrchr(pszRasPbk, TEXT('\\'));
        if (pszSlash)
        {
            *pszSlash = TEXT('\0'); // remove the RAS phonebook name
        }   
        else
        {
            CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- unable to convert RAS pbk name to pbk path!"));
            CmFree(pszRasPbk);
            pszRasPbk = NULL;
        }
    }

    return pszRasPbk;
}

//+----------------------------------------------------------------------------
//
//      Function        DisableWin95RasWizard
//
//      Synopsis        This function disable the Win95 Dial-up Networking wizard
//              by writing a dword reg value 0x00000080 in the registry.
//
//      Arguments       NONE
//
//      Returns         NONE
//
//      History         7/1/97                          henryt          created
//-----------------------------------------------------------------------------
void DisableWin95RasWizard(
    void)
{
    HKEY    hkReg = NULL;
    LONG    lRes;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwValue;

    lRes = RegOpenKeyExA(HKEY_CURRENT_USER, c_pszRegRemoteAccess, 0,
                         KEY_QUERY_VALUE|KEY_SET_VALUE, &hkReg);

    if (ERROR_SUCCESS != lRes)
    {
        CMTRACE1(TEXT("DisableWin95RasWizard() RegOpenKeyEx() failed, GLE=%u."), lRes);
        goto exit;
    }
        
    //
    // see if we already have a value there.
    //
    dwSize = sizeof(DWORD);
    lRes = RegQueryValueExA(hkReg, 
                            c_pszRegWizard, 
                            NULL, 
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize);

    if (lRes == ERROR_SUCCESS   &&
        dwSize == sizeof(DWORD) &&
        dwType == REG_BINARY    &&
        dwValue == ICM_RAS_REG_WIZARD_VALUE) 
    {
        CMTRACE(TEXT("DisableWin95RasWizard() RegQueryValueEx() - found correct value."));
        goto exit;
    }
        
    //
    // well, the value is not in reg yet.  we need to create the value.
    //
    dwValue = ICM_RAS_REG_WIZARD_VALUE;
    lRes = RegSetValueExA(hkReg, 
                          c_pszRegWizard,
                          0, 
                          REG_BINARY, 
                          (LPBYTE)&dwValue, 
                          sizeof(dwValue));
#ifdef DEBUG
    if (ERROR_SUCCESS != lRes)
    {
        CMTRACE1(TEXT("DisableWin95RasWizard() RegSetValueEx() failed, GLE=%u."), lRes);
    }
#endif    
exit:

    if (hkReg)
    {
        lRes = RegCloseKey(hkReg);

#ifdef DEBUG
        if (ERROR_SUCCESS != lRes)
        {
            CMTRACE1(TEXT("DisableWin95RasWizard() RegCloseKey() failed, GLE=%u."), lRes);
        }
#endif
    }
    return;
}



//+----------------------------------------------------------------------------
//
//  Function    SetIsdnDualChannelEntries
//
//  Synopsis    As what the func name says.  We prepare the RASENTRY and
//              RASSUBENTRY properly.  We don't actually make RAS calls to
//              save the entries. We'll leave it to the caller(so that the
//              can make other changes to the structs for other reasons and 
//              commit the changes in 1 or 2 RAS calls).
//
//  Arguments   pArgs [IN]          Pointer to ArgsStruct
//              pRasEntry [IN/OUT]  rasentry to be filled
//              ppRasSubEntry [OUT] pointer to be filled with the subentry array
//                                  The buffer is allocated in this function.
//              pdwSubEntryCount    Number of subentries allocated.
//
//  Returns     BOOL                TRUE = success, FALSE = failure.
//
//-----------------------------------------------------------------------------
BOOL SetIsdnDualChannelEntries(ArgsStruct *pArgs, LPRASENTRY pRasEntry,
                                      LPRASSUBENTRY *ppRasSubEntry, PDWORD pdwSubEntryCount)
{
    //
    //  Lets check the input parameters
    //
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pRasEntry);
    MYDBGASSERT(ppRasSubEntry);
    MYDBGASSERT(pdwSubEntryCount);
    if ((NULL == pArgs) || (NULL == pRasEntry) || (NULL == ppRasSubEntry) ||
        (NULL == pdwSubEntryCount))
    {
        return FALSE;
    }
    
    //
    //  Since we don't support BAP if they called this function they must have wanted
    //  to do DualChannel ISDN.  If the dial mode isn't set for dual channel, we will
    //  assert an continue.  Better to connect the user in dual channel mode then not
    //  at all if they have a misconfigured profile.
    //
    MYDBGASSERT(pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL);

    //
    //  Check the size of the passed in RasEntry struct.  If it isn't at least
    //  a 4.01 size struct, then return.
    //
    MYDBGASSERT(pRasEntry->dwSize >= sizeof(LPRASENTRY_V401));
    if (sizeof(LPRASENTRY_V401) > pRasEntry->dwSize)
    {
        return FALSE;
    }

    LPRASENTRY_V401 pRasEntry401 = (LPRASENTRY_V401)pRasEntry;

    //
    // set isdn dial mode to dial both channels
    //
    pRasEntry401->dwDialMode = RASEDM_DialAll;
    CMTRACE(TEXT("ISDN Dual Channel Mode On"));

    if (OS_NT)
    {
       *pdwSubEntryCount = 2;
    }
    else if (OS_MIL)
    {
        // 112351: 9x only requires one sub entry.  We'll keep the device name the same.
        // In this case, Win9x will work as follows:
        //  for the 1st channel, the device name provided works fine.
        //  for the 2nd channel, 9x sees the device is in use and looks for the
        //  the closest match (which is the 2nd channel).
        //
    
       *pdwSubEntryCount = 1;
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("SetIsdnDualChannelEntries -- Function called on a platform other than NT or Millennium."));
        return FALSE;
    }

    //
    //  Allocate the sub entries
    //
    *ppRasSubEntry = (LPRASSUBENTRY)CmMalloc((*pdwSubEntryCount)*(sizeof(RASSUBENTRY)));

    if (NULL == *ppRasSubEntry)
    {
        CMASSERTMSG(FALSE, TEXT("SetIsdnDualChannelEntries -- CmMalloc failed to alloc ppRasSubEntry."));
        return FALSE;
    }

    //
    //  Fill in the sub entries with the device and phonenumber information
    //
    for (DWORD dwIndex=0; dwIndex < (*pdwSubEntryCount); dwIndex++)
    {
        (*ppRasSubEntry)[dwIndex].dwSize = sizeof(RASSUBENTRY);
        lstrcpyU((*ppRasSubEntry)[dwIndex].szDeviceType, pArgs->szDeviceType);
        lstrcpyU((*ppRasSubEntry)[dwIndex].szDeviceName, pArgs->szDeviceName);
        lstrcpyU((*ppRasSubEntry)[dwIndex].szLocalPhoneNumber, pRasEntry401->szLocalPhoneNumber);
    }
    
    return TRUE;
}

//
// Keep in case we ever want to support BAP
//
/*
BOOL SetIsdnDualChannelEntries(
    ArgsStruct              *pArgs,
    LPRASENTRY              pre,
    LPRASSUBENTRY           *prgrse,
    PDWORD                  pdwSubEntryCount
)
{
    LPRASENTRY_V401 pre401;

    MYDBGASSERT(pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL);

    MYDBGASSERT(pre->dwSize >= sizeof(LPRASENTRY_V401));
    pre401 = (LPRASENTRY_V401)pre;

    //
    // set isdn dial mode
    //

    if (pArgs->dwIsdnDialMode == CM_ISDN_MODE_DIALALL)
    {
        //
        // dial both channels
        //
        pre401->dwDialMode = RASEDM_DialAll;
        CMTRACE(TEXT("ISDN Dual Channel Mode On"));
    }
    else
    {
        //
        // dial 2nd channel on demand
        //

        //
        // First get the 4 thresholds
        //
        if (!pArgs->dwDialExtraPercent)
        {
            pArgs->dwDialExtraPercent = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                 c_pszCmEntryDialExtraPercent, 
                                                                 DEFAULT_DIALEXTRAPERCENT);
            if (pArgs->dwDialExtraPercent < 0 ||
                pArgs->dwDialExtraPercent > 100)
            {
                pArgs->dwDialExtraPercent = DEFAULT_DIALEXTRAPERCENT;
            }
        }
        
        if (!pArgs->dwDialExtraSampleSeconds)
        {
            pArgs->dwDialExtraSampleSeconds = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                       c_pszCmEntryDialExtraSampleSeconds, 
                                                                       DEFAULT_DIALEXTRASAMPLESECONDS);
            if (pArgs->dwDialExtraSampleSeconds < 0)
            {
                pArgs->dwDialExtraSampleSeconds = DEFAULT_DIALEXTRASAMPLESECONDS;
            }
        }
    
        if (!pArgs->dwHangUpExtraPercent)
        {
            pArgs->dwHangUpExtraPercent = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                   c_pszCmEntryHangUpExtraPercent, 
                                                                   DEFAULT_HANGUPEXTRAPERCENT);
            if (pArgs->dwHangUpExtraPercent < 0 ||
                pArgs->dwHangUpExtraPercent > 100)
            {
                pArgs->dwHangUpExtraPercent = DEFAULT_HANGUPEXTRAPERCENT;
            }
        }
        
        if (!pArgs->dwHangUpExtraSampleSeconds)
        {
            pArgs->dwHangUpExtraSampleSeconds = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                         c_pszCmEntryHangUpExtraSampleSeconds, 
                                                                         DEFAULT_HANGUPEXTRASAMPLESECONDS);
            if (pArgs->dwHangUpExtraSampleSeconds < 0)
            {
                pArgs->dwHangUpExtraSampleSeconds = DEFAULT_HANGUPEXTRASAMPLESECONDS;
            }
        }

        //
        // set multilink info
        //
        pre401->dwDialMode = RASEDM_DialAsNeeded;

        pre401->dwDialExtraPercent          = pArgs->dwDialExtraPercent;
        pre401->dwDialExtraSampleSeconds    = pArgs->dwDialExtraSampleSeconds;
        pre401->dwHangUpExtraPercent        = pArgs->dwHangUpExtraPercent;
        pre401->dwHangUpExtraSampleSeconds  = pArgs->dwHangUpExtraSampleSeconds;

        CMTRACE2(TEXT("ISDN 2nd Channel Dial On Demand: dial extra %u%%, dial extra %u sample secs"),
                 pre401->dwDialExtraPercent, pre401->dwDialExtraSampleSeconds);

        CMTRACE2(TEXT("\t\thangup extra %u%%, hangup extra %u sample secs"),
                 pre401->dwHangUpExtraPercent, pre401->dwHangUpExtraSampleSeconds);
    }


    if (OS_NT)
    {
        if (!(*prgrse = (LPRASSUBENTRY)CmMalloc(2*sizeof(RASSUBENTRY))))
        {
            CMTRACE(TEXT("SetIsdnDualChannelEntries failed to alloc a ras sub entry"));
            return FALSE;
        }
        
        ZeroMemory((PVOID)*prgrse, 2*sizeof(RASSUBENTRY));

        //
        // first channel
        //
        (*prgrse)[0].dwSize = sizeof(RASSUBENTRY);
        lstrcpyU((*prgrse)[0].szDeviceType, pArgs->szDeviceType);
        lstrcpyU((*prgrse)[0].szDeviceName, pArgs->szDeviceName);
        lstrcpyU((*prgrse)[0].szLocalPhoneNumber, pre401->szLocalPhoneNumber);

        //
        // the 2nd channel is identical
        //
        CopyMemory((PVOID)(*prgrse + 1), (PVOID)*prgrse, sizeof(RASSUBENTRY));

        *pdwSubEntryCount = 2;
    }
    else
    {
        MYDBGASSERT(OS_MIL);

        CMTRACE(TEXT("doing the Millennium subentry stuff"));

        // 112351: 9x only requires one sub entry.  We'll keep the device name the same.
        // In this case, Win9x will work as follows:
        //  for the 1st channel, the device name provided works fine.
        //  for the 2nd channel, 9x sees the device is in use and looks for the
        //  the closest match (which is the 2nd channel).
        //

        if (!(*prgrse = (LPRASSUBENTRY)CmMalloc(1*sizeof(RASSUBENTRY))))
        {
            CMTRACE(TEXT("SetIsdnDualChannelEntries failed to alloc a ras sub entry"));
            return FALSE;
        }

        ZeroMemory((PVOID)*prgrse, 1*sizeof(RASSUBENTRY));

        //
        // 2nd channel
        //
        (*prgrse)[0].dwSize = sizeof(RASSUBENTRY);
        lstrcpyU((*prgrse)[0].szDeviceType, pArgs->szDeviceType);
        lstrcpyU((*prgrse)[0].szDeviceName, pArgs->szDeviceName);
        lstrcpyU((*prgrse)[0].szLocalPhoneNumber, pre401->szLocalPhoneNumber);

        *pdwSubEntryCount = 1;
    }
    return TRUE;
}
*/


//+----------------------------------------------------------------------------
//
//      Function        SetNtIdleDisconnectInRasEntry
//
//      Synopsis        As what the func name says.  We prepare the RASENTRY and
//              RASSUBENTRY properly.  We don't actually make RAS calls to
//              save the entries. We'll leave it to the caller(so that the
//              can make other changes to the structs for other reasons and 
//              commit the changes in 1 or 2 RAS calls).
//
//      Arguments       pArgs [IN]              Pointer to ArgsStruct
//              pre   [OUT]         Pointer to RASENTRY with the correct size
//
//      Returns         BOOL                TRUE = success, FALSE = failure.
//
//-----------------------------------------------------------------------------
BOOL SetNtIdleDisconnectInRasEntry(
    ArgsStruct      *pArgs,
    LPRASENTRY      pre
)
{
    if (!OS_NT4)
    {
        return FALSE;
    }
    
    if ((NULL == pArgs) || (NULL == pre) || (pre->dwSize < sizeof(LPRASENTRY_V401)))
    {
        CMASSERTMSG(FALSE, TEXT("SetNtIdleDisconnectInRasEntry -- Invalid parameter"));
        return FALSE;
    }

    //
    // If idle-disconnect is enabled, use the options value otherwise 
    // pArgs->dwIdleTimeout is in minutes.  Note that 0xFFFFFFFF means
    // no idle disconnect to RAS but 0 is the value we use to mean never
    // idle disconnect in the CMS.
    //

    DWORD dwIdle = (pArgs->dwIdleTimeout * 60);

    if (0 == dwIdle)
    {
        dwIdle = (DWORD)-1;
    }

    ((LPRASENTRY_V401 )pre)->dwIdleDisconnectSeconds = dwIdle;

    CMTRACE1(TEXT("SetNtIdleDisconnect: current idle Timeout is %u seconds."), dwIdle);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:   DisableSystemIdleDisconnect
//
// Synopsis:   This function sets the idle timeout value of a RAS connection to
//             be disabled.
//
// Arguments:  LPRASENTRY pre - pointer to a RASENTRY to disable idle disconnect for
//
// Returns:    BOOL TRUE = success, FALSE = failure.
//
//-----------------------------------------------------------------------------
BOOL DisableSystemIdleDisconnect(LPRASENTRY pre)
{
    if ((NULL == pre) || (pre->dwSize < sizeof(LPRASENTRY_V401)))
    {
        CMASSERTMSG(FALSE, TEXT("DisableSystemIdleDisconnect -- Invalid parameter"));
        return FALSE;
    }

    //
    // Set the idle time to 0xFFFFFFFF which means no idle disconnect to RAS
    //

    ((LPRASENTRY_V401 )pre)->dwIdleDisconnectSeconds = (DWORD)-1;

    CMTRACE(TEXT("DisableSystemIdleDisconnect -- System Idle disconnect disabled"));

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//      Function        RasDialFunc2
//
//      Synopsis        A RAS callback type 2 for RasDial.
//
//      Arguments       
//      ULONG_PTR dwCallbackId,// user-defined value specified in RasDial 
//      DWORD dwSubEntry,      // subentry index in multilink connection
//      HRASCONN hrasconn,     // handle to RAS connection
//      UINT unMsg,            // type of event that has occurred
//      RASCONNSTATE rascs,    // connection state about to be entered
//      DWORD dwError,         // error that may have occurred
//      DWORD dwExtendedError  // extended error information for some errors
//
//      Returns         LPRASENTRY - pointer to the RASENTRY structure allocated
//
//-----------------------------------------------------------------------------
DWORD WINAPI RasDialFunc2(
    ULONG_PTR dwCallbackId,     // user-defined value specified in RasDial 
    DWORD dwSubEntry,           // subentry index in multilink connection
    HRASCONN hrasconn,          // handle to RAS connection
    UINT unMsg,                 // type of event that has occurred
    RASCONNSTATE rascs,         // connection state about to be entered
    DWORD dwError,              // error that may have occurred
    DWORD dwExtendedError       // extended error information for some errors
)
{   
    CMTRACE2(TEXT("RasDialFunc2():  dwSubentry=%u. dwErr=0x%x"), dwSubEntry, dwError);
    CMTRACE2(TEXT("RasDialFunc2():  dwExtendedErr=0x%x, rascs=%u"), dwExtendedError, rascs);

    MYDBGASSERT(dwCallbackId);

    if (dwCallbackId)
    {
        ArgsStruct *pArgs = (ArgsStruct *) dwCallbackId;        
        pArgs->dwRasSubEntry = dwSubEntry;

        //CMTRACE1(TEXT("RasDialFunc2():  pArgs->lInConnectOrCancel=%d"),pArgs->lInConnectOrCancel);
        //CMASSERTMSG((NOT_IN_CONNECT_OR_CANCEL == pArgs->lInConnectOrCancel),
        //            TEXT("RasDialFunc2 - RasDial mutex is NOT NULL..."));

        SendMessage(pArgs->hwndMainDlg, pArgs->uMsgId, rascs, dwError);
    }

    return 1;
}

//+----------------------------------------------------------------------------
//
// Function:  SetRasDialExtensions
//
// Synopsis:  Encapsulates initialization and configuration of the 
//            RasDialExtensions that we use on NT.
//
// Arguments: pArgs - Ptr to global args struct
//            fEnablePausedStates - Use Paused states or not
//            fEnableCustomScripting - whether to use custom scripting or not
//
// Returns:   DWORD - Error code
//
// History:   nickball      Created    7/22/99
//
//+----------------------------------------------------------------------------
DWORD SetRasDialExtensions(ArgsStruct* pArgs, BOOL fEnablePausedStates, BOOL fEnableCustomScripting)
{
    DWORD dwRes = ERROR_SUCCESS;

    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If not already allocated, we need a RasDialExtensions struct
    //

    if (!pArgs->pRasDialExtensions)
    {
        pArgs->pRasDialExtensions = AllocateAndInitRasDialExtensions();

        if (!pArgs->pRasDialExtensions)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {                    
        dwRes = InitRasDialExtensions(pArgs->pRasDialExtensions);
    }

    if (ERROR_SUCCESS != dwRes)
    {
        goto SetRasDialExtensionsExit;
    }

    //
    // Turn on PauseStates for NT
    //

    if (fEnablePausedStates)
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_PausedStates; 
    }

    //
    //  Turn on custom scripting if we are running on Whistler+ and the caller
    //  asked for it.
    //
    if (fEnableCustomScripting && OS_NT51)
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_UseCustomScripting;
    }

    //
    // RDEOPT_NoUser is required for the WinLogon credential case, 
    // which we identify by the presence of either lpEapLogonInfo 
    // or lpRasNoUser.  Note that the if statement below is somewhat redundant
    // since we should have CM_LOGON_TYPE_WINLOGON set if we get either a NoUser
    // struct or an EapLogonInfo struct.  However, wanted to point out that on Win2k
    // one of the first two will always be true and on Whistler the first two may be
    // false but the third true (RAS now sends a flag to tell us when we are at WinLogon on 
    // whistler as there are Ctrl-Alt-Del with SmartCard cases where it sends neither struct).
    //

    if (pArgs->lpEapLogonInfo || pArgs->lpRasNoUser || (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType))
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_NoUser;
    }

    //
    // If the modem speaker is turned off, makes sure that we
    // disable it explicitly in RAS, otherwise it will use 
    // its default and turn the speaker on. These settings 
    // should be ignored by RAS in the tunnel case.
    //

    if (pArgs->tlsTapiLink.bModemSpeakerOff)
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_IgnoreModemSpeaker;
        pArgs->pRasDialExtensions->dwfOptions &= ~RDEOPT_SetModemSpeaker;
    }

SetRasDialExtensionsExit:

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Function:  InitRasDialExtensions
//
// Synopsis:  Flushes a previously allocated RasDialExtensions buffer and sets
//            size, options for re-use.
//
// Arguments: LPRASDIALEXTENSIONS - Ptr to allocated struct with size set.
//
// Returns:   DWORD - Error code
//
// History:   nickball      Created    5/22/99
//
//+----------------------------------------------------------------------------
DWORD InitRasDialExtensions(LPRASDIALEXTENSIONS lpRasDialExtensions)
{   
    MYDBGASSERT(lpRasDialExtensions);

    if (NULL == lpRasDialExtensions)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First, we determine the size
    //

    DWORD dwSize = OS_NT5 ? sizeof(RASDIALEXTENSIONS_V500) : sizeof(RASDIALEXTENSIONS);

    //
    // Flush buffer and reset size.
    //

    ZeroMemory(lpRasDialExtensions, dwSize);

    lpRasDialExtensions->dwSize = dwSize;

    //
    // Set customdial if needed
    //

    if (dwSize == sizeof(RASDIALEXTENSIONS_V500))
    {  
        // 
        // Set the CustomDial flag for NT5. We don't set this on NT4 
        // and 9X as a precaution because the falg isn't defined.
        //

        lpRasDialExtensions->dwfOptions |= RDEOPT_CustomDial;
    }

    CMTRACE1(TEXT("InitRasDialExtensions() - dwSize is %u"), dwSize);

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateAndInitRasDialExtensions
//
// Synopsis:  Encapsulates the allocation of a RASEXTENSION based upon the OS
//
// Arguments: None
//
// Returns:   LPRASDIALEXTENSIONS - Ptr to allocated struct with size set.
//
// History:   nickball      Created    5/13/99
//
//+----------------------------------------------------------------------------
LPRASDIALEXTENSIONS AllocateAndInitRasDialExtensions()
{
    //
    // Allocate struct and pre-fill as appropriate
    //

    LPRASDIALEXTENSIONS prdeNew = (LPRASDIALEXTENSIONS)CmMalloc(OS_NT5 ? 
        sizeof(RASDIALEXTENSIONS_V500) : sizeof(RASDIALEXTENSIONS));

    if (!prdeNew)
    {
        CMTRACE(TEXT("AllocateAndInitRasDialExtensions: failed to alloc RasDialExtension buffer"));
        return NULL;
    }
    
    InitRasDialExtensions(prdeNew);

    return prdeNew;
}

//+----------------------------------------------------------------------------
//
// Function:  InitRasDialParams
//
// Synopsis:  Flushes a previously allocated RasDialParams buffer and sets
//            size, options for re-use.
//
// Arguments: LPRASDIALPARAMS - Ptr to allocated struct with size set.
//
// Returns:   DWORD - Error code
//
// History:   nickball      Created    5/22/99
//
//+----------------------------------------------------------------------------
DWORD InitRasDialParams(LPRASDIALPARAMS lpRasDialParams)
{   
    MYDBGASSERT(lpRasDialParams);

    if (NULL == lpRasDialParams)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First, we determine the size
    //

    DWORD dwSize = OS_NT ? sizeof(RASDIALPARAMS_V401) : sizeof(RASDIALPARAMS);

    //
    // Flush buffer and reset size.
    //

    ZeroMemory(lpRasDialParams, dwSize);

    lpRasDialParams->dwSize = dwSize;

    CMTRACE1(TEXT("InitRasDialParams() - dwSize is %u"), dwSize);

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateAndInitRasDialParams
//
// Synopsis:  Encapsulates the allocation of a RASDIALPARAMS based upon the OS
//
// Arguments: None
//
// Returns:   LPRASDIALPARAMS - Ptr to allocated struct with size set.
//
// History:   nickball      Created    5/22/99
//
//+----------------------------------------------------------------------------
LPRASDIALPARAMS AllocateAndInitRasDialParams()
{
    //
    // Allocate struct and pre-fill as appropriate
    //

    LPRASDIALPARAMS prdpNew = (LPRASDIALPARAMS)CmMalloc(OS_NT ? 
        sizeof(RASDIALPARAMS_V401) : sizeof(RASDIALPARAMS));

    if (!prdpNew)
    {
        CMTRACE(TEXT("AllocateRasDialParams: failed to alloc RasDialParams buffer"));
        return NULL;
    }
    
    InitRasDialParams(prdpNew);

    return prdpNew;
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateRasEntry
//
// Synopsis:  Encapsulates the allocation of a RASENTRY struct based upon the OS
//
// Arguments: None
//
// Returns:   LPRASENTRY - Ptr to allocated struct with size set.
//
// History:   nickball  Created Header    5/13/99
//
//+----------------------------------------------------------------------------
LPRASENTRY AllocateRasEntry()
{
    static DWORD    s_dwRasEntrySize = -1;

    //
    // first, we determine the size
    //
    if (s_dwRasEntrySize == -1)
    {                
        if (OS_NT51)
        {
            //
            // Whistler
            //
            s_dwRasEntrySize = sizeof(RASENTRY_V501);
        }
        else if (OS_W2K)
        {
            //
            // nt5
            //
            s_dwRasEntrySize = sizeof(RASENTRY_V500);        
        }
        else if (OS_MIL || OS_NT4)
        {
            //
            // Millennium uses the NT4 structure
            //
            s_dwRasEntrySize = sizeof(RASENTRY_V401);
        }
        else
        {
            //
            // win9x
            //
            s_dwRasEntrySize = sizeof(RASENTRY);
        }
    }

    //
    // add 512 bytes since a rasentry can contain alternate phone #'s
    // See RASENTRY.dwAlternateOffset 
    //
    LPRASENTRY preNew = (LPRASENTRY)CmMalloc(s_dwRasEntrySize+512);

    if (!preNew)
    {
        CMTRACE(TEXT("AllocateRasEntry: failed to alloc rasentry buffer"));
        return NULL;
    }
    
    preNew->dwSize = s_dwRasEntrySize;
    if (s_dwRasEntrySize >= sizeof(RASENTRY_V500))
    {
        ((LPRASENTRY_V500)preNew)->dwType = RASET_Internet;
   
        //
        // For NT5, set szCustomDialDll with our Module name. This ensures that our
        // custom DialDlg, DialEntry, and Hangup routines will be called by RAS for
        // operations on our connectoid. We don't want to tie our path to anything 
        // machine specific, so we'll use the %windir% environment string. 
        // 

        lstrcpyU(((LPRASENTRY_V500)preNew)->szCustomDialDll, c_pszCmDialPath);
    }

    CMTRACE1(TEXT("AllocateRasEntry() - s_dwRasEntrySize is %u"), s_dwRasEntrySize);

    return preNew;
}

#if 0
/*

//+----------------------------------------------------------------------------
//
// Function:  GetRasSystemPhoneBookPath
//
// Synopsis:  Builds the conventional path to the RAS system phonebook
//
// Arguments: None
//
// Returns:   LPTSTR - The phonebook path 
//
// History:   nickball    Created    8/14/98
//
//+----------------------------------------------------------------------------
LPTSTR GetRasSystemPhoneBookPath()
{
    MYDBGASSERT(OS_NT);
    
    TCHAR szTemp[MAX_PATH+1];

    GetSystemDirectoryU(szTemp,sizeof(szTemp));
    lstrcatU(szTemp, c_pszRasDirRas);
    lstrcatU(szTemp, c_pszRasPhonePbk);
    
    return CmStrCpyAlloc(szTemp);
}

//+---------------------------------------------------------------------------
//
//      Function:       InitDefaultRasPhoneBook
//
//      Synopsis:       Special case Helper function ensures that there is a default 
//                              ras phonebook when running on NT. We simply attempt to create 
//                              the file which fails if the file already exists, or creates 
//                              an empty file if it does not.
//
//      Arguments:      None
//
//      Returns:        Nothing
//
//      History:        a-nichb -       4/30/97         Created
//                      VetriV          5/21/97         Changed code to call GetOSVersion()
//                                                      instead of using pArgs->dwPlatformID
//                                                      for bug #4700    
//                      nickball        ??/??/98        Removed as we no longer call RasValidateEntry
//                                                      which introduced the requirement of having at
//                                                      least an empty phonebook for the API to work.
//
//----------------------------------------------------------------------------
void InitDefaultRasPhoneBook()
{               
    //
    // NT only. Create empty system phonebook if none exists
    //

    if (OS_NT) 
    {       
        LPTSTR pszSystemPbk = GetRasSystemPhoneBookPath();

        if (pszSystemPbk)
        {
            //
            // Try to create the phonebook, fails if file already exists
            //
            
            HANDLE hInf = CreateFileU(pszSystemPbk,
                                      GENERIC_WRITE|GENERIC_READ,
                                      0,
                                      NULL,
                                      CREATE_NEW,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

            if (hInf != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hInf);
            }
        }
        CmFree(pszSystemPbk);
    }
}
*/
#endif

//+----------------------------------------------------------------------------
//
// Function:  GetRasPbkFromNT5ProfilePath
//
// Synopsis:  Helper function to manufacture a RAS phonebook path from
//            a .CMP file path on NT5
//
// Arguments: LPCTSTR pszProfile - The full path to a profile .CMP file.
//
// Returns:   LPTSTR - The new phonebook path. NULL on failure
//
// History:   nickball    Created    8/13/98
//
//+----------------------------------------------------------------------------
LPTSTR GetRasPbkFromNT5ProfilePath(LPCTSTR pszProfile)
{
    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(pszProfile);

    if (NULL == pszProfile)
    {
        return NULL;
    }

    //
    // We will deduce the phonebook path from our current profile location.
    //

    LPTSTR pszRasPhonePath = (LPTSTR) CmMalloc(MAX_PATH + 1);    
    MYDBGASSERT(pszRasPhonePath);

    if (pszRasPhonePath)
    {
        //
        // Strip .CMP file name and parent directory
        //
        
        LPTSTR pszDir = CmStripFileName(pszProfile, FALSE);
        MYDBGASSERT(pszDir);
        
        if (pszDir)
        {
            LPTSTR pszTmp = CmStrrchr(pszDir, TEXT('\\'));                   
            MYDBGASSERT(pszTmp);

            if (pszTmp)
            {

                *pszTmp = 0;
                
                //
                // Append \\pbk\\rasphone.pbk
                //
                
                lstrcpyU(pszRasPhonePath, pszDir);
                lstrcatU(pszRasPhonePath, TEXT("\\"));
                lstrcatU(pszRasPhonePath, c_pszPbk);
                lstrcatU(pszRasPhonePath, c_pszRasPhonePbk);               
            }
            
            CmFree(pszDir);
        }           
        else
        {
            CmFree(pszRasPhonePath);
        }
    }                            

    return pszRasPhonePath;
}

#define MAX_BLOB_CHARS_PER_LINE 128

//+----------------------------------------------------------------------------
//
// Function:  ReadDunSettingsEapData
//
// Synopsis:  Retrieves DUN setting for EAP config (opaque blob) data. The 
//            entry may span several lines and contain several EAP data blocks.
//
// Arguments: CIni *pIni - Ptr to ini object to be used.
//            LPBYTE* ppbEapData - Address of pointer to store EapData, allocated here.
//            LPDWORD pdwEapSize - Ptr to a DWORD to record the size of the data blob.
//            DWORD dwCustomAuthKey - The EAP type that we are interested in.
//            LPBYTE* ppbEapStruct - [OUT] used for returning the whole 
//                                   EAP_CUSTOM_DATA structure. Can be NULL.
//            DWORD* pdwEapStructSize - [OUT] used for returning the size of the
//                                   EAP_CUSTOM_DATA structure. Can be NULL.
//
// Returns:   TRUE on success
//
// Note:      CM expects blob data to be provided in numbered entries such as:
//                    CustomAuthData0=, CustomAuthData1=, CustomAuthData2=, etc.
//
// History:   nickball    Created                                       08/24/98
//            nickball    Handle multiple EAP data blocks in blob.      09/11/99
//
//+----------------------------------------------------------------------------
BOOL ReadDunSettingsEapData(CIni *pIni, 
        LPBYTE* ppbEapData,
        LPDWORD pdwEapSize,
        const DWORD dwCustomAuthKey,
        LPBYTE* ppbEapStruct,
        LPDWORD pdwEapStructSize)
{
    CHAR *pchBuf = NULL;
    CHAR szTmp[MAX_BLOB_CHARS_PER_LINE + 2]; 
    CHAR szEntry[128];
    int nLine = -1;
    int nRead = -1; 
    int nTotal = 0;

    LPBYTE pbEapBytes = NULL;
    DWORD cbEapBytes = 0;

    MYDBGASSERT(pIni);
    MYDBGASSERT(ppbEapData);
    MYDBGASSERT(pdwEapSize);

    //
    // ppbEapStruct && pdwEapStructSize are allowed to be NULL, so if you need to use them, check for NULL first
    //
    if (NULL == pIni || NULL == ppbEapData || NULL == pdwEapSize) 
    {
        return FALSE;
    }

    if (ppbEapStruct)
    {
        *ppbEapStruct = NULL;
    }

    if (pdwEapStructSize)
    {
        *pdwEapStructSize = 0;
    }

    //
    // First get the section (it should include &) then the entry.
    //

    BOOL bRet = FALSE;
    LPWSTR pszLoadSection = pIni->LoadSection(c_pszCmSectionDunServer);         
    LPSTR pszSection = WzToSzWithAlloc(pszLoadSection);       
    LPSTR pszFile = WzToSzWithAlloc(pIni->GetFile());

    if (!pszLoadSection || !pszSection || !pszFile)
    {
        bRet = FALSE;
        goto exit;
    }

    // 
    // Read numbered entries until there are no more. 
    // Note: RAS blob doesn't exceed 64 chars, but can wrap over multiple lines
    //

    while (nRead)
    {
        //
        // Read CustomAuthDataX where X is the number of entries
        // 

        nLine++;
        wsprintfA(szEntry, "%s%d", c_pszCmEntryDunServerCustomAuthData, nLine);

        nRead = GetPrivateProfileStringA(pszSection, szEntry, "", szTmp, sizeof(szTmp), pszFile);

        if (nRead)
        {               
            //
            // If line exceeded 64 chars, it is considered corrupt
            // 

            if (MAX_BLOB_CHARS_PER_LINE < nRead)
            {                               
                nTotal = 0;
                break;
            }

            //
            // Update our local master buffer with the latest fragment
            //

            if (nLine)
            {
                pchBuf = CmStrCatAllocA(&pchBuf, szTmp);
            }
            else
            {
                pchBuf = CmStrCpyAllocA(szTmp);
            }

            if (!pchBuf)
            {
                bRet = FALSE;
                goto exit;
            }

            nTotal += nRead;
        }
    }

    //
    // At this point we should have the entire entry in pchBuf in HEX format
    // Convert the buffer to byte format and store in supplied EAP buffer.
    //

    if (nTotal && !(nTotal & 1))
    {
        nTotal /= 2; // Only need half the hex char size

        cbEapBytes = nTotal + 1;
        pbEapBytes = (BYTE *) CmMalloc(cbEapBytes);

        if (!pbEapBytes)
        {
            goto exit;
        }

        CHAR *pch = pchBuf;
        BYTE *pb = pbEapBytes;

        while (*pch != '\0')
        {
                *pb = HexValue( *pch++ ) * 16;
                *pb += HexValue( *pch++ );
                ++pb;
        }

        //
        // Now we have the bytes, locate and extract the data block that we
        // are after. Note: Multiple blocks are arrayed using the following 
        // header:
        //
        //  typedef struct _EAP_CUSTOM_DATA
        //  {
        //      DWORD dwSignature;
        //      DWORD dwCustomAuthKey;
        //      DWORD dwSize;
        //      BYTE  abdata[1];
        //  } EAP_CUSTOM_DATA;
        //

        EAP_CUSTOM_DATA *pCustomData = (EAP_CUSTOM_DATA *) pbEapBytes;

        while (((LPBYTE) pCustomData - pbEapBytes) < nTotal)
        {
            if (pCustomData->dwCustomAuthKey == dwCustomAuthKey)
            {
                //
                // Bingo! We have a match, first make sure that the indicated 
                // size isn't pointing out into space, then make a copy and 
                // run for the hills.
                //

                if (((LPBYTE) pCustomData - pbEapBytes) + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize > (DWORD) nTotal)
                {
                    MYDBGASSERT(FALSE);
                    goto exit;
                }

                *ppbEapData = (BYTE *) CmMalloc(pCustomData->dwSize);        

                if (*ppbEapData)
                {   
                    CopyMemory(*ppbEapData, pCustomData->abdata, pCustomData->dwSize);                    

                    *pdwEapSize = pCustomData->dwSize;                                                     
                    bRet = TRUE;
                    goto exit;                                
                }
            }       

            //
            // Locate the next data block
            //

            pCustomData = (EAP_CUSTOM_DATA *) ((LPBYTE) pCustomData + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize); 
        }
    }

exit:
    if (bRet && ppbEapStruct && pdwEapStructSize)
    {
        *ppbEapStruct = pbEapBytes;
        *pdwEapStructSize = cbEapBytes;
    }
    else
    {
        CmFree(pbEapBytes);
    }
    CmFree(pchBuf);
    CmFree(pszLoadSection);
    CmFree(pszSection);
    CmFree(pszFile);
    

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDUNSettings
//
// Synopsis:  Reads the DUN settings for the specified DUN name and .CMS file 
//            into a RASENTRY structure. Because some settings are not supported 
//                        on downlevel platforms, this function will potentially display an
//                        error message to the user.
//
// Arguments: ArgsStruct *pArgs  - Ptr to global args struct.
//            LPCSTR pszFile     - Full path to the .CMS file.
//            LPCTSTR pszDunName - The DUN name for the settings.
//            LPVOID pvBuffer    - Ptr to RASENTRY buffer.
//            LPBYTE* ppbEapData - Address of pointer to store EapData
//            LPDWORD pdwEapSize - Ptr to a DWORD to record the size of the data blob.
//            BOOL  fTunnel      - are we reading tunnel settings?
//
// Returns:   ERROR_SUCCESS on success. Use GetLastError for failure details.
//
// Note:      This was formerly the PhoneBookReadDun API in CMPBK.DLL
//
// History:   nickball    8/22/98   Created Header    
//            nickball    02/03/99  Added pArgs :( in order to have access to the 
//                                  the top-level service for path conversion.
//
//+----------------------------------------------------------------------------
LRESULT ReadDUNSettings(ArgsStruct *pArgs,
        LPCTSTR pszFile, 
        LPCTSTR pszDunName, 
        LPVOID pvBuffer, 
        LPBYTE* ppbEapData, 
        LPDWORD pdwEapSize,
        BOOL    fTunnel) 
{       
    MYDBGASSERT(pszFile);
    MYDBGASSERT(pszDunName);
    MYDBGASSERT(pvBuffer);

    if (NULL == pszFile || NULL == pszDunName || NULL == pvBuffer)
    {
        return (ERROR_INVALID_PARAMETER);
    }

    CMTRACE1(TEXT("ReadDUNSettings -- using DUN setting: %s"), pszDunName);
    
    RASENTRYW *preRas = (RASENTRYW *) pvBuffer;

    //
    // Setup INI object. Prepend pszDunName with "&" for section.
    //

    CIni iniFile(g_hInst, pszFile);
    
    LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));
    pszSection = CmStrCatAlloc(&pszSection, pszDunName);
    iniFile.SetSection(pszSection);
    CmFree(pszSection);

    //
    // Get and apply the Phone section entries
    //

    if (iniFile.GPPB(c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneDialAsIs)) 
    {
        preRas->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;
    }
    
    CopyGPPS(&iniFile, c_pszCmSectionDunPhone, c_pszCmEntryDunPhonePhoneNumber, preRas->szLocalPhoneNumber, sizeof(preRas->szLocalPhoneNumber)/sizeof(TCHAR));
    CopyGPPS(&iniFile,c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneAreaCode, preRas->szAreaCode, sizeof(preRas->szAreaCode)/sizeof(TCHAR));
    preRas->dwCountryCode = iniFile.GPPI(c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneCountryCode, preRas->dwCountryCode);
    preRas->dwCountryID = iniFile.GPPI(c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneCountryId, preRas->dwCountryID);
    
    //
    // Get and apply the Device section entries
    //

    CopyGPPS(&iniFile,c_pszCmSectionDunDevice, c_pszCmEntryDunDeviceType, preRas->szDeviceType, sizeof(preRas->szDeviceType)/sizeof(TCHAR));
    CopyGPPS(&iniFile,c_pszCmSectionDunDevice, c_pszCmEntryDunDeviceName, preRas->szDeviceName, sizeof(preRas->szDeviceName)/sizeof(TCHAR));
    
    //
    // Get and apply the Server section entries
    //

    LPTSTR pszTmp = iniFile.GPPS(c_pszCmSectionDunServer, c_pszCmEntryDunServerType);
    if (*pszTmp) 
    {
        if (0 == lstrcmpiU(pszTmp, c_pszDunPpp)) 
        {
            preRas->dwFramingProtocol = RASFP_Ppp;
        } 
        else if (0 == lstrcmpiU(pszTmp, c_pszDunCslip)) 
        {
            preRas->dwFramingProtocol = RASFP_Slip;
            preRas->dwfOptions |= RASEO_IpHeaderCompression;
        } 
        else if (0 == lstrcmpiU(pszTmp, c_pszDunSlip)) 
        {
            preRas->dwFramingProtocol = RASFP_Slip;
            if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunTcpIpIpHeaderCompress,
                             (BOOL) preRas->dwfOptions & RASEO_IpHeaderCompression)) 
            {
                preRas->dwfOptions |= RASEO_IpHeaderCompression;
            } 
            else 
            {
                preRas->dwfOptions &= ~RASEO_IpHeaderCompression;
            }
        }
    }
    CmFree(pszTmp);
    
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerSwCompress,
                                    (BOOL) preRas->dwfOptions & RASEO_SwCompression)) 
    {
        preRas->dwfOptions |= RASEO_SwCompression;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_SwCompression;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDisableLcp,
                                    (BOOL) preRas->dwfOptions & RASEO_DisableLcpExtensions)) 
    {
        preRas->dwfOptions |= RASEO_DisableLcpExtensions;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_DisableLcpExtensions;
    }
    
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNetworkLogon,
                                    (BOOL) preRas->dwfOptions & RASEO_NetworkLogon)) 
    {
        preRas->dwfOptions |= RASEO_NetworkLogon;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_NetworkLogon;
    }
        
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNegotiateTcpIp,
                                    (BOOL) preRas->dwfNetProtocols & RASNP_Ip)) 
    {
        preRas->dwfNetProtocols |= RASNP_Ip;
    } 
    else 
    {
        preRas->dwfNetProtocols &= ~RASNP_Ip;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNegotiateIpx,
                                    (BOOL) preRas->dwfNetProtocols & RASNP_Ipx)) 
    {
        preRas->dwfNetProtocols |= RASNP_Ipx;
    } 
    else 
    {
        preRas->dwfNetProtocols &= ~RASNP_Ipx;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNegotiateNetBeui, preRas->dwfNetProtocols&RASNP_NetBEUI)) 
    {
        preRas->dwfNetProtocols |= RASNP_NetBEUI;
    } 
    else 
    {
        preRas->dwfNetProtocols &= ~RASNP_NetBEUI;
    }

    //
    // Get the NT5 specific DUN settings. We will error out if we're running 
    // downlevel when these settings are configured and the EnforceCustomSecurity
    // flag has been set.
    //
    // Note: c_pszCmEntryDunServerEnforceCustomSecurity is a DUN setting and is FALSE by default
    //

    BOOL bEnforceCustomSecurity = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerEnforceCustomSecurity, FALSE);

    //
    // Is EAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireEap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireEAP)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequireEAP;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireEAP;
    }

    //
    // PAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequirePap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequirePAP)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequirePAP;        
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequirePAP;
    }

    //
    // SPAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireSpap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireSPAP)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequireSPAP;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireSPAP;
    }

    //
    // CHAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireChap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireCHAP)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequireCHAP;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireCHAP;
    }

    //
    // MSCHAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireMsCHAP)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequireMsCHAP;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireMsCHAP;
    }

    //
    // MSCHAP2 required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap2,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireMsCHAP2)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequireMsCHAP2;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireMsCHAP2;
    }

    //
    // W95 MSCHAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireW95MsChap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireW95MSCHAP)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_RequireW95MSCHAP;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireW95MSCHAP;
    }

    //
    // Custom Security configuration
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomSecurity,
                                    (BOOL) preRas->dwfOptions & RASEO_Custom)) 
    {
        if (OS_NT5)
        {
            preRas->dwfOptions |= RASEO_Custom;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_Custom;
    }

    //
    // Now get the legacy security settings if we don't already have
    // settings specificed from above.  By checking for the Win2k specific
    // settings first we allow Admins to specify both so that legacy platforms
    // can have settings but Win2k can use the more granular settings.
    // If we didn't do this the legacy flags could water down the security on Win2k ...
    //
    const DWORD dwWin2kSecuritySettings = RASEO_RequireEAP | RASEO_RequirePAP | RASEO_RequireSPAP | 
                                          RASEO_RequireCHAP | RASEO_RequireMsCHAP | RASEO_RequireMsCHAP2 | RASEO_RequireW95MSCHAP;

    if (0 == (preRas->dwfOptions & dwWin2kSecuritySettings) || !OS_NT5)
    {
        //
        // Security settings
        //
        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerPwEncrypt,
                                            (BOOL) preRas->dwfOptions & RASEO_RequireEncryptedPw)) 
        {
            preRas->dwfOptions |= RASEO_RequireEncryptedPw;
        } 
        else 
        {
            preRas->dwfOptions &= ~RASEO_RequireEncryptedPw;
        }

        //
        // MS-CHAP
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerPwEncryptMs,
                                        (BOOL) preRas->dwfOptions & RASEO_RequireMsEncryptedPw)) 
        {
            preRas->dwfOptions |= RASEO_RequireMsEncryptedPw;
        } 
        else 
        {
            preRas->dwfOptions &= ~RASEO_RequireMsEncryptedPw;
        }
    }
    else
    {
        CMASSERTMSG((preRas->dwfOptions & RASEO_Custom), TEXT("ReadDUNSettings -- Win2k+ security setting configured but RASEO_Custom not specified."));
    }

    //
    // Encrypt Data (legacy setting, same as ET_Require from above)
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDataEncrypt,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireDataEncryption)) 
    {
        preRas->dwfOptions |= RASEO_RequireDataEncryption;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireDataEncryption;
    }    

    //
    // Encryption type, just a straight int read. (win2k+ setting)
    //
    
    int nTmp = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerEncryptionType, -1);

    if (OS_NT5)
    {
        //
        // We need to set Tunnel encryption type to ET_Require because that's what the ConnFolder does.
        // We also set it ET_Require if the user specified RASEO_RequireDataEncryption as a legacy setting
        // but didn't specify a specific win2k setting.
        //
        if (-1 == nTmp)
        {
            if (fTunnel || (preRas->dwfOptions & RASEO_RequireDataEncryption))
            {
                nTmp = ET_Require;
            }
            else
            {
                nTmp = ET_Optional;       
            }
        }
        ((LPRASENTRY_V500)preRas)->dwEncryptionType = (DWORD) nTmp;
    }
    else
    {
        if (-1 != nTmp && bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);
        }
    }  
   
    //
    // Get the EAP type ID (CustomAuthKey) - The data is stored in the RAS 
    // pbk via a specific API, just before dialing - SetCustomAuthData().
    //

    nTmp = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomAuthKey, -1);

    //
    // If a type ID for EAP is specified, see if there is any config data
    //

    if (-1 != nTmp) 
    {                       
        if (OS_NT5)
        {
            //
            // We have an ID and its NT5, read the EAP config data
            //
            ((LPRASENTRY_V500)preRas)->dwCustomAuthKey = nTmp;              

            //
            // Last two params are NULL, NULL since we don't need the whole eap custom auth data structure
            //
            ReadDunSettingsEapData(&iniFile, ppbEapData, pdwEapSize, nTmp, NULL, NULL);    
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    }

    //
    // Get and apply the Networking section entries. 
    //

    nTmp = iniFile.GPPI(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingVpnStrategy, -1);

    if (-1 != nTmp)
    {
        if (OS_NT5)
        {
            ((LPRASENTRY_V500)preRas)->dwVpnStrategy = nTmp;
        }
        else if (bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);        
        }
    }

    //
    //  See if the profile calls for using a Pre-Shared Key for L2TP.
    //
    if (OS_NT51 && fTunnel)
    {
        if (iniFile.GPPB(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingUsePreSharedKey,
                         (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_UsePreSharedKey)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_UsePreSharedKey;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_UsePreSharedKey;
        }
    }
    else if (fTunnel && ConfiguredToDialWithSafeNet(pArgs) && (OS_W9X || OS_NT4))
    {
        //
        //  Link to SafeNet
        //
        SafeNetLinkageStruct SnLinkage = {0};
        DWORD dwAuthMode;

        if (LinkToSafeNet(&SnLinkage))
        {
            //
            //  First figure out what auth mode we are supposed to be using.
            //

            if (iniFile.GPPB(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingUsePskDownLevel))
            {
                dwAuthMode = SN_PRESHR;
            }
            else
            {
                //
                //  Now get the current authmode of the SafeNet Client.  We do this because if the auth mode
                //  is a specific cert and we are going to set AutoCert then we don't want to change it.
                //
                DWORD dwSize = sizeof(DWORD);
                MYVERIFY(SnLinkage.pfnSnPolicyGet(SN_AUTHMODE, (VOID*)&(dwAuthMode), &dwSize));

                if (SN_CERT != dwAuthMode)
                {
                    dwAuthMode = SN_AUTOCERT;
                } // else leave it SN_CERT
            }

            //
            //  Now set the auth mode
            //
            if (FALSE == SnLinkage.pfnSnPolicySet(SN_AUTHMODE, (VOID*)&dwAuthMode))
            {
                CMTRACE1(TEXT("ReadDUNSettings -- SnPolicySet failed with GLE=%d"), GetLastError());
                CMASSERTMSG(FALSE, TEXT("ReadDUNSettings -- unable to set SN_AUTHMODE"));
                
                //
                //  We were unable to set the policy, we must change the adapter to be the MS PPTP adapter instead of
                //  the SafeNet adapter.
                //
                pArgs->bSafeNetClientAvailable = FALSE;
                MYDBGASSERT(PickTunnelDevice(pArgs, preRas->szDeviceType, preRas->szDeviceName));
                pArgs->Log.Log(SN_ADAPTER_CHANGE_EVENT, pArgs->szTunnelDeviceName, preRas->szDeviceName); // log the fact we are changing devices
                lstrcpynU(pArgs->szTunnelDeviceName, preRas->szDeviceName, sizeof (pArgs->szTunnelDeviceName)/sizeof(TCHAR));
            }
            else
            {
                if (FALSE == SnLinkage.pfnSnPolicyReload())
                {
                    CMTRACE1(TEXT("ReadDUNSettings -- pfnSnPolicyReload failed with GLE=%d"), GetLastError());
                    CMASSERTMSG(FALSE, TEXT("ReadDUNSettings -- unable to commit the SafeNet settings to the driver."));

                    //
                    //  We were unable to commit the changes to the SafeNet driver, we must change 
                    //  the adapter to be the MS PPTP adapter instead of the SafeNet adapter.
                    //
                    pArgs->bSafeNetClientAvailable = FALSE;
                    MYDBGASSERT(PickTunnelDevice(pArgs, preRas->szDeviceType, preRas->szDeviceName));
                    pArgs->Log.Log(SN_ADAPTER_CHANGE_EVENT, pArgs->szTunnelDeviceName, preRas->szDeviceName); // log the fact we are changing devices
                    lstrcpynU(pArgs->szTunnelDeviceName, preRas->szDeviceName, sizeof (pArgs->szTunnelDeviceName)/sizeof(TCHAR));
                }
            }

            UnLinkFromSafeNet(&SnLinkage);
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("ReadDUNSettings -- SafeNet client wasn't available even though we thought it should be... continuing with PPTP."));
            pArgs->bSafeNetClientAvailable = FALSE;
        }
    }

    //
    // File and Print sharing.  Note that on systems up to Win2k we only have the traditional RASEO_SecureLocalFiles.
    // However, Win2k gave this flag two purposes (enable/disable NetBt and enable/disable file and print sharing).
    // In Whistler two separate flags were developed to allow greater granularity.  To give legacy profiles the behavior
    // they expect while disabling file and print sharing as the default the logic gets a little complicated.  Basically
    // the new flag overrides the legacy flag and defaults to 1.  If the new flag isn't specified then we use the value
    // of the legacy flag if it is specified.  If neither is specified we set it to 1.  On platforms previous to Whistler
    // the old flag is the only thing we have and it defaults to 0.
    //

    int nLegacySecureLocalFiles = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerSecureLocalFiles, -1);
    int nSecureFileAndPrint = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerSecureFileAndPrint, -1);

    if (-1 == nSecureFileAndPrint)
    {
        nSecureFileAndPrint = nLegacySecureLocalFiles ? 1 : 0;
    }

    if (-1 == nLegacySecureLocalFiles)
    {
        nLegacySecureLocalFiles = 0;
    }

    if (OS_NT51)
    {
        //
        // Set the 501/Options2 style File and Print sharing flag
        //

        if (nSecureFileAndPrint) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_SecureFileAndPrint;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_SecureFileAndPrint;
        }
    }
    else
    {
        if (nLegacySecureLocalFiles) 
        {
            preRas->dwfOptions |= RASEO_SecureLocalFiles;
        }
        else
        {
            preRas->dwfOptions &= ~RASEO_SecureLocalFiles;    
        }    
    }

    //
    // Pick up Whistler specific DUN settings
    //
    
    if (OS_NT51)    
    {
        //
        // Get the 501/Options2 style MSNet binding flag
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerSecureClientForMSNet,
                                        (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_SecureClientForMSNet)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_SecureClientForMSNet;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_SecureClientForMSNet;
        }

        //
        // Get the 501/Options2 style Multilink Negotiation flag
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDontNegotiateMultilink,
                                        (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_DontNegotiateMultilink)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_DontNegotiateMultilink;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_DontNegotiateMultilink;
        }

        //
        // Get the 501/Options2 style DontUseRasCredentials flag
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDontUseRasCredentials,
                                        (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_DontUseRasCredentials)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_DontUseRasCredentials;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_DontUseRasCredentials;
        }

        //
        //  Get the RASEO_CustomScript flag value.  Note that this flag existed on Win2k but wasn't
        //  available for RasDial only RasDialDlg.  On Whistler+ it is available to RasDial as well.
        //  Note that we also have to set the RDEOPT_UseCustomScripting flag in the RASDIALEXTENSIONS
        //  for this to work.
        //
        if (iniFile.GPPB(c_pszCmSectionDunScripting, c_pszCmEntryDunScriptingUseRasCustomScriptDll,
                                        (BOOL) (preRas->dwfOptions & RASEO_CustomScript))) 
        {
            preRas->dwfOptions |= RASEO_CustomScript;
        } 
        else 
        {
            preRas->dwfOptions &= ~RASEO_CustomScript;
        }

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDisableNbtOverIP,
                         (BOOL) (((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_DisableNbtOverIP)))
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_DisableNbtOverIP;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_DisableNbtOverIP;
        }
    }

    //
    // Get and apply the TCP/IP section entries
    //

    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpSpecifyIpAddress,
                                        (BOOL) preRas->dwfOptions & RASEO_SpecificIpAddr)) 
    {
        preRas->dwfOptions |= RASEO_SpecificIpAddr;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_SpecificIpAddr;
    }
    
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpIpAddress, &preRas->ipaddr);
    
    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpSpecifyServerAddress,
                                    (BOOL) preRas->dwfOptions & RASEO_SpecificNameServers)) 
    {
        preRas->dwfOptions |= RASEO_SpecificNameServers;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_SpecificNameServers;
    }

    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpIpHeaderCompress,
                                    (BOOL) preRas->dwfOptions & RASEO_IpHeaderCompression)) 
    {
        preRas->dwfOptions |= RASEO_IpHeaderCompression;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_IpHeaderCompression;
    }

    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpDnsAddress, &preRas->ipaddrDns);
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpDnsAltAddress, &preRas->ipaddrDnsAlt);
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpWinsAddress, &preRas->ipaddrWins);
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpWinsAltAddress, &preRas->ipaddrWinsAlt);
    
    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpGatewayOnRemote,
                                    (BOOL) preRas->dwfOptions & RASEO_RemoteDefaultGateway)) 
    {
        preRas->dwfOptions |= RASEO_RemoteDefaultGateway;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }

    if (OS_NT51)
    {
        //
        //  If the caller specified a DNS suffix then lets read it and add it to the RAS entry
        //
        CopyGPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpDnsSuffix, ((LPRASENTRY_V501)preRas)->szDnsSuffix, sizeof(((LPRASENTRY_V501)preRas)->szDnsSuffix)/sizeof(TCHAR));
    }

    //
    //  Set the TCP Window size -- the NTT DoCoMo fix for Whistler.  The Win2k version of this fix
    //  must be written through a private RAS API that must be called after the phonebook entry 
    //  exists ie. after we call RasSetEntryProperties ... otherwise it won't work on the first
    //  dial.
    //
    if (OS_NT51)
    {
        ((LPRASENTRY_V501)preRas)->dwTcpWindowSize = iniFile.GPPI(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpTcpWindowSize, 0);
    }

    //
    // Get and apply the Scripting section entries
    //

    TCHAR szScript[MAX_PATH + 1] = TEXT("");
    CopyGPPS(&iniFile,c_pszCmSectionDunScripting, c_pszCmEntryDunScriptingName, szScript, sizeof(szScript)/sizeof(TCHAR));

    //
    // The script path from our cms file is a relative path. We need to convert
    // it to a full path, but make sure that we use the top-level service for
    // the conversion because it is used to derive the short-service name for
    // the directory.  Note that tunnel dun settings cannot have a script.
    //        

    if (szScript[0] && !fTunnel) 
    {
        CMTRACE1(TEXT("ReadDunSettings() - Converting script path %s to full path"), szScript);
        pszTmp = CmConvertRelativePath(pArgs->piniService->GetFile(), szScript);

        MYDBGASSERT(pszTmp);

        if (pszTmp && *pszTmp)
        {           
            lstrcpyU(preRas->szScript, pszTmp);
            CMTRACE1(TEXT("ReadDunSettings() - Script file is %s"), preRas->szScript);
        }

        CmFree(pszTmp);
    }   
    else
    {
        //
        // The cms didn't specify a script ==> no script
        //
        preRas->szScript[0] = TEXT('\0');
    }

    //
    //  If this is Whistler+ or Win2k with SP3 then we may need to invoke a terminal window
    //
    if (OS_NT5 && IsTerminalWindowSupportedOnWin2kPlus() && !fTunnel && 
        iniFile.GPPB(c_pszCmSectionDunScripting, c_pszCmEntryDunScriptingUseTerminalWindow,
        (BOOL) preRas->dwfOptions & RASEO_TerminalAfterDial)) 
    {
        preRas->dwfOptions |= RASEO_TerminalAfterDial;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_TerminalAfterDial;
    }

    return (ERROR_SUCCESS);
}


//+----------------------------------------------------------------------------
//
// Function:  ValidateDialupDunSettings
//
// Synopsis:  Verifies the DUN settings that the specified .CMS and DUN name are
//            supported on the current platform. If we are running on a downlevel
//            OS and we encounter any NT specific security settings we error out.
//
// Arguments: LPCTSTR pszCmsFile     - The phone # specific .CMS file name.
//            LPCTSTR pszDunName     - The DUN name, if any for the settings.
//            LPCTSTR pszTopLevelCms - The top-level CMS file name.
//
// Returns:   BOOL - TRUE on success.
//
// History:   nickball    Created               8/26/98
//
//+----------------------------------------------------------------------------
BOOL ValidateDialupDunSettings(LPCTSTR pszCmsFile, LPCTSTR pszDunName, LPCTSTR pszTopLevelCms)
{
    MYDBGASSERT(pszCmsFile);
    MYDBGASSERT(*pszCmsFile);
    MYDBGASSERT(pszDunName);

    if (NULL == pszCmsFile || (!*pszCmsFile) || NULL == pszDunName)
    {
        return FALSE;
    }

    //
    // On NT5 we currently support all settings, so succeed automatically
    //

    if (OS_NT5)
    {
        return TRUE;
    }

    //
    // Determine the DUN name that we are looking for. In the tunnel case we
    // always read it from the .CMS. For dial-up, we'll use the specified DUN
    // name, and revert to the .CMS if blank. 
    //

    CIni iniFile(g_hInst, pszCmsFile);

    //
    // Now determine the DUN name to be used when looking up settings.
    //

    LPTSTR pszEntryName;

    //
    // If we have a specific DUN name to use, and we're not tunneling 
    // use it instead of the default DUN setting in the .CMS.
    //

    if (pszDunName && *pszDunName)
    {
        pszEntryName = CmStrCpyAlloc(pszDunName);
    }
    else
    {
        pszEntryName = GetDefaultDunSettingName(&iniFile, FALSE); // FALSE == not tunnel
    }

    //
    // If no DUN name is specified, then pass validation automatically
    //

    if (!pszEntryName || (!*pszEntryName))
    {
        CmFree(pszEntryName);
        CMTRACE1(TEXT("ValidateDunSettings() - No DUN name found in %s"), pszCmsFile);
        return TRUE;
    }
    
    //
    // Include the entryname in the section headers
    //

    LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));
    pszSection = CmStrCatAlloc(&pszSection, pszEntryName);
    iniFile.SetSection(pszSection);

    CmFree(pszSection);
    CmFree(pszEntryName);

    //
    // Check to see if the admin wants us to check the custom security settings
    // against the platform. By default, we do not enforce this check.
    // 
    //

    if (FALSE == iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerEnforceCustomSecurity))
    {
        return TRUE;
    }

    //
    // Now check the actual settings if we're still here.
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireEap))                             
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequirePap))
    {
        goto ValidateDunSettingsExit;
    }
            
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireSpap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireChap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap2))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireW95MsChap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomSecurity))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerEncryptionType))                             
    {
        goto ValidateDunSettingsExit;
    }

    if (-1 != iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomAuthKey, -1))  
    {
        goto ValidateDunSettingsExit;
    }
            
    if (-1 != iniFile.GPPI(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingVpnStrategy, -1))
    {
        goto ValidateDunSettingsExit;
    }
    
    return TRUE;

ValidateDunSettingsExit:

    //
    // Get the top-level service name
    //

    CIni iniTopLevelCms(g_hInst, pszTopLevelCms);

    LPTSTR pszTitle = GetServiceName(&iniTopLevelCms);
    LPTSTR pszTmp = CmFmtMsg(g_hInst,IDMSG_UNSUPPORTED_SETTING_NUM);       

    MessageBoxEx(NULL, pszTmp, pszTitle, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309
    
    CmFree(pszTmp);                 
    CmFree(pszTitle);

    CMTRACE1(TEXT("ValidateDunSettings() - Unsupported setting detected in %s"), pszCmsFile);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  IsTerminalWindowSupportedOnWin2kPlus
//
// Synopsis:  Detects if the private RAS API in RasDlg.dll to invoke a terminal
//            window is available or not.  Should exist on win2k with SP3+ or
//            on whistler and greater.
//
// Arguments: None
//
// Returns:   TRUE if the private API for terminal window support is available
//
// History:   quintinb    Created               08/06/01
//
//+----------------------------------------------------------------------------
BOOL IsTerminalWindowSupportedOnWin2kPlus()
{
    MYDBGASSERT(OS_NT5);
    BOOL bReturn = FALSE;
    typedef DWORD (WINAPI *pfnDwTerminalDlgSpec)(LPCWSTR, LPCWSTR, RASDIALPARAMS *, HWND, HRASCONN);

    //
    //  First call loadlibrary on rasdlg.dll
    //

    HMODULE hRasDlg = LoadLibraryExU(TEXT("rasdlg.dll"), NULL, 0);

    if (hRasDlg)
    {
        pfnDwTerminalDlgSpec pfnDwTerminalDlg = (pfnDwTerminalDlgSpec)GetProcAddress(hRasDlg, "DwTerminalDlg");

        if (pfnDwTerminalDlg)
        {
            bReturn = TRUE;
        }

        FreeLibrary(hRasDlg);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  InvokeTerminalWindow
//
// Synopsis:  Allows CM to invoke a terminal window on Whistler or later versions
//            of Win2k but calling a private RAS API in RasDlg.dll.
//
// Arguments: LPCWSTR pszPhoneBook - full path to the phonebook file
//            LPCWSTR pszEntry - entry name to invoke the terminal window for
//            RASDIALPARAMS *pRasDialParams - RasDialParams for the connection
//                                            to invoke the terminal window for
//            HWND hWnd - window handle of the parent dialog
//            HRASCONN hRasconn - handle to the ras connection
//
// Returns:   Windows error message
//
// History:   quintinb    Created               07/11/00
//
//+----------------------------------------------------------------------------
DWORD InvokeTerminalWindow(LPCWSTR pszPhoneBook, LPCWSTR pszEntry, RASDIALPARAMS *pRasDialParams, HWND hWnd, HRASCONN hRasconn)
{
    //
    //  Validate the input parameters.  Note that pszPhoneBook can be NULL but if it is non-NULL then we cannot have
    //  an empty string.
    //
    MYDBGASSERT(OS_NT5);
    if (((NULL != pszPhoneBook) && (L'\0' == pszPhoneBook[0])) || 
        (NULL == pszEntry) || (L'\0' == pszEntry[0]) || (NULL == pRasDialParams) || 
        (NULL == hWnd) || (NULL == hRasconn))
    {
        CMASSERTMSG(FALSE, TEXT("InvokeTerminalWindow - Invalid parameter passed."));
        return ERROR_INVALID_PARAMETER; 
    }

    DWORD dwReturn;
    typedef DWORD (WINAPI *pfnDwTerminalDlgSpec)(LPCWSTR, LPCWSTR, RASDIALPARAMS *, HWND, HRASCONN);

    //
    //  First call loadlibrary on rasdlg.dll
    //

    HMODULE hRasDlg = LoadLibraryExU(TEXT("rasdlg.dll"), NULL, 0);

    if (hRasDlg)
    {
        pfnDwTerminalDlgSpec pfnDwTerminalDlg = (pfnDwTerminalDlgSpec)GetProcAddress(hRasDlg, "DwTerminalDlg");

        if (pfnDwTerminalDlg)
        {
            dwReturn = pfnDwTerminalDlg(pszPhoneBook, pszEntry, pRasDialParams, hWnd, hRasconn);
        }
        else
        {
            dwReturn = ERROR_PROC_NOT_FOUND;
        }
        
        FreeLibrary(hRasDlg);
    }
    else
    {
        dwReturn = ERROR_MOD_NOT_FOUND;
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  OnPauseRasDial
//
// Synopsis:  Message handler for RasDial pause states. In the pause state, RAS
//            is suspended, waiting for us to restart it by calling RasDial after
//            performing the appropriate interface with the user.
//
// Arguments: HWND hwndDlg      - Window handle of main dialog
//            ArgsStruct *pArgs - Ptr to global args struct  
//            WPARAM wParam     - wParam being handled  
//            LPARAM lParam     - lParam being handled
//
// Returns:   Windows error message
//
// History:   nickball    Created               05/19/99
//
//+----------------------------------------------------------------------------

DWORD OnPauseRasDial(HWND hwndDlg, ArgsStruct *pArgs, WPARAM wParam, LPARAM lParam)        
{                      
    CMTRACE2(TEXT("OnPauseRasDial - wParam is %u and lParam is %u."), wParam, lParam);    

    MYDBGASSERT(pArgs);
    if (NULL == pArgs)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get connection handle and re-dial
    //
    
    HRASCONN hRasConn;
    DWORD dwRes = ERROR_SUCCESS;    
    LPTSTR pszRasPbk = pArgs->pszRasPbk;
    
    //
    // Determine the appropriate connection handle and phonebook
    // Note: Make an explicit copy or we'll wind up re-dialing
    // if the connection drops while the pause UI is invoked.
    //

    if (IsDialingTunnel(pArgs))
    {
        hRasConn = pArgs->hrcTunnelConn;
    }
    else
    {
        hRasConn = pArgs->hrcRasConn;

        if (pArgs->pszRasHiddenPbk)
        {
            pszRasPbk = pArgs->pszRasHiddenPbk;
        }
    }

    //
    // In certain pause states we need to repopulate RASDIALPARAMS
    // password because we always wipe it for security reasons
    // after using it in RasDial. Thus we need to find out which 
    // passwords (Inet or regular) to use to repopulate RASDIALPARAMS
    //        
    CSecurePassword *pSecPass = NULL;
    BOOL fUsingInetCredentials = (!pArgs->fUseSameUserName &&
                                !IsDialingTunnel(pArgs) && 
                                UseTunneling(pArgs, pArgs->nDialIdx));


    //
    // Handle the pause
    //

    switch (wParam)
    {
        case (RASCS_PAUSED + 4):  // 4100 - RASCS_InvokeEapUI )

            //
            // If UNATTENDED, just bail out immediately.
            //
    
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                dwRes = ERROR_INTERACTIVE_MODE;
                goto OnPauseRasDialExit;
            }

            //
            // If EAP triggered the pause, invoke the EAP UI
            //
    
            dwRes = pArgs->rlsRasLink.pfnInvokeEapUI(hRasConn, pArgs->dwRasSubEntry, pArgs->pRasDialExtensions, hwndDlg);
      
            CMTRACE1(TEXT("OnPauseRasDial() - InvokeEapUI() returns %u."), dwRes);           
            break;

        case RASCS_PasswordExpired: // Domain password has expired
        {
            //
            // If UNATTENDED, just bail out immediately.
            //
    
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                dwRes = ERROR_INTERACTIVE_MODE;
                goto OnPauseRasDialExit;
            }

            CChangePasswordDlg  NewPasswordDlg(pArgs);
            
            if (IDOK != NewPasswordDlg.DoDialogBox(g_hInst, IDD_CHANGEPASSWORD, pArgs->hwndMainDlg))
            {
                if (pArgs->dwExitCode)// REVIEW:  CChangePasswordDlg never sets dwExitCode, why are we doing this?  quintinb 8/8/2001
                {
                    dwRes = pArgs->dwExitCode;
                }
                else
                {
                    dwRes = ERROR_CANCELLED;
                }
            }
            
            CMTRACE1(TEXT("OnPauseRasDial() - Password Expired"), dwRes);
            
            break;
        }

        case RASCS_CallbackSetByCaller: // Server wants to call us back
        {           
            //
            // Preset dial params and call dialog to retrieve number from user
            // 
            
            LPTSTR pszTmp = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryCallbackNumber);   
            lstrcpyU(pArgs->pRasDialParams->szCallbackNumber, pszTmp);
            CmFree(pszTmp);
       
            //
            // If we're running unattended, skip the dialog phase. The 
            // presumption is that there is no user there to receive it.
            //

            BOOL bPromptUser = !(pArgs->dwFlags & FL_UNATTENDED);
                               
            if (bPromptUser)    
            {
                //
                // The above also applies in the case of DialAutomatically
                // if we have a phone number, then there is no need to prompt.
                //
                
                if (pArgs->fDialAutomatically && TEXT('\0') != pArgs->pRasDialParams->szCallbackNumber[0])
                {
                    bPromptUser = FALSE;
                }
            }

            if (bPromptUser)
            {
                CCallbackNumberDlg CallbackNumberDialog(pArgs);                       
                
                if (IDOK != CallbackNumberDialog.DoDialogBox(g_hInst, IDD_CALLBACK_NUMBER, pArgs->hwndMainDlg))
                {
                    //
                    // If the user canceled, clear the number so that RAS wont attempt callback
                    //

                    lstrcpyU(pArgs->pRasDialParams->szCallbackNumber, TEXT(""));
                }
            }
           
            //
            // Now make sure the password is in the RASCREDENTAIAL structure.
            //
            if (fUsingInetCredentials)
            {
                pSecPass = &(pArgs->SecureInetPW);

                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Inet - pArgs->szInetUserName = %s"), pArgs->szInetUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Inet - pArgs->szDomain = %s"), pArgs->szDomain);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Inet - pArgs->pRasDialParams->szUserName = %s"), pArgs->pRasDialParams->szUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Inet - pArgs->pRasDialParams->szDomain = %s"), pArgs->pRasDialParams->szDomain);

                CMASSERTMSG(0 == lstrcmpU(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName), TEXT("OnPauseRasDial() - RASCS_CallbackSetByCaller - Inet - szInetUserName doesn't match RASDIALPARAMS"));

            }
            else
            {
                pSecPass = &(pArgs->SecurePW);

                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Corp - pArgs->szUserName = %s"), pArgs->szUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Corp - pArgs->szDomain = %s"), pArgs->szDomain);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Corp - pArgs->pRasDialParams->szUserName = %s"), pArgs->pRasDialParams->szUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_CallbackSetByCaller - Corp - pArgs->pRasDialParams->szDomain = %s"), pArgs->pRasDialParams->szDomain);

                CMASSERTMSG(0 == lstrcmpU(pArgs->szUserName, pArgs->pRasDialParams->szUserName), TEXT("OnPauseRasDial() - RASCS_CallbackSetByCaller - Corp - Username doesn't match RASDIALPARAMS"));
                CMASSERTMSG(0 == lstrcmpU(pArgs->szDomain , pArgs->pRasDialParams->szDomain), TEXT("OnPauseRasDial() - RASCS_CallbackSetByCaller - Corp - domain doesn't match RASDIALPARAMS"));

            }

            if (FALSE == pSecPass->IsEmptyString())
            {
                LPTSTR pszClearPassword = NULL;
                DWORD cbClearPassword = 0;
                BOOL fRetPassword = FALSE;

                fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

                if (fRetPassword && pszClearPassword)
                {
                    lstrcpynU(pArgs->pRasDialParams->szPassword, pszClearPassword, lstrlenU(pszClearPassword)+1);
                    CmEncodePassword(pArgs->pRasDialParams->szPassword);
                    
                    //
                    // Clear and Free the clear-text password
                    //

                    pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
                }
            }


            dwRes = ERROR_SUCCESS;          
            CMTRACE1(TEXT("OnPauseRasDial() - CallbackSetByCaller returns %u"), dwRes);
            
            break;
        }

        case RASCS_RetryAuthentication: // Credentials aren't correct
        {
            //
            // If UNATTENDED, just bail out immediately.
            //
    
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                dwRes = ERROR_INTERACTIVE_MODE;
                goto OnPauseRasDialExit;
            }

            //
            // Creds didn't work, prompt user for new ones.
            //

            CRetryAuthenticationDlg RetryAuthenticationDialog(pArgs); 

            if (IDOK != RetryAuthenticationDialog.DoDialogBox(g_hInst, 
                                                               RetryAuthenticationDialog.GetDlgTemplate(),
                                                               pArgs->hwndMainDlg))         
            {
                //
                // User canceled, or the call was dropped elsewhere. Use 
                // existing error code or designate authentication failure.
                //

                if (pArgs->dwExitCode) // REVIEW:  CRetryAuthenticationDlg never sets dwExitCode, why are we doing this?  quintinb 8/8/2001
                {
                    dwRes = pArgs->dwExitCode;
                }
                else
                {
                    dwRes = ERROR_AUTHENTICATION_FAILURE;
                }
            }
            
            CMTRACE1(TEXT("OnPauseRasDial() - RetryAuthentication"), dwRes);            
            break;      
        }
        
        case RASCS_Interactive:         // Terminal/script pause state
            if (OS_NT5 && IsTerminalWindowSupportedOnWin2kPlus())
            {
                if (pArgs->dwFlags & FL_UNATTENDED)
                {
                    dwRes = ERROR_INTERACTIVE_MODE;
                    goto OnPauseRasDialExit;
                }

                //
                // Now make sure the password is in the RASCREDENTAIAL structure before invoking
                // Terminal window.
                //
                if (fUsingInetCredentials)
                {
                    pSecPass = &(pArgs->SecureInetPW);

                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->szInetUserName = %s"), pArgs->szInetUserName);
                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->szDomain = %s"), pArgs->szDomain);
                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->pRasDialParams->szUserName = %s"), pArgs->pRasDialParams->szUserName);
                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->pRasDialParams->szDomain = %s"), pArgs->pRasDialParams->szDomain);

                    //
                    // The user names should match. 
                    //
                    CMASSERTMSG((0 == lstrcmpU(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName)), TEXT("OnPauseRasDial() - RASCS_Interactive - Inet - szInetUserName doesn't match RASDIALPARAMS"));
                }
                else
                {
                    pSecPass = &(pArgs->SecurePW);

                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->szUserName = %s"), pArgs->szUserName);
                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->szDomain = %s"), pArgs->szDomain);
                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->pRasDialParams->szUserName = %s"), pArgs->pRasDialParams->szUserName);
                    CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->pRasDialParams->szDomain = %s"), pArgs->pRasDialParams->szDomain);

                    //
                    // The user names and domains should match since we'll be using the corp password to
                    // populate RASDIALPARAMS
                    //

                    CMASSERTMSG(0 == lstrcmpU(pArgs->szUserName, pArgs->pRasDialParams->szUserName), TEXT("OnPauseRasDial() - RASCS_Interactive - Corp - Username doesn't match RASDIALPARAMS"));
                    CMASSERTMSG(0 == lstrcmpU(pArgs->szDomain , pArgs->pRasDialParams->szDomain), TEXT("OnPauseRasDial() - RASCS_Interactive - Corp - domain doesn't match RASDIALPARAMS"));
                }

                if (FALSE == pSecPass->IsEmptyString())
                {
                    LPTSTR pszClearPassword = NULL;
                    DWORD cbClearPassword = 0;
                    BOOL fRetPassword = FALSE;

                    fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

                    if (fRetPassword && pszClearPassword)
                    {
                        lstrcpynU(pArgs->pRasDialParams->szPassword, pszClearPassword, lstrlenU(pszClearPassword)+1);

                        if (!OS_W2K)
                        {
                            //
                            // We don't want to encode this on Win2K. The RAS TerminalDlg code on Win2K doesn't 
                            // like encoded passwords, thus it fails. On XP/Server 2003 this was changed (254385).
                            //
                            CmEncodePassword(pArgs->pRasDialParams->szPassword);
                        }
                        
                        //
                        // Clear and Free the clear-text password
                        //

                        pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
                    }
                }

                dwRes = InvokeTerminalWindow(pszRasPbk, pArgs->szServiceName, pArgs->pRasDialParams, pArgs->hwndMainDlg, hRasConn);

                //
                // Before RasDial (below) the password gets decoded so must encode it here, because for
                // Win2K we didn't encoded before calling InvokeTerminalWindow
                //
                if (OS_W2K)
                {
                    CmEncodePassword(pArgs->pRasDialParams->szPassword);
                }

                break;
            } // else fail through to default and error out.

        //
        // We got a pause state that we don't handle, error out.
        //
        default:
            dwRes = ERROR_INTERACTIVE_MODE;
            CMASSERTMSG(FALSE, TEXT("OnPauseRasDial() - Error, unsupported RAS pause state encountered."));                                
            break;
    }

    //
    // On success, call RasDial to resume connection
    //

    if (ERROR_SUCCESS == dwRes)
    {

        //
        // Since these pause states no longer use RASDIALPARAMS to store the password
        // we need to get it in the clear and copy it into the structure
        //
        if ((RASCS_PasswordExpired == wParam) || (RASCS_RetryAuthentication == wParam))
        {
            if (fUsingInetCredentials)
            {
                pSecPass = &(pArgs->SecureInetPW);

                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->szInetUserName = %s"), pArgs->szInetUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->szDomain = %s"), pArgs->szDomain);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->pRasDialParams->szUserName = %s"), pArgs->pRasDialParams->szUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Inet - pArgs->pRasDialParams->szDomain = %s"), pArgs->pRasDialParams->szDomain);

                //
                // The Inet user names should match. 
                //
                CMASSERTMSG((0 == lstrcmpU(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName)), TEXT("OnPauseRasDial() - RASCS_Interactive - Inet - szInetUserName doesn't match RASDIALPARAMS"));
            }
            else
            {
                pSecPass = &(pArgs->SecurePW);

                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->szUserName = %s"), pArgs->szUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->szDomain = %s"), pArgs->szDomain);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->pRasDialParams->szUserName = %s"), pArgs->pRasDialParams->szUserName);
                CMTRACE1(TEXT("nPauseRasDial() - RASCS_Interactive - Corp - pArgs->pRasDialParams->szDomain = %s"), pArgs->pRasDialParams->szDomain);

                //
                // The user names and domains should match since we'll be using the corp password to
                // populate RASDIALPARAMS
                //

                CMASSERTMSG(0 == lstrcmpU(pArgs->szUserName, pArgs->pRasDialParams->szUserName), TEXT("OnPauseRasDial() - RASCS_Interactive - Corp - Username doesn't match RASDIALPARAMS"));
                CMASSERTMSG(0 == lstrcmpU(pArgs->szDomain , pArgs->pRasDialParams->szDomain), TEXT("OnPauseRasDial() - RASCS_Interactive - Corp - domain doesn't match RASDIALPARAMS"));
            }

            LPTSTR pszClearPassword = NULL;
            DWORD cbClearPassword = 0;
            BOOL fRetPassword = FALSE;

            fRetPassword = pSecPass->GetPasswordWithAlloc(&pszClearPassword, &cbClearPassword);

            if (fRetPassword && pszClearPassword)
            {
                lstrcpynU(pArgs->pRasDialParams->szPassword, pszClearPassword, CELEMS(pArgs->pRasDialParams->szPassword));
                CmEncodePassword(pArgs->pRasDialParams->szPassword);
                
                //
                // Clear and Free the clear-text password
                //

                pSecPass->ClearAndFree(&pszClearPassword, cbClearPassword);
            }

        }

        //
        // Decode active password, re-call RasDial, then re-encode
        //
        
        CmDecodePassword(pArgs->pRasDialParams->szPassword); 

        CMASSERTMSG((NOT_IN_CONNECT_OR_CANCEL == pArgs->lInConnectOrCancel),
                    TEXT("OnPauseRasDial - RasDial mutex is NOT NULL..."));

        dwRes = pArgs->rlsRasLink.pfnDial(pArgs->pRasDialExtensions, 
                                          pszRasPbk, 
                                          pArgs->pRasDialParams, 
                                          GetRasCallBackType(), 
                                          GetRasCallBack(pArgs), 
                                          &hRasConn);

        CmWipePassword(pArgs->pRasDialParams->szPassword); 
 
        CMTRACE1(TEXT("OnPauseRasDial() - RasDial() returns %u."), dwRes);           

        //
        // Reset timers, the current action starts now.
        //

        pArgs->dwStateStartTime = GetTickCount();
        pArgs->nLastSecondsDisplay = (UINT) -1;
    }

OnPauseRasDialExit:

    if (ERROR_SUCCESS != dwRes)
    {
        OnRasErrorMessage(hwndDlg, pArgs, dwRes);
    }

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Function:  GetRasCallBackType
//
// Synopsis:  Simple function to return the Callback type that we use for RasDial
//            depending upon the OS.
//
// Arguments: None
//
// Returns:   DWORD - The callback type
//
// History:   nickball    Created       05/22/99
//
//+----------------------------------------------------------------------------

DWORD GetRasCallBackType()
{
    if (OS_NT5) 
    {
        return 2;
    }
    else
    {
        return -1;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetRasCallBack
//
// Synopsis:  Simple function to return the Callback that we use for RasDial
//            depending upon the OS.
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct  
//
// Returns:   LPVOID - The callback
//
// History:   nickball    Created       05/22/99
//
//+----------------------------------------------------------------------------

LPVOID GetRasCallBack(ArgsStruct* pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return NULL;
    }

    //
    // Now set return the callback func or hwnd according to OS.
    //

    if (OS_NT5)
    {       
        //
        // Set Callback data in RasDialParams
        //

        if (pArgs->pRasDialParams->dwSize == sizeof(RASDIALPARAMS_V401))
        {          
            ((LPRASDIALPARAMS_V401)pArgs->pRasDialParams)->dwCallbackId = (ULONG_PTR) pArgs;
        }      

       return (LPVOID) RasDialFunc2;
    }
    else
    {
        MYDBGASSERT(pArgs->hwndMainDlg);
        return (LPVOID) pArgs->hwndMainDlg;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Resource ID definitions
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------

// Used by icmdlg.rc
//
#define IDD_MAIN_ALL_USERDATA           101
#define IDD_MAIN_NO_USERDATA            102
#define IDD_MAIN_UID_ONLY               103
#define IDD_MAIN_UID_AND_PWD            104
#define IDD_MAIN_UID_AND_DMN            105
#define IDD_MAIN_PWD_ONLY               106
#define IDD_MAIN_PWD_AND_DMN            107
#define IDD_MAIN_DMN_ONLY               108
#define IDD_CHANGEPASSWORD              109
#define IDD_CALLBACK_NUMBER             110
//                                      111
#define IDI_APP                         112
#define IDB_APP                         113
#define IDD_PHONEBOOK                   114
#define IDD_PHONEBOOKEX                 115
#define IDB_PB                          116
//                                      117
//                                      118
//                                      119
#define IDM_TRAY                        120
#define IDMC_TRAY_OPEN                  121
#define IDD_RECONNECT                   123
#define IDD_DIAL                        124
#define IDD_MODEM                       125
#define IDD_TUNNEL                      126
#define IDD_TUNNEL_SIGNIN               127
#define IDD_EDIT_NUMBER                 128
#define IDD_RETRY_UID_PWD_DMN           129
#define IDD_RETRY_UID_AND_DMN           130
#define IDD_RETRY_PWD_AND_DMN           131
#define IDD_RETRY_DMN_ONLY              132
#define IDD_RETRY_UID_AND_PWD           133
#define IDD_RETRY_UID_ONLY              134
#define IDD_RETRY_PWD_ONLY              135
//                                      136
//                                      137
//                                      138
//                                      139
//                                      140
//                                      141
//                                      142
//                                      143
#define IDD_INTERNET_SIGNIN             144
#define IDD_INTERNET_SIGNIN_NO_UID      145
#define IDD_INTERNET_SIGNIN_NO_PWD      146
#define IDD_INET_SIGNIN                 147
#define IDD_INET_SIGNIN_NO_UID          148
#define IDD_INET_SIGNIN_NO_PWD          149
#define IDD_OPTIONS                     150
//                                      151
#define IDD_ABOUT                       152
#define IDD_GENERAL                     153
#define IDD_GENERAL_DIRECT              154
#define IDD_VPN                         155

#define IDC_MAIN_BITMAP                 1001
#define IDC_PHONEBOOK_BITMAP            1002
#define IDC_MAIN_USERNAME_EDIT          1004
#define IDC_MAIN_PASSWORD_EDIT          1005
#define IDC_MAIN_REMEMBER_CHECKBOX      1006
#define IDC_MAIN_MESSAGE_DISPLAY        1007
#define IDC_MAIN_STATUS_DISPLAY         1008
#define IDC_MAIN_DOMAIN_EDIT            1009
#define IDC_MAIN_PROPERTIES_BUTTON      1010
#define IDC_MAIN_HELP_BUTTON            1011
#define IDB_ABOUT                       1012
#define IDC_EDIT_PHONE                  1013
#define IDC_EDIT_AREA_CODE              1014
#define IDC_EDIT_EXACT                  1015
#define IDC_EDIT_COUNTRY_COMBO          1016
#define IDC_MAIN_USERNAME_STATIC        1017
#define IDC_MAIN_PASSWORD_STATIC        1018
#define IDC_MAIN_DOMAIN_STATIC          1019
#define IDC_EDIT_HELP                   1020
#define IDC_RADIO_DIRECT                1021
#define IDC_RADIO_DIALUP                1022
//                                      1023
//                                      1024
#define IDC_PHONEBOOK_SERVICETYPE_COMBO 1025
#define IDC_PHONEBOOK_COUNTRY_COMBO     1026
#define IDC_PHONEBOOK_PHONE_LIST        1027
#define IDC_PHONEBOOK_REGION_COMBO      1028
#define IDC_PHONEBOOK_REGION_STATIC     1029
#define IDC_PHONEBOOK_HELP_BUTTON       1030
#define IDC_PHONEBOOK_MORE_BUTTON       1031
#define IDC_PHONEBOOKEX_PHONE_LIST      1032
#define IDC_PHONEBOOKEX_MESSAGE_DISPLAY 1033
#define IDC_MAIN_SERVICE_LABEL          1034
#define IDC_MAIN_STATUS_LABEL           1035
#define IDC_PHONEBOOKEX_MORE_STATIC     1036
//                                      1037
#define IDC_CONNSTAT_ICON               1038
#define IDC_CONNSTAT_DURATION_DISPLAY   1039
#define IDC_CONNSTAT_SPEED_DISPLAY      1040
#define IDC_CONNSTAT_RECEIVED_DISPLAY   1041
#define IDC_CONNSTAT_SENT_DISPLAY       1042
#define IDC_CONNSTAT_DISCONNECT_BUTTON  1043
#define IDC_CONNSTAT_DISCONNECT_DISPLAY 1044
#define IDC_NEW_PASSWORD                1045
#define IDC_CONFIRMNEWPASSWORD          1046
//                                      1047
//                                      1048
#define IDC_DETAILS                     1049
#define IDC_DETAILINFO                  1050
#define IDC_DIALGROUP                   1051
#define IDC_MODEMGROUP                  1052
#define IDC_INET_ICON                   1053
#define IDC_CALLBACK_NUM_EDIT           1054
#define IDC_CALLBACK_NUM_LABEL1         1055
#define IDC_CALLBACK_NUM_LABEL2         1056
#define IDC_CONNECT                     1057
#define IDC_RECONNECT_MSG               1058
#define IDC_MAIN_RESET_PASSWORD         1059
#define IDC_MAIN_CUSTOM                 1060
#define IDC_ABOUT_FRAME                 1061
#define IDC_ABOUT_BITMAP                1062
#define IDC_ABOUT_VERSION               1063
#define IDC_ABOUT_WARNING               1064
#define IDC_ABOUT_CM_STATIC             1065
#define IDC_ABOUT_VERSION_STATIC        1066
#define IDC_ABOUT_COPYRIGHT_STATIC      1067
#define IDC_ABOUT_SHOCKWAVE_STATIC      1068
#define IDC_CONNSTAT_STATIC_CALL_DURATION   1069
#define IDC_CONNSTAT_STATIC_CONNECT_SPEED   1070
#define IDC_CONNSTAT_STATIC_BYTES_RECEIVED  1071
#define IDC_CONNSTAT_STATIC_BYTES_SENT      1072
//                                      1073
//                                      1074
//                                      1075
//                                      1076
//                                      1077
//                                      1078
//                                      1079
//                                      1080
//                                      1081
#define IDC_RETRY_DOMAIN                1082
#define IDC_RETRY_PASSWORD              1083
#define IDC_RETRY_USERNAME              1084
#define IDC_RETRY_REMEMBER              1085
#define IDC_RETRY_PASSWORD_STATIC       1086
#define IDC_RETRY_USERNAME_STATIC       1087
#define IDC_RETRY_DOMAIN_STATIC         1088
#define IDC_RETRY_EXPLAIN               1089
//                                      1090
//                                      1091
#define IDS_BAD_CON_FILE                1092
#define IDS_WRONG_WINDOWS_VER16         1093
#define IDS_WRONG_WINDOWS_VER32         1094
#define IDS_DNSERR_CAPTION              1095
#define IDS_DNSERR_MESSAGE              1096
//                                      1097
#define IDS_CAPTION                     1098
#define IDS_IPNOMEM                     1099
#define IDS_IPBAD_FIELD_VALUE           1100
#define IDS_ADVANCED_BAD_IRQ            1101
#define IDS_ADVANCED_BAD_HEXCHR         1102
#define IDS_COMM_NOT_AVAILABLE          1103
#define IDS_MODEMS_PROPERTIES           1104

#define IDS_NO_MODEM_INSTALLED          1105
#define IDS_INSTALL_MODEM               1106
#define IDS_CHANGE_MODEM                1107

#define IDS_CANCEL_PLAYBACK             1108
#define IDS_TERMINAL_CAPTION            1109
#define IDS_DOMAIN_BAD_IP               1110
#define IDS_SHIVAENV_NOT_SET            1111
//                                      1112
#define IDS_IP_UNKNOWN                  1113
#define IDS_IP_ADDRESS                  1114
#define IDS_SHIVAENV_NOT_SET_2          1115
#define IDC_PHONE_NUMBER                1116
#define IDC_GENERAL_START_IE            1117
#define IDC_MODEM_TYPE                  1118
#define IDC_MODEM_CHANGE_MODEM          1119
#define IDC_MODEM_PORT                  1120
#define IDC_MODEM_SPEAKER_BOX           1121
#define IDC_MODEM_MAXSPEED              1122
#define IDC_MODEM_ADVANCED              1123
#define IDC_ADVANCED_IRQ                1124
#define IDC_ADVANCED_IOADR              1125
#define IDC_DOMAIN_NAME                 1126
#define IDC_DOMAIN_DNS                  1127
#define IDC_DOMAIN_BACKUP               1128
#define IDC_MODEM_OFF                   1130
#define IDC_DOMAIN_STATIC_IP            1131
#define IDC_MODEM_HIGH                  1132
//                                      1133
//                                      1134
//                                      1135
//                                      1136
//                                      1137
//                                      1138
//                                      1139
#define IDC_DOMAIN_IP_DYNAMIC           1140
#define IDC_DOMAIN_IP_STATIC            1141
#define IDC_DOMAIN_DNS_DYNAMIC          1142
#define IDC_DOMAIN_DNS_STATIC           1143
#define IDC_DOMAIN_STATIC_IP_LBL        1144
#define IDC_DOMAIN_DNS_PRI_LBL          1145
#define IDC_DOMAIN_DNS_SEC_LBL          1146
#define IDC_COUNTRY_COMBO               1147
#define IDC_CONNECT_LINE_IP             1148
// End IEDIAL defines

#define IDC_GENERAL_EDITNUMBER          1244
#define IDC_GENERAL_PHONENUMBERS_GROUPBOX 1245
#define IDC_STATIC_MINUTES              1246
#define IDC_STATIC_TIMES                1247
#define IDC_GENERAL_PRIMARYDESC_DISPLAY 1248
#define IDC_GENERAL_BACKUPDESC_DISPLAY  1249
#define IDC_GENERAL_P1_STATIC           1250
#define IDC_GENERAL_P2_STATIC           1251
#define IDC_GENERAL_PRIMARY_EDIT        1252
#define IDC_GENERAL_BACKUP_EDIT         1253
#define IDC_GENERAL_PRIMARYPB_BUTTON    1254
#define IDC_GENERAL_BACKUPPB_BUTTON     1255
#define IDC_GENERAL_TAPI_BUTTON         1256
#define IDC_GENERAL_MODEM_COMBO         1257
#define IDC_GENERAL_UDR1_CHECKBOX       1258
#define IDC_GENERAL_UDR2_CHECKBOX       1259
#define IDC_INET_USERNAME_STATIC        1261
#define IDC_INET_PASSWORD_STATIC        1262
#define IDC_CONNECT_USING               1263
#define IDC_INET_USERNAME               1264
#define IDC_INET_PASSWORD               1265
//                                      1266
#define IDC_INET_REMEMBER               1267
#define IDC_OPTIONS_IDLETIME_LIST       1269
#define IDC_OPTIONS_REDIALCOUNT_SPIN    1270
#define IDC_OPTIONS_REDIALCOUNT_EDIT    1271
#define IDC_MAIN_NOPROMPT_CHECKBOX      1272
#define IDC_OPTIONS_SECURITY            1275
#define IDC_OPTIONS_START_IE            1276
#define IDC_OPTIONS_MINIMIZE            1277    
#define IDC_MAIN_NOPASSWORD_CHECKBOX    1278
#define IDC_OPTIONS_LOGGING             1279
#define IDC_OPTIONS_CLEAR_LOG           1280    
#define IDC_OPTIONS_VIEW_LOG            1281    
#define IDC_LOGGING_GROUPBOX            1282
//
#define IDC_VPN_MSG                     1285
#define IDC_VPN_SEL_COMBO               1286

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

#define ICONNMGR_BMP_CLASS      TEXT("IConnMgr Bitmap Class")
#define ICONNMGR_STATUS_CLASS   TEXT("IConnMgr Status Class")

// Access Point specific values
#define IDD_MAIN_ALL_USERDATA_FAV       1290
#define IDC_MAIN_ACCESSPOINT_STATIC     1291
#define IDC_MAIN_ACCESSPOINT_COMBO      1292

#define IDD_MAIN_NO_USERDATA_FAV        1293
#define IDD_MAIN_UID_ONLY_FAV           1294
#define IDD_MAIN_UID_AND_PWD_FAV        1295
#define IDD_MAIN_UID_AND_DMN_FAV        1296
#define IDD_MAIN_PWD_ONLY_FAV           1297
#define IDD_MAIN_PWD_AND_DMN_FAV        1298
#define IDD_MAIN_DMN_ONLY_FAV           1299


#define IDC_GENERAL_ACCESSPOINT_STATIC  1302
#define IDC_GENERAL_NEWAP_BUTTON        1303
#define IDC_GENERAL_DELETEAP_BUTTON     1304
#define IDC_SETTINGS                    1305
#define IDC_GENERAL_ACCESSPOINT_COMBO   1306

#define IDD_NEW_ACCESSPOINT             1307
#define IDC_NEWAP_NAME_EDIT             1308

// Dialogs with global credentials options _GCOPT
#define IDD_MAIN_ALL_USERDATA_FAV_GCOPT 1309
#define IDD_MAIN_UID_AND_PWD_FAV_GCOPT  1310
#define IDD_MAIN_PWD_ONLY_FAV_GCOPT     1311
#define IDD_MAIN_PWD_AND_DMN_FAV_GCOPT  1312
#define IDD_MAIN_ALL_USERDATA_GCOPT     1313
#define IDD_MAIN_UID_AND_PWD_GCOPT      1314
#define IDD_MAIN_PWD_ONLY_GCOPT         1315
#define IDD_MAIN_PWD_AND_DMN_GCOPT      1316

#define IDC_OPT_CREDS_SINGLE_USER       1317
#define IDC_OPT_CREDS_ALL_USER          1318

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        156
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1319
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\tooltip.h ===
//+----------------------------------------------------------------------------
//
// File:     tooltip.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Main header file for tool tips
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:   markcl Created    11/2/00
//
//+----------------------------------------------------------------------------

// NOTE: The following 2 sections will need to be removed if we compile with NT verion > 4.0 
// or _WIN32_IE > 4.0.

//
// Copied from commctrl.h
//
#define TTS_BALLOON             0x40
//#define TTI_INFO                1

#define TTM_SETTITLEA           (WM_USER + 32)  // wParam = TTI_*, lParam = char* szTitle
#define TTM_SETTITLEW           (WM_USER + 33)  // wParam = TTI_*, lParam = wchar* szTitle

#ifdef UNICODE
#define TTM_SETTITLE            TTM_SETTITLEW
#else
#define TTM_SETTITLE            TTM_SETTITLEA
#endif
// End of copied commctrl.h

//
// Copied from shlwapi.h
//
typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);
// End of copied shlwapi.h



//+---------------------------------------------------------------------------
//
//	class CBalloonTip
//
//	Description: Balloon Tip window
//
//	History:	markcl    Created   10/31/00
//
//----------------------------------------------------------------------------

class CBalloonTip
{
public:
	CBalloonTip();
		
	BOOL DisplayBalloonTip(LPPOINT lppoint, UINT iIcon, LPCTSTR lpszTitle, LPTSTR lpszBalloonMsg, HWND hWndParent);
	BOOL HideBalloonTip();


protected:
    static LRESULT CALLBACK SubClassBalloonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static WNDPROC m_pfnOrgBalloonWndProc;  // the original edit control window proc for subclassing

	HWND		m_hwndTT;		// handle for the balloon tooltip
	BOOL		m_bTTActive;	// whether the balloon tooltip is active or not

	TOOLINFO	m_ti;				// tooltip structure

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\tooltip.cpp ===
//+----------------------------------------------------------------------------
//
// File:     tooltip.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the code for the implementing balloon tips.
//
// Copyright (c) 1996-2000 Microsoft Corporation
//
// Author:   markcl    Created Header   11/2/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"


WNDPROC CBalloonTip::m_pfnOrgBalloonWndProc = NULL;

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::CBalloonTip
//
// Synopsis:  Balloon tip constructor
//
// Arguments:	nothing
//
// Returns:   nothing
//
// History:   markcl	Created Header    10/31/00
//
//+----------------------------------------------------------------------------

CBalloonTip::CBalloonTip()
{
    // Nothing to do
}

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::DisplayBallonTip
//
// Synopsis:  Displays a balloon tip
//
// Arguments:	LLPOINT	lppoint         - pointer to a POINT struct with the coordinates for displaying
//              int		iIcon           - type of icon to display in the balloon tip
//              LPCTSTR	lpszTitle       - Title of the balloon tip window
//              LPTSTR	lpszBalloonMsg  - Message to display in the balloon tip
//              HWND	hWndParent      - handle to the parent window
//
// Returns:   nothing
//
// History:   markcl    Created Header    10/31/00
//
//+----------------------------------------------------------------------------
BOOL CBalloonTip::DisplayBalloonTip(LPPOINT lppoint, UINT iIcon, LPCTSTR lpszTitle, LPTSTR lpszBalloonMsg, HWND hWndParent)
{

    //
    //	If we don't have a message or a position, we don't display the balloon tip.
    //
    if (NULL == lpszBalloonMsg || NULL == lppoint)
    {
        MYDBGASSERT(lpszBalloonMsg && lppoint);

        return FALSE;
    }

    //
    //  Comctl32.dll must be 5.80 or greater to use balloon tips.  We check the dll version 
    //  by calling DllGetVersion in comctl32.dll.
    //
    HINSTANCE hComCtl = LoadLibraryExA("comctl32.dll", NULL, 0);

    CMASSERTMSG(hComCtl, TEXT("LoadLibrary - comctl32 failed for Balloon Tips"));

    if (hComCtl != NULL)
    {
        typedef HRESULT (*DLLGETVERSIONPROC)(DLLVERSIONINFO* lpdvi);

        DLLGETVERSIONPROC fnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hComCtl,"DllGetVersion");

        MYDBGASSERT(fnDllGetVersion);

        if (NULL == fnDllGetVersion)
        {
            //
            //  DllGetVersion does not exist in Comctl32.dll.  This mean the version is too old so we need to fail.
            //
            FreeLibrary(hComCtl);
            return FALSE;
        }
        else
        {
            DLLVERSIONINFO dvi;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            HRESULT hResult = (*fnDllGetVersion)(&dvi);

            FreeLibrary(hComCtl);
			
            if (SUCCEEDED(hResult))
            {
                //
                //  Take the version returned and compare it to 5.80.
                //
                if (MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion) < MAKELONG(80,5))
                {
                    CMTRACE2(TEXT("COMCTL32.DLL version - %d.%d"),dvi.dwMajorVersion,dvi.dwMinorVersion);
                    CMTRACE1(TEXT("COMCTL32.DLL MAKELONG - %li"),MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion));
                    CMTRACE1(TEXT("Required minimum MAKELONG - %li"),MAKELONG(80,5));
					
                    // Wrong DLL version
                    return FALSE;
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("Call to DllGetVersion in comctl32.dll failed."));
                return FALSE;
            }
        }
    }

    //
    //  Hide any existing balloon tips before trying to display a new one.
    //    
    if (m_hwndTT && m_bTTActive)
    {
        HideBalloonTip();
    }

    //
    // Create the Balloon ToolTip window
    //
    m_hwndTT = CreateWindowExU(NULL,TOOLTIPS_CLASS, TEXT("CM Balloon Tip Window"),
                               WS_POPUP | TTS_BALLOON, CW_USEDEFAULT, CW_USEDEFAULT,
                               CW_USEDEFAULT, CW_USEDEFAULT, hWndParent, NULL, g_hInst, NULL);

    if (m_hwndTT)
    {
        m_ti.cbSize = sizeof(m_ti);
        m_ti.uFlags = TTF_TRACK;
        m_ti.hwnd = hWndParent;
        m_ti.hinst = g_hInst;
	
        SendMessageU(m_hwndTT,TTM_ADDTOOL,0,(LPARAM) (LPTOOLINFO) &m_ti);

        SendMessageU(m_hwndTT,TTM_SETMAXTIPWIDTH,0,200);
    }
    else
    {
        MYDBGASSERT(m_hwndTT);
        return FALSE;
    }

    //
    //  Subclass the edit control
    //
    m_pfnOrgBalloonWndProc = (WNDPROC)SetWindowLongU(m_hwndTT, GWLP_WNDPROC, (LONG_PTR)SubClassBalloonWndProc);

    //
    //  Save the this pointer with the window
    //
    SetWindowLongU(m_hwndTT, GWLP_USERDATA, (LONG_PTR)this);

    //
    //	Set the balloon message
    //
    m_ti.lpszText = lpszBalloonMsg;
    SendMessageU(m_hwndTT,TTM_UPDATETIPTEXT,0,(LPARAM) (LPTOOLINFO) &m_ti);

    //
    //  If we got a title, then add it
    //
    if (lpszTitle)
    {
	
        //
        //  confirm we have a valid icon
        //
        if (iIcon > 3)
        {
            iIcon = TTI_NONE;  // TTI_NONE = No icon
        }
		
        SendMessageU(m_hwndTT,TTM_SETTITLE,(WPARAM) iIcon,(LPARAM) lpszTitle);
    }

    //
    //  Set the position
    //
    SendMessageU(m_hwndTT,TTM_TRACKPOSITION,0,(LPARAM) (DWORD) MAKELONG(lppoint->x,lppoint->y));

    //
    //  Show balloon tip window
    //
    SendMessageU(m_hwndTT,TTM_TRACKACTIVATE,(WPARAM) TRUE,(LPARAM) (LPTOOLINFO) &m_ti);

    //  Set active state
    m_bTTActive = TRUE;
	
    return TRUE;

}

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::HideBallonTip
//
// Synopsis:  Hides a balloon tip
//
// Arguments: nothing
//
// Returns:   nothing
//
// History:   markcl	Created Header    10/31/00
//
//+----------------------------------------------------------------------------
BOOL CBalloonTip::HideBalloonTip()
{

    // check active state && handle
    if(m_hwndTT && m_bTTActive)
    {
        // hide window
        SendMessageU(m_hwndTT,TTM_TRACKACTIVATE,(WPARAM) FALSE,(LPARAM) (LPTOOLINFO) &m_ti);

        m_bTTActive = FALSE;

        // force a repaint on parent window
        InvalidateRect(m_ti.hwnd,NULL,NULL);

        // destroy window
        DestroyWindow(m_hwndTT);
        m_hwndTT = NULL;

        return TRUE;

    }
    else
    {

        return FALSE;
    
    }

}

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::SubClassBalloonWndProc
//
// Synopsis:  Subclassed wnd proc to trap the mouse button clicks on the balloon tip window
//
// Arguments: standard win32 window proc params
//
// Returns:   standard win32 window proc return value
//
// History:   markcl      created         11/2/00
//
//+----------------------------------------------------------------------------
LRESULT CALLBACK CBalloonTip::SubClassBalloonWndProc(HWND hwnd, UINT uMsg, 
                                                      WPARAM wParam, LPARAM lParam)
{

    if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN))
    {
	
        //
        // Get the object pointer saved by SetWindowLong
        //
        CBalloonTip* pBalloonTip = (CBalloonTip*)GetWindowLongU(hwnd, GWLP_USERDATA);
        MYDBGASSERT(pBalloonTip);

        if (pBalloonTip)
        {
            pBalloonTip->HideBalloonTip();
        }
    }

    // 
    // Call the original window procedure for default processing. 
    //
    return CallWindowProcU(m_pfnOrgBalloonWndProc, hwnd, uMsg, wParam, lParam); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\tapi.cpp ===
//+----------------------------------------------------------------------------
//
// File:     tapi.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The module contains the code related to TAPI.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   byao       created         04/29/97
//           quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"    
#include "unimodem.h" 

//
// Local prototype
//

DWORD GetModemSpeakerMode(TapiLinkageStruct *ptlsTapiLink);

//+----------------------------------------------------------------------------
//
// Function:  TapiCallback
//
// Synopsis:  NULL callback required param when intializing line
//
// Arguments: DWORD hDevice - 
//            DWORD dwMsg - 
//            DWORD dwCallbackInstance - 
//            DWORD dwParam1 - 
//            DWORD dwParam2 - 
//            DWORD dwParam3 - 
//
// Returns:   Nothing
//
// History:   nickball      Created Header    7/7/99
//
//+----------------------------------------------------------------------------

VOID FAR PASCAL TapiCallback(DWORD hDevice, 
                             DWORD dwMsg, 
                             DWORD dwCallbackInstance, 
                             DWORD dwParam1, 
                             DWORD dwParam2, 
                             DWORD dwParam3) 
{
    // nothing
}

//+----------------------------------------------------------------------------
//
// Function:  OpenTapi
//
// Synopsis:  
//
// Arguments: HINSTANCE hInst - 
//            TapiLinkageStruct *ptlsTapiLink - 
//
// Returns:   BOOL - 
//
// History:   quintinb Created Header    5/1/99
//
//+----------------------------------------------------------------------------
BOOL OpenTapi(HINSTANCE hInst, TapiLinkageStruct *ptlsTapiLink) 
{
    LONG lRes;

    if (ptlsTapiLink->bOpen) 
    {
        return (TRUE);
    }
    
    if (!ptlsTapiLink->pfnlineInitialize || !ptlsTapiLink->pfnlineShutdown) 
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return (FALSE);
    }
    
    lRes = ptlsTapiLink->pfnlineInitialize(&ptlsTapiLink->hlaLine,
                                            hInst,
                                            TapiCallback,
                                            NULL,
                                            &ptlsTapiLink->dwDevCnt);

    CMTRACE3(TEXT("OpenTapi() lineInitialize() returns %u, hlaLine=0x%x, dwDevCnt=%u."), 
        lRes, ptlsTapiLink->hlaLine, ptlsTapiLink->dwDevCnt);
    
    if (lRes != 0) 
    {
        DWORD dwErr = ERROR_INVALID_PARAMETER;

        switch (lRes) 
        {

            case LINEERR_REINIT:
                dwErr = ERROR_BUSY;
                break;

            case LINEERR_RESOURCEUNAVAIL:
            case LINEERR_NOMEM:
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
        }

        SetLastError(dwErr);
        return (FALSE);
    }
    
    ptlsTapiLink->bOpen = TRUE;
    ptlsTapiLink->bDevicePicked = FALSE;
    ptlsTapiLink->bModemSpeakerOff = FALSE;

    return (TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CloseTapi
//
// Synopsis:  Helper function to clean up TAPI line.
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - Our TAPI linkage struct
//
// Returns:   Nothing
//
// History:   nickball    Created Header    7/7/99
//
//+----------------------------------------------------------------------------

void CloseTapi(TapiLinkageStruct *ptlsTapiLink) 
{
    if (ptlsTapiLink->bOpen) 
    {
        ptlsTapiLink->bOpen = FALSE;
        ptlsTapiLink->pfnlineShutdown(ptlsTapiLink->hlaLine);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  LinkToTapi
//
// Synopsis:  Encapsulates the calling of LinkToDll with the correct table of 
//            function names to be used therein with GetProcAddress
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - The Tapi linkage struct to receive the function addresses
//            LPCTSTR pszTapi - The explicit name of the DLL  
//
// Returns:   BOOL - TRUE if fully linked
//
// History:   nickball    Created Header    12/31/97
//
//+----------------------------------------------------------------------------

BOOL LinkToTapi(TapiLinkageStruct *ptlsTapiLink, LPCSTR pszTapi) 
{
    BOOL bRet = FALSE;

    if (OS_NT)
    {
        static LPCSTR apszTapi[] = 
        {
            //
            //  Several of the Tapi Functions don't have W versions.  Use all the Unicode functions
            //  that we can however.
            //
            "lineInitialize", // no W version
            "lineNegotiateAPIVersion", // no W version
            "lineGetDevCapsW",
            "lineGetDevConfig",
            "lineShutdown", // no W version
            "lineTranslateAddressW",
            "lineTranslateDialogW",
            "lineGetTranslateCaps",
            "lineSetCurrentLocation",
            NULL
        };

        MYDBGASSERT(sizeof(ptlsTapiLink->apvPfnTapi)/sizeof(ptlsTapiLink->apvPfnTapi[0])==sizeof(apszTapi)/sizeof(apszTapi[0]));
        bRet = LinkToDll(&ptlsTapiLink->hInstTapi,pszTapi,apszTapi,ptlsTapiLink->apvPfnTapi);    
    }
    else
    {
        static LPCSTR apszTapi[] = 
        {
            "lineInitialize",
            "lineNegotiateAPIVersion",
            "lineGetDevCaps",
            "lineGetDevConfig",
            "lineShutdown",
            "lineTranslateAddress",
            "lineTranslateDialog",
            "lineGetTranslateCaps",
            "lineSetCurrentLocation",
            NULL
        };
        MYDBGASSERT(sizeof(ptlsTapiLink->apvPfnTapi)/sizeof(ptlsTapiLink->apvPfnTapi[0])==sizeof(apszTapi)/sizeof(apszTapi[0]));
        bRet = LinkToDll(&ptlsTapiLink->hInstTapi,pszTapi,apszTapi,ptlsTapiLink->apvPfnTapi);    
    }

    return bRet;
}



//+----------------------------------------------------------------------------
//
// Function:  UnlinkFromTapi
//
// Synopsis:  Helper function to release link to TAPI and clear linkage struct
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - Ptr to our TAPI linkage struct
//
// Returns:   Nothing
//
// History:   nickball    Created Header    7/7/99
//            
//            t-urama     Modified          08/04/00 Access Points: Restore Tapi 
//                                                   location when CM was started
//+----------------------------------------------------------------------------

void UnlinkFromTapi(TapiLinkageStruct *ptlsTapiLink) 
{
    if (ptlsTapiLink->hInstTapi) 
    {
        //
        // If we changed the original Tapi location, restore it
        //
        if (-1 != ptlsTapiLink->dwOldTapiLocation)
        {
            RestoreOldTapiLocation(ptlsTapiLink);
        }

        CloseTapi(ptlsTapiLink);
        
        FreeLibrary(ptlsTapiLink->hInstTapi);
        
        memset(ptlsTapiLink,0,sizeof(*ptlsTapiLink));
    }
}

LPTSTR GetModemFromLineDevCapsWithAlloc(LPLINEDEVCAPS pldcLineDevCaps)
{
    LPTSTR pszTmp = NULL;

    if (OS_NT)
    {
        pszTmp = (LPTSTR) CmMalloc((pldcLineDevCaps->dwLineNameSize + 1)*sizeof(TCHAR));

        if (pszTmp)
        {
            LPTSTR pszPointerIntoTapiBuffer = LPTSTR((DWORD_PTR)pldcLineDevCaps + pldcLineDevCaps->dwLineNameOffset);
            lstrcpynU (pszTmp, pszPointerIntoTapiBuffer, pldcLineDevCaps->dwLineNameSize + 1);
        }    
    }
    else
    {
        //
        //  If this is Win9x, then we have an Ansi buffer that we need to convert to Unicode
        //
        LPSTR pszAnsiTmp = (LPSTR) CmMalloc((pldcLineDevCaps->dwLineNameSize + 1)*sizeof(CHAR));

        if (pszAnsiTmp)
        {
            LPSTR pszPointerIntoTapiBuffer = LPSTR((DWORD_PTR)pldcLineDevCaps + pldcLineDevCaps->dwLineNameOffset);
            lstrcpynA (pszAnsiTmp, pszPointerIntoTapiBuffer, pldcLineDevCaps->dwLineNameSize + 1);

            pszTmp = SzToWzWithAlloc(pszAnsiTmp);

            CmFree(pszAnsiTmp);
        }
    
    }

    return pszTmp;
}

BOOL SetTapiDevice(HINSTANCE hInst, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   LPCTSTR pszModem) 
{
    BOOL bRet = TRUE;
    LONG lRes;
    DWORD dwTmp;
    LPLINEDEVCAPS pldcLineDevCaps;

    if (!OpenTapi(hInst,ptlsTapiLink)) 
    {
        return (FALSE);
    }
    
    if (ptlsTapiLink->bDevicePicked && (lstrcmpU(ptlsTapiLink->szDeviceName, pszModem) == 0)) 
    {
        return (TRUE);
    }
    
    CMTRACE1(TEXT("SetTapiDevice() looking for device name match with (%s)."), pszModem);

    ptlsTapiLink->bDevicePicked = FALSE;

    //
    //  LineGetDevCaps has both an Ansi version (win9x) and a Unicode version.  Thus we must use
    //  the correct char size as needed.
    //
    dwTmp = sizeof(LINEDEVCAPS) + (2048 * (OS_NT ? sizeof(WCHAR) : sizeof(CHAR)));
    
    pldcLineDevCaps = (LPLINEDEVCAPS) CmMalloc(dwTmp);
    if (NULL == pldcLineDevCaps)
    {
        return FALSE;
    }
    pldcLineDevCaps->dwTotalSize = dwTmp;

    for (ptlsTapiLink->dwDeviceId=0; ptlsTapiLink->dwDeviceId < ptlsTapiLink->dwDevCnt; ptlsTapiLink->dwDeviceId++) 
    {
        LINEEXTENSIONID leiLineExtensionId;

        lRes = ptlsTapiLink->pfnlineNegotiateAPIVersion(ptlsTapiLink->hlaLine,
                                                         ptlsTapiLink->dwDeviceId,
                                                         MIN_TAPI_VERSION,
                                                         MAX_TAPI_VERSION,
                                                         &ptlsTapiLink->dwApiVersion,
                                                         &leiLineExtensionId);

        CMTRACE3(TEXT("******* SetTapiDevice() lineNegotiateAPIVersion(dwDeviceId=%u) returns %u, dwApiVersion=0x%x."), 
            ptlsTapiLink->dwDeviceId, lRes, ptlsTapiLink->dwApiVersion);
    
        if (lRes == ERROR_SUCCESS) 
        {
            lRes = ptlsTapiLink->pfnlineGetDevCaps(ptlsTapiLink->hlaLine,
                                                    ptlsTapiLink->dwDeviceId,
                                                    ptlsTapiLink->dwApiVersion,
                                                    0,
                                                    pldcLineDevCaps);

            CMTRACE2(TEXT("SetTapiDevice() lineGetDevCaps(dwDeviceId=%u) returns %u."), 
                ptlsTapiLink->dwDeviceId, lRes);
            
            if (lRes == ERROR_SUCCESS) 
            {
                //
                // Copy out the device name according to reported offset and 
                // length. Don't assume that its a NULL terminated string.
                //
                LPTSTR pszTmp = GetModemFromLineDevCapsWithAlloc(pldcLineDevCaps);

                if (pszTmp)
                {
                    //
                    //  Okay, we have a device name from TAPI, first try to do a straight
                    //  comparision with the one we are looking for
                    //

                    CMTRACE1(TEXT("SetTapiDevice() - examining LineName of (%s)."), pszTmp); 
                    
                    if (0 == lstrcmpU(pszModem, pszTmp))
                    {
                        ptlsTapiLink->bDevicePicked = TRUE;
                    }
                    else
                    {
                        //
                        //  We didn't find a straight match but that doesn't mean that
                        //  this isn't our device.  On NT, RAS keeps its device names in ANSI
                        //  internally.  Thus we can try roundtripping the string to MBCS and
                        //  back and see if they match now.  Another possibility is that this
                        //  is an ISDN device, because on NT4 the RAS name and TAPI name are
                        //  different for ISDN devices.  So, instead of checking the LineName
                        //  we should check the ProviderInfo (it is concatenation of two NULL terminated strings
                        //  and the second string is the used by RAS as device name)
                        //
                        if (OS_NT)
                        {
                            DWORD dwSize = WzToSz(pszTmp, NULL, 0); // cannot use WzToSzWithAlloc or we would get asserts
                                                                    // that the string didn't roundtrip on debug builds.
                                                                    // The point here is not to have it round trip so 
                                                                    // that is what we want but we don't want to assert.

                            if (0 != dwSize)
                            {
                                LPSTR pszAnsiTmp = (LPSTR)CmMalloc(dwSize*sizeof(CHAR));

                                if (pszAnsiTmp)
                                {
                                    if (WzToSz(pszTmp, pszAnsiTmp, dwSize))
                                    {
                                       LPWSTR pszRoundTripped = SzToWzWithAlloc(pszAnsiTmp);

                                        if (pszRoundTripped)
                                        {
                                            if (0 == lstrcmpU(pszModem, pszRoundTripped))
                                            {
                                                ptlsTapiLink->bDevicePicked = TRUE;
                                            }
                                        }
                                        CmFree(pszRoundTripped);
                                    }
                                    CmFree(pszAnsiTmp);
                                }
                            }

                            //
                            //  Okay, check for an ISDN device name if it is one
                            //
                            if (!ptlsTapiLink->bDevicePicked)
                            {
                                //
                                // Copy out the provider info according to reported offset  
                                // and length. Don't assume that its NULL terminated.
                                //
                                CmFree(pszTmp);
                                pszTmp = (LPTSTR) CmMalloc((pldcLineDevCaps->dwProviderInfoSize + 1)*sizeof(TCHAR));
                    
                                if (pszTmp)
                                {                       
                                    lstrcpynU(pszTmp, (LPTSTR)((LPBYTE)pldcLineDevCaps + pldcLineDevCaps->dwProviderInfoOffset), (pldcLineDevCaps->dwProviderInfoSize + 1));

                                    //
                                    // We should do this only if the device type is ISDN
                                    // The device type is the first string in the ProviderInfo
                                    //

                                    CMTRACE1(TEXT("SetTapiDevice() - examining ProviderInfo of (%s) for match with (RASDT_Isdn)."), pszTmp); 
                        
                                    if (0 == lstrcmpiU(pszTmp, RASDT_Isdn))
                                    {
                                        ptlsTapiLink->bDevicePicked = TRUE;
                                    }
                                }                    
                            }
                        }
                    }
                }

                //
                //  If we found a device, then we need to copy the name over
                //
                if (ptlsTapiLink->bDevicePicked)
                {
                    lstrcpynU(ptlsTapiLink->szDeviceName, pszModem, CELEMS(ptlsTapiLink->szDeviceName));

                    if (OS_NT)
                    {
                        dwTmp = GetModemSpeakerMode(ptlsTapiLink);
        
                        if (-1 != dwTmp && MDMSPKR_OFF == dwTmp)
                        {
                            ptlsTapiLink->bModemSpeakerOff = TRUE;
                        }
                    }

                    //
                    //  We found a device, stop looking...
                    //
                    CmFree(pszTmp);
                    break;
                }

                CmFree(pszTmp);
            }
        }
    }
    
    CmFree(pldcLineDevCaps);
    bRet = ptlsTapiLink->bDevicePicked;

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  GetModemSpeakerMode
//
// Synopsis:  Queries Modem settings for Speaker modeof a modem device.
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - Ptr to TAPI linkage 
//
// Returns:   DWORD - The speaker mode for a valid modem device or 0xFFFFFFFF 
//
// History:   nickball    Created     7/7/99
//
//+----------------------------------------------------------------------------
DWORD GetModemSpeakerMode(TapiLinkageStruct *ptlsTapiLink)
{   
    DWORD dwRet = -1;

    LPVARSTRING lpVar = (LPVARSTRING) CmMalloc(sizeof(VARSTRING));

    //
    // Get the required buffer size by querying the config.
    //

    if (lpVar)
    {
        lpVar->dwTotalSize = sizeof(VARSTRING);
        lpVar->dwUsedSize = lpVar->dwTotalSize;

        DWORD dwTmpRet = ptlsTapiLink->pfnlineGetDevConfig(ptlsTapiLink->dwDeviceId, lpVar, "comm/datamodem/dialout"); 

        if (LINEERR_STRUCTURETOOSMALL == dwTmpRet || lpVar->dwNeededSize > lpVar->dwTotalSize)
        {
            //
            // We need a bigger buffer, re-allocate
            // 

            DWORD dwTmp = lpVar->dwNeededSize;

            CmFree(lpVar);
            lpVar = (LPVARSTRING) CmMalloc(dwTmp);                                             
        
            if (lpVar)
            {
                lpVar->dwTotalSize = dwTmp;
                lpVar->dwUsedSize = lpVar->dwTotalSize;

                //
                // Now get the actual config
                //

                dwTmpRet = ptlsTapiLink->pfnlineGetDevConfig(ptlsTapiLink->dwDeviceId, lpVar, "comm/datamodem/dialout"); 

                if (ERROR_SUCCESS != dwTmpRet)
                {
                    CmFree(lpVar);
                    lpVar = NULL;
                }
            }
        }
    }                        
    
    //
    // If we don't have a valid VARSTRING something failed, error out.
    //

    if (NULL == lpVar)
    {
        return -1;                                                
    }
    
    //
    // We have a VARSTRING for the "dialout" config, 
    // get the MODEMSETTINGS info. and see how the
    // modem speaker is configured.
    //

    PUMDEVCFG       lpDevConfig = NULL;
    LPCOMMCONFIG    lpCommConfig    = NULL;
    LPMODEMSETTINGS lpModemSettings = NULL;

    if (lpVar->dwStringFormat == STRINGFORMAT_BINARY && 
        lpVar->dwStringSize >= sizeof(UMDEVCFG))
    {
        lpDevConfig = (PUMDEVCFG) 
            ((LPBYTE) lpVar + lpVar->dwStringOffset);

        lpCommConfig = &lpDevConfig->commconfig;

        //
        // Check modems only
        //

        if (lpCommConfig->dwProviderSubType == PST_MODEM)
        {
            lpModemSettings = (LPMODEMSETTINGS)((LPBYTE) lpCommConfig + 
                                    lpCommConfig->dwProviderOffset);

            dwRet = lpModemSettings->dwSpeakerMode;           
        }                                                
    }

    CmFree(lpVar);

    return dwRet;
}


//+----------------------------------------------------------------------------
//
// Func:    MungePhone
//
// Desc:    call TAPI to do phone dial info translation
//
// Args:    [pszModem]      - IN, modem string
//          [ppszPhone]     - INOUT, phone number for display
//          [ptlsTapiLink]  - IN, argument string for connect action
//          [hInst]         - IN, instance handle (needed to call TAPI)
//          [fDialingRules] - are dialing rules enabled
//          [ppszDial]      - OUT, dialable phone number
//          [fAccessPointsEnabled] - IN, are access points enabled
// Return:  LRESULT
//
// Notes:   
//
// History: 01-Mar-2000   SumitC      Added header block
//          04-Mar-2000   SumitC      fixed case for dialing rules not enabled
//          04-Aug-2000   t-urama     Added changing the TAPI location based on access point
//
//-----------------------------------------------------------------------------

LRESULT MungePhone(LPCTSTR pszModem, 
                   LPTSTR *ppszPhone, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   HINSTANCE hInst, 
                   BOOL fDialingRules,
                   LPTSTR *ppszDial,
                   BOOL fAccessPointsEnabled)
{

    LPLINETRANSLATEOUTPUT pltoOutput = NULL;
    DWORD dwLen;
    LPWSTR pszDisplayable = NULL;
    LPWSTR pszDialable = NULL;
    LPSTR pszAnsiDisplayable = NULL;
    LPSTR pszAnsiDialable = NULL;
    LPTSTR pszOriginalPhoneNumber = NULL;
    LRESULT lRes;

    //
    //  Check the input params.  Note that ppszDial could be NULL.
    //
    if ((NULL == pszModem) || (NULL == ppszPhone) || (NULL == *ppszPhone) || (NULL == ptlsTapiLink) || (NULL == hInst))
    {
        lRes =  ERROR_INVALID_PARAMETER;
        CMASSERTMSG(FALSE, TEXT("MungePhone - invalid param."));
        goto done;
    }
    
    if (!SetTapiDevice(hInst, ptlsTapiLink, pszModem)) 
    {
        lRes = ERROR_NOT_FOUND;
        goto done;
    }

    if (FALSE == fDialingRules)
    {
        pszOriginalPhoneNumber = CmStrCpyAlloc(*ppszPhone);
    }
    
    if (TRUE == fDialingRules)
    {
        if (fAccessPointsEnabled)
        {
            //
            // Access Points are enabled. we now have to change the TAPI location 
            // to that of the current access point. First get the current TAPI 
            // location from TAPI
            //

            DWORD dwRet = GetCurrentTapiLocation(ptlsTapiLink);
            if (-1 == dwRet)
            {
                lRes = ERROR_NOT_FOUND;
                goto done;
            }

            if ((0 != ptlsTapiLink->dwTapiLocationForAccessPoint) && (dwRet != ptlsTapiLink->dwTapiLocationForAccessPoint))
            {
                //
                // The current TAPI location is different from the access point TAPI location
                // Change it.  Note that if the current TAPI location is 0, this just means we haven't written
                // one for the favorite yet.  Don't try to change it as SetCurrentTapiLocation will error out.
                //

                lRes = SetCurrentTapiLocation(ptlsTapiLink, ptlsTapiLink->dwTapiLocationForAccessPoint);
            
                if (lRes != ERROR_SUCCESS)
                {
                    CMASSERTMSG(FALSE, TEXT("MungePhone -- unable to set the current TAPI location."));
                    goto done;
                }

                CMTRACE1(TEXT("MungePhone() - Changed TAPI location to %u."), ptlsTapiLink->dwTapiLocationForAccessPoint);

                //
                // Save the TAPI location that was being used when CM started. 
                // This will be restored when CM exits
                //
                if (-1 == ptlsTapiLink->dwOldTapiLocation) 
                {
                    ptlsTapiLink->dwOldTapiLocation = dwRet;
                    CMTRACE1(TEXT("Saved TAPI location used when CM started, location is %d"), ptlsTapiLink->dwOldTapiLocation);
                }
            }
        }
    }
 
    //
    // Setup buffer for output, make sure to size the CHARs properly
    //
    dwLen = sizeof(*pltoOutput) + (1024 * (OS_NT ? sizeof(WCHAR) : sizeof(CHAR)));

    pltoOutput = (LPLINETRANSLATEOUTPUT) CmMalloc(dwLen);
    if (NULL == pltoOutput)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    pltoOutput->dwTotalSize = dwLen;

    //
    // Do the translation
    //

    if (OS_NT)
    {
        lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                     ptlsTapiLink->dwDeviceId,
                                                     ptlsTapiLink->dwApiVersion,
                                                     *ppszPhone,
                                                     0,
                                                     LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                     pltoOutput);
    }
    else
    {
        LPSTR pszAnsiPhone = WzToSzWithAlloc(*ppszPhone);

        if (pszAnsiPhone)
        {
            //
            // Note that the Cast on parameter 4 is to fake out the compiler, 
            // rather than building a full set of "U" infrastructure for
            // the tapi linkage when only a couple of TAPI calls take strings.
            //
            
            lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                         ptlsTapiLink->dwDeviceId,
                                                         ptlsTapiLink->dwApiVersion,
                                                         (LPWSTR)pszAnsiPhone, 
                                                         0,
                                                         LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                         pltoOutput);
        }

        CmFree(pszAnsiPhone);
    }

    CMTRACE3(TEXT("MungePhone(Modem=%s,Phone=%s) lineTranslateAddress(DeviceId=%u)"),
             MYDBGSTR(pszModem), MYDBGSTR(*ppszPhone), ptlsTapiLink->dwDeviceId);
    CMTRACE1(TEXT("\treturns %u."), lRes);

    if (lRes == ERROR_SUCCESS)
    {    
        //
        // Get ptrs to displayable and dialable variations
        //
        LPBYTE pBase = (LPBYTE) pltoOutput;

        if (OS_NT)
        {
            pszDisplayable = (LPTSTR) (pBase + pltoOutput->dwDisplayableStringOffset);
            pszDialable = (LPTSTR) (pBase + pltoOutput->dwDialableStringOffset);
        }
        else
        {
            pszAnsiDisplayable = (LPSTR)(pBase + pltoOutput->dwDisplayableStringOffset);
            pszAnsiDialable = (LPSTR)(pBase + pltoOutput->dwDialableStringOffset);
        }
    }

done:
    CmFree(*ppszPhone);
    *ppszPhone = NULL;
    if (ppszDial) 
    {
        CmFree(*ppszDial);
        *ppszDial = NULL;
    }
    
    // Allocate buffers using the ptr ptrs specified by the caller 
    // and fill them with the displayable and dialable versions
    

    if (ERROR_SUCCESS == lRes) 
    {
        if (OS_NT)
        {
            if (fDialingRules)
            {
                *ppszPhone = CmStrCpyAlloc(pszDisplayable);
            }
            else
            {
                *ppszPhone = CmStrCpyAlloc(pszOriginalPhoneNumber);
            }
        }
        else
        {
            if (fDialingRules)
            {
                *ppszPhone = SzToWzWithAlloc(pszAnsiDisplayable);
            }
            else
            {
                *ppszPhone = CmStrCpyAlloc(pszOriginalPhoneNumber);
            }
        }
        
        MYDBGASSERT(*ppszPhone);
        if (*ppszPhone)
        {
            //
            // TAPI prepends a space, so trim the displayable number.
            // 
            CmStrTrim(*ppszPhone);
            SingleSpace(*ppszPhone);
        }
        else
        {
            //
            //  If we failed to alloc *ppszPhone, continue because we don't
            //  depend on it below but we want the return code to be a failure.
            //
            lRes = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (ppszDial) 
        {
            if (OS_NT)
            {
                if (fDialingRules)
                {
                    *ppszDial = CmStrCpyAlloc(pszDialable);
                }
                else
                {
                    *ppszDial = (LPTSTR) CmMalloc(sizeof(TCHAR)*(2 + lstrlenU(pszOriginalPhoneNumber))); // 2 == one for NULL term and one for first char of pszDialable

                    if (*ppszDial)
                    {
                        (*ppszDial)[0] = pszDialable[0];
                        (*ppszDial)[1] = 0;
                        lstrcatU(*ppszDial, pszOriginalPhoneNumber);
                    }
                }
            }
            else
            {
                if (fDialingRules)
                {
                    *ppszDial = SzToWzWithAlloc(pszAnsiDialable);
                }
                else
                {
                    *ppszDial = (LPTSTR) CmMalloc(sizeof(TCHAR)*(2 + lstrlenU(pszOriginalPhoneNumber))); // 2 == one for NULL term and one for first char of pszDialable

                    if (*ppszDial)
                    {
                        int lRet = MultiByteToWideChar(CP_ACP, 0, pszAnsiDialable, 1, *ppszDial, 1);

                        (*ppszDial)[lRet] = 0;
                        lstrcatU(*ppszDial, pszOriginalPhoneNumber);
                    }
                }
            }
        }
    }

    if (FALSE == fDialingRules)
    {
        CmFree(pszOriginalPhoneNumber);
    }
    CmFree(pltoOutput);
    return (lRes);
}

//+----------------------------------------------------------------------------
//
// Func:    GetCurrentTapiLocation
//
// Desc:    get the current Tapi location
//
// Args:    [ptlsTapiLink]  - IN, Ptr to TAPI linkage
//          
// Return:  DWORD dwCurrentLoc - Current Tapi Location
//
// Notes:   
//
// History: t-urama     07/21/2000  Created 
//-----------------------------------------------------------------------------

DWORD GetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink)
{
    MYDBGASSERT(ptlsTapiLink->pfnlineGetTranslateCaps);
    if (!ptlsTapiLink->pfnlineGetTranslateCaps)
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return (-1);
    }

    LPLINETRANSLATECAPS lpTranslateCaps = NULL;
    DWORD dwLen;
    LRESULT lRes;
    DWORD dwRes = -1;
    BOOL bLoopAgain = FALSE;

    dwLen = sizeof(*lpTranslateCaps) + (1024 * (OS_NT ? sizeof(WCHAR) : sizeof(CHAR)));

    do
    {
        CmFree(lpTranslateCaps);
        lpTranslateCaps = (LPLINETRANSLATECAPS) CmMalloc(dwLen);
        MYDBGASSERT(lpTranslateCaps);
        
        if (NULL == lpTranslateCaps)
        {
            lRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lpTranslateCaps->dwTotalSize = dwLen;

        lRes = ptlsTapiLink->pfnlineGetTranslateCaps(ptlsTapiLink->hlaLine,                   
                                                    ptlsTapiLink->dwApiVersion,                  
                                                    lpTranslateCaps);

        bLoopAgain = (LINEERR_STRUCTURETOOSMALL == lRes) || ((ERROR_SUCCESS == lRes) && (lpTranslateCaps->dwNeededSize > lpTranslateCaps->dwTotalSize));

        if (bLoopAgain)
        {
            dwLen = lpTranslateCaps->dwNeededSize;
        }

    } while(bLoopAgain);

    if (ERROR_SUCCESS != lRes)
    {
        CMTRACE1(TEXT("lineGetTranslateCaps returns error code %u."), lRes);
    }
    else
    {
        dwRes = lpTranslateCaps->dwCurrentLocationID;
    }
    CmFree(lpTranslateCaps);
    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Func:    SetCurrentTapiLocation
//
// Desc:    Set the current Tapi location
//
// Args:    TapiLinkageStruct *ptlsTapiLink  - Ptr to TAPI linkage
//          DWORD dwLocation - New location
//
// Return:  DWORD - Error code
//
// Notes:   
//
// History: t-urama     07/21/2000  Created
//-----------------------------------------------------------------------------

DWORD SetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink, DWORD dwLocation)
{
    MYDBGASSERT(ptlsTapiLink->pfnlineSetCurrentLocation);
    if (!ptlsTapiLink->pfnlineSetCurrentLocation)
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return (-1);
    }

    DWORD dwRes = 0;
    dwRes = ptlsTapiLink->pfnlineSetCurrentLocation(ptlsTapiLink->hlaLine, dwLocation);

    CMTRACE1(TEXT("SetCurrentTapiLocation -- setting TAPI location to %d"), dwLocation);

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Func:    RestoreOldTapiLocation
//
// Desc:    Restore the Tapi location to the one when CM was started
//
// Args:    TapiLinkageStruct *ptlsTapiLink  - IN, Ptr to TAPI linkage
//
// Return:  Nothing
//
// Notes:   
//
// History: t-urama     07/21/2000  Created
//-----------------------------------------------------------------------------
                                                     
void RestoreOldTapiLocation(TapiLinkageStruct *ptlsTapiLink)
{
    if (ptlsTapiLink->dwOldTapiLocation != ptlsTapiLink->dwTapiLocationForAccessPoint)
    {
        CMTRACE1(TEXT("RestoreOldTapiLocation -- setting TAPI location to %d"), ptlsTapiLink->dwOldTapiLocation);
        MYVERIFY (0 == SetCurrentTapiLocation(ptlsTapiLink, ptlsTapiLink->dwOldTapiLocation));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\state.h ===
//+----------------------------------------------------------------------------
//
// File:     state.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Dialing states definition
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb	Created Header	08/16/99
//
//+----------------------------------------------------------------------------

#ifndef __STATE_H_DEFINED__
#define __STATE_H_DEFINED__

#ifndef _PROGSTATE_ENUMERATION
#define _PROGSTATE_ENUMERATION
typedef enum _ProgState {
        PS_Interactive=0,		  // interactive with user
        PS_Dialing,				  // dialing primary number
        PS_RedialFrame,			  // Redialing, for future flash frame# only, not a state
        PS_Pausing,				  // waiting to re-dial
        PS_Authenticating,		  // authenticating user-password
        PS_Online,				  // connected/on-line
		PS_TunnelDialing,		  // start to dial up tunnel server
		PS_TunnelAuthenticating,  // start authentication for tunnel connection
		PS_TunnelOnline,		  // we're now online for tunneling
		PS_Error,					// Error while attempting to connect
        PS_Last
} ProgState;

const int NUMSTATES = PS_Last;

#endif // _PROGSTATE_ENUMERATION
#endif // __STATE_H_DEFINED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\userinfo.cpp ===
//+----------------------------------------------------------------------------
//
// File:     userinfo.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the code that handles getting/saving user info.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt     created         02/??/98
//           quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cmuufns.h"

#include "pwd_str.h"
#include "userinfo_str.h"
#include "conact_str.h"

///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////

//
// CM_MAX_PWD - Maximum possible size of password dataencrypted or otherwise.
//              Includes inbound buffer size + room for encryption expansion.
//

const DWORD CM_MAX_PWD = PWLEN * 3; // 2.73 would be enough

//
// Define this if you want to test userinfo upgrade! You should also delete the key
// HKEY_CURRENT_USER\Software\Microsoft\Connection Manager\UserInfo\<Service Name>
//
//#define TEST_USERINFO_UPGRADE 1

#define CACHE_KEY_LEN 80 // Don't change unless you've read every comment regarding it

//
// Suffix for CacheEntry name used on Legacy and W9x. Note: the space is not a typo

const TCHAR* const c_pszCacheEntryNameSuffix = TEXT(" (Connection Manager)"); 

///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
// func prototypes
///////////////////////////////////////////////////////////////////////////////////

////////////////



BOOL WriteDataToReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    CONST BYTE *lpData, 
    DWORD cbData,
    BOOL fAllUser);


BOOL ReadDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    LPDWORD lpdwType, 
    BYTE *lpData, 
    LPDWORD lpcbData,
    BOOL fAllUser);

LPBYTE GetDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    DWORD dwSize,
    BOOL fAllUser);

BOOL DeleteDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID,
    BOOL fAllUser);

BOOL DeleteUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiEntry);

BOOL ReadPasswordFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    LPTSTR      *ppszPassword);

LPCTSTR TranslateUserDataID(
    UINT uiDataID);

BOOL ReadUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData);

BOOL DeleteUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry);

DWORD RasSetCredsWrapper(
    ArgsStruct *pArgs, 
    LPCTSTR pszPhoneBook, 
    DWORD dwMask, 
    LPCTSTR pszData);

int WriteUserInfoToRas(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData);

int DeleteUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry);

DWORD RasGetCredsWrapper(
    ArgsStruct *pArgs,
    LPCTSTR pszPhoneBook,
    DWORD dwMask,
    PVOID *ppvData);

BOOL ReadUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData);

///////////////

BOOL ReadStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName,
    LPTSTR      *ppszStr
);

BOOL DeleteStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName
);

LPTSTR GetLegacyKeyName(ArgsStruct *pArgs);

LPTSTR EncryptPassword(
    ArgsStruct *pArgs, 
    LPCTSTR pszPassword, 
    LPDWORD lpdwBufSize, 
    LPDWORD lpdwCryptType,
    BOOL fReg,
    LPSTR pszSubKey);

LPBYTE DecryptPassword(
    ArgsStruct *pArgs, 
    LPBYTE pszEncryptedData, 
    DWORD dwEncryptionType,
    DWORD dwEncryptedBytes,
    BOOL /*fReg*/,
    LPSTR pszSubKey);

LPTSTR BuildUserInfoSubKey(
    LPCTSTR pszServiceKey, 
    BOOL fAllUser);

///////////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////////

#ifdef TEST_USERINFO_UPGRADE

//+---------------------------------------------------------------------------
//
//  Function:   WriteStringToCache
//
//  Synopsis:   Write a null terminated password string to cache.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszEntryName    name to identify the cache entry
//              pszStr          the string
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL WriteStringToCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName,
    LPTSTR      pszStr)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEntryName && *pszEntryName);
    MYDBGASSERT(pszStr && *pszStr);
    
    DWORD dwRes = ERROR_SUCCESS;

    //
    // In the legacy case, we use mpr.dll for caching user data on W9x.
    // On NT we use the Local Security Authority (LSA)
    //

    if (OS_NT)
    {    
        if (InitLsa(pArgs)) 
        {
            if (!(*ppszStr = (LPTSTR)CmMalloc(dwBufSize)))
            {
                return FALSE;
            }
           
            dwRes = LSA_WriteString(pArgs, pszEntryName, pszStr);
            DeInitLsa(pArgs);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        //
        // for Windows95
        //
        HINSTANCE hInst = NULL;
        WORD (WINAPI *pfnFunc)(LPSTR,WORD,LPSTR,WORD,BYTE,UINT) = NULL;
    
        //
        // Load MPR for system password cache support 
        //

        MYVERIFY(hInst = LoadLibraryExA("mpr.dll", NULL, 0));
        
        if (hInst) 
        {
            //
            // Get function ptr for WNetCachePassword API and cache the password
            //

            MYVERIFY(pfnFunc = (WORD (WINAPI *)(LPSTR,WORD,LPSTR,WORD,BYTE,UINT)) 
                GetProcAddress(hInst, "WNetCachePassword"));
            
            if (pfnFunc) 
            {
                //
                //  Convert the EntryName and Password Strings to Ansi
                //

                LPSTR pszAnsiEntryName = WzToSzWithAlloc(pszEntryName);
                LPSTR pszAnsiStr = WzToSzWithAlloc(pszStr);

                if (pszAnsiStr && pszAnsiEntryName)
                {
                    //
                    // Store the password
                    //

                    dwRes = pfnFunc(pszAnsiEntryName,
                                    (WORD)lstrlenA(pszAnsiEntryName),
                                    pszAnsiStr,
                                    (WORD)lstrlenA(pszAnsiStr),
                                    CACHE_KEY_LEN,
                                    0);                
                }
                else
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }

                CmFree(pszAnsiStr);
                CmFree(pszAnsiEntryName);
            }
            else
            {
                dwRes = GetLastError();
            }

            FreeLibrary(hInst);
        }
        else
        {
            dwRes = GetLastError();
        }
    }

#ifdef DEBUG
    if (dwRes)
    {
        CMTRACE1(TEXT("WriteStringToCache() failed, err=%u."), dwRes);
    }
#endif

    return (ERROR_SUCCESS == dwRes);
}

#endif //TEST_USERINFO_UPGRADE



//+----------------------------------------------------------------------------
//
// Function:  BuildUserInfoSubKey
//
// Synopsis:  Constructs the appropriate subkey for UserInfo based on the service
//            name key and the user mode of the profile.
//
// Arguments: LPCTSTR pszServiceKey - The service name key
//            BOOL fAllUser         - Flag indicating that profile is All-User
//
// Returns:   LPTSTR - Ptr to allocated buffer containing subkey or NULL on failure.
//
// History:   nickball    Created    8/14/98
//
//+----------------------------------------------------------------------------
LPTSTR BuildUserInfoSubKey(LPCTSTR pszServiceKey, BOOL fAllUser)
{
    MYDBGASSERT(pszServiceKey);

    if (NULL == pszServiceKey)
    {
        return NULL;
    }

    //
    // Use the appropriate base key
    // 
    
    LPTSTR pszSubKey = NULL;

    if (fAllUser)
    {
        pszSubKey = CmStrCpyAlloc(c_pszRegCmUserInfo);       
    }
    else
    {
        pszSubKey = CmStrCpyAlloc(c_pszRegCmSingleUserInfo);          
    }

    MYDBGASSERT(pszSubKey);

    //
    // Append profile service name
    //

    if (pszSubKey && *pszSubKey)
    {
        pszSubKey = CmStrCatAlloc(&pszSubKey, pszServiceKey);  
        MYDBGASSERT(pszSubKey);

        return pszSubKey;
    }

    CmFree(pszSubKey);

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  BuildICSDataInfoSubKey
//
// Synopsis:  Constructs the appropriate subkey for ICS UserInfo based on the service
//            name key.
//
// Arguments: LPCTSTR pszServiceKey - The service name key
//
// Returns:   LPTSTR - Ptr to allocated buffer containing subkey or NULL on failure.
//
// History:   03/30/2001    tomkel      Created
//
//+----------------------------------------------------------------------------
LPTSTR BuildICSDataInfoSubKey(LPCTSTR pszServiceKey)
{
    MYDBGASSERT(pszServiceKey);

    if (NULL == pszServiceKey)
    {
        return NULL;
    }

    //
    // Use the appropriate base key
    // 
    
    LPTSTR pszSubKey = NULL;

    pszSubKey = CmStrCpyAlloc(c_pszRegCmRoot);       

    MYDBGASSERT(pszSubKey);

    //
    // Append profile service name
    //

    if (pszSubKey && *pszSubKey)
    {
        pszSubKey = CmStrCatAlloc(&pszSubKey, pszServiceKey);  
       
        MYDBGASSERT(pszSubKey);

        if (pszSubKey)
        {
            CmStrCatAlloc(&pszSubKey, TEXT("\\"));
            if (pszSubKey)
            {
                CmStrCatAlloc(&pszSubKey, c_pszCmRegKeyICSDataKey);
            }
        }

        return pszSubKey;
    }

    CmFree(pszSubKey);

    return NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  dwGetWNetCachedPassword
//
// Synopsis:  Wrapper to encapsulate linking to MPR.DLL and calling GetWNetCac
//            hedPassword.
//
// Arguments: LPSTR pszEntryName - The names of the key used to identify the password.
//            LPSTR* ppszStr - The buffer to receive the retrieved password.
//            WORD* pwSizeOfStr - The size of the input buffer. Also receives 
//                                of the # of chars retrieved.
//
// Returns:   DWORD - Windows error code.
//
// History:   nickball    Created Header    6/17/99
//
//+----------------------------------------------------------------------------

DWORD dwGetWNetCachedPassword(LPSTR pszEntryName, LPSTR* ppszStr, WORD* pwSizeOfStr)
{
    MYDBGASSERT(OS_W9X);

    DWORD dwRes = ERROR_SUCCESS;
    WORD (WINAPI *pfnFunc)(LPSTR,WORD,LPSTR,LPWORD,BYTE) = NULL;
    HINSTANCE hInst = NULL;

    //
    // Load MPR for system password cache support 
    //

    MYVERIFY(hInst = LoadLibraryExA("mpr.dll", NULL, 0));
    
    if (hInst) 
    {
        //
        // Get function ptr for WNetGetCachedPassword API and retrieve the string
        //

        MYVERIFY(pfnFunc = (WORD (WINAPI *)(LPSTR,WORD,LPSTR,LPWORD,BYTE)) 
            GetProcAddress(hInst, "WNetGetCachedPassword"));

        //
        // Read the cache data
        //

        if (pfnFunc) 
        {
            //
            // NOTE: Final param must be CACHE_KEY_LEN (80), no docs to indicate 
            // exact usage of API but retrieval is tied to the value used when
            // storing the pwd. Thus we hard code to CACHE_KEY_LEN because this 
            // is the value that was used by the original version that stored 
            // the password in the 9X cache. The receiving buffer size is 
            // retained at 256 to minimize delta from latest shipping version. 
            //
            // NT# 355459 - nickball - 6/17/99
            //            
            
            dwRes = pfnFunc(pszEntryName, (WORD)lstrlenA(pszEntryName),
                            *ppszStr, pwSizeOfStr, CACHE_KEY_LEN);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        dwRes = GetLastError();
    }

    if (NULL != hInst)                      
    {
        FreeLibrary(hInst);    
    }

    return (dwRes);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadStringFromCache
//
//  Synopsis:   Read a null terminated string from cache.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszEntryName    name to identify the cache entry
//              ppszStr         ptr to the ptr of the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName,
    LPTSTR      *ppszStr
)
{
    DWORD   dwRes = ERROR_SUCCESS;
    
    //
    // Alloc buffer - the buffer is uuencoded.  See UserInfoToString().
    //
    
    WORD wBufSize = 256; // arbitrary, we used to use 80 on W95 

    //
    // On NT, we use the Local Security Authority (LSA) services for reading
    // the string in the legacy case. On Win9x, we uses mpr.dll. 
    // Note: wBufSize is used as an in\out param, can be modified below.
    //

    if (OS_NT) 
    {
        if (InitLsa(pArgs))
        {
            if (!(*ppszStr = (LPTSTR)CmMalloc(wBufSize)))
            {
                return FALSE;
            }

            dwRes = LSA_ReadString(pArgs, pszEntryName, *ppszStr, wBufSize);
            DeInitLsa(pArgs);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        //
        // for Windows95
        //

        LPSTR pszAnsiStr = (LPSTR)CmMalloc(wBufSize);
        LPSTR pszAnsiEntryName = WzToSzWithAlloc(pszEntryName);
        
        if (pszAnsiStr && pszAnsiEntryName)
        {
            dwRes = dwGetWNetCachedPassword(pszAnsiEntryName, &pszAnsiStr, &wBufSize);

            if (ERROR_SUCCESS == dwRes)
            {
                *ppszStr = SzToWzWithAlloc(pszAnsiStr);
                if (NULL == *ppszStr)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }

        CmFree (pszAnsiStr);
        CmFree (pszAnsiEntryName);
    }

    if (dwRes)
    {
        CmFree(*ppszStr);
        *ppszStr = NULL;
        CMTRACE1(TEXT("ReadStringFromCache() failed, err=%u."), dwRes);
    }

    return (ERROR_SUCCESS == dwRes);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteStringFromCache
//
//  Synopsis:   Delete the string from cache.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszEntryName    name to identify the cache entry
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName
)
{
    DWORD   dwRes;

    //
    // on NT, we use the Local Security Authority (LSA) services for storing
    // the string.  On Win95, we use mpr.dll.
    //
    if (OS_NT) 
    {
        if (InitLsa(pArgs)) 
        {
            dwRes = LSA_WriteString(pArgs, pszEntryName, NULL);
            DeInitLsa(pArgs);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        //
        // for Windows95
        //
        HINSTANCE   hInst = NULL;
        WORD (WINAPI *pfnFunc)(LPSTR,WORD,BYTE) = NULL;

        // Load MPR for system password cache support 
        
        MYVERIFY(hInst = LoadLibraryExA("mpr.dll", NULL, 0));
        
        // Get function ptr for WNetRemoveCachedPassword API and remove the string
        
        if (!hInst) 
        {
            return FALSE;
        }

        MYVERIFY(pfnFunc = (WORD (WINAPI *)(LPSTR,WORD,BYTE)) 
            GetProcAddress(hInst, "WNetRemoveCachedPassword"));

        if (!pfnFunc) 
        {
            FreeLibrary(hInst);
            return FALSE;
        }
       
        LPSTR pszAnsiEntryName = WzToSzWithAlloc(pszEntryName);
        
        if (pszAnsiEntryName)
        {
            dwRes = pfnFunc(pszAnsiEntryName, (WORD)lstrlenA(pszAnsiEntryName), CACHE_KEY_LEN);
        }
        else
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
        }

        CmFree (pszAnsiEntryName);

        FreeLibrary(hInst);
    }

#ifdef DEBUG
    if (dwRes)
    {
        CMTRACE1(TEXT("DeleteStringFromCache() LSA_WriteString/WNetRemoveCachedPassword() failed, err=%u."), dwRes);
    }
#endif

    return (ERROR_SUCCESS == dwRes);
}

//+---------------------------------------------------------------------------
//
//  Function:   RasSetCredsWrapper
//
//  Synopsis:   Wrapper to call RasSetCredential.  This function stores the
//              given string in the appropriate field of a RASCREDENTIALS struct
//              (based on the value in dwMask) and calls RasSetCredentials.
//               
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszPhoneBook    Full path to the phonebook file, or NULL for 
//                              the default all user pbk
//              dwMask          dwMask value to set in the RASCREDENTIALS
//                              struct.  Currently must be one of RASCM_UserName, 
//                              RASCM_Domain, or RASCM_Password.
//              pszData         string data to set
//
//  Returns:    DWORD   ERROR_SUCCESS if successful, a windows error code otherwise
//
//----------------------------------------------------------------------------
DWORD RasSetCredsWrapper(
    ArgsStruct *pArgs,
    LPCTSTR pszPhoneBook,
    DWORD dwMask,
    LPCTSTR pszData
)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    BOOL fSavePassword = TRUE;

    MYDBGASSERT(pArgs && pArgs->rlsRasLink.pfnSetCredentials);
    MYDBGASSERT(pszData);
    MYDBGASSERT((RASCM_UserName == dwMask) || (RASCM_Domain == dwMask) || (RASCM_Password == dwMask));

    if (pArgs && pszData && pArgs->rlsRasLink.pfnSetCredentials)
    {
        LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);

        if (pszConnectoid)
        {
            RASCREDENTIALS RasCredentials = {0};
            RasCredentials.dwSize = sizeof(RasCredentials);
            
            if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
            {
                RasCredentials.dwMask = dwMask | RASCM_DefaultCreds; 
            }
            else
            {
                RasCredentials.dwMask = dwMask; 
            }
            
            BOOL bClearPassword = FALSE;

            if (RASCM_UserName == dwMask)
            {
                lstrcpyU(RasCredentials.szUserName, pszData);
            }
            else if (RASCM_Domain == dwMask)
            {
                lstrcpyU(RasCredentials.szDomain, pszData);
            }
            else if (RASCM_Password == dwMask)
            {
                if (0 == lstrcmpU(c_pszSavedPasswordToken, pszData))
                {
                    //
                    // We have 16 *'s. This password is from the RAS cred store, 
                    // so we don't want to save the 16 *'s 
                    //
                    fSavePassword = FALSE;
                    dwRet = ERROR_SUCCESS;
                }
                else
                {
                    lstrcpyU(RasCredentials.szPassword, pszData);
                    bClearPassword = (TEXT('\0') == pszData[0]);
                }
            }
            else
            {
                CmFree(pszConnectoid);
                return ERROR_INVALID_PARAMETER;
            }

            if (fSavePassword)
            {
                dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &RasCredentials, bClearPassword);

                if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwRet)
                {
                    //
                    //  Then the phonebook entry doesn't exist yet, lets create it.
                    //
                    LPRASENTRY pRasEntry = (LPRASENTRY)CmMalloc(sizeof(RASENTRY));

                    if (pRasEntry && pArgs->rlsRasLink.pfnSetEntryProperties)
                    {
                        pRasEntry->dwSize = sizeof(RASENTRY);
                        dwRet = pArgs->rlsRasLink.pfnSetEntryProperties(pszPhoneBook, pszConnectoid, pRasEntry, pRasEntry->dwSize, NULL, 0);

                        //
                        //  Lets try to set the credentials one more time ...
                        //
                        if (ERROR_SUCCESS == dwRet)
                        {
                            dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &RasCredentials, bClearPassword);
                        }

                        CmFree(pRasEntry);
                    }
                }
            }
            CmWipePassword(RasCredentials.szPassword);
            CmFree(pszConnectoid);
        }
    }

    return dwRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteUserInfoToRas
//
//  Synopsis:   Write a userinfo data to ras credential storage
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiDataID        the resource ID associated with the data
//              pvData          userinfo data
//
//  Returns:    int    TRUE = success, FALSE = failure, returns -1 if RAS
//                     doesn't cache this piece of data and it should be put
//                     in the registry instead.
//
//----------------------------------------------------------------------------
int WriteUserInfoToRas(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData)
{
    int iReturn = -1;

    if (OS_NT5 && pArgs && pArgs->bUseRasCredStore)
    {
        DWORD dwMask;
        LPTSTR pszPhoneBook = NULL;

        switch (uiDataID)
        {
            case UD_ID_USERNAME:
                dwMask = RASCM_UserName;
                iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, (LPCTSTR)pvData));
                break;

            case UD_ID_PASSWORD:
                dwMask = RASCM_Password;
                iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, (LPCTSTR)pvData));
                MYDBGASSERT(iReturn);

                //
                //  Note that if we are using the same username then we want to write the password to both the
                //  password and the InetPassword storage.  This is because we don't actually have a password, just
                //  16 *'s.  This tells RAS to look in its internal store for the password.  The trouble is that if
                //  we don't cache the real password when we hand RAS the 16 *'s, it looks and finds a NULL password.
                //  Thus we keep both passwords the same and this avoids that problem.
                //
                if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseSameUserName))
                {
                    pszPhoneBook = CreateRasPrivatePbk(pArgs);

                    if (pszPhoneBook)
                    {
                        iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pszPhoneBook, dwMask, (LPCTSTR)pvData));
                        CmFree(pszPhoneBook);
                    }                
                }

                break;

            case UD_ID_DOMAIN:
                dwMask = RASCM_Domain;
                iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, (LPCTSTR)pvData));
                break;

            case UD_ID_INET_PASSWORD:
                dwMask = RASCM_Password;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pszPhoneBook, dwMask, (LPCTSTR)pvData));
                    CmFree(pszPhoneBook);
                }
                break;

            case UD_ID_INET_USERNAME:
                dwMask = RASCM_UserName;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pszPhoneBook, dwMask, (LPCTSTR)pvData));
                    CmFree(pszPhoneBook);
                }
                break;

            default:
                break;
        }
    }

    if ((0 != iReturn) && (-1 != iReturn))
    {
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            CMTRACE1(TEXT("WriteUserInfoToRas() - %s saved to the Global RAS Credential store"), TranslateUserDataID(uiDataID));
        }
        else
        {
            CMTRACE1(TEXT("WriteUserInfoToRas() - %s saved to the User RAS Credential store"), TranslateUserDataID(uiDataID));
        }
    }

    return iReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteUserInfoToReg
//
//  Synopsis:   Write a userinfo data to the registry.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiDataID        the resource ID associated with the data
//              pvData          userinfo data
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL WriteUserInfoToReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData)
{
    MYDBGASSERT(pArgs);    
    MYDBGASSERT(pvData);    

    BOOL fRet = FALSE;
    UINT uiID = uiDataID; // can be changed in switch
    BYTE *lpData;

    if (NULL == pArgs || NULL == pvData)
    {
        return FALSE;
    }

    //
    // Determine Reg params based upon uiDataID
    //

    switch (uiID)
    {
        case UD_ID_USERNAME:
        case UD_ID_INET_USERNAME:
        case UD_ID_DOMAIN:
        case UD_ID_CURRENTACCESSPOINT:
        {    
            //
            // Store as strings
            //
                      
            DWORD dwSize = (lstrlenU((LPTSTR)pvData) + 1) * sizeof(TCHAR);            
            
            MYDBGASSERT(dwSize <= (UNLEN + sizeof(TCHAR))); // Make sure size is reasonable

            lpData = (BYTE *) pvData;

            fRet = WriteDataToReg(pArgs->szServiceName, uiID, REG_SZ, lpData, dwSize, pArgs->fAllUser);                
            break;
        }

        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:
        {
            DWORD dwBufLen = 0;
            DWORD dwCrypt = 0;
            LPTSTR pszSubKey = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
            
            LPSTR pszAnsiSubKey = WzToSzWithAlloc(pszSubKey);
            
            if (UD_ID_INET_PASSWORD == uiID)
            {
                dwCrypt |= CMSECURE_ET_USE_SECOND_RND_KEY;
            }

            //
            // Encrypt
            //
            
            LPTSTR pszEncryptedData = EncryptPassword(pArgs, (LPTSTR) pvData, &dwBufLen, &dwCrypt, TRUE, pszAnsiSubKey);
            
            //
            // Free in case we return if the function failed
            //
            CmFree(pszSubKey);
            CmFree(pszAnsiSubKey);

            if (!pszEncryptedData)
            {
                return FALSE;
            }

            MYDBGASSERT(dwBufLen <= CM_MAX_PWD); // Can't read it out otherwise
            
            //
            // Write the password and the encryption type on success
            //
        
            if (WriteDataToReg(pArgs->szServiceName, uiID, REG_BINARY, (BYTE *) pszEncryptedData, dwBufLen, pArgs->fAllUser))                
            {
                //
                // A second write for the encryption type. Written as a DWORD.
                //

                uiID = UD_ID_PCS;           
                
                //
                // Now that we're UNICODE enabled, we will always be encrypting 
                // a UNICODE string, so update the crypt type, so that it can be
                // properly decrypted.
                //
                
                dwCrypt = AnsiToUnicodePcs(dwCrypt);
                
                lpData = (BYTE *) &dwCrypt;
            
                fRet = WriteDataToReg(pArgs->szServiceName, uiID, REG_DWORD, lpData, sizeof(DWORD), pArgs->fAllUser);                
            }

            // 
            // Release the buffer before we go
            // 
            
            CmFree(pszEncryptedData);

            
            break;
        }
        
        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
        case UD_ID_ACCESSPOINTENABLED:
        {            
            //
            // Store BOOL as DWORD
            //

            DWORD dwTmp = *(LPBOOL)pvData;            
            lpData = (BYTE *) &dwTmp;

            fRet = WriteDataToReg(pArgs->szServiceName, uiID, REG_DWORD, lpData, sizeof(DWORD), pArgs->fAllUser);                
            break;
        }

        default:
            break;
    }

    MYDBGASSERT(fRet);
    return fRet;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteDataToReg
//
// Synopsis:  Stores the specified data as the specifed value under the 
//            specified key under the userinfo root.
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            DWORD dwType - The registry data type
//            CONST BYTE *lpData - Ptr to the data to be stored
//            DWORD cbData - The size of the data buffer
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   BOOL - TRUE on success, otherwise FALSE
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
BOOL WriteDataToReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    CONST BYTE *lpData, 
    DWORD cbData,
    BOOL fAllUser)
{
    MYDBGASSERT(pszKey && *pszKey);
    MYDBGASSERT(lpData);

    HKEY    hKeyCm;
    DWORD   dwDisposition;
    DWORD   dwRes = 1;
    LPTSTR  pszSubKey; 

    if (NULL == pszKey || !*pszKey || NULL == lpData)
    {
        return FALSE;
    }
                  
    //
    // Per-user data is always stored under HKEY_CURRENT_USER
    // Build the sub key to be opened.
    //

    pszSubKey = BuildUserInfoSubKey(pszKey, fAllUser);

    if (NULL == pszSubKey)
    {
        return FALSE;
    }
    
    //
    // Open the sub key under HKCU
    //
    
    dwRes = RegCreateKeyExU(HKEY_CURRENT_USER,
                            pszSubKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE,
                            NULL,
                            &hKeyCm,
                            &dwDisposition);

    //
    // If we opened the key successfully, write the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegSetValueExU(hKeyCm, 
                               TranslateUserDataID(uiDataID), 
                               NULL, 
                               dwType,
                               lpData, 
                               cbData);             
#ifdef DEBUG
        if (ERROR_SUCCESS == dwRes)
        {
            CMTRACE1(TEXT("WriteDataToReg() - %s written to registry"), TranslateUserDataID(uiDataID));
        }
#endif
        
        RegCloseKey(hKeyCm);
    }

    CmFree(pszSubKey);

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  DeleteDataFromReg
//
// Synopsis:  Deletes the specified value under the specified by uiDataID
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   BOOL - TRUE on success, otherwise FALSE
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
BOOL DeleteDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID,
    BOOL fAllUser)
{
    MYDBGASSERT(pszKey && *pszKey);

    HKEY    hKeyCm;
    DWORD   dwRes = 1;
    LPTSTR  pszSubKey; 

    if (NULL == pszKey || !*pszKey)
    {
        return FALSE;
    }
                  
    //
    // Per-user data is always stored under HKEY_CURRENT_USER
    // Build the sub key to be opened.
    //

    pszSubKey = BuildUserInfoSubKey(pszKey, fAllUser);

    if (NULL == pszSubKey)
    {
        return FALSE;
    }
    
    //
    // Open the sub key under HKCU
    //

    dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszSubKey,
                          0,
                          KEY_SET_VALUE,
                          &hKeyCm);
       
    //
    // If we opened the key successfully, delete the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegDeleteValueU(hKeyCm, TranslateUserDataID(uiDataID));

        //
        // Delete the key used for encrypting the passwords
        //
        if (UD_ID_PASSWORD == uiDataID)
        {
            dwRes = RegDeleteValueU(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey);
        }

        if (UD_ID_INET_PASSWORD == uiDataID)
        {
            dwRes = RegDeleteValueU(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey);
        }

#ifdef DEBUG
        if (ERROR_SUCCESS == dwRes)
        {
            CMTRACE1(TEXT("DeleteDataFromReg() - %s removed from registry"), TranslateUserDataID(uiDataID));
        }
#endif
                
        RegCloseKey(hKeyCm);
    }

    CmFree(pszSubKey);

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  GetDataFromReg
//
// Synopsis:  Allocates a buffer for and retrieves the specifed data from the
//            registry.
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            DWORD dwType - The registry data type 
//            DWORD dwSize - Numbrt of bytes in the data buffer
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   LPBYTE - Ptr to retrieved data, NULL on error
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
LPBYTE GetDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    DWORD dwSize,
    BOOL fAllUser)
{    
    MYDBGASSERT(pszKey);

    DWORD dwSizeTmp = dwSize;
    DWORD dwTypeTmp = dwType;

    if (NULL == pszKey || !*pszKey)
    {
        return NULL;
    }

    //
    // Allocate a buffer of the desired size
    //

    LPBYTE lpData = (BYTE *) CmMalloc(dwSize);

    if (NULL == lpData)
    {
        return FALSE;
    }

    //
    // Read the data from the registry
    //

    if (!ReadDataFromReg(pszKey, uiDataID, &dwTypeTmp, lpData, &dwSizeTmp, fAllUser))
    {
        CmFree(lpData);
        lpData = NULL;
    }

    return lpData;
}
//+---------------------------------------------------------------------------
//
//  Function:   ReadUserInfoFromReg
//
//  Synopsis:   Read the specified userinfo data from the registry.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiDataID        the resource ID associated with the data
//              ppvData         ptr to ptr to be allocated and filled
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       *ppvData)
{
    MYDBGASSERT(pArgs);    
    MYDBGASSERT(ppvData);    

    BYTE *lpData = NULL;

    if (NULL == pArgs || NULL == ppvData)
    {
        return FALSE;
    }

    //
    // Set size and type as appropriate
    //

    switch (uiDataID)
    {
        case UD_ID_USERNAME:
        case UD_ID_INET_USERNAME:
        case UD_ID_DOMAIN: 
        case UD_ID_CURRENTACCESSPOINT:
        {    
            lpData =  GetDataFromReg(pArgs->szServiceName, uiDataID, REG_SZ, (UNLEN + 1) * sizeof(TCHAR), pArgs->fAllUser);           
            
            if (lpData)
            {
                *ppvData = lpData;            
            }
            
            break;
        }

        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:            
        {    
            BYTE *lpTmp = NULL;

            //
            // Get the encryption type 
            //

            lpData = GetDataFromReg(pArgs->szServiceName, UD_ID_PCS, REG_DWORD, sizeof(DWORD), pArgs->fAllUser);

            if (!lpData)
            {
                return FALSE;
            }
            
            //
            // Since we know the return value in this case is a DWORD, then cast it to DWORD pointer 
            // and get the value
            //
            DWORD dwCrypt = *((DWORD*)lpData);
            CmFree(lpData);    

            //
            // Now retrieve the encrypted password
            //
            
            lpData = GetDataFromReg(pArgs->szServiceName, uiDataID, REG_BINARY, CM_MAX_PWD, pArgs->fAllUser);

            if (!lpData)
            {
                return FALSE;
            }

            //
            // Decrypt it
            //

            DWORD dwSize = lstrlenU((LPTSTR)lpData)*sizeof(TCHAR);

            //
            // Crypt routines only know about Ansi PCS values, so convert as necessary
            //
            LPTSTR pszSubKey = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);           
            LPSTR pszAnsiSubKey = WzToSzWithAlloc(pszSubKey);

            if (UD_ID_INET_PASSWORD == uiDataID)
            {
                dwCrypt |= CMSECURE_ET_USE_SECOND_RND_KEY;
            }

            lpTmp = DecryptPassword(pArgs, (LPBYTE)lpData, UnicodeToAnsiPcs(dwCrypt), dwSize, TRUE, pszAnsiSubKey);

            //
            // Free the buffer for the reg query
            //

            CmFree(lpData);         
            
            //
            // We're Unicode now, so if the password was encrypted 
            // as an Ansi string convert the data to a UNICODE string.
            // Otherwise, just update the supplied buffer.
            //

            if (IsAnsiPcs(dwCrypt) && lpTmp)
            {
                *ppvData = SzToWzWithAlloc((LPSTR)lpTmp);
                CmFree(lpTmp);
            }
            else
            {
                *ppvData = lpTmp;            
            }

            //
            // Assign lpData for return purposes
            //

            lpData = (BYTE*) *ppvData;  // NULL on failure
            
            CmFree(pszSubKey);
            CmFree(pszAnsiSubKey);
            break;
        }

        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
        case UD_ID_ACCESSPOINTENABLED:
        {            
            lpData =  GetDataFromReg(pArgs->szServiceName, uiDataID, REG_DWORD, sizeof(DWORD), pArgs->fAllUser);

            if (lpData)
            {
                //
                // Translate to DWORD pointer and check the value
                //

                if (*((DWORD*)lpData))
                {
                    *(BOOL *)*ppvData = TRUE;
                }
                else
                {
                    *(BOOL *)*ppvData = FALSE;
                }
            
                CmFree(lpData);            
            }
            
            break;
        }

        default:
            MYDBGASSERT(FALSE);
            return FALSE;
    }           

    return (NULL != lpData); 
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDataFromReg
//
// Synopsis:  Retrieves the data from the specifed value under the 
//            specified key under the userinfo root.
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            LPDWORD lpdwType - The registry data type expected, and returned
//            CONST BYTE *lpData - Ptr to buffer for data
//            LPDWORD lpcbData - The size of the data buffer
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   BOOL - TRUE on success, otherwise FALSE
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
BOOL ReadDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    LPDWORD lpdwType, 
    BYTE *lpData, 
    LPDWORD lpcbData,
    BOOL fAllUser)
{   
    MYDBGASSERT(pszKey && *pszKey);
    MYDBGASSERT(lpData);
    MYDBGASSERT(lpcbData);
    MYDBGASSERT(lpdwType);

    HKEY    hKeyCm;
    DWORD   dwRes = 1;
    DWORD   dwTypeTmp; // the value returned by query

    LPTSTR  pszSubKey; 

    if (NULL == pszKey || !*pszKey || NULL == lpData)
    {
        return FALSE;
    }
                  
    //
    // Per-user data is always stored under HKEY_CURRENT_USER
    // Build the sub key to be opened.
    //

    pszSubKey = BuildUserInfoSubKey(pszKey, fAllUser);

    if (NULL == pszSubKey)
    {
        return FALSE;
    }
    
    //
    // Open the sub key under HKCU
    //
    
    dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszSubKey,
                          0,
                          KEY_QUERY_VALUE,
                          &hKeyCm);
    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegQueryValueExU(hKeyCm, 
                                 TranslateUserDataID(uiDataID),
                                 NULL,
                                 &dwTypeTmp,
                                 lpData, 
                                 lpcbData);        
        
        if (ERROR_SUCCESS == dwRes)
        {
            CMTRACE1(TEXT("ReadDataFromReg() - %s read from registry"), TranslateUserDataID(uiDataID));
            MYDBGASSERT(*lpdwType == dwTypeTmp);

            if (*lpdwType == dwTypeTmp)
            {
                *lpdwType = dwTypeTmp;
            }
        }
        
        RegCloseKey(hKeyCm);
    }

    CmFree(pszSubKey);
    
    return (ERROR_SUCCESS == dwRes && (*lpdwType == dwTypeTmp)); // sanity check that type was expected
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfoFromReg
//
//  Synopsis:   Delete userinfo data from registry
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         cmp field entry id
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiEntry
)
{
    return DeleteDataFromReg(pArgs->szServiceName, uiEntry, pArgs->fAllUser);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfoFromRas
//
//  Synopsis:   Delete userinfo data from the RAS credential cache
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         cmp field entry id
//
//  Returns:    int    TRUE = success, FALSE = failure, -1 if RAS doesn't
//                                                         store this info
//
//----------------------------------------------------------------------------
int DeleteUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry
)
{
    LPTSTR pszEmpty = TEXT("");

    return WriteUserInfoToRas(pArgs, uiEntry, pszEmpty);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadPasswordFromCmp
//
//  Synopsis:   Read a null terminated password string from Cmp.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         cmp entry name
//              ppszPassword    ptr to ptr of the password buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadPasswordFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    LPTSTR      *ppszPassword
)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(ppszPassword);

    if (NULL == pArgs || NULL == ppszPassword)
    {
        return FALSE;
    }

    //
    // Read in password from profile
    //
    
    BOOL fOk = FALSE;

    LPTSTR pszEncryptedData = pArgs->piniProfile->GPPS(c_pszCmSection, TranslateUserDataID(uiEntry));

    if (*pszEncryptedData)
    {
        //
        // Trim away all the spaces at both ends
        //

        CmStrTrim(pszEncryptedData);

        //
        // Get the type and decrypt
        //
        
        DWORD dwEncryptionType = (DWORD)pArgs->piniProfile->GPPI(c_pszCmSection, 
                                                       c_pszCmEntryPcs,
                                                       CMSECURE_ET_RC2);   // default   
        //
        //  Since this was saved in the CMP in Ansi form, we need to convert the characters back to
        //  Ansi form so that we can decrypt them.  We still may not be able to (if we cannot
        //  round trip the Unicode conversion for instance) but then we will fail and display a
        //  blank password.  Not the end of the world but hopefully avoidable.
        //
        
        LPSTR pszAnsiEncryptedData;
        LPSTR pszAnsiUnEncryptedData;

        pszAnsiEncryptedData = WzToSzWithAlloc(pszEncryptedData);
        
        if (NULL != pszAnsiEncryptedData)
        {
            DWORD dwSize = lstrlenA(pszAnsiEncryptedData)*sizeof(TCHAR);
            
            //
            // Here we don't need to differentiate between main password and internet password
            // because we are reading this from a file and the mask is used when reading to/from 
            // registry.
            //

            pszAnsiUnEncryptedData = (LPSTR)DecryptPassword(pArgs, 
                                                            (LPBYTE)pszAnsiEncryptedData, 
                                                            dwEncryptionType, 
                                                            dwSize, 
                                                            FALSE,
                                                            NULL);

            if (pszAnsiUnEncryptedData)
            {
                *ppszPassword = SzToWzWithAlloc(pszAnsiUnEncryptedData);

                if (NULL != *ppszPassword)
                {
                    fOk = ((BOOL)**ppszPassword);
                }
                CmWipePasswordA(pszAnsiUnEncryptedData);
                CmFree(pszAnsiUnEncryptedData);
            }    
        }

        CmFree(pszAnsiEncryptedData);
    }

    CmFree(pszEncryptedData);

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadUserInfoFromCmp
//
//  Synopsis:   Read a userinfo data from cmp.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              ppvData         ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData
)
{   
    switch (uiEntry)
    {
        case UD_ID_USERNAME:
        case UD_ID_INET_USERNAME:
        case UD_ID_DOMAIN:
            *ppvData = (PVOID)pArgs->piniProfile->GPPS(c_pszCmSection, TranslateUserDataID(uiEntry));
            break;

        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:
            return ReadPasswordFromCmp(pArgs, uiEntry, (LPTSTR *)ppvData);
            break;

        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
            *(BOOL *)(*ppvData) = pArgs->piniProfile->GPPB(c_pszCmSection, TranslateUserDataID(uiEntry));
            break;

            //
            //  None of these should be in the CMP by this point.  Return a failure value.
            //
        case UD_ID_PCS:
        case UD_ID_ACCESSPOINTENABLED:
        case UD_ID_CURRENTACCESSPOINT: // if we are trying to read the access point
            CMASSERTMSG(FALSE, TEXT("ReadUserInfoFromCmp -- trying to read a value that should never be in the cmp, why?"));
            *ppvData = NULL;
            return FALSE;
            break;

        default:
            MYDBGASSERT(0);
            break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfoFromCmp
//
//  Synopsis:   Deletes userinfo data from cmp.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry
)
{
    BOOL bReturn = FALSE;
    UINT  uiKeepDefCreds = 0;
    const TCHAR* const c_pszKeepDefaultCredentials = TEXT("KeepDefaultCredentials"); 

    if (NULL == pArgs)
    {
        return bReturn;
    }

    switch (uiEntry)
    {
        case UD_ID_USERNAME:
        case UD_ID_DOMAIN:
        case UD_ID_INET_USERNAME:
        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:

            //
            // Get KeepDefaultCredentials value from CMP
            //
            uiKeepDefCreds = GetPrivateProfileIntU(c_pszCmSection, c_pszKeepDefaultCredentials, 0,
                                                   pArgs->piniProfile->GetFile());

            if (0 == uiKeepDefCreds) 
            {
                if (WritePrivateProfileStringU(c_pszCmSection, TranslateUserDataID(uiEntry), 
                                               NULL, pArgs->piniProfile->GetFile()))
                {
                    bReturn = TRUE;
                }
            }
            break;

        default:
            MYDBGASSERT(0);
            break;

    }
    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasGetCredsWrapper
//
//  Synopsis:   Wrapper function to call RasGetCredentials.  The function
//              calls RasGetCredentials and then copies the appropriate data
//              from the RASCREDENTIALS struct into the buffer pointed to by
//              *ppvData (allocated on the caller behalf).  Note that the value
//              set in dwMask determines which data item is retrieved from the
//              credentials cache.  Currently, dwMask must be one of RASCM_UserName,
//              RASCM_Domain, or RASCM_Password.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszPhoneBook    full path to the phonebook file to get the 
//                              data from, or NULL to use the all user default pbk
//              dwMask          dwMask value for the RASCREDENTIALS struct
//              ppvData         ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    DWORD   ERROR_SUCCESS on success, winerror on failure
//
//----------------------------------------------------------------------------
DWORD RasGetCredsWrapper(
    ArgsStruct *pArgs,
    LPCTSTR pszPhoneBook,
    DWORD dwMask,
    PVOID *ppvData
)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;

    MYDBGASSERT(pArgs && pArgs->rlsRasLink.pfnGetCredentials);
    MYDBGASSERT(ppvData);
    MYDBGASSERT((RASCM_UserName == dwMask) || (RASCM_Domain == dwMask) || (RASCM_Password == dwMask));

    if (pArgs && ppvData && pArgs->rlsRasLink.pfnGetCredentials)
    {
        LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);

        if (pszConnectoid)
        {
            RASCREDENTIALS RasCredentials = {0};
            RasCredentials.dwSize = sizeof(RasCredentials);
            
            if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
            {
                RasCredentials.dwMask = dwMask | RASCM_DefaultCreds;
            }
            else
            {
                RasCredentials.dwMask = dwMask; 
            }
            
            dwRet = pArgs->rlsRasLink.pfnGetCredentials(pszPhoneBook, pszConnectoid, &RasCredentials);

            if (ERROR_SUCCESS == dwRet)
            {
                LPTSTR pszData = NULL;

                if (RASCM_UserName == dwMask)
                {
                    pszData = RasCredentials.szUserName;
                }
                else if (RASCM_Domain == dwMask)
                {
                    pszData = RasCredentials.szDomain;                
                }
                else if (RASCM_Password == dwMask)
                {
                    pszData = RasCredentials.szPassword;
                }

                LPTSTR pszReturn = CmStrCpyAlloc(pszData);

                if (NULL == pszReturn)
                {
                    dwRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    *ppvData = pszReturn;
                }
            }

            CmWipePassword(RasCredentials.szPassword);

            CmFree(pszConnectoid);
        }
    }

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadUserInfoFromRas
//
//  Synopsis:   Read userinfo data from the RAS credentials cache
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              ppvData         ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData
)
{
    BOOL bReturn = FALSE;

    if (OS_NT5 && pArgs && pArgs->bUseRasCredStore)
    {
        DWORD dwMask;
        LPTSTR pszPhoneBook = NULL;

        switch (uiEntry)
        {
            case UD_ID_USERNAME:
                dwMask = RASCM_UserName;
                bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, ppvData));

                break;

            case UD_ID_PASSWORD:
                dwMask = RASCM_Password;
                bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, ppvData));
                break;

            case UD_ID_DOMAIN:
                dwMask = RASCM_Domain;
                bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, ppvData));
                break;

            case UD_ID_INET_PASSWORD:
                dwMask = RASCM_Password;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pszPhoneBook, dwMask, ppvData));
                    CmFree(pszPhoneBook);
                }
                break;

            case UD_ID_INET_USERNAME:
                dwMask = RASCM_UserName;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pszPhoneBook, dwMask, ppvData));
                    CmFree(pszPhoneBook);
                }
                break;
        }
    }

    if (bReturn)
    {
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            CMTRACE1(TEXT("ReadUserInfoFromRas() - %s retrieved from the Global RAS Credential store"), TranslateUserDataID(uiEntry));
        }
        else
        {
            CMTRACE1(TEXT("ReadUserInfoFromRas() - %s retrieved from the User RAS Credential store"), TranslateUserDataID(uiEntry));
        }
    }

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUserInfo
//
//  Synopsis:   Get an userinfo.  The user info can reside in either the
//              cache, cmp, or registry.  This functions hides this from the
//              user.
//
//  We first try the cmp file.  If that fails, we try the cache.
//       We'll get the following user info:
//           username, 
//           password, 
//           domain,
//           remember main passwd,
//           dial automatically,
//           inet username,
//           inet passwd
//           remember inet password
//           inet use same user name
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              pvData          ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL GetUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       *ppvData
)
{
    BOOL bReturn = ReadUserInfoFromRas(pArgs, uiEntry, ppvData);

    if (!bReturn)
    {
        bReturn = ReadUserInfoFromReg(pArgs, uiEntry, ppvData);        
    }

    if (!bReturn)
    {
        bReturn = ReadUserInfoFromCmp(pArgs, uiEntry, ppvData);
    }

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   SaveUserInfo
//
//  Synopsis:   Save an userinfo.  The user info can reside in either the
//              RAS cred cache or the registry.  This functions abstracts
//              this from the user.
//
//  We first try the RAS cred cache.  If the RAS cred cache doesn't hold that
//  piece of info we then save it in the registry.
//       We'll save the following user info:
//           username, 
//           password, 
//           domain,
//           remember main passwd,
//           dial automatically,
//           inet username,
//           inet passwd
//           remember inet password
//           inet use same user name
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              pvData          ptr to the data buffer.  If the userinfo is
//                              multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL SaveUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       pvData
)
{
    //
    //  Try giving the Data to RAS first.  If the function returns
    //  -1, then this is data that RAS doesn't hold for us and we will
    //  have to put it in the registry instead.
    //
    int iReturn = WriteUserInfoToRas(pArgs, uiEntry, pvData);

    if (-1 == iReturn)
    {
        //
        // Just write the data to the registry. Use CMP only as
        // an upgrade reference for UserInfo data post CM 1.1
        //

        iReturn = WriteUserInfoToReg(pArgs, uiEntry, pvData);
    }

    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfo
//
//  Synopsis:   Delete an userinfo.  The user info can reside in either the
//              RAS Cred cache or the registry.  This functions abstracts
//              this from the user.
//
//       We first try the RAS cache first.  If that piece of info isn't stored
//       in the RAS cache then we try the registry.
//
//       We'll delete the following user info:
//           username, 
//           password, 
//           domain,
//           remember main passwd,
//           dial automatically,
//           inet username,
//           inet passwd
//           remember inet password
//           inet use same user name
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry
)
{
    int iReturn = DeleteUserInfoFromRas(pArgs, uiEntry);

    if (-1 == iReturn)
    {
        iReturn = DeleteUserInfoFromReg(pArgs, uiEntry);
    }

    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   NeedToUpgradeUserInfo
//
//  Synopsis:   Do we need to upgrade the cm 1.0/1.1 userinfo to the cm 1.2 format?
// 
//  Arguments:  pArgs - Ptr to global args struct
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
int NeedToUpgradeUserInfo(
    ArgsStruct  *pArgs)
{
    MYDBGASSERT(pArgs);

    DWORD dwRes;
    HKEY hKeyCm;
    LPTSTR pszSubKey;
    int iReturn = c_iNoUpgradeRequired;

    if (pArgs)
    {
        //
        //  If this is NT5 or greater, we want to be storing our credentials with RAS
        //  instead of the registry.  
        //
        //  If this isn't NT5 we still want to upgrade the user to using the registry as 
        //  storage instead of the cmp if they haven't already
        //  been upgraded.  Thus the simple test is to open the service name key in HKCU. 
        //  This key will exist, if the user has already run 1.2 bits.
        //

        pszSubKey = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);

        dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                              pszSubKey,
                              0,
                              KEY_QUERY_VALUE,
                              &hKeyCm);

        if (ERROR_SUCCESS == dwRes)
        {
            //
            //  Then we have the registry method, unless we are supposed to be using the RAS
            //  cred store we are done.  If we are supposed to be using the RAS cred store
            //  we need to check to make sure that we are using it.  Note we could have a problem
            //  here if the user has registry cred data and then their registry gets write protected.
            //  This would allow us to read from it but not delete the old data.  Thus the user
            //  would never be able to save any changes because we would always think they needed
            //  to upgrade.  An unlikely scenario but possible ...
            //

            if (pArgs->bUseRasCredStore)
            {
                LPTSTR pszUserName = NULL;

                BOOL bRet = ReadUserInfoFromReg(pArgs, UD_ID_USERNAME, (PVOID*)&pszUserName);

                if (bRet && (NULL != pszUserName) && (TEXT('\0') != pszUserName[0]))
                {
                    //
                    //  Then we have the username in the registry.  Lets upgrade to the RAS
                    //  credential store.
                    //
                    iReturn = c_iUpgradeFromRegToRas;
                }

                CmFree(pszUserName);
            }

            RegCloseKey(hKeyCm);
        }
        else
        {
            iReturn = c_iUpgradeFromCmp;
        }

        CmFree(pszSubKey);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NeedToUpgradeUserInfo -- NULL pArgs passed"));    
    }

    //
    // We don't want to upgrade if it's ICS. This prevents from adding info to the registry.
    //
    if (CM_LOGON_TYPE_ICS == pArgs->dwWinLogonType)
    {
        iReturn = c_iNoUpgradeRequired;
    }


    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpgradeUserInfoFromRegToRasAndReg
//
//  Synopsis:   Upgrade the userinfo from CM 1.2 registry only format to the
//              CM 1.3 format which uses both RAS credential storage and
//              the registry.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL UpgradeUserInfoFromRegToRasAndReg(
    ArgsStruct  *pArgs
)
{
    BOOL bReturn = FALSE;

    if (OS_NT5)
    {
        LPTSTR pszTmp;

        pszTmp = NULL;

        //
        // If we get an empty string "" from ReadUserInfoFromReg we don't want to 
        // save the empty string to the RAS Credstore because it might overwrite 
        // global credentials information. This can happen if User1 saves global
        // credentials and User2 tries using the same profile. Since User2 is running 
        // this profile for the 1st time, he'll run through an upgrade path and if global
        // creds exist we don't want to null them out.
        //
        
        if (ReadUserInfoFromReg(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_INET_USERNAME);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_INET_USERNAME, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_INET_PASSWORD);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_INET_PASSWORD, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_USERNAME, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_USERNAME);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_USERNAME, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_DOMAIN, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_DOMAIN);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_DOMAIN, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_PASSWORD);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_PASSWORD, pszTmp);
            }
            CmFree(pszTmp);
        }

        //
        //  Now delete the PCS value as it is no longer meaningful
        //
        DeleteUserInfoFromReg(pArgs, UD_ID_PCS);
    }
    else
    {
        MYDBGASSERT(FALSE);
    }


    return bReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   UpgradeUserInfoFromCmp
//
//  Synopsis:   Upgrade the userinfo from cm1.0/1,1 format to 1.3 format.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL UpgradeUserInfoFromCmp(
    ArgsStruct  *pArgs
)
{
    LPTSTR      pszTmp;
    BOOL        fTmp;
    PVOID       pv;

    //
    // First retrieve each of the non-cached data items
    // Then delete username, internetusername, domain, password, 
    // internetpassword, remember password, remember internet password
    // and noprompt (dial automatically) from the CMP file.
    // If the KeepDefaultCredentials is set to 1 in the .CMP file then the 
    // DeleteUserInfoFromCmp function does not actually delete the values from 
    // the file.
    // If we get an empty string "" from ReadUserInfoFromCmp we don't want to 
    // save the empty string to the RAS Credstore because it might overwrite 
    // global credentials information. This can happen if User1 saves global
    // credentials and User2 tries using the same profile. Since User2 is running 
    // this profile for the 1st time, he'll run through an upgrade path and if global
    // creds exist we don't want to null them out.
    //

    pszTmp = NULL;
    ReadUserInfoFromCmp(pArgs, UD_ID_USERNAME, (PVOID*)&pszTmp);
    if (pszTmp && lstrlenU(pszTmp))
    {
        SaveUserInfo(pArgs, UD_ID_USERNAME, pszTmp);
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_USERNAME);
    CmFree(pszTmp);

    pszTmp = NULL;
    ReadUserInfoFromCmp(pArgs, UD_ID_DOMAIN, (PVOID*)&pszTmp);
    if (pszTmp && lstrlenU(pszTmp))
    {
        SaveUserInfo(pArgs, UD_ID_DOMAIN, pszTmp);
    }    
    DeleteUserInfoFromCmp(pArgs, UD_ID_DOMAIN);
    CmFree(pszTmp);

    pszTmp = NULL;
    ReadUserInfoFromCmp(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszTmp);
    if (pszTmp && lstrlenU(pszTmp))
    {
        SaveUserInfo(pArgs, UD_ID_INET_USERNAME, pszTmp);
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_INET_USERNAME);
    CmFree(pszTmp);

    pv = &fTmp;
    ReadUserInfoFromCmp(pArgs, UD_ID_NOPROMPT, &pv);
    SaveUserInfo(pArgs, UD_ID_NOPROMPT, pv);
    DeleteUserInfoFromCmp(pArgs, UD_ID_NOPROMPT);

    pv = &fTmp;
    ReadUserInfoFromCmp(pArgs, UD_ID_REMEMBER_PWD, &pv);
    SaveUserInfo(pArgs, UD_ID_REMEMBER_PWD, pv);
    DeleteUserInfoFromCmp(pArgs, UD_ID_REMEMBER_PWD);

    pv = &fTmp;
    ReadUserInfoFromCmp(pArgs, UD_ID_REMEMBER_INET_PASSWORD, &pv);
    SaveUserInfo(pArgs, UD_ID_REMEMBER_INET_PASSWORD, pv);
    DeleteUserInfoFromCmp(pArgs, UD_ID_REMEMBER_INET_PASSWORD);

    //
    // Construct old cache entry name
    //

    LPTSTR pszCacheEntryName = GetLegacyKeyName(pArgs);
    
    //
    // main passwd
    //
    pszTmp = NULL;
    
    //
    // To get the passwords, the cm 1.1 logic is that we first try the cmp, then the cache.
    //

    if (ReadUserInfoFromCmp(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp))
    {
        if (pszTmp && lstrlenU(pszTmp))
        {
            SaveUserInfo(pArgs, UD_ID_PASSWORD, pszTmp);
        }
    }
    else
    {
        CmFree(pszTmp);
        pszTmp = NULL;

#ifdef  TEST_USERINFO_UPGRADE
    
        MYVERIFY(WriteStringToCache(pArgs, pszCacheEntryName, TEXT("CM 1.1 main password")));
#endif        
        
        //
        // Try to read it from cache
        //

        if (ReadStringFromCache(pArgs, pszCacheEntryName, &pszTmp))
        {
            if (pszTmp && lstrlenU(pszTmp))
            {
                if (SaveUserInfo(pArgs, UD_ID_PASSWORD, pszTmp))
                {

#ifdef  TEST_USERINFO_UPGRADE

                MYVERIFY(DeleteStringFromCache(pArgs, pszCacheEntryName));
#endif
                }
            }
        }
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_PASSWORD);
    CmFree(pszTmp);

    //
    // inet passwd
    //
    pszTmp = NULL;
    if (ReadUserInfoFromCmp(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszTmp))
    {
        if (pszTmp && lstrlenU(pszTmp))
        {
            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, pszTmp);
        }
    }
    else
    {
        CmFree(pszTmp);
        pszTmp = NULL;

        //
        // Build tunnel entry name and read string from cache
        //
      
        pszCacheEntryName = CmStrCatAlloc(&pszCacheEntryName, TEXT("-tunnel"));

#ifdef  TEST_USERINFO_UPGRADE
        
        MYVERIFY(WriteStringToCache(pArgs, pszCacheEntryName, TEXT("CM 1.1 internet password")));
#endif
       
        if (ReadStringFromCache(pArgs, pszCacheEntryName, &pszTmp))
        {
            if (pszTmp && lstrlenU(pszTmp))
            {
                if (SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, pszTmp))
                {

#ifdef  TEST_USERINFO_UPGRADE

                MYVERIFY(DeleteStringFromCache(pArgs, pszCacheEntryName));
#endif
                }
            }
        }
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_INET_PASSWORD);
    CmFree(pszTmp);

    CmFree(pszCacheEntryName);

    return TRUE; // MarkUserInfoUpgraded(pArgs);
}

//+----------------------------------------------------------------------------
//
// Function:  GetLegacyKeyName
//
// Synopsis:  Builds the string fragment used to build cache entry name. The "
//            sign-in" prefix is maintained for legacy compatibility
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   LPTSTR - Ptr to allocated string containing "<service name> - Sign-In"
//
// Note:      Used exclusively for cache entry name construction
//
// History:   nickball    Created Header    4/16/98
//
//+----------------------------------------------------------------------------
LPTSTR GetLegacyKeyName(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    //
    // Service name is the basis of the key name. We also include 
    // IDMSG_TITLESERVICE and append a suffix of " (Connection Manager)"
    //

    LPTSTR pszRes = CmFmtMsg(g_hInst, IDMSG_TITLESERVICE, pArgs->szServiceName);
    
    MYDBGASSERT(pszRes && *pszRes);

    if (pszRes)
    {
        pszRes = CmStrCatAlloc(&pszRes, c_pszCacheEntryNameSuffix);
    }

    return (pszRes);
}

//+----------------------------------------------------------------------------
//
// Function:  EncryptPassword
//
// Synopsis:  Wrapper for encrypting password
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPCTSTR pszPassword - The password to be encrypted
//            LPDWORD lpdwBufSize - Buffer for size of the encrypted buffer - optional
//            LPDWORD lpdwCryptType - Buffer for crypto type used
//            BOOL    fReg - Password is disguised for registry storage
//
// Returns:   LPTSTR - Ptr to allocated buffer containing encrypted form of password
//
// History:   nickball    Created Header    5/22/98
//
//+----------------------------------------------------------------------------

LPTSTR EncryptPassword(
    ArgsStruct *pArgs, 
    LPCTSTR pszPassword, 
    LPDWORD lpdwBufSize, 
    LPDWORD lpdwCryptType,
    BOOL /*fReg*/,
    LPSTR pszSubKey)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszPassword);
    MYDBGASSERT(lpdwCryptType);
    DWORD dwEncryptedBufferLen;
    DWORD dwSize = 0;

    LPTSTR pszEncryptedData = NULL;
    TCHAR szSourceData[PWLEN + 1];

    if (NULL == pArgs || NULL == pszPassword || NULL == lpdwCryptType)
    { 
        return NULL;
    }

    //
    // Standard encryption, copy the password
    //

    lstrcpyU(szSourceData, pszPassword);
   
    //
    // It is not safe to call InitSecure more than once
    //
    if (!pArgs->fInitSecureCalled)
    {
        pArgs->fInitSecureCalled = TRUE;
        InitSecure(FALSE); // don't use fast encryption anymore
    }

    //
    // Encrypt the provided password
    //

    if (EncryptData(
            (LPBYTE)szSourceData, 
            (lstrlenU(szSourceData)+1) * sizeof(TCHAR),
            (LPBYTE*)&pszEncryptedData,
            &dwEncryptedBufferLen,
            lpdwCryptType,
#if defined(DEBUG) && defined(DEBUG_MEM)
            (PFN_CMSECUREALLOC)AllocDebugMem, // Give the DEBUG_MEM version of alloc/free
            (PFN_CMSECUREFREE)FreeDebugMem,   // Not quit right, AllocDebugMem takes 3 param
            pszSubKey))
#else
            (PFN_CMSECUREALLOC)CmMalloc,
            (PFN_CMSECUREFREE)CmFree,
            pszSubKey))
#endif
    {
        if (lpdwBufSize)
        {
            *lpdwBufSize = dwEncryptedBufferLen;
        }   
    }

    MYDBGASSERT(pszEncryptedData);
    
    CmWipePassword(szSourceData);
    return pszEncryptedData;
}

//+----------------------------------------------------------------------------
//
// Function:  DecryptPassword
//
// Synopsis:  Wrapper to decrypt password
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPCTSTR pszEncryptedData - The encrypted data
//            DWORD dwEncryptionType - The encryption type of the data
//            BOOL    fReg - Password is disguised for registry storage
//
// Returns:   LPTSTR - Ptr to a buffer containing the decrypted form of the password.
//
// History:   nickball    Created     5/22/98
//
//+----------------------------------------------------------------------------
LPBYTE DecryptPassword(
    ArgsStruct *pArgs, 
    LPBYTE pszEncryptedData, 
    DWORD dwEncryptionType,
    DWORD dwEncryptedBytes,
    BOOL /*fReg*/,
    LPSTR pszSubKey)
{      
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEncryptedData);
    
    DWORD dwDecryptedBufferLen;
    LPBYTE pszDecryptedData = NULL;

    if (NULL == pArgs || NULL == pszEncryptedData)
    { 
        return NULL;
    }

    //
    // It is not safe to call InitSecure more than once
    //

    if (!pArgs->fInitSecureCalled)
    {
        pArgs->fInitSecureCalled = TRUE;
        InitSecure(FALSE); // don't use fast encryption anymore
    }

    if (DecryptData(pszEncryptedData, dwEncryptedBytes, &pszDecryptedData, &dwDecryptedBufferLen,
                    dwEncryptionType, 
#if defined(DEBUG) && defined(DEBUG_MEM)
             (PFN_CMSECUREALLOC)AllocDebugMem, // Give the DEBUG_MEM version of alloc/free
             (PFN_CMSECUREFREE)FreeDebugMem,   // Not quit right, AllocDebugMem takes 3 param
             pszSubKey))

#else
                    (PFN_CMSECUREALLOC)CmMalloc, 
                    (PFN_CMSECUREFREE)CmFree,
                    pszSubKey))
#endif
    {
        return pszDecryptedData;
    }

    return NULL; 
}

//+----------------------------------------------------------------------------
//
// Function:  TranslateUserDataID
//
// Synopsis:  Wrapper to map user data ID to string name of .CMP entry
//
// Arguments: UINT uiDataID - UserInfo data ID to be translated
//
// Returns:   LPCTSTR - Ptr to a constant containing the .CMP entry flag
//
// History:   nickball    Created     10/13/98
//
//+----------------------------------------------------------------------------
LPCTSTR TranslateUserDataID(UINT uiDataID)
{   
    switch(uiDataID)
    {

    case UD_ID_USERNAME:
        return c_pszCmEntryUserName;
        break;

    case UD_ID_INET_USERNAME:
        return c_pszCmEntryInetUserName;
        break;

    case UD_ID_DOMAIN:
        return c_pszCmEntryDomain;
        break;

    case UD_ID_PASSWORD:
        return c_pszCmEntryPassword;
        break;

    case UD_ID_INET_PASSWORD:
        return c_pszCmEntryInetPassword;
        break;

    case UD_ID_NOPROMPT:
        return c_pszCmEntryNoPrompt;
        break;

    case UD_ID_REMEMBER_PWD:
        return c_pszCmEntryRememberPwd;
        break;
    
    case UD_ID_REMEMBER_INET_PASSWORD:
        return c_pszCmEntryRememberInetPwd;
        break;
 
    case UD_ID_PCS:
        return c_pszCmEntryPcs;
        break;

    case UD_ID_ACCESSPOINTENABLED:
        return c_pszCmEntryAccessPointsEnabled;
        break;

    case UD_ID_CURRENTACCESSPOINT:
        return c_pszCmEntryCurrentAccessPoint;
        break;

    default:
        break;
    }

    MYDBGASSERT(FALSE);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\rnawnd.cpp ===
//+----------------------------------------------------------------------------
//
// File:     rnawnd.cpp    
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Win9x Rnaapp.exe workaround code.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include <process.h>

#define MAX_RNA_WND_TITLE_LEN   26    // Max chars for window title compare
#define MAX_ZAPRNA_PAUSE 50           // milliseconds to pause between window enumerations  

typedef struct tagFRCTParam {
    HANDLE hEvent;
	LPSTR pszDun;
} ZRCTParam, *PZRCTP;

typedef struct tagFindParam {
	LPCSTR pszTitle;
    HWND hwndRNA;
} FINDPARAM, *PFINDPARAM;

//+---------------------------------------------------------------------------
//
//	Function:	FindRnaWindow
//
//	Synopsis:	Callback for EnumWindows().  It receives the hwnd of all the 
//              top-level windows.  It's job is to look for the RNA status wnd.
//
//	Arguments:	hwndTop hwnd of the top-level window
//              lParam  title of the rna wnd to be found.
//
//	Returns:	NONE
//
//	History:	henryt	Created		8/19/97
//----------------------------------------------------------------------------

BOOL CALLBACK FindRnaWindow(
    HWND    hwndTop,
    LPARAM  lParam)
{
    MYDBGASSERT(lParam);

    PFINDPARAM pFindParam = (PFINDPARAM) lParam;
    CHAR szTitle[MAX_RNA_WND_TITLE_LEN + 1];

    if (NULL == pFindParam)
    {
        return TRUE;
    }

    //
    // We are looking for a top-level window with a title matching lParam
    //
    
    if (MAKEINTATOM(GetClassLongU(hwndTop, GCW_ATOM)) == WC_DIALOG)
    {
        GetWindowTextA(hwndTop, szTitle, MAX_RNA_WND_TITLE_LEN + 1);
        //
        // truncate the window title as we only check the first few chars
        //
        szTitle[MAX_RNA_WND_TITLE_LEN] = '\0';

        if (lstrcmpA(szTitle, pFindParam->pszTitle) == 0)
        {
            //
            // Its a match, update the hwnd and bail
            //

            pFindParam->hwndRNA = hwndTop;
            return FALSE;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  fnZRCT
//
// Synopsis:  Thread to terminate RNA "Connected To" dlg
//
// Arguments: void *pvParam - Thread parameters PZRCTP containing connectoid 
//                            name is expected
//
// Returns:   unsigned long - Standard thread return code
//
// History:   nickball    Created    3/5/98
//
//+----------------------------------------------------------------------------
static unsigned long __stdcall fnZRCT(void *pvParam) 
{
	PZRCTP pParam = (PZRCTP) pvParam;
    PFINDPARAM pFindParam = NULL;
	unsigned uRes = 1;
	HMODULE hLibrary = NULL;
	BOOL bRes;
	HLOCAL hRes;
    LPSTR pszFmt = NULL;
	CHAR szTmp[MAX_PATH];
	DWORD dwIdx;
    DWORD dwWait;

    MYDBGASSERT(pParam->hEvent);
    MYDBGASSERT(pParam->pszDun);

    //
    // Load RNAAPP.EXE, so we can access its resources
    //

	hLibrary = LoadLibraryExA("rnaapp.exe", NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (!hLibrary) 
    {
		uRes = GetLastError();
		CMTRACE1(TEXT("fnZRCT() LoadLibraryEx() failed, GLE=%u."), GetLastError());
		goto done;
	}

    //
    // Extract string #204 from RNAAPP.EXE, then release.
    //
	
    if (!LoadStringA(hLibrary, 204, szTmp, sizeof(szTmp)/sizeof(CHAR)-1))
    {
		uRes = GetLastError();
		CMTRACE1(TEXT("fnZRCT() LoadString() failed, GLE=%u."), GetLastError());
		goto done;
	}
	
    bRes = FreeLibrary(hLibrary);
    hLibrary = NULL;

#ifdef DEBUG
    if (!bRes)
    {
        CMTRACE1(TEXT("fnZRCT() FreeLibrary() failed, GLE=%u."), GetLastError());
    }
#endif
	
    //
    // Format the string with our DUN name
    //
    
    pszFmt = (LPSTR)CmMalloc((lstrlenA(szTmp)+1)*sizeof(TCHAR));
	
    if (!pszFmt) 
    {
		uRes = GetLastError();
		CMTRACE1(TEXT("fnZRCT() CmMalloc() failed, GLE=%u."), GetLastError());
		goto done;
	}
	
    lstrcpyA(pszFmt, szTmp);
	wsprintfA(szTmp, pszFmt, pParam->pszDun);
    
    //
    // to work around a bug where a long connectoid/profile name can prevent
    // us to look for the RNA window(because the window title will be truncated)
    // we only read the first 26 chars.
    //

    szTmp[MAX_RNA_WND_TITLE_LEN] = '\0';
   
    //
    // Setup param for FindRnaWindow callback used in EnumWindows
    //

    pFindParam = (PFINDPARAM)CmMalloc(sizeof(FINDPARAM));
	if (!pFindParam) 
    {
		CMTRACE1(TEXT("ZapRNAConnectedTo() CmMalloc() failed, GLE=%u."), GetLastError());
		goto done;
	}
    
    pFindParam->pszTitle = szTmp;
    pFindParam->hwndRNA = NULL;

    //
    // Try to find the window every 50 milliseconds up to 200 times
    //

    CMTRACE1(TEXT("fnZRCT() is watching for a window named %s."), szTmp);

    for (dwIdx=0; dwIdx < 200; dwIdx++) 
    {
        EnumWindows(FindRnaWindow, (LPARAM) pFindParam);

		//hwndRNA = FindWindow(TEXT("#32770"),szTmp);
		
        //
        // If hwnd has a value, its the RNA wind, hide it and bail
        //

        if (pFindParam->hwndRNA) 
        {
			CMTRACE(TEXT("fnZRCT() is hiding the dialog."));
			ShowWindowAsync(pFindParam->hwndRNA,SW_HIDE);
			uRes = 0;
			break;
		}
		
        //
        // Wait for MAX_ZAPRNA_PAUSE milliseconds, or until event is signaled
        //

        dwWait = WaitForSingleObject(pParam->hEvent, MAX_ZAPRNA_PAUSE);

        //
        // If not a timeout, we're done
        //

        if (WAIT_TIMEOUT != dwWait)
        {
            //
            // If not an event signal, report 
            //

            if (WAIT_OBJECT_0 != dwWait)
            {       
    		    CMTRACE1(TEXT("fnZRCT() WAIT_OBJECT_0 != dwWait, GLE=%u."), GetLastError());
            }

            break;
        }
	}

done:
	
    //
    // Cleanup
    //
#ifdef DEBUG
    if (uRes)
    {
        CMTRACE(TEXT("fnZRCT() has exited without hiding the dialog."));
    }
#endif

    CmFree(pParam->pszDun);
	CmFree(pParam);
	CmFree(pFindParam);
	CmFree(pszFmt);

#ifdef DEBUG
    if (uRes)
    {
        CMTRACE(TEXT("fnZRCT() could not free all of its alloc-ed memory"));
    }
#endif

    if (hLibrary) 
    {
		bRes = FreeLibrary(hLibrary);
	}
	
    CMTRACE1(TEXT("fnZRCT() is exiting with uRes=%u."), uRes);

	return (uRes);
}

//+----------------------------------------------------------------------------
//
// Function:  ZapRNAConnectedTo
//
// Synopsis:  Fires off thread to hide the RNA "Connected To" dlg
//
// Arguments: LPCTSTR pszDUN - The name of the DUN entry that we are connecting
//            HANDLE hEvent - Handle to CM termination event
//
// Returns:   HANDLE - Handle of created thread or NULL on failure
//
// History:   nickball    Created Header    3/5/98
//
//+----------------------------------------------------------------------------
HANDLE ZapRNAConnectedTo(LPCTSTR pszDUN, HANDLE hEvent) 
{
	MYDBGASSERT(pszDUN);
    MYDBGASSERT(hEvent);
    
    PZRCTP pParam;
	unsigned long tidThread;
	HANDLE hThread = NULL;

	if (NULL == pszDUN || NULL == *pszDUN || NULL == hEvent) 
    {
		return hThread;
	}
	
    pParam = (PZRCTP) CmMalloc(sizeof(ZRCTParam));

	if (!pParam) 
    {
		CMTRACE1(TEXT("ZapRNAConnectedTo() CmMalloc() failed, GLE=%u."), GetLastError());
		return hThread;
	}

    pParam->pszDun = WzToSzWithAlloc(pszDUN);

	if (!pParam->pszDun) 
    {
		CMTRACE1(TEXT("ZapRNAConnectedTo() CmMalloc() failed, GLE=%u."), GetLastError());
		return hThread;
	}
    
    //
    // Setup params to be passed to thread
    //

    pParam->hEvent = hEvent;

    //
    // Create the Zap thread 
    //

    hThread = (HANDLE) CreateThread(NULL, 0, fnZRCT, pParam, 0, &tidThread);
	if (!hThread) 
    {
        //
        // Couldn't create thread, free params
        //

        CMTRACE1(TEXT("ZapRNAConnectedTo() CreateThread() failed, GLE=%u."), GetLastError());
		CmFree(pParam);
	} 

    // 
    // Note: pParam is release inside thread
    //
 
    CMTRACE1(TEXT("fnZRCT() is exiting with hThread=%u."), hThread);
    
    return hThread;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//      
// Module:   CMDIAL32.DLL 
//
// Synopsis: Various utility functions
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   dondu      Created   01/01/96
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "DynamicLib.h"
#include "profile_str.h"
#include "tunl_str.h"
#include "stp_str.h"
#include "dun_str.h"

#include "linkdll.cpp" // LinkToDll and BindLinkage

//
//  Get the common functions AddAllKeysInCurrentSectionToCombo
//  and GetPrivateProfileStringWithAlloc
//
#include "gppswithalloc.cpp"

const TCHAR* const c_pszTunnelName = TEXT(" Tunnel");
const TCHAR* const c_pszRegCurrentVersion       = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
const TCHAR* const c_pszRegCsdVersion           = TEXT("CSDVersion");
const TCHAR* const c_pszIconMgrClass            = TEXT("IConnMgr Class");
const TCHAR* const c_pszCmEntryPasswordHandling     = TEXT("PasswordHandling"); 
//+----------------------------------------------------------------------------
//
// Function:  CmGetWindowTextAlloc
//
// Synopsis:  Retrieves the text of a control in a dialog, returning the text in
//            a block of allocated memory
//
// Arguments: HWND hwndDlg - The window that owns the control
//            UINT nCtrl - The ID of the control
//
// Returns:   LPTSTR - Ptr to buffer containing the window text
//
// History:   nickball    Created Header    4/1/98
//
//+----------------------------------------------------------------------------
LPTSTR CmGetWindowTextAlloc(HWND hwndDlg, UINT nCtrl) 
{
    LPTSTR pszRes = NULL;
    HWND hwndCtrl = nCtrl ? GetDlgItem(hwndDlg, nCtrl) : hwndDlg;

    if (hwndCtrl)
    {
        size_t nLen = GetWindowTextLengthU(hwndCtrl);
        
        pszRes = (LPTSTR)CmMalloc((nLen+2)*sizeof(TCHAR));

        if (pszRes)
        {
            GetWindowTextU(hwndCtrl, pszRes, nLen+1);
        }
    }

    return (pszRes);
}

//+----------------------------------------------------------------------------
//
// Function:  ReducePathToRelative
//
// Synopsis:  Helper function, converts a full profile file path into a 
//            relative path.
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            LPCTSTR pszFullPath   - The full path to the file
//            
//
// Returns:   LPTSTR - The relative path form or NULL
//
// Note:      The file to be reduced should exist and be located
//            in the profile directory
//
// History:   nickball    Created    8/12/98
//
//+----------------------------------------------------------------------------
LPTSTR ReducePathToRelative(ArgsStruct *pArgs, LPCTSTR pszFullPath)
{    
    MYDBGASSERT(pszFullPath);
    MYDBGASSERT(pArgs);

    if (NULL == pszFullPath || NULL == pArgs || FALSE == FileExists(pszFullPath))
    {
        return NULL;
    }
 
    //
    // Use CMS as base
    //

    LPTSTR pszReduced = CmStripPathAndExt(pArgs->piniService->GetFile()); 
    MYDBGASSERT(pszReduced);

    if (pszReduced)
    {
        //
        // Append the filename
        //
        
        pszReduced = CmStrCatAlloc(&pszReduced, TEXT("\\"));
        MYDBGASSERT(pszReduced);

        if (pszReduced)
        {
            LPTSTR pszFileName = StripPath(pszFullPath);
            MYDBGASSERT(pszFileName);    

            if (pszFileName)    
            {
                pszReduced = CmStrCatAlloc(&pszReduced, pszFileName);
                MYDBGASSERT(pszReduced);
                CmFree(pszFileName);
   
                if (pszReduced)
                {
                    return pszReduced;
                }
            }
        }
    }
    
    CmFree(pszReduced);
    return NULL;
}


// get service name from the service file
LPTSTR GetServiceName(CIni *piniService) 
{
    LPTSTR pszTmp;

    pszTmp = piniService->GPPS(c_pszCmSection,c_pszCmEntryServiceName);
    if (!*pszTmp) 
    {
        //
        // failed to get service name, then use base filename
        //
        CmFree(pszTmp);
        pszTmp = CmStripPathAndExt(piniService->GetFile());
        
        //
        // Do not write the entry back to .CMS file - #4849
        //
        // piniService->WPPS(c_pszCmSection, c_pszCmEntryServiceName, pszTmp);
    }
    return (pszTmp);
}

//+----------------------------------------------------------------------------
//
//  Function    GetTunnelSuffix
//
//  Synopsis    Returns an allocated string containing the tunnel suffix
//
//  Arguments   None
//
//  Returns     LPTSTR - Ptr to the suffix in its entirety, caller must free
//
//  History     06/14/99    nickball    Created
//
//-----------------------------------------------------------------------------
LPTSTR GetTunnelSuffix()
{    
    MYDBGASSERT(OS_W9X); // secondary connectoids only exist on 9X

    //
    // First copy the phrase " Tunnel", which is not localized
    // 

    LPTSTR pszSuffix = CmStrCpyAlloc(c_pszTunnelName); 
    
    //
    // Now retrieve the localizable phrase " (for advanced use only)"
    //
   
    if (pszSuffix)
    {
        LPTSTR pszTmp = CmLoadString(g_hInst, IDS_TUNNEL_SUFFIX);
        pszSuffix = CmStrCatAlloc(&pszSuffix, pszTmp);
        CmFree(pszTmp);
    }

    MYDBGASSERT(pszSuffix);

    return pszSuffix;
}

//+----------------------------------------------------------------------------
//
//  Function    GetDefaultDunSettingName
//
//  Synopsis    Get the default DUN name from the specified .CMS
//
//  Arguments   piniService - The service file object to be used.
//              fTunnel - Indicates if the profile is for tunneling
//
//  Returns     LPTSTR - Ptr to the DUN name
//
//  History     10/28/98    nickball    Created
//
//-----------------------------------------------------------------------------
LPTSTR GetDefaultDunSettingName(CIni* piniService, BOOL fTunnelEntry)
{
    //
    // Get the DUN name from the top level service file, ex: snowbird online service
    //

    LPTSTR pszTmp = NULL;
       
    if (fTunnelEntry)
    {
        pszTmp = piniService->GPPS(c_pszCmSection, c_pszCmEntryTunnelDun);
        MYDBGASSERT(pszTmp && *pszTmp); // CMAK writes this, it shouldn't be blank
    }
    else
    {
        pszTmp = piniService->GPPS(c_pszCmSection, c_pszCmEntryDun);
    }

    return (pszTmp);
}


//+----------------------------------------------------------------------------
//
//  Function    GetDunSettingName
//
//  Synopsis    Get the current DUN name
//
//  Arguments   pArgs - Ptr to ArgStruct
//              dwEntry - index of rasentry (ignored if fTunnel is true)
//              fTunnel - is this a VPN?
//
//  Returns     Dun setting name
//
//  History     01-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR GetDunSettingName(ArgsStruct * pArgs, DWORD dwEntry, BOOL fTunnel)
{
    LPTSTR pszTmp = NULL;

    MYDBGASSERT(pArgs);
    MYDBGASSERT(fTunnel || (dwEntry <= 1));

    if (NULL == pArgs)
    {
        return NULL;
    }

    if (fTunnel)
    {
        pszTmp = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelDun);
        MYDBGASSERT(pszTmp && *pszTmp); // CMAK writes this, it shouldn't be blank
        
        if (pszTmp && !*pszTmp)
        {
            // the "empty string" case
            CmFree(pszTmp);
            pszTmp = NULL;
        }
    }
    else
    {
        if (pArgs->aDialInfo[dwEntry].szDUN[0])
        {
            pszTmp = CmStrCpyAlloc(pArgs->aDialInfo[dwEntry].szDUN);
        }
        else
        {
            CIni * pIni = GetAppropriateIniService(pArgs, dwEntry);

            if (pIni)
            {
                pszTmp = pIni->GPPS(c_pszCmSection, c_pszCmEntryDun);
                delete pIni;
            }        
        }
    }

    if (NULL == pszTmp)
    {
        pszTmp = GetDefaultDunSettingName(pArgs->piniService, fTunnel);
    }

    return pszTmp;
}


//+----------------------------------------------------------------------------
//
//  Function    GetCMSforPhoneBook
//
//  Synopsis    Get the name of the .CMS file that contains the current phonebook
//
//  Arguments   pArgs - Ptr to ArgStruct
//              dwEntry - index of rasentry
//
//  Returns     phonebook filename (NULL if error or not found)
//
//  History     10-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR GetCMSforPhoneBook(ArgsStruct * pArgs, DWORD dwEntry)
{
    LPTSTR pszTmp = NULL;

    MYDBGASSERT(pArgs);
    MYDBGASSERT(dwEntry <= 1);

    if (NULL == pArgs)
    {
        return NULL;
    }

    PHONEINFO * pPhoneInfo = &(pArgs->aDialInfo[dwEntry]);

    if (pPhoneInfo && pPhoneInfo->szPhoneBookFile[0])
    {
        LPTSTR pszFileName = CmStrrchr(pPhoneInfo->szPhoneBookFile, TEXT('\\'));

        if (pszFileName)
        {
            pszTmp = CmStrCpyAlloc(CharNextU(pszFileName));
        }
    }

    return pszTmp;
}


//+----------------------------------------------------------------------------
//
// Function:  FileExists
//
// Synopsis:  Helper function to encapsulate determining if a file exists. 
//
// Arguments: LPCTSTR pszFullNameAndPath - The FULL Name and Path of the file.
//
// Returns:   BOOL - TRUE if the file is located
//
// History:   nickball    Created    3/9/98
//
//+----------------------------------------------------------------------------
BOOL FileExists(LPCTSTR pszFullNameAndPath)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFileU(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (GetFileType(hFile) == FILE_TYPE_DISK)
            {
                CloseHandle(hFile);
                return TRUE;
            }
            else
            {
                CloseHandle(hFile);
                return FALSE;
            }
        }
    }
    
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsBlankString
//  
//  Synopsis:   Check whether a given string contains only spaces(' ')
//
//  Arguments:  pszString   string to be verified
//
//  Returns:    TRUE            only space is in the string
//              FALSE           otherwise
//
//  History:    byao            Modified  4/11/97
//              byao            Modified  4/14/97   Change the function to apply to
//                                                  all strings (instead of phone no only).
//----------------------------------------------------------------------------
BOOL IsBlankString(LPCTSTR pszString)
{
    MYDBGASSERT(pszString);

    DWORD dwIdx;
    DWORD dwLen = lstrlenU(pszString);

    if (NULL == pszString)
    {
        return FALSE;
    }

    for (dwIdx = 0; dwIdx < dwLen; dwIdx++)
    {
        if (pszString[dwIdx]!=TEXT(' '))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//
// Acceptable phone number characters
//

#define VALID_CTRL_CHARS TEXT("\03\026\030") // ctrl-c, ctrl-v, ctrl-x.
#define VALID_PHONE_CHARS TEXT("0123456789AaBbCcDdPpTtWw!@$ -()+*#,\0")

//+---------------------------------------------------------------------------
//
//  Function:   IsValidPhoneNumChar
//
//  Synopsis:   Helper function to encapsulate validation of a character to 
//              determine if it is an acceptable input char for a phone number
//
//  Arguments:  TCHAR tChar - the char in question
//
//  Returns:    TRUE    if valid
//              FALSE   otherwise
//
//  History:    nickball - Created - 7/7/97
//
//----------------------------------------------------------------------------
BOOL IsValidPhoneNumChar(TCHAR tChar)
{
    LPTSTR lpValid = NULL;
    
    //
    // Scan thru the list of valid tapi characters
    //

    for (lpValid = VALID_PHONE_CHARS; *lpValid; lpValid++)
    {
        if (tChar == (TCHAR) *lpValid)
        {
            return TRUE;
        }
    }

    //
    // Scan thru the list of valid ctrl characters
    //

    for (lpValid = VALID_CTRL_CHARS; *lpValid; lpValid++)
    {
        if (tChar == (TCHAR) *lpValid)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMappingByRoot
//
//  Synopsis:   Read in the mapping from the [HKCU or HKLM] branch of the registry
//
//  Arguments:  hkRoot          either HKCU or HKLM
//              pszDUN[IN]      Connectoid name
//              pszMapping[IN]  Full path of the service profile(.CMS) for this connectoid
//              dwNumCharsInMapping[IN]   Number of chars in pszMapping, including the NULL char
//
//  Returns:    TRUE        if registry key read in successfully
//              FALSE       otherwise
//
//----------------------------------------------------------------------------
BOOL ReadMappingByRoot(
    HKEY    hkRoot,
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwNumCharsInMapping,
    BOOL bExpandEnvStrings
) 
{
    MYDBGASSERT(pszDUN);
    MYDBGASSERT(pszMapping);
    MYDBGASSERT(dwNumCharsInMapping);

    if (NULL == pszDUN || NULL == pszMapping)
    {
        return FALSE;
    }

    TCHAR szTmp[MAX_PATH + 1] = TEXT("");
    DWORD dwNumBytesInTmp = sizeof(szTmp);
    DWORD dwRes;

    HKEY hkKey;
    DWORD dwType;

    dwRes = RegOpenKeyExU(hkRoot,
                          c_pszRegCmMappings,  // Mappings sub-key
                          0,
                          KEY_READ,
                          &hkKey);
    if (dwRes != ERROR_SUCCESS) 
    {
        CMTRACE1(TEXT("ReadMappingByRoot() RegOpenKeyEx() failed, GLE=%u."), dwRes);
        return (FALSE);
    }

    dwRes = RegQueryValueExU(hkKey, pszDUN, NULL, &dwType, (LPBYTE) szTmp, &dwNumBytesInTmp);

    RegCloseKey(hkKey);
 
    //
    // If no value found, just bail
    // 

    if ((dwRes != ERROR_SUCCESS) || (!*szTmp))
    {
        CMTRACE1(TEXT("ReadMappingByRoot() RegQueryValueEx() failed, GLE=%u."), dwRes);
        return FALSE;
    }

    // 
    // Check for and expand environment strings
    //
    
    if (bExpandEnvStrings && (TEXT('%') == *szTmp))
    {
        CMTRACE1(TEXT("Expanding Mapping environment string as %s"), szTmp);

        dwRes = ExpandEnvironmentStringsU(szTmp, pszMapping, dwNumCharsInMapping);        

        MYDBGASSERT(dwRes <= dwNumCharsInMapping);
    }
    else
    {
        lstrcpyU(pszMapping, szTmp);
        dwRes = lstrlenU(pszMapping) + 1;
    }

#ifdef DEBUG
    if (dwRes <= dwNumCharsInMapping)
    {
        CMTRACE1(TEXT("ReadMappingByRoot() SUCCESS. Mapping is %s"), pszMapping);
    }
    else
    {
        CMTRACE(TEXT("ReadMappingByRoot() FAILED."));
    }
#endif

    return (dwRes <= dwNumCharsInMapping);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMapping
//
//  Synopsis:   Read in the mapping from the registry
//
//  Arguments:  pszDUN[IN]     Connectoid name
//              pszMapping[IN] Full path of the service profile(.CMS) for this connectoid
//              dwMapping[IN]  Number of chars in pszMapping, including the NULL char
//              fAllUser[IN]   Look in the AllUser hive
//
//  Returns:    BOOL           TRUE if found
//
//----------------------------------------------------------------------------
BOOL ReadMapping(
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwMapping,
    BOOL fAllUser,
    BOOL bExpandEnvStrings) 
{
    BOOL fOk = FALSE;

    //
    // Copied from ntdef.h
    //

    #define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
   
    if (fAllUser)
    {
        CMTRACE1(TEXT("ReadMapping() - Reading AllUser Mapping for %s"), pszDUN);
        
        fOk = ReadMappingByRoot(HKEY_LOCAL_MACHINE, pszDUN, pszMapping, dwMapping, bExpandEnvStrings);            
    }
    else
    {
        CMTRACE1(TEXT("ReadMapping() - Reading Single User Mapping for %s"), pszDUN);

        //
        // Only NT5 has single-user profiles
        //

        MYDBGASSERT(OS_NT5);

        if (OS_NT5)
        {        
            //
            // There are cases where we aren't always running in the user context (certain
            // WinLogon cases and certain delete notification cases).  At these times we
            // have impersonation setup but don't have direct access to the HKCU, thus
            // we use RtlOpenCurrentUser in these instances.
            //

            CDynamicLibrary libNtDll;   // Destructor will call FreeLibrary
            HANDLE hCurrentUserKey = NULL;

            if (libNtDll.Load(TEXT("NTDLL.DLL")))
            {
                typedef NTSTATUS (NTAPI * RtlOpenCurrentUserPROC)(IN ULONG DesiredAccess,
                    OUT PHANDLE CurrentUserKey);
                typedef NTSTATUS (NTAPI * NtClosePROC)(IN HANDLE Handle);

                RtlOpenCurrentUserPROC pfnRtlOpenCurrentUser;

                if ( (pfnRtlOpenCurrentUser = (RtlOpenCurrentUserPROC)libNtDll.GetProcAddress("RtlOpenCurrentUser")) != NULL)
                {
                    if (NT_SUCCESS (pfnRtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hCurrentUserKey)))
                    {                    
                        fOk = ReadMappingByRoot((HKEY)hCurrentUserKey, pszDUN, pszMapping, dwMapping, bExpandEnvStrings);
                                            
                        NtClosePROC pfnNtClose;

                        if ( (pfnNtClose = (NtClosePROC)libNtDll.GetProcAddress("NtClose")) != NULL)
                        {
                            pfnNtClose(hCurrentUserKey);
                        }
                    }
                }

            }

            MYDBGASSERT(hCurrentUserKey);
        }   
    }

    return fOk;
}

//+----------------------------------------------------------------------------
//
// Function:  StripPath
//
// Synopsis:  Helper function to deal with the tedium of extracting the filename 
//            part of a complete filename and path.
//
// Arguments: LPCTSTR pszFullNameAndPath - Ptr to the full filename with path
//
// Returns:   LPTSTR - Ptr to an allocated buffer containing the dir, or NULL on failure.
//
// Note:      It is up to the caller to provide reasonable input, the only requirement
//            is that the input contain '\'. 
//
// History:   nickball    Created    3/31/98
//
//+----------------------------------------------------------------------------
LPTSTR StripPath(LPCTSTR pszFullNameAndPath)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (NULL == pszFullNameAndPath)
    {
        return NULL;
    }

    //
    // Locate the last '\'
    //
    
    LPTSTR pszSlash = CmStrrchr(pszFullNameAndPath, TEXT('\\'));

    if (NULL == pszSlash)
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

    //
    // Return an allocated copy of the string beyond the last '\'
    //

    pszSlash = CharNextU(pszSlash);

    return (CmStrCpyAlloc(pszSlash)); 
}

//+----------------------------------------------------------------------------
//
// Function:  NotifyUserOfExistingConnection
//
// Synopsis:  Helper function to notify user that connection is either connect
//            ing or connected already.
//
// Arguments: HWND hwndParent - Hwnd of parent if any.
//            LPCM_CONNECTION pConnection - Ptr to CM_CONNECTION structure 
//                                          containing state, entry name, etc.
//            BOOL fStatus - Flag indicating the status pane should be used for display.
//
// Returns:   Nothing
//
// History:   nickball    Created Header    3/17/98
//
//+----------------------------------------------------------------------------
void NotifyUserOfExistingConnection(HWND hwndParent, LPCM_CONNECTION pConnection, BOOL fStatus)
{   
    MYDBGASSERT(pConnection);

    //
    // Test assumptions
    //

    if (NULL == pConnection)
    {
        return;
    }

    MYDBGASSERT(CM_CONNECTED == pConnection->CmState || 
                CM_CONNECTING == pConnection->CmState ||
                CM_DISCONNECTING == pConnection->CmState);

    //
    // First load the correct message based upon state
    //

    int iMsgId;

    switch (pConnection->CmState)
    {
        case CM_CONNECTED:
            iMsgId = IDMSG_ALREADY_CONNECTED;
            break;

        case CM_CONNECTING: 
            iMsgId = IDMSG_ALREADY_CONNECTING;   
            break;

        case CM_DISCONNECTING: 
            iMsgId = IDMSG_ALREADY_DISCONNECTING;   
            break;
        
        default:
            MYDBGASSERT(FALSE);
            return;
            break;
    }

    //
    // Format the message with service name
    //

    LPTSTR pszMsg = CmFmtMsg(g_hInst, iMsgId, pConnection->szEntry);

    if (pszMsg)
    {
        //
        // Display according to requested output 
        //

        if (fStatus)
        {
            AppendStatusPane(hwndParent, pszMsg);
        }
        else
        {
            MessageBoxEx(hwndParent, pszMsg, pConnection->szEntry, MB_OK|MB_ICONINFORMATION, LANG_USER_DEFAULT);
        }

        CmFree(pszMsg);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetConnection 
//
// Synopsis:  Helper routine to retrieve the connection data for the current
//            service from the connection table.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Allocated ptr to a CM_CONNECTION or NULL
//
// History:   nickball    Created    2/23/98
//
//+----------------------------------------------------------------------------
LPCM_CONNECTION GetConnection(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pArgs->pConnTable);
   
    LPCM_CONNECTION pConnection = (LPCM_CONNECTION) CmMalloc(sizeof(CM_CONNECTION));   

    if (pArgs && pArgs->pConnTable && pConnection)
    {
        //
        // Retrieve the entry
        //

        if (FAILED(pArgs->pConnTable->GetEntry(pArgs->szServiceName, pConnection)))
        {
            CmFree(pConnection);
            pConnection = NULL;
        }
    }

    return pConnection;
}

//+----------------------------------------------------------------------------
//
// Function:  SingleSpace
//
// Synopsis:  Converts multiple space chars in a string to single spaces.
//            For example: "1  206  645 7865" becomes "1 206 645 7865"
//
// Arguments: LPTSTR pszStr - The string to be examined/modified
//
// Returns:   Nothing
//
// Note:      This is a fix for the MungePhone problem on W95 where TAPI adds 
//            two spaces between the 9 and the 1 when dialing long distance 
//            with a prefix. RAID #3198
//
// History:   nickball    4/1/98    Created Header    
//            nickball    4/1/98    Relocated from cm_misc.cpp
//
//+----------------------------------------------------------------------------
void SingleSpace(LPTSTR pszStr) 
{
    LPTSTR pszTmp = pszStr;

    while (pszTmp && *pszTmp)
    {
        if (CmIsSpace(pszTmp) && CmIsSpace(pszTmp + 1))
        {
            lstrcpyU(pszTmp, (pszTmp + 1)); 
        }

        pszTmp++;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  Ip_GPPS
//
// Synopsis:  Retrieves the result of a GPPS on the specified CIni object in R
//            ASIPADDR format. Used for reading IP addresses in INI files. 
//
// Arguments: CIni *pIni - The Cini object to be used
//            LPCTSTR pszSection - String name of the section to be read
//            LPCTSTR pszEntry - String name of the entry to be read
//            RASIPADDR *pIP - Ptr to the RASIPADDR structure to be filled.
//
// Returns:   static void - Nothing
//
// History:   nickball    Created Header    8/22/98
//
//+----------------------------------------------------------------------------

void Ip_GPPS(CIni *pIni, LPCTSTR pszSection, LPCTSTR pszEntry, RASIPADDR *pIP)
{    
    LPTSTR pszTmp;
    LPTSTR pszOctet;
    RASIPADDR ip;

    MYDBGASSERT(pszSection);
    MYDBGASSERT(pszEntry);

    pszTmp = pIni->GPPS(pszSection, pszEntry);
    if (!*pszTmp) 
    {
        CmFree(pszTmp);
        return;
    }
    memset(&ip,0,sizeof(ip));
    pszOctet = pszTmp;
    ip.a = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet != '.') 
    {
        CmFree(pszTmp);
        return;
    }
    pszOctet++;
    ip.b = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet != '.') 
    {
        CmFree(pszTmp);
        return;
    }
    pszOctet++;
    ip.c = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet != '.') 
    {
        CmFree(pszTmp);
        return;
    }
    pszOctet++;
    ip.d = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet) 
    {
        CmFree(pszTmp);
        return;
    }
    
    memcpy(pIP,&ip,sizeof(ip));
    CmFree(pszTmp);
    return;
}

//+----------------------------------------------------------------------------
//
// Function:  CopyGPPS
//
// Synopsis:  Copies the result of a GPPS call on the specified INI object to 
//            the buffer specified in pszBuffer.
//
// Arguments: CIni *pIni - Ptr to the CIni object to be used.
//            LPCTSTR pszSection - String name the section to be read
//            LPCTSTR pszEntry - String name of the entry to be read
//            LPTSTR pszBuffer - The buffer to be filled with the result
//            size_t nLen - The size of the buffer to be filled
//
// Returns:   static void - Nothing
//
// History:   nickball    Created Header    8/22/98
//
//+----------------------------------------------------------------------------
void CopyGPPS(CIni *pIni, LPCTSTR pszSection, LPCTSTR pszEntry, LPTSTR pszBuffer, size_t nLen) 
{
    // REVIEW:  Doesn't check input params

    LPTSTR pszTmp;

    pszTmp = pIni->GPPS(pszSection, pszEntry);
    if (*pszTmp) 
    {
        lstrcpynU(pszBuffer, pszTmp, nLen);
    }
    CmFree(pszTmp);
}

//
// From ras\ui\common\nouiutil\noui.c
//

CHAR HexChar(IN BYTE byte)

    /* Returns an ASCII hexidecimal character corresponding to 0 to 15 value,
    ** 'byte'.
    */
{
    const CHAR* pszHexDigits = "0123456789ABCDEF";

    if (byte >= 0 && byte < 16)
        return pszHexDigits[ byte ];
    else
        return '0';
}

//
// From ras\ui\common\nouiutil\noui.c
//

BYTE HexValue(IN CHAR ch)

    /* Returns the value 0 to 15 of hexadecimal character 'ch'.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )((ch - 'A') + 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )((ch - 'a') + 10);
    else
        return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  StripCanonical
//
// Synopsis:  Simple helper to strip canonical formatting codes from a phone number
//            Obviously the number is assumed to be in canonical format.
//
// Arguments: LPTSTR pszSrc - the string to be modifed
//
// Returns:   Nothing
//
// History:   nickball      09/16/98     Created 
//
//+----------------------------------------------------------------------------
void StripCanonical(LPTSTR pszSrc)
{
    MYDBGASSERT(pszSrc);
    MYDBGASSERT(pszSrc);
    
    if (NULL == pszSrc || !*pszSrc)
    {
        return;
    }
    //
    // eg. +1 (425) 555 5555
    //
    
    LPTSTR pszNext = CharNextU(pszSrc);

    if (pszNext)
    {
        lstrcpyU(pszSrc, pszNext);
    
        //
        // eg. 1 (425) 555 5555
        //

        LPTSTR pszLast = CmStrchr(pszSrc, TEXT('('));

        if (pszLast)
        {
            pszNext = CharNextU(pszLast);
            
            if (pszNext)
            {
                lstrcpyU(pszLast, pszNext);         

                //
                // eg. 1 425) 555 5555  
                //

                pszLast = CmStrchr(pszSrc, TEXT(')'));

                if (pszLast)
                {
                    pszNext = CharNextU(pszLast);

                    if (pszNext)
                    {
                        lstrcpyU(pszLast, pszNext);                             
                    }
                }

                // 
                // eg. 1 425 555 5555
                //
            }
        }           
    }                       
}

//+----------------------------------------------------------------------------
//
// Function:  StripFirstElement
//
// Synopsis:  Simple helper to strip the substring prior to the first space in 
//            a string
//
// Arguments: LPTSTR pszSrc - the string to be modifed
//
// Returns:   Nothing
//
// History:   nickball      09/16/98     Created 
//
//+----------------------------------------------------------------------------
void StripFirstElement(LPTSTR pszSrc)
{
    MYDBGASSERT(pszSrc);
    MYDBGASSERT(pszSrc);
       
    if (pszSrc && *pszSrc)
    {
        LPTSTR pszSpace = CmStrchr(pszSrc, TEXT(' '));
        
        if (pszSpace && *pszSpace)
        {
            LPTSTR pszTmp = CharNextU(pszSpace);
            
            if (pszTmp && *pszTmp)
            {
                lstrcpyU(pszSrc, pszTmp);
            }
        }
    }
}   

//+----------------------------------------------------------------------------
//
// Function:  FrontExistingUI
//
// Synopsis:  Fronts existing UI for a given profile connect or settings attempt
// 
// Arguments: CConnectionTable *pConnTable  - ptr to connection table if any.
//            LPTSTR pszServiceName         - the long service name
//            BOOL fConnect                 - flag indicating that the request is for connect
//
// Note:      Caller is required to ensure that there is not an existing 
//            (non-logon) window with the same service names as the title.
//
// Returns:   TRUE if we fronted anything
//
//+----------------------------------------------------------------------------
BOOL FrontExistingUI(CConnectionTable *pConnTable, LPCTSTR pszServiceName, BOOL fConnect)
{
    LPTSTR pszPropTitle = GetPropertiesDlgTitle(pszServiceName);
    HWND hwndProperties = NULL;
    HWND hwndLogon = NULL;
    HWND hwndFront = NULL;
    BOOL bRet = FALSE;
    BOOL fLaunchProperties = FALSE;

    //
    // First look for a properties dialog
    // 

    if (pszPropTitle)
    {
        hwndProperties = FindWindowExU(NULL, NULL, WC_DIALOG, pszPropTitle);
    }
    
    CmFree(pszPropTitle);   

    //
    // Now see if we have a logon dialog up
    //
       
    hwndLogon = FindWindowExU(NULL, NULL, c_pszIconMgrClass, pszServiceName);
    
    //
    // Assume the common case, then consider the alternative scenarios.
    // 

    hwndFront = hwndLogon ? hwndLogon : hwndProperties;

    //
    // Note: There is an ambiguous case in which both UIs are up, but aren't 
    // related, in which case we front according to the requested action.
    //

    if (hwndLogon && hwndProperties)
    {
        //
        // We have both dialogs up, if the logon owns the properties dialog
        // or the request is for a properties display, we'll front properties. 
        //

        if (hwndLogon == GetParent(hwndProperties) || !fConnect)
        {
            hwndFront = hwndProperties;
        }
    }
    
    //
    // If we have a window handle, front it
    //

    if (hwndFront)
    {
        CMTRACE(TEXT("FrontExistingUI - Fronting existing connect instance UI"));

        SetForegroundWindow(hwndFront);

        bRet = TRUE;

        //
        // If the request is for properties, and there is a logon UI, but no
        // properties, we want to launch the properties UI from the logon UI
        // programmatically.
        //

        if (!fConnect && !hwndProperties) // fLaunchProperties)
        {
            if (pConnTable)
            {
                CM_CONNECTION Connection;
                ZeroMemory(&Connection, sizeof(CM_CONNECTION));
             
                //
                // Don't launch in the middle of connecting, etc.
                //

                if (FAILED(pConnTable->GetEntry(pszServiceName, &Connection)))
                {
                    PostMessageU(hwndLogon, WM_COMMAND, MAKEWPARAM(IDC_MAIN_PROPERTIES_BUTTON, 0), (LPARAM)0);
                }
            }
        }
    }   
    
    return bRet;
}

#if 0 // NT 301988
/*

//+----------------------------------------------------------------------------
//
// Function:  IsAnotherInstanceRunning
//
// Synopsis:  Check to see if another instance of the same profile running.
//
// Arguments: CConnectionTable *pConnTable - ptr to the connection table
//            LPTSTR pszServiceName - the long service name
//            DWORD  dwFlags - the application flags FL_*
//
// Returns:   Nothing
//
//+----------------------------------------------------------------------------
BOOL IsAnotherInstanceRunning(
    CConnectionTable    *pConnTable,
    LPCTSTR             pszServiceName,
    DWORD               dwFlags
)
{
    BOOL   fRet;
    HWND   hwnd;
    LPTSTR pszPropTitle;

    //
    // first look for the Properties dialog
    //
    if (!(pszPropTitle = GetPropertiesDlgTitle(pszServiceName)))
    {
        return FALSE;
    }

    fRet = TRUE;
    
    if (!(hwnd = FindWindowEx(NULL, NULL, WC_DIALOG, pszPropTitle)))
    {
        //
        // now look for the main dialog.  We make sure that the window returned
        // is really the main dialog, not the Status dialog.  Since the parent of
        // the main dialog is the desktop, we can tell by making sure the parent 
        // of the window returned is the desktop window.
        //
        if ((hwnd = FindWindowEx(NULL, NULL, WC_DIALOG, pszServiceName)) &&
            (GetWindow(hwnd, GW_OWNER) && GetWindow(hwnd, GW_OWNER) != GetDesktopWindow()))
        {
            hwnd = NULL;
        }
    }

    CmFree(pszPropTitle);


    BOOL          fEntryExists;
    CM_CONNECTION Connection;

    ZeroMemory(&Connection, sizeof(CM_CONNECTION));
    fEntryExists = pConnTable && SUCCEEDED(pConnTable->GetEntry(pszServiceName, &Connection));

    if (hwnd)
    {
        CMTRACE(TEXT("Found a previous instance of the same profile."));

        SetForegroundWindow(hwnd);

        //
        // if we're connecting, the "Properties" button is disabled and so we don't bring
        // up the properties dialog.  We don't want to do this also during disconnection
        // and reconnecting.
        //

        if (dwFlags & FL_PROPERTIES && 
            (!fEntryExists ||
             fEntryExists            &&
             Connection.CmState != CM_CONNECTING &&
             Connection.CmState != CM_RECONNECTPROMPT))
        {
            CMTRACE(TEXT("Bringing up the Properties dialog from the previous instance..."));
            //
            // try to bring up the properties dialog of the first instance
            //
            PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDC_MAIN_PROPERTIES_BUTTON, 0), (LPARAM)0);
        }
    }
    else
    {
        //
        // During disconnect and reconnect, we don't want to pop up either the main or the 
        // properties dlg.  However, we want to let cmdial run if the Reconnect prompt is gone
        // and the this is a reconnect request from CMMON
        //

        if (fEntryExists && 
            (Connection.CmState == CM_DISCONNECTING         || 
             Connection.CmState == CM_RECONNECTPROMPT       && 
             dwFlags & FL_PROPERTIES))
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;
        }
    }

    return fRet;
}   
*/
#endif

LPTSTR GetPropertiesDlgTitle(
    LPCTSTR pszServiceName
)
{
    LPTSTR pszTmp = NULL;
    LPTSTR pszTitle = NULL;

    //
    // first look for the Properties dialog
    //
    if (!(pszTmp = CmLoadString(g_hInst, IDS_PROPERTIES_SUFFIX)))
    {
        return NULL;
    }
    if (!(pszTitle = CmStrCpyAlloc(pszServiceName)))
    {
        CmFree(pszTmp);
        return NULL;
    }
    if (!CmStrCatAlloc(&pszTitle, pszTmp))
    {
        CmFree(pszTmp);
        CmFree(pszTitle);
        return NULL;
    }

    CmFree(pszTmp);
    return pszTitle;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPPTPMsgId
//
// Synopsis:  Simple helper to determine appropriate PPTP msg based on OS cfg.
//
// Arguments: None
//
// Returns:   Integer ID of resource string
//
// History:   nickball      12/07/98     Created 
//
//+----------------------------------------------------------------------------
int GetPPTPMsgId(void)
{
    int nID;

    if (OS_NT) 
    {
        //
        // We need to tell the user to re-apply the service pack after manual
        // install of PPTP if they have one.
        //

        if (IsServicePackInstalled())
        {
            nID =   IDMSG_NEED_PPTP_NT_SP;
        }
        else
        {
            nID = IDMSG_NEED_PPTP_NT; // NT w/o SP
        }
    }
    else 
    {
        nID = IDMSG_NEED_PPTP_WIN95;
            
    }

    return nID;
}

//+----------------------------------------------------------------------------
//  Function    IsServicePackInstalled
//
//  Synopsis    Checks the CSDVersion key in the registry to see if a service
//              pack is installed on this machine
//
//  Arguments   None
//
//  Returns     TRUE if service pack (any SP) is installed
//              FALSE if no service pack is installed
//
//  History     2/4/98  VetriV  Created     
//-----------------------------------------------------------------------------
BOOL IsServicePackInstalled(void)
{
    TCHAR szBuffer[MAX_PATH] = {TEXT("\0")};
    HKEY hkey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);
    
    if (ERROR_SUCCESS == RegOpenKeyExU(HKEY_LOCAL_MACHINE, 
                                       c_pszRegCurrentVersion, 
                                       0,
                                       KEY_READ,
                                       &hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueExU(hkey,
                                              c_pszRegCsdVersion,
                                              NULL,
                                              &dwType,
                                              (LPBYTE)szBuffer,
                                              &dwSize))
        {
            if (szBuffer[0] != TEXT('\0'))
            {
                RegCloseKey(hkey);
                return TRUE;
            }
        }

        RegCloseKey(hkey);
    }

    
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  RegisterWindowClass
//
// Synopsis:  Encapsulates registration of window class
//
// Arguments: HINSTANCE hInst - Hinst of DLL
//
// Returns:   DWORD - GetLastError
//
// History:   nickball    Created Header    6/3/99
//
//+----------------------------------------------------------------------------
DWORD RegisterWindowClass(HINSTANCE hInst)
{
    WNDCLASSEXA wc;
    ZeroMemory(&wc, sizeof(wc));
    
    if (GetClassInfoExA(NULL,(LPSTR)WC_DIALOG,&wc))
    {
        //
        // Convert to Ansi before calling Ansi forms of APIs. We use the 
        // Ansi forms because GetClassInfoEx cannot be readily wrapped.
        //
    
        LPSTR pszClass = WzToSzWithAlloc(c_pszIconMgrClass);
    
        if (!pszClass)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wc.lpszClassName = pszClass;
        wc.cbSize = sizeof(wc);
        wc.hInstance = hInst;

        if (!RegisterClassExA(&wc)) 
        {
            DWORD dwError = GetLastError();

            CMTRACE1(TEXT("RegisterWindowClass() RegisterClassEx() failed, GLE=%u."), dwError);

            //
            // Only fail if the class does not already exist
            //

            if (ERROR_CLASS_ALREADY_EXISTS != dwError)
            {
                CmFree(pszClass);
                return dwError;
            }
        }      
    
        CmFree(pszClass);
    }
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  UnRegisterWindowClass
//
// Synopsis:  Encapsulates un-registering window class
//
// Arguments: HINSTANCE hInst - Hinst of DLL
//
// Returns:   BOOL - result of UnregsiterClass
//
// History:   nickball    Created Header    6/3/99
//
//+----------------------------------------------------------------------------
BOOL UnRegisterWindowClass(HINSTANCE hInst)
{
    return UnregisterClassU(c_pszIconMgrClass, g_hInst);   
}

//+----------------------------------------------------------------------------
//
// Function:  IsActionEnabled
//
// Synopsis:  checks Registry to see if a command is allowed to run
//
// Arguments: CONST WCHAR *pszProgram         - Name of program to be executed
//            CONST WCHAR *pszServiceName     - Long service name
//            CONST WCHAR *pszServiceFileName - Full path to Service file
//            LPDWORD lpdwLoadType            - Ptr to be filled with load type
//
// Returns:   TRUE if action is allowed @ this time
//
// Notes:     Checks SOFTWARE\Microsoft\Connection Manager\<ServiceName>
//             Under which you will have the Values for each command
//              0 - system32 directory
//              1 - profile directory
//
// History:   v-vijayb    Created Header    07/20/99
//            nickball    Revised           07/27/99
//
//+----------------------------------------------------------------------------
BOOL IsActionEnabled(CONST WCHAR *pszProgram, 
                     CONST WCHAR *pszServiceName, 
                     CONST WCHAR *pszServiceFileName,
                     LPDWORD lpdwLoadType)
{
    HKEY        hKey;
    DWORD       dwLoadFlags, cb;
    BOOL        fIsAllowed = FALSE;
    WCHAR       szSubKey[MAX_PATH + 1];
    WCHAR       szBaseName[MAX_PATH + 1];
    WCHAR       szPath[MAX_PATH + 1];
    WCHAR       *pszTmp;

    MYDBGASSERT(pszProgram && pszServiceName && pszServiceFileName && lpdwLoadType);

    if (NULL == pszProgram ||
        NULL == pszServiceName ||
        NULL == pszServiceFileName ||
        NULL == lpdwLoadType)
    {
        return FALSE;
    }

    *lpdwLoadType = -1;

    if (!IsLogonAsSystem())
    {
        return (TRUE);
    }

    MYDBGASSERT(OS_NT);

    lstrcpyW(szPath, pszProgram);

    //
    // Check for extension. We don't allow anything that doesn't have an extension.
    //
    
    pszTmp = CmStrrchrW(szPath, TEXT('.'));
    if (pszTmp == NULL)
    {
        return (FALSE);
    }

    //
    // Get Basename 
    //
    
    pszTmp = CmStrrchrW(szPath, TEXT('\\'));
    if (pszTmp)
    {
        lstrcpyW(szBaseName, CharNextW(pszTmp));
        *pszTmp = TEXT('\0');
    }
    else
    {
        lstrcpyW(szBaseName, pszProgram);
    }

    lstrcpyW(szSubKey, L"SOFTWARE\\Microsoft\\Connection Manager\\");
    lstrcatW(szSubKey, pszServiceName);
    lstrcatW(szSubKey, L"\\WinLogon Actions");

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &hKey) )
    {
        cb = sizeof(dwLoadFlags);
        if (ERROR_SUCCESS == RegQueryValueExW(hKey, szBaseName, NULL, NULL, (PBYTE) &dwLoadFlags, &cb))
        {
            switch (dwLoadFlags)
            {
                case 0: // system32 directory only

                    //
                    // No paths in this case, .CMS entry should match key name
                    //
                    
                    if (0 == lstrcmpiW(szBaseName, szPath))
                    {
                        fIsAllowed = TRUE;
                        *lpdwLoadType = dwLoadFlags;
                    }
                    
                    break;

                case 1: // profile directory only

                    //
                    // Get servicename path
                    //

                    pszTmp = CmStripFileNameW(pszServiceFileName, FALSE);
                    
                    if (pszTmp && 0 == lstrcmpiW(pszTmp, szPath))
                    {
                        fIsAllowed = TRUE;
                        *lpdwLoadType = dwLoadFlags;
                    }

                    CmFree(pszTmp);

                    break;

                default:    // invalid flag
                    CMTRACE1(TEXT("IsActionEnabled() - Invalid LoadFlags %d"), dwLoadFlags);
                    goto OnError;
                    break;
            }

        }

OnError:
        RegCloseKey(hKey);
    }


    if (fIsAllowed == FALSE)
    {
        CMTRACE1W(L"IsActionEnabled(returned FALSE) %s", pszProgram);
    }

    return (fIsAllowed);
}

//+----------------------------------------------------------------------------
//
// Function:  ApplyPasswordHandlingToBuffer
//
// Synopsis:  Convert password: all upper case, all lower case, or no conversion
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            LPTSTR pszBuffer      - Buffer to be modified
//
// Returns:   Nothing 
//
// Note:      Available types are: PWHANDLE_LOWER, PWHANDLE_UPPER, PWHANDLE_NONE:
//
// History:   nickball    Created          03/03/00
//
//+----------------------------------------------------------------------------
void ApplyPasswordHandlingToBuffer(ArgsStruct *pArgs, 
                                   LPTSTR pszBuffer)
{    
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszBuffer);

    if (NULL == pArgs || NULL == pszBuffer)
    {
        return;
    }
        
    CIni *piniService = GetAppropriateIniService(pArgs, pArgs->nDialIdx);

    if (piniService)
    {
        switch (piniService->GPPI(c_pszCmSection, c_pszCmEntryPasswordHandling)) 
        {
            case PWHANDLE_LOWER:
                CharLowerU(pszBuffer);
                break;

            case PWHANDLE_UPPER:
                CharUpperU(pszBuffer);
                break;

            case PWHANDLE_NONE:
            default:
                break;
        }
    }

    delete piniService;
}

//+----------------------------------------------------------------------------
//
// Function:  ApplyDomainHandlingToDialParams
//
// Synopsis:  Handles the messy details of Domain management relative to username
//            Returns a buffer containing the original buffer and (if appropriate) 
//            the domain prepended. 
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            CIni *piniService     - Ptr to the Cini object to be used
//            LPTSTR pszBuffer      - Ptr to the current buffer to which we'll prepend
//
// Returns:   LPTSTR                -  
//
// History:   nickball    Created          03/04/00
//
//+----------------------------------------------------------------------------
LPTSTR ApplyDomainPrependToBufferAlloc(ArgsStruct *pArgs, 
                                       CIni *piniService, 
                                       LPTSTR pszBuffer, 
                                       LPCTSTR pszDunName)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(piniService);
    MYDBGASSERT(pszBuffer);
    MYDBGASSERT(pszDunName);

    if (NULL == pArgs || NULL == piniService || NULL == pszBuffer || NULL == pszDunName)
    {
        return NULL;
    }

    BOOL bPrependDomain = FALSE;

    //
    // Prepare the user name. We may need to pre-pend the domain
    //
       
    if (*pArgs->szDomain)
    {       
        //
        // There is a domain, see if pre-pending is explicitly set in the
        // DUN setting for this connection.
        //
        LPTSTR pszDunEntry = NULL;
        LPTSTR pszPreviousSection = NULL;

        if (pszDunName && *pszDunName)
        {
            pszDunEntry = CmStrCpyAlloc(pszDunName);
        }
        else
        {
            pszDunEntry = GetDefaultDunSettingName(piniService, FALSE); // FALSE == fTunnelEntry, never called from DoTunnelDial
        }
        
        MYDBGASSERT(pszDunEntry);

        if (pszDunEntry)
        {
            //
            //  Since we are going to call SetSection on piniService to set it up
            //  to retrieve the DUN setting name, we should save the existing value
            //  before we overwrite it.
            //
            pszPreviousSection = CmStrCpyAlloc(piniService->GetSection());
            MYDBGASSERT(pszPreviousSection);

            if (pszPreviousSection) // this will either be "" or the previous section name
            {
                LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));

                pszSection = CmStrCatAlloc(&pszSection, pszDunEntry);
                MYDBGASSERT(pszSection);

                piniService->SetSection(pszSection);

                CmFree(pszSection);
            }
        }

        int nTmp = piniService->GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunPrependDialupDomain, -1);    

        if (-1 == nTmp)
        {
            //
            // There is no prepend flag, so on W9X infer from the VPN scenario.
            // The inference is that if we're dialing a number that is part of
            // a VPN scenario AND its a same-name logon, then we need to prepend
            // the Domain to the user name (eg. REDMOND\username).
            //

            if (OS_W9X && pArgs->fUseTunneling && pArgs->fUseSameUserName) 
            {
                bPrependDomain = TRUE;    
            }    
        }
        else
        {           
            bPrependDomain = (BOOL) nTmp;
        }

        //
        //  Restore the previous section to piniService to as not to have a function side effect.
        //
        if (pszPreviousSection)
        {
            piniService->SetSection(pszPreviousSection);
            CmFree(pszPreviousSection);        
        }

        CmFree(pszDunEntry);
    }

    //
    // Build username as required
    //

    LPTSTR pszName = NULL;

    if (bPrependDomain)
    {
        pszName = CmStrCpyAlloc(pArgs->szDomain);        
        CmStrCatAlloc(&pszName, TEXT("\\"));
        CmStrCatAlloc(&pszName, pszBuffer);
    }   
    else
    {
        pszName = CmStrCpyAlloc(pszBuffer);
    }

    return pszName;
}


//+----------------------------------------------------------------------------
//
// Function:  GetPrefixAndSuffix
//
// Synopsis:  Handles the messy details of determining the username prefix and 
//            suffix to be used. This data varies according to whether the 
//            referencING profile has either a prefix and suffix in which case 
//            they are used against all phone #s. However, if they do not exist
//            in the referencING profile, then the prefix and suffix in the 
//            referecED profile (if any) are used.
//
// Arguments: ArgsStruct *pArgs          - Ptr to global Args struct
//            CIni *piniService          - Ptr to the Cini object to be used
//            LPTSTR *ppszUsernamePrefix - Address of pointer to be allocated
//                                         filled w/ prefix.
//            LPTSTR *ppszUsernamePrefix - Address of pointer to be allocated
//                                         filled w/ suffix.
//
// Returns:   Nothing, caller should validate output
//
// History:   nickball    Created          05/31/00
//
//+----------------------------------------------------------------------------
void GetPrefixSuffix(ArgsStruct *pArgs, CIni* piniService, LPTSTR *ppszUsernamePrefix, LPTSTR *ppszUsernameSuffix)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(piniService);
    MYDBGASSERT(ppszUsernameSuffix);
    MYDBGASSERT(ppszUsernamePrefix);

    if (NULL == pArgs || NULL == piniService || NULL == ppszUsernamePrefix || NULL == ppszUsernameSuffix)
    {
        return;
    }   
    
    //
    // If the referencING (top-level) service file includes a prefix or suffix,
    // then we'll use it. Otherwise, we'll use the realm from the service file 
    // associated with the phone book from which the user selected the POP.
    //

    LPTSTR pszTmpPrefix = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryUserPrefix);
    LPTSTR pszTmpSuffix = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryUserSuffix);   

    //
    // Thus, if both prefix and suffix are empty and this is a referencED profile 
    // and the user has selected a phone # from a referenced pbk, we'll retrieve 
    // the data from the referencED service file.
    //
    
    if (pszTmpPrefix && pszTmpSuffix)
    {
        if (!*pszTmpPrefix && !*pszTmpSuffix)
        {
            if (pArgs->fHasRefs && 
                lstrcmpiU(pArgs->aDialInfo[pArgs->nDialIdx].szPhoneBookFile, pArgs->piniService->GetFile()) != 0) 
            {
                if (pszTmpPrefix)
                {
                    CmFree(pszTmpPrefix);
                }

                if (pszTmpSuffix)
                {
                    CmFree(pszTmpSuffix);
                }
                pszTmpPrefix = piniService->GPPS(c_pszCmSection, c_pszCmEntryUserPrefix);
                pszTmpSuffix = piniService->GPPS(c_pszCmSection, c_pszCmEntryUserSuffix);
            }
        }
    }

    *ppszUsernamePrefix = pszTmpPrefix;
    *ppszUsernameSuffix = pszTmpSuffix;
}

//+----------------------------------------------------------------------------
//
// Function:  ApplyPrefixSuffixToBufferAlloc
//
// Synopsis:  Handles the messy details of Domain management relative to username
//            Updates the the RasDialParams as appropriate.
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            CIni *piniService     - Ptr to the Cini object to be used
//            LPTSTR pszBuffer      - Ptr to current buffer to which we'll apply
//                                    suffix and prefix data.
//
// Returns:   A new buffer allocation containing the original buffer
//            with applied suffix and prefix data. 
//
// Note:      The CIni object is expected to be that associated with the current
//            number. In other words, that returned by GetApporpriateIniService
//
// History:   nickball    Created          03/04/00
//            nickball    GetPrefixSuffix  05/31/00
//
//+----------------------------------------------------------------------------

LPTSTR ApplyPrefixSuffixToBufferAlloc(ArgsStruct *pArgs, 
                                      CIni *piniService, 
                                      LPTSTR pszBuffer)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(piniService);
    MYDBGASSERT(pszBuffer);

    if (NULL == pArgs || NULL == piniService || NULL == pszBuffer)
    {
        return NULL;
    }
   
    LPTSTR pszUsernamePrefix = NULL;
    LPTSTR pszUsernameSuffix = NULL;

    GetPrefixSuffix(pArgs, piniService, &pszUsernamePrefix, &pszUsernameSuffix);

    //
    // Don't double prepend the prefix if there is one. User may have
    // provided a fully qualified name including realm prefix. 
    // (eg. MSN/user)
    //

    if (*pszUsernamePrefix)
    {
        DWORD dwBufferLen = lstrlenU(pszBuffer);
        DWORD dwPrefixLen = lstrlenU(pszUsernamePrefix);

        if (dwBufferLen > dwPrefixLen)
        {
            TCHAR cReplacedChar = pszBuffer[dwPrefixLen];
            pszBuffer[dwPrefixLen] = TEXT('\0');

            if (0 == lstrcmpiU(pszBuffer, pszUsernamePrefix))
            {
                //
                //  The prefix has already been prepended.  Let's clear out
                //  the pszUsernamePrefix field.
                //
                *pszUsernamePrefix = TEXT('\0');
            }

            pszBuffer[dwPrefixLen] = cReplacedChar;
        }
    }

    CmStrCatAlloc(&pszUsernamePrefix, pszBuffer);

    //
    // Don't double append the suffix if there is one. User may have
    // provided a fully qualified name including domain suffix. 
    // (eg. user@ipass.com)
    //

    if (*pszUsernameSuffix)
    {
        DWORD dwSuffixLen = lstrlenU(pszUsernameSuffix);
        DWORD dwUserNameLen = lstrlenU(pszUsernamePrefix);

        //
        //  Make sure the total username is longer than the suffix itself,
        //  otherwise we have no change of a double append.  If it is longer than
        //  the suffix length, go ahead and make sure we aren't appending the suffix
        //  twice.
        //
        if (dwSuffixLen && (dwSuffixLen < dwUserNameLen))
        {
            if (0 == lstrcmpiU(&(pszUsernamePrefix[dwUserNameLen - dwSuffixLen]), pszUsernameSuffix))
            {
                *pszUsernameSuffix = TEXT('\0');
            }
        }
    }

    CmStrCatAlloc(&pszUsernamePrefix, pszUsernameSuffix);
    
    CmFree(pszUsernameSuffix);

    //
    // pszUsernamePrefix now contains the final product
    //

    return pszUsernamePrefix;    
}

//+----------------------------------------------------------------------------
//
// Function:  InBetween
//
// Synopsis:  Simple function which returns TRUE if the passed in number is
//            in between the given lower and upper bounds.  Note that the
//            boundaries themselves are considered in bounds.
//
// Arguments: int iLowerBound - lower bound
//            int iNumber - number to test
//            int iUpperBound - upper bound
//
// Returns:   TRUE if the number is equal to either of the boundaries or in between
//            the two numbers.  Note that if the lower and upper boundary numbers
//            are backwards it will always return FALSE.
//
//
// History:   quintinb    Created          07/24/00
//
//+----------------------------------------------------------------------------
BOOL InBetween(int iLowerBound, int iNumber, int iUpperBound)
{
    return ((iLowerBound <= iNumber) && (iUpperBound >= iNumber));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\wsock.cpp ===
//+----------------------------------------------------------------------------
//
// File:     wsock.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the winsock related CM code.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt     created         03/??/98
//           quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "winsock.h"
#include "tunl_str.h"

///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////

typedef int (PASCAL FAR *PFN_WSAStartup)(WORD, LPWSADATA);
typedef int (PASCAL FAR *PFN_WSACleanup)(void);
typedef struct hostent FAR * (PASCAL FAR *PFN_gethostbyname)(const char FAR * name);

///////////////////////////////////////////////////////////////////////////////////
// func prototypes
///////////////////////////////////////////////////////////////////////////////////

BOOL InvokeGetHostByName(
    ArgsStruct  *pArgs
);

BOOL BuildDnsTunnelList(
    ArgsStruct      *pArgs,
    struct hostent  *pHe
);

BOOL BuildRandomTunnelIndex(
    ArgsStruct      *pArgs,
    DWORD           dwCount
);

///////////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//	Function:	TryAnotherTunnelDnsAddress
//
//	Synopsis:	see if there's another dns address associated with the current
//              tunnel name.  if so, set that address in primary or extended
//              tunnel ip properly.
//
//	Arguments:	pArgs               ptr to ArgsStruct
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------

BOOL TryAnotherTunnelDnsAddress(
    ArgsStruct  *pArgs
)
{
    MYDBGASSERT(pArgs);

    //
    // RAS does all this for us on NT5, so bail out now.
    //

    if (NULL == pArgs || OS_NT5)
    {
        return FALSE;
    }

    //
    // if the list of tunnel ip addrs is empty, let's resolve the dns name
    // and see if there are other addrs behind the dns name.
    //
    if (!pArgs->pucDnsTunnelIpAddr_list)
    {
        if (!InvokeGetHostByName(pArgs))
        {
            return FALSE;
        }
    }

    MYDBGASSERT(pArgs->pucDnsTunnelIpAddr_list);

    if (pArgs->uiCurrentDnsTunnelAddr == pArgs->dwDnsTunnelAddrCount - 1)
    {
        //
        // we've run out of addrs in the list.
        //

        //
        // we need to destroy the list
        //
        CmFree(pArgs->pucDnsTunnelIpAddr_list);
        pArgs->pucDnsTunnelIpAddr_list = NULL;

        CmFree(pArgs->rgwRandomDnsIndex);
        pArgs->rgwRandomDnsIndex = NULL;

        pArgs->uiCurrentDnsTunnelAddr = 0;
        pArgs->dwDnsTunnelAddrCount = 0;

        //
        // If we're currently using the primary tunnel server, we need to 
        // restore it since we overwrote it.
        //

        LPTSTR pszTunnelIp = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);

        if (lstrlenU(pszTunnelIp) > RAS_MaxPhoneNumber) 
        {
            pszTunnelIp[0] = TEXT('\0');
        }

        pArgs->SetPrimaryTunnel(pszTunnelIp);
        CmFree(pszTunnelIp);

        return FALSE;
    }

    //
    // try the next ip addr in the list
    //
    TCHAR   szAddr[16];     // xxx.xxx.xxx.xxx
    unsigned char *puc;

    pArgs->uiCurrentDnsTunnelAddr++;

    puc = pArgs->pucDnsTunnelIpAddr_list + pArgs->rgwRandomDnsIndex[pArgs->uiCurrentDnsTunnelAddr]*4;

    wsprintfU(szAddr, TEXT("%hu.%hu.%hu.%hu"),
             *puc,
             *(puc+1),
             *(puc+2),
             *(puc+3));

    CMTRACE1(TEXT("TryAnotherTunnelDnsAddress: found ip addr %s for the tunnel server"), szAddr);

    pArgs->SetPrimaryTunnel(szAddr);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//	Function:	InvokeGetHostByName
//
//	Synopsis:	call gethostbyname and sets up internal ipaddr list.
//
//	Arguments:	pArgs               ptr to ArgsStruct
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------
BOOL InvokeGetHostByName(
    ArgsStruct  *pArgs
)
{
    HINSTANCE           hInst;
    PFN_WSAStartup      pfnWSAStartup;
    PFN_WSACleanup      pfnWSACleanup = NULL;
    PFN_gethostbyname   pfngethostbyname;
    WSADATA             wsaData;
    struct hostent      *pHe;
    BOOL                fOk = FALSE;
#ifdef UNICODE
    LPSTR pszHostName;
    DWORD dwSize;
#endif
    //
    // the list's gotta be empty
    //
    MYDBGASSERT(!pArgs->pucDnsTunnelIpAddr_list);

    MYVERIFY(hInst = LoadLibraryExA("wsock32.dll", NULL, 0));

    if (!hInst) 
    {
        return FALSE;
    }

    if (!(pfnWSAStartup = (PFN_WSAStartup)GetProcAddress(hInst, "WSAStartup")))
    {
        goto exit;
    }

    if (pfnWSAStartup(MAKEWORD(1, 1), &wsaData))
    {
        goto exit;
    }

    pfnWSACleanup = (PFN_WSACleanup)GetProcAddress(hInst, "WSACleanup");

    if (!(pfngethostbyname = (PFN_gethostbyname)GetProcAddress(hInst, "gethostbyname")))
    {
        goto exit;
    }

#ifdef UNICODE

    pszHostName = WzToSzWithAlloc(pArgs->GetTunnelAddress());

    if (pszHostName)
    {
        pHe = pfngethostbyname(pszHostName);
        CmFree(pszHostName);

        if (!pHe)
        {
            goto exit;
        }
    }
    else
    {
        goto exit;
    }

#else
    if (!(pHe = pfngethostbyname(pArgs->GetTunnelAddress())))
    {
        goto exit;
    }
#endif

    if (BuildDnsTunnelList(pArgs, pHe))
    {
        fOk = TRUE;
    }

exit:

    if (pfnWSACleanup)
    {
        pfnWSACleanup();
    }

    if (hInst)
    {
        FreeLibrary(hInst);
    }

    return fOk;
}



//+---------------------------------------------------------------------------
//
//	Function:	BuildDnsTunnelList
//
//	Synopsis:	Build a tunnel address list.
//
//	Arguments:	pArgs   ptr to ArgsStruct
//              pHe     a ptr to hostent(returned by gethostbyname()).
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------
BOOL BuildDnsTunnelList(
    ArgsStruct      *pArgs,
    struct hostent  *pHe
)
{
    DWORD   dwCnt;

    //
    // see how many addrs we have
    //
    for (dwCnt=0; pHe->h_addr_list[dwCnt]; dwCnt++)
        ;

    if (dwCnt < 2)
    {
        return FALSE;
    }

    //
    // if we have more than one addrs, save the list.
    //
    pArgs->dwDnsTunnelAddrCount = dwCnt;

    if (!(pArgs->pucDnsTunnelIpAddr_list = (unsigned char *)CmMalloc(dwCnt*pHe->h_length)))
    {
        CMTRACE(TEXT("InvokeGetHostByName: failed to alloc tunnel addr list"));
        return FALSE;
    }

    for (dwCnt=0; dwCnt<pArgs->dwDnsTunnelAddrCount; dwCnt++)
    {
        CopyMemory(pArgs->pucDnsTunnelIpAddr_list + dwCnt*pHe->h_length,
                   pHe->h_addr_list[dwCnt],
                   pHe->h_length);
    }

    pArgs->uiCurrentDnsTunnelAddr = 0;

    //
    // we need a random list.  With this, we can get a random addr in constant
    // time(and fast).  see cmtools\getips.
    //
    if (!BuildRandomTunnelIndex(pArgs, dwCnt))
    {
        CmFree(pArgs->pucDnsTunnelIpAddr_list);
        pArgs->pucDnsTunnelIpAddr_list = NULL;
        return FALSE;
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//	Function:	BuildRandomTunnelIndex
//
//	Synopsis:	Build a list random indices.  With this, we can get a random 
//              addr in constant time(and fast).  see cmtools\getips.
//
//	Arguments:	pArgs   ptr to ArgsStruct
//              dwCount # of of indices
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------

BOOL BuildRandomTunnelIndex(
    ArgsStruct      *pArgs,
    DWORD           dwCount
)
{
    DWORD   i, j;
    PWORD   rgwIndex;
    WORD    wTmp;

    //
    // we can only have at most 65536 ip addrs(the max. range of a WORD), which is plenty.
    //
    MYDBGASSERT((dwCount > 1) && (dwCount <= 65536));

    if (!(pArgs->rgwRandomDnsIndex = (PWORD)CmMalloc(sizeof(WORD)*dwCount)))
    {
        return FALSE;
    }

    //
    // now start build the random indices...
    //
    for (i=0, rgwIndex=pArgs->rgwRandomDnsIndex; i<dwCount; i++)
    {
        rgwIndex[i] = (WORD)i;
    }

#ifdef  DEBUG
    {
        unsigned char *puc;
        TCHAR   szAddr[16];     // xxx.xxx.xxx.xxx

        CMTRACE2(TEXT("BuildRandomTunnelIndex: BEFORE randomization(server=%s, count=%u):"), 
                 pArgs->GetTunnelAddress(), dwCount);
    
        for (i=0; i<dwCount; i++)
        {
            puc = pArgs->pucDnsTunnelIpAddr_list + i*4;
            wsprintfU(szAddr, TEXT("%hu.%hu.%hu.%hu"),
                     *puc,
                     *(puc+1),
                     *(puc+2),
                     *(puc+3));
            CMTRACE2(TEXT("%u: %s"), i, szAddr);
        }
    }
#endif

    //
    // If we only have 2 addrs, the first address has already been used by RAS, 
    // there's no need to randomize the list.  We'll just use the 2nd addr.
    //
    if (dwCount == 2)
    {
        return TRUE;
    }

    CRandom r;

    //
    // randomize the indices.  skip the first entry.
    //
    for (i=1; i<dwCount; i++)
    {
        do 
        {
            //
            // j has to be non-zero(to leave the 0-th entry untouhced).
            //
            j = r.Generate() % dwCount;
        } while (!j);

        if (i != j)
        {
            wTmp = rgwIndex[i];
            rgwIndex[i] = rgwIndex[j];
            rgwIndex[j] = wTmp;
        }
    }

#ifdef  DEBUG
    {
        unsigned char *puc;
        TCHAR   szAddr[16];     // xxx.xxx.xxx.xxx

        CMTRACE2(TEXT("BuildRandomTunnelIndex: AFTER randomization(server=%s, count=%u):"), 
                 pArgs->GetTunnelAddress(), dwCount);
    
        for (i=0; i<dwCount; i++)
        {
            puc = pArgs->pucDnsTunnelIpAddr_list + rgwIndex[i]*4;
            wsprintfU(szAddr, TEXT("%hu.%hu.%hu.%hu"),
                      *puc,
                      *(puc+1),
                      *(puc+2),
                      *(puc+3));
            CMTRACE2(TEXT("%u: %s"), i, szAddr);
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdial\help\cmmgr32.h ===
/* Copyright (c) 1998 Microsoft Corporation */
/* Help ID mapping for Connection Manager 32-bit Help topics */
/* Help file = cmmgr32.hlp */
/* If you make a change to this file, be sure to notify your help author and/or your lead developer.*/


/* Topic that the Help button goes to */
#define ICM_TRB                     0001

/* Logon dialog */
#define IDH_LOGON_NAME              1002
#define IDH_LOGON_PSWD              1003
#define IDH_LOGON_NEW               4010
#define IDH_LOGON_DOMAIN            3090
#define IDH_LOGON_AUTOCONN          2006
#define IDH_LOGON_SVCMSG            1008
#define IDH_LOGON_CONNECT_STAT      1005
#define IDH_LOGON_CONNECT           1006
#define IDH_LOGON_PROPERTIES        1007
#define IDH_LOGON_CANCEL            1010
#define IDH_LOGON_SAVEPW            1012
#define IDH_LOGON_SAVEFORALL        1014
#define IDH_LOGON_SAVEFORME         1015

// Access Points --logon dialog - Help ID for the Accesspoints combo box
#define IDH_LOGON_ACCESSPOINTS      1013

/* Connections Status dialog box */
#define IDH_STATUS_DISCONNECT       1011

/* Connections Properties dialog--General tab */
#define IDH_GENERAL_ALREADY         8002
#define IDH_GENERAL_DIALTHIS        8003
#define IDH_GENERAL_PHONENUM        2000
#define IDH_GENERAL_PHONEBOOK       2001
#define IDH_GENERAL_PHONEBOOKB      2005
#define IDH_GENERAL_BACKUPNUM       2002
#define IDH_GENERAL_DIALRULE        2003
#define IDH_GENERAL_USE_DIAL_RULE   4020
#define IDH_GENERAL_USE_DIAL_RULEB  4021
#define IDH_GENERAL_CONNECT_MODEM   2004

// Access Points -- General tab
#define IDH_GENERAL_NEWAP           4022    // New button
#define IDH_GENERAL_DELETEAP        4023    // Delete button
#define IDH_GENERAL_ACCESSPOINTS    4024    // Access points combo box

/* Connection Properties dialog--Options tab */
#define IDH_OPTIONS_IDLEDIS         2010
#define IDH_OPTIONS_REDIAL          2020
#define IDH_OPTIONS_LOGGING         2030
#define IDH_OPTIONS_CLEAR_LOG       2040
#define IDH_OPTIONS_VIEW_LOG        2050

/* Connections Properties dialog--Internet Logon tab */
#define IDH_INTERNET_PASSWORD       2060
#define IDH_INTERNET_USER_NAME      2070
#define IDH_INTERNET_SAVEPASS       2080

/* Connection Properties dialog--VPN tab */
#define IDH_VPN_SELECTOR            2100

/* Phone Book dialog */
#define IDH_PHONEBOOK_SERVICETYP    3000
#define IDH_PHONEBOOK_COUNTRY       3001
#define IDH_PHONEBOOK_STATEREG      3002
#define IDH_PHONEBOOK_ACCESSNUMS    3003
#define IDH_PHONEBOOK_MORENUMS      3005
#define IDH_PHONEBOOK_SVCMSG        3006

/*Retry Dialog */
#define IDH_RETRY_REMEMBER          2501
#define IDH_RETRY_USERNAME_STATIC   2502
#define IDH_RETRY_USERNAME          2503
#define IDH_RETRY_PASSWORD_STATIC   2504
#define IDH_RETRY_PASSWORD          2505
#define IDH_RETRY_DOMAIN_STATIC     2506
#define IDH_RETRY_DOMAIN            2507
#define IDH_RETRY_OK                2508
#define IDH_RETRY_CANCEL            2509

/*Button IDs */
#define IDH_CMHELP                  4000
#define IDH_DETAILS                 6020
#define IDH_OK_CONNECTED            6030
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\cmfdi.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmfdi.cpp
//
// Module:   CMDL32.EXE
//
// Synopsis: CFdi class implementations
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#include <fcntl.h>
#include <sys\stat.h>

const TCHAR* const c_pszExeFile  =  TEXT("PBUPDATE.EXE");    // for detecting itExeInCab
const TCHAR* const c_pszInfFile  =  TEXT("PBUPDATE.INF");    // for detecting itInfInCab
const TCHAR* const c_pszVerFile  =  TEXT("PBUPDATE.VER");    // version string in .CAB
const TCHAR* const c_pszPbr      =  TEXT("PBR");            // regions file extension

//
// CFDIFile Implementation
//

CFDIFile::~CFDIFile() 
{
    // nothing
}

DWORD CFDIFile::Read(LPVOID pv, DWORD cb) 
{
    return 0;
}

DWORD CFDIFile::Write(LPVOID pv, DWORD cb) 
{
    return 0;
}

long CFDIFile::Seek(long dist, int seektype)
{
    return 0;
}

int CFDIFile::Close()
{
    return 0;
}

HANDLE CFDIFile::GetHandle() 
{
    return (INVALID_HANDLE_VALUE);
}

//
// CFDIFileFile Implementation
//

CFDIFileFile::CFDIFileFile() 
{

    m_hFile = INVALID_HANDLE_VALUE;
}


CFDIFileFile::~CFDIFileFile() 
{

    if (m_hFile != INVALID_HANDLE_VALUE) {
        MYDBG(("CFDIFileFile::~CFDIFileFile() destructor called while file still open."));
        Close();
    }
}


BOOL CFDIFileFile::CreateFile(LPCTSTR pszFile,
                              DWORD dwDesiredAccess,
                              DWORD dwShareMode,
                              DWORD dwCreationDistribution,
                              DWORD dwFlagsAndAttributes,
                              DWORD dwFileSize) 
{
    // Make sure the files isn't in use
    
    if (m_hFile != INVALID_HANDLE_VALUE) 
    {
        MYDBG(("CFDIFileFile::CreateFile() file is already open."));
        SetLastError(ERROR_OUT_OF_STRUCTURES);
        return (FALSE);
    }
    
    // Open Create/Open the file
    
    m_hFile = ::CreateFile(pszFile,dwDesiredAccess,dwShareMode,NULL,dwCreationDistribution,dwFlagsAndAttributes,NULL);
    if (m_hFile == INVALID_HANDLE_VALUE) 
    {
        MYDBG(("CFDIFileFile::CreateFile() CreateFile(pszFile=%s,dwDesiredAccess=%u,dwShareMode=%u,dwCreationDistribution=%u,dwFlagsAndAttributes=%u) failed, GLE=%u.",
               pszFile,dwDesiredAccess,dwShareMode,dwCreationDistribution,dwFlagsAndAttributes,GetLastError()));
        return (FALSE);
    }
    
    // If dwFileSize is specified, move the pointer by dwFileSize bytes 
    
    if (dwFileSize) 
    {
        BOOL bRes;
        DWORD dwRes;
        dwRes = SetFilePointer(m_hFile,dwFileSize,NULL,FILE_BEGIN);
        MYDBGTST(dwRes==INVALID_SET_FILE_POINTER ,("CFDIFileFile::CreateFile() SetFilePointer() failed, GLE=%u.",GetLastError()));
        
        // If that worked, set the end of file at the file pointer position
        
        if (dwRes != INVALID_SET_FILE_POINTER) 
        {
            bRes = SetEndOfFile(m_hFile);
            MYDBGTST(!bRes,("CFDIFileFile::CreateFile() SetEndOfFile() failed, GLE=%u.",GetLastError()));
        }
        
        // Reset the file pointer to the beginning
        
        if ((dwRes != INVALID_SET_FILE_POINTER ) && bRes) 
        {
            dwRes = SetFilePointer(m_hFile,0,NULL,FILE_BEGIN);
            MYDBGTST(dwRes==INVALID_SET_FILE_POINTER ,("CFDIFileFile::CreateFile() SetFilePointer() failed, GLE=%u.",GetLastError()));
        }
        
        // Close the file and bail if we failed the above 
        
        if ((dwRes == INVALID_SET_FILE_POINTER ) || !bRes) 
        {
            bRes = CloseHandle(m_hFile);
            MYDBGTST(!bRes,("CFDIFileFile::CreateFile() CloseHandle() failed, GLE=%u.",GetLastError()));
            m_hFile = INVALID_HANDLE_VALUE;
            return (-1);
        }       
    }
    
    return (TRUE);
}


BOOL CFDIFileFile::CreateUniqueFile(LPTSTR pszFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes) 
{
    DWORD dwIdx;
    TCHAR szFile[MAX_PATH+1];

    if (m_hFile != INVALID_HANDLE_VALUE) {
        MYDBG(("CFDIFileFile::CreateUniqueFile() file is already open."));
        SetLastError(ERROR_OUT_OF_STRUCTURES);
        return (FALSE);
    }
    dwIdx = 0;
    while (1) {
        wsprintf(szFile,"%08u.tmp",dwIdx);
        m_hFile = ::CreateFile(szFile,dwDesiredAccess,dwShareMode,NULL,CREATE_NEW,dwFlagsAndAttributes,NULL);
        if (m_hFile != INVALID_HANDLE_VALUE) {
            break;
        }
        if (IsErrorForUnique(GetLastError(), szFile)) {
            MYDBG(("CFDIFileFile::CreateUniqueFile() CreateFile() failed, GLE=%u.",GetLastError()));
            return (FALSE);
        }
        dwIdx++;
    }
    lstrcpy(pszFile,szFile);
    return (TRUE);
}


DWORD CFDIFileFile::Read(LPVOID pv, DWORD cb) 
{
    BOOL bRes;
    DWORD dwRes;

    bRes = ReadFile(m_hFile,pv,cb,&dwRes,NULL);
    if (!bRes) {
        MYDBG(("CFDIFileFile::Read() ReadFile() failed, GLE=%u.",GetLastError()));
        return ((UINT) -1);
    }
    return (dwRes);
}


DWORD CFDIFileFile::Write(LPVOID pv, DWORD cb) 
{
    BOOL bRes;
    DWORD dwRes;

    bRes = WriteFile(m_hFile,pv,cb,&dwRes,NULL);
    if (!bRes) {
        MYDBG(("CFDIFileFile::Write() WriteFile() failed, GLE=%u.",GetLastError()));
        return ((UINT) -1);
    }
    return (dwRes);
}


long CFDIFileFile::Seek(long dist, int seektype) 
{
    DWORD dwRes;

    dwRes = SetFilePointer(m_hFile,dist,NULL,seektype);
    if (dwRes == INVALID_SET_FILE_POINTER) {
        MYDBG(("CFDIFileFile::Seek() SetFilePointer() failed, GLE=%u.",GetLastError()));
        return (-1);
    }
    return ((long) dwRes);
}


int CFDIFileFile::Close() 
{
    BOOL bRes;

    bRes = CloseHandle(m_hFile);
    if (!bRes) {
        MYDBG(("CFDIFileFile::Close() CloseHandle() failed, GLE=%u.",GetLastError()));
        return (-1);
    }
    m_hFile = INVALID_HANDLE_VALUE;
    return (0);
}


HANDLE CFDIFileFile::GetHandle() 
{
    return (m_hFile);
}

//
// FDI wrapper routines
//

void HUGE * FAR DIAMONDAPI fdi_alloc(ULONG cb) 
{
    return (CmMalloc(cb));
}

void FAR DIAMONDAPI fdi_free(void HUGE *pv) 
{
    CmFree(pv);
}

INT_PTR FAR DIAMONDAPI fdi_open(char FAR *pszFile, int oflag, int pmode) 
{
    TCHAR szTempFileName[MAX_PATH+1];
    DWORD dwDesiredAccess;
    DWORD dwShareMode = FILE_SHARE_READ;
    DWORD dwCreationDistribution;
    DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
    DWORD dwFileSize = 0;
    DWORD dwRes;
    BOOL bRes;

    CFDIFileFile *pfff = NULL;

    pfff = new CFDIFileFile;
    if (!pfff) {
        MYDBG(("fdi_open() new CFDIFileFile failed."));
        return (-1);
    }

    switch (oflag & (_O_RDONLY|_O_WRONLY|_O_RDWR)) {

        case _O_RDONLY:
            dwDesiredAccess = GENERIC_READ;
            break;

        case _O_WRONLY:
            dwDesiredAccess = GENERIC_WRITE;
            break;

        case _O_RDWR:
            dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
            break;

        default:
            MYDBG(("fdi_open() invalid read/write flags, oflag=%u.",oflag));
            delete pfff;
            return (-1);
    }
    if (oflag & _O_CREAT) {
        if (!(pmode & _S_IWRITE)) {
            dwFlagsAndAttributes |= FILE_ATTRIBUTE_READONLY;
        }
    }
    if (oflag & (_O_CREAT | _O_EXCL)) {
        dwCreationDistribution = CREATE_NEW;
    } else if (oflag & (_O_CREAT | _O_TRUNC)) {
        dwCreationDistribution = CREATE_ALWAYS;
    } else if (oflag & _O_CREAT) {
        dwCreationDistribution = OPEN_ALWAYS;
    } else if (oflag & _O_TRUNC) {
        dwCreationDistribution = TRUNCATE_EXISTING;
    } else {
        dwCreationDistribution = OPEN_EXISTING;
    }
    if (*pszFile == '*') {
        PFDISPILLFILE pfsf = (PFDISPILLFILE) pszFile;
        TCHAR szTempPath[MAX_PATH+1];                                      

        ZeroMemory(szTempPath,sizeof(szTempPath));
        ZeroMemory(szTempFileName,sizeof(szTempFileName));
        dwRes = GetTempPath(sizeof(szTempPath)/sizeof(TCHAR)-1,szTempPath);
        MYDBGTST(!dwRes,("fdi_open() GetTempPath() failed, GLE=%u.",GetLastError()));
        
        dwRes = GetTempFileName(szTempPath,TEXT("ctf"),0,szTempFileName);
        MYDBGTST(!dwRes,("fdi_open() GetTempFileName() failed, GLE=%u.",GetLastError()));
        MYDBGTST(!dwRes,("fdi_open() GetTempFileName() failed, GLE=%u.",GetLastError()));
        pszFile = szTempFileName;
        dwFileSize = pfsf->cbFile;
        dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE;
    }
    bRes = pfff->CreateFile(pszFile,dwDesiredAccess,dwShareMode,dwCreationDistribution,dwFlagsAndAttributes,dwFileSize);

    if (!bRes) {
        delete pfff;
        return (-1);
    }                 
    
    return ((INT_PTR)pfff);    
}

UINT FAR DIAMONDAPI fdi_read(INT_PTR hf, void FAR *pv, UINT cb) 
{
        return (((CFDIFile *) hf)->Read(pv,cb));
}

UINT FAR DIAMONDAPI fdi_write(INT_PTR hf, void FAR *pv, UINT cb) 
{
    return (((CFDIFile *) hf)->Write(pv,cb));
}

long FAR DIAMONDAPI fdi_seek(INT_PTR hf, long dist, int seektype) 
{
    return (((CFDIFile *) hf)->Seek(dist,seektype));
}

int FAR DIAMONDAPI fdi_close(INT_PTR hf) 
{
    int nRes;

    CFDIFile *pff = (CFDIFile *) hf;
    nRes = pff->Close();
    delete pff;
    return (nRes);
}

INT_PTR FAR DIAMONDAPI fdi_notify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin) 
{
    NotifyArgs *pnaArgs = (NotifyArgs *) pfdin->pv;
    BOOL bRes;

    switch (fdint) 
    {
        case fdintCOPY_FILE: 
        {
            InstallType itType;
            TCHAR szTmp[MAX_PATH+1];
            LPTSTR  pszExt;         // file extension
            PFILEPROCESSINFO pFPI;

            MYDBG(("fdi_notify() fdint=fdintCOPY_FILE, psz1=%s, cb=%u.",pfdin->psz1,pfdin->cb));
            if (lstrlen(pnaArgs->pdaArgs->szCabDir)+lstrlen(pfdin->psz1)+1>sizeof(szTmp)/sizeof(TCHAR)-1) 
            {
                MYDBG(("fdi_notify() szCabDir=%s+pszFile=%s exceeds MAX_PATH.",pnaArgs->pdaArgs->szCabDir,pfdin->psz1));
                return (-1);
            }
            lstrcpy(szTmp,pnaArgs->pdaArgs->szCabDir);
        
            if (szTmp[0] && (GetLastChar(szTmp) != '\\')) 
            {
                lstrcat(szTmp,TEXT("\\"));
            }
            lstrcat(szTmp,pfdin->psz1);
            
            if (!(pnaArgs->dwAppFlags & AF_NO_EXEINCAB) && (lstrcmpi(pfdin->psz1,c_pszExeFile) == 0)) 
            {
                //
                // Its a .EXE, note the fact for later processing
                //

                itType = itInvalid;  // currently an invalid type

                pnaArgs->pdaArgs->fContainsExeOrInf = TRUE;
            } 
            else if (!(pnaArgs->dwAppFlags & AF_NO_INFINCAB) && (lstrcmpi(pfdin->psz1,c_pszInfFile) == 0)) 
            {
                //
                // Its a .INF, note the fact for later processing
                //

                itType = itInvalid;  // currently an invalid type

                pnaArgs->pdaArgs->fContainsExeOrInf = TRUE;
            } 
            else if (!(pnaArgs->dwAppFlags & AF_NO_PBDINCAB) && (lstrcmpi(pfdin->psz1,c_pszPbdFile) == 0)) 
            {
                //
                // Its a .PBD, note the fact for later processing
                //
                itType = itPbdInCab;
            } 
            else if ((pszExt = CmStrchr(pfdin->psz1, TEXT('.'))) && (lstrcmpi(pszExt+1, c_pszPbk) == 0)) 
            {
                *pszExt = TEXT('\0');
                // if the PBK is not for this service, we don't use it.
                if (lstrcmpi(pfdin->psz1, pnaArgs->pdaArgs->pszPhoneBookName) != 0)
                {
                    itType = itInvalid;
                }
                else 
                {
                    itType = itPbkInCab;
                }
                // restore the filename
                *pszExt = TEXT('.');
            } 
            else if ((pszExt = CmStrchr(pfdin->psz1, TEXT('.'))) && (lstrcmpi(pszExt+1, c_pszPbr) == 0)) 
            {
                *pszExt = TEXT('\0');
                // if the PBR is not for this service, we don't use it.
                if (lstrcmpi(pfdin->psz1, pnaArgs->pdaArgs->pszPhoneBookName) != 0)
                {
                    itType = itInvalid;
                }
                else 
                {
                    itType = itPbrInCab;
                }
                // restore the filename
                *pszExt = TEXT('.');
                
                // save the name in pdaArgs

                // if (!(pnaArgs->pdaArgs->pszNewPbrFile = CmStrCpyAlloc(pfdin->psz1))) 
                // {
                //     MYDBG((TEXT("fdi_notify(): CmStrCpyAlloc for pszNewPbrFile failed.")));
                //     return -1;
                // }
            } 
            else if (lstrcmpi(pfdin->psz1, c_pszVerFile) == 0)
            {
                // a version file - we don't process it.  We'll read the version in fdintCLOSE_FILE_INFO
                itType = itInvalid;
            }
            else 
            {
                itType = itInvalid;
            }
            
            // create a file process info.  add one to the existing list.
            if (itType != itInvalid) 
            {
                if (!pnaArgs->pdaArgs->rgfpiFileProcessInfo) 
                    pFPI = (PFILEPROCESSINFO)CmMalloc(sizeof(FILEPROCESSINFO));
                else
                    pFPI = (PFILEPROCESSINFO)CmRealloc(pnaArgs->pdaArgs->rgfpiFileProcessInfo,
                                (pnaArgs->pdaArgs->dwNumFilesToProcess+1)*sizeof(FILEPROCESSINFO));
                
                if (!pFPI) 
                {
                    MYDBG((TEXT("fdi_notify(): Malloc(FILEPROCESSINFO) failed.")));
                    return -1;
                }

                pnaArgs->pdaArgs->rgfpiFileProcessInfo = pFPI;
                pnaArgs->pdaArgs->dwNumFilesToProcess++;
                pFPI[pnaArgs->pdaArgs->dwNumFilesToProcess-1].itType = itType;
                pFPI[pnaArgs->pdaArgs->dwNumFilesToProcess-1].pszFile = CmStrCpyAlloc(pfdin->psz1);
            }

            // Do standard fdintCOPY_FILE processing, create the file and return the handle
        
            CFDIFileFile *pfff;

            pfff = new CFDIFileFile;
            if (!pfff) 
            {
                MYDBG(("fdi_notify() new CFDIFileFile failed."));
                return (-1);
            }
            bRes = pfff->CreateFile(szTmp,GENERIC_WRITE,FILE_SHARE_READ,CREATE_NEW,FILE_ATTRIBUTE_NORMAL,0);
            if (!bRes) 
            {
                delete pfff;
                return (-1);
            }
    
            return ((INT_PTR)pfff);    
        }

        case fdintCLOSE_FILE_INFO: 
        {
            int iRes;
            TCHAR szTmp[MAX_PATH+1];

            // Append file name to cab dir
            
            lstrcpy(szTmp,pnaArgs->pdaArgs->szCabDir);
            if (szTmp[0] && (GetLastChar(szTmp) != '\\')) 
            {
                lstrcat(szTmp,TEXT("\\"));
            }
            lstrcat(szTmp,pfdin->psz1);

            // Set the date and time to the original file time not the current time
            
            FILETIME ftTmp;
            FILETIME ftTime;

            bRes = DosDateTimeToFileTime(pfdin->date,pfdin->time,&ftTmp);
            MYDBGTST(!bRes,("fdi_notify() DosDateTimeToFileTime(%u,%u) failed, GLE=%u.",pfdin->date,pfdin->time,GetLastError()));
            
            bRes = LocalFileTimeToFileTime(&ftTmp,&ftTime);
            MYDBGTST(!bRes,("fdi_notify() LocalFileTimeToFileTime() failed, GLE=%u.",GetLastError()));
            
            bRes = SetFileTime(((CFDIFile *) (pfdin->hf))->GetHandle(),&ftTime,&ftTime,&ftTime);
            MYDBGTST(!bRes,("fdi_notify() SetFileTime() failed, GLE=%u.",GetLastError()));

            iRes = fdi_close(pfdin->hf);   

            // If this is the version file, get the version number

            if (lstrcmpi(pfdin->psz1,c_pszVerFile) == 0) 
            {
                pnaArgs->pdaArgs->pszVerNew = GetVersionFromFile(szTmp);
            }                               

            // Set file attributes according to original file attribs

            bRes = SetFileAttributes(szTmp,pfdin->attribs);
            MYDBGTST(!bRes,("fdi_notify() SetFileAttributes(%s,%u) failed, GLE=%u.",szTmp,pfdin->attribs,GetLastError()));
                        
            return ((iRes==0)?TRUE:FALSE);
        }

        case fdintNEXT_CABINET:
            MYDBG(("fdi_notify_scan() spanning cabinets is not supported."));
            return (-1);

        default:
            MYDBG(("fdi_notify_scan() fdint=%u.",fdint));
            break;
    }
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\cmdl.h ===
//+----------------------------------------------------------------------------
//
// File:         cmdl.h
//
// Module:       CMDL32.EXE
//
// Synopsis: Header file for common definitions
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:       nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------

#ifndef _CMDL_INC
#define _CMDL_INC

#include <windows.h>
#include <ras.h>
#include <raserror.h>
#include <windowsx.h>

#ifdef  WIN32_LEAN_AND_MEAN
#include <shellapi.h>
#endif

#include <stdlib.h>                                                                          
#include <ctype.h>
#include <tchar.h>

//#define ISBU_VERSION                          "6.0.1313.0\0"          /* VERSIONINFO string */

#include <commctrl.h>
#include <wininet.h>

#include <stdio.h>
#include <io.h>

#include "base_str.h"
#include "dl_str.h"
#include "mgr_str.h"
#include "pbk_str.h"
#include "log_str.h"
#include "cm_def.h"
#include "resource.h"
#include "cm_phbk.h"
#include "cmdebug.h"
#include "cmutil.h"
#include "cmlog.h"
#include "mutex.h"
#include "cmfdi.h"
#include "util.h"
#include "pnpuverp.h"
#include "inetopt.h"


#define BUFFER_LENGTH           (8*1024)                                                                                // buffer length for i/o
#define DEFAULT_DELAY           (2*60)                                                                                  // default delay before downloading, in seconds
#define DEFAULT_HIDE            (-1)                   // default number of milliseconds to keep window hidden

const TCHAR* const c_pszPbdFile =  TEXT("PBUPDATE.PBD");    // for detecting itPbdInCab

#define IDX_INETTHREAD_HANDLE   0               // must be *first*
#define IDX_EVENT_HANDLE        1

#define HANDLE_COUNT            2

extern "C" __declspec(dllimport) HRESULT WINAPI PhoneBookLoad(LPCSTR pszISP, DWORD_PTR *pdwPB);
extern "C" __declspec(dllimport) HRESULT WINAPI PhoneBookUnload(DWORD_PTR dwPB);
extern "C" __declspec(dllimport) HRESULT WINAPI PhoneBookMergeChanges(DWORD_PTR dwPB, LPCSTR pszChangeFile);

typedef enum _EventType {
        etDataBegin,
        etDataReceived,
        etDataEnd,
        etInstall,
        etDone,
        etICMTerm
} EventType;


// Values for dwAppFlags
#define AF_NO_DELETE            0x0001                  // does not delete file(s) on exit
#define AF_NO_INSTALL           0x0002                  // downloads and verifies, but does not install
#ifdef DEBUG
#define AF_NO_VERIFY            0x0004                  // bypasses WinVerifyTrust() - only available in DEBUG builds
#endif
#define AF_NO_PROFILE           0x0008                  // no profile on command line (and hence must use AF_URL, and no phone book delta support)
#define AF_URL                  0x0010                  // URL on command line (in next token) instead of in profile->service
#define AF_NO_EXE               0x0020                  // disable running of .EXEs
#define AF_NO_EXEINCAB          0x0040                  // disable running of PBUPDATE.EXE from .CAB
#define AF_NO_INFINCAB          0x0080                  // disable running of PBUPDATE.INF from .CAB
#define AF_NO_PBDINCAB          0x0100                  // disable running of PBUPDATE.PBD from .CAB
#define AF_NO_SHLINCAB          0x0200                  // disable running of first file in .CAB
#define AF_NO_VER               0x0400                  // disable updating of phone book version
//#define AF_NO_UPDATE          0x0800                  // don't do any work
#define AF_LAN                  0x1000                  // update request is over a LAN, don't look for the RAS connection before download
#define AF_VPN                  0x2000                  // this is a VPN file update request instead of a PBK update request


typedef void (*EVENTFUNC)(DWORD,DWORD,LPVOID);


// NOTE - the values in enum _InstallType are in sorted order!  Higher values have
// higher precendence.

typedef enum _InstallType {

        itInvalid = 0,  // Must be 0.
        itPbdInCab,
        itPbkInCab,
        itPbrInCab,

} InstallType;


// the info on how we process each file we find in the cab
typedef struct _FILEPROCESSINFO {
    LPTSTR      pszFile;
    InstallType itType;
} FILEPROCESSINFO, *PFILEPROCESSINFO;

// download args, one per URL(or .cms)
typedef struct _DownloadArgs {
    LPTSTR pszCMSFile;
    LPTSTR pszPbkFile;
    LPTSTR pszPbrFile;
    LPTSTR pszUrl;
    LPTSTR pszVerCurr;
    LPTSTR pszVerNew;
    LPTSTR pszPhoneBookName;
    LPURL_COMPONENTS psUrl;
    HINTERNET hInet;
    HINTERNET hConn;
    HINTERNET hReq;
    TCHAR szFile[MAX_PATH+1];
    EVENTFUNC pfnEvent;
    LPVOID pvEventParam;
    DWORD dwTransferred;
    DWORD dwTotalSize;
    BOOL bTransferOk;
    BOOL * volatile pbAbort;
    TCHAR szCabDir[MAX_PATH+1];
    BOOL fContainsExeOrInf;
    TCHAR szHostName[MAX_PATH+1];
    DWORD dwBubbledUpError;
    DWORD   dwNumFilesToProcess;
    PFILEPROCESSINFO   rgfpiFileProcessInfo;
} DownloadArgs;

typedef struct _ArgsStruct {
    HINSTANCE hInst;
    DWORD dwDownloadDelay;
    LPTSTR pszProfile;
    DWORD dwAppFlags;
    UINT nMsgId;
    HWND hwndDlg;
    DWORD dwHandles;
    HANDLE ahHandles[HANDLE_COUNT];
    DWORD dwArgsCnt;
    DownloadArgs *pdaArgs;
    BOOL bAbort;
    DWORD dwDataCompleted;
    DWORD dwDataTotal;
    DWORD dwDataStepSize;
    LPTSTR pszServiceName;
    HICON hIcon;
    HICON hSmallIcon;
    BOOL bShow;
    DWORD dwFirstEventTime;
    DWORD dwHideDelay;
    DWORD dwComplete;
    CmLogFile Log;
} ArgsStruct;

typedef struct _NotifyArgs 
{
        DWORD dwAppFlags;
        DownloadArgs *pdaArgs;
} NotifyArgs;

//
//  Function Prototypes
//
BOOL UpdateVpnFileForProfile(LPCTSTR pszCmpPath, LPCTSTR pszCmsPath, CmLogFile * pLog, BOOL bCheckConnection);
BOOL IsConnectionAlive(LPCSTR pszConnectionName);

#endif // _CMDL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//      
// Module:   CMDL32.EXE 
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:	 nickball   Created   04/08/98
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "cmdl.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\cmfdi.h ===
//+----------------------------------------------------------------------------
//
// File:	 cmfdi.h
//
// Module:	 CMDL32.EXE
//
// Synopsis: CFdi class declarations
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------
#ifndef _CMDL_FDI_INC
#define _CMDL_FDI_INC

#include <windows.h>

extern "C" 
{
	#include <diamondd.h>
}

//
// CFDIFile declaration
//

class CFDIFile 
{
	public:
		virtual ~CFDIFile();
		virtual DWORD Read(LPVOID pv, DWORD cb);
		virtual DWORD Write(LPVOID pv, DWORD cb);
		virtual long Seek(long dist, int seektype);
		virtual int Close();
		virtual HANDLE GetHandle();
};

//
// CFDIFileFile declaration
//

class CFDIFileFile : public CFDIFile 
{
	public:
		CFDIFileFile();
		~CFDIFileFile();
		BOOL CreateFile(LPCTSTR pszFile,
						DWORD dwDesiredAccess,
						DWORD dwShareMode,
						DWORD dwCreationDistribution,
						DWORD dwFlagsAndAttributes,
						DWORD dwFileSize);
		BOOL CreateUniqueFile(LPTSTR pszFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes);
		virtual DWORD Read(LPVOID pv, DWORD cb);
		virtual DWORD Write(LPVOID pv, DWORD cb);
		virtual long Seek(long dist, int seektype);
		virtual int Close();
		virtual HANDLE GetHandle();
	private:
		HANDLE m_hFile;
};

//
// FDI wrapper routines
//

void HUGE * FAR DIAMONDAPI fdi_alloc(ULONG cb);

void FAR DIAMONDAPI fdi_free(void HUGE *pv);

INT_PTR FAR DIAMONDAPI fdi_open(char FAR *pszFile, int oflag, int pmode);

UINT FAR DIAMONDAPI fdi_read(INT_PTR hf, void FAR *pv, UINT cb);

UINT FAR DIAMONDAPI fdi_write(INT_PTR hf, void FAR *pv, UINT cb);

long FAR DIAMONDAPI fdi_seek(INT_PTR hf, long dist, int seektype);

int FAR DIAMONDAPI fdi_close(INT_PTR hf);

INT_PTR FAR DIAMONDAPI fdi_notify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);

#endif // _CMDL_FDI_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp     
//
// Module:   CMDL32.EXE
//
// Synopsis: Mutex class implementation.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

#ifndef UNICODE
#define CreateMutexU CreateMutexA
#else
#define CreateMutexU CreateMutexW
#endif

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   CMDL32.EXE
//
// Synopsis: Resource IDs
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------

#define IDD_MAIN            101
#define IDI_APP             102
//#define IDC_MAIN_HELP     1001
#define IDC_MAIN_PROGRESS   1002
#define IDC_MAIN_MESSAGE    1003

#define IDMSG_PERCENT_COMPLETE  1010
#define IDMSG_PBTITLE           1011

#define IDMSG_LOG_NO_UPDATE_REQUIRED    1015
#define IDMSG_LOG_FULL_UPDATE           1016
#define IDMSG_LOG_DELTA_UPDATE          1017


#define ICONNDWN_CLASS "IConnDwn Class"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//
// Module:   CMDL32.EXE
//
// Synopsis: Main source for PhoneBook download connect action
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   nickball    Created Header   04/08/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "shlobj.h"

const TCHAR* const c_pszIConnDwnMsg             =  TEXT("IConnDwn Message");                // for RegisterWindowMessage() for event messages
const TCHAR* const c_pszIConnDwnAgent           =  TEXT("Microsoft Connection Manager");    // agent for InternetOpen()
const TCHAR* const c_pszIConnDwnContent         =  TEXT("application/octet-stream");        // content type for HttpOpenRequest()

const TCHAR* const c_pszCmEntryHideDelay        = TEXT("HideDelay");
const TCHAR* const c_pszCmEntryDownloadDelay    = TEXT("DownLoadDelay");
const TCHAR* const c_pszCmEntryPbUpdateMessage  = TEXT("PBUpdateMessage");

BOOL CleanUpCMDLArgs(ArgsStruct *pasArgs);

//
//  Include the shared source code for SuppressInetAutoDial and SetInetStateConnected
//
#include "inetopt.cpp"

static BOOL CmFreeIndirect(LPVOID *ppvBuffer) 
{
    CmFree(*ppvBuffer);
    *ppvBuffer = NULL;
    return TRUE;
}

static BOOL CmFreeIndirect(LPTSTR *ppszBuffer) 
{
    return (CmFreeIndirect((LPVOID *) ppszBuffer));
}

static LPURL_COMPONENTS MyInternetCrackUrl(LPTSTR pszUrl, DWORD dwOptions) 
{
    struct _sRes 
    {
        URL_COMPONENTS sUrl;
        TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
        TCHAR szHostName[INTERNET_MAX_HOST_NAME_LENGTH+1];
        TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH+1];
        TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH+1];
        TCHAR szUrlPath[INTERNET_MAX_PATH_LENGTH+1];
        TCHAR szExtraInfo[INTERNET_MAX_PATH_LENGTH+1];
    } *psRes;
    BOOL bRes;
    UINT nIdx;
    UINT nSpaces;

    if (!pszUrl) 
    {
        MYDBG(("MyInternetCrackUrl() invalid parameter."));
        SetLastError(ERROR_INVALID_PARAMETER);
        return (NULL);
    }
    psRes = (struct _sRes *) CmMalloc(sizeof(*psRes));
    if (!psRes) 
    {
        return (NULL);
    }
    psRes->sUrl.dwStructSize = sizeof(psRes->sUrl);
    psRes->sUrl.lpszScheme = psRes->szScheme;
    psRes->sUrl.dwSchemeLength = sizeof(psRes->szScheme);
    psRes->sUrl.lpszHostName = psRes->szHostName;
    psRes->sUrl.dwHostNameLength = sizeof(psRes->szHostName);
    psRes->sUrl.lpszUserName = psRes->szUserName;
    psRes->sUrl.dwUserNameLength = sizeof(psRes->szUserName);
    psRes->sUrl.lpszPassword = psRes->szPassword;
    psRes->sUrl.dwPasswordLength = sizeof(psRes->szPassword);
    psRes->sUrl.lpszUrlPath = psRes->szUrlPath;
    psRes->sUrl.dwUrlPathLength = sizeof(psRes->szUrlPath);
    psRes->sUrl.lpszExtraInfo = psRes->szExtraInfo;
    psRes->sUrl.dwExtraInfoLength = sizeof(psRes->szExtraInfo);
    bRes = InternetCrackUrl(pszUrl,0,dwOptions,&psRes->sUrl);
    if (!bRes) 
    {
        MYDBG(("MyInternetCrackUrl() InternetCrackUrl(pszUrl=%s) failed, GLE=%u.",pszUrl,GetLastError()));
        CmFree(psRes);
        return (NULL);
    }
    
    nSpaces = 0;
    
    for (nIdx=0;psRes->szExtraInfo[nIdx];nIdx++) 
    {
        if (psRes->szExtraInfo[nIdx] == ' ') 
        {
            nSpaces++;
        }
    }
    
    if (nSpaces) 
    {
        TCHAR szQuoted[sizeof(psRes->szExtraInfo)/sizeof(TCHAR)];

        if (lstrlen(psRes->szExtraInfo)+nSpaces*2 > sizeof(psRes->szExtraInfo)/sizeof(TCHAR)-1) 
        {
            MYDBG(("MyInternetCrackUrl() quoting spaces will exceed buffer size."));
            CmFree(psRes);
            return (NULL);
        }
        
        ZeroMemory(szQuoted,sizeof(szQuoted));
        nSpaces = 0;
        
        for (nIdx=0,nSpaces=0;psRes->szExtraInfo[nIdx];nIdx++,nSpaces++) 
        {
            if (psRes->szExtraInfo[nIdx] == ' ') 
            {
                szQuoted[nSpaces++] = '%';
                szQuoted[nSpaces++] = '2';
                szQuoted[nSpaces] = '0';
            } 
            else 
            {
                szQuoted[nSpaces] = psRes->szExtraInfo[nIdx];
            }
        }
        lstrcpy(psRes->szExtraInfo,szQuoted);
    }
    return (&psRes->sUrl);
}

static BOOL DownloadFileFtp(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;

    WIN32_FIND_DATA wfdData;
    LPBYTE pbData = NULL;

    LPTSTR pszObject = (LPTSTR) CmMalloc((INTERNET_MAX_PATH_LENGTH*2) + 1);

    if (NULL == pszObject)
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;   
    }

    pdaArgs->hInet = InternetOpen(c_pszIConnDwnAgent,INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hInet) 
    {
        MYDBG(("DownloadFileFtp() InternetOpen() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    pdaArgs->hConn = InternetConnect(pdaArgs->hInet,
                                     pdaArgs->psUrl->lpszHostName,
                                     pdaArgs->psUrl->nPort,
                                     pdaArgs->psUrl->lpszUserName&&*pdaArgs->psUrl->lpszUserName?pdaArgs->psUrl->lpszUserName:NULL,
                                     pdaArgs->psUrl->lpszPassword&&*pdaArgs->psUrl->lpszPassword?pdaArgs->psUrl->lpszPassword:NULL,
                                     INTERNET_SERVICE_FTP,
                                     0,
                                     0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hConn) 
    {
        MYDBG(("DownloadFileFtp() InternetConnect(pszHostName=%s) failed, GLE=%u.",pdaArgs->psUrl->lpszHostName,GetLastError()));
        goto done;
    }
    
    lstrcpy(pszObject,pdaArgs->psUrl->lpszUrlPath);
//      lstrcat(pszObject,pdaArgs->psUrl->lpszExtraInfo);
    ZeroMemory(&wfdData,sizeof(wfdData));
    pdaArgs->hReq = FtpFindFirstFile(pdaArgs->hConn,pszObject,&wfdData,INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE,0);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hReq) 
    {
        MYDBG(("DownloadFileFtp() FtpFindFirstFile() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    
    bRes = InternetFindNextFile(pdaArgs->hReq,&wfdData);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (bRes || (GetLastError() != ERROR_NO_MORE_FILES)) 
    {
        MYDBG(("DownloadFileFtp() InternetFindNextFile() returned unexpected result, bRes=%u, GetLastError()=%u.",bRes,bRes?0:GetLastError()));
        bRes = FALSE;
        goto done;
    }
    
    InternetCloseHandle(pdaArgs->hReq);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    pdaArgs->dwTotalSize = wfdData.nFileSizeLow;
    pdaArgs->hReq = FtpOpenFile(pdaArgs->hConn,pszObject,GENERIC_READ,FTP_TRANSFER_TYPE_BINARY,0);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hReq) 
    {
        MYDBG(("DownloadFileFtp() FtpOpenFile() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    
    pbData = (LPBYTE) CmMalloc(BUFFER_LENGTH);
    
    if (!pbData) 
    {
        goto done;
    }
    
    while (1) 
    {
        DWORD dwBytesRead;
        DWORD dwBytesWritten;

        bRes = InternetReadFile(pdaArgs->hReq,pbData,BUFFER_LENGTH,&dwBytesRead);
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFtp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFtp() InternetReadFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (!dwBytesRead) 
        {
            break;
        }
        
        bRes = WriteFile(hFile,pbData,dwBytesRead,&dwBytesWritten,NULL);
    
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFtp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFtp() WriteFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (dwBytesRead != dwBytesWritten) 
        {
            MYDBG(("DownloadFileFtp() dwBytesRead=%u, dwBytesWritten=%u.",dwBytesRead,dwBytesWritten));
            SetLastError(ERROR_DISK_FULL);
            goto done;
        }
        
        pdaArgs->dwTransferred += dwBytesRead;
        
        if (pdaArgs->pfnEvent) 
        {
            pdaArgs->pfnEvent(pdaArgs->dwTransferred,pdaArgs->dwTotalSize,pdaArgs->pvEventParam);
        }
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFtp() aborted."));
            goto done;
        }
    }
    
    bRes = TRUE;

done:
    
    if (pbData) 
    {
        CmFree(pbData);
    }
    
    if (pdaArgs->hReq) 
    {
        InternetCloseHandle(pdaArgs->hReq);
        pdaArgs->hReq = NULL;
    }
    
    if (pdaArgs->hConn) 
    {
        InternetCloseHandle(pdaArgs->hConn);
        pdaArgs->hConn = NULL;
    }
    
    if (pdaArgs->hInet) 
    {
        InternetCloseHandle(pdaArgs->hInet);
        pdaArgs->hInet = NULL;
    }

    if (pszObject)
    {
        CmFree(pszObject);
    }

    return (bRes);
}

static BOOL DownloadFileFile(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;

    HANDLE hInFile = INVALID_HANDLE_VALUE;
    LPBYTE pbData = NULL;

    hInFile = CreateFile(pdaArgs->psUrl->lpszUrlPath,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFile() aborted."));
        goto done;
    }
    
    if (hInFile == INVALID_HANDLE_VALUE) 
    {
        MYDBG(("DownloadFileFile() CreateFile(pszFile=%s) failed, GLE=%u.",pdaArgs->psUrl->lpszUrlPath,GetLastError()));
        goto done;
    }
    
    pdaArgs->dwTotalSize = GetFileSize(hInFile,NULL);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFile() aborted."));
        goto done;
    }
    
    if (pdaArgs->dwTotalSize == -1) 
    {
        MYDBG(("DownloadFileFile() GetFileSize() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    
    pbData = (LPBYTE) CmMalloc(BUFFER_LENGTH);
    
    if (!pbData) 
    {
        goto done;
    }
    
    while (1) 
    {
        DWORD dwBytesRead;
        DWORD dwBytesWritten;

        bRes = ReadFile(hInFile,pbData,BUFFER_LENGTH,&dwBytesRead,NULL);
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFile() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFile() ReadFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (!dwBytesRead) 
        {
            break;
        }
        
        bRes = WriteFile(hFile,pbData,dwBytesRead,&dwBytesWritten,NULL);
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFile() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFile() WriteFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (dwBytesRead != dwBytesWritten) 
        {
            MYDBG(("DownloadFileFile() dwBytesRead=%u, dwBytesWritten=%u.",dwBytesRead,dwBytesWritten));
            SetLastError(ERROR_DISK_FULL);
            goto done;
        }
        
        pdaArgs->dwTransferred += dwBytesWritten;
        
        if (pdaArgs->pfnEvent) 
        {
            pdaArgs->pfnEvent(pdaArgs->dwTransferred,pdaArgs->dwTotalSize,pdaArgs->pvEventParam);
        }
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFile() aborted."));
            goto done;
        }
    }
    bRes = TRUE;

done:

    if (pbData) 
    {
        CmFree(pbData);
    }
    
    if (hInFile != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(hInFile);
    }

    return (bRes);
}

static BOOL DownloadFileHttp(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;
    LPBYTE pbData = NULL;
    DWORD dwTmpLen;
    DWORD dwTmpIdx;
    DWORD dwStatus;
    LPCTSTR apszContent[] = {c_pszIConnDwnContent,NULL};

    LPTSTR pszObject = (LPTSTR) CmMalloc(INTERNET_MAX_PATH_LENGTH + 1);

    if (NULL == pszObject)
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;   
    }

    pdaArgs->dwBubbledUpError = 0;

    pdaArgs->hInet = InternetOpen(c_pszIConnDwnAgent,INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0);

    //
    // Supress auto-dial calls to CM from WININET now that we have a handle
    //

    SuppressInetAutoDial(pdaArgs->hInet);

    //
    //  Make sure that WinInet isn't in offline mode
    //
    (VOID)SetInetStateConnected(pdaArgs->hInet);

    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hInet) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() InternetOpen() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }
    
    pdaArgs->hConn = InternetConnect(pdaArgs->hInet,
                                     pdaArgs->psUrl->lpszHostName,
                                     pdaArgs->psUrl->nPort,
                                     pdaArgs->psUrl->lpszUserName&&*pdaArgs->psUrl->lpszUserName?pdaArgs->psUrl->lpszUserName:NULL,
                                     pdaArgs->psUrl->lpszPassword&&*pdaArgs->psUrl->lpszPassword?pdaArgs->psUrl->lpszPassword:NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hConn) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() InternetConnect(pszHostName=%s) failed, GLE=%u.", pdaArgs->psUrl->lpszHostName, pdaArgs->dwBubbledUpError));
        goto done;
    }
    
    lstrcpy(pszObject,pdaArgs->psUrl->lpszUrlPath);
    lstrcat(pszObject,pdaArgs->psUrl->lpszExtraInfo);
    
    MYDBG(("DownloadFileHttp() - HttpOpenRequest - %s", pszObject));

    pdaArgs->hReq = HttpOpenRequest(pdaArgs->hConn,
                                    NULL,
                                    pszObject,
                                    NULL,
                                    NULL,
                                    apszContent,
                                    INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE|(pdaArgs->psUrl->nScheme==INTERNET_SCHEME_HTTPS?INTERNET_FLAG_SECURE:0),
                                    0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hReq) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() HttpOpenRequest() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }
    
    bRes = HttpSendRequest(pdaArgs->hReq,NULL,0,NULL,0);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!bRes) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() HttpSendRequest() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }

    pbData = (LPBYTE) CmMalloc(BUFFER_LENGTH);
    
    if (!pbData) 
    {
        goto done;
    }
    
    while (1) 
    {
        DWORD dwBytesRead;
        DWORD dwBytesWritten;

        bRes = InternetReadFile(pdaArgs->hReq,pbData,BUFFER_LENGTH,&dwBytesRead);
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileHttp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            pdaArgs->dwBubbledUpError = GetLastError();
            MYDBG(("DownloadFileHttp() InternetReadFile() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
            goto done;
        }
        
        if (!dwBytesRead) 
        {
            break;
        }
        
        bRes = WriteFile(hFile,pbData,dwBytesRead,&dwBytesWritten,NULL);
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileHttp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            pdaArgs->dwBubbledUpError = GetLastError();
            MYDBG(("DownloadFileHttp() WriteFile() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
            goto done;
        }
        
        if (dwBytesRead != dwBytesWritten) 
        {
            MYDBG(("DownloadFileHttp() dwBytesRead=%u, dwBytesWritten=%u.",dwBytesRead,dwBytesWritten));
            SetLastError(ERROR_DISK_FULL);
            goto done;
        }
        
        if (!pdaArgs->dwTransferred) 
        {
            dwTmpLen = sizeof(pdaArgs->dwTotalSize);
            dwTmpIdx = 0;
            bRes = HttpQueryInfo(pdaArgs->hReq,HTTP_QUERY_FLAG_NUMBER|HTTP_QUERY_CONTENT_LENGTH,&pdaArgs->dwTotalSize,&dwTmpLen,&dwTmpIdx);
            if (*(pdaArgs->pbAbort)) 
            {
                MYDBG(("DownloadFileHttp() aborted."));
                goto done;
            }
            MYDBGTST(!bRes,("DownloadFileHttp() HttpQueryInfo() failed, GLE=%u.",GetLastError()));
            if (!bRes)
            {
                pdaArgs->dwBubbledUpError = GetLastError();
            }
        }
        
        pdaArgs->dwTransferred += dwBytesRead;
        
        if (pdaArgs->pfnEvent) 
        {
            pdaArgs->pfnEvent(pdaArgs->dwTransferred,pdaArgs->dwTotalSize,pdaArgs->pvEventParam);
        }
        if (*(pdaArgs->pbAbort))
        {
            MYDBG(("DownloadFileHttp() aborted."));
            goto done;
        }
    }
    
    dwTmpLen = sizeof(dwStatus);
    dwTmpIdx = 0;
    
    bRes = HttpQueryInfo(pdaArgs->hReq,HTTP_QUERY_FLAG_NUMBER|HTTP_QUERY_STATUS_CODE,&dwStatus,&dwTmpLen,&dwTmpIdx);

    if (!bRes) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() HttpQueryInfo() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }

    switch (dwStatus) 
    {
        case HTTP_STATUS_OK:
            break;

        case HTTP_STATUS_NO_CONTENT:
        case HTTP_STATUS_BAD_REQUEST:
        case HTTP_STATUS_NOT_FOUND:
        case HTTP_STATUS_SERVER_ERROR:
        default:
            pdaArgs->dwBubbledUpError = dwStatus;
            MYDBG(("DownloadFileHttp() HTTP status code = %u.",dwStatus));
            bRes = FALSE;
            SetLastError(ERROR_FILE_NOT_FOUND);
            goto done;
    }
    bRes = TRUE;

done:

    if ((0 == pdaArgs->dwBubbledUpError) && !*(pdaArgs->pbAbort))
    {
        //
        //  If the error value hasn't been set yet, and isn't the Abort case (which
        //  is logged separately) try to get it from GetLastError().
        //
        pdaArgs->dwBubbledUpError = GetLastError();
    }

    if (pbData) 
    {
        CmFree(pbData);
    }
    
    if (pdaArgs->hReq) 
    {
        InternetCloseHandle(pdaArgs->hReq);
        pdaArgs->hReq = NULL;
    }
    
    if (pdaArgs->hConn) 
    {
        InternetCloseHandle(pdaArgs->hConn);
        pdaArgs->hConn = NULL;
    }
    
    if (pdaArgs->hInet) 
    {
        InternetCloseHandle(pdaArgs->hInet);
        pdaArgs->hInet = NULL;
    }
    
    if (bRes && (pdaArgs->dwTransferred > pdaArgs->dwTotalSize)) 
    {
        pdaArgs->dwTotalSize = pdaArgs->dwTransferred;
    }

    if (pszObject)
    {
        CmFree(pszObject);
    }
    
    return (bRes);
}

static BOOL DownloadFile(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;

    pdaArgs->psUrl = MyInternetCrackUrl((LPTSTR) pdaArgs->pszUrl,ICU_ESCAPE);
    if (!pdaArgs->psUrl) 
    {
        return (NULL);
    }
    
    switch (pdaArgs->psUrl->nScheme) 
    {
        case INTERNET_SCHEME_FTP:
            bRes = DownloadFileFtp(pdaArgs,hFile);
            break;

        case INTERNET_SCHEME_HTTP:
        case INTERNET_SCHEME_HTTPS:
            bRes = DownloadFileHttp(pdaArgs,hFile);
            break;

        case INTERNET_SCHEME_FILE:
            bRes = DownloadFileFile(pdaArgs,hFile);
            break;

        default:
            MYDBG(("DownloadFile() unhandled scheme (%u).",pdaArgs->psUrl->nScheme));
            SetLastError(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
            break;
    }

    // useful for logging
    lstrcpyn(pdaArgs->szHostName, pdaArgs->psUrl->lpszHostName, MAX_PATH);

    CmFree(pdaArgs->psUrl);
    pdaArgs->psUrl = NULL;
    return (bRes);
}

typedef struct _EventParam 
{
    ArgsStruct *pArgs;
    DWORD dwIdx;
} EventParam;

static void EventFunc(DWORD dwCompleted, DWORD dwTotal, LPVOID pvParam) 
{
    EventParam *pepParam = (EventParam *) pvParam;

    MYDBG(("EventFunc() dwCompleted=%u, dwTotal=%u.",dwCompleted,dwTotal));
    pepParam->pArgs->dwDataCompleted = dwCompleted;
    pepParam->pArgs->dwDataTotal = dwTotal;
    PostMessage(pepParam->pArgs->hwndDlg,pepParam->pArgs->nMsgId,etDataReceived,0);
}

static BOOL ProcessCabinet(DownloadArgs *pdaArgs, DWORD dwAppFlags) 
{
    BOOL    fRet = TRUE;

    if (!pdaArgs->bTransferOk) 
        return (TRUE); // If the transfer failed, just leave the install type as itInvalid.
    
    {
        HFDI hfdi;
        ERF erf;
        FDICABINETINFO info;
        BOOL bRes;
        NotifyArgs naArgs = {dwAppFlags,pdaArgs};
        
        bRes = CreateTempDir(pdaArgs->szCabDir);
    
        if (bRes) 
        {
            hfdi = FDICreate(fdi_alloc,fdi_free,fdi_open,fdi_read,fdi_write,fdi_close,fdi_seek,cpu80386,&erf);
            MYDBGTST(!hfdi,("ProcessCabinet() FDICreate() failed, fError=%u, erfOper=%u, erfType=%u.",erf.fError,erf.fError?erf.erfOper:0,erf.fError?erf.erfType:0));
            if (hfdi) 
            {
                // Open the suspected cab file 
                
                CFDIFileFile fff;
                
                bRes = fff.CreateFile(pdaArgs->szFile,GENERIC_READ,FILE_SHARE_READ,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
                if (bRes) 
                {
                    // Verify that this is in fact a cabinet file
                    bRes = FDIIsCabinet(hfdi,(INT_PTR) &fff, &info);
                    MYDBGTST(!bRes,("ProcessCabinet() FDIIsCabinet() failed, fError=%u, erfOper=%u, erfType=%u.",erf.fError,erf.fError?erf.erfOper:0,erf.fError?erf.erfType:0));
                    fff.Close();
                    if (bRes) 
                    {
                        // Do the FDI copy

                        bRes = FDICopy(hfdi,pdaArgs->szFile,TEXT(""),0,(PFNFDINOTIFY)fdi_notify,NULL,&naArgs);
                        if (!bRes) 
                        {
                            MYDBG(("ProcessCabinet() FDICopy() failed, fError=%u, erfOper=%u, erfType=%u.",erf.fError,erf.fError?erf.erfOper:0,erf.fError?erf.erfType:0));
                            //pdaArgs->itType = itInvalid;
                        }
                    }
                }

                // Destroy the FDI context
                
                bRes = FDIDestroy(hfdi);
                MYDBGTST(!bRes,("ProcessCabinet() FDIDestroy() failed."));
            }
        }
    }
    
    return fRet;
}

//
// Recursively deletes the contents of a directory(pszDir).  Changes the file 
// attributes from RO to RW if necessary.
//
static BOOL ZapDir(LPCTSTR pszDir) 
{
    HANDLE hFind = NULL;
    TCHAR szTmp[MAX_PATH+1];
    BOOL bRes;

    // If pszDir format is not appropriate, bail out

    if (!pszDir || !*pszDir || (lstrlen(pszDir)+2 > sizeof(szTmp)/sizeof(TCHAR)-1)) 
    {
        SetLastError(ERROR_BAD_PATHNAME);
        return (FALSE);
    }
    
    lstrcpy(szTmp,pszDir);

    if (GetLastChar(szTmp) != '\\') 
    {
        lstrcat(szTmp,TEXT("\\"));
    }
    
    lstrcat(szTmp,TEXT("*"));

    // Traverse directory

    WIN32_FIND_DATA wfdData;
    hFind = FindFirstFile(szTmp,&wfdData);
    MYDBGTST((hFind==INVALID_HANDLE_VALUE)&&(GetLastError()!=ERROR_FILE_NOT_FOUND)&&(GetLastError()!=ERROR_NO_MORE_FILES)&&(GetLastError()!=ERROR_PATH_NOT_FOUND),("ZapDir() FindFirstFile() failed, GLE=%u.",GetLastError()));

    if (hFind != INVALID_HANDLE_VALUE) 
    {
        while (1) 
        {
            MYDBGTST(lstrlen(pszDir)+lstrlen(wfdData.cFileName)+1 > sizeof(szTmp)/sizeof(TCHAR)-1,("ZapDir() pszDir=%s+cFileName=%s exceeds %u.",pszDir,wfdData.cFileName,sizeof(szTmp)/sizeof(TCHAR)-1));
            if (lstrlen(pszDir)+lstrlen(wfdData.cFileName)+1 <= sizeof(szTmp)/sizeof(TCHAR)-1) 
            {
                if ((lstrcmp(wfdData.cFileName,TEXT(".")) != 0) && (lstrcmp(wfdData.cFileName,TEXT("..")) != 0)) 
                {
                    lstrcpy(szTmp,pszDir);
                    if (GetLastChar(szTmp) != '\\') 
                    {
                        lstrcat(szTmp,TEXT("\\"));
                    }
                
                    lstrcat(szTmp,wfdData.cFileName);
    
                    // If the file is read-only, attrib writeable so we can delete it

                    if (wfdData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) 
                    {
                        bRes = SetFileAttributes(szTmp,wfdData.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY);
                        MYDBGTST(!bRes,("ZapDir() SetFileAttributes(szTmp=%s) failed, GLE=%u.",szTmp,GetLastError()));
                    }

                    // Found a dir entry, recurse down a level

                    if (wfdData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        ZapDir(szTmp);
                    } 
                    else 
                    {
                        bRes = DeleteFile(szTmp);
                        MYDBGTST(!bRes,("ZapDir() DeleteFile(szTmp=%s) failed, GLE=%u.",szTmp,GetLastError()));
                    }
                }
            }
            
            // Go to next file

            bRes = FindNextFile(hFind,&wfdData);
            if (!bRes) 
            {
                MYDBGTST((GetLastError()!=ERROR_FILE_NOT_FOUND)&&(GetLastError()!=ERROR_NO_MORE_FILES),("ZapDir() FindNextFile() failed, GLE=%u.",GetLastError()));
                break;
            }
        }
        
        bRes = FindClose(hFind);
        MYDBGTST(!bRes,("ZapDir() FindClose() failed, GLE=%u.",GetLastError()));
    }

    // Now that the files have been removed, delete the directory
    
    bRes = RemoveDirectory(pszDir);
    MYDBGTST(!bRes&&(GetLastError()!=ERROR_PATH_NOT_FOUND),("ZapDir() RemoveDirectory(pszDir=%s) failed, GLE=%u.",pszDir,GetLastError()));
    return (bRes);
}

//
// Executes installation of phone book update based upon download file
//

static BOOL DoInstall(ArgsStruct *pArgs, HWND hwndParent, DWORD dwAppFlags) 
{
    DWORD dwIdx;

    // If no install, we are done

    if (dwAppFlags & AF_NO_INSTALL) 
    {
        return (TRUE);
    }
    
    // For each arg, handle installation

    for (dwIdx=0;dwIdx<pArgs->dwArgsCnt;dwIdx++) 
    {
        DownloadArgs *pdaArgs;
        UINT    i;
        BOOL bInstallOk = FALSE;
        BOOL bRes = TRUE;

        pdaArgs = pArgs->pdaArgs + dwIdx;

        pdaArgs->dwBubbledUpError = 0;
        
        // Only perform if the rename worked.

        if (bRes) 
        {       
            for (i=0; i<pdaArgs->dwNumFilesToProcess; i++) 
            {
                //
                // Reset install flag for each file that is processed, 
                // otherwise a single success will cause us to interpret
                // the entire install as successful. #5887
                //
                
                bInstallOk = FALSE; 

                switch (pdaArgs->rgfpiFileProcessInfo[i].itType) 
                {
                    case itPbdInCab: // Delta phonebook file

                        // if the CAB contains an EXE or an INF, then we don't do PBD
                        if (pdaArgs->fContainsExeOrInf)
                        {
                            continue;
                        }

                        if (pdaArgs->pszCMSFile) 
                        {
                            HRESULT hRes;
                            DWORD_PTR dwPb;
                    
                            // Update the Phonebook using API calls

                            hRes = PhoneBookLoad(pdaArgs->pszCMSFile, &dwPb);

                            MYDBGTST(hRes!=ERROR_SUCCESS,("DoInstall() PhoneBookLoad(pszCMSFile=%s) failed, GLE=%u.", pdaArgs->pszCMSFile, hRes));
                            
                            if (hRes == ERROR_SUCCESS) 
                            {
                                // 
                                // Build path to delta file, to be passed to phonebook merge
                                //

                                TCHAR szPbd[MAX_PATH+1];
                                lstrcpy(szPbd, pdaArgs->szCabDir);
                                lstrcat(szPbd, TEXT("\\"));
                                lstrcat(szPbd, c_pszPbdFile);

                                hRes = PhoneBookMergeChanges(dwPb, szPbd);
                                MYDBGTST(hRes!=ERROR_SUCCESS,("DoInstall() PhoneBookMergeChanges() failed, GLE=%u.",hRes));
                                if (hRes == ERROR_SUCCESS) 
                                {
                                    bInstallOk = TRUE;
                                }
                                else
                                {
                                    pdaArgs->dwBubbledUpError = hRes;
                                }
                                
                                hRes = PhoneBookUnload(dwPb);
                                MYDBGTST(hRes!=ERROR_SUCCESS,("DoInstall() PhoneBookUnload() failed, GLE=%u.",hRes));
                            }
                            
                            if (!bInstallOk && !(dwAppFlags & AF_NO_VER)) 
                            {
                                // We currently zap the version string on any failure.  This should cause
                                // the phone book to get completely update the next time around.
                            
                                WritePrivateProfileString(c_pszCmSection,
                                                          c_pszVersion,
                                                          TEXT("0"),
                                                          pdaArgs->pszCMSFile);
                            }
                        }
                        break;

                    case itPbkInCab: // Phone book file
                    {
                        TCHAR szPbk[MAX_PATH+1];
                        
                        // if the CAB contains an EXE or an INF, then we don't do PBK
                        if (pdaArgs->fContainsExeOrInf)
                        {
                            continue;
                        }

                        lstrcpy(szPbk, pdaArgs->szCabDir);
                        lstrcat(szPbk, TEXT("\\"));
                        lstrcat(szPbk, pdaArgs->rgfpiFileProcessInfo[i].pszFile);
            
                        // Try to copy the phonebook file directly

                        if (!CopyFile(szPbk, pdaArgs->pszPbkFile, FALSE))
                        {
                            pdaArgs->dwBubbledUpError = GetLastError();
                            MYDBG((TEXT("DoInstall() itPbkInCab, CopyFile() failed, GLE=%u."), pdaArgs->dwBubbledUpError));
                        }
                        else
                        {
                            bInstallOk = TRUE;
                        }
                        break;
                    }
                    
                    case itPbrInCab: // Region file
                    {
                        TCHAR szPbr[MAX_PATH+1];
                    
                        // if the CAB contains an EXE or an INF, then we don't do PBD
                        if (pdaArgs->fContainsExeOrInf)
                        {
                            continue;
                        }
                                    
                        lstrcpy(szPbr, pdaArgs->szCabDir);
                        lstrcat(szPbr, TEXT("\\"));
                        lstrcat(szPbr, pdaArgs->rgfpiFileProcessInfo[i].pszFile);
                        
                        // Try to copy the region file directly

                        if (!CopyFile(szPbr, pdaArgs->pszPbrFile, FALSE))
                        {
                            MYDBG((TEXT("DoInstall() itPbrInCab, CopyFile() failed, GLE=%u."), GetLastError()));
                        }
                        else
                        {
                            bInstallOk = TRUE;
                        }

                        break;
                    }
                } // switch (pdaArgs->rgfpiFileProcessInfo[i].itType)
            } // for (i=0; i<pdaArgs->dwNumFilesToProcess; i++)
        } // if (bRes)

        // Update version info in CMS

        if (bInstallOk && !(dwAppFlags & AF_NO_VER) && pdaArgs->pszVerNew && pdaArgs->pszCMSFile) 
        {
            WritePrivateProfileString(c_pszCmSection,
                                      c_pszVersion,
                                      pdaArgs->pszVerNew,
                                      pdaArgs->pszCMSFile);
        }
    }
    
    return (TRUE);
}


//+----------------------------------------------------------------------------
//
// Func:    CheckFileForPBSErrors
//
// Desc:    Scan the downloaded file for PBS errors
//
// Args:    [hFile] - handle to the already opened tempfile
//
// Return:  LONG (0 = no download needed, +ve = PBS error code, -1 = other error)
//
// Notes:
//
// History: 14-Apr-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
static LONG CheckFileForPBSErrors(HANDLE hFile)
{
    LONG lRet = -1;
    
    MYDBGASSERT(hFile);

    if (hFile && (INVALID_HANDLE_VALUE != hFile))
    {
        TCHAR szFirstThree[4] = {0};
        DWORD dwBytesRead;

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        if (ReadFile(hFile, szFirstThree, 3, &dwBytesRead, NULL) &&
            (dwBytesRead >= 3))
        {
            if (0 == lstrcmpi(szFirstThree, TEXT("204")))
            {
                //
                //  "204" => no download necessary
                //
                lRet = 0;
            }
            else if (0 != CmCompareString(szFirstThree, TEXT("MSC")))
            {
                //
                //  "MSC" => we have a phonebook.  If *not* MSC, get the error number
                //
                LONG lVal = 0;
                for (int i = 0 ; i < 3; ++i)
                {
                    if ((szFirstThree[i] >= TEXT('0')) && (szFirstThree[i] <= TEXT('9')))
                    {
                        lVal = (lVal *10) + (szFirstThree[i] - TEXT('0'));
                    }
                    else
                    {
                        break;
                    }
                }

                if (lVal)
                {
                    lRet = lVal;
                }
            }
        }
    }

    return lRet;
}

//+----------------------------------------------------------------------------
//
// Function:  IsConnectionAlive
//
// Synopsis:  Gets the active RAS connection list from RasEnumConnections and
//            checks to see if the passed in Connection Name is in the list.
//            Note that because of the naming of the tunnel connectoid on Win9x
//            (connection name + Tunnel), we also check for any connections
//            that start with the connection name.  If we get this wrong, the
//            http requests will error out anyway, but we are just trying to
//            figure it out ahead of time.  The /LAN switch should be used to bypass
//            this check.
//
// Arguments: LPCSTR pszConnectionName - name of the connection to look for
//
// Returns:   BOOL - whether the connection is active or not
//
// History:   quintinb    Created Header    08/22/01
//
//+----------------------------------------------------------------------------
BOOL IsConnectionAlive(LPCSTR pszConnectionName)
{
    BOOL fConnected = FALSE; // return value
    RASCONN RasConn, *prgRasConn;
    DWORD   cb, cConnections;
    PVOID   pRasEnumMem = NULL;

    if ((NULL == pszConnectionName) || (TEXT('\0') == pszConnectionName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("IsConnectionAlive -- Invalid Connection name passed into function."));
        return FALSE;
    }

    cb = sizeof(RasConn);
    prgRasConn = &RasConn;
    prgRasConn->dwSize = cb;

    DWORD dwRes = RasEnumConnections(prgRasConn, &cb, &cConnections);
    
    if (dwRes == ERROR_BUFFER_TOO_SMALL)
    {
        pRasEnumMem = CmMalloc(cb);

        if (pRasEnumMem == NULL)
        {
            MYDBG(("IsConnectionAlive() failed. Out of memory"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {        
            prgRasConn = (RASCONN *) pRasEnumMem;
            prgRasConn[0].dwSize = sizeof(RASCONN);
        
            dwRes = RasEnumConnections(prgRasConn, &cb, &cConnections);
        }
    }

    //
    // Iterate through connections to check if our's is active
    // if there is a problem getting this list we don't abort?
    //
    if (dwRes == ERROR_SUCCESS)
    {
        DWORD iConn;
    
        PTCHAR pszTruncatedRasEntryName = NULL;
        DWORD dwServiceNameLen = 0;
        DWORD dwRasEntryNameLen = 0;
        
        dwServiceNameLen = lstrlen(pszConnectionName);
        pszTruncatedRasEntryName = (PTCHAR)CmMalloc((dwServiceNameLen + 1) * sizeof(TCHAR));

        for (iConn = 0; iConn < cConnections; iConn++)
        {
            dwRasEntryNameLen = lstrlen(prgRasConn[iConn].szEntryName);
            
            if ((dwServiceNameLen < dwRasEntryNameLen) && pszTruncatedRasEntryName)
            {
                ZeroMemory((PVOID)pszTruncatedRasEntryName, (dwServiceNameLen + 1) * sizeof(TCHAR));

                //
                // dwServiceNameLen + 1 to copy the null character
                //
                lstrcpyn(pszTruncatedRasEntryName, prgRasConn[iConn].szEntryName, dwServiceNameLen + 1);
                
                if (lstrcmpi(pszConnectionName, pszTruncatedRasEntryName) == 0)
                {
                    fConnected = TRUE;
                    break;
                }
            }
            else
            {
                if (lstrcmpi(pszConnectionName, prgRasConn[iConn].szEntryName) == 0)
                {
                    fConnected = TRUE;
                    break;
                }
            }
        }

        CmFree(pszTruncatedRasEntryName);
        pszTruncatedRasEntryName = NULL;
    }

    if (pRasEnumMem != NULL)
    {
        CmFree(pRasEnumMem);
    }

    return fConnected;
}

//static unsigned __stdcall InetThreadFunc(void *pvParam) 
DWORD WINAPI InetThreadFunc(void *pvParam) 
{
    EventParam epParam = {(ArgsStruct *) pvParam,0};
    BOOL bRes = FALSE;
    BOOL bSuccess = FALSE;
    DWORD dwFileIdx;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Wait for delay period to expire
    
    DWORD dwRes = WaitForSingleObject(epParam.pArgs->ahHandles[1], epParam.pArgs->dwDownloadDelay);

    MYDBGTST(dwRes==WAIT_FAILED,("InetThreadFunc() WaitForMultipleObjects() failed, GLE=%u.",GetLastError()));

    //
    // Check if connection is still valid before starting the download
    // on NT5 we depend on setting the don't autodial flag for InternetSetOptions()
    // Unless, of course, the /LAN flag was specified in which case we don't want
    // this connection check to happen because the caller is telling us this is happening
    // over a LAN connection.
    //
    if (!(epParam.pArgs->dwAppFlags & AF_LAN))
    {
        if (FALSE == IsConnectionAlive(epParam.pArgs->pszServiceName))
        {
            MYDBG(("InetThreadFunc() aborted. No connection"));
            epParam.pArgs->bAbort = TRUE;
            goto done;        
        }
    }

    //
    //  Make sure we haven't aborted before starting...
    //
    if (epParam.pArgs->bAbort) 
    {
        MYDBG(("InetThreadFunc() aborted."));
        goto done;
    }

    for (epParam.dwIdx=0;epParam.dwIdx<epParam.pArgs->dwArgsCnt;epParam.dwIdx++) 
    {
        int i = 0;
        UINT uReturn = 0;
        DownloadArgs * pDA = &(epParam.pArgs->pdaArgs[epParam.dwIdx]);

        while (i++ < 3)
        {
            //
            //  On Win9x and/or slow machines, GetTempFileName sometimes fails,
            //  and cmdl32 errors all the way out.  In the debugger, if the call
            //  is retried, it will invariably succeed.  This sounds like a timing
            //  issue with the OS.  We do 3 tries, separated by a 1-second sleep.
            //
            uReturn = GetTempFileName(TEXT("."), TEXT("000"), 0, epParam.pArgs->pdaArgs[epParam.dwIdx].szFile);
            if (uReturn)
            {
                break;
            }
            Sleep(1000);
        }

        if (0 == uReturn)
        {
            DWORD dwError = GetLastError();
            MYDBG(("InetThreadFunc() GetTempFileName failed, GLE=%u.", dwError));
            epParam.pArgs->Log.Log(PB_DOWNLOAD_FAILURE, dwError, pDA->pszPhoneBookName, pDA->szHostName);
            goto done;
        }
        else
        {
            hFile = CreateFile(epParam.pArgs->pdaArgs[epParam.dwIdx].szFile,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (INVALID_HANDLE_VALUE == hFile)
            {
                DWORD dwError = GetLastError();
                MYDBG(("InetThreadFunc() CreateFile(szFile=%s) failed, GLE=%u.", epParam.pArgs->pdaArgs[epParam.dwIdx].szFile, dwError));
                epParam.pArgs->Log.Log(PB_DOWNLOAD_FAILURE, dwError, pDA->pszPhoneBookName, pDA->szHostName);
                goto done;            
            }
        }

        //
        //  Check to make sure we haven't been aborted
        //
        if (epParam.pArgs->bAbort) 
        {
            MYDBG(("InetThreadFunc() aborted."));
            goto done;
        }

        // We have a valid tmp file name, download phonebook update into it.
    
        epParam.pArgs->pdaArgs[epParam.dwIdx].pfnEvent = EventFunc;
        epParam.pArgs->pdaArgs[epParam.dwIdx].pvEventParam = &epParam;
        epParam.pArgs->pdaArgs[epParam.dwIdx].pbAbort = &epParam.pArgs->bAbort;
        
        PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etDataBegin,0);

        bRes = DownloadFile(&epParam.pArgs->pdaArgs[epParam.dwIdx],hFile);
        FlushFileBuffers(hFile);

        LONG lResult = CheckFileForPBSErrors(hFile);

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        
        if (epParam.pArgs->bAbort) 
        {
            MYDBG(("InetThreadFunc() aborted."));
            goto done;
        }

        PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etDataEnd,0);
        
#if 0 
/*
        if (!bRes && !epParam.dwIdx)
        {
            // TBD: Currently, a failure to update the primary phonebook prevents any
            // secondary phonebooks from being updated.  But a failure to update one
            // secondary does not prevent other secondaries from being updated.
            
            goto done;   
        }
*/      
#endif
        //
        // If download failed (either cpserver thinks that we don't need to update
        // the phone book or the phone book doesn't exist on the server), just keep 
        // on downloading the phone books for other profiles.
        //
    
        if (!bRes) 
        {
            if (lResult < 0)
            {
                //
                //  we parsed the downloaded file and got some error other than
                //  the 2 cases handled below
                //
                epParam.pArgs->Log.Log(PB_DOWNLOAD_FAILURE, pDA->dwBubbledUpError, pDA->pszPhoneBookName, pDA->szHostName);
            }
            else
            {
                //
                //  we contacted the web server successfully, and...
                //
                epParam.pArgs->Log.Log(PB_DOWNLOAD_SUCCESS, pDA->pszPhoneBookName, pDA->pszVerCurr, pDA->szHostName);

                if (lResult > 0)
                {
                    //
                    //  ... (case 1) the web server or PBS reported an error
                    //
                    epParam.pArgs->Log.Log(PB_UPDATE_FAILURE_PBS, lResult, pDA->pszPhoneBookName);
                }
                else
                {
                    //
                    //  ... (case 2) PBS said no download necessary
                    //
                    MYDBGASSERT(0 == lResult);

                    LPTSTR pszText = CmFmtMsg(epParam.pArgs->hInst, IDMSG_LOG_NO_UPDATE_REQUIRED);

                    epParam.pArgs->Log.Log(PB_UPDATE_SUCCESS,
                                           SAFE_LOG_ARG(pszText),
                                           pDA->pszPhoneBookName,
                                           pDA->pszVerCurr,
                                           pDA->pszVerCurr,     // for no-download case, these are the same
                                           pDA->szHostName);
                    CmFree(pszText);
                }
            }

            continue;
        }

        if (bRes && epParam.pArgs->pdaArgs[epParam.dwIdx].dwTotalSize) 
        {
            epParam.pArgs->pdaArgs[epParam.dwIdx].bTransferOk = TRUE;
        }
        
        if (epParam.pArgs->bAbort) 
        {
            MYDBG(("InetThreadFunc() aborted."));
            goto done;
        }
        
        //
        //  Phonebook download was successful, log this and proceed to unpack/update
        //
        epParam.pArgs->Log.Log(PB_DOWNLOAD_SUCCESS, pDA->pszPhoneBookName, pDA->pszVerCurr, pDA->szHostName);

        bRes = ProcessCabinet(&epParam.pArgs->pdaArgs[epParam.dwIdx],epParam.pArgs->dwAppFlags);

        if (bRes && (NULL == pDA->rgfpiFileProcessInfo))
        {
            MYDBGASSERT(FALSE);

            // strange case.  set error here so that we log something sensible later
            pDA->dwBubbledUpError = ERROR_INVALID_DATA;     // yes. we know this is lame.
        }

        if (bRes && pDA->rgfpiFileProcessInfo)
        {
            //
            //  figure out if this was a full or delta download
            //
            BOOL fFoundFullCab = FALSE;
            BOOL fFoundDeltaCab = FALSE;
            
            for (DWORD dwFileIndex = 0; dwFileIndex < pDA->dwNumFilesToProcess; ++dwFileIndex)
            {
                switch (pDA->rgfpiFileProcessInfo[dwFileIndex].itType)
                {
                    case itPbkInCab:
                        fFoundFullCab = TRUE;
                        break;
                        
                    case itPbdInCab:
                        fFoundDeltaCab = TRUE;
                        break;
                }
            }

            if (fFoundFullCab ^ fFoundDeltaCab)
            {
                // the cab should contain one or the other, but not both

                LPTSTR pszTemp = NULL;

                if (fFoundFullCab)
                {
                    pszTemp = CmFmtMsg(epParam.pArgs->hInst, IDMSG_LOG_FULL_UPDATE);
                }
                else if (fFoundDeltaCab)
                {
                    pszTemp = CmFmtMsg(epParam.pArgs->hInst, IDMSG_LOG_DELTA_UPDATE);
                }

                MYDBGASSERT(pszTemp);
                if (pszTemp)
                {
                    epParam.pArgs->Log.Log(PB_UPDATE_SUCCESS,
                                           SAFE_LOG_ARG(pszTemp),
                                           pDA->pszPhoneBookName,
                                           pDA->pszVerCurr,
                                           pDA->pszVerNew,
                                           pDA->szHostName);

                    CmFree(pszTemp);
                }
            }
            else
            {
                // strange cab (or at least, doesn't contain what we expected)

                // both full and delta
                CMASSERTMSG(!(fFoundFullCab && fFoundDeltaCab), TEXT("This cab has both full and delta phonebooks!!"));
                // neither full nor delta
                CMASSERTMSG(! (!fFoundFullCab && !fFoundDeltaCab), TEXT("This cab has neither a full nor a delta phonebook!!"));
                
                pDA->dwBubbledUpError = ERROR_BAD_FORMAT;
                epParam.pArgs->Log.Log(PB_UPDATE_FAILURE_CMPBK, pDA->dwBubbledUpError, pDA->pszPhoneBookName);
            }
        }
        else
        {
            epParam.pArgs->Log.Log(PB_UPDATE_FAILURE_CMPBK, pDA->dwBubbledUpError, pDA->pszPhoneBookName);
        }

        if (!bRes)
        {
            goto done;
        }

        bSuccess = TRUE; // We have at least one successful download #5635

#if 0 
/*
        if (!epParam.dwIdx &&
            epParam.pArgs->pdaArgs[epParam.dwIdx].dwTotalSize &&
            (epParam.pArgs->pdaArgs[epParam.dwIdx].itType != itInvalid) &&
            (epParam.pArgs->pdaArgs[epParam.dwIdx].itType != itPbdInCab)) 
        {
            // TBD: Currently, if the primary service is being updated in any way other than
            // a simple phone number delta, we do *not* update any of the secondary phonebooks
            // this time around.
            break;
        }
*/
#endif

    }

    //
    // If no download attempts succeeded, bail completely
    //
    
    if (!bSuccess)
    {
        MYDBG(("InetThreadFunc() no download success."));
        goto done;
    }

    if (epParam.pArgs->bAbort) 
    {
        MYDBG(("InetThreadFunc() aborted."));
        goto done;
    }
       
    // At this point, everything is all set - we're ready to perform the actual installs.  So
    // send a message to the main window telling it to do the installs, and wait until it
    // signals success back.
    
    PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etInstall,0);
    dwRes = WaitForSingleObject(epParam.pArgs->ahHandles[IDX_EVENT_HANDLE],INFINITE);
    
    if (epParam.pArgs->bAbort)
    {
        MYDBG(("InetThreadFunc() aborted."));
        goto done;
    }
    
    SetLastError(ERROR_SUCCESS);

done:

    if (epParam.pArgs->bAbort)
    {
        epParam.pArgs->Log.Log(PB_ABORTED);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    
    PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etDone,0);
    return (GetLastError());
}

//
// The main dlg
//

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{ 
    ArgsStruct *pArgs = (ArgsStruct *) GetWindowLongPtr(hwndDlg,DWLP_USER);
    static UINT uTimerID = 0;

    switch (uMsg) 
    {             
        case WM_INITDIALOG: 
        {
            RECT rDlg;
            RECT rWorkArea;
            DWORD dwThreadId = 0;
            SetWindowLongPtr(hwndDlg,DWLP_USER,(LONG_PTR)lParam);
            pArgs = (ArgsStruct *) lParam;
            pArgs->hwndDlg = hwndDlg;
            
            MYDBG(("MainDlgProc() - WM_INITDIALOG."));

            // Get the dialog rect and the available work area.
            
            GetWindowRect(hwndDlg,&rDlg);

            if (SystemParametersInfoA(SPI_GETWORKAREA,0,&rWorkArea,0))
            {
                // Move the dialog to the bottom right of the screen
                
                MoveWindow(hwndDlg,
                    rWorkArea.left + ((rWorkArea.right-rWorkArea.left) - (rDlg.right-rDlg.left) - GetSystemMetrics(SM_CXBORDER)),
                    rWorkArea.top + ((rWorkArea.bottom-rWorkArea.top) - (rDlg.bottom-rDlg.top) - GetSystemMetrics(SM_CYBORDER)),
                    rDlg.right-rDlg.left,
                    rDlg.bottom-rDlg.top,
                    FALSE);         
            }

            // Get update message from ini

            if (pArgs->pszProfile) 
            {
                TCHAR szTmp1[MAX_PATH+1];
                TCHAR szTmp2[MAX_PATH+1];

                GetDlgItemText(hwndDlg,IDC_MAIN_MESSAGE,szTmp2,sizeof(szTmp2)/sizeof(TCHAR)-1);
                GetPrivateProfileString(c_pszCmSection,
                                        c_pszCmEntryPbUpdateMessage, 
                                        szTmp2,
                                        szTmp1,
                                        sizeof(szTmp1)/sizeof(TCHAR)-1,
                                        pArgs->pdaArgs->pszCMSFile);
                SetDlgItemText(hwndDlg,IDC_MAIN_MESSAGE,szTmp1);
            }

            // Spin download thread (InetThreadFunc)

            pArgs->dwHandles = sizeof(pArgs->ahHandles) / sizeof(pArgs->ahHandles[0]);

            pArgs->ahHandles[IDX_EVENT_HANDLE] = CreateEvent(NULL,FALSE,FALSE,NULL);
            if (!pArgs->ahHandles[IDX_EVENT_HANDLE]) 
            {
                MYDBG(("MainDlgProc() CreateEvent() failed, GLE=%u.",GetLastError()));
                EndDialog(hwndDlg,FALSE);
            }

            //pArgs->ahHandles[IDX_INETTHREAD_HANDLE] = (HANDLE) _beginthreadex(NULL,0,InetThreadFunc,pArgs,0,&nThreadId);
            pArgs->ahHandles[IDX_INETTHREAD_HANDLE] = (HANDLE) CreateThread(0,0,InetThreadFunc,pArgs,0,&dwThreadId);
            if (!pArgs->ahHandles[IDX_INETTHREAD_HANDLE]) 
            {
                MYDBG(("MainDlgProc() CreateThread() failed, GLE=%u.",GetLastError()));
                EndDialog(hwndDlg,FALSE);
            }

            SetFocus((HWND) wParam);
            return (FALSE);
        }

        case WM_WINDOWPOSCHANGING:

            // Until we set pArgs->bShow to TRUE, we prevent the window from
            // ever being shown.
            if (!pArgs->bShow && (((LPWINDOWPOS) lParam)->flags & SWP_SHOWWINDOW)) 
            {
                ((LPWINDOWPOS) lParam)->flags &= ~SWP_SHOWWINDOW;
                ((LPWINDOWPOS) lParam)->flags |= SWP_HIDEWINDOW;
            }
            break;

        case WM_INITMENUPOPUP: 
        {
            HMENU hMenu = (HMENU) wParam;
//          UINT nPos = (UINT) LOWORD(lParam);
            BOOL fSysMenu = (BOOL) HIWORD(lParam);

            if (fSysMenu) 
            {
                EnableMenuItem(hMenu,SC_MAXIMIZE,MF_BYCOMMAND|MF_GRAYED);
            }
            break;
        }

        case WM_DESTROY:
        {                       
            // Kill timer if we have one
            
            if (uTimerID)
            {
                KillTimer(hwndDlg, uTimerID);
            }
            
            // If we have args, set bAbort true
            
            if (pArgs)
            {
                pArgs->bAbort = TRUE;
            }
            else
            {
                MYDBGASSERT(FALSE); // should not happen if dailog loads
            }                   
            
            break;
        }

        case WM_QUERYENDSESSION:
        {
            MYDBG(("MainDlgProc -- Got WM_QUERYENDSESSION message"));
            if (pArgs)
            {
                pArgs->bAbort = TRUE;
            }
            break;
        }

        case WM_ENDSESSION:
        {
            MYDBG(("MainDlgProc -- Got WM_ENDSESSION message"));        

            // 
            // Check the WPARAM. If it's TRUE then we are ending the session
            // and need to clean up.
            //
            if ((BOOL)wParam && pArgs)
            {
                pArgs->bAbort = TRUE;
                CleanUpCMDLArgs(pArgs);
            }

            EndDialog(hwndDlg,FALSE);
            break;
        }
        default:
            break;
    }
    
    // Check for custom messages
    
    if (pArgs && (uMsg == pArgs->nMsgId)) 
    {
        LPTSTR pszMsg;
        MYDBG(("Custom arg - %u received.", (DWORD) wParam));
       
        //
        // Setup FirstEvent time for tracking delays
        //                                            
        
        if (!pArgs->dwFirstEventTime) 
        {
            pArgs->dwFirstEventTime = GetTickCount();
            MYDBG(("Setting FirstEventTime to %u.", pArgs->dwFirstEventTime));
        }
        if (!pArgs->bShow && (GetTickCount() - pArgs->dwFirstEventTime > pArgs->dwHideDelay)) 
        {
            MYDBG(("HideDelay of %u expired, displaying dlg now.", pArgs->dwHideDelay));
            pArgs->bShow = TRUE;
            ShowWindow(hwndDlg,SW_SHOWNA);
        }

        // Handle specific message
        
        switch (wParam) 
        {
            case etDataBegin:
                pArgs->dwDataStepSize = 0;
                SendDlgItemMessage(hwndDlg,IDC_MAIN_PROGRESS,PBM_SETRANGE,0,MAKELPARAM(0,100));
                SendDlgItemMessage(hwndDlg,IDC_MAIN_PROGRESS,PBM_SETPOS,0,0);
                pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PERCENT_COMPLETE,0);
                SetWindowText(hwndDlg,pszMsg);
                CmFree(pszMsg);
                break;

            case etDataReceived:
                if (pArgs->dwDataTotal) // PREVENT DIVIDE BY ZERO
                { 
                    if (!pArgs->dwDataStepSize ) 
                    {
                        //
                        // Progress controls have a limit to there maximum 
                        // integral value so calculate an aproximate step size.
                        // 
                        //

                        pArgs->dwDataStepSize = (pArgs->dwDataTotal / 65535) + 1;

                        SendDlgItemMessage(hwndDlg,
                                           IDC_MAIN_PROGRESS,
                                           PBM_SETRANGE,
                                           0,
                                           MAKELPARAM(0,pArgs->dwDataTotal/pArgs->dwDataStepSize));
                    }
                    if (pArgs->dwDataStepSize) 
                    {
                        SendDlgItemMessage(hwndDlg,IDC_MAIN_PROGRESS,PBM_SETPOS,(WORD) (pArgs->dwDataCompleted / pArgs->dwDataStepSize),0);
                        pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PERCENT_COMPLETE,(pArgs->dwDataCompleted*100)/pArgs->dwDataTotal);
                        SetWindowText(hwndDlg,pszMsg);
                        CmFree(pszMsg);
                    }
                }
                break;

            case etDataEnd:
                pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PERCENT_COMPLETE,100);
                SetWindowText(hwndDlg,pszMsg);
                CmFree(pszMsg);
                break;

            case etInstall:
            {
                CNamedMutex PbMutex;
                               
                //
                // Hide the window, we're ready to install
                //

                pArgs->bShow = TRUE;            
                ShowWindow(hwndDlg,SW_HIDE);
                
                //
                // Grab the mutex before we begin PB updates. If it fails then 
                // abort the install, we'll try again next time the user connects.

                if (PbMutex.Lock(c_pszCMPhoneBookMutex))
                {
                    DoInstall(pArgs,hwndDlg,pArgs->dwAppFlags);
                    PbMutex.Unlock();
                }

                SetEvent(pArgs->ahHandles[IDX_EVENT_HANDLE]);
                ShowWindow(hwndDlg,SW_HIDE);
                break;
            }

            case etDone:
                EndDialog(hwndDlg,TRUE);
                break;

            case etICMTerm:
                SetEvent(pArgs->ahHandles[IDX_EVENT_HANDLE]);
                break;
        }
    }
    return (FALSE);
}


static void AddToUrl(LPTSTR pszUrl, LPTSTR pszVersion, LPTSTR pszService) 
{
    TCHAR szHttpstr[MAX_PATH];
    TCHAR szChar[16];
    int i,len;

    if (!CmStrchr(pszUrl,'?')) 
    {
        lstrcat(pszUrl,TEXT("?"));
    } 
    else
    {
        if (pszUrl[lstrlen(pszUrl)-1] != '&') 
        {
            lstrcat(pszUrl,TEXT("&"));
        }
    }

    
    // TBD Maybe get more info to send to the server.  We currently send
    // OSArch, OSType, LCID, OSVer, CMVer, PBVer, and ServiceName.
    
    SYSTEM_INFO siInfo;
    OSVERSIONINFO oviInfo;

    GetSystemInfo(&siInfo);
    ZeroMemory(&oviInfo,sizeof(oviInfo));
    oviInfo.dwOSVersionInfoSize = sizeof(oviInfo);
    GetVersionEx(&oviInfo);

    // #pragma message("ALERT - Resolution required - need to remove ISBU_VERSION." __FILE__)

    wsprintf(pszUrl+lstrlen(pszUrl),
             TEXT("OSArch=%u&OSType=%u&LCID=%u&OSVer=%u.%u.%u&CMVer=%s"),
             siInfo.wProcessorArchitecture,
             oviInfo.dwPlatformId,
             ConvertDefaultLocale(LOCALE_SYSTEM_DEFAULT),
             oviInfo.dwMajorVersion,
             oviInfo.dwMinorVersion,
             (oviInfo.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)?LOWORD(oviInfo.dwBuildNumber):oviInfo.dwBuildNumber,
             VER_PRODUCTVERSION_STR);

    if (pszVersion && *pszVersion) 
    {
        wsprintf(pszUrl+lstrlen(pszUrl),TEXT("&PBVer=%s"),pszVersion);
    }
    
    if (pszService && *pszService) 
    {
        // replace spaces with %20 for HTTP - 10216
        len = strlen(pszService);
        szHttpstr[0] = 0;
        szChar[1] = 0;
        for (i=0; i<len; ++i)
        {
            if (pszService[i] == ' ')
            {
                lstrcat(szHttpstr,"%20");
            }
            else
            {
                szChar[0] = pszService[i];
                lstrcat(szHttpstr,szChar);
            }
        }
        wsprintf(pszUrl+lstrlen(pszUrl),TEXT("&PB=%s"),szHttpstr);
    }
}

static BOOL WINAPI RefFunc(LPCTSTR pszFile,
                           LPCTSTR pszURL,
                           PPBFS , // pFilterA,
                           PPBFS , // pFilterB,
                           DWORD_PTR dwParam) 
{
    ArgsStruct *pArgs = (ArgsStruct *) dwParam;
    DownloadArgs *pdaArgsTmp;
    TCHAR szTmp[MAX_PATH+1];
    BOOL bOk = FALSE;
    LPTSTR  pszSlash;
    LPTSTR  pszDot;

    pdaArgsTmp = (DownloadArgs *) CmRealloc(pArgs->pdaArgs,(pArgs->dwArgsCnt+1)*sizeof(DownloadArgs));
    if (pdaArgsTmp) 
    {
        pArgs->pdaArgs = pdaArgsTmp;
        pdaArgsTmp += pArgs->dwArgsCnt;
        pdaArgsTmp->pszCMSFile = CmStrCpyAlloc(pszFile);
    
        if (pdaArgsTmp->pszCMSFile) 
        {
            // If get the version number from the CMS file

            GetPrivateProfileString(c_pszCmSection,
                                    c_pszVersion,
                                    TEXT(""),
                                    szTmp,
                                    (sizeof(szTmp)/sizeof(TCHAR))-1,
                                    pdaArgsTmp->pszCMSFile);
            pdaArgsTmp->pszVerCurr = CmStrCpyAlloc(szTmp);
        
            // get the PBK filename from the CMS file
            GetPrivateProfileString(c_pszCmSectionIsp,
                        c_pszCmEntryIspPbFile,
                        TEXT(""),
                        szTmp,
                        sizeof(szTmp)/sizeof(TCHAR)-1,
                        pdaArgsTmp->pszCMSFile);
            pdaArgsTmp->pszPbkFile = CmStrCpyAlloc(szTmp);
        
            // get the PDR filename from the CMS file
            GetPrivateProfileString(c_pszCmSectionIsp,
                        c_pszCmEntryIspRegionFile,
                        TEXT(""),
                        szTmp,
                        sizeof(szTmp)/sizeof(TCHAR)-1,
                        pdaArgsTmp->pszCMSFile);
            pdaArgsTmp->pszPbrFile = CmStrCpyAlloc(szTmp);

            // get the phone book name
            if (!(pszSlash = CmStrrchr(pdaArgsTmp->pszPbkFile, TEXT('\\')))) 
            {
                MYDBG((TEXT("RefFunc() bad PBK FILE - no backslash.")));
                goto parse_err;
            }

            if (!(pszDot = CmStrchr(pszSlash, TEXT('.')))) 
            {
                MYDBG((TEXT("Reffunc() bad PBK FILE - no dot.")));
                goto parse_err;
            }
            
            *pszDot = TEXT('\0');
            
            if (!(pdaArgsTmp->pszPhoneBookName = CmStrCpyAlloc(pszSlash+1)))
            {
                MYDBG((TEXT("Reffunc() out of memory.")));
            }
            // restore the slash
            *pszDot = TEXT('.');
            goto next_param;

parse_err:  
            pdaArgsTmp->pszPhoneBookName = CmStrCpyAlloc(TEXT(""));
        
next_param:
            if (pdaArgsTmp->pszVerCurr) 
            {
                // Build URL with version number and service name
                
                pdaArgsTmp->pszUrl = (LPTSTR) CmMalloc((INTERNET_MAX_URL_LENGTH+1)*sizeof(TCHAR));
                if (pdaArgsTmp->pszUrl) 
                {
                    lstrcpy(pdaArgsTmp->pszUrl,pszURL);
                    AddToUrl(pdaArgsTmp->pszUrl,pdaArgsTmp->pszVerCurr,pdaArgsTmp->pszPhoneBookName);
                    pArgs->dwArgsCnt++;
                    bOk = TRUE;
                }
            }
        }
    }

    // Cleanup

    if (!bOk && pdaArgsTmp) 
    {
        CmFreeIndirect(&pdaArgsTmp->pszCMSFile);
        CmFreeIndirect(&pdaArgsTmp->pszVerCurr);
        CmFreeIndirect(&pdaArgsTmp->pszUrl);
    }
    return (TRUE);
}

//
// cmmgr32.exe passes cmdl32.exe the cmp filename in full path.
//
static BOOL InitArgs(ArgsStruct *pArgs) 
{
    static struct 
    {
        LPTSTR pszFlag;
        DWORD dwFlag;
    } asFlags[] = {{TEXT("/no_delete"),AF_NO_DELETE},
                   {TEXT("/no_install"),AF_NO_INSTALL},
#ifdef DEBUG
                   {TEXT("/no_verify"),AF_NO_VERIFY},
#endif
                   {TEXT("/url"),AF_URL},
                   {TEXT("/no_profile"),AF_NO_PROFILE},
                   {TEXT("/no_exe"),AF_NO_EXE},
                   {TEXT("/no_exeincab"),AF_NO_EXEINCAB},
                   {TEXT("/no_infincab"),AF_NO_INFINCAB},
                   {TEXT("/no_pbdincab"),AF_NO_PBDINCAB},
                   {TEXT("/no_shlincab"),AF_NO_SHLINCAB},
                   {TEXT("/no_ver"),AF_NO_VER},
                   {TEXT("/LAN"),AF_LAN},
                   {TEXT("/VPN"),AF_VPN},
                   {NULL,0}};
    DWORD dwIdx;
    BOOL bInUrl;
    LPTSTR pszUrl = NULL;
    BOOL bRes = FALSE;
    TCHAR szPath[MAX_PATH+1];
    DWORD dwRes;
//  LPTSTR pszFileInPath;

    //
    // Get simulated ArgV
    //

    LPTSTR pszCmdLine = CmStrCpyAlloc(GetCommandLine());
   
    LPTSTR *ppszArgv = GetCmArgV(pszCmdLine);

    if (!ppszArgv || !ppszArgv[0]) 
    {
        MYDBG(("InitArgs() invalid parameter."));
        goto done;
    }
    
    //
    // Proces arguments
    //

    bInUrl = FALSE;
    
    for (dwIdx=1;ppszArgv[dwIdx];dwIdx++) 
    {
        DWORD dwFlagIdx;

        for (dwFlagIdx=0;asFlags[dwFlagIdx].pszFlag;dwFlagIdx++) 
        {
            if (lstrcmpi(asFlags[dwFlagIdx].pszFlag,ppszArgv[dwIdx]) == 0) 
            {
                if (bInUrl) 
                {
                    MYDBG(("InitArgs() URL expected after AF_URL flag."));
                    goto done;
                }
                switch (asFlags[dwFlagIdx].dwFlag) 
                {
                    case AF_URL:
                        bInUrl = TRUE;
                        break;

                    case AF_NO_PROFILE:
                        if (pArgs->pszProfile) 
                        {
                            MYDBG(("InitArgs() argument number %u (%s) is invalid.",dwIdx,ppszArgv[dwIdx]));
                            goto done;
                        }
                        // fall through
                    default:
                        pArgs->dwAppFlags |= asFlags[dwFlagIdx].dwFlag;
                        break;
                }
                break;
            }
        }
        if (!asFlags[dwFlagIdx].pszFlag) 
        {
            if (bInUrl) 
            {
                if (pszUrl) 
                {
                    MYDBG(("InitArgs() argument number %u (%s) is invalid.",dwIdx,ppszArgv[dwIdx]));
                    goto done;
                }
                bInUrl = FALSE;
                pszUrl = (LPTSTR) CmMalloc((INTERNET_MAX_URL_LENGTH+1)*sizeof(TCHAR));
                if (!pszUrl) 
                {
                    goto done;
                }
                lstrcpy(pszUrl,ppszArgv[dwIdx]);

            } 
            else 
            {
                if (pArgs->pszProfile || (pArgs->dwAppFlags & AF_NO_PROFILE)) 
                {
                    MYDBG(("InitArgs() argument number %u (%s) is invalid.",dwIdx,ppszArgv[dwIdx]));
                    goto done;
                }
                /*
                ZeroMemory(szPath,sizeof(szPath));
                dwRes = GetFullPathName(ppszArgv[dwIdx],sizeof(szPath)/sizeof(TCHAR)-1,szPath,&pszFileInPath);
                MYDBGTST(!dwRes,("InitArgs() GetFullPathName() failed, GLE=%u.",GetLastError()));
                */
                //
                // the cmp filename is always in full path.
                //
                lstrcpy(szPath, ppszArgv[dwIdx]);
                pArgs->pszProfile = CmStrCpyAlloc(szPath);
                if (!pArgs->pszProfile) 
                {
                    goto done;
                }
                else
                {
                    //
                    // Set the current dir to the profile dir
                    // If the szPath contains only the file name, then
                    // assume that the current dir is the profile dir
                    //
                    char *pszTemp = NULL;
                    
                    pszTemp = CmStrrchr(szPath, TEXT('\\'));
                    if (NULL != pszTemp)
                    {
                        *pszTemp = TEXT('\0');
                        MYVERIFY(SetCurrentDirectory(szPath));
                    }
                }
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////
    if (pArgs->dwAppFlags & AF_VPN)
    {
        //
        //  They have asked for a VPN download.  Let's make sure that the only other flags
        //  they have specified are /LAN or /NO_DELETE
        //
        DWORD dwAllowedFlags = AF_VPN | AF_LAN | AF_NO_DELETE;
        if ((dwAllowedFlags | pArgs->dwAppFlags) != dwAllowedFlags)
        {
            CMASSERTMSG(FALSE, TEXT("InitArgs in cmdl32.exe -- VPN flag specified with other non supported flags, exiting."));
            goto done;
        }

        bRes = TRUE;
        CMTRACE(TEXT("InitArgs - /VPN flag detected going into VPN file download mode."));
        goto done;
    }
////////////////////////////////////////////////////////////////////////////////////////////
    if (bInUrl) 
    {
        MYDBG(("InitArgs() URL expected after AF_URL flag."));
        goto done;
    }
    
    if (!pArgs->pszProfile && !(pArgs->dwAppFlags & AF_NO_PROFILE)) 
    {
        MYDBG(("InitArgs() must use AF_NO_PROFILE if no profile given on command line."));
        goto done;
    }
    
    if (pArgs->pszProfile && pszUrl) 
    {
        MYDBG(("InitArgs() can't give both a profile and a URL on the command line."));
        goto done;
    }
    
    pArgs->pdaArgs = (DownloadArgs *) CmMalloc(sizeof(DownloadArgs));
    
    if (!pArgs->pdaArgs) 
    {
        goto done;
    }
    pArgs->dwArgsCnt++;
    
    if (!pszUrl) 
    {
        TCHAR szTmp[MAX_PATH+1];
        PhoneBookParseInfoStruct pbpisInfo;
        LPTSTR  pszSlash;
        LPTSTR  pszDot;
        int nVal = 0;

        if (!pArgs->pszProfile) 
        {
            MYDBG(("InitArgs() must give AF_URL on command line when AF_NO_PROFILE is given."));
            goto done;
        }

        // Get CMS file name

        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntryCmsFile,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pszProfile);
        if (!szTmp[0]) 
        {
            MYDBG(("InitArgs() [Connection Manager] CMSFile= entry not found in %s.",pArgs->pszProfile));
            goto done;
        }

        /*
        ZeroMemory(szPath,sizeof(szPath));
        dwRes = GetFullPathName(szTmp,sizeof(szPath)/sizeof(TCHAR)-1,szPath,&pszFileInPath);
        MYDBGTST(!dwRes,("InitArgs() GetFullPathName() failed, GLE=%u.",GetLastError()));
        */
        //
        // we simply append the relative path of the cms file to the profile dir to
        // construct the cms path.
        //
        lstrcat(szPath, TEXT("\\"));
        lstrcat(szPath, szTmp);

        pArgs->pdaArgs->pszCMSFile = CmStrCpyAlloc(szPath);
        if (!pArgs->pdaArgs->pszCMSFile) 
        {
            goto done;
        }
        
        // get the PBK filename from the CMS file
        GetPrivateProfileString(c_pszCmSectionIsp,
                                c_pszCmEntryIspPbFile,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        if (!*szTmp) 
        {
            MYDBG(("InitArgs() [ISP Info] RegionFile= entry not found in %s.",pArgs->pdaArgs->pszCMSFile));
            pArgs->pdaArgs->pszPhoneBookName = CmStrCpyAlloc(TEXT(""));
        }
        else 
        {
            if (!(pArgs->pdaArgs->pszPbkFile = CmStrCpyAlloc(szTmp)))
                goto done;
    
            // get the phone book name
            if (!(pszSlash = CmStrrchr(pArgs->pdaArgs->pszPbkFile, TEXT('\\')))) 
            {
                MYDBG((TEXT("InitArgs() bad PBKFILE - no backslash.")));
                goto done;
            }

            if (!(pszDot = CmStrchr(pszSlash, TEXT('.')))) 
            {
                MYDBG((TEXT("InitArgs() bad PBKFILE - no dot.")));
                goto done;
            }

            *pszDot = TEXT('\0');
            
            if (!(pArgs->pdaArgs->pszPhoneBookName = CmStrCpyAlloc(pszSlash+1)))
                goto done;
            // restore the slash
            *pszDot = TEXT('.');
        }

    

        // get the PBR filename from the CMS file
        GetPrivateProfileString(c_pszCmSectionIsp,
                                c_pszCmEntryIspRegionFile,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        MYDBGTST(!*szTmp, ("InitArgs() [ISP Info] RegionFile= entry not found in %s.",pArgs->pdaArgs->pszCMSFile));

        if (!(pArgs->pdaArgs->pszPbrFile = CmStrCpyAlloc(szTmp)))
            goto done;
    
        GetPrivateProfileString(c_pszCmSection,
                                c_pszVersion,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);  
                                                                                    
        pArgs->pdaArgs->pszVerCurr = CmStrCpyAlloc(szTmp);
        
        if (!pArgs->pdaArgs->pszVerCurr) 
        {
            goto done;
        }
        
        pArgs->pdaArgs->pszUrl = (LPTSTR) CmMalloc((INTERNET_MAX_URL_LENGTH+1)*sizeof(TCHAR));
        
        if (!pArgs->pdaArgs->pszUrl) 
        {
            goto done;
        }
        
        ZeroMemory(&pbpisInfo,sizeof(pbpisInfo));
        pbpisInfo.dwSize = sizeof(pbpisInfo);
        pbpisInfo.pszURL = pArgs->pdaArgs->pszUrl;
        pbpisInfo.dwURL = INTERNET_MAX_URL_LENGTH;
        pbpisInfo.pfnRef = RefFunc;
        pbpisInfo.dwRefParam = (DWORD_PTR) pArgs;
        bRes = PhoneBookParseInfo(pArgs->pdaArgs->pszCMSFile,&pbpisInfo);
        
        if (!bRes) 
        {
            MYDBG(("InitArgs() PhoneBookParseInfo() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        PhoneBookFreeFilter(pbpisInfo.pFilterA);
        PhoneBookFreeFilter(pbpisInfo.pFilterB);
        
        //
        // Bug fix #3064, a-nichb - HideDelay & DownloadDelay
        // Use nVal while retrieving entries, then assign to global
        //
                
        // Get Download delay

        nVal = GetPrivateProfileInt(c_pszCmSection,
                                    c_pszCmEntryDownloadDelay,
                                    DEFAULT_DELAY,
                                    pArgs->pdaArgs->pszCMSFile);
        
        // Convert to milliseconds

        pArgs->dwDownloadDelay = ((DWORD) nVal * (DWORD) 1000);
        MYDBG(("Download delay is %u millisseconds.", pArgs->dwDownloadDelay));

        // Get Hide delay 
        
        nVal = GetPrivateProfileInt(c_pszCmSection,
                                    c_pszCmEntryHideDelay,
                                    -1,
                                    pArgs->pdaArgs->pszCMSFile);
        //
        // Convert to milliseconds
        //
        if (nVal < 0)
        {
            pArgs->dwHideDelay = DEFAULT_HIDE;
        }
        else
        {
            pArgs->dwHideDelay = ((DWORD) nVal * (DWORD) 1000);
        }
        
        MYDBG(("Hide delay is %u milliseconds.", pArgs->dwHideDelay));

#if 0
/*
        // we don't support SuppressUpdates anymore

        if (GetPrivateProfileInt(c_pszCmSection, //13226
                                 TEXT("SuppressUpdates"),
                                 0,
                                 pArgs->pszProfile)) 
        {
            pArgs->dwAppFlags |= AF_NO_UPDATE;
        }
*/
#endif

    } 
    else 
    {
        pArgs->pdaArgs[0].pszUrl = pszUrl;
        pszUrl = NULL;
    }
    
    if (pArgs->pszProfile) 
    {
        TCHAR szTmp1[MAX_PATH+1];
        TCHAR szTmp2[MAX_PATH+1];

        pArgs->pszServiceName = (LPTSTR) CmMalloc((MAX_PATH+1)*sizeof(TCHAR));
        if (!pArgs->pszServiceName) 
        {
            goto done;
        }
        
        lstrcpy(szTmp1,pArgs->pdaArgs->pszCMSFile);
        
        if (CmStrrchr(szTmp1,'.')) 
        {
            *CmStrrchr(szTmp1,'.') = 0;
        }
        
        if (CmStrrchr(szTmp1,'\\')) 
        {
            lstrcpy(szTmp1,CmStrrchr(szTmp1,'\\')+1);
        }
        
        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntryServiceName,
                                szTmp1,
                                pArgs->pszServiceName,
                                MAX_PATH,
                                pArgs->pdaArgs->pszCMSFile);
        
        // Get the name of the large icon
        
        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntryBigIcon,
                                TEXT(""),
                                szTmp2,
                                sizeof(szTmp2)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        
        // If we have a name, load the large icon

        if (szTmp2[0]) 
        {
            pArgs->hIcon = CmLoadIcon(pArgs->hInst,szTmp2); 
        }

        // Get the name of the small icon

        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntrySmallIcon,
                                TEXT(""),
                                szTmp2,
                                sizeof(szTmp2)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        
        // If we have a name, load the small icon

        if (szTmp2[0]) 
        {
            pArgs->hSmallIcon = CmLoadSmallIcon(pArgs->hInst,szTmp2); 
        }
    }
    
    //
    // If the name based icon loads were not successful, load defaults from EXE
    //

    if (!pArgs->hIcon) 
    {
        pArgs->hIcon = CmLoadIcon(pArgs->hInst, MAKEINTRESOURCE(IDI_APP));
    }
    
    if (!pArgs->hSmallIcon) 
    {
        pArgs->hSmallIcon = CmLoadSmallIcon(pArgs->hInst,MAKEINTRESOURCE(IDI_APP));
    }
    
    AddToUrl(pArgs->pdaArgs->pszUrl,pArgs->pdaArgs->pszVerCurr,pArgs->pdaArgs->pszPhoneBookName);

    bRes = TRUE;

done:
    
    // 
    // Cleanup
    // 
    
    if (pszUrl) 
    {
        CmFree(pszUrl);
    }

    if (pszCmdLine)
    {
        CmFree(pszCmdLine);
    }
    
    if (ppszArgv)
    {
        CmFree(ppszArgv);
    }
   
    return (bRes);
}

static BOOL InitApplication(ArgsStruct *pArgs) 
{
    WNDCLASSEX wcDlg;

    wcDlg.cbSize = sizeof(wcDlg);
    
    if (FALSE == GetClassInfoEx(NULL, WC_DIALOG, &wcDlg)) 
    {      
        MYDBG(("InitApplication() GetClassInfoEx() failed, GLE=%u.",GetLastError()));
        return (FALSE);                             
    }                                               

    wcDlg.lpszClassName = ICONNDWN_CLASS;
    wcDlg.hIcon = pArgs->hIcon;
    wcDlg.hIconSm = pArgs->hSmallIcon;
    wcDlg.hInstance = pArgs->hInst; 

    pArgs->hIcon = NULL;
    pArgs->hSmallIcon = NULL;     
    
    //
    // We have our class data setup, register the class
    //

    ATOM aRes = RegisterClassEx(&wcDlg);
    if (!aRes) 
    {  
        //
        // We may have more than one instance, so check the error case
        // 

        DWORD dwError = GetLastError();
        
        if (ERROR_ALREADY_EXISTS != dwError)
        {
            MYDBG(("InitApplication() RegisterClassEx() failed, GLE=%u.",GetLastError()));
            return (FALSE);
        }
    }

    MYDBG(("InitApplication() Class %s is registered.", wcDlg.lpszClassName));

    return TRUE;    
}

static BOOL InitInstance(ArgsStruct *pArgs) 
{
    pArgs->nMsgId = RegisterWindowMessage(c_pszIConnDwnMsg);
    if (!pArgs->nMsgId) 
    {
        MYDBG(("InitInstance() RegisterWindowMessage() failed."));
        return (FALSE);
    }
    
    return (TRUE);
}


//+----------------------------------------------------------------------------
//
// Func:    InitLogging
//
// Desc:    Initializes logging functionality for the CMDL32 module
//
// Args:    [pArgs]      - args struct to pick up stuff from
//          [pszCmsPath] - path to CMS file
//
// Return:  BOOL (TRUE for success)
//
// Notes:   IMPORTANT: note that CMDL32 is compiled Ansi whereas CMUTIL, which
//          contains the logging functionality, is Unicode.  CmLogFile exposes both
//          Ansi and Unicode variants for member functions that take strings.
//          However, the arguments passed to the Log calls are Ansi - they are
//          handled correctly by using %S (note, capital S) in the corresponding
//          format strings in cmlog.rc.
//
// History: 11-Apr-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
static BOOL InitLogging(ArgsStruct * pArgs, LPCTSTR pszCmsPath)
{
    BOOL    fAllUser   = TRUE;
    BOOL    fEnabled   = FALSE;
    DWORD   dwMaxSize  = 0;
    CHAR    szFileDir[MAX_PATH + 1] = {0};

    //
    //  First figure out if this profile is AllUsers or Single User
    //
    if (!OS_W9X)
    {
        HMODULE hShell32 = LoadLibraryExA("Shell32.dll", NULL, 0);

        if (hShell32)
        {
            typedef DWORD (WINAPI *pfnSHGetSpecialFolderPathASpec)(HWND, CHAR*, int, BOOL);

            pfnSHGetSpecialFolderPathASpec pfnSHGetSpecialFolderPathA;

            pfnSHGetSpecialFolderPathA = (pfnSHGetSpecialFolderPathASpec)
                                            GetProcAddress(hShell32,
                                                           "SHGetSpecialFolderPathA");

            if (pfnSHGetSpecialFolderPathA)
            {
                CHAR szPath[MAX_PATH+1];

                if (TRUE == pfnSHGetSpecialFolderPathA(NULL, szPath, CSIDL_APPDATA, FALSE))
                {
                    CHAR szProfile[MAX_PATH + 1];

                    lstrcpyn(szProfile, pArgs->pszProfile, MAX_PATH);
                    szProfile[ lstrlen(szPath) ] = '\0';
                    
                    if (0 == lstrcmpi(szProfile, szPath))
                    {
                        fAllUser = FALSE;
                    }
                }
            }

            FreeLibrary(hShell32);
        }
    }
    //
    //  To get Enabled, we have the code equivalent of IniBoth
    //
    
    fEnabled = c_fEnableLogging;

    BOOL bGotValueFromReg = FALSE;
    HKEY hkey;
    CHAR szRegPath[2 * MAX_PATH];

    lstrcpy(szRegPath, fAllUser ? "SOFTWARE\\Microsoft\\Connection Manager\\UserInfo\\" :
                                  "SOFTWARE\\Microsoft\\Connection Manager\\SingleUserInfo\\");

    if ( (lstrlen(szRegPath) + 1 + lstrlen(pArgs->pszServiceName) + 1) > (2 * MAX_PATH))
    {
        return FALSE;
    }
    
    lstrcat(szRegPath, "\\");
    lstrcat(szRegPath, pArgs->pszServiceName);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      szRegPath,
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
        DWORD dwType;
        DWORD bEnabled;
        DWORD dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             c_pszCmEntryEnableLogging,
                                             NULL,
                                             &dwType,
                                             (PBYTE) &bEnabled,
                                             &dwSize))
        {
            fEnabled = bEnabled ? TRUE : FALSE;
            bGotValueFromReg = TRUE;
        }
        
        RegCloseKey(hkey);        
    }
    

    //
    //  To *exactly* mimic pIniBoth we should check the .CMP here too.  However,
    //  the moment the user brings up the UI we will write this value to the
    //  registry if it was in the .CMP.  So, skip the CMP step.
    //
    if (FALSE == bGotValueFromReg)
    {
        fEnabled = (BOOL ) GetPrivateProfileInt(c_pszCmSection,
                                                c_pszCmEntryEnableLogging,
                                                c_fEnableLogging,
                                                pszCmsPath);
    }

    //
    //  To get MaxSize, we have the code equivalent of IniService
    //
    dwMaxSize = GetPrivateProfileInt(c_pszCmSectionLogging,
                                     c_pszCmEntryMaxLogFileSize,
                                     c_dwMaxFileSize,
                                     pszCmsPath);

    //
    //  LogFileDirectory is also obtained via IniService
    //
    GetPrivateProfileString(c_pszCmSectionLogging,
                            c_pszCmEntryLogFileDirectory,
                            c_szLogFileDirectory,
                            szFileDir,
                            sizeof(szFileDir) / sizeof(TCHAR) - 1,
                            pszCmsPath);

    //
    //  In the /VPN case, some of the code that populates pArgs is skipped, so
    //  we must get the ServiceName ourselves.
    //
    CHAR szServiceName[MAX_PATH + 1];

    GetPrivateProfileString(c_pszCmSection,
                            c_pszCmEntryServiceName,
                            TEXT(""),
                            szServiceName,
                            MAX_PATH,
                            pszCmsPath);

    if (TEXT('\0') == szServiceName[0])
    {
        // without a service name, we're not going to log much.
        CMTRACE(TEXT("InitLogging - could not find servicename in .CMS file, exiting."));
        return FALSE;
    }

    //
    //  Use these values to initialize logging
    //
    pArgs->Log.Init(pArgs->hInst, fAllUser, szServiceName);
    
    pArgs->Log.SetParams(fEnabled, dwMaxSize, szFileDir);
    if (pArgs->Log.IsEnabled())
    {
        pArgs->Log.Start(FALSE);        // FALSE => no banner
    }
    else
    {
        pArgs->Log.Stop();
    }

    return TRUE;
}

// can't #include "gppswithalloc.cpp" twice
LPTSTR GetPrivateProfileStringWithAlloc(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault, LPCTSTR pszFile);

int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR , int ) 
{
    MYDBG(("====================================================="));
    MYDBG((" CMDL32.EXE - LOADING - Process ID is 0x%x ", GetCurrentProcessId()));
    MYDBG(("====================================================="));

    INT_PTR iRes = 1;    
    ArgsStruct asArgs;
    DWORD dwIdx = 0;
    BOOL bRes = FALSE;
    LPTSTR pszService = NULL;
    LPTSTR pszCmsPath = NULL;
   
    //
    // Initialize app-wide arguments
    //

    ZeroMemory(&asArgs,sizeof(asArgs));
    
    //
    // We can't use hInst param if we're not linked with libc.
    // libc uses GetModuleHandle(NULL), so we will too.
    //
    
    asArgs.hInst = GetModuleHandleA(NULL); //  hInst;
    MYDBGTST(NULL == asArgs.hInst, ("WinMain - GetModuleHandle(NULL) returned 0x%x, GLE=%u.", asArgs.hInst, GetLastError()));

    if (!InitArgs(&asArgs)) 
    {
        goto done;
    }

    //
    //  Both UpdateVpn and InitLogging need the .CMS file, so get that now
    //
    pszService = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryCmsFile, TEXT(""), asArgs.pszProfile);
    if (NULL == pszService)
    {
        goto done;
    }
    pszCmsPath = CmBuildFullPathFromRelative(asArgs.pszProfile, pszService);
    if (NULL == pszCmsPath)
    {
        goto done;
    }
    
    //
    //  Initialize Logging
    //
    if (!InitLogging(&asArgs, pszCmsPath))
    {
        goto done;
    }

///////////////////////////////////////////////////////////////////////////////////
    if (asArgs.dwAppFlags & AF_VPN)
    {
        iRes = UpdateVpnFileForProfile(asArgs.pszProfile, pszCmsPath, &asArgs.Log, !(asArgs.dwAppFlags & AF_LAN)); // if /LAN flag is set, don't check the connection.
        goto done;
    }
///////////////////////////////////////////////////////////////////////////////////
    // Set UPDATE flag

//      if (asArgs.dwAppFlags & AF_NO_UPDATE) 
//      {
//              MYDBG(("WinMain() user has disabled updates."));
//              goto done;
//      }

    // Initialize the app.

    if (!InitApplication(&asArgs)) 
    {
        goto done;
    }

    // Setup this instance

    if (!InitInstance(&asArgs)) 
    {
        goto done;
    }

    InitCommonControls();

    iRes = DialogBoxParam(asArgs.hInst,MAKEINTRESOURCE(IDD_MAIN),NULL, MainDlgProc,(LPARAM) &asArgs);

    MYDBGTST(iRes == -1, ("WinMain() - DialogBoxParam(0x%x, 0x%x, NULL, MainDlgProc, 0x%x) - failed",asArgs.hInst, MAKEINTRESOURCE(IDD_MAIN), &asArgs));

done:

    CmFree(pszService);
    CmFree(pszCmsPath);
    
    CleanUpCMDLArgs(&asArgs);

    //
    //  Uninitialize logging
    //
    asArgs.Log.DeInit();

    //
    // the C runtine uses ExitProcess() to exit.
    //

    MYDBG(("====================================================="));
    MYDBG((" CMDL32.EXE - UNLOADING - Process ID is 0x%x ", GetCurrentProcessId()));
    MYDBG(("====================================================="));

    ExitProcess((UINT)iRes);
  
    return ((int)iRes);
}

//+----------------------------------------------------------------------------
//
// Func:    CleanUpCMDLArgs
//
// Desc:    Cleans up the CMDL arguments and any sessions or handles that are 
//          open.
//
// Args:    [pArgs]      - args struct to pick up stuff from
//
// Return:  BOOL (TRUE for success)
//
// History: 08/01/2001  tomkel      Created
//
//-----------------------------------------------------------------------------
BOOL CleanUpCMDLArgs(ArgsStruct *pasArgs)
{
    BOOL fRetVal = FALSE;
    DWORD dwIdx = 0;
    BOOL bRes = FALSE;

    if (NULL == pasArgs)
    {
        return fRetVal;
    }

    MYDBG(("CleanUpCMDLArgs -- BEGIN"));

    //
    // Close any handles created during WININET session
    // The InternetCloseHandle function terminates any pending operations on 
    // the handle and discards any outstanding data. If a thread is blocking 
    // a call to Wininet.dll, another thread in the application can call 
    // InternetCloseHandle on the Internet handle being used by the first thread 
    // to cancel the operation and unblock the first thread.
    //

    for (dwIdx=0;dwIdx<pasArgs->dwArgsCnt;dwIdx++) 
    {
        DownloadArgs *pdaArgs;

        pdaArgs = pasArgs->pdaArgs + dwIdx;
        
        if (pdaArgs->hReq) 
        {
            bRes = InternetCloseHandle(pdaArgs->hReq);
            MYDBGTST(!bRes,("CleanUpCMDLArgs() InternetCloseHandle(asArgs.pdaArgs[%u].hReq) failed, GLE=%u.",dwIdx,GetLastError()));
            pdaArgs->hReq = NULL;
        }

        if (pdaArgs->hConn) 
        {
            bRes = InternetCloseHandle(pdaArgs->hConn);
            MYDBGTST(!bRes,("CleanUpCMDLArgs() InternetCloseHandle(asArgs.pdaArgs[%u].hConn) failed, GLE=%u.",dwIdx,GetLastError()));
            pdaArgs->hConn = NULL;
        }
        
        if (pdaArgs->hInet) 
        {
            bRes = InternetCloseHandle(pdaArgs->hInet);
            MYDBGTST(!bRes,("CleanUpCMDLArgs() InternetCloseHandle(asArgs.pdaArgs[%u].hInet) failed, GLE=%u.",dwIdx,GetLastError()));
            pdaArgs->hInet = NULL;
        }
    }
    
    //
    // Wait for thread to terminate
    //
    if (pasArgs->ahHandles[IDX_INETTHREAD_HANDLE]) 
    {
        long lRes;

        lRes = WaitForSingleObject(pasArgs->ahHandles[IDX_INETTHREAD_HANDLE],45*1000);
        MYDBGTST(lRes!=WAIT_OBJECT_0,("CleanUpCMDLArgs() WaitForSingleObject() failed, GLE=%u.",lRes));
    }

    //
    // Free profile and service data
    //
    if (pasArgs->pszProfile) 
    {
        CmFree(pasArgs->pszProfile);
        pasArgs->pszProfile = NULL;
    }
    
    if (pasArgs->pszServiceName) 
    {
        CmFree(pasArgs->pszServiceName);
        pasArgs->pszServiceName = NULL;
    }    

    //
    // Cleanup for each argument
    //
    for (dwIdx=0;dwIdx<pasArgs->dwArgsCnt;dwIdx++) 
    {
        DownloadArgs *pdaArgs;
        UINT i;

        pdaArgs = pasArgs->pdaArgs + dwIdx;
        CmFreeIndirect(&pdaArgs->pszCMSFile);
        CmFreeIndirect(&pdaArgs->pszPbkFile);
        CmFreeIndirect(&pdaArgs->pszPbrFile);
        CmFreeIndirect(&pdaArgs->pszUrl);
        CmFreeIndirect(&pdaArgs->pszVerCurr);
        CmFreeIndirect(&pdaArgs->pszVerNew);
        //CmFreeIndirect(&pdaArgs->pszNewPbrFile);
        CmFreeIndirect(&pdaArgs->pszPhoneBookName);

        if (pdaArgs->psUrl) 
        {
            CmFree(pdaArgs->psUrl);
            pdaArgs->psUrl = NULL;
        }

        for (i=0; i<pdaArgs->dwNumFilesToProcess; i++)
            CmFree(pdaArgs->rgfpiFileProcessInfo[i].pszFile);
        
        CmFree(pdaArgs->rgfpiFileProcessInfo);
    
        //
        // As long as AF_NO_DELETE is NOT set, clean up temp files and dirs
        //
        if (!(pasArgs->dwAppFlags & AF_NO_DELETE)) 
        {
            if (pdaArgs->szFile[0]) 
            {
                bRes = DeleteFile(pdaArgs->szFile);
                MYDBGTST(!bRes,("CleanUpCMDLArgs() DeleteFile(asArgs[pdaArgs[%lu].szFile=%s) failed, GLE=%u.",dwIdx,pdaArgs->szFile,GetLastError()));
            }
            
            if (pdaArgs->szCabDir[0]) 
            {
                ZapDir(pdaArgs->szCabDir);
            }
        }
    }

    //
    // Release download args
    //
    if (pasArgs->pdaArgs) 
    {
        CmFree(pasArgs->pdaArgs);
        pasArgs->pdaArgs = NULL;
    }
    
    for (dwIdx=0;dwIdx<sizeof(pasArgs->ahHandles)/sizeof(pasArgs->ahHandles[0]);dwIdx++) 
    {
        if (pasArgs->ahHandles[dwIdx]) 
        {
            bRes = CloseHandle(pasArgs->ahHandles[dwIdx]);
            MYDBGTST(!bRes,("WinMain() CloseHandle(asArgs.ahHandles[%u]) failed, GLE=%u.",dwIdx,GetLastError()));
            pasArgs->ahHandles[dwIdx] = NULL;
        }
    }

    MYDBG(("CleanUpCMDLArgs -- END"));
    fRetVal = TRUE;
    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\util.h ===
//+----------------------------------------------------------------------------
//
// File:	 util.h
//
// Module:	 CMDL32.EXE
//
// Synopsis: Header file for utility routines specific to CMDL
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------

#ifndef _CMDL_UTIL_INC
#define _CMDL_UTIL_INC

//
// Function Protoypes
//

BOOL IsErrorForUnique(DWORD dwErrCode, LPSTR lpszFile);
LPTSTR GetVersionFromFile(LPSTR lpszFile);
BOOL CreateTempDir(LPTSTR pszDir);
TCHAR GetLastChar(LPTSTR pszStr);
LPTSTR *GetCmArgV(LPTSTR pszCmdLine);

#endif // _CMDL_UTIL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 util.cpp
//
// Module:	 CMDL32.EXE
//
// Synopsis: Utility routines specific to CMDL
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 nickball    Created    4/8/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
// Definitions
//

#define MAX_CMD_ARGS            15

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//
// Helper function to determine if a file open error 
// is due to the fact that a file doesn't exist
//

BOOL IsErrorForUnique(DWORD dwErrCode, LPSTR lpszFile) 
{
	if (!lpszFile)
	{
		MYDBGASSERT(lpszFile);
		return TRUE;
	}

	// If the file exists, return false, its not a unique file error
	
	switch (dwErrCode) 
	{
		case ERROR_FILE_EXISTS:
		case ERROR_ACCESS_DENIED:
		case ERROR_ALREADY_EXISTS:
			return (FALSE);

		default:
			break;
	}

    return (TRUE);
}

//
// Helper function to retrieve the version number from the version file
//

LPTSTR GetVersionFromFile(LPSTR lpszFile)
{
    MYDBGASSERT(lpszFile);

    LPTSTR pszVerNew = NULL;

    if (NULL == lpszFile)
    {
        return NULL;
    }

    //
    // We simply read the version file contents to get the version number
	//
    				
	HANDLE hFileSrc = CreateFile(lpszFile,
		                           GENERIC_READ,
		                           FILE_SHARE_READ,
		                           NULL,
		                           OPEN_EXISTING, 
		                           FILE_ATTRIBUTE_NORMAL,
		                           NULL);

	MYDBGTST(hFileSrc == INVALID_HANDLE_VALUE,("GetVersionFromFile() CreateFile() failed - %s.", lpszFile));

	if (hFileSrc != INVALID_HANDLE_VALUE)
	{
        DWORD dwSize = GetFileSize(hFileSrc, NULL);

        MYDBGTST(dwSize >= 0x7FFF,("GetVersionFromFile() Version file is too large - %s.", lpszFile));
    
        if (dwSize < 0x7FFF)
        {
            // Read in contennts

	        DWORD dwBytesIn;
	 
			pszVerNew = (LPTSTR) CmMalloc(dwSize);
						
			if (pszVerNew) 
			{
		        // Read entire file contents into buffer
		        
		        int nRead = ReadFile(hFileSrc, pszVerNew, dwSize, &dwBytesIn, NULL);
		        MYDBGTST(!nRead,("GetVersionFromFile() ReadFile() failed - %s.",lpszFile));

				if (nRead)
        		{
				    // Make sure that the ver string is properly truncated
						
					LPTSTR pszTmp = pszVerNew;
			
					while (*pszTmp) 
					{
						// Truncate the version string to the first tab, newline, or carriage return.
			
						if (*pszTmp == '\t' || *pszTmp == '\n' || *pszTmp == '\r') 
						{
							*pszTmp = 0;
							break;
						}
			
						pszTmp++;
					}
		        }
	        }

			MYDBGTST(!pszVerNew,("GetVersionFromFile() CmMalloc(%u) failed.",dwSize));
	    }
					
		CloseHandle(hFileSrc);
	} 

    return pszVerNew;
}

//
// Helper function to create a temp directory.  Note that we
// expect pszDir to be at least MAX_PATH + 1.
//

BOOL CreateTempDir(LPTSTR pszDir) 
{
    TCHAR szTmp[MAX_PATH+1];
    BOOL bRes = FALSE;

    if (pszDir)
    {
        UINT uReturn = GetTempFileName(TEXT("."), TEXT("000"), 0, szTmp);

        if (0 == uReturn)
        {
            DWORD dwError = GetLastError();
            MYDBG(("CreateTempDir() GetTempFileName failed, GLE=%u.", dwError));
        }
        else
        {
            MYVERIFY(DeleteFile(szTmp));

            bRes = CreateDirectory(szTmp, NULL);

            if (!bRes) 
            {
                MYDBG(("CreateTempDir() CreateDirectory() failed, GLE=%u.",GetLastError()));
            }
            else
            {
                lstrcpy(pszDir, szTmp);
            }
        }
    }

    return bRes;
}

//
// Get the last character(DBCS-enabled)
//

TCHAR GetLastChar(LPTSTR pszStr)
{
    LPTSTR  pszPrev;
     
    if (!pszStr)
    {
    	return 0;
    }

    pszPrev = pszStr;

    while (*pszStr)
    {
	    pszPrev = pszStr;
	    pszStr = CharNext(pszStr);
    }

    return *pszPrev;
}


//+----------------------------------------------------------------------------
//
// Function:  GetCmArgV
//
// Synopsis:  Simulates ArgV using GetCommandLine
//
// Arguments: LPTSTR pszCmdLine - Ptr to a copy of the command line to be processed
//
// Returns:   LPTSTR * - Ptr to a ptr array containing the arguments. Caller is
//                       responsible for releasing memory.
//
// History:   nickball    Created     4/9/98
//
//+----------------------------------------------------------------------------
LPTSTR *GetCmArgV(LPTSTR pszCmdLine)
{   
    MYDBGASSERT(pszCmdLine);

    if (NULL == pszCmdLine || NULL == pszCmdLine[0])
    {
        return NULL;
    }

    //
    // Allocate Ptr array, up to MAX_CMD_ARGS ptrs
    //
    
    LPTSTR *ppCmArgV = (LPTSTR *) CmMalloc(sizeof(LPTSTR) * MAX_CMD_ARGS);

    if (NULL == ppCmArgV)
    {
        return NULL;
    }

    //
    // Declare locals
    //

    LPTSTR pszCurr;
    LPTSTR pszNext;
    LPTSTR pszToken;
    CMDLN_STATE state;
    state = CS_CHAR;
    int ndx = 0;  

    //
    // Parse out pszCmdLine and store pointers in ppCmArgV
    //

    pszCurr = pszToken = pszCmdLine;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // We found a token                
                    //

                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    ppCmArgV[ndx] = pszToken;
                    ndx++;

                    pszCurr = pszToken = pszNext;
                    state = CS_END_SPACE;
                    continue;
                }
				else 
                {
                    if (state == CS_END_SPACE || state == CS_END_QUOTE)
				    {
					    pszToken = CharNext(pszToken);
				    }
                }
                
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // We found a token
                    //
                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    
                    ppCmArgV[ndx] = pszToken;
                    ndx++;
                    
                    pszCurr = pszToken = pszNext;
                    
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    //
                    // End of the line, set last token
                    //

                    ppCmArgV[ndx] = pszToken;
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);

    return ppCmArgV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmdl\vpndownload.cpp ===
//+----------------------------------------------------------------------------
//
// File:     vpndownload.cpp
//
// Module:   CMDL32.EXE
//
// Synopsis: This file contains the code to handle the updating of VPN phonebooks.
//
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Author:   quintinb   Created     11/03/00
//
//+----------------------------------------------------------------------------
#include "cmdl.h"
#include "gppswithalloc.cpp"
#include "tunl_str.h"

//+----------------------------------------------------------------------------
//
// Function:  DownloadVpnFileFromUrl
//
// Synopsis:  This function is responsible for downloading a VPN file update
//            from the given URL and storing the retreived data in a temp file.
//            The full path to the temp file is passed back to the caller via
//            the ppszVpnUpdateFile variable.  The var must be freed by the caller.
//
// Arguments: LPCTSTR pszVpnUpdateUrl - URL to update the vpn file from
//            LPTSTR* ppszVpnUpdateFile - pointer to hold the file name of the
//                                        updated VPN file downloaded from the server.
//                                        Used by the caller to copy the temp file
//                                        over the existing file.  The memory allocated
//                                        for this string must be freed by the caller.
//
// Returns:   DWORD - ERROR_SUCCESS if download was successful, error code otherwise
//
// History:   quintinb Created     11/05/00
//
//+----------------------------------------------------------------------------
DWORD DownloadVpnFileFromUrl(LPCTSTR pszVpnUpdateUrl, LPTSTR* ppszVpnUpdateFile)
{
    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;
    BOOL bDeleteFileOnFailure = FALSE;
    HANDLE hFile = NULL;
    HINTERNET hInternet = NULL;
    HINTERNET hPage = NULL;
    DWORD dwSize = MAX_PATH;
    LPTSTR pszBuffer = NULL;
    BOOL bExitLoop = FALSE;

    if ((NULL == pszVpnUpdateUrl) || (TEXT('\0') == pszVpnUpdateUrl[0]))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    CMTRACE1("DownloadVpnFileFromUrl: URL is %s", pszVpnUpdateUrl);

    //
    //  First, let's create the file that we are going to download the updated file
    //  too.  This requires us to figure out what the temporary directory path is
    //  and then create a uniquely named file in it.
    //

    do
    {
        CmFree(pszBuffer);
        pszBuffer = (LPTSTR)CmMalloc((dwSize + 1)*sizeof(TCHAR));

        if (pszBuffer)
        {
            DWORD dwReturnedSize = GetTempPath (dwSize, pszBuffer);

            if (0 == dwReturnedSize)
            {
                //
                //  An error occurred, lets report it and bail.
                //
                dwError = GetLastError();
                CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- GetTempPath returned an error."));
                CMTRACE1(TEXT("DownloadVpnFileFromUrl -- GetTempPath failed, GLE = %d"), dwError);
                goto Cleanup;
            }
            else if (dwReturnedSize > dwSize)
            {
                //
                //  Not big enough we will have to loop again.
                //
                dwSize = dwReturnedSize;
                if (1024*1024 < dwReturnedSize)
                {
                    CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- GetTempPath asked for more than 1MB of memory.  Something is wrong, bailing."));
                    goto Cleanup;                
                }
            }
            else
            {
                //
                //  We got what we wanted, it's time to leave the loop
                //
                bExitLoop = TRUE;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- CmMalloc failed for pszBuffer."));
            goto Cleanup;
        }
    
    } while(!bExitLoop);

    //
    //  Okay, now we have the temp file path.  Next let's get a temp file name in that directory.
    //
    *ppszVpnUpdateFile = (LPTSTR)CmMalloc((dwSize + 24)*sizeof(TCHAR)); // GetTempFileName doesn't provide sizing info, lame
    
    if (*ppszVpnUpdateFile)
    {
        dwSize = GetTempFileName(pszBuffer, TEXT("VPN"), 0, *ppszVpnUpdateFile);

        if ((0 == dwSize) || (TEXT('\0') == (*ppszVpnUpdateFile)[0]))
        {
            dwError = GetLastError();
            CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- GetTempFileName failed."));
            goto Cleanup;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- CmMalloc failed for *ppszVpnUpdateFile"));
        goto Cleanup;    
    }

    //
    //  Free pszBuffer so we can use it to read in file data below
    //
    CmFree (pszBuffer);
    pszBuffer = NULL;

    //
    //  Okay, we have a file name let's get a file handle to it that we can write too
    //

    hFile = CreateFile(*ppszVpnUpdateFile, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        //
        //  We have created the file, let's make sure to delete it if we fail from here on out.
        //
        bDeleteFileOnFailure = TRUE;

        //
        //  Initialize WININET
        //
        hInternet = InternetOpen(TEXT("Microsoft(R) Connection Manager Vpn File Update"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

        if (hInternet)
        {            
            //
            // Supress auto-dial calls to CM from WININET now that we have a handle
            //
            SuppressInetAutoDial(hInternet);

            //
            //  Make sure that WinInet isn't in offline mode
            //
            (VOID)SetInetStateConnected(hInternet);

            //
            //  Open the URL
            //
            hPage = InternetOpenUrl(hInternet, pszVpnUpdateUrl, NULL, 0, 0, 0);

            if (hPage)
            {
                const DWORD c_dwBufferSize = 1024; // REVIEW: why did the original use 4096 on the stack, seems awfully large to me?
                pszBuffer = (LPTSTR)CmMalloc(c_dwBufferSize);

                if (pszBuffer)
                {
                    bExitLoop = FALSE;

                    do
                    {
                        if (InternetReadFile(hPage, pszBuffer, c_dwBufferSize, &dwSize))
                        {
                            //
                            //  We got data, write it to the temp file
                            //

                            if (0 == dwSize)
                            {
                                //
                                //  We succeeded with a zero read size.  That means we hit
                                //  end of file and are done.
                                //
                                dwError = ERROR_SUCCESS;
                                bExitLoop = TRUE;
                            }

                            if (FALSE == WriteFile(hFile, pszBuffer, dwSize, &dwSize, NULL))
                            {
                                dwError = GetLastError();
                                CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- WriteFile failed."));
                                goto Cleanup;   
                            }
                        }
                        else
                        {
                            dwError = GetLastError();
                            goto Cleanup;
                        }

                    } while (!bExitLoop);

                    //
                    // now let's see if we have a valid file, or an "error" HTML page
                    //
                    if (0 == GetPrivateProfileSection(c_pszCmSectionVpnServers,
                                                      pszBuffer,
                                                      c_dwBufferSize,
                                                      *ppszVpnUpdateFile))
                    {
                        dwError = ERROR_INVALID_DATA;
                        CMTRACE(TEXT("DownloadVpnFileFromUrl -- downloaded file does not seem to contain a VPN list."));
                        goto Cleanup;
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- unable to allocate the file buffer"));
                    goto Cleanup;                
                }
            }
            else
            {
                dwError = GetLastError();
                CMTRACE1(TEXT("DownloadVpnFileFromUrl -- InternetOpenUrl failed, GLE %d"), dwError);
            }
        }
        else
        {
            dwError = GetLastError();
            CMTRACE1(TEXT("DownloadVpnFileFromUrl -- InternetOpen failed, GLE %d"), dwError);
        }
    }

Cleanup:

    //
    //  Close our handles
    //
    if (hPage)
    {
        InternetCloseHandle(hPage);
    }

    if (hInternet)
    {
        InternetCloseHandle(hInternet);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    //
    //  Free up the buffer we alloc-ed
    //
    CmFree(pszBuffer);

    //
    //  Finally cleanup the temp file and temp file name if we failed
    //
    if (ERROR_SUCCESS != dwError)
    {
        if (bDeleteFileOnFailure && *ppszVpnUpdateFile)
        {
            DeleteFile(*ppszVpnUpdateFile);
        }

        CmFree(*ppszVpnUpdateFile);
        *ppszVpnUpdateFile = NULL;

        CMTRACE(TEXT("DownloadVpnFileFromUrl -- VPN file download failed!"));
    }
    else
    {
        CMTRACE(TEXT("DownloadVpnFileFromUrl -- VPN file download succeeded!"));
    }

    return dwError;
}

//+----------------------------------------------------------------------------
//
// Function:  OverwriteVpnFileWithUpdate
//
// Synopsis:  This function is responsible for copying the given new vpn file
//            over the given existing vpn file.  The code first makes a backup
//            copy of the existing file just in case something goes wrong with the
//            data overwrite.  If a problem exists then it copies the original back
//            over to ensure nothing got corrupted in the failed copy.
//
// Arguments: LPCTSTR pszExistingVpnFile - full path to the existing VPN file
//            LPCTSTR pszNewVpnFile - full path to the temp VPN file to overwrite
//                                    the existing file with.
//
// Returns:   DWORD - ERROR_SUCCESS if update was successful, error code otherwise
//
// History:   quintinb Created     11/03/00
//
//+----------------------------------------------------------------------------
DWORD OverwriteVpnFileWithUpdate(LPCTSTR pszExistingVpnFile, LPCTSTR pszNewVpnFile)
{
    if ((NULL == pszExistingVpnFile) || (NULL == pszNewVpnFile) ||
        (TEXT('\0') == pszExistingVpnFile[0]) || (TEXT('\0') == pszNewVpnFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("OverwriteVpnFileWithUpdate -- invalid parameter passed."));
        return FALSE;
    }

    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;

    //
    //  We first want to make a backup copy of the original file
    //
    const TCHAR* const c_pszDotBak = TEXT(".bak");
    DWORD dwSize = (lstrlen(pszExistingVpnFile) + lstrlen(c_pszDotBak) + 1)*sizeof(TCHAR);

    LPTSTR pszBackupFile = (LPTSTR)CmMalloc(dwSize);

    if (pszBackupFile)
    {
        wsprintf(pszBackupFile, TEXT("%s%s"), pszExistingVpnFile, c_pszDotBak);

        CMASSERTMSG(pszBackupFile[0], TEXT("OverwriteVpnFileWithUpdate -- wsprintf failed!"));
        if (CopyFile(pszExistingVpnFile, pszBackupFile, FALSE)) // FALSE == bFailIfExists
        {
            //
            //  Now copy over the new file
            //
            if (CopyFile(pszNewVpnFile, pszExistingVpnFile, FALSE)) // FALSE == bFailIfExists
            {
                dwError = ERROR_SUCCESS;
            }
            else
            {
                dwError = GetLastError();
                CMTRACE1(TEXT("OverwriteVpnFileWithUpdate -- CopyFile of the new file over the original file failed, GLE %s"), dwError);
                CMASSERTMSG(FALSE, TEXT("OverwriteVpnFileWithUpdate -- update of the original file failed, attempting to restore the original from backup."));

                //
                //  We need to restore the backup file
                //
                if (!CopyFile(pszBackupFile, pszExistingVpnFile, FALSE)) // FALSE == bFailIfExists
                {
                    // NOTE we don't use dwError here, we want the original error to be logged
                    CMTRACE1(TEXT("OverwriteVpnFileWithUpdate -- CopyFile to restore the saved backup file failed, GLE %s"), GetLastError());

                    CMASSERTMSG(FALSE, TEXT("OverwriteVpnFileWithUpdate -- restoration of backup failed!"));
                }
            }

            //
            //  Delete the backup file
            //
            DeleteFile(pszBackupFile);
        }
        else
        {
            dwError = GetLastError();
            CMTRACE1(TEXT("OverwriteVpnFileWithUpdate -- CopyFile of the original file to the backup file failed, GLE %s"), dwError);
        }
    }

    CmFree(pszBackupFile);

    if (ERROR_SUCCESS == dwError)
    {
        CMTRACE(TEXT("OverwriteVpnFileWithUpdate -- VPN file update succeeded!"));
    }
    else
    {
        CMTRACE(TEXT("OverwriteVpnFileWithUpdate -- VPN file update failed."));    
    }

    return dwError;
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateVpnFileForProfile
//
// Synopsis:  This function is called to download and update a VPN file with a
//            newly downloaded VPN update file.
//
// Arguments: LPCTSTR pszCmpPath - full path to the cmp file
//            CmLogFile * pLog - object to use for logging
//
// Returns:   BOOL - TRUE if the download and update were successful.
//
// History:   quintinb Created     11/03/00
//
//+----------------------------------------------------------------------------
BOOL UpdateVpnFileForProfile(LPCTSTR pszCmpPath, LPCTSTR pszCmsPath, CmLogFile * pLog, BOOL bCheckConnection)
{
    if ((NULL == pszCmpPath) || (TEXT('\0') == pszCmpPath[0]))
    {
        CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- invalid pszCmpPath parameter."));
        return FALSE;
    }

    BOOL bLogAtEnd = TRUE;
    BOOL bReturn = FALSE;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (pszCmsPath && *pszCmsPath)
    {
        //
        //  Let's check to see if we are connected unless the caller told us to skip the check
        //
        if (bCheckConnection)
        {
            LPTSTR pszConnectionName = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryServiceName, TEXT(""), pszCmsPath);

            if (pszConnectionName && *pszConnectionName)
            {
                if (FALSE == IsConnectionAlive(pszConnectionName))
                {
                    CMTRACE(TEXT("UpdateVpnFileForProfile -- not connected ... aborting."));
                    pLog->Log(VPN_DOWNLOAD_FAILURE, ERROR_NOT_CONNECTED, TEXT(""), TEXT(""));
                    CmFree(pszConnectionName);
                    return FALSE;
                }
            }

            CmFree(pszConnectionName);
        }

        //
        //  Next get the VPN phonebook file name from the profile.
        //
        LPTSTR pszVpnFileName = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryTunnelFile, TEXT(""), pszCmsPath);

        if (pszVpnFileName && *pszVpnFileName)
        {
            LPTSTR pszVpnFile = CmBuildFullPathFromRelative(pszCmpPath, pszVpnFileName);

            if (pszVpnFile && *pszVpnFile)
            {
                //
                //  Now get the URL to update the vpn file from
                //
                LPTSTR pszVpnUpdateUrl = GetPrivateProfileStringWithAlloc(c_pszCmSectionSettings, c_pszCmEntryVpnUpdateUrl, TEXT(""), pszVpnFile);

                if (pszVpnUpdateUrl && *pszVpnUpdateUrl)
                {
                    //
                    //  Finally, we have a URL so let's download the updated VPN server list.
                    //
                    LPTSTR pszUpdatedVpnFile = NULL;

                    dwError = DownloadVpnFileFromUrl(pszVpnUpdateUrl, &pszUpdatedVpnFile);
                    bReturn = (ERROR_SUCCESS == dwError);

                    bLogAtEnd = FALSE;  // we're going to start logging items right now
                    if (bReturn)
                    {
                        pLog->Log(VPN_DOWNLOAD_SUCCESS, pszVpnFile, pszVpnUpdateUrl);
                    }
                    else
                    {
                        pLog->Log(VPN_DOWNLOAD_FAILURE, dwError, pszVpnFile, pszVpnUpdateUrl);
                    }

                    if (bReturn && pszUpdatedVpnFile && *pszUpdatedVpnFile)
                    {
                        dwError = OverwriteVpnFileWithUpdate(pszVpnFile, pszUpdatedVpnFile);
                        bReturn = (ERROR_SUCCESS == dwError);
                        if (bReturn)
                        {
                            pLog->Log(VPN_UPDATE_SUCCESS, pszVpnFile);
                        }
                        else
                        {
                            pLog->Log(VPN_UPDATE_FAILURE, dwError, pszVpnFile);
                        }
                    }

                    CmFree (pszUpdatedVpnFile);
                }
                else
                {
                    dwError = GetLastError();
                    CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to get the URL to update the vpn file from..."));    
                }

                CmFree(pszVpnUpdateUrl);
            }
            else
            {
                dwError = GetLastError();
                CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to expand the path to the vpn file."));    
            }

            CmFree(pszVpnFile);
        }
        else
        {
            dwError = GetLastError();
            CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to retrieve the vpn file name."));    
        }

        CmFree(pszVpnFileName);
    }

    if (bLogAtEnd)
    {
        pLog->Log(VPN_DOWNLOAD_FAILURE, dwError, TEXT("?"), TEXT("?"));
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmgr\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:	 cmmaster.h
//
// Module:	 CMMGR32.EXE
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 quintinb    Created header    08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "icm.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmgr\cmfmtstr.h ===
//+----------------------------------------------------------------------------
//
// File:     cmfmtstr.h
//
// Module:   CMMGR32.EXE
//
// Synopsis: String IDs for cmfmtstr.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#define IDMSG_NOCMDLINE_MSG             11000
#define IDMSG_NOCMS_MSG					11101
#define IDMSG_APP_TITLE                 11102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmgr\icm.h ===
//+----------------------------------------------------------------------------
//
// File:     icm.h
//
// Module:   CMMGR32.EXE
//
// Synopsis: Main header for cmmgr32.exe
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#ifndef _ICM_INC
#define _ICM_INC

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <ctype.h>
#include <wchar.h>
#include <raserror.h>
#include <rasdlg.h>
#include <shlobj.h>

#include "cmras.h"
#include "cm_def.h"
#include "cmdebug.h"
#include "cmutil.h"
#include "cmdial.h"

#include "base_str.h"
#include "mgr_str.h"
#include "reg_str.h"

#include "uapi.h"

#include "cmfmtstr.h"

#ifdef __cplusplus
extern "C" {
#endif

extern HINSTANCE g_hInst;

#ifdef __cplusplus
}
#endif

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//
// External prototypes from util.cpp
//

BOOL GetProfileInfo(
    LPTSTR pszCmpName,
    LPTSTR pszServiceName
);

BOOL IsCmpPathAllUser(
    LPCTSTR pszCmp
);


#endif // _ICM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmgr\cmmgr.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmmgr.cpp
//
// Module:   CMMGR32.EXE
//
// Synopsis: Main file for the CM downlevel executable.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb    Created header    08/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

// 
// Common CM includes
//

#include "cmtiming.h"

BOOL InitArgs(
    LPTSTR    pszCmdln,
    LPTSTR    pszCmp,
    PDWORD    pdwFlags
);

void CheckCmdArg(
    LPTSTR  pszToken, 
    LPTSTR  pszCmp, 
    PDWORD  pdwFlags
);
                    


HINSTANCE   g_hInst;


//+---------------------------------------------------------------------------
//
//  Function:   InitArgs
//
//  Synopsis:   Parses the command line arguments, return the connectoid name if 
//              "dialing with connectoid"
//
//  Arguments:  pArgs           - Pointer to global args struct
//              nArgC           - number of command line arguments
//              ppszArgv        - command arguments
//              pszConnectoid   - Connectoid name as found on command line
//
//  Returns:    TRUE        if succeed
//              FALSE       otherwise
//
//  History:    byao        Modified  5/8/97
//                          Added handler for 'dialing with connectoid'
//----------------------------------------------------------------------------
BOOL InitArgs(
    LPTSTR    pszCmdln,
    LPTSTR    pszCmp,
    PDWORD    pdwFlags
) 
{
    LPTSTR  pszCurr;
    LPTSTR  pszToken;

    CMDLN_STATE state;
    
    // Parse the command line.

    state = CS_CHAR;
    pszCurr = pszToken = pszCmdln;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // we found a token
                    //
                    *pszCurr = TEXT('\0');
                    CheckCmdArg(pszToken, pszCmp, pdwFlags);
                    *pszCurr = TEXT(' ');
                    pszCurr = pszToken = CharNextU(pszCurr);
                    state = CS_END_SPACE;
                    continue;
                }
                else if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    pszToken = CharNextU(pszToken);
                }
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // we found a token
                    //
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNextU(pszToken);
                    CheckCmdArg(pszToken, pszCmp, pdwFlags);
                    *pszCurr = TEXT('\"');
                    pszCurr = pszToken = CharNextU(pszCurr);
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    CheckCmdArg(pszToken, pszCmp, pdwFlags);
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNextU(pszCurr);
    } while (state != CS_DONE);

    return TRUE;
}



//
// determines the cmdline parameter.
//
void CheckCmdArg(
    LPTSTR  pszToken, 
    LPTSTR  pszCmp, 
    PDWORD  pdwFlags
)
{
    struct 
    {
        LPCTSTR pszArg;
        DWORD dwFlag;
    } ArgTbl[] = {
                  {TEXT("/settings"),FL_PROPERTIES},
                  {TEXT("/autodial"),FL_AUTODIAL},
                  {TEXT("/unattended"), FL_UNATTENDED},  // unattended dial
                  {NULL,0}};
    
    CMTRACE1(TEXT("Command line argument %s"), pszToken);

    //
    // Look through our table for a match and set flags accordingly.
    //
    
    for (size_t nIdx=0;ArgTbl[nIdx].pszArg;nIdx++) 
    {
        if (lstrcmpiU(pszToken, ArgTbl[nIdx].pszArg) == 0) 
        {
            MYDBGASSERT(!(*pdwFlags & ArgTbl[nIdx].dwFlag)); // only one of each please
            CMTRACE2(TEXT("InitArgs() parsed option %s, flag=0x%x."), pszToken, ArgTbl[nIdx].dwFlag);

            *pdwFlags |= ArgTbl[nIdx].dwFlag;

            break;
        }
    }

    // 
    // If table is exhausted, then its a data argument.
    //

    if (!ArgTbl[nIdx].pszArg) 
    {
        // 
        // If this is the first data argument then it must be a profile 
        // source, either a .CMP file, a "connectoid" (.CON file).
        //
        lstrcpyU(pszCmp, pszToken);
    }

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  WinMain
//
// Synopsis:  Main entry point of the exe
//
// History:   byao      Modified        05/06/97    
//                          handle 'dialing with connectoid' and 'unattended dialing'
//
//            quintinb  Modified        05/12/99
//                          bAllUsers for MSN to use cmmgr32.exe on both NT5 and win98SR1
//
//+----------------------------------------------------------------------------

int WINAPI WinMain(HINSTANCE hInst, 
                   HINSTANCE hPrevInst, 
                   LPSTR /*pszCmdLine*/, 
                   int /*iCmdShow*/) 
{

    //
    //  First Things First, lets initialize the U Api's
    //
    if (!InitUnicodeAPI())
    {
        //
        //  Without our U api's we are going no where.  Bail.
        //
        MessageBox(NULL, TEXT("Cmmgr32.exe Initialization Error:  Unable to initialize Unicode to ANSI conversion layer, exiting."),
                   TEXT("Connection Manager"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    LPTSTR pszCmdLine;

    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMGR32.EXE - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    CM_SET_TIMING_INTERVAL("WinMain");

    //
    // Declare local vars
    //

    TCHAR   szServiceName[RAS_MaxEntryName] = {0};    // service name
    TCHAR   szCmp[MAX_PATH];                    // cmp filename
    LPTSTR  pszCL;
    DWORD   dwExitCode = ERROR_SUCCESS;
    DWORD   dwFlags = 0;
    DWORD   dwSize;   
    BOOL    bAllUsers; 
    LPCMDIALINFO lpCmInfo = NULL;

#ifndef UNICODE
    LPWSTR pszwServiceName;
#endif

    //
    // we can't use hInst if we're linked with libc.  libc uses GetModuleHandle(NULL).
    //
    g_hInst = GetModuleHandleA(NULL);

    //
    //  Expand any environment strings in the command line
    //


    dwSize = lstrlenU(GetCommandLine()) + 1;

    do
    {
        pszCmdLine = (LPTSTR)CmMalloc(sizeof(WCHAR)*dwSize);

        if (pszCmdLine)
        {
            DWORD dwRequiredSize = ExpandEnvironmentStringsU(GetCommandLine(), pszCmdLine, dwSize);
            if (0 == dwRequiredSize)
            {
                CMASSERTMSG(FALSE, TEXT("ExpandEnvironmentStrings Failed, exiting."));
                goto done;
            }
            else if (dwRequiredSize > dwSize)
            {
                //
                //  Buffer not large enough.  Try again.
                //
                dwSize = dwRequiredSize;
                CmFree(pszCmdLine);
            }
            else
            {
                //
                //  It worked and was the correct size
                //
                break;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("Unable to CmMalloc Memory for the command line string, exiting."));
            goto done;            
        }

    } while(1);
    
    //
    //  Now process the command line
    //
    CmStrTrim(pszCmdLine);

    pszCL = pszCmdLine;

    //
    // Scan, and skip over, subsequent characters until
    // another double-quote or a null is encountered.
    //
    if (*pszCL == TEXT('\"')) 
    {
        while (*(++pszCL) != TEXT('\"')
            && *pszCL) 
            ;

        //
        // If we stopped on a double-quote (usual case), skip
        // over it.
        //
        if ( *pszCL == TEXT('\"') )
            pszCL++;
    }

    //
    // skip the spaces
    //
    while (*pszCL && *pszCL == TEXT(' '))
        pszCL++;

    //
    // Return here if command line is empty - ALL PLATFORMS !!!!!!!
    //

    if (pszCL[0] == TEXT('\0'))
    {
        LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NOCMDLINE_MSG);
        LPTSTR pszTitle = CmFmtMsg(g_hInst, IDMSG_APP_TITLE);
        MessageBoxEx(NULL,pszMsg, pszTitle, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309
        CmFree(pszTitle);
        CmFree(pszMsg);
        
        dwExitCode = ERROR_WRONG_INFO_SPECIFIED;
        goto done;
    }

    //
    // Parse the command line options: Basically, this is to set 
    // commandline option flags, as well as the profile filename
    //
    //
    // without libc, pszCmdLine in WinMain is empty.
    //
    if (!InitArgs(pszCL, szCmp, &dwFlags))
    {
        dwExitCode = GetLastError();
        goto done;
    }

    //
    // Get the service name from the CMP
    // 

    if (!GetProfileInfo(szCmp, szServiceName))
    {
        CMTRACE(TEXT("WinMain() can't run without a profile on the command line."));
        LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NOCMS_MSG);
        LPTSTR pszTitle = CmFmtMsg(g_hInst, IDMSG_APP_TITLE);
        MessageBoxEx(NULL, pszMsg, pszTitle, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309       
        CmFree(pszMsg);
        CmFree(pszTitle);
        
        dwExitCode = ERROR_WRONG_INFO_SPECIFIED;           
        goto done;
    }

    //
    // Always set the FL_DESKTOP flag when CMMGR is calling, it is more 
    // efficient than checking the module filename inside CmCustomDialDlg
    //

    if (!(dwFlags & FL_DESKTOP))
    {
        dwFlags |= FL_DESKTOP;
    }

    //
    // Call CMDIAL as appropriate
    // 
    
    lpCmInfo = (LPCMDIALINFO) CmMalloc(sizeof(CMDIALINFO));
   
    if (NULL == lpCmInfo)
    {
        dwExitCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    lpCmInfo->dwCmFlags = dwFlags;

    //
    // Determine if this is an all user call based upon the path. 
    // Thus we can support single-user profiles on NT5.
    //

    bAllUsers = IsCmpPathAllUser(szCmp);

    CmCustomDialDlg(NULL, 
                bAllUsers ? RCD_AllUsers : RCD_SingleUser, 
                NULL,           
                szServiceName, 
                NULL, 
                NULL, 
                NULL,
                lpCmInfo);

done:   

    UnInitUnicodeAPI();
    
    CmFree(pszCmdLine);
    CmFree(lpCmInfo);

    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMGR32.EXE - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    //
    // the C runtine uses ExitProcess() to exit.
    //

    ExitProcess((UINT)dwExitCode);
   
    return ((int)dwExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Precompiled header for cmmon
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#include <windows.h>
#include "CmDebug.h"
#include "CmUtil.h"
#include "shelldll.h"
#include "Base_Str.h"
#include "Dl_Str.h"
#include "Mgr_Str.h"
#include "Mon_Str.h"

#include "uapi.h"
#include "pwutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\cm_misc.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Miscellaneous function headers for cmmon32.exe
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#ifndef _CM_MISC_INC
#define _CM_MISC_INC

//
// Utility.cpp
//
void FmtNum(DWORD dwNum, LPSTR pszNum, DWORD dwNumSize); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\connection.cpp ===
//+----------------------------------------------------------------------------
//
// File:     connection.cpp  
//
// Module:   CMMON32.EXE
//
// Synopsis: 
//      Implement class CCmConnection
//      CCmConnection manages a single connection.  
//           
//      The m_StatusDlg lives through out the CONNECTED/DISCONNECT_COUNTDOWN
//      state.  The appearance changes when it comes to COUNTDOWN state.
//
//      The m_ReconnectDlg is the reconnect prompt dialog.  It exist during
//      STATE_PROMPT_RECONNECT state.
//
//      Both dialogs are modeless.  (We need a initially invisible status dialog 
//      to receive timer and trayicon message.  I did not find any way to create
//      a invisible modal dialog without flashing.)
//
//      CreateDialog will simply return, unlike DialogBox, which returns only after
//      Dialog is ended.  To simplify the implementation, we handle end-dialog event
//      in the thread routine instead of in the dialog procedure.
//
//      When we need to end the status or reconnect dialog, we simply post a thread 
//      message to end the dialog and continue to the next state.  The connection 
//      thread runs a message loop and processes thread message.
//
//      The RasMonitorDlg on NT is running in another thread.  Otherwise the connection
//      thread message can not be processed
//
//      The connection is event driven module.  ConnectionThread() is the entry 
//      point of the connection thread.
//
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    2/11/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "connection.h"
#include "Monitor.h"
#include "TrayIcon.h"
#include "ShellDll.h"
#include <tchar.h>
#include <rasdlg.h>
#include "cmdial.h"
#include <wininet.h> // for INTERNET_DIALSTATE_DISCONNECTED
#include "DynamicLib.h"

#include "log_str.h"
#include "userinfo_str.h"

HINSTANCE g_hInst = NULL;

//
// Functions in cmdial32.dll, the prototype is in cmdial.h
//
static const CHAR* const c_pszCmReconnect = "CmReConnect";
static const CHAR* const c_pszCmHangup = "CmCustomHangUp";

//
// CMS flags used exclusively by connection.cpp
//
static const TCHAR* const c_pszCmEntryIdleThreshold     = TEXT("IdleThreshold");
static const TCHAR* const c_pszCmEntryNoPromptReconnect = TEXT("NoPromptReconnect");
static const TCHAR* const c_pszCmEntryHideTrayIcon      = TEXT("HideTrayIcon");

typedef BOOL (WINAPI * CmReConnectFUNC)(LPTSTR lpszPhonebook, 
    LPTSTR lpszEntry, 
    LPCMDIALINFO lpCmInfo);

typedef DWORD (WINAPI * CmCustomHangUpFUNC)(HRASCONN hRasConn, 
    LPCTSTR pszEntry,
    BOOL fIgnoreRefCount,
    BOOL fPersist);

//
// The timer interval for StateConnectedOnTimer();
//
const DWORD TIMER_INTERVAL = 1000;

DWORD CCmConnection::m_dwCurPositionId = 0;
//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CCmConnection
//
// Synopsis:  Constructor, called in the monitor thread
//
// Arguments: const CONNECTED_INFO* pConnectedInfo - Information passed from 
//                cmdial upon conected
//            const CM_CONNECTION* pConnectionEntry - Information in the
//                Connection table
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
CCmConnection::CCmConnection(const CM_CONNECTED_INFO* pConnectedInfo, 
                             const CM_CONNECTION* pConnectionEntry) : 
#pragma warning(disable:4355) //'this' : used in base member initializer list
    m_StatusDlg(this),
#pragma warning(default:4355) 
    m_TrayIcon()
{
    MYDBGASSERT(pConnectedInfo);
    MYDBGASSERT(pConnectionEntry);

    m_dwState = STATE_CONNECTED;
    m_hBigIcon = m_hSmallIcon = NULL;

    m_dwConnectStartTime = GetTickCount() - 500; // .5 second for round off

    m_dwCountDownStartTime = 0;
    m_dwThreadId = 0;

    //
    // set this to TRUE, so the WorkingSet will be minimized before MsgWait
    // while there is no more message
    //
    m_fToMinimizeWorkingSet = TRUE;  

    m_fHideTrayIcon = FALSE;

    //
    // Save the data from pConnectedInfo
    //

    //lstrcpynU(m_ReconnectInfo.szPassword, pConnectedInfo->szPassword, 
    //    sizeof(m_ReconnectInfo.szPassword)/sizeof(m_ReconnectInfo.szPassword[0]));
    //lstrcpynU(m_ReconnectInfo.szInetPassword, pConnectedInfo->szInetPassword, 
    //    sizeof(m_ReconnectInfo.szPassword)/sizeof(m_ReconnectInfo.szPassword[0]));

    m_ReconnectInfo.dwCmFlags = pConnectedInfo->dwCmFlags | FL_RECONNECT; // Cm specific flags

    lstrcpynU(m_szServiceName, pConnectedInfo->szEntryName, sizeof(m_szServiceName)/sizeof(m_szServiceName[0]));

    //
    // NOTE: Fast User Switching is only available on WinXP and beyond, and this
    //       member variable should only be accessed/used for WinXP and beyond.
    //
    m_fGlobalGlobal = (pConnectionEntry->fAllUser && (pConnectedInfo->dwCmFlags & FL_GLOBALCREDS));
    CMTRACE1(TEXT("CCmConnection::CCmConnection set m_fGlobalGlobal to %d"), m_fGlobalGlobal);

    //
    // Get the RAS phonebook
    //

    lstrcpynU(m_szRasPhoneBook, pConnectedInfo->szRasPhoneBook, sizeof(m_szRasPhoneBook)/sizeof(m_szRasPhoneBook[0]));   

    //
    // Init m_IniProfile, m_IniService and m_IniBoth
    //
    InitIniFiles(pConnectedInfo->szProfilePath);

    //
    //  Because the IdleTimeout and EnableLogging values are not saved
    //  per access point as all the other profile settings are, we must change the PrimaryRegPath
    //  value of m_IniBoth so that it points to the non-access point registry location.
    //
    LPCTSTR c_pszUserInfoRegPath = (pConnectionEntry->fAllUser) ? c_pszRegCmUserInfo : c_pszRegCmSingleUserInfo;

    LPTSTR pszSavedPrimaryRegPath = CmStrCpyAlloc(m_IniBoth.GetPrimaryRegPath());
    LPTSTR pszPrimaryRegPath = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lstrlenU(c_pszUserInfoRegPath) + lstrlenU(m_szServiceName) + 1));

    if (pszPrimaryRegPath && pszSavedPrimaryRegPath)
    {
        wsprintfU(pszPrimaryRegPath, TEXT("%s%s"), c_pszUserInfoRegPath, m_szServiceName);
        
        m_IniBoth.SetPrimaryRegPath(pszPrimaryRegPath);

        CmFree(pszPrimaryRegPath);
    }

    //
    //  Initialize Logging
    //
    m_Log.Init(g_hInst, pConnectionEntry->fAllUser, GetServiceName());
    
    BOOL fEnabled       = FALSE;
    DWORD dwMaxSize     = 0;
    LPTSTR pszFileDir   = NULL;

    fEnabled    = m_IniBoth.GPPB(c_pszCmSection, c_pszCmEntryEnableLogging, c_fEnableLogging);
    dwMaxSize   = m_IniService.GPPI(c_pszCmSectionLogging, c_pszCmEntryMaxLogFileSize, c_dwMaxFileSize);
    pszFileDir  = m_IniService.GPPS(c_pszCmSectionLogging, c_pszCmEntryLogFileDirectory, c_szLogFileDirectory);
    
    m_Log.SetParams(fEnabled, dwMaxSize, pszFileDir);
    if (m_Log.IsEnabled())
    {
        m_Log.Start(FALSE);     // FALSE => no banner
    }
    else
    {
        m_Log.Stop();
    }
    CmFree(pszFileDir);

    //
    // Whether to enable auto disconnect for no-traffic and no-watch-process
    // 0 of dwIdleTime means never timeout
    //

    const DWORD DEFAULT_IDLETIMEOUT = 10;  // default idle time out is 10 minute
    DWORD dwIdleTime = (DWORD) m_IniBoth.GPPI(c_pszCmSection, 
                                              c_pszCmEntryIdleTimeout, 
                                              DEFAULT_IDLETIMEOUT);

    //
    //  Set the m_IniBoth object back to its previous Primary Reg path
    //
    if (pszSavedPrimaryRegPath)
    {
        m_IniBoth.SetPrimaryRegPath(pszSavedPrimaryRegPath);
        CmFree(pszSavedPrimaryRegPath);
    }

    //
    // No watch-process time-out if IdleTime is "never"
    //
    if (dwIdleTime)
    {
        for (int i=0; pConnectedInfo->ahWatchHandles[i] != 0; i++)
        {

            m_WatchProcess.Add(pConnectedInfo->ahWatchHandles[i]);
        }
    }

    if (!OS_NT4)
    {        
        m_ConnStatistics.SetDialupTwo(pConnectedInfo->fDialup2);

        m_ConnStatistics.Open(CMonitor::GetInstance(),
                           pConnectedInfo->dwInitBytesRecv,
                           pConnectedInfo->dwInitBytesSend,
                           pConnectionEntry->hDial,
                           pConnectionEntry->hTunnel);
        if (dwIdleTime)
        {
            //
            // Adjust minutes value to milliseconds
            //

            dwIdleTime = dwIdleTime * 1000 * 60;

            DWORD dwIdleThreshold = m_IniService.GPPI(c_pszCmSection,
                                                      c_pszCmEntryIdleThreshold,
                                                      0L); // default threshold is always 0 bytes

            //
            // Start idle statistic counter anyway
            // IsIdle will return FALSE, if it is never updated
            //
            m_IdleStatistics.Start(dwIdleThreshold, dwIdleTime);
        }
    }

    //
    // Save data from pConnectionEntry
    //
    MYDBGASSERT(pConnectionEntry->hDial || pConnectionEntry->hTunnel);
    MYDBGASSERT(pConnectionEntry->CmState == CM_CONNECTED);

    m_hRasDial = pConnectionEntry->hDial;
    m_hRasTunnel = pConnectionEntry->hTunnel;

    m_szHelpFile[0] = 0;
    
    //
    // the position id increased by 1 for each connection
    //
    m_dwPositionId = m_dwCurPositionId;
    m_dwCurPositionId++;
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::~CCmConnection
//
// Synopsis:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/18/98
//
//+----------------------------------------------------------------------------
CCmConnection::~CCmConnection()
{
    ASSERT_VALID(this);

    if (m_hBigIcon)
    {
        DeleteObject(m_hBigIcon);
    }

    if (m_hSmallIcon)
    {
        DeleteObject(m_hSmallIcon);
    }

    if (m_hEventRasNotify)
    {
        CloseHandle(m_hEventRasNotify);
    }

    //
    //  UnInitialize Logging
    //
    m_Log.DeInit();

}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::InitIniFiles
//
// Synopsis:  Initialize data member m_IniProfile, m_IniService and m_IniBoth
//
// Arguments: const TCHAR* pszProfileName - the full path of the .cmp file
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/10/98
//
//+----------------------------------------------------------------------------

void CCmConnection::InitIniFiles(const TCHAR* pszProfileName)
{
    if (NULL == pszProfileName)
    {
        return;
    }

    g_hInst = CMonitor::GetInstance(); 

    //
    // .cmp file
    //
    m_IniProfile.Clear();
    m_IniProfile.SetHInst(CMonitor::GetInstance());
    m_IniProfile.SetFile(pszProfileName);

    //
    // .cms file
    //
    m_IniService.Clear();
    m_IniService.SetHInst(CMonitor::GetInstance());

    LPTSTR pszService = m_IniProfile.GPPS(c_pszCmSection,c_pszCmEntryCmsFile);
    MYDBGASSERT(pszService);

    //
    // the .cms file is relative to .cmp path, convert it to absolute path
    //

    LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszService);

    MYDBGASSERT(pszFullPath);

    if (pszFullPath)
    {
        m_IniService.SetFile(pszFullPath);
    }

    CmFree(pszFullPath);
    CmFree(pszService);

    // both: .CMP file takes precedence over .CMS file
    //       use .CMP file as primary file
    //
    m_IniBoth.Clear();
    m_IniBoth.SetHInst(CMonitor::GetInstance());
    m_IniBoth.SetFile(m_IniService.GetFile());
    m_IniBoth.SetPrimaryFile(m_IniProfile.GetFile());
}


//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StartConnectionThread
//
// Synopsis:  Start the connection thread.  Called by monitor on CONNECTED 
//            message from cmdial
//
// Arguments: None
//
// Returns:   BOOL - Whether the thread is created successfully
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::StartConnectionThread()
{
    DWORD dwThreadId;
    HANDLE hThread;
    
    if ((hThread = CreateThread(NULL, 0, ConnectionThread ,this,0,&dwThreadId)) == NULL)
    {
        MYDBGASSERT(FALSE);
        CMTRACE(TEXT("CCmConnection::StartConnectionThread CreateThread failed"));
        return FALSE;
    }

    CloseHandle(hThread);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  static CCmConnection::ConnectionThread
//
// Synopsis:  The connection thread. Call back function for CreateThread
//
// Arguments: LPVOID lParam - pConnection
//
// Returns:   DWORD WINAPI - thread exit code
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI CCmConnection::ConnectionThread(LPVOID lParam)
{
    MYDBGASSERT(lParam);

    //
    // Call the non-static function
    //
    return ((CCmConnection*)lParam)->ConnectionThread();
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::ConnectionThread
//
// Synopsis:  The non-static connection thread, so we can referrence 
//            data/fuction directly
//
// Arguments: None
//
// Returns:   DWORD - thread exit code
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
DWORD CCmConnection::ConnectionThread()
{
    m_dwThreadId = GetCurrentThreadId();

    m_dwState = STATE_CONNECTED;

    //
    // Run the connected/disconnect-count-down state
    // StateConnected() will change m_dwState to the new state
    //
    StateConnected();

    //
    // Whether to remove the connection from the shared connection table
    // This is TRUE, only if user clicks No for the prompt reconnect dialog
    //
    BOOL fRemoveFromSharedTable = FALSE;

    if (m_dwState != STATE_TERMINATED)
    {
        //
        // if auto reconnect is not enabled, then show the reconnect prompt
        //
        if (m_dwState != STATE_RECONNECTING)
        {
            //
            // Run the prompt reconnect state
            //
            m_dwState = StatePrompt();
        }

        if (m_dwState != STATE_RECONNECTING)
        {
            //
            // User clicks No for the reconnect-prompt dialog
            // Clear the entry from connection table
            //
            fRemoveFromSharedTable = TRUE;
        }
        else
        {
            //
            // User clicks Yes for the reconnect-prompt dialog
            // Move from Connected array to reconnecting array
            //

            CMonitor::MoveToReconnectingConn(this);

            //
            // Run the reconnect state
            //
            Reconnect();
        }
    }

    CMTRACE(TEXT("The connection thread is terminated"));

    //
    // The connection is terminated without need to ask for reconnect
    // Remove the connection from monitor conntected connection array
    // If fRemoveFromSharedTable is FALSE, do not clear the entry from shared table. 
    // CmCustomHangup clears the table
    // Monitor will delete the connection object.  Must exit the thread after this. 
    //
    CMonitor::RemoveConnection(this, fRemoveFromSharedTable);

    CMonitor::MinimizeWorkingSet();

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedInit
//
// Synopsis:  Initialization for the connected state, unlike the connstructor
//            This is called with in the connection thread
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CCmConnection::StateConnectedInit()
{
    m_dwConnectStartTime = GetTickCount();

    //
    // Load big and small connection icon: m_hBigIcon and m_hSmallIcon
    //
    LoadConnectionIcons();

    m_StatusDlg.Create(CMonitor::GetInstance(), CMonitor::GetMonitorWindow(), m_szServiceName, m_hBigIcon);
    m_StatusDlg.ChangeToStatus();

    //
    // Change the window position, so multiple status window will not be at 
    // the same position
    //
    PositionWindow(m_StatusDlg.GetHwnd(), m_dwPositionId);

    //
    // Change the dialog titlebar icon 
    //
    SendMessageU(m_StatusDlg.GetHwnd(),WM_SETICON,ICON_BIG,(LPARAM) m_hBigIcon);
    SendMessageU(m_StatusDlg.GetHwnd(),WM_SETICON,ICON_SMALL,(LPARAM) m_hSmallIcon);

    //
    // Set the help file name
    //

    LPTSTR lpHelpFile = LoadHelpFileName();
    
    if (lpHelpFile)
    {
        m_StatusDlg.SetHelpFileName(lpHelpFile);
    }
    else
    {
        m_StatusDlg.SetHelpFileName(c_pszDefaultHelpFile);
    }

    CmFree(lpHelpFile);
   
    //
    // Determine whether or not, we're hiding the icon. The default is TRUE 
    // for NT5 because we already have full support from the folder.
    //

    m_fHideTrayIcon= m_IniService.GPPI(c_pszCmSection, c_pszCmEntryHideTrayIcon, OS_NT5);

    if (!m_fHideTrayIcon && !(OS_NT5 && IsLogonAsSystem()))
    {
        HICON hIcon = NULL;

        LPTSTR pszTmp = m_IniService.GPPS(c_pszCmSection, c_pszCmEntryTrayIcon);
        if (*pszTmp) 
        {
            //
            // The icon name is relative to the .cmp file, convert it into full name
            //

            LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszTmp);

            hIcon = CmLoadSmallIcon(CMonitor::GetInstance(), pszFullPath);
            
            CmFree(pszFullPath);
        }
        CmFree(pszTmp);

        //
        // Use the default tray icon
        //
        if (!hIcon) 
        {
            hIcon = CmLoadSmallIcon(CMonitor::GetInstance(), MAKEINTRESOURCE(IDI_APP));
        }

        //
        // m_TrayIcon is responsible to delete the hIcon object
        //
        m_TrayIcon.SetIcon(hIcon, m_StatusDlg.GetHwnd(), WM_TRAYICON, 0,m_szServiceName);

        // Question: , shall we also load the tray icon cmd from iniProfile?
        m_TrayIcon.CreateMenu(&m_IniService, IDM_TRAYMENU);
   }

    //
    // Try to call RasConnectionNotification.  When connection is losted
    //  a event will be signaled 
    //
    m_RasApiDll.Load();
    m_hEventRasNotify = CallRasConnectionNotification(m_hRasDial, m_hRasTunnel);

    if (m_hEventRasNotify)
    {
        //
        // If we got the event, unload RAS, otherwise, need to check connection on timer
        //
        m_RasApiDll.Unload();
    }
}




//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnected
//
// Synopsis:  The connection is in the connected or disconnect-count-down state
//            Run the message loop until state is changed
//
// Arguments: None
//
// Returns:   CONN_STATE - The new state, either STATE_TERMINATED or 
//                                STATE_PROMPT_RECONNECT
//
// History:   fengsun Created Header    2/4/98
//
//+----------------------------------------------------------------------------

//
// The reconnect dialog only shows up on Win95 Gold
// And we need to use service name to find the dialog.
//
void ZapRNAReconnectStop(HANDLE hThread);
HANDLE ZapRNAReconnectStart(BOOL *pbConnLost);

void CCmConnection::StateConnected()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_CONNECTED);
    BOOL fLostConnection = FALSE;
    
    CMTRACE(TEXT("Enter StateConnected"));

    StateConnectedInit();

    HANDLE hThreadRnaReconnect = NULL;

    if (OS_W95)
    {
        hThreadRnaReconnect = ZapRNAReconnectStart(NULL);
    }

    // 
    // Ignore return value
    //
    BOOL fRV = CheckRasConnection(fLostConnection);

    // 
    // If we lost the connection, we need to hangup so that rasman has the correct
    // ref count.
    // 
    if (fLostConnection)
    {
        CMTRACE(TEXT("StateConnected - Actually not connected. Need to hangup to notify rasman."));
        m_dwState = StateConnectedProcessEvent(EVENT_CMDIAL_HANGUP);
    }
    else
    {
        while (m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN)
        {
            CONN_EVENT dwEvent = StateConnectedGetEvent();
            MYDBGASSERT(dwEvent <= EVENT_NONE);

            if (dwEvent < EVENT_NONE )
            {
                //
                // Call the event handler to process the event
                //
                m_dwState = StateConnectedProcessEvent(dwEvent);
            }
        }
    }

    if (hThreadRnaReconnect)
    {
        ZapRNAReconnectStop(hThreadRnaReconnect);
    }

}


//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedGetEvent
//
// Synopsis:  In the state of CONNECTED/COUNTDOWN. Wait until some event happens. 
//              Also runs the message loop
//
// Arguments: None
//
// Returns:   CCmConnection::CONN_EVENT - The event that can cause the 
//            connection change the state other than CONNECTED/COUNTDOWN
//
// History:   Created Header    2/18/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_EVENT CCmConnection::StateConnectedGetEvent()
{
    ASSERT_VALID(this);
    //
    // The last time SateConnectedOnTimer got called
    //

    DWORD dwLastTimerCalled = 0;
    //
    // Loop until we got some event
    //
    while (TRUE)
    {
        MYDBGASSERT(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN);

        //
        // Process all the messages in the message queue
        //
        MSG msg;
        while(PeekMessageU(&msg, NULL,0,0,PM_REMOVE))
        {
            if (msg.hwnd == NULL)
            {
                //
                // it is a thread message
                //
                
                MYDBGASSERT((msg.message >= WM_APP) || (msg.message == WM_CONN_EVENT));
                if (msg.message == WM_CONN_EVENT)
                {
                    MYDBGASSERT(msg.wParam < EVENT_NONE);
                    return (CONN_EVENT)msg.wParam;
                }
            }
            else
            {   
                //
                // Also dispatch message for Modeless dialog box
                //
                if (!IsDialogMessageU(m_StatusDlg.GetHwnd(), &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessageU(&msg);
                }
            }
        }

        //
        // whether cmmon needs timer.
        // The timer is needed, if we have check the ras connection on timer,
        // or we have to check idle disconnect on timer,
        // or the state is disconnect-count-down,
        // or status dialog is visible
        //
        BOOL fNeedTimer = !m_hEventRasNotify 
            || m_IdleStatistics.IsStarted() 
            || m_dwState == STATE_COUNTDOWN
            || IsWindowVisible(m_StatusDlg.GetHwnd());

        //
        // If more than 1 seconds elapsed, call the timer
        //
        if (fNeedTimer && GetTickCount() - dwLastTimerCalled >= TIMER_INTERVAL)
        {
            dwLastTimerCalled = GetTickCount();
            CONN_EVENT dwEvent = StateConnectedOnTimer();

            if (dwEvent != EVENT_NONE)
            {
                return dwEvent;
            }
        }

        //
        // Setup the opbject array for MsgWaitForMultipleObjects
        //

        HANDLE ahObjectsToWait[3];
        int nObjects = 0;

        if (m_hEventRasNotify)
        {
            ahObjectsToWait[nObjects] = m_hEventRasNotify;
            nObjects++;
        }

        if (m_WatchProcess.GetSize())
        {
            //
            // If we have any process to watch, just add the first hProcess
            // Since we want to know whether all processes exit
            //
            ahObjectsToWait[nObjects] = m_WatchProcess.GetProcess(0);
            MYDBGASSERT(ahObjectsToWait[nObjects]);
            nObjects++;
        }

        //
        // From MSDN:
        // The documentation for MsgWaitForMultipleObjects() says that the API returns 
        // successfully when either the objects are signalled or the input is available. 
        // However, the API behaves as if it requires that the objects are signalled 
        // and the input is available. 
        //
        // Put an extra event seems to fix it for NT
        //
        if (OS_NT && nObjects)
        {
            ahObjectsToWait[nObjects] = ahObjectsToWait[nObjects-1];
            nObjects++;
        }

        if (m_fToMinimizeWorkingSet)
        {
            //
            // If we do not need a timer here, minimize the working set.
            // before calling  MsgWaitForMultipleObjects.
            //
            CMonitor::MinimizeWorkingSet();
            m_fToMinimizeWorkingSet = FALSE;
        }

        DWORD dwRes = MsgWaitForMultipleObjects(nObjects, ahObjectsToWait, FALSE, 
            fNeedTimer ? 1000 : INFINITE, 
            QS_ALLINPUT);

        //
        // Timeout
        //
        if (dwRes == WAIT_TIMEOUT)
        {
            //
            // We always checks timer on the beginning of the loop
            //
            continue;
        }

        //
        // An event
        //
#pragma warning(push)
#pragma warning(disable:4296)
        if (dwRes >= WAIT_OBJECT_0 && dwRes < WAIT_OBJECT_0 + nObjects)
#pragma warning(pop)
        {
            BOOL        fLostConnection;
            
            //
            // Ras Event
            //
            if (m_hEventRasNotify && ahObjectsToWait[dwRes - WAIT_OBJECT_0] == m_hEventRasNotify &&
                    !CheckRasConnection(fLostConnection))
            {
                //
                // Got a notification that the RAS connection is losted
                //
                
                CMTRACE(TEXT("CCmConnection::StateConnectedGetEvent() - m_hEventRasNotify && ahObjectsToWait[dwRes - WAIT_OBJECT_0] == m_hEventRasNotify"));
                return EVENT_LOST_CONNECTION;
            }
            else
            {
                //
                // A watch process exits
                // IsIdle() remove the process from the list
                //
                if (m_WatchProcess.IsIdle())
                {
                    //
                    // If all the watch process are terminated, change to disconnect countdown
                    //
                    CMTRACE(TEXT("CCmConnection::StateConnectedGetEvent() - m_WatchProcess.IsIdle()"));
                    return EVENT_IDLE;
                }

                continue;
            }
        }

        //
        // A message
        //
        if (dwRes == WAIT_OBJECT_0 + nObjects)
        {
            continue;
        }

        if (-1 == dwRes)
        {
            CMTRACE1(TEXT("MsgWaitForMultipleObjects failed, LastError:%d"), GetLastError());
            //
            // Something does wrong
            //
            continue;
        }

        //
        // what is this return value
        //
        CMTRACE1(TEXT("MsgWaitForMultipleObjects returns %d"), dwRes);
        continue;
    }

    //
    // should never get here
    //
    MYDBGASSERT(FALSE);
    return EVENT_USER_DISCONNECT;
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedOnTimer
//
// Synopsis:  Process the timer in the state of CONNECTED/COUNTDOWN
//
// Arguments: None
//
// Returns:   CCmConnection::CONN_EVENT - The event that can cause the 
//            connection change the state other than CONNECTED/COUNTDOWN or EVENT_NONE
//
// History:   fengsun Created Header    2/18/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_EVENT CCmConnection::StateConnectedOnTimer()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN);

    if (m_dwState != STATE_CONNECTED && m_dwState != STATE_COUNTDOWN)
    {
        return EVENT_NONE;
    }

    //
    // Check whether CM is still connected, only if the Ras notify event is not available
    //
    if (m_hEventRasNotify == NULL)
    {
        BOOL fLostConnection;
        
        BOOL fConnect = CheckRasConnection(fLostConnection);

        CMTRACE2(TEXT("CCmConnection::StateConnectedOnTimer - CheckRasConnection returns %d - fLostConnection is %d"), fConnect, fLostConnection);

        if (!fConnect)
        {
            return (fLostConnection ? EVENT_LOST_CONNECTION : EVENT_USER_DISCONNECT);
        }
    }

    //
    // If we don't have stats, something went wrong accessing the 
    // registry stats earlier, so try to initialize again here.
    //

    if (OS_W98 && !m_ConnStatistics.IsAvailable())
    {
        //
        // Try to initialize the perf stats from the registry again
        //

        CMASSERTMSG(FALSE, TEXT("StateConnectedOnTimer() - Statistics unavailable, re-initializing stats now."));

        m_ConnStatistics.Open(CMonitor::GetInstance(),
                              (DWORD)-1,
                              (DWORD)-1,
                              m_hRasDial,
                              m_hRasTunnel);      
    }

    //
    // Get statistics for Win9x
    //
    
    if (m_ConnStatistics.IsAvailable())
    {
        m_ConnStatistics.Update();

        // 
        // collecting data points for monitoring idle-disconnect
        // check whether ICM has received more data points than the IdleThreshold value
        // during the past IDLE_SPREAD time
        // Start() is not called for NT
        //

        if (m_IdleStatistics.IsStarted())
        {
            m_IdleStatistics.UpdateEveryInterval(m_ConnStatistics.GetBytesRead());
        }
    }

    if (m_dwState == STATE_CONNECTED)
    {
        //
        // Check idle time out
        //

        if (m_IdleStatistics.IsIdleTimeout())
        {
            //
            // Disconnect count down 
            //
            
            CMTRACE(TEXT("CCmConnection::StateConnectedOnTimer() - m_IdleStatistics.IsIdleTimeout()"));
            return EVENT_IDLE;
        }

        //
        // Check process watch list
        //

        if (m_WatchProcess.IsIdle())
        {
            //
            // Disconnect count down 
            //
            
            CMTRACE(TEXT("CCmConnection::StateConnectedOnTimer() - m_WatchProcess.IsIdle())"));
            return EVENT_IDLE;
        }

        //
        // Update the status window, only if the window is visible
        //
        if (IsWindowVisible(m_StatusDlg.GetHwnd()))
        {
            if (m_ConnStatistics.IsAvailable())
            {
                m_StatusDlg.UpdateStats(m_ConnStatistics.GetBaudRate(), 
                                        m_ConnStatistics.GetBytesRead(), 
                                        m_ConnStatistics.GetBytesWrite(), 
                                        m_ConnStatistics.GetBytesPerSecRead(), 
                                        m_ConnStatistics.GetBytesPerSecWrite());
            }

            //
            // We have exact duration numbers from RAS on NT5, so use them.
            //

            if (m_ConnStatistics.GetDuration())
            {
                m_StatusDlg.UpdateDuration(m_ConnStatistics.GetDuration() / 1000);
            }
            else
            {
                m_StatusDlg.UpdateDuration((GetTickCount() - m_dwConnectStartTime) / 1000);
            }
        }

        return EVENT_NONE;
    }
    else    // m_dwState == STATE_COUNTDOWN
    {

        //
        // Note: NetBEUI seems to insist on sending unsolicited 
        // stuff over the dial-up adapter. So we will define 
        // "idle" as "not having received anything".
        //

        //
        //  check whether we have new traffic that exceeds the threshold.
        //  But we don't care about network traffic if the countdown is caused
        //  by 0 watched process
        //
        if (!m_WatchProcess.IsIdle() && !m_IdleStatistics.IsIdle() )
        {

            // 
            // We were in our idle wait, but we just picked up some
            // activity. Stay on line.
            // If this is NT5 we don't use our own status dialog so just hide
            // it again.  If this is downlevel then just change the dialog to
            // a status dialog
            //
            if (OS_NT5)
            {
                m_StatusDlg.DismissStatusDlg();
            }
            else
            {
                m_StatusDlg.ChangeToStatus();
            }

            m_dwState = STATE_CONNECTED;

            return EVENT_NONE; 
        } 

        //
        // If the time elapsed is more than 30 second, timeout
        //

        DWORD dwElapsed = GetTickCount() - m_dwCountDownStartTime;

        if (dwElapsed > IDLE_DLG_WAIT_TIMEOUT) 
        {
            //
            // Connection has been idle for timeout period and the
            // grace period is up with no user intervention, so we
            // quit/disconnect, and ask for reconnect
            //

            CMTRACE(TEXT("CCmConnection::StateConnectedOnTimer() - dwElapsed > IDLE_DLG_WAIT_TIMEOUT"));
            return EVENT_COUNTDOWN_ZERO;
        } 
        else 
        {
            //
            // Connection has been idle for timeout period but we 
            // are still in the grace period, show countdown.
            //

            int nTimeLeft = (int) ((IDLE_DLG_WAIT_TIMEOUT - dwElapsed) / 1000);
            
            //
            // Update duration and countdown seconds left.
            //
            
            if (m_ConnStatistics.GetDuration()) // NT5 only
            {
                m_StatusDlg.UpdateCountDown(m_ConnStatistics.GetDuration() / 1000,
                                            nTimeLeft);
            }
            else
            {
                m_StatusDlg.UpdateCountDown((GetTickCount() - m_dwConnectStartTime) / 1000, 
                                            nTimeLeft);
            }
        }

        return EVENT_NONE;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedProcessEvent
//
// Synopsis:  Process the connection event while in CONNECTED/COUNTDOWN state
//
// Arguments: CONN_EVENT dwEvent - the event to process
//
// Returns:   CCmConnection::CONN_STATE - The new state of the connection
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_STATE CCmConnection::StateConnectedProcessEvent(CONN_EVENT dwEvent)
{
    ASSERT_VALID(this);
    switch (dwEvent)
    {
    case EVENT_IDLE:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_IDLE"));

        if (m_dwState != STATE_COUNTDOWN)
        {
            //
            // No-traffic/ No-watch-process idle event
            // change to Disconnect count down 
            //
            m_dwCountDownStartTime = GetTickCount();
            m_StatusDlg.ChangeToCountDown();
            //
            // Update duration and countdown seconds left
            //
            
            int nTimeLeft = IDLE_DLG_WAIT_TIMEOUT / 1000;

            if (m_ConnStatistics.GetDuration()) // NT5 only
            {
                m_StatusDlg.UpdateCountDown(m_ConnStatistics.GetDuration() / 1000,
                                            nTimeLeft);
            }
            else
            {
                m_StatusDlg.UpdateCountDown((GetTickCount() - m_dwConnectStartTime) / 1000, 
                                            nTimeLeft);
            }

            //
            //  Don't show the UI if we are at Winlogon unless we are on NT4
            //
            if (!IsLogonAsSystem() || OS_NT4)
            {
                m_StatusDlg.BringToTop();
            }
        }

        return STATE_COUNTDOWN;

    case EVENT_CMDIAL_HANGUP:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_CMDIAL_HANGUP"));

        m_Log.Log(DISCONNECT_EXT);

        //
        // Cmdial posted cmmon a message to clean up the connection.
        // Do not need to call hangup here
        //
        StateConnectedCleanup();

        return STATE_TERMINATED;

    case EVENT_LOST_CONNECTION:
    case EVENT_COUNTDOWN_ZERO:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_LOST_CONNECTION/EVENT_COUNTDOWN_ZERO"));
        
        //
        // lost-ras-connection event or the count down counter is down to 0
        //        
        if (IsPromptReconnectEnabled() && !m_WatchProcess.IsIdle() ||
            ( dwEvent == EVENT_LOST_CONNECTION && IsAutoReconnectEnabled() ) )
        {
            CmCustomHangup(TRUE); // fPromptReconnect = TRUE, do not remove from Conn Table

            //
            // It is possible
            // Someone else called cmdial to disconnect, while we are disconnecting.
            // If the ref count is down to  0, cmdial will remove the entry
            //

            CM_CONNECTION CmEntry;
            if (CMonitor::ConnTableGetEntry(m_szServiceName, &CmEntry))
            {
                //
                // Cmdial should change the state to CM_RECONNECTPROMPT
                //
                CMTRACE2(TEXT("CmEntry.CmState is %d, event is %d"), CmEntry.CmState, dwEvent);
                
                MYDBGASSERT(CmEntry.CmState == CM_RECONNECTPROMPT);

                if (EVENT_LOST_CONNECTION == dwEvent)
                {
                    m_Log.Log(DISCONNECT_EXT_LOST_CONN);
                }
                else if (EVENT_COUNTDOWN_ZERO == dwEvent)
                {
                    m_Log.Log(DISCONNECT_INT_AUTO);
                }

                //
                // is auto reconnect enabled(don't show reconnect prompt)?
                //
                if (dwEvent == EVENT_LOST_CONNECTION && IsAutoReconnectEnabled())
                {
                    //
                    //  On win98 Gold, we have a timing issue with Auto Reconnect because
                    //  notification that the line was dropped is sent before cleanup for
                    //  the connection takes place.  Thus, we need to poll the connection
                    //  status using RasGetConnectionStatus until the line is available
                    //  before trying to reconnect.  NTRAID 273033.
                    //
                    if (OS_W98 && (NULL != m_hRasDial))
                    {
                        BOOL bConnectionActive;
                        BOOL bLostConnection;   //ignored
                        int iCount = 0;

                        do
                        {
                            bConnectionActive = CheckRasConnection(bLostConnection);
                            if (bConnectionActive)
                            {
                                Sleep(50);
                            }

                            iCount++;
                            
                            // 50 Milliseconds * 200 = 10 seconds
                            // If waiting 10 seconds hasn't fixed it, not sure that it will
                            // get fixed by this method.
                            

                        } while ((200 >= iCount) && (bConnectionActive));
                    }

                    return STATE_RECONNECTING;
                }

                return STATE_PROMPT_RECONNECT;
            }
            else
            {
                return STATE_TERMINATED;
            }
        }

        //
        // Else fall through
        //
    
    case EVENT_USER_DISCONNECT:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_USER_DISCONNECT"));

        m_Log.Log(DISCONNECT_INT_MANUAL);

        //
        // For EVENT_USER_DISCONNECT
        // User can disconnect from tray icon, status dialog, or countdown dialog.
        // Or prompt reconnect is not enabled             
        //
        CmCustomHangup(FALSE); // fPromptReconnect = FALSE
        return STATE_TERMINATED;

    default:
        //
        // Unexpected event, do the same thing as EVENT_USER_DISCONNECT
        //
        MYDBGASSERT(FALSE);
        CmCustomHangup(FALSE); // fPromptReconnect = FALSE
        return STATE_TERMINATED;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::IsAutoReconnectEnabled
//
// Synopsis:  See if auto-reconnect is enabled, but only if we aren't logged-in
//            as system.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/18/98
//            tomkel  moved from connection.h  06/06/2001
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::IsAutoReconnectEnabled() const
{
    //
    // Load the AutoReconnect flag from profile
    // Default is FALSE
    //
    BOOL fReturn = FALSE;

    if (!IsLogonAsSystem())
    {
        fReturn = m_IniService.GPPB(c_pszCmSection, c_pszCmEntryAutoReconnect, FALSE);
    }

    return fReturn; 
}


//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedCleanup
//
// Synopsis:  Cleanup before exiting the connected state
//
// Arguments: BOOL fEndSession, whether windows is going to logoff/shutdown
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/18/98
//
//+----------------------------------------------------------------------------
void CCmConnection::StateConnectedCleanup(BOOL fEndSession)
{
    ASSERT_VALID(this);
    //
    // Remove the trayicon, destroy the status dialog
    //
    m_TrayIcon.RemoveIcon();
    m_ConnStatistics.Close();

    //
    // Do not close window on WM_ENDSESSION.  Otherwise, cmmon would be terminated right here
    //
    if (!fEndSession)
    {
        m_StatusDlg.KillRasMonitorWindow();
        DestroyWindow(m_StatusDlg.GetHwnd());
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::IsPromptReconnectEnabled
//
// Synopsis:  When prompt-reconnect is enabled by the profile
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/18/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::IsPromptReconnectEnabled() const
{
    //
    // Load the NoPromptReconnect flag from profile.  Also check the Unattended flag and
    // if we are running in the system account on win2k or Whistler.  If any of the above
    // are true then we don't prompt, otherwise we do.
    //

    BOOL fPromptReconnect = !(m_IniService.GPPB(c_pszCmSection,
        c_pszCmEntryNoPromptReconnect, FALSE)); 

    if (!fPromptReconnect || (m_ReconnectInfo.dwCmFlags & FL_UNATTENDED) || (IsLogonAsSystem() && OS_NT5))
    {
        //
        // Do not prompt reconnect
        //
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CmCustomHangup
//
// Synopsis:  Call cmdial to hangup the connection
//
// Arguments: BOOL fPromptReconnect, whether cmmon are going to prompt the 
//                  reconnect dialog
//            BOOL fEndSession, whther windows is going to logoff/shutdown
//                  Default value is FALSE
//
// Returns:   Nothing
//
// History:   fegnsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::CmCustomHangup(BOOL fPromptReconnect, BOOL fEndSession)
{
    ASSERT_VALID(this);

    CMTRACE2(TEXT("CCmConnection::CmCustomHangup - fPromptReconnect is %d and fEndSession is %d"), fPromptReconnect, fEndSession);

    //
    // Remove the trayicon close status dlg, before hangup
    //
    StateConnectedCleanup(fEndSession);

    //
    // It is possible the connection is disconnected or disconnecting
    //

    CM_CONNECTION CmEntry;

    if (!CMonitor::ConnTableGetEntry(m_szServiceName, &CmEntry) ||
        CmEntry.CmState != CM_CONNECTED)
    {
        //
        // The connection is disconnected by someone else, do not hangup.
        //

        CMTRACE(TEXT("CCmConnection::CmCustomHangup - Entry is not connected, canceling hangup"));       
        return TRUE; 
    }

    //
    // Call cmdial32.dll CmCustomHangup
    //

    //
    // The destructor of CDynamicLibrary calls FreeLibrary
    //
    CDynamicLibrary LibCmdial;
    
    if (!LibCmdial.Load(TEXT("cmdial32.dll")))
    {
        MYDBGASSERT(FALSE);
        return FALSE;
    }

    CmCustomHangUpFUNC pfnCmCustomHangUp;

    pfnCmCustomHangUp = (CmCustomHangUpFUNC)LibCmdial.GetProcAddress(c_pszCmHangup);
    MYDBGASSERT(pfnCmCustomHangUp);

    if (pfnCmCustomHangUp)
    {
        //
        // hRasConn = NULL, 
        // fIgnoreRefCount = TRUE, always except for InetDialHandler
        // fPersist = fPromptReconnect, do not remove the entry if 
        // we are going to prompt for reconnect
        //
        DWORD dwRet;
        dwRet = pfnCmCustomHangUp(NULL, m_szServiceName, TRUE, fPromptReconnect);
        CMTRACE1(TEXT("CCmConnection::CmCustomHangup -- Return Value from CmCustomHangup is %u"), dwRet);
        return (ERROR_SUCCESS == dwRet);
    }

    return FALSE;

}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CallRasConnectionNotification
//
// Synopsis:  call RasConnectionNotify.  Ras will set the event when connection
//             is lost
//
// Arguments: HRASCONN hRasDial - The dial ras handle
//            HRASCONN hRasTunnel - The tunnel ras handle
//
// Returns:   HANDLE - the event handle, or NULL if failed
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HANDLE CCmConnection::CallRasConnectionNotification(HRASCONN hRasDial, HRASCONN hRasTunnel)
{
    DWORD       dwRes;
    
    MYDBGASSERT(hRasDial || hRasTunnel);

    //
    // Call RasConnectionNotification.  Ras will call us back when connection is losted.
    // However, this fuction is not avaliable for Win95 with DUN 1.0
    //

    if (!m_RasApiDll.HasRasConnectionNotification())
    {
        return NULL;
    }

    HANDLE hEvent = NULL;

    if (OS_W9X)
    {
        //
        // Create an manual-reset non-signaled event on Win95, Win98 & WinME
        //
        hEvent = CreateEventU(NULL, TRUE, FALSE, NULL);
    }
    else
    {
        //
        // Create an auto-reset non-signaled event
        //
        hEvent = CreateEventU(NULL, FALSE, FALSE, NULL);

    }

    //
    // v-vijayb: Changed to use INVALID_HANDLE_VALUE(notify for all disconnects), as we where
    // not getting notified after a reconnect or after connecting thru winlogon.
    // StateConnectedGetEvent() will check if this connection is lost to determine if it was 
    // a disconnection of this connection or some other.
    //
    if (hRasDial)
    {
        //
        // Copied from RAS.h
        // #if (WINVER >= 0x401)
        //
        #define RASCN_Disconnection     0x00000002
        if (OS_NT)
        {
            dwRes = m_RasApiDll.RasConnectionNotification((HRASCONN) INVALID_HANDLE_VALUE, hEvent, RASCN_Disconnection);
        }
        else
        {
            dwRes = m_RasApiDll.RasConnectionNotification(hRasDial, hEvent, RASCN_Disconnection);
        }
        
        if (dwRes != ERROR_SUCCESS)
        {
            CMASSERTMSG(FALSE, TEXT("RasConnectionNotification Failed"));
            CloseHandle(hEvent);
            return NULL;
        }
    }

    if (hRasTunnel)
    {
        if (OS_NT)
        {
            dwRes = m_RasApiDll.RasConnectionNotification((HRASCONN) INVALID_HANDLE_VALUE, hEvent, RASCN_Disconnection);
        }
        else
        {
            dwRes = m_RasApiDll.RasConnectionNotification(hRasTunnel, hEvent, RASCN_Disconnection);
        }
        
        if (dwRes != ERROR_SUCCESS)
        {
            CMASSERTMSG(FALSE, TEXT("RasConnectionNotification Failed"));
            CloseHandle(hEvent);
            return NULL;
        }
    }

    return hEvent;
}

//+---------------------------------------------------------------------------
//
//  struct RASMON_THREAD_INFO
//
//  Description: Information passed to RasMonitorDlgThread by OnStatusDetails
//
//  History:    fengsun Created     2/11/98
//
//----------------------------------------------------------------------------
struct RASMON_THREAD_INFO
{
    HRASCONN hRasConn; // the ras handle to display status
    HWND hwndParent;   // the parent window for the RasMonitorDlg
};

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnStatusDetails
//
// Synopsis:  Called upon pressing detailed button on NT status dlg
//            Call RasMonitorDlg to display the dial-up monitor 
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------

void CCmConnection::OnStatusDetails()
{
    ASSERT_VALID(this);
    //
    // RasDlg.dll is not available for Win9X
    //
    MYDBGASSERT(OS_NT4);

    if (!OS_NT4)
    {
        return;
    }

    //
    // RasMonitorDlg pops up a modal dialog box, which will block the thread message loop.
    // No thread message or event can be processed
    // Create another thread to call RasMonitorDlg
    //

    //
    // Alloc the parametor from heap. It is not safe to use stack here.
    // CreateThread can return before the thread routine is called
    // The thread is responsible to free the pointer
    //
    RASMON_THREAD_INFO* pInfo = (RASMON_THREAD_INFO*)CmMalloc(sizeof(RASMON_THREAD_INFO));
    if (NULL == pInfo)
    {
        CMTRACE(TEXT("CCmConnection::OnStatusDetails alloc for pInfo failed"));
        return;
    }
    
    pInfo->hRasConn = m_hRasTunnel?m_hRasTunnel : m_hRasDial;
    pInfo->hwndParent = m_StatusDlg.GetHwnd();

    DWORD dwThreadId;
    HANDLE hThread;
    if ((hThread = CreateThread(NULL, 0, RasMonitorDlgThread ,pInfo,0,&dwThreadId)) == NULL)
    {
        MYDBGASSERT(FALSE);
        CMTRACE(TEXT("CCmConnection::OnStatusDetails CreateThread failed"));
        CmFree(pInfo);
        return ;
    }

    CloseHandle(hThread);
}


//+----------------------------------------------------------------------------
//
// Function:  static CCmConnection::RasMonitorDlgThread
//
// Synopsis:  The thread to call RasMonitorDlg to avoid blocking the thread 
//            message loop.  RasMonitorDlg is a modal dialogbox.  The thead exits
//            when the dialog is closed.  That happens when user close the dialog box, 
//            or m_StatusDlg.KillRasMonitorWindow() is called
//
// Arguments: LPVOID lParam - RASMON_THREAD_INFO* the information passed to the thread
//
// Returns:   DWORD WINAPI - The thread return value
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI CCmConnection::RasMonitorDlgThread(LPVOID lParam)
{
    MYDBGASSERT(lParam);

    RASMON_THREAD_INFO* pInfo = (RASMON_THREAD_INFO*)lParam;

    MYDBGASSERT(pInfo->hRasConn);
    
    //
    // Get the device name first, if tunnel is available, use tunnel device
    //
    RASCONNSTATUS rcsStatus;
    memset(&rcsStatus,0,sizeof(rcsStatus));
    rcsStatus.dwSize = sizeof(rcsStatus);

    //
    // Load Rasapi32.dll here.  This dll is not loaded on NT
    // Destructor will unload the DLL
    //
    CRasApiDll rasApiDll;
    if (!rasApiDll.Load())
    {
        MYDBGASSERT(FALSE);
        CmFree(pInfo);
        return 1;
    }

    DWORD dwRes = rasApiDll.RasGetConnectStatus(pInfo->hRasConn, &rcsStatus);
    CMASSERTMSG(dwRes == ERROR_SUCCESS, TEXT("RasGetConnectStatus failed"));

    //
    // The connection is lost.  Still call RasMonitorDlg with empty name
    //

    RASMONITORDLG RasInfo;
    WORD (WINAPI *pfnFunc)(LPTSTR,LPRASMONITORDLG) = NULL;

    ZeroMemory(&RasInfo,sizeof(RasInfo));
    RasInfo.dwSize = sizeof(RasInfo);
    RasInfo.hwndOwner = pInfo->hwndParent;
    RasInfo.dwStartPage = RASMDPAGE_Status;

    CmFree(pInfo);

    //
    // Call rasdlg.dll -> RasMonitorDlg
    //
    
    //
    // The destructor of CDynamicLibrary calls FreeLibrary
    //
    CDynamicLibrary LibRasdlg;

    if (!LibRasdlg.Load(TEXT("RASDLG.DLL")))
    {
        CMTRACE1(TEXT("Rasdlg.dll LoadLibrary() failed, GLE=%u."), GetLastError());
        return 1;
    }

    pfnFunc = (WORD (WINAPI *)(LPTSTR,LPRASMONITORDLG))LibRasdlg.GetProcAddress("RasMonitorDlg"A_W);
    if (pfnFunc)
    {
        pfnFunc(rcsStatus.szDeviceName, &RasInfo);
    }

    LibRasdlg.Unload();
    rasApiDll.Unload();

    //
    // Minimize the working set before exit the thread.
    //
    CMonitor::MinimizeWorkingSet();
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StatePrompt
//
// Synopsis:  The connection is in the prompt-reconnect stste
//            Run the message loop until state is changed
//
// Arguments: None
//
// Returns:   CONN_STATE - The new state, either STATE_TERMINATED or 
//                                STATE_RECONNECTING
//
// History:   fengsun Created Header    2/4/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_STATE CCmConnection::StatePrompt()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_PROMPT_RECONNECT);
//    MYDBGASSERT(!IsWindow(m_StatusDlg.GetHwnd()));

    CMTRACE(TEXT("Enter StatePrompt"));

    LPTSTR pszReconnectMsg = CmFmtMsg(CMonitor::GetInstance(),IDMSG_RECONNECT,m_szServiceName);

    m_ReconnectDlg.Create(CMonitor::GetInstance(), NULL,
        pszReconnectMsg,m_hBigIcon);

    CmFree(pszReconnectMsg);

    //
    // Change the window position, so multiple status window will not be at 
    // the same position
    //
    PositionWindow(m_ReconnectDlg.GetHwnd(), m_dwPositionId);

    //
    // Change the dialog titlebar icon. This does not work,
    // Reconnect dialog does not have system menu icon
    //
    SendMessageU(m_ReconnectDlg.GetHwnd(),WM_SETICON,ICON_BIG,(LPARAM) m_hBigIcon);
    SendMessageU(m_ReconnectDlg.GetHwnd(),WM_SETICON,ICON_SMALL,(LPARAM) m_hSmallIcon);

    //
    // Minimize the working set
    //
    CMonitor::MinimizeWorkingSet();

    MSG msg;
    while(GetMessageU(&msg, NULL,0,0))
    {
        if (msg.hwnd == NULL)
        {
            //
            // it is a thread message
            //

            MYDBGASSERT((msg.message >= WM_APP) || (msg.message == WM_CONN_EVENT));
            if (msg.message == WM_CONN_EVENT)
            {
                MYDBGASSERT(msg.wParam == EVENT_USER_DISCONNECT 
                        || msg.wParam == EVENT_RECONNECT
                        || msg.wParam == EVENT_CMDIAL_HANGUP);
                break;
            }
        }
        else
        {
            //
            // Also dispatch message for Modeless dialog box
            //
            if (!IsDialogMessageU(m_ReconnectDlg.GetHwnd(), &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageU(&msg);
            }
        }

    }

    //
    // If the status window is not destroyed yet, destroy it now
    //
    if (IsWindow(m_ReconnectDlg.GetHwnd()))
    {
        DestroyWindow(m_ReconnectDlg.GetHwnd());
    }

    if (msg.wParam == EVENT_RECONNECT)
    {
        return STATE_RECONNECTING;
    }
    else
    {
        return STATE_TERMINATED;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnTrayIcon
//
// Synopsis:  called Upon tray icon message
//
// Arguments: WPARAM wParam - wParam of the message
//            LPARAM lParam - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/4/98
//
//+----------------------------------------------------------------------------
DWORD CCmConnection::OnTrayIcon(WPARAM, LPARAM lParam)
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN);

    switch (lParam) 
    {
        case WM_LBUTTONDBLCLK:
            //
            //  Don't show the UI if we are at Winlogon unless we are on NT4
            //
            if (!IsLogonAsSystem() || OS_NT4)
            {
                m_StatusDlg.BringToTop();
            }
            break;

        case WM_RBUTTONUP: 
            {
                //
                // Popup the tray icon menu at the mouse location
                //
                POINT PosMouse;
                if (!GetCursorPos(&PosMouse))
                {
                    MYDBGASSERT(FALSE);
                    break;
                }
                //
                // From Microsoft Knowledge Base
                // PRB: Menus for Notification Icons Don't Work Correctly
                // To correct the first behavior, you need to make the current window 
                // the foreground window before calling TrackPopupMenu
                //
                //  see also fixes for Whistler bugs 41696 and 90576
                //

                if (FALSE == SetForegroundWindow(m_StatusDlg.GetHwnd()))
                {
                    CMTRACE(TEXT("SetForegroundWindow before TrackPopupMenu failed"));
                }

                m_TrayIcon.PopupMenu(PosMouse.x, PosMouse.y, m_StatusDlg.GetHwnd());
                PostMessageU(m_StatusDlg.GetHwnd(), WM_NULL, 0, 0);
            }
            break;

        default:
            break;
    }

    return TRUE;
}




//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnStayOnLine
//
// Synopsis:  Called when "Stay Online" button is pressed in the disconnect
//            count down dialog box
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
void CCmConnection::OnStayOnLine()
{
    ASSERT_VALID(this);
    //
    // Change the dialog to display status
    //
    m_StatusDlg.ChangeToStatus();
    m_dwState = STATE_CONNECTED;

    if (m_WatchProcess.IsIdle())
    {
        //
        // If idle bacause of no watching process
        // User clickes stay online, 0 watch process is not idle any more
        //
        m_WatchProcess.SetNotIdle();
    }

    if (m_IdleStatistics.IsIdleTimeout())
    {
        //
        // If idle bacause of no traffic
        // User clickes stay online, restart the idle counter
        //
        m_IdleStatistics.Reset();
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::PostHangupMsg
//
// Synopsis:  Called by monitor to clean up the connection.  The request was 
//            come from cmdial to remove tray icon  and status dialog
//            cmdial is responsible to actually hangup the connection
// 
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
void CCmConnection::PostHangupMsg() const
{
    //
    // NOTE: This function is called within the Monitor thread
    // Do not referrence any volatile data
    // The CMMON_HANGUP_INFO request can come in at any state
    //

    //
    // Post a message, so this will be handled in the connection thread
    //
    BOOL fRet = PostThreadMessageU(m_dwThreadId,WM_CONN_EVENT, EVENT_CMDIAL_HANGUP, 0);
    
#if DBG
    if (FALSE == fRet)
    {
        CMTRACE1(TEXT("CCmConnection::PostHangupMsg -- PostThreadMessage failed (GLE = %d)"), GetLastError());
    }
#endif
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::Reconnect
//
// Synopsis:  The connection is in reconnecting state
//            Simply load cmdial32.dll and call CmCustomDialDlg
//
// Arguments: None
//
// Returns:   BOOL whether reconnect successfully
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::Reconnect()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_RECONNECTING);

    CMTRACE(TEXT("Enter Reconnect"));

    //
    // Load cmdial32.dll and call CmReConnect();
    //

    //
    // The destructor of CDynamicLibrary calls FreeLibrary
    //
    CDynamicLibrary LibCmdial;
    
    if (!LibCmdial.Load(TEXT("cmdial32.dll")))
    {
        MYDBGASSERT(FALSE);
        return FALSE;
    }

    CmReConnectFUNC pfnCmReConnect;

    pfnCmReConnect = (CmReConnectFUNC)LibCmdial.GetProcAddress(c_pszCmReconnect);
    MYDBGASSERT(pfnCmReConnect);

    if (!pfnCmReConnect)
    {
        return FALSE;
    }

    //
    //  Log that we're reconnecting
    //
    m_Log.Log(RECONNECT_EVENT);

    //
    // If we have a RAS phonebook name pass it to reconnect, else NULL for system
    //

    if (m_szRasPhoneBook[0])
    {
        return (pfnCmReConnect(m_szRasPhoneBook, m_szServiceName, &m_ReconnectInfo));
    }
    else
    {
        return (pfnCmReConnect(NULL, m_szServiceName, &m_ReconnectInfo));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CheckRasConnection
//
// Synopsis:  Check whether the RAS connection is still connected
//
// Arguments: OUT BOOL& fLostConnection - 
//                If the no longer connected, TRUE means lost connection
//                                            FALSE means user disconnect
//
// Returns:   BOOL - Whether still connected
//
// History:   fengsun Created Header    2/8/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::CheckRasConnection(OUT BOOL& fLostConnection)
{
    ASSERT_VALID(this);

    MYDBGASSERT(m_hRasDial != NULL || m_hRasTunnel != NULL);

    // Whether we are still connected   
    BOOL fConnected = TRUE;
    RASCONNSTATUS rcsStatus;
    DWORD dwRes = ERROR_SUCCESS;

    if (NULL == m_hRasDial && NULL == m_hRasTunnel)
    {
        //
        //  If both m_hRasTunnel and m_hRasDial are NULL, we're definitely not
        //  connected.  Yes, we have lost the connection, and return value is FALSE.
        //
        fLostConnection = TRUE;
        return FALSE;
    }

    // check tunnel status first
    if (m_hRasTunnel != NULL) 
    {
        memset(&rcsStatus,0,sizeof(rcsStatus));
        rcsStatus.dwSize = sizeof(rcsStatus);

        //
        // This function will load RASAPI32.dll, if not loaded yet
        // Will not unload RASAPI32.dll, since this function is called on timer
        //
        dwRes = m_RasApiDll.RasGetConnectStatus(m_hRasTunnel, &rcsStatus);
        if (dwRes != ERROR_SUCCESS  || rcsStatus.rasconnstate == RASCS_Disconnected) 
        {
            //
            // The connection is lost
            //
            fConnected = FALSE;
        }
    }

    // check dialup connection status
    if (fConnected && m_hRasDial != NULL)
    {
        memset(&rcsStatus,0,sizeof(rcsStatus));
        rcsStatus.dwSize = sizeof(rcsStatus);
        dwRes = m_RasApiDll.RasGetConnectStatus(m_hRasDial, &rcsStatus);
    }

    if ((dwRes == ERROR_SUCCESS) 
         && ((rcsStatus.rasconnstate != RASCS_Disconnected) 
            || (rcsStatus.dwError == PENDING))) 
    {
        // CMTRACE(TEXT("CCmConnection::CheckRasConnection - rcsStatus.rasconnstate != RASCS_Disconnected || rcsStatus.dwError == PENDING"));
        return TRUE;
    }

    //
    // CM is no longer connected
    //

    CMTRACE3(TEXT("OnTimer() RasGetConnectStatus() returns %u, rasconnstate=%u, dwError=%u."), dwRes, 
        rcsStatus.rasconnstate, rcsStatus.dwError);

    if (rcsStatus.dwError == ERROR_USER_DISCONNECTION && OS_W9X)
    {
        fLostConnection = FALSE;

        //
        // On NT, ERROR_USER_DISCONNECTION is received in
        // the event of idle disconnect which we consider 
        // a lost connection
        // 
    }
    else
    {
        fLostConnection = TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnEndSession
//
// Synopsis:  Called upon WM_ENDSESSION message
//
// Arguments: BOOL fEndSession - whether the session is being ended, wParam
//            BOOL fLogOff - whether the user is logging off or shutting down, 
//                           lParam
//
// Returns:   Nothing
//
// History:   fengsun Created Header    5/4/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::OnEndSession(BOOL fEndSession, BOOL)
{
    CMTRACE(TEXT("CCmConnection::OnEndSession"));
    if (fEndSession)
    {
        //
        // The session can end any time after this function returns
        // If we are connected, hangup the connection
        //
        if(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN)
        {
            return CmCustomHangup(FALSE, TRUE); // fPromptReconnect = FALSE, fEndSession = TRUE
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnAdditionalTrayMenu
//
// Synopsis:  Called upon additional menuitem is selected from tray icon menu
//
// Arguments: WORD nCmd - LOWORD(wParam) of WM_COMMAND, the menu id
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CCmConnection::OnAdditionalTrayMenu(WORD nCmd)
{
    ASSERT_VALID(this);
    MYDBGASSERT( (nCmd >= IDM_TRAYMENU) 
        && nCmd <(IDM_TRAYMENU + m_TrayIcon.GetAdditionalMenuNum()));

    nCmd -= IDM_TRAYMENU; // get the index for the command

    if (nCmd >= m_TrayIcon.GetAdditionalMenuNum())
    {
        return;
    }

    //
    // Run the command line
    //
    ExecCmdLine(m_TrayIcon.GetMenuCommand(nCmd), m_IniService.GetFile());
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::GetProcessId
//
// Synopsis:  Find the process specified by pszModule & returns its PID
//
// Arguments: WCHAR *pszModule
//
// Returns:   PID of process or 0 if not found
//
// History:   v-vijayb    Created     7/20/99
//
//+----------------------------------------------------------------------------
DWORD CCmConnection::GetProcessId(WCHAR *pszModule)
{
    DWORD       dwPID = 0;
    HINSTANCE   hInstLib;
    DWORD       cbPIDs, cbNeeded, iPID, cPIDs;
    DWORD       *pdwPIDs = NULL;
    HANDLE      hProcess;
    HMODULE     hMod;
    WCHAR       szFileName[MAX_PATH + 1];
    
    //
    // PSAPI Function Pointers.
    //

    BOOL (WINAPI *lpfEnumProcesses)(DWORD *, DWORD cb, DWORD *);
    BOOL (WINAPI *lpfEnumProcessModules)(HANDLE, HMODULE *, DWORD, LPDWORD);
    DWORD (WINAPI *lpfGetModuleBaseName)(HANDLE, HMODULE, WCHAR *, DWORD);

    hInstLib = LoadLibrary(TEXT("PSAPI.DLL"));
    if (hInstLib == NULL)
    {
        return (0);
    }

    //
    // Get procedure addresses.
    //
    lpfEnumProcesses = (BOOL(WINAPI *)(DWORD *,DWORD,DWORD*)) GetProcAddress(hInstLib, "EnumProcesses") ;
    lpfEnumProcessModules = (BOOL(WINAPI *)(HANDLE, HMODULE *, DWORD, LPDWORD)) GetProcAddress(hInstLib, "EnumProcessModules") ;
    lpfGetModuleBaseName =(DWORD (WINAPI *)(HANDLE, HMODULE, WCHAR *, DWORD)) GetProcAddress(hInstLib, "GetModuleBaseNameW") ;
    if (lpfEnumProcesses == NULL || lpfEnumProcessModules == NULL || lpfGetModuleBaseName == NULL)
    {
        goto OnError;
    }

    cbPIDs = 256 * sizeof(DWORD);
    cbNeeded = 0;
    do
    {
        if (pdwPIDs != NULL)
        {
            HeapFree(GetProcessHeap(), 0, pdwPIDs);
            cbPIDs = cbNeeded;
        }
        pdwPIDs = (DWORD *) CmMalloc(cbPIDs);
        if (pdwPIDs == NULL)
        {
            goto OnError;
        }
        if (!lpfEnumProcesses(pdwPIDs, cbPIDs, &cbNeeded))
        {
            goto OnError;
        }

    } while (cbNeeded > cbPIDs);

    cPIDs = cbNeeded / sizeof(DWORD);
    for (iPID = 0; iPID < cPIDs; iPID ++)
    {
        szFileName[0] = 0;
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pdwPIDs[iPID]);
        if (hProcess != NULL)
        {
            if (lpfEnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
            {
                if (lpfGetModuleBaseName(hProcess, hMod, szFileName, sizeof(szFileName)))
                {
                    if (lstrcmpiW(pszModule, szFileName) == 0)
                    {
                        dwPID = pdwPIDs[iPID];
                    }
                }
            }

            CloseHandle(hProcess);
            if (dwPID != 0)
            {
                break;
            }
        }

    }

OnError:

    if (pdwPIDs != NULL)
    {
        CmFree(pdwPIDs);
    }
    FreeLibrary(hInstLib);

    return (dwPID);
}

typedef BOOL (WINAPI *lpfDuplicateTokenEx)(
    HANDLE, 
    DWORD, 
    LPSECURITY_ATTRIBUTES, 
    SECURITY_IMPERSONATION_LEVEL, 
    TOKEN_TYPE, 
    PHANDLE
);

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::RunAsUser
//
// Synopsis:  Run the action as an exe or other shell object on the choosen desktop
//
// Arguments: WCHAR *pszProgram - name of module to be launched
//            WCHAR *pszParams  - parameters to be passed to module
//            WCHAR *pszDesktop - desktop on which to launch module
//
// Returns:   HANDLE - The action Process handle, for Win32 only
//
// History:   07/19/99  v-vijayb      Created                        
//            07/27/99  nickball      Return codes and explicit path. 
//
//+----------------------------------------------------------------------------
HANDLE CCmConnection::RunAsUser(WCHAR *pszProgram, WCHAR *pszParams, WCHAR *pszDesktop)
{
    STARTUPINFOW        StartupInfo = {0};
    PROCESS_INFORMATION ProcessInfo = {0};

    WCHAR szShell[MAX_PATH + 1];
    DWORD dwPID;
    HANDLE hProcess = NULL;
    HANDLE hUserToken = NULL;
    HANDLE hProcessToken = NULL;

    MYDBGASSERT(pszProgram);
    CMTRACE(TEXT("RunAsUser"));

    //
    //  NOTE: Normally we only have one icon in the systray, being run by Explorer,
    //        thus any menuitem execution is done in the user's account.  On NT4,
    //        we can't rely on the Connections Folder to handle this for us, so we
    //        create and manage the systray icon ourselves, but we have to make
    //        sure than any items executed, are executed using the User's account.
    //        Or, on NT5 and later, we can have the strange case where HideTrayIcon
    //        is set to 0, thus requiring us to create/manage a systray icon (so
    //        there are 2 connectoids in the systray), hence the code below checks
    //        for all flavors of NT (rather than just NT4).
    //
    if (!OS_NT)
    {
        MYDBGASSERT(FALSE); 
        return NULL;
    }

    //
    // Get the PID for the shell. We expect explorer.exe, but could be others
    //

    GetProfileString(TEXT("windows"), TEXT("shell"), TEXT("explorer.exe"), szShell, MAX_PATH);
    dwPID = GetProcessId(szShell);

    //
    // Now extract the token from the shell process
    //

    if (dwPID)
    {
        //
        // Get the Process handle from the PID
        //

        hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, dwPID);
        CMTRACE1(TEXT("RunAsUser/OpenProcess(PROCESS_ALL_ACCESS, TRUE, dwPID) returns 0x%x"), hProcess);
    
        if (hProcess)
        {
            //
            // Get the token
            //

            if (OpenProcessToken(hProcess, TOKEN_ASSIGN_PRIMARY | TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE, &hProcessToken))
            {
                HINSTANCE hInstLibrary = LoadLibrary(TEXT("ADVAPI32.DLL"));
                CMTRACE1(TEXT("RunAsUser/LoadLibrary(ADVAPI32.DLL) returns 0x%x"), hInstLibrary);

                //
                // Get user token via DuplicateTokenEx and impersonate the user
                //
                
                if (hInstLibrary)
                {
                    lpfDuplicateTokenEx lpfuncDuplicateTokenEx = (lpfDuplicateTokenEx) GetProcAddress(hInstLibrary, "DuplicateTokenEx");
                    
                    CMTRACE1(TEXT("RunAsUser/GetProcAddress(hInstLibrary, DuplicateTokenEx) returns 0x%x"), lpfuncDuplicateTokenEx);

                    if (lpfuncDuplicateTokenEx)
                    {
                        if (lpfuncDuplicateTokenEx(hProcessToken, 
                                                   TOKEN_ASSIGN_PRIMARY | TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE, 
                                                   NULL, 
                                                   SecurityImpersonation, 
                                                   TokenPrimary, 
                                                   &hUserToken))
                        {            
                            BOOL bRes = ImpersonateLoggedOnUser(hUserToken);                   

                            if (FALSE == bRes)
                            {
                                hUserToken = NULL;
                                CMTRACE1(TEXT("RunAsUser/ImpersonateLoggedOnUser failed, GLE=&u"), GetLastError());    
                            }
                        }
                    }

                    FreeLibrary(hInstLibrary);
                }

                CloseHandle(hProcessToken);
            }

            CloseHandle(hProcess);
        }
    }

    CMTRACE1(TEXT("RunAsUser - hUserToken is 0x%x"), hUserToken);

    //
    // Can't impersonate user, don't run because we're in the system account
    //

    if (NULL == hUserToken)
    {
        MYDBGASSERT(FALSE);
        return NULL;   
    }

    //
    // Now prep CreateProcess
    //

    StartupInfo.cb = sizeof(StartupInfo);
    if (pszDesktop)
    {
        StartupInfo.lpDesktop = pszDesktop;
        StartupInfo.wShowWindow = SW_SHOW;
    }

    //
    // Build the path and params
    //

    LPWSTR pszwCommandLine = (LPWSTR) CmMalloc((2 + lstrlen(pszProgram) + 1 + lstrlen(pszParams) + 1) * sizeof(TCHAR));

    if (NULL == pszwCommandLine)
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

    //
    //  Copy path, but surround with double quotes for security
    //
    lstrcpyU(pszwCommandLine, TEXT("\""));
    lstrcatU(pszwCommandLine, pszProgram);
    lstrcatU(pszwCommandLine, TEXT("\""));

    if (pszParams[0] != L'\0')
    {
        lstrcatU(pszwCommandLine, TEXT(" "));
        lstrcatU(pszwCommandLine, pszParams);
    }
   
    CMTRACE1(TEXT("RunAsUser/CreateProcessAsUser() - Launching %s"), pszwCommandLine);
    
    if (NULL == CreateProcessAsUser(hUserToken, NULL, pszwCommandLine, 
                               NULL, NULL, FALSE, CREATE_SEPARATE_WOW_VDM, 
                               NULL, NULL,
                               &StartupInfo, &ProcessInfo))
    {
        CMTRACE1(TEXT("RunAsUser/CreateProcessAsUser() failed, GLE=%u."), GetLastError());
        ProcessInfo.hProcess = NULL;
        ProcessInfo.hThread = NULL;
    }

    if (ProcessInfo.hThread)
    {
        CloseHandle(ProcessInfo.hThread);
    }    

    CloseHandle(hUserToken);        
    RevertToSelf();
   
    CmFree(pszwCommandLine);
    return (ProcessInfo.hProcess);
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::ExecCmdLine
//
// Synopsis:  ShellExecute the command line
//            The code is copied from CActionList::RunAsExe
//
// Arguments: const TCHAR* pszCmdLine - the command line to run, including
//                  arguments
//            const TCHAR* pszCmsFile - Full path of CMS file
//
// Returns:   BOOL - Whether ShellExecute succeed
//
// Notes:     Menu actions consists of a command string and an optional argument string.
//            The first delimited string is considered the command portion and anything
//            thereafter is treated as the argument portion, which formatless and passed
//            indiscriminately to ShellExecuteEx. Long filename command paths are 
//            enclosed in "+" signs by CMAK. Thus the following permutations are allowed:
//
//            "C:\\Progra~1\\Custom.Exe" 
//            "C:\\Progra~1\\Custom.Exe Args" 
//            "+C:\\Program Files\\Custom.Exe+"
//            "+C:\\Program Files\\Custom.Exe+ Args"
//
// History:   02/10/98  fengsun     Created Header
//            02/09/99  nickball    Fixed long filename bug one year later.
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::ExecCmdLine(const TCHAR* pszCmdLine, const TCHAR* pszCmsFile) 
{
    LPTSTR pszArgs = NULL;
    LPTSTR pszCmd = NULL;

    BOOL bRes = FALSE;

    MYDBGASSERT(pszCmdLine);
    MYDBGASSERT(pszCmsFile);

    if (NULL == pszCmdLine || NULL == pszCmsFile)
    {       
        return FALSE;    
    }
    
    CMTRACE1(TEXT("ExecCmdLine() pszCmdLine is %s"), pszCmdLine);

    if (CmParsePath(pszCmdLine, pszCmsFile, &pszCmd, &pszArgs))
    {    
        CMTRACE1(TEXT("ExecCmdLine() pszCmd is %s"), pszCmd);
        CMTRACE1(TEXT("ExecCmdLine() pszArgs is %s"), pszArgs);
         
        //
        // Now we have the exe name and args separated, execute it
        //

        if (IsLogonAsSystem())
        {
            HANDLE hProcess = RunAsUser(pszCmd, pszArgs, TEXT("Winsta0\\default"));

            if (hProcess)
            {
                CloseHandle(hProcess);
                bRes = TRUE;
            }
            else
            {
                bRes = FALSE;
            }
        }
        else
        {
            SHELLEXECUTEINFO seiInfo;

            ZeroMemory(&seiInfo,sizeof(seiInfo));
            seiInfo.cbSize = sizeof(seiInfo);
            seiInfo.fMask |= SEE_MASK_FLAG_NO_UI;
            seiInfo.lpFile = pszCmd;
            seiInfo.lpParameters = pszArgs;
            seiInfo.nShow = SW_SHOW;

            //
            // Load Shell32.dll and call Shell_ExecuteEx
            //

            CShellDll ShellDll(TRUE); // TRUE == don't unload shell32.dll because of bug 289463
            bRes = ShellDll.ExecuteEx(&seiInfo);

            CMTRACE2(TEXT("ExecCmdLine/ShellExecuteEx() returns %u - GLE=%u"), bRes, GetLastError());
        }           
    }

    CmFree(pszCmd);
    CmFree(pszArgs);
   
    CMTRACE1(TEXT("ExecCmdLine() - Returns %d"), bRes);
   
    return bRes;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::LoadHelpFileName
//
// Synopsis:  Get the connection help file name
//
// Arguments: None
//
// Returns:   LPTSTR - The help file name, can be a empty string
//            caller is responsible to free the pointer
//
// History:   Created Header    2/13/98
//
//+----------------------------------------------------------------------------
LPTSTR CCmConnection::LoadHelpFileName() 
{
    //
    // Read the filename from profile first
    //
    
    LPTSTR pszFullPath = NULL;
    
    LPTSTR pszFileName = m_IniService.GPPS(c_pszCmSection,c_pszCmEntryHelpFile);

    if (pszFileName != NULL && pszFileName[0])
    {
        //
        // The help file name is relative to the .cmp file, convert it into full name
        //
        pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszFileName);
    }

    CmFree(pszFileName);
    
    return pszFullPath;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::LoadConnectionIcons
//
// Synopsis:  Load big and small icon of the connection
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/13/98
//
//+----------------------------------------------------------------------------
void CCmConnection::LoadConnectionIcons()
{
    // Load large icon name

    LPTSTR pszTmp = m_IniService.GPPS(c_pszCmSection, c_pszCmEntryBigIcon);

    if (*pszTmp) 
    {
        //
        // The icon name is relative to the .cmp file, convert it into full name
        //
        LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszTmp);

        m_hBigIcon = CmLoadIcon(CMonitor::GetInstance(), pszFullPath);

        CmFree(pszFullPath);
    }

    CmFree(pszTmp);

    // Use default (EXE) large icon if no user icon found

    if (!m_hBigIcon) 
    {
        m_hBigIcon = CmLoadIcon(CMonitor::GetInstance(), MAKEINTRESOURCE(IDI_APP));
    }

    // Load the small Icon
    // Load small icon name

    pszTmp = m_IniService.GPPS(c_pszCmSection, c_pszCmEntrySmallIcon);
    if (*pszTmp) 
    {
        //
        // The icon name is relative to the .cmp file, convert it into full name
        //
        LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszTmp);
        
        m_hSmallIcon = CmLoadSmallIcon(CMonitor::GetInstance(), pszFullPath);

        CmFree(pszFullPath);
    }
    CmFree(pszTmp);

    // Use default (EXE) small icon if no user icon found

    if (!m_hSmallIcon)
    {
        m_hSmallIcon = CmLoadSmallIcon(CMonitor::GetInstance(), MAKEINTRESOURCE(IDI_APP));
    }

}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::PositionWindow
//
// Synopsis:  Position the window according to dwPositionId, so multiple 
//            connection window would be positioned differently
//
// Arguments: HWND hWnd - The window to position
//            dwPositionId - the id of the window
//
// Returns:   Nothing
//
// History:   fengsun Created Header    3/25/98
//
//+----------------------------------------------------------------------------
void CCmConnection::PositionWindow(HWND hWnd, DWORD dwPositionId) 
{
    MYDBGASSERT(IsWindow(hWnd));

    //
    // Get the rect of this window
    //
    RECT rcDlg;
    GetWindowRect(hWnd, &rcDlg);

    //
    // center within work area
    //
    RECT rcArea;
    SystemParametersInfoA(SPI_GETWORKAREA, NULL, &rcArea, NULL);


    //
    // Position the window on the desktop work area according to the PositionId
    //      x = Desktop.midX - width/2
    //      y = Desktop.midY - hight/2 + hight * (PostitionId%3 -1)
    // X position is always the same
    // Y position repeat for every three time
    //
    int xLeft = (rcArea.left + rcArea.right) / 2 - (rcDlg.right - rcDlg.left) / 2;
    int yTop = (rcArea.top + rcArea.bottom) / 2 - (rcDlg.bottom - rcDlg.top) / 2
                + (rcDlg.bottom - rcDlg.top) * ((int)dwPositionId%3 -1);

    //
    // if the dialog is outside the screen, move it inside
    //
    if (xLeft < rcArea.left)
    {
        xLeft = rcArea.left;
    }
    else if (xLeft + (rcDlg.right - rcDlg.left) > rcArea.right)
    {
        xLeft = rcArea.right - (rcDlg.right - rcDlg.left);
    }

    if (yTop < rcArea.top)
    {
        yTop = rcArea.top;
    }
    else if (yTop + (rcDlg.bottom - rcDlg.top) > rcArea.bottom)
    {
        yTop = rcArea.bottom - (rcDlg.bottom - rcDlg.top);
    }

    
    SetWindowPos(hWnd, NULL, xLeft, yTop, -1, -1,
        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

}


#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::AssertValid
//
// Synopsis:  For debug purpose only, assert the connection object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CCmConnection::AssertValid() const
{
    MYDBGASSERT(m_dwState >= 0 && m_dwState <= STATE_TERMINATED);
    MYDBGASSERT(m_hRasDial != NULL || m_hRasTunnel != NULL);
    ASSERT_VALID(&m_ConnStatistics);
    ASSERT_VALID(&m_IdleStatistics);
    ASSERT_VALID(&m_StatusDlg);

    //    ASSERT_VALID(m_TrayIcon);
    //    ASSERT_VALID(m_WatchProcess);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\arrayptr.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ArrayPtr.h	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Implement class CPtrArray, a array of void*, which grows dynamicly
//           This class is exactly the same as the one defined by MFC.
//           Help on the class also comes with vc help
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    2/17/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ArrayPtr.h"

CPtrArray::CPtrArray()
{
   m_pData = NULL;
   m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
   ASSERT_VALID(this);

   delete [] (BYTE*)m_pData;
}

void CPtrArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nNewSize >= 0);

   if (nGrowBy != -1)
   {
      m_nGrowBy = nGrowBy;  // set new size
   }

   if (nNewSize == 0)
   {
      // shrink to nothing 
      delete [] (BYTE*)m_pData;
      m_pData = NULL;
      m_nSize = m_nMaxSize = 0;
   }
   else if (m_pData == NULL)
   {
      // create one with exact size
      m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

      if (m_pData)
	  {
	     memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

		 m_nSize = m_nMaxSize = nNewSize;
	  }
   }
   else if (nNewSize <= m_nMaxSize)
   {
      // it fits

      if (m_pData)
      {
         if (nNewSize > m_nSize)
         {
             void* pElement = m_pData[m_nSize];

             if (pElement)
             {
               // initialize the new elements
               memset(&pElement, 0, (nNewSize-m_nSize) * sizeof(void*));
             }
         }

         m_nSize = nNewSize;
      }
   }
   else
   {
      // Otherwise grow array
      int nNewMax;
      if (nNewSize < m_nMaxSize + m_nGrowBy)
      {
         nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
      }
      else
      {
         nNewMax = nNewSize;  // no slush
      }

      void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

      if (pNewData && m_pData)
      {
          // copy new data from old
          memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

          // construct remaining elements
          MYDBGASSERT(nNewSize > m_nSize);

          memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

          // get rid of old stuff (note: no destructors called)
          delete [] (BYTE*)m_pData;
          m_pData = pNewData;
          m_nSize = nNewSize;
          m_nMaxSize = nNewMax;
      }
   }
}

void CPtrArray::FreeExtra()
{
   ASSERT_VALID(this);

   if (m_pData && (m_nSize != m_nMaxSize))
   {
      // shrink to desired size
      void** pNewData = NULL;
      if (m_nSize != 0)
      {
         pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];

         if (pNewData)
         {
             // copy new data from old
             memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

             // get rid of old stuff (note: no destructors called)
             delete [] (BYTE*)m_pData;
             m_pData = pNewData;
             m_nMaxSize = m_nSize;
         }
      }
      else
      {
          // get rid of old stuff (note: no destructors called)
          delete [] (BYTE*)m_pData;
          m_pData = pNewData;
          m_nMaxSize = m_nSize;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nIndex >= 0);

   if (nIndex >= m_nSize)
   {
      SetSize(nIndex+1);
   }

   if (m_pData)
   {
       m_pData[nIndex] = newElement;
   }
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount /*=1*/)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nIndex >= 0);    // will expand to meet need
   MYDBGASSERT(nCount > 0);     // zero or negative size not allowed

   if (nIndex >= m_nSize)
   {
      // adding after the end of the array
      SetSize(nIndex + nCount);  // grow so nIndex is valid
   }
   else
   {
      // inserting in the middle of the array
      int nOldSize = m_nSize;
      SetSize(m_nSize + nCount);  // grow it to new size
      // shift old data up to fill gap

      if (m_pData)
      {
         CmMoveMemory(&m_pData[nIndex+nCount], &m_pData[nIndex], (nOldSize-nIndex) * sizeof(void*));

         // re-init slots we copied from

         memset(&m_pData[nIndex], 0, nCount * sizeof(void*));
      }
   }

   // insert new value in the gap
   MYDBGASSERT(nIndex + nCount <= m_nSize);

   while (m_pData && nCount--)
   {
      m_pData[nIndex++] = newElement;
   }
}

void CPtrArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nIndex >= 0);
   MYDBGASSERT(nCount >= 0);
   MYDBGASSERT(nIndex + nCount <= m_nSize);

   if ((NULL == m_pData) || (nCount < 0) || (nIndex < 0) || ((nIndex + nCount) > m_nSize))
   {
      return;
   }

   // just remove a range
   int nMoveCount = m_nSize - (nIndex + nCount);

   if (nMoveCount)
   {
      memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount], nMoveCount * sizeof(void*));
   }

   m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
   ASSERT_VALID(this);
   MYDBGASSERT(pNewArray != NULL);
   ASSERT_VALID(pNewArray);
   MYDBGASSERT(nStartIndex >= 0);

   if (pNewArray && (pNewArray->GetSize() > 0))
   {
      InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
      for (int i = 0; i < pNewArray->GetSize(); i++)
         SetAt(nStartIndex + i, pNewArray->GetAt(i));
   }
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef DEBUG

void CPtrArray::AssertValid() const
{
   if (m_pData == NULL)
   {
      MYDBGASSERT(m_nSize == 0 && m_nMaxSize == 0);
   }
   else
   {
      MYDBGASSERT(m_nSize >= 0);
      MYDBGASSERT(m_nMaxSize >= 0);
      MYDBGASSERT(m_nSize <= m_nMaxSize);
      MYDBGASSERT(!IsBadReadPtr(m_pData, m_nMaxSize * sizeof(void*)));
   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\arrayptr.h ===
//+----------------------------------------------------------------------------
//
// File:     ArrayPtr.h	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Implement class CPtrArray, a array of void*, which grows dynamicly
//           This class is exactly the same as the one defined by MFC.
//           Help on the class also comes with vc help
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    2/17/98
//
//+----------------------------------------------------------------------------

#ifndef ARRAYPTR_H
#define ARRAYPTR_H

#include "windows.h"
#include "CmDebug.h"


class CPtrArray 
{

public:

// Construction
   CPtrArray();
   ~CPtrArray();

// Attributes
   int GetSize() const;
   int GetUpperBound() const;
   void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
   // Clean up
   void FreeExtra();
   void RemoveAll();

   // Accessing elements
   void* GetAt(int nIndex) const;
   void SetAt(int nIndex, void* newElement);
   void*& ElementAt(int nIndex);

   // Direct Access to the element data (may return NULL)
   const void** GetData() const;
   void** GetData();

   // Potentially growing the array
   void SetAtGrow(int nIndex, void* newElement);
   int Add(void* newElement);
   int Append(const CPtrArray& src);
   void Copy(const CPtrArray& src);

   // overloaded operator helpers
   void* operator[](int nIndex) const;
   void*& operator[](int nIndex);

   // Operations that move elements around
   void InsertAt(int nIndex, void* newElement, int nCount = 1);
   void RemoveAt(int nIndex, int nCount = 1);
   void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
   void** m_pData;   // the actual array of data
   int m_nSize;     // # of elements (upperBound - 1)
   int m_nMaxSize;  // max allocated
   int m_nGrowBy;   // grow amount

public:
#ifdef DEBUG
   void AssertValid() const;  //assert this is valid, for debugging
#endif
};



inline int CPtrArray::GetSize() const
{
    return m_nSize;
}

inline int CPtrArray::GetUpperBound() const
{
    return m_nSize-1;
}

inline void CPtrArray::RemoveAll()
{
    SetSize(0);
}

inline void* CPtrArray::GetAt(int nIndex) const
{ 
    MYDBGASSERT(nIndex >= 0 && nIndex < m_nSize);
    return m_pData ? m_pData[nIndex] : NULL;
}

inline void CPtrArray::SetAt(int nIndex, void* newElement)
{ 
    MYDBGASSERT(nIndex >= 0 && nIndex < m_nSize);
    if (m_pData)
    {
        m_pData[nIndex] = newElement;
    }
}

inline void*& CPtrArray::ElementAt(int nIndex)
{
    MYDBGASSERT(nIndex >= 0 && nIndex < m_nSize);
    return m_pData[nIndex];
}

inline int CPtrArray::Add(void* newElement)
{
    int nIndex = m_nSize;
    SetAtGrow(nIndex, newElement);
    return nIndex;
}

inline void* CPtrArray::operator[](int nIndex) const
{
    return GetAt(nIndex);
}

inline void*& CPtrArray::operator[](int nIndex)
{
    return ElementAt(nIndex);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmgr\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//
// Module:   CMMGR32.EXE
//
// Synopsis: Utility functions for cmmgr32.exe
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------


#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
//  Function    GetProfileInfo
//
//  Synopsis    get the service name from cms
//              
//
//  Arguments   pszCmpName      the cmp file name.  Can be in one of the following
//                              3 formats:
//
//                              1. relative paths without the extension(e.g. msn, cm\msn)
//                              2. relative path with the extension(e.g. msn.cmp, cm\msn.cmp)
//                              3. full path(e.g. c:\cm\msn.cmp)
//
//              pszServiceName  the output buffer for the service name(ServiceName).
//                              must be at least RAS_MaxEntryName.
//
//  Returns     BOOL    TRUE=success, FALSE=failure
//
//-----------------------------------------------------------------------------

BOOL GetProfileInfo(
    LPTSTR pszCmpName,
    LPTSTR pszServiceName
) 
{
    LPTSTR pszTmp;
    LPTSTR pszDot;
    LPTSTR pszSlash;
    LPTSTR pszColon;
    
    TCHAR szFileName[MAX_PATH + 1];
    TCHAR szCmsFile[MAX_PATH + 1];
    TCHAR szPath[MAX_PATH + 1];

    lstrcpynU(szFileName, pszCmpName, sizeof(szFileName)/sizeof(TCHAR)-1);

    pszDot = CmStrrchr(szFileName, TEXT('.'));
    pszSlash = CmStrrchr(szFileName, TEXT('\\'));
    pszColon = CmStrrchr(szFileName, TEXT(':'));
    
    if ((pszSlash >= pszDot) && (pszColon >= pszDot)) 
    {
        //
        // The argument doesn't have an extension, so we'll include one.
        //
        lstrcatU(szFileName, TEXT(".cmp"));
    }

    //
    // We need to change our current dir to read the profiles.
    // If we found a slash, it's either a UNC path, relative path, or
    // a full path. Use it to set the current dir. Otherwise use we 
    // assume that the profile is local and use the application path.
    //

    if (pszSlash)
    {
        *pszSlash = TEXT('\0');
        MYVERIFY(SetCurrentDirectoryU(szFileName));
        //
        // restore the slash
        //
        *pszSlash = TEXT('\\');
    }
    else
    {
        //
        // Assumes its local, use app path for current dir
        //
               
        TCHAR szCurrent[MAX_PATH];
    
        if (GetModuleFileNameU(NULL, szCurrent, MAX_PATH - 1))
        {            
            pszSlash = CmStrrchr(szCurrent, TEXT('\\'));
            
            MYDBGASSERT(pszSlash);

            if (pszSlash)
            {
                *pszSlash = TEXT('\0');  

                MYVERIFY(SetCurrentDirectoryU(szCurrent));
            }
        }
    }

    //
    // test whether this is a valid cmp
    //
    if (SearchPathU(NULL, szFileName, NULL, MAX_PATH, szPath, &pszTmp))
    {
        BOOL bReturn = FALSE;
        
        //
        // szPath should now be a full path.
        //

        //
        // first get the CMS file path from the cmp file.
        //

        GetPrivateProfileStringU(c_pszCmSection, c_pszCmEntryCmsFile, TEXT(""), szCmsFile, MAX_PATH, szPath);

        //
        // construct the cms file path.  the cms file path obtained from the cmp file 
        // is a relative path.
        //
        pszTmp = CmStrrchr(szPath, TEXT('\\'));
        if (NULL != pszTmp)
        {
            //
            // Move past the '\\'
            //
            pszTmp = CharNextU(pszTmp);
            
            if (NULL != pszTmp)
            {
                lstrcpyU(pszTmp, szCmsFile); 
                GetPrivateProfileStringU(c_pszCmSection, c_pszCmEntryServiceName, TEXT(""), 
                                        pszServiceName, MAX_PATH, szPath);              
                //
                // If the .cms file doesn't exist or is corrupt
                // the value of pszService will be ""
                //
                if (TEXT('\0') != *pszServiceName)
                {
                    bReturn = TRUE;
                }
            }
        }

        return bReturn;
    }
    else
    {
        //
        // there isn't much we can do here
        //
        *pszServiceName = TEXT('\0');

        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Function    IsCmpPathAllUser
//
//  Synopsis    If this function is executed on NT5, then it checks to see if
//              the passed in CMP file path has the users APP_DATA directory as
//              part of the path.  If so, then it considers the profile to be
//              single user.  Otherwise it returns that the profile is all user.
//              If the function encounters an error it returns that the profile
//              is all user (that is considered the default case).
//              
//
//  Arguments   pszCmp          the cmp file name
//
//  Returns     BOOL    TRUE == All User Profile, FALSE == Single User profile
//
//  History     quintinb    Created     05/12/99
//
//-----------------------------------------------------------------------------
BOOL IsCmpPathAllUser(LPCTSTR pszCmp)
{
    BOOL bReturn = TRUE;

    //
    //  If we get an invalid input parameter then just assume that it is
    //  All User.  On the other hand, if the OS isn't NT5, then we are
    //  All User so there is no need to check the path.  If we are on
    //  NT5 and the beginning of the cmp path matches the users
    //  Application data dir, then we have a single user profile and
    //  should return false.
    //

    if ((NULL != pszCmp) && (TEXT('\0') != pszCmp[0]) && OS_NT5)
    {

        //
        //  Load shell32 here so that we can call the shell to find out
        //  the path to the Application Data directory.
        //

        typedef HRESULT (WINAPI *pfnSHGetSpecialFolderLocationSpec)(HWND, int, LPITEMIDLIST*);
        typedef BOOL (WINAPI *pfnSHGetPathFromIDListSpec)(LPCITEMIDLIST, LPTSTR);
        typedef HRESULT (WINAPI *pfnSHGetMallocSpec)(LPMALLOC *);

        pfnSHGetSpecialFolderLocationSpec pfnSHGetSpecialFolderLocation;
        pfnSHGetMallocSpec pfnSHGetMalloc;
        pfnSHGetPathFromIDListSpec pfnSHGetPathFromIDList;

        HMODULE hShell32 = LoadLibraryExA("Shell32.dll", NULL, 0);

        if (hShell32)
        {
            pfnSHGetSpecialFolderLocation = (pfnSHGetSpecialFolderLocationSpec)GetProcAddress(hShell32, 
                "SHGetSpecialFolderLocation");

            pfnSHGetMalloc = (pfnSHGetMallocSpec)GetProcAddress(hShell32, "SHGetMalloc");

#ifdef UNICODE
            pfnSHGetPathFromIDList = (pfnSHGetPathFromIDListSpec)GetProcAddress(hShell32,
                "SHGetPathFromIDListW");
#else
            pfnSHGetPathFromIDList = (pfnSHGetPathFromIDListSpec)GetProcAddress(hShell32,
                "SHGetPathFromIDListA");
#endif

            if (pfnSHGetSpecialFolderLocation && pfnSHGetPathFromIDList && pfnSHGetMalloc)
            {
                LPITEMIDLIST pidl;
                TCHAR szAppDataDir[MAX_PATH+1];
                TCHAR szTemp[MAX_PATH+1];

                HRESULT hr = pfnSHGetSpecialFolderLocation(NULL,
                                                           CSIDL_APPDATA,
                                                           &pidl);    
                if (SUCCEEDED(hr))
                {
                    if (pfnSHGetPathFromIDList(pidl, szAppDataDir))
                    {
                        UINT uiLen = lstrlenU(szAppDataDir) + 1;
                        lstrcpynU(szTemp, pszCmp, uiLen);

                        if (0 == lstrcmpiU(szAppDataDir, szTemp))
                        {
                            bReturn = FALSE;
                        }
                    }

                    LPMALLOC pMalloc;
                    if (SUCCEEDED(pfnSHGetMalloc(&pMalloc)))
                    {
                        pMalloc->Free(pidl);
                        MYVERIFY(SUCCEEDED(pMalloc->Release()));
                    }
                }            
            }

            FreeLibrary(hShell32);
        }
    }

    //
    //  Figure out what the user directory of the current user is.  We can compare this
    //  against the directory of the phonebook and see if we have a private user
    //  profile or an all user profile.

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\connection.h ===
//+----------------------------------------------------------------------------
//
// File:     connection.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header for the CCmConnection class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#ifndef CONNECTION_H
#define CONNECTION_H

#include "cm_misc.h"
#include "ras.h"
#include "ConnStat.h"
#include "Idlestat.h"
#include "WatchProcess.h"
#include "StatusDlg.h"
#include "ReconnectDlg.h"
#include "cm_def.h"
#include "resource.h"
#include "TrayIcon.h"
#include <rasdlg.h>
#include "cmdial.h"
#include "RasApiDll.h"
#include "cmlog.h"


struct tagCmConnectedInfo;  // CM_CONNECTED_INFO
struct Cm_Connection;       // CM_CONNECTION

class CCmConnection
{
public:
    // Called by main thread
    // Post a hangup message to itself
    // The connection is already hangup,
    void PostHangupMsg() const;

    CCmConnection(const tagCmConnectedInfo * pConnectedInfo, 
        const Cm_Connection* pConnectionEntry);
    ~CCmConnection();

    const TCHAR* GetServiceName() const {return m_szServiceName;}

    enum { 
        // Tray icon message send to status window
        WM_TRAYICON = WM_USER + 1, 
        WM_CONN_EVENT,  // Internal message posted to the thread, wParam in below
    };

    // Connection events, wParam for WM_CONN_EVENT
    enum CONN_EVENT
    {
        EVENT_LOST_CONNECTION, // The connection is lost
        EVENT_IDLE,            // No-traffic/No watching-process
        EVENT_COUNTDOWN_ZERO,  // Disconnect Countdown down to 0
        EVENT_USER_DISCONNECT, // user choose to disconnect 
        EVENT_CMDIAL_HANGUP,   // cmdial send cmmon a hangup request
        EVENT_RECONNECT,       // User clicked OK for the reconnect dialog
        EVENT_NONE,            // No event happened
    };

    // wParam for WM_COMMAND
    enum {IDM_TRAYMENU = IDC_DISCONNECT + 1000};  // addition tray icon menu id start from here

    void ReInstateTrayIcon();                       // re-add the trayicon to the tray
    DWORD OnTrayIcon(WPARAM wParam, LPARAM lParam); // WM_TRAYICON
    void OnStatusDetails();                         // "Detail" button clicked
    void OnStayOnLine();                            // "Stay Online" clicked
    void OnAdditionalTrayMenu(WORD nCmd);           // Additinal command from tray menu selected
    BOOL OnEndSession(BOOL fEndSession, BOOL fLogOff); // WM_ENDSESSION

    // Logging class
    CmLogFile m_Log;

    // Is this a "global" user (i.e. an all-user connectoid) with global creds?
    // That's the only type of connectoid that will survive a Fast User Switch
    BOOL m_fGlobalGlobal;
    
protected:
    enum CONN_STATE
    {  
        STATE_CONNECTED, // the connection is connected, this is the initial state
        STATE_COUNTDOWN, // displaying disconnect count down dialog box
        STATE_PROMPT_RECONNECT, // Displaying prompt reconnect dialog
        STATE_RECONNECTING,  // Calling cmdial to reconnect
        STATE_TERMINATED,    // connection no longer exist
    };  

    // Internal state
    CONN_STATE m_dwState;

    // The connection thread ID
    DWORD m_dwThreadId;

    // Dial-up RAS connection handle
    HRASCONN m_hRasDial;

    // Tunnel RAS connection handle
    HRASCONN m_hRasTunnel;

    // Connection statistics for Win9x
    CConnStatistics m_ConnStatistics;

    // Disconnect count down timer is 30 seconds
    enum{IDLE_DLG_WAIT_TIMEOUT = 30 * 1000}; 

    // Manage idle disconnect for Win9x
    CIdleStatistics m_IdleStatistics;

    // The tray icon on the task bar
    CTrayIcon   m_TrayIcon;

    // The big and small CM icon, 
    // the icon for status dialog and reconnect dialog
    HICON m_hBigIcon;
    HICON m_hSmallIcon;

    // Manage watch process list
    CWatchProcessList m_WatchProcess;

    // the start time when connected
    DWORD m_dwConnectStartTime;

    // The start time of disconnect count down
    DWORD m_dwCountDownStartTime;

    // Status and disconnect count down dialog
    CStatusDlg m_StatusDlg;

    // the prompt reconnect dialog
    CReconnectDlg m_ReconnectDlg;

    //
    // Information for reconnect only, except dwCmFlags
    //
        
    CMDIALINFO m_ReconnectInfo;

    // the long service name
    TCHAR m_szServiceName[RAS_MaxEntryName + 1];

    TCHAR m_szRasPhoneBook[MAX_PATH];

    CIni m_IniProfile;  // .cmp file
    CIni m_IniService;  // .cms file
    CIni m_IniBoth;     // Both .cmp and .cms file
                        // Write to .cmp file
                        // Read from .cmp file, if not found try .cms file

    // The help file name
    TCHAR m_szHelpFile[128];

    // An event for RAS to be signaled whe connection is lost
    // If NULL, we have to check the connection by RasGetConnectionStatus in our timer
    HANDLE m_hEventRasNotify;

    // The link to rasapi32
    CRasApiDll m_RasApiDll;

    // Whether to minimize the working set before MsgWaitForMultipleObject
    BOOL m_fToMinimizeWorkingSet;

    // hide the trayicon?
    BOOL m_fHideTrayIcon;

    // Used to cascade the window, increased by 1 for each connection
    static DWORD m_dwCurPositionId;
    // The position id of this connection, use this id to position the window
    DWORD m_dwPositionId;
public:    
    BOOL StartConnectionThread(); // Create a thread for this connection
    CONN_EVENT StateConnectedOnTimer(); 
    BOOL IsTrayIconHidden() const;

protected:
    static DWORD WINAPI ConnectionThread(LPVOID pConnection);  // Thread entry point
    DWORD ConnectionThread();   // Non static function of the entry point

    void InitIniFiles(const TCHAR* pszProfileName);
    void StateConnectedInit();
    void StateConnectedCleanup(BOOL fEndSession = FALSE);

    void StateConnected();  // The life time of state STATE_CONNECTED/COUNTDOWN
    CONN_EVENT StateConnectedGetEvent();

    CONN_STATE StateConnectedProcessEvent(CONN_EVENT wEvent);

    BOOL CmCustomHangup(BOOL fPromptReconnect, BOOL fEndSession = FALSE);

    BOOL CheckRasConnection(OUT BOOL& fLostConnection);

    LPTSTR LoadHelpFileName() ;
    void LoadConnectionIcons();
    BOOL IsPromptReconnectEnabled() const;
    BOOL IsAutoReconnectEnabled() const;

    HANDLE CallRasConnectionNotification(HRASCONN hRasDial, HRASCONN hRasTunnel);
    static DWORD WINAPI RasMonitorDlgThread(LPVOID lParam);


    CONN_STATE StatePrompt();
    BOOL Reconnect();

    //
    // Utility functions
    //
    BOOL ExecCmdLine(const TCHAR* pszCmdLine, const TCHAR* pszCmsFile);
    HANDLE RunAsUser(WCHAR *pszProgram, WCHAR *pszParams, WCHAR *pszDesktop);
    DWORD GetProcessId(WCHAR *pszModule);

    static void PositionWindow(HWND hWnd, DWORD dwPositionId);
public:
#ifdef DEBUG
   void AssertValid() const;  //assert this is valid, for debugging
#endif
};

//
// Inline functions
//


inline BOOL CCmConnection::IsTrayIconHidden() const
{
    return m_fHideTrayIcon;
}

inline void CCmConnection::ReInstateTrayIcon()
{
    //
    // we need to re-add the trayicon
    //
    m_TrayIcon.SetIcon(NULL, m_StatusDlg.GetHwnd(), WM_TRAYICON, 0, m_szServiceName);
}
     
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\modaldlgclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     modaldlgclass.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Modal dlg implementation
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//	Please see pnpu\common\source for the actual source here.
//

#include "modaldlg.h"
#include "modaldlg.cpp"

#include "modelessdlg.h"
#include "modelessdlg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\connstat.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ConnStat.cpp	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Implementation of class CConnStatistics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 Fengsun Created    10/15/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ConnStat.h"
#include "cm_misc.h" // for MYDBGASSERT
#include "DynamicLib.h"
#include "resource.h"
#include "perf_str.h"

//
// DeviceIoControl code
//

#define UNIMODEM_IOCTL_GET_STATISTICS	0x0000a007

//
// Constructor and destructor
//

CConnStatistics::CConnStatistics()
{
    m_TrafficRing.Reset();
    m_dwReadPerSecond = m_dwWritePerSecond = m_dwBaudRate = m_dwDuration = 0;
    m_dwInitBytesRead = m_dwInitBytesWrite = (DWORD)-1;
    m_hStatDevice = NULL;
    m_hKey = NULL;
    m_fAdapter2 = FALSE;
    m_fAdapterSet = FALSE;
    m_pszTotalBytesRecvd = m_pszTotalBytesXmit = m_pszConnectSpeed = NULL;
}

CConnStatistics::~CConnStatistics()
{
    Close();
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::OpenByDevice
//
// Synopsis:  
//
// Arguments: HRASCONN hrcRasConn - the ras connection handle, needed for 
//                     non-tunnle connection, when registry is not available
//
// Returns:   BOOL - Whether open succeeded.  
//              Because the TAPI device handle maybe available later from cmstat dll
//              Use IsAvailable() to see whether statistics is available
//
// History:   fengsun Created Header    10/29/97
//
//+----------------------------------------------------------------------------
BOOL CConnStatistics::OpenByDevice(HRASCONN hrcRasConn)
{
    MYDBGASSERT(OS_W95);
    MYDBGASSERT(!IsAvailable());
    MYDBGASSERT(hrcRasConn);

    if (GetDeviceHandle(hrcRasConn))
    {
        return TRUE;
    }

    //
    // NOTE: For win95 gold, GetDeviceHandle will fail if TAPI 2.1 is installed.  
    // We used to have a hack there to hook the lights.exe.  We decided to take
    // it out and to let the setup program ask user to upgrade TAPI or DUN. We 
    // dropped HookLight(), because it does not work for multiple connections.
    //

    MYDBGASSERT(FALSE);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//	Function:	Open()
//
//	Synopsis:	Encapsulates the opening of the statistics data store
//
// Arguments:   HINSTANCE hInst         - The instance to LoadString "Dial-up Adapter"
//              DWORD dwInitBytesRecv   - Initial value of TotalBytesRecvd
//              DWORD dwInitBytesSend   - Initial value of TotalBytesXmit
//              HRASCONN hDial          - Handle to dial-up connection, if any
//              HRASCONN hTunnel        - Handle to tunnel connection, if any
//
//	Returns:    TRUE  if succeed
//			    FALSE otherwise
//
//	History:    nickball    03/04/00     Created. Wrapped existing code.
//              
//  Note:       This function initialize the connection statistics from one
//              of three places. 
//
//                  1) W98 registry 
//                  2) NT5 RAS API
//                  3) W95 Tapi device handle. 
//
//----------------------------------------------------------------------------
void CConnStatistics::Open(HINSTANCE hInst, 
                           DWORD dwInitBytesRecv,
                           DWORD dwInitBytesSend, 
                           HRASCONN hDial, 
                           HRASCONN hTunnel)
{
    //
    // Start statistics 
    //
   
    if (OS_NT5)
    {
        OpenByStatisticsApi(dwInitBytesRecv, dwInitBytesSend, hDial, hTunnel);
    }
    else
    {
        OpenByPerformanceKey(hInst,
                             dwInitBytesRecv,
                             dwInitBytesSend);
    }

    //
    // See if we have stats, go with plan B if not.
    //

    if (!IsAvailable())
    {
        //
        // On W95, we have a fallback position of hooking the TAPI handle 
        // via RAS, so use it. Note: We will retry initializing stats on every 
        // timer tick if we don't get them here, so all is not lost for W98.
        // Note that we only check hDial here because if you are on win95 without
        // MSDUN 1.2, you aren't able to tunnel.
        //

        if (OS_W95 && hDial)
        {
            OpenByDevice(hDial);
        }
    }
}

//+---------------------------------------------------------------------------
//
//	Function:	OpenByStatisticsApi()
//
//	Synopsis:	Sets initial values and makes sure the RasApis are loaded.
//
// Arguments:   DWORD dwInitBytesRecv   - Initial value of TotalBytesRecvd
//              DWORD dwInitBytesSend   - Initial value of TotalBytesXmit
//              HRASCONN hDial          - Handle to dial-up connection, if any
//              HRASCONN hTunnel        - Handle to tunnel connection, if any
//
//	Returns:    Nothing
//
//	History:    nickball    03/04/00   Created from OpenByPerformanceKey
//
//----------------------------------------------------------------------------
void CConnStatistics::OpenByStatisticsApi(DWORD dwInitBytesRecv, 
                                          DWORD dwInitBytesSend,
                                          HRASCONN hDial, 
                                          HRASCONN hTunnel)
{
    //
    // Initialize our APIs
    //

    m_RasApiDll.Load();
    
    //
    // Get the handle that we'll use to look up stats.
    // Try tunnel first, then drop back to dial-up
    //

    CMTRACE2(TEXT("CConnStatistics::OpenByStatisticsApi() hTunnel is 0x%x and hDial is 0x%x"), hTunnel, hDial);

    m_hRasConn = hTunnel ? hTunnel : hDial;

    //
    // Init the bytes sent and received with whatever was pushed down to us.
    //

    m_dwInitBytesRead = dwInitBytesRecv;
    m_dwInitBytesWrite = dwInitBytesSend;
}

//+---------------------------------------------------------------------------
//
//	Function:	OpenByPerformanceKey()
//
//	Synopsis:	Open the registry key for Dial-Up Adapter Performance Data
//
// Arguments:   HINSTANCE hInst - The instance to LoadString "Dial-up Adapter"
//              DWORD dwInitBytesRecv - Initial value of TotalBytesRecvd
//              DWORD dwInitBytesSend - Initial value of TotalBytesXmit
//
//	Returns:    TRUE  if succeed
//			    FALSE otherwise
//
//	History:    byao	    07/16/97     Created		                
//              fengsun     10/01/97     Make it a member fuction     
//              nickball    11/14/98     If key exists, use it
//              
//  Note:       This function initialize the connection statistics from the 
//              registry. It is used when the initial bytes sent/recvd are 
//              known as is the case when CMDIAL hands off to CMMON.
//
//----------------------------------------------------------------------------

void CConnStatistics::OpenByPerformanceKey(HINSTANCE hInst, 
                                           DWORD dwInitBytesRecv,
                                           DWORD dwInitBytesSend)
{
    //
    // If available, there's nothing to do here
    //

    if (IsAvailable() || !m_fAdapterSet)
    {
        MYDBGASSERT(FALSE);
        return;

    }   
 
    //
    // We haven't opened the key yet, try to do so
    //

    MYDBGASSERT(!m_hKey);

    if (m_hKey)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwErrCode = RegOpenKeyExU( HKEY_DYN_DATA, 
							  c_pszDialupPerfKey,
							  0, 
							  KEY_ALL_ACCESS, 
							  &m_hKey );

    if (dwErrCode != ERROR_SUCCESS)
    {
    	CMTRACE1(TEXT("OpenDAPPerfKey() RegOpenKeyEx() returned GLE=%u."), dwErrCode);
        m_hKey = NULL;
        return;
    }

    m_dwInitBytesRead = dwInitBytesRecv;
    m_dwInitBytesWrite = dwInitBytesSend;

    GetStatRegValues(hInst);

    //
    // If intial values are -1, reget the initial values.
    //

    if (((DWORD)-1 == dwInitBytesRecv) || ((DWORD)-1 == dwInitBytesSend))
    {  
        //
        // Get the initial statistics info
        //

        if (!GetPerfData(m_dwInitBytesRead, m_dwInitBytesWrite, m_dwBaudRate))
        {
            //
            // No dial-up statistic info
            //
            
            RegCloseKey(m_hKey);
            m_hKey = NULL;

            CMTRACE(TEXT("CConnStatistics::OpenByPerformanceKey() - failed to find stats"));
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::GetStatRegValues
//
// Synopsis:  Helper method, builds the reg value names using the localized 
//            form of the word "Dial-up Adapter".
//
// Arguments: HINSTANCE hInst
//
// Returns:   Nothing
//
// History:   nickball      Created     11/14/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::GetStatRegValues(HINSTANCE hInst)
{
    CMTRACE1(TEXT("CConnStatistics::GetStatRegValues - m_pszTotalBytesRecvd is %s"), m_pszTotalBytesRecvd);

    //
    // bug 149367 The word "Dial-up Adapter" need to be localized.  
    // Load it from resource if no loaded yet
    //

    if (m_pszTotalBytesRecvd == NULL)
    {
        m_pszTotalBytesRecvd = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesRecvd, m_fAdapter2 ? c_pszDialup_2_TotalBytesRcvd : c_pszDialupTotalBytesRcvd);

        m_pszTotalBytesXmit = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesXmit, m_fAdapter2 ? c_pszDialup_2_TotalBytesXmit : c_pszDialupTotalBytesXmit);

        m_pszConnectSpeed = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszConnectSpeed, m_fAdapter2 ? c_pszDialup_2_ConnectSpeed : c_pszDialupConnectSpeed);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::Close
//
// Synopsis:  Stop gathering statistic and close the handle
//
// Arguments: 
//
// Returns:   
//
// History:   Created Header    10/15/97
//
//+----------------------------------------------------------------------------
void CConnStatistics::Close()
{
	if (m_hStatDevice) 
	{
		BOOL bRes = CloseHandle(m_hStatDevice);
        m_hStatDevice = NULL;

#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("CConnStatistics::Close() CloseHandle() failed, GLE=%u."), GetLastError());
        }
#endif
	}

	if (m_hKey)
	{
		DWORD dwErrCode = RegCloseKey(m_hKey);
		CMTRACE1(TEXT("Close() RegCloseKey() returned GLE=%u."), dwErrCode);
        m_hKey = NULL;
	}

    CmFree( m_pszTotalBytesRecvd );
    CmFree( m_pszTotalBytesXmit );
    CmFree( m_pszConnectSpeed );

    m_pszTotalBytesRecvd = m_pszTotalBytesXmit = m_pszConnectSpeed = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::Update
//
// Synopsis:  Gather new statistic information
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Fengsun Created     10/15/97
//
//+----------------------------------------------------------------------------
void CConnStatistics::Update()
{
    if (!IsAvailable())
    {
        MYDBGASSERT(FALSE);
        return;
    }
    
    CTraffic curTraffic;
    curTraffic.dwTime = GetTickCount();

    MYDBGASSERT(curTraffic.dwTime > m_TrafficRing.GetOldest().dwTime);

    if (curTraffic.dwTime == m_TrafficRing.GetOldest().dwTime)
    {
        return;
    }

    //
    // Prefer performace registry data 
    //

    if (OS_NT5)
    {
        RAS_STATS RasStats;
 
        ZeroMemory(&RasStats, sizeof(RasStats));
        RasStats.dwSize = sizeof(RAS_STATS);
        
        DWORD dwRet = m_RasApiDll.RasGetConnectionStatistics(m_hRasConn, &RasStats);

        if (ERROR_SUCCESS == dwRet)
        {
            curTraffic.dwRead   = RasStats.dwBytesRcved;
            curTraffic.dwWrite  = RasStats.dwBytesXmited;
            m_dwBaudRate        = RasStats.dwBps;
            m_dwDuration        = RasStats.dwConnectDuration;
        }
    }
    else
    {
        //
        // Not NT5, try the registry
        //
        
        if (m_hKey)
        {    
            if (!GetPerfData(curTraffic.dwRead, curTraffic.dwWrite, m_dwBaudRate))
            {
                return;
            }
            curTraffic.dwRead -= m_dwInitBytesRead;
            curTraffic.dwWrite -= m_dwInitBytesWrite;
        }
        else
        {
            //
            // Last resort for 9x, try to use stat device 
            //
            
            if (m_hStatDevice)
            {
                if (!GetTapiDeviceStats(curTraffic.dwRead, curTraffic.dwWrite, m_dwBaudRate))
                {
	    	        BOOL bRes = CloseHandle(m_hStatDevice);
                    m_hStatDevice = NULL;

                    if (!bRes)
                    {
                        CMTRACE1(TEXT("CConnStatistics::Update() CloseHandle() failed, GLE=%u."), GetLastError());
                    }
                    return;
                }
            }   
            else
            {
                MYDBGASSERT(m_hStatDevice);
                return;
            }
        }
    }

    //
    // Calculate the avarage between two interval
    //
    const CTraffic& lastTraffic = m_TrafficRing.GetOldest();

    DWORD dwDeltaTime = curTraffic.dwTime - lastTraffic.dwTime;
    m_dwReadPerSecond = ((curTraffic.dwRead - lastTraffic.dwRead)*1000) /dwDeltaTime;
    m_dwWritePerSecond = ((curTraffic.dwWrite - lastTraffic.dwWrite)*1000) /dwDeltaTime;

    m_TrafficRing.Add(curTraffic);
}


//+---------------------------------------------------------------------------
//
//	Function:	GetPerfData
//
//	Synopsis:	Get Performance Data from DUN1.2 performance registry
//
//	Arguments:	
//
//	Returns:	TRUE: succeed
//				FALSE otherwise
//
//	History:	byao	created		7/16/97
//              fengsun change it into a member function 10/14/97
//					
//----------------------------------------------------------------------------
BOOL CConnStatistics::GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const
{
    if (OS_W9X)
    {
        MYDBGASSERT(m_hKey != NULL);   
        MYDBGASSERT(m_pszTotalBytesRecvd && *m_pszTotalBytesRecvd);

        LONG dwErrCode;

        DWORD dwValueSize, dwValueType;
	    DWORD dwValue;

        //
        // "Dial-up Adapter\TotalBytesRecvd"
        //
        dwValueSize = sizeof(DWORD);
	    dwErrCode = RegQueryValueExU(
				    m_hKey,
                    m_pszTotalBytesRecvd,
				    NULL,
				    &dwValueType,
				    (PBYTE)&dwValue,
				    &dwValueSize);

	    if (dwErrCode == ERROR_SUCCESS) 
	    {
		    dwRead = dwValue;
        }
	    else 
	    {
      	    CMTRACE2(TEXT("GetPerfData() RegQueryValueEx() %s failed and returned GLE=%u."),
                m_pszTotalBytesRecvd, dwErrCode);

		    return FALSE;
	    }

        //
        // "Dial-up Adapter\TotalBytesXmit"
        //
	    
	    dwValueSize = sizeof(DWORD);
	    dwErrCode = RegQueryValueExU(
				    m_hKey,
                    m_pszTotalBytesXmit,
				    NULL,
				    &dwValueType,
				    (PBYTE)&dwValue,
				    &dwValueSize);

	    if (dwErrCode == ERROR_SUCCESS) 
	    {
		    dwWrite = dwValue;
        }
	    else 
	    {
      	    CMTRACE2(TEXT("GetPerfData() RegQueryValueEx() %s failed and returned GLE=%u."),
                m_pszTotalBytesXmit, dwErrCode);

		    return FALSE;
	    }

        //
        // "Dial-up Adapter\ConnectSpeed"
        //
	    dwValueSize = sizeof(DWORD);
	    dwErrCode = RegQueryValueExU(
				    m_hKey,
                    m_pszConnectSpeed,
				    NULL,
				    &dwValueType,
				    (PBYTE)&dwValue,
				    &dwValueSize);

	    if (dwErrCode == ERROR_SUCCESS) 
	    {
		    dwBaudRate = dwValue;
        }
	    else 
	    {
            CMTRACE2(TEXT("GetPerfData() RegQueryValueEx() %s failed and returned GLE=%u."), m_pszConnectSpeed, dwErrCode);
		    return FALSE;
	    }
    }

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//	Function:	GetTapiDeviceStats
//
//	Synopsis:	Get Modem Performance Data by DeviceIoControl
//
//	Arguments:	
//
//	Returns:	TRUE: succeed
//				FALSE otherwise
//
//	History:	byao	created		7/16/97
//              fengsun change it into a member function 10/14/97
//					
//----------------------------------------------------------------------------
BOOL CConnStatistics::GetTapiDeviceStats(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const
{
	BOOL bRes;
	DWORD dwRet;

    typedef struct tagAPISTATS {
	    LPVOID hPort;
	    DWORD fConnected;
	    DWORD DCERate;
	    DWORD dwPerfRead;
	    DWORD dwPerfWrite;
    } APISTATS;

	APISTATS ApiStats;

	if (m_hStatDevice) 
	{
		bRes = DeviceIoControl(m_hStatDevice,
							   UNIMODEM_IOCTL_GET_STATISTICS,
							   &ApiStats,
							   sizeof(ApiStats),
							   &ApiStats,
							   sizeof(ApiStats),
							   &dwRet,
							   NULL);
		if (bRes && ApiStats.fConnected) 
		{
            dwRead = ApiStats.dwPerfRead;
            dwWrite = ApiStats.dwPerfWrite;
            dwBaudRate = ApiStats.DCERate;
			return (TRUE);
		}
        
		CMTRACE(TEXT("GetTapiDeviceStats() DeviceIoControl() failed - disabling hStatDevice."));
	}

	return (FALSE);
}




//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::GetDeviceHandle
//
// Synopsis:  Get the TAPI device handle
//
// Arguments: HRASCONN hrcRasConn - the ras connection handle
//
// Returns:   BOOL - TRUE if succeed
//
// History:   fengsun Created Header    10/29/97
//
//+----------------------------------------------------------------------------
BOOL CConnStatistics::GetDeviceHandle(HRASCONN hrcRasConn) 
{
    MYDBGASSERT(hrcRasConn);
    MYDBGASSERT(!m_hStatDevice);

    typedef struct tagDEVICE_PORT_INFO 
    {
	    DWORD dwSize;
	    HANDLE hDevicePort;
	    HLINE hLine;
	    HCALL hCall;
	    DWORD dwAddressID;
	    DWORD dwLinkSpeed;
	    char szDeviceClass[RAS_MaxDeviceType+1];
    } DEVICE_PORT_INFO, *LPDEVICE_PORT_INFO;

    typedef struct tagMacInfo 
    {
	    VARSTRING varstring;
	    HANDLE hCommDevice;
	    char szDeviceClass[1];
    } MacInfo;

    typedef DWORD (WINAPI *RnaGetDevicePortFUNC)(HANDLE,LPDEVICE_PORT_INFO);
	RnaGetDevicePortFUNC pfnRnaGetDevicePort;

    //
    // Load rasapi32.dll and call RnaGetDevicePort
    //
    
    //
    // The destructor of CDynamicLibrary automaticly call FreeLibrary
    //
    CDynamicLibrary RasLib;

    if (!RasLib.Load(TEXT("rasapi32.dll")))
	{
        CMTRACE1(TEXT("GetDeviceHandle() LoadLibrary() failed, GLE=%u."), GetLastError());
		return FALSE;
	}
    
	pfnRnaGetDevicePort = (RnaGetDevicePortFUNC) RasLib.GetProcAddress("RnaGetDevicePort");
	if (!pfnRnaGetDevicePort) 
	{
        CMTRACE1(TEXT("GetDeviceHandle() GetProcAddress() failed, GLE=%u."), GetLastError());
        return FALSE;
	}

	DWORD dwRes;
	DEVICE_PORT_INFO dpi;

	ZeroMemory(&dpi,sizeof(dpi));
	dpi.dwSize = sizeof(dpi);

    dwRes = pfnRnaGetDevicePort(hrcRasConn,&dpi);
	if (dwRes) 
	{
        CMTRACE1(TEXT("GetDeviceHandle() RnaGetDevicePort() failed, GLE=%u."), dwRes);
        return FALSE;
	}

    //
    // Load TAPI32.dll
    // CDynamicLibrary Free the lib on destructor
    //
    CDynamicLibrary LibTapi;

    if (!LibTapi.Load(TEXT("TAPI32.DLL")))
    {
        return FALSE;
    }

    typedef LONG (WINAPI *TapiLineGetIDFUNC)
        (HLINE, DWORD, HCALL, DWORD, LPVARSTRING, LPCSTR);

    //
    //  Always call the Ansi version since this is a Win9x only function
    //
    TapiLineGetIDFUNC pfnTapiLineGetID; 
	pfnTapiLineGetID = (TapiLineGetIDFUNC) LibTapi.GetProcAddress("lineGetID");

    if (pfnTapiLineGetID == NULL)
    {
        MYDBGASSERT(pfnTapiLineGetID != NULL);
        return FALSE;
    }

    LONG lRes;

    CMTRACE3(TEXT("GetDeviceHandle() hDevicePort=0x%x, hLine=0x%x, hCall=0x%x,"), dpi.hDevicePort, dpi.hLine, dpi.hCall);
    CMTRACE3(TEXT("\tdwAddressID=0x%x, dwLinkSpeed=%u, szDeviceClass=%s."), dpi.dwAddressID, dpi.dwLinkSpeed, dpi.szDeviceClass);

    m_dwBaudRate = dpi.dwLinkSpeed;
	
    MacInfo* pmi = NULL;
    DWORD dwSize = sizeof(*pmi);
	
    do
    {
	    CmFree(pmi);
	    pmi = (MacInfo *) CmMalloc(dwSize);
        if (pmi == NULL)
        {
            lRes = ERROR_OUTOFMEMORY;
            break;
        }

	    pmi->varstring.dwTotalSize = dwSize;


	    lRes = pfnTapiLineGetID(dpi.hLine,
					        dpi.dwAddressID,
					        NULL,
					        LINECALLSELECT_ADDRESS,
					        &pmi->varstring,
                            "comm/datamodem");

        dwSize = pmi->varstring.dwNeededSize;
    } while(pmi->varstring.dwNeededSize > pmi->varstring.dwTotalSize);

#ifdef DEBUG
    if (lRes)
    {
        CMTRACE1(TEXT("CConnStatistics::GetDeviceHandle() lineGetID() failed, GLE=%u."), lRes);
    }
#endif

	if (!lRes && pmi != NULL ) 
	{
		m_hStatDevice = pmi->hCommDevice;
	}

	CmFree(pmi);

    return m_hStatDevice != NULL; 
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::AssertValid() const
{
    MYDBGASSERT(m_hKey == NULL || m_hStatDevice == NULL);
    MYDBGASSERT(m_fAdapter2 == TRUE || m_fAdapter2 == FALSE);
    ASSERT_VALID(&m_TrafficRing);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\connstat.h ===
//+----------------------------------------------------------------------------
//
// File:     connstat.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header for the CConnStatistics class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#ifndef CONNSTAT_H
#define CONNSTAT_H

#include <windows.h>
#include <ras.h>
#include <tapi.h>

#include "RasApiDll.h"
#include "SmplRing.h"

//+---------------------------------------------------------------------------
//
//	class CConnStatistics
//
//	Description: A class to collect connection statistics
//               OpenByPerformanceKey() will start gathering data from registry
//               OpenByDevice   will gathering data from TAPI device handle
//
//	History:	fengsun	    10/01/97    Created
//              nickball    03/04/00    Heavily revised for NT5 usage   
//
//----------------------------------------------------------------------------
class CConnStatistics
{
public:
    CConnStatistics();
    ~CConnStatistics();

    void  Update();             // Update the statistics
    DWORD GetBytesPerSecRead() const;
    DWORD GetBytesPerSecWrite() const;
    DWORD GetBytesRead() const;
    DWORD GetBytesWrite() const;
    DWORD GetBaudRate() const;
    DWORD GetDuration() const;

    void Open(HINSTANCE hInst, 
              DWORD dwInitBytesRecv,
              DWORD dwInitBytesSend, 
              HRASCONN hRasDial, 
              HRASCONN hRAsTunnel);

    void Close();        // No more statistic information

    void  SetDialupTwo(BOOL fAdapter2);
    DWORD GetInitBytesRead() const;
    DWORD GetInitBytesWrite() const;

    BOOL IsAvailable() const;  // whether statistic information is available

protected:
    
    void OpenByStatisticsApi(DWORD dwInitBytesRecv,
                             DWORD dwInitBytesSend,
                             HRASCONN hDial, 
                             HRASCONN hTunnel);
                             
    void OpenByPerformanceKey(HINSTANCE hInst, 
                              DWORD dwInitBytesRecv,
                              DWORD dwInitBytesSend); 

    BOOL OpenByDevice(HRASCONN hrcRasConn);

    BOOL GetDeviceHandle(HRASCONN hrcRasConn);

    BOOL GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const;
    BOOL GetTapiDeviceStats(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const;
    void GetStatRegValues(HINSTANCE hInst);

protected:
    struct CTraffic
    {
        DWORD dwRead;
        DWORD dwWrite;
        DWORD dwTime;  // time in minisecond
    };

    enum {STAT_COUNT = 3};

    CSimpleRing<CTraffic, STAT_COUNT> m_TrafficRing;
    
    DWORD m_dwReadPerSecond;
    DWORD m_dwWritePerSecond;
    DWORD m_dwBaudRate;
    DWORD m_dwDuration;


    HANDLE m_hStatDevice;   // the TAPI device handle

    HRASCONN m_hRasConn;    // the RAS connection handle

	// For DUN 1.2, ICM uses perfmon counters for connection status data
	// however, these perfmon counters such as TotalBytesReceived are from last reboot
	// so we need to record the initial data in order to get correct value for this
	// particular connection

    HKEY   m_hKey;          // Performance registry handle
    DWORD  m_dwInitBytesRead;
    DWORD  m_dwInitBytesWrite;

    //
    // Registry names are different for PPP and PPTP
    //
    BOOL m_fAdapter2;
    BOOL m_fAdapterSet;

    //
    // Localized version of 
    // "Dial-up Adapter"\TotalBytesRecvd"
    // "Dial-up Adapter"\TotalBytesXmit"
    // "Dial-up Adapter"\ConnectSpeed"
    //
    LPTSTR m_pszTotalBytesRecvd;
    LPTSTR m_pszTotalBytesXmit;
    LPTSTR m_pszConnectSpeed;

    // The link to rasapi32
    CRasApiDll m_RasApiDll;

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};

//
// Inline functions
//

inline DWORD CConnStatistics::GetInitBytesRead() const
{
    return m_dwInitBytesRead;
}

inline DWORD CConnStatistics::GetInitBytesWrite() const
{
    return m_dwInitBytesWrite;
}

inline void CConnStatistics::SetDialupTwo(BOOL fAdapter2) 
{
    m_fAdapterSet = TRUE;
    m_fAdapter2 = fAdapter2;
}

inline DWORD CConnStatistics::GetBytesPerSecRead() const
{
    return m_dwReadPerSecond;
}

inline DWORD CConnStatistics::GetBytesPerSecWrite() const
{
    return m_dwWritePerSecond;
}

inline DWORD CConnStatistics::GetDuration() const
{
    return OS_NT5 ? (m_dwDuration) : 0; 
}

inline DWORD CConnStatistics::GetBytesRead() const
{
    return m_TrafficRing.GetLatest().dwRead;
}

inline DWORD CConnStatistics::GetBytesWrite() const
{
    return m_TrafficRing.GetLatest().dwWrite;
}

inline BOOL CConnStatistics::IsAvailable() const
{
    return OS_NT5 ? (m_hRasConn && m_RasApiDll.IsLoaded()) : (m_hKey || m_hStatDevice);
}

inline DWORD CConnStatistics::GetBaudRate() const
{
    return m_dwBaudRate;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\idlestat.cpp ===
//+----------------------------------------------------------------------------
//
// File:     IdleStat.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Implementation of class CIdleStatistics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 Fengsun Created    10/01/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "IdleStat.h"

//+---------------------------------------------------------------------------
//
//	CIdleStatistics::Start()
//
//	Synopsis:	Start the idle statistics
//
//	Arguments:	dwThreshold: The idle threshold.  Traffic in a minute Less than 
//                          the threshold is considered idle
//              dwTimeOut: Idle time out in minisecond
//
//	History:	fengsun	created on 10/1/97
//
//----------------------------------------------------------------------------

void CIdleStatistics::Start(DWORD dwThreshold, DWORD dwTimeOut)
{
    MYDBGASSERT(dwTimeOut != 0);

    m_dwThreshold = dwThreshold;
    m_dwTimeOut = dwTimeOut;
    m_dwStartIdleTime = 0;

    m_DataPointsRing.Reset();
}

//+---------------------------------------------------------------------------
//
//	CIdleStatistics::UpdateEveryInterval()
//
//	Synopsis:	This function should be call every Interval with a updated statistic 
//
//	Arguments:	dwTraffic: the updated statistics
//
//
//	History:	fengsun	created on 10/1/97
//
//----------------------------------------------------------------------------
void CIdleStatistics::UpdateEveryInterval(DWORD dwTraffic)
{
    DWORD dwLast = m_DataPointsRing.GetOldest();

    m_DataPointsRing.Add(dwTraffic);

    if (dwLast == 0) // Started less than a minute
    {
        return;
    }

    if (dwTraffic - dwLast > m_dwThreshold)
    {
        //
        // Not idle
        //
        m_dwStartIdleTime = 0;
    }
    else
    {
        if (m_dwStartIdleTime == 0)
		{
			//
			// We are already idle for 1 minute
			//
            m_dwStartIdleTime = GetTickCount() - IDLE_INTERVAL;
		}
    }
}


#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CIdleStatistics::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CIdleStatistics::AssertValid() const
{
    MYDBGASSERT(m_dwTimeOut <10000*60*1000); // less than 10000 minutes
    MYDBGASSERT(m_dwThreshold <= 64*1024);
    ASSERT_VALID(&m_DataPointsRing);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\pwfuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwfuncs.cpp     
//
// Module:   CMMON32.EXE
//
// Synopsis: This source file pound includes the password utility functions, 
//           see common\source\pwutil.cpp for specifics.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   nickball   created         08/04/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//	Please see pnpu\cm\common\source for the actual source here.
//

#include "pwutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\idlestat.h ===
//+----------------------------------------------------------------------------
//
// File:     IdleStat.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Definition for the CIdleStatistics class to handle Idle Disconnect
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#ifndef IDLESTAT_H
#define IDLESTAT_H

#include "SmplRing.h"

//+---------------------------------------------------------------------------
//
//	class CIdleStatistics
//
//	Description: A class to handle idle disconnect
//               After Start(), call UpdateEveryInterval(dwTraffic) for every 
//               interval, every second.  Then use IsIdle() and IsIdleTimeout()
//               to tell whether it is currently idle and whether the idle 
//               timeout is reached.
//               Note, this class will only handle one direction traffic 
//                     (read or write)
//
//	History:	fengsun	Created		10/1/97
//
//----------------------------------------------------------------------------

class CIdleStatistics
{
public:
    CIdleStatistics();

    void Start(DWORD dwThreshold, DWORD dwTimeOut); // start the idle statistics
    void Stop();                                    // Stop the idle statistics
    BOOL IsStarted() const;                     // Whether the idle statistics is started
                                                //   return FALSE if Start() is not called
                                                //   or Stop() is called
    void Reset();                               // reset idle start time to 0

    BOOL IsIdle() const;                        // Whether the connection is currently idle
    BOOL IsIdleTimeout() const;                 // Whether the idle timeout is reached
    void UpdateEveryInterval(DWORD dwTraffic);  // This function is called every second


protected:
    enum {IDLE_INTERVAL = 60L*1000L };		// 1 minute for idle disconnect time period
    enum {IDLE_MONITOR_DATA_POINTS = IDLE_INTERVAL/1000};  // every second

    DWORD m_dwTimeOut;               // Timeout time in miniseconds
    DWORD m_dwThreshold;             // The threshold, if the traffic in last minute
                                     //     is below threshold, it is considered idle
    DWORD m_dwStartIdleTime;         // The start time when the connection is idle, 
                                     //     or 0 if not currently idle

    CSimpleRing<DWORD, IDLE_MONITOR_DATA_POINTS> m_DataPointsRing;  // A 60 point DWORD data array

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};


//
// Inline functions
//

inline CIdleStatistics::CIdleStatistics()
{
    m_dwTimeOut = m_dwThreshold = m_dwStartIdleTime = 0; 
}

inline void CIdleStatistics::Reset()
{
    m_dwStartIdleTime = 0;
    m_DataPointsRing.Reset();
}

inline void CIdleStatistics::Stop()
{
    m_dwTimeOut = 0;
}

inline BOOL CIdleStatistics::IsStarted() const
{
    return m_dwTimeOut != 0;
}

inline BOOL CIdleStatistics::IsIdle() const
{
    return IsStarted() && (m_dwStartIdleTime != 0);
}

inline BOOL CIdleStatistics::IsIdleTimeout() const
{
    return IsIdle() && 
		 ( (GetTickCount() - m_dwStartIdleTime) > m_dwTimeOut);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\monitor.h ===
//+----------------------------------------------------------------------------
//
// File:     Monitor.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Definition of the class CMonitor
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/05/98
//
//+----------------------------------------------------------------------------


#include "ArrayPtr.h"
#include <ras.h>
#include "ConTable.h"

class CCmConnection;
struct tagCmConnectedInfo;  // CM_CONNECTED_INFO
struct tagCmHangupInfo;     // CM_HANGUP_INFO

//+---------------------------------------------------------------------------
//
//  class CMonitor
//
//  Description: Class CMonitor manage all connected CM conaction.  It has 
//              data/functions not specific to a particular connection.  
//              It also manage the communication with 
//              other CM components like CMDIAL.DLL.  
//
//  History:  fengsun Created 1/22/98
//
//----------------------------------------------------------------------------

class CMonitor
{
public:
    CMonitor();
    ~CMonitor();

public:
    //
    // Static public functions, can be called without CMonitor instance
    //

    // Called by ::WinMain
    static int WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR pszCmdLine, int iCmdShow);

    static HINSTANCE GetInstance() {return m_hInst;};
    static HWND GetMonitorWindow() {MYDBGASSERT(m_pThis); return m_pThis->m_hwndMonitor;}
    static void MinimizeWorkingSet();
    static void RestoreWorkingSet();
    static BOOL ConnTableGetEntry(IN LPCTSTR pszEntry, OUT CM_CONNECTION* pCmEntry);
    static void RemoveConnection(CCmConnection* pConnection, BOOL fClearTable);
    static void MoveToReconnectingConn(CCmConnection* pConnection);

protected:

    enum {
        //
        // this message is posted from connection thread to remove a connection
        // from shared table and internal array.
        // We use PostMessage, because all the operation on this array is handled 
        // by monitor thread.  Other wise we need CriticalSection to protect the array.
        // When both array are empty, cmmon exit
        // wParam is one of the value below, lParam is pointer to the connection
        //
        WM_REMOVE_CONNECTION = WM_USER + 1, 
    };

    //
    // wParam for WM_REMOVE_CONNECTION message
    //
    enum {
        REMOVE_CONNECTION,  // Remove from Connected/Reconnecting Array
        MOVE_TO_RECONNECTING    // Move from connected array to reconnecting array
        };    


    HANDLE m_hProcess; // the process handle for the monitor, used to changed working set

    // The Connection Table file mapping
    CConnectionTable m_SharedTable;

    // the invisible monitor window handle message from cmdial32.dll and connection thread
    HWND m_hwndMonitor;

    // Internal array for connected connection
    // Can only be accessed from the monitor thread
    CPtrArray m_InternalConnArray;

    // Array of reconnecting connections
    // Can only be accessed from the monitor thread
    // If both array are down to 0, cmmon exits
    CPtrArray m_ReconnectConnArray;

    //  Called on start up
    //  Open Connection Table
    //  CreateMonitorWindow, SharedTable.SetHwndMonotor()
    BOOL Initialize();
    
    // Called upon exit
    // Close all the connections, terminate all thread
    // Release connection table
    void Terminate();

    // Register a window class and create the invisible monitorwindow
    HWND CreateMonitorWindow();

    // The Monitor window procedure, process all the message
    static LRESULT CALLBACK MonitorWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    //
    // Message handler
    //

    // upon receiving connected message from cmdial32.dll
    // Create the CcmConnection object, add to internal table
    void OnConnected(const tagCmConnectedInfo* pConnectedInfo);


    // Upon hangup request from CMDIAL32.DLL
    // Look up the InternalConnArray for the connection
    // Call pConnection->PostHangupMsg();
    // Hangup is done in connection thread
    void OnHangup(const tagCmHangupInfo* pHangupInfo);

    //
    //  Upon WM_QUERYENDSESSION message, we walk the table of connections
    //  and call pConnection->OnEndSession on them so they will hangup and
    //  clean themselves up.
    //
    BOOL OnQueryEndSession(BOOL fLogOff) const;

    // Upon WM_REMOVE_CONNECTION message posted by connection thread
    void OnRemoveConnection(DWORD dwRequestType, CCmConnection* pConnection);

    // Look up the connection array for a connection by name
    CCmConnection* LookupConnection(const CPtrArray& PtrArray, const TCHAR* pServiceName) const;

    // Look up the connection array for a connection by connection pointer
    int LookupConnection(const CPtrArray& ConnArray, const CCmConnection* pConnection) const;

    // Maintain or drop connections across a Fast User Switch
    BOOL HandleFastUserSwitch(DWORD dwAction);

protected:
    // The exe instance handle
    static HINSTANCE m_hInst;

    // Used by static function MonitorWindowProc
    static CMonitor* m_pThis;

#ifdef DEBUG
    void AssertValid() const; // protected: not safe to call in other thread
#endif
};

inline void CMonitor::MinimizeWorkingSet()
{
    MYDBGASSERT(m_pThis->m_hProcess);
    
    if (m_pThis->m_hProcess)
    {
        SetProcessWorkingSetSize(m_pThis->m_hProcess, 128*1024, 384*1024);
    }
}

inline void CMonitor::RestoreWorkingSet()
{
    MYDBGASSERT(m_pThis->m_hProcess);

    if (m_pThis->m_hProcess)
    {
        SetProcessWorkingSetSize(m_pThis->m_hProcess, 0, 0);
    }
}

inline BOOL CMonitor::ConnTableGetEntry(IN LPCTSTR pszEntry, OUT CM_CONNECTION* pCmEntry)
{
    MYDBGASSERT(pCmEntry);
    MYDBGASSERT(m_pThis);

    return (SUCCEEDED(m_pThis->m_SharedTable.GetEntry(pszEntry, pCmEntry)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\monitor.cpp ===
//+----------------------------------------------------------------------------
//
// File:     Monitor.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Implement class CMonitor
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    01/22/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "Monitor.h"
#include "Connection.h"

// The following blocks are copied from winuser.h and wtsapi32.h (we compile with
// _WIN32_WINNT set to less than 5.01, so we can't get these values via a #include)
//
#include "winuser.h"
#define WM_WTSSESSION_CHANGE            0x02B1
//
#include "WtsApi32.h"
#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8

#include "shelldll.cpp"  // for common source

//
// The monitor invisible window class name
//
static const TCHAR* const c_pszCmMonWndClass = TEXT("CM Monitor Window");

//
// static class data members
//
HINSTANCE CMonitor::m_hInst = NULL;
CMonitor* CMonitor::m_pThis = NULL;

inline CMonitor::CMonitor()
{
    MYDBGASSERT(m_pThis == NULL);
    m_pThis = this;
    m_hProcess = NULL;
}

inline CMonitor::~CMonitor()
{
    MYDBGASSERT(m_InternalConnArray.GetSize() == 0);
    MYDBGASSERT(m_ReconnectConnArray.GetSize() == 0);
    MYDBGASSERT(m_hProcess == NULL);
};

//+----------------------------------------------------------------------------
//
// Function:  WinMain
//
// Synopsis:  WinMain of the exe
//
//
// History:   Created Header    1/22/98
//
//+----------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE , HINSTANCE hPrevInst, LPSTR pszCmdLine, int iCmdShow) 
{

    //
    //  First Things First, lets initialize the U Api's
    //
    if (!InitUnicodeAPI())
    {
        //
        //  Without our U api's we are going no where.  Bail.  Don't show the message if
        //  we are running in the system account since we might be running without a user
        //  present.
        //

        if (!IsLogonAsSystem())
        {
            MessageBox(NULL, TEXT("Cmmon32.exe Initialization Error:  Unable to initialize Unicode to ANSI conversion layer, exiting."),
                       TEXT("Connection Manager"), MB_OK | MB_ICONERROR);
        }

        return FALSE;
    }

#ifdef DEBUG
    
    DWORD cb = 0;
    HWINSTA hWSta = GetProcessWindowStation();
    HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());
    TCHAR szWinStation[MAX_PATH] = {0};
    TCHAR szDesktopName[MAX_PATH] = {0};

    GetUserObjectInformation(hDesk, UOI_NAME, szDesktopName, sizeof(szDesktopName), &cb);
    GetUserObjectInformation(hWSta, UOI_NAME, szWinStation, sizeof(szWinStation), &cb);
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMON32.EXE - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE1(TEXT(" WindowStation Name = %s"), szWinStation);
    CMTRACE1(TEXT(" Desktop Name = %s"), szDesktopName);
    CMTRACE(TEXT("====================================================="));

#endif

    int iRet = CMonitor::WinMain(GetModuleHandleA(NULL), hPrevInst, pszCmdLine, iCmdShow);

#ifdef DEBUG
    
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMON32.EXE - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

#endif

    if (!UnInitUnicodeAPI())
    {
        CMASSERTMSG(FALSE, TEXT("cmmon32.exe WinMain, UnInitUnicodeAPI failed - we are probably leaking a handle"));
    }

    //
    // that's what C runtime does to exit.
    //
    ExitProcess(iRet);
    return iRet;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::WinMain
//
// Synopsis:  Called by ::WinMain
//
// Arguments: Same as WinMain
//            
//
// Returns:   int - return value of the process
//
// History:   Created Header    1/22/98
//
//+----------------------------------------------------------------------------
int CMonitor::WinMain(HINSTANCE hInst, HINSTANCE /*hPrevInst*/, LPSTR /*pszCmdLine*/, int /*iCmdShow*/)
{
    m_hInst = hInst;

    //
    // The only Monitor object exist during the life time of WinMain
    //
    CMonitor theMonitor;

    if (!theMonitor.Initialize())
    {
        CMTRACE(TEXT("theMonitor.Initialize failed"));
        return 0;
    }


    MSG msg;

    //
    // Loop until PostQuitMessage is called,
    // This happens when both connected and reconnecting array are down to 0
    //
    while(GetMessageU(&msg, NULL,0,0))
    {
        TranslateMessage(&msg);
        DispatchMessageU(&msg);
    }

    theMonitor.Terminate();

    CMTRACE(TEXT("The Monitor is terminated"));

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::Initialize
//
// Synopsis:  Initialize before the monitor start the message loop
//
// Arguments: None
//
// Returns:   BOOL - Whether successfully initialized
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
BOOL CMonitor::Initialize()
{
    DWORD dwProcessId = GetCurrentProcessId();
    m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
    MYDBGASSERT(m_hProcess);

    BOOL fStandAlone = FALSE;  // whether cmmon is lauched directly instead of through cmdial

    if (FAILED(m_SharedTable.Open()))
    {
#ifdef DEBUG
        if ( MessageBox(NULL, TEXT("CMMON32.exe has to be launched by CMDIAL. \nContinue testing?"), 
            TEXT("CmMon32 ERROR"), MB_YESNO|MB_ICONQUESTION|MB_SYSTEMMODAL)
             == IDNO)
        {
            return FALSE;
        }

        fStandAlone = TRUE;

        if (FAILED(m_SharedTable.Create()))
#endif
        return FALSE;
    }

#ifdef DEBUG
    //
    // No other CMMON running
    //
    HWND hwndMonitor;
    m_SharedTable.GetMonitorWnd(&hwndMonitor);

    MYDBGASSERT(hwndMonitor == NULL);

#endif

    if ((m_hwndMonitor = CreateMonitorWindow()) == NULL)
    {
        CMTRACE(TEXT("CreateMonitorWindow failed"));
        return FALSE;
    }

    MYVERIFY(SUCCEEDED(m_SharedTable.SetMonitorWnd(m_hwndMonitor)));

    //
    // Register for user changes (XP onwards only)
    //
    if (OS_NT51)
    {
        HINSTANCE hInstLib = LoadLibrary(TEXT("WTSAPI32.DLL"));
        if (hInstLib)
        {
            BOOL (WINAPI *pfnWTSRegisterSessionNotification)(HWND, DWORD);
            
            pfnWTSRegisterSessionNotification = (BOOL(WINAPI *)(HWND, DWORD)) GetProcAddress(hInstLib, "WTSRegisterSessionNotification") ;
            if (pfnWTSRegisterSessionNotification)
            {
                pfnWTSRegisterSessionNotification(m_hwndMonitor, NOTIFY_FOR_ALL_SESSIONS);
            }
            FreeLibrary(hInstLib);
        }
        else
        {
            MYDBGASSERT(0);
        }
    }

    //
    // Tell CmDial32.dll, CmMon is ready to receive message
    //
    HANDLE hEvent = OpenEventU(EVENT_ALL_ACCESS, FALSE, c_pszCmMonReadyEvent);

    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
    else if (!fStandAlone) // if Cmmon was launched stand alone for debugging purposes, cmdial32.dll won't have created the event beforehand so ignore the error.
    {
        DWORD dw = GetLastError();
        CMTRACE1(TEXT("CreateMonitorWindow -- OpenEvent failed, GLE=%d"), dw);
        CMASSERTMSG(FALSE, TEXT("CreateMonitorWindow -- OpenEvent failed.  Please check cmtrace for the specific error code."));
    }

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::Terminate
//
// Synopsis:  Cleanup, before exit
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CMonitor::Terminate()
{
    //
    // All the thread should exited at this point
    //

    if (m_ReconnectConnArray.GetSize() != 0)
    {
        MYDBGASSERT(FALSE);
    }

    if (m_InternalConnArray.GetSize() != 0)
    {
        MYDBGASSERT(FALSE);
    }

    //
    // Unregister for user changes (XP onwards only)
    //
    if (OS_NT51)
    {
        HINSTANCE hInstLib = LoadLibrary(TEXT("WTSAPI32.DLL"));
        if (hInstLib)
        {
            BOOL (WINAPI *pfnWTSUnRegisterSessionNotification)(HWND);
            
            pfnWTSUnRegisterSessionNotification = (BOOL(WINAPI *)(HWND)) GetProcAddress(hInstLib, "WTSUnRegisterSessionNotification") ;
            if (pfnWTSUnRegisterSessionNotification)
            {
                pfnWTSUnRegisterSessionNotification(m_hwndMonitor);
            }
            FreeLibrary(hInstLib);
        }
        else
        {
            MYDBGASSERT(0);
        }
    }

#ifdef DEBUG
    HWND hwndMonitor;
    m_SharedTable.GetMonitorWnd(&hwndMonitor);
    MYDBGASSERT(hwndMonitor == m_hwndMonitor);
#endif

    MYVERIFY(SUCCEEDED(m_SharedTable.SetMonitorWnd(NULL)));
    m_SharedTable.Close();

    CloseHandle(m_hProcess);
    m_hProcess = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::CreateMonitorWindow
//
// Synopsis:  Register and create the invisible monitor window
//
// Arguments: None
//
// Returns:   HWND - The monitor window handle
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HWND CMonitor::CreateMonitorWindow()
{
    //
    // Register a window class and create the window
    //
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));

    wc.lpszClassName = c_pszCmMonWndClass;
    wc.lpfnWndProc = MonitorWindowProc;
    wc.cbSize = sizeof(wc);

    if (!RegisterClassExU( &wc ))
    {
        CMTRACE(TEXT("RegisterClassEx failed"));
        return NULL;
    }

     return CreateWindowExU(0, c_pszCmMonWndClass, TEXT(""), 0, 0, 
                            0, 0, 0, 0, 0, m_hInst, 0);
}


//+----------------------------------------------------------------------------
//
// Function:  CMonitor::HandleFastUserSwitch
//
// Synopsis:  Does any disconnects required when XP does a fast user switch
//
// Arguments: dwAction - a WTS_ value indicating how the user's state has changed
//
// Returns:   BOOL - success or failure
//
// History:   10-Jul-2001   SumitC      Created
//
//+----------------------------------------------------------------------------
BOOL
CMonitor::HandleFastUserSwitch(IN DWORD dwAction)
{
    BOOL    bRet = TRUE;
    BOOL    fDisconnecting = FALSE;

    MYDBGASSERT(OS_NT51);
    if (!OS_NT51)
    {
        goto Cleanup;
    }

    CMTRACE(TEXT("CMonitor::HandleFastUserSwitch - Start"));
    if ((WTS_SESSION_LOCK == dwAction) || (WTS_SESSION_UNLOCK == dwAction))
    {
        CMTRACE(TEXT("CMonitor::HandleFastUserSwitch - Ignore, either WTS_SESSION_LOCK or WTS_SESSION_UNLOCK"));

        // don't do anything for lock and unlock
        goto Cleanup;
    }

    //
    //  See if we are disconnecting
    //

    if ((WTS_CONSOLE_DISCONNECT == dwAction) ||
        (WTS_REMOTE_DISCONNECT == dwAction) ||
        (WTS_SESSION_LOGOFF == dwAction))
    {
        CMTRACE(TEXT("CMonitor::HandleFastUserSwitch - Disconnecting: WTS_CONSOLE_DISCONNECT, WTS_REMOTE_DISCONNECT, WTS_SESSION_LOGOFF"));
        fDisconnecting = TRUE;
    }
    else
    {
        CMTRACE1(TEXT("CMonitor::HandleFastUserSwitch - Stay connected. dwAction = 0x%x"), dwAction);
    }


    
    //
    //  If a session is being disconnected, find out if any of the connected
    //  connectoids are single-user, and disconnect them if so.
    //
    if (fDisconnecting)
    {
        CMTRACE(TEXT("CMonitor::HandleFastUserSwitch -- see if theres anything to disconnect"));

        for (INT i = 0; i < m_InternalConnArray.GetSize(); ++i)
        {
            CCmConnection* pConnection = (CCmConnection*)m_InternalConnArray[i];
            ASSERT_VALID(pConnection);
            
            if (pConnection && (FALSE == pConnection->m_fGlobalGlobal))
            {
                CMTRACE1(TEXT("CMonitor::HandleFastUserSwitch -- found one, disconnecting %s"), pConnection->GetServiceName());
                MYVERIFY(TRUE == pConnection->OnEndSession(TRUE, FALSE));
            }
        }
    }

Cleanup:
    return bRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CMonitor::MonitorWindowProc
//
// Synopsis:  The window procedure of the invisible monitor window
//
// Arguments: HWND hWnd - Window Proc parameters
//            UINT uMsg - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   LRESULT - 
//
// History:   Created Header    2/3/98
//
//+----------------------------------------------------------------------------
LRESULT CALLBACK CMonitor::MonitorWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg)
    {
    case WM_COPYDATA:
        {
            ASSERT_VALID(m_pThis);
            COPYDATASTRUCT* pCopyData = (COPYDATASTRUCT*) lParam;
            MYDBGASSERT(pCopyData);

            switch(pCopyData->dwData) 
            {
            case CMMON_CONNECTED_INFO:
                MYDBGASSERT(pCopyData->cbData >= sizeof(CM_CONNECTED_INFO));
                m_pThis->OnConnected((CM_CONNECTED_INFO*)pCopyData->lpData);
                return TRUE;

            case CMMON_HANGUP_INFO:
                MYDBGASSERT(pCopyData->cbData == sizeof(CM_HANGUP_INFO));
                m_pThis->OnHangup((CM_HANGUP_INFO*)pCopyData->lpData);
                return TRUE;

            default:
                MYDBGASSERT(FALSE);
                return FALSE;
            }
        }

        break;

    case WM_REMOVE_CONNECTION:
        ASSERT_VALID(m_pThis);
        m_pThis->OnRemoveConnection((DWORD)wParam, (CCmConnection*)lParam);
        return TRUE;
        break;

    case WM_QUERYENDSESSION:
        CMTRACE(TEXT("CMonitor::MonitorWindowProc -- Got WM_QUERYENDSESSION message"));
        return m_pThis->OnQueryEndSession((BOOL)lParam);
        break;

    case WM_ENDSESSION:
        CMTRACE(TEXT("CMonitor::MonitorWindowProc -- Got WM_ENDSESSION message"));
        break;

    default:
        break;
    }

    return DefWindowProcU(hWnd, uMsg, wParam, lParam);
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnConnected
//
// Synopsis:  Called upon CMMON_CONNECTED_INFO received from cmdial
//
// Arguments: const CONNECTED_INFO* pConnectedInfo - Info from CmDial
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
void CMonitor::OnConnected(const CM_CONNECTED_INFO* pConnectedInfo)
{
    ASSERT_VALID(this);

    CMTRACE(TEXT("CMonitor::OnConnected"));

    RestoreWorkingSet();

    MYDBGASSERT(pConnectedInfo);

    //
    // Not in the connected table
    //
    MYDBGASSERT(!LookupConnection(m_InternalConnArray, pConnectedInfo->szEntryName));

    // ASSERT in the shared table
    CM_CONNECTION ConnectionEntry;

    if (FAILED(m_SharedTable.GetEntry(pConnectedInfo->szEntryName, &ConnectionEntry)))
    {
        MYDBGASSERT(!"CMonitor::OnConnected: Can not find the connection");
        return;
    }

    CCmConnection* pConnection = new CCmConnection(pConnectedInfo, &ConnectionEntry);
    MYDBGASSERT(pConnection);

    if (pConnection)
    {
        m_InternalConnArray.Add(pConnection);

        pConnection->StartConnectionThread();
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnHangup
//
// Synopsis:  Upon CMMON_HANGUP_INFO request from CMDIAL
//            Post the request to the thread
//
// Arguments: const CM_HANGUP_INFO* pHangupInfo - Info from CmDial
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CMonitor::OnHangup(const CM_HANGUP_INFO* pHangupInfo)
{
    ASSERT_VALID(this);
    RestoreWorkingSet();

    MYDBGASSERT(pHangupInfo);
    MYDBGASSERT(pHangupInfo->szEntryName[0]);

    //
    // Upon hangup request from CMDIAL.DLL
    // Look up the InternalConnArray for the connection
    //

    CCmConnection* pConnection = LookupConnection(m_InternalConnArray,pHangupInfo->szEntryName);

    //
    // CMDIAL post this message regardless whether there is a connection 
    //

    if (!pConnection)
    {
        return;
    }

    pConnection->PostHangupMsg();
    //
    // The connection thread will post a REMOVE_CONNECTION message back when finished
    //
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::LookupConnection
//
// Synopsis:  Look up a connection from connection array by service name
//
// Arguments: const CPtrArray& ConnArray - The array to lookup
//            const TCHAR* pServiceName - The servicename of the connection
//
// Returns:   CCmConnection* - the connection found or NULL
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CCmConnection* CMonitor::LookupConnection(const CPtrArray& ConnArray, const TCHAR* pServiceName) const
{
    for (int i =0; i<ConnArray.GetSize(); i++)
    {
        CCmConnection* pConnection = (CCmConnection*)ConnArray[i];

        ASSERT_VALID(pConnection);

        if (lstrcmpiU(pServiceName, pConnection->GetServiceName()) == 0)
        {
            return pConnection;
        }
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::LookupConnection
//
// Synopsis:  Look up a connection from connection array by connection pointer
//
// Arguments: const CPtrArray& ConnArray - The array to lookup
//            const CCmConnection* pConnection - The connection pointer
//
// Returns:   int - the index to the array, or -1 if not found
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
int CMonitor::LookupConnection(const CPtrArray& ConnArray, const CCmConnection* pConnection) const
{
    ASSERT_VALID(pConnection);

    for (int i =0; i<ConnArray.GetSize(); i++)
    {
        if ((CCmConnection*)ConnArray[i] == pConnection )
        {
            return i;
        }
    }

    return -1;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::RemoveConnection
//
// Synopsis:  Called by connection thread to remove a connection from 
//            connected/reconnecting array
//
// Arguments: CCmConnection* pConnection - The connection to remove
//            BOOL fClearTable - Whter to remove the connection from shared table
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/23/98
//
//+----------------------------------------------------------------------------
void CMonitor::RemoveConnection(CCmConnection* pConnection, BOOL fClearTable)
{
    if (fClearTable)
    {
        //
        // Called in Connection thread.  Operation on m_SharedTable is multi-thread safe
        //
        m_pThis->m_SharedTable.ClearEntry(pConnection->GetServiceName());
    }

    //
    // The internal connection list is not safe to be accessed by multiple thread
    // Message will be processed in monitor thread OnRemoveConnection
    //
    PostMessageU(GetMonitorWindow(), WM_REMOVE_CONNECTION, 
                REMOVE_CONNECTION, (LPARAM)pConnection);
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::MoveToReconnectingConn
//
// Synopsis:  Called by connection thread.  Move a connection from connected 
//            array to reconnecting array
//
// Arguments: CCmConnection* pConnection - The connectio to move
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/23/98
//
//+----------------------------------------------------------------------------
void CMonitor::MoveToReconnectingConn(CCmConnection* pConnection)
{
    //
    // Message will be processed in OnRemoveConnection
    // Note: SendMessage to another thread can cause deadlock, if the reveiving 
    // thread also SendMessage back to this thread. 
    // Use SendMessageTimeout if that is the case
    //
    PostMessageU(GetMonitorWindow(), WM_REMOVE_CONNECTION, 
                 MOVE_TO_RECONNECTING, (LPARAM)pConnection);
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnRemoveConnection
//
// Synopsis:  Called whether a remove connection request is received from 
//            connection thread.  
//            Remove the connection from connected array or reconnecting array
//            Delete it from the shared connectio table
//            If both array are down to 0, exit cmmon
//
// Arguments: DWORD dwRequestType - 
//                  REMOVE_CONNECTION remove the connection from either array
//                  MOVE_TO_RECONNECTING move the connection from connected array 
//                          to reconnecting array
//
//            CCmConnection* pConnection - The connetion to remove or move
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
void CMonitor::OnRemoveConnection(DWORD dwRequestType, CCmConnection* pConnection)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pConnection);

    switch(dwRequestType)
    {
    case REMOVE_CONNECTION:
        {
            int nIndex = LookupConnection(m_InternalConnArray, pConnection);

            if (nIndex != -1)
            {
                //
                // Remove the entry from connected array
                //
                m_InternalConnArray.RemoveAt(nIndex);

            }
            else
            {
                //
                // Remove the entry from reconnecting array
                //
                nIndex = LookupConnection(m_ReconnectConnArray, pConnection);
                MYDBGASSERT(nIndex != -1);

                if (nIndex == -1)
                {
                    break;
                }

                m_ReconnectConnArray.RemoveAt(nIndex);
            }

            delete pConnection;
        }

        break;

    case MOVE_TO_RECONNECTING:
        {
            //
            // Move from connected array to reconnecting array
            //
            int nIndex = LookupConnection(m_InternalConnArray, pConnection);
            MYDBGASSERT(nIndex != -1);

            if (nIndex == -1)
            {
                break;
            }

            m_InternalConnArray.RemoveAt(nIndex);
            m_ReconnectConnArray.Add(pConnection);
        }

        break;

    default:
        MYDBGASSERT(FALSE);
        break;
    }

    //
    // If there are no connections, quit CmMon
    //
    if (m_ReconnectConnArray.GetSize() == 0 && m_InternalConnArray.GetSize() == 0)
    {
        PostQuitMessage(0);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnQueryEndSession
//
// Synopsis:  This message processes the WM_QUERYENDSESSION message by passing
//            it to all the connection threads.
//
// Arguments: Nothing
//
// Returns:   TRUE if successful, FALSE otherwise
//
// History:   quintinb Created      3/18/99
//
//+----------------------------------------------------------------------------
BOOL CMonitor::OnQueryEndSession(BOOL fLogOff) const
{
    //
    // This is the code that was here before fixing bug .NET Server 442193 for fast user switching.
    // This method is called on WM_QUERYENDSESSION. The issue is that at logoff, 
    // the threads weren't getting enough time to finish and thus weren't disconnecting.
    // We need to disconnect for each thread now.
    //

    BOOL bOkayToEndSession = TRUE;
    BOOL bReturn = FALSE;

    for (int i = 0; i < m_InternalConnArray.GetSize(); i++)
    {
        CCmConnection* pCmConnection = (CCmConnection*)m_InternalConnArray[i];

        if (pCmConnection)
        {
            ASSERT_VALID(pCmConnection);
        
            bReturn = pCmConnection->OnEndSession(TRUE, fLogOff); // fEndSession == TRUE
            bOkayToEndSession = bOkayToEndSession && bReturn;
        }
    }

    return bOkayToEndSession;
}


#ifdef DEBUG

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::AssertValid
//
// Synopsis:  Helper function for debug. Assert the object is in a valid state
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CMonitor::AssertValid() const
{
    MYDBGASSERT(IsWindow(m_hwndMonitor));
    MYDBGASSERT(m_pThis == this);

    ASSERT_VALID(&m_InternalConnArray);
    ASSERT_VALID(&m_ReconnectConnArray);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Resource IDs
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CmMon.rc
//
#define IDI_APP                         101
#define IDD_CONNSTAT                    104
#define IDD_CONNSTATNT4                 105
#define IDM_TRAY                        120
#define IDMC_TRAY_STATUS                121
#define IDD_RECONNECT                   123
#define IDC_CONNSTAT_ICON               1038
#define IDC_CONNSTAT_DURATION_DISPLAY   1039
#define IDC_CONNSTAT_SPEED_DISPLAY      1040
#define IDC_CONNSTAT_RECEIVED_DISPLAY   1041
#define IDC_CONNSTAT_SENT_DISPLAY       1042
#define IDC_DISCONNECT                  1043
#define IDC_CONNSTAT_DISCONNECT_DISPLAY 1044
#define IDC_AUTODISC                    1045
#define IDC_DETAILS                     1049
#define IDC_DETAILINFO                  1050
#define IDC_RECONNECT_MSG               1058
#define IDC_CONNSTAT_STATIC_CALL_DURATION 1069
#define IDC_CONNSTAT_STATIC_CONNECT_SPEED 1070
#define IDC_CONNSTAT_STATIC_BYTES_RECEIVED 1071
#define IDC_CONNSTAT_STATIC_BYTES_SENT  1072

//#define IDS_YES                         10010
//#define IDS_NO                          10011
//#define IDS_TRUE                        10012
//#define IDS_FALSE                       10013

#define IDMSG_CONNSPEED                 11054
#define IDMSG_CONNDUR                   11055
#define	IDMSG_CONNCNT					11056
#define IDMSG_CONNCNTRATE               11057
#define	IDMSG_CONNDISCONNECT			11060
#define IDMSG_CONNDISC_STAYONLINE       11061
#define IDMSG_CONNDISC_DISCNOW          11062
#define IDMSG_CONNDISC_OK               11063
#define IDMSG_CONNDISC_DISCONNECT       11064
#define IDMSG_DUR_START                 11065
#define IDMSG_DUR_START2                11066
#define IDMSG_DUR_START3                11067
#define IDMSG_DUR_START4                11068
#define IDMSG_DUR_START5                11069
#define IDMSG_DUR_START6                11070
#define IDMSG_DUR_START7                11071
#define IDMSG_DUR_START8                11072
#define IDMSG_DUR_START9                11073
#define IDMSG_DUR_START10               11074
#define IDMSG_DUR_START11               11075
#define IDMSG_DUR_START12               11076
#define IDMSG_DUR_START13               11077
#define IDMSG_DUR_START14               11078
#define IDMSG_DUR_START15               11079
#define IDMSG_DUR_START16               11080
#define IDMSG_DUR_START17               11081
#define IDMSG_DUR_START18               11082
#define IDMSG_DUR_START19               11083
#define IDMSG_DUR_START20               11084
#define IDMSG_DUR_START21               11085
#define IDMSG_DUR_START22               11086
#define IDMSG_DUR_START23               11087
#define IDMSG_DUR_START24               11088
#define IDMSG_DUR_START25               11089
#define IDMSG_DUR_START26               11090
#define IDMSG_DUR_START27               11091
#define IDMSG_RECONNECT                 11094
#define IDS_REG_DIALUP_ADAPTER          11208

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        125
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\reconnectdlg.h ===
//+----------------------------------------------------------------------------
//
// File:     ReconnectDlg.h
//
// Module:	 CMMON32.EXE
//
// Synopsis: Define the reconnect dialog class CReconnectDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fegnsun Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef RECONNECTDLG_H
#define RECONNECTDLG_H

#include <windows.h>
//#include "ModalDlg.h"
#include "ModelessDlg.h"

class CCmConnection;
 
//+---------------------------------------------------------------------------
//
//	class CReconnectDlg
//
//	Description: The class for reconnect prompt dialog
//
//	History:	fengsun	Created		2/17/98
//
//----------------------------------------------------------------------------
class CReconnectDlg : public CModelessDlg
{
public:
    HWND Create(HINSTANCE hInstance, HWND hWndParent,
        LPCTSTR lpszReconnectMsg, HICON hIcon);

protected:
    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();    // WM_INITDIALOG

    static const DWORD m_dwHelp[]; // help id pairs
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\reconnectdlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ReconnectDlg.h
//
// Module:	 CMMON32.EXE
//
// Synopsis: implement the reconnect dialog class CReconnectDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fegnsun Created    02/17/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ReconnectDlg.h"
#include "Connection.h"
#include "resource.h"

// Question: Do we need help for reconnect dialog
const DWORD CReconnectDlg::m_dwHelp[] = {0,0};




//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::Create
//
// Synopsis:  Create the reconnect modeless dialog
//
// Arguments: HINSTANCE hInstance - the instance for the dialog resource
//            HWND hWndParent - The parant window
//            LPCTSTR lpszReconnectMsg - The reconnect message on the dialog
//            HICON hIcon - The icon on the dialog
//
// Returns:   HWND - The reconnect dialog window handle
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HWND CReconnectDlg::Create(HINSTANCE hInstance, HWND hWndParent,
    LPCTSTR lpszReconnectMsg, HICON hIcon)
{
    MYDBGASSERT(lpszReconnectMsg);
    MYDBGASSERT(hIcon);

    if (!CModelessDlg::Create(hInstance, IDD_RECONNECT, hWndParent)) 
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

	UpdateFont(m_hWnd);
	SetDlgItemTextU(m_hWnd,IDC_RECONNECT_MSG, lpszReconnectMsg);
	SendDlgItemMessageU(m_hWnd,IDC_CONNSTAT_ICON,STM_SETIMAGE,
						IMAGE_ICON,(LPARAM) hIcon);

    SetWindowPos(m_hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);

    return m_hWnd;
}

//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::OnOK
//
// Synopsis:  called when OK button is clicked
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CReconnectDlg::OnOK()
{
    //
    // The connection thread will kill the reconnect dialog and call cmdial to reconnect
    //
    PostThreadMessageU(GetCurrentThreadId(), CCmConnection::WM_CONN_EVENT, 
        CCmConnection::EVENT_RECONNECT, 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::OnInitDialog
//
// Synopsis:  Called when dialog is intialized and WM_INITDIALOG is received.
//
// Arguments: None
//
// Returns:   BOOL - FALSE is focus was assigned to a control.
//
// History:   nickball      03/22/00    Created 
//
//+----------------------------------------------------------------------------
BOOL CReconnectDlg::OnInitDialog()
{
    SetForegroundWindow(m_hWnd);        
    Flash();
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::OnCancel
//
// Synopsis:  Called when cancel button is clicked
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CReconnectDlg::OnCancel()
{
    //
    // The connection thread will kill the reconnect dialog and quit
    //
    PostThreadMessageU(GetCurrentThreadId(), CCmConnection::WM_CONN_EVENT,
        CCmConnection::EVENT_USER_DISCONNECT, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\rasapidll.h ===
//+----------------------------------------------------------------------------
//
// File:     RasApiDll.h	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Dynamicly link to RASAPI32.dll
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    03/12/98
//
//+----------------------------------------------------------------------------

#ifndef RASAPIALL_H
#define RASAPIALL_H

#include <ras.h>
#include "DynamicLib.h"

//
// The statistics structure used with RasGetConnectionStatistics API
//   

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;

//+---------------------------------------------------------------------------
//
//	class :	CRasApiDll
//
//	Synopsis:	A class to dynamic link to RASAPI32.DLL, derived from CDynamicLibrary
//              Calling any of the RAS function will load the DLL
//
//	History:	fengsun created		3/12/98
//
//----------------------------------------------------------------------------

class CRasApiDll : public CDynamicLibrary
{
public: 
    CRasApiDll();
    DWORD RasGetConnectStatus(HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus);
    
    DWORD RasConnectionNotification(HRASCONN hrasconn,  
                                    HANDLE hEvent,
                                    DWORD dwFlags);
    
    DWORD RasGetConnectionStatistics(HRASCONN hrasconn, PRAS_STATS pRasStats);

    BOOL Load();

    BOOL HasRasConnectionNotification() const;

protected:
    typedef DWORD (WINAPI* RasGetConnectStatusFUNC)(HRASCONN, LPRASCONNSTATUS);
    typedef DWORD (WINAPI* RasConnectionNotificationFUNC)(HRASCONN hrasconn,  
                                                          HANDLE hEvent,
                                                          DWORD dwFlags);
    typedef DWORD (WINAPI* RasGetConnectionStatisticsFUNC) (HRASCONN, PRAS_STATS);


    RasGetConnectStatusFUNC         m_pfnRasGetConnectStatus;
    RasConnectionNotificationFUNC   m_pfnRasConnectionNotification;
    RasGetConnectionStatisticsFUNC  m_pfnRasGetConnectionStatistics;
};


//
// Constructor
//
inline CRasApiDll::CRasApiDll() : CDynamicLibrary()
{
    m_pfnRasGetConnectStatus = NULL;
    m_pfnRasConnectionNotification = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::Load
//
// Synopsis:  Load RASAPI32.dll
//
// Arguments: None
//
// Returns:   BOOL - TRUE if load successfully
//
// History:   fengsun Created Header    3/12/98
//
//+----------------------------------------------------------------------------
inline 
BOOL CRasApiDll::Load()
{
    if(IsLoaded())
    {
        return TRUE;
    }

    if (!CDynamicLibrary::Load(TEXT("RASAPI32.DLL")))
    {
        return FALSE;
    }

    LPSTR pszGetConnectStatusFuncName;
    LPSTR pszConnectionNotificationFuncName;
    LPSTR pszGetConnectionStatisticsFuncName;

    if (OS_NT)
    {
        pszGetConnectStatusFuncName = "RasGetConnectStatusW";
        pszConnectionNotificationFuncName = "RasConnectionNotificationW";
    }
    else
    {
        pszGetConnectStatusFuncName = "RasGetConnectStatusA";
        pszConnectionNotificationFuncName = "RasConnectionNotificationA";
    }

    m_pfnRasGetConnectStatus = (RasGetConnectStatusFUNC)CDynamicLibrary::GetProcAddress
                    (pszGetConnectStatusFuncName);
    
    m_pfnRasConnectionNotification = (RasConnectionNotificationFUNC)CDynamicLibrary::GetProcAddress
                    (pszConnectionNotificationFuncName);

    //
    // Only on NT5, we load the statistics retrieval API
    //

    if (OS_NT5)
    {
        pszGetConnectionStatisticsFuncName = "RasGetConnectionStatistics";

        m_pfnRasGetConnectionStatistics = (RasGetConnectionStatisticsFUNC)CDynamicLibrary::GetProcAddress
                    (pszGetConnectionStatisticsFuncName);
    }
    
    MYDBGASSERT(m_pfnRasGetConnectStatus);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::RasGetConnectionStatistics
//
// Synopsis:  Call the ras function RasGetConnectionStatistics.
//            Load the Dll, if not loaded yet
//
// Arguments: HRASCONN hrasconn     - Same as ::RasGetConnectStatus
//            RAS_STATS RasStats    - The Ras statistics
//
// Returns:   DWORD - Same as ::RasGetConnectStatus
//
// History:   nickball  03/04/00    Created. Cloned from RasGetConnectStatus
//
//+----------------------------------------------------------------------------
inline 
DWORD CRasApiDll::RasGetConnectionStatistics(HRASCONN hRasConn, PRAS_STATS pRasStats)
{
    DWORD dwReturn = ERROR_INVALID_FUNCTION;
    MYDBGASSERT(hRasConn);
    MYDBGASSERT(pRasStats);

    MYVERIFY(Load());

    if (IsLoaded() && m_pfnRasGetConnectionStatistics)
    {
        return (m_pfnRasGetConnectionStatistics(hRasConn, pRasStats));
    }

    return ERROR_INVALID_FUNCTION;
}

//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::RasGetConnectStatus
//
// Synopsis:  Call the ras function RasGetConnectStatus.
//            Load the Dll, if not loaded yet
//
// Arguments: HRASCONN hrasconn - Same as ::RasGetConnectStatus
//            LPRASCONNSTATUSA lprasconnstatus - Same as ::RasGetConnectStatus
//
// Returns:   DWORD - Same as ::RasGetConnectStatus
//
// History:   fengsun Created Header    3/12/98
//
//+----------------------------------------------------------------------------
inline 
DWORD CRasApiDll::RasGetConnectStatus(HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus)
{
    DWORD dwReturn = ERROR_INVALID_FUNCTION;
    MYDBGASSERT(hrasconn);
    MYDBGASSERT(lprasconnstatus);

    MYVERIFY(Load());

    if (IsLoaded() && m_pfnRasGetConnectStatus != NULL)
    {
        if (OS_NT)
        {
            dwReturn = m_pfnRasGetConnectStatus(hrasconn, lprasconnstatus);
        }
        else
        {
            RASCONNSTATUSA RasConnStatusA;
            ZeroMemory(&RasConnStatusA, sizeof(RASCONNSTATUSA));
            RasConnStatusA.dwSize = sizeof(RASCONNSTATUSA);

            //
            // We cast this here because we only have one function declaration. We should
            // probably have one for Unicode and one for ANSI but for now the cast works 
            // fine.
            //
            
            dwReturn = m_pfnRasGetConnectStatus(hrasconn, (LPRASCONNSTATUS)&RasConnStatusA); 

            if (ERROR_SUCCESS == dwReturn)
            {
                lprasconnstatus->rasconnstate = RasConnStatusA.rasconnstate;
                lprasconnstatus->dwError = RasConnStatusA.dwError;
                SzToWz(RasConnStatusA.szDeviceType, lprasconnstatus->szDeviceType, RAS_MaxDeviceType);
                SzToWz(RasConnStatusA.szDeviceName, lprasconnstatus->szDeviceName, RAS_MaxDeviceName);
            }
        }    
    }

    return dwReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::RasConnectionNotification
//
// Synopsis:  Call the ras function RasConnectionNotification.
//            Load the Dll, if not loaded yet
//
// Arguments: HRASCONN hrasconn - Same as ::RasConnectionNotification
//            HANDLE hEvent - Same as ::RasConnectionNotification
//            DWORD dwFlags - Same as ::RasConnectionNotification
//
// Returns:   DWORD - Same as ::RasConnectionNotification
//
// History:   fengsun Created Header    3/12/98
//
//+----------------------------------------------------------------------------
inline
DWORD CRasApiDll::RasConnectionNotification(HRASCONN hrasconn,  
                                            HANDLE hEvent,
                                            DWORD dwFlags)
{
    MYDBGASSERT(hrasconn);
    MYDBGASSERT(hEvent);
    MYDBGASSERT(dwFlags);

    MYVERIFY(Load());

    if(!IsLoaded() || m_pfnRasConnectionNotification == NULL)
    {
        return ERROR_INVALID_FUNCTION;
    }

    return m_pfnRasConnectionNotification(hrasconn, hEvent, dwFlags);
}


//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::HasRasConnectionNotification
//
// Synopsis:  Whether the dll has the function RasConnectionNotification()
//            which is not available for WIN9x w/ DUN1.0
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the function is avalaible
//
// History:   fengsun Created Header    3/13/98
//
//+----------------------------------------------------------------------------
inline
BOOL CRasApiDll::HasRasConnectionNotification() const
{
    MYDBGASSERT(m_hInst);

    return m_pfnRasConnectionNotification != NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\statusdlg.h ===
//+----------------------------------------------------------------------------
//
// File:     statusdlg.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header for the CStatusDlg Class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#ifndef STATUSDLG_H
#define STATUSDLG_H

#include <windows.h>
#include "ModelessDlg.h"

class CCmConnection;

//+---------------------------------------------------------------------------
//
//	class CStatusDlg
//
//	Description: The class for both Status dialog and count down dialog
//
//	History:	fengsun	Created		2/17/98
//
//----------------------------------------------------------------------------
class CStatusDlg : public CModelessDlg
{
public:
    CStatusDlg(CCmConnection* pConnection);
    HWND Create(HINSTANCE hInstance, HWND hWndParent,
        LPCTSTR lpszTitle, HICON hIcon);


    // Call RasMonitorDlg
    // Shall CM display the new NT5 status dialog
    void ChangeToCountDown(); // change to count down dialog box
    void ChangeToStatus();    // Change to Status dialog box
    void UpdateStatistics();  // Update statistics for Win95
    void UpdateCountDown(DWORD dwDuration, DWORD dwSeconds);
    void UpdateStats(DWORD dwBaudRate, DWORD dwBytesRead, DWORD dwBytesWrite,
                 DWORD dwByteReadPerSec, DWORD dwByteWritePerSec);
    void UpdateDuration(DWORD dwSeconds);
    void KillRasMonitorWindow(); 
    void BringToTop();
    void DismissStatusDlg();
    
    virtual BOOL OnInitDialog();    // WM_INITDIALOG

protected:
    // Status or count down dialog box. TRUE means currently it is displaying status
    BOOL m_fDisplayStatus;  

    // Pointer to the connection to notify event
    CCmConnection* m_pConnection;

    // Whether window is visible when it is changed into count down
    // Need to restore the previous visible state when "StayOnLine"
    BOOL m_fStatusWindowVisible;

    //
    // registered hwnd msg for IE4 explorer.  This msg is broadcasted 
    // when the taskbar comes up.
    //
    UINT m_uiHwndMsgTaskBar;

    void OnDisconnect();
    virtual void OnOK();
    virtual void OnCancel();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );
    HWND GetRasMonitorWindow();
    static BOOL CALLBACK KillRasMonitorWndProc(HWND hwnd,  LPARAM lParam);


	static const DWORD m_dwHelp[]; // help id pairs

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};

inline void CStatusDlg::BringToTop()
{
    //
    // On NT, we should bring the RAS monitor window to top, if exist
    //
    ShowWindow(m_hWnd, SW_SHOW);
	EnableWindow(m_hWnd, TRUE);

    HWND hwndTop = GetLastActivePopup(m_hWnd);
    MYDBGASSERT(hwndTop);

    SetForegroundWindow(hwndTop);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\rnawnd.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 rnawnd.cpp 
//
// Module:	 CMMON32.EXE
//
// Synopsis: Kill the DUN Reconnect dialog for Win95 Gold
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 quintinb       Created header      08/17/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include <process.h>

struct RECONNECT_PARAM 
{
	HANDLE hEvent;
	BOOL *pbConnLost;
};

static unsigned long __stdcall ZapRNAReconnectThread(void *pvParam) 
{
	RECONNECT_PARAM* pParam = (RECONNECT_PARAM*) pvParam;
	HANDLE hEvent = pParam->hEvent;
	BOOL *pbConnLost = pParam->pbConnLost;
	long lRes;
	BOOL bRes;
	HMODULE hLibrary;
	HRSRC hrsrcDlg;
	HGLOBAL hgDlg;
	LPDLGTEMPLATE pDlg;
	WCHAR szTmp[MAX_PATH];
	unsigned uRes = 1;
	HWND hwndRNA;
	HLOCAL hRes;

    CMTRACE(TEXT("ZapRNAReconnectThread()"));

	hRes = LocalFree(pvParam);
#ifdef DEBUG
    if (hRes)
    {
        CMTRACE1(TEXT("ZapRNAReconnectThread() LocalFree() failed, GLE=%u."), GetLastError());
    }
#endif

	szTmp[0] = 0;
	
    hLibrary = LoadLibraryExA("rnaapp.exe", NULL, LOAD_LIBRARY_AS_DATAFILE);
		
    if (hLibrary) 
    {
	hrsrcDlg = FindResourceExU(hLibrary, TEXT("#1010"), RT_DIALOG, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

		if (hrsrcDlg)
        {
			hgDlg = LoadResource(hLibrary, hrsrcDlg);
			if (hgDlg) 
            {
				pDlg = (LPDLGTEMPLATE) LockResource(hgDlg);
				
				if (pDlg) 
                {
					LPWSTR pszTmp = (LPWSTR) (pDlg + 1);

					switch (*pszTmp) 
                    {

						case 0x0000:
							pszTmp++;
							break;

						case 0xffff:
							pszTmp += 2;
							break;

						default:
							pszTmp += lstrlenU(pszTmp) + 1;
							break;
					}
					switch (*pszTmp) 
                    {

						case 0x0000:
							pszTmp++;
							break;

						case 0xffff:
							pszTmp += 2;
							break;

						default:
							pszTmp += lstrlenU(pszTmp) + 1;
					}

                    lstrcpyU(szTmp, pszTmp);
				}
                else
                {
                    CMTRACE(TEXT("ZapRNAReconnectThread() LockResource() failed."));
                }
			}
            else
            {
    			CMTRACE1(TEXT("ZapRNAReconnectThread() LoadResource() failed, GLE=%u."), GetLastError());        
            }
		}
        else
        {
            CMTRACE1(TEXT("ZapRNAReconnectThread() FindResource() failed, GLE=%u."), GetLastError());
        }

		bRes = FreeLibrary(hLibrary);

#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectThread() FreeLibrary() failed, GLE=%u."), GetLastError());        
        }
#endif

	}
    else
    {
        CMTRACE1(TEXT("ZapRNAReconnectThread() LoadLibraryEx() failed, GLE=%u."), GetLastError());
    }

	if (szTmp[0]) 
    {
		CMTRACE1(TEXT("ZapRNAReconnectThread() is watching for a window named %s."), szTmp);

		while (1) 
        {
			lRes = WaitForSingleObject(hEvent,750);
			
            if (lRes != WAIT_TIMEOUT) 
            {
#ifdef DEBUG
                if (WAIT_FAILED == lRes)
                {
                    CMTRACE1(TEXT("ZapRNAReconnectThread() WaitForSingleObject() failed, GLE=%u."), 
                        GetLastError());
                }
                else if (WAIT_OBJECT_0 == lRes)
                {
                    CMTRACE(TEXT("ZapRNAReconnectThread() was told to die."));                
                }
#endif
				break;
			}

			hwndRNA = FindWindowExU(NULL, NULL, WC_DIALOG, szTmp);

			if (hwndRNA) 
            {
				CMTRACE(TEXT("ZapRNAReconnectThread() is canceling the reconnect dialog."));

				PostMessageA(hwndRNA,WM_COMMAND,IDCANCEL,0);
				
                if (pbConnLost) 
                {
					*pbConnLost = TRUE;
				}
			}
		}
	}

	bRes = CloseHandle(hEvent);

#ifdef DEBUG

	if (!bRes)
    {
        CMTRACE1(TEXT("ZapRNAReconnectThread() CloseHandle() failed, GLE=%u."), GetLastError());
    }
    
    CMTRACE1(TEXT("ZapRNAReconnectThread() is exiting with uRes=%u."), uRes);
#endif

    return (uRes);
}


HANDLE ZapRNAReconnectStart(BOOL *pbConnLost) 
{
	HANDLE hEvent;
	BOOL bRes;
	HANDLE hThread = NULL;
	unsigned long tidThread;
	RECONNECT_PARAM* pParam = NULL;
	HLOCAL hRes;

    CMTRACE(TEXT("ZapRNAReconnectStart()"));

    //
    // Not quite right for multiple connections.  This is unlike to happen for Win95 Gold w DUN1.0
    //
    hEvent = CreateEventA(NULL, FALSE, FALSE, "IConnMgr ZRRS Event");

#ifdef DEBUG
    if (!hEvent)
    {
        CMTRACE1(TEXT("ZapRNAReconnectStart() CreateEvent() failed, GLE=%u."), GetLastError());
    }
    else if (hEvent && (ERROR_ALREADY_EXISTS == GetLastError()))
    {
        CMTRACE(TEXT("ZapRNAReconnectStart() ZapRNAReconnectThread() is already running."));
    }
#endif
    
    if (hEvent && (GetLastError() != ERROR_ALREADY_EXISTS)) 
    {
		pParam = (RECONNECT_PARAM*) LocalAlloc(LPTR,sizeof(*pParam));

		if (pParam) 
        {
			pParam->hEvent = hEvent;
			pParam->pbConnLost = pbConnLost;
			hThread = (HANDLE) CreateThread(NULL,0,ZapRNAReconnectThread,pParam,0,&tidThread);

#ifdef DEBUG
            if (!hThread)
            {
                CMTRACE1(TEXT("ZapRNAReconnectStart() CreateThread() failed, GLE=%u."), GetLastError());
            }
#endif
		}
	}

	if (!hThread) 
    {
		bRes = CloseHandle(hEvent);

#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStart() CloseHandle() failed, GLE=%u."), GetLastError());
        }
#endif

		if (pParam) 
        {
			hRes = LocalFree(pParam);

#ifdef DEBUG
            if (hRes)
            {
                CMTRACE1(TEXT("ZapRNAReconnectStart() LocalFree() failed, GLE=%u."), GetLastError());
            }
#endif
		}
	}

    CMTRACE1(TEXT("ZapRNAReconnectStart() is exiting with hThread=%u."), hThread);

	return hThread;
}


void ZapRNAReconnectStop(HANDLE hThread) 
{
	HANDLE hEvent;
	BOOL bRes;
	long lRes;

    CMTRACE(TEXT("ZapRNAReconnectStop()"));
    MYDBGASSERT(hThread);

	hEvent = OpenEventA(EVENT_MODIFY_STATE, FALSE, "IConnMgr ZRRS Event");

	if (hEvent) 
    {
		bRes = SetEvent(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStop() SetEvent() failed, GLE=%u."), GetLastError());
        }
#endif

		bRes = CloseHandle(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStop() CloseHandle(hEvent) failed, GLE=%u."), GetLastError());
        }
#endif

		lRes = WaitForSingleObject(hThread,2000);
#ifdef DEBUG
        if (WAIT_OBJECT_0 != lRes)
        {
            CMTRACE2(TEXT("ZapRNAReconnectStop() WaitForSingleObject() returns %u, GLE=%u."), 
                lRes, (WAIT_FAILED == lRes) ? GetLastError() : 0);
        }
#endif

		bRes = CloseHandle(hThread);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStop() CloseHandle(hThread) failed, GLE=%u."), GetLastError());
        }
#endif
	}
    else
    {
        CMTRACE1(TEXT("ZapRNAReconnectStop() OpenEvent() failed, GLE=%u."), GetLastError());
    }

    CloseHandle(hThread);

    CMTRACE1(TEXT("ZapRNAReconnectStop() is exiting."), hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\statusdlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:    StatusDlg.cpp
//
// Module:	 CMMON32.EXE
//
// Synopsis: Implement status/count-down dialog class CStatusDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 ?????      Created    02/20/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "StatusDlg.h"
#include "Connection.h"
#include "resource.h"
#include "Monitor.h"
#include "cmmgr32.h" // help IDs
#include "cm_misc.h"
#include "resource.h"

//
// Map of control id to help id
//
const DWORD CStatusDlg::m_dwHelp[] = {IDOK,           IDH_OK_CONNECTED,
                                      IDC_DISCONNECT, IDH_STATUS_DISCONNECT,
                                      IDC_DETAILS,    IDH_DETAILS,
				                      0,0};

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::CStatusDlg
//
// Synopsis:  Constructor
//
// Arguments: CCmConnection* pConnection - The connection to notify event
//
// Returns:   Nothing
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
CStatusDlg::CStatusDlg(CCmConnection* pConnection):CModelessDlg(m_dwHelp)
{
    m_pConnection = pConnection;
    m_fDisplayStatus = FALSE;
    m_fStatusWindowVisible = FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::Create
//
// Synopsis:  Create a modeless status dialog
//
// Arguments: HINSTANCE hInstance - Instance of the resource
//            HWND hWndParent - Parent window
//            LPCTSTR lpszTitle - Dialog window title
//            HICON hIcon - Dialog icon
//
// Returns:   HWND - The dialog window handle
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
HWND CStatusDlg::Create(HINSTANCE hInstance, HWND hWndParent,
    LPCTSTR lpszTitle, HICON hIcon)
{
    MYDBGASSERT(lpszTitle);
    MYDBGASSERT(hIcon);

    DWORD dwStatusDlgId = OS_NT4 ? IDD_CONNSTATNT4 : IDD_CONNSTAT;

    if (!CModelessDlg::Create(hInstance, dwStatusDlgId, hWndParent)) 
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

	EnableWindow(m_hWnd, FALSE);
	UpdateFont(m_hWnd);
	SetWindowTextU(m_hWnd,lpszTitle);
	SendDlgItemMessageA(m_hWnd,IDC_CONNSTAT_ICON,STM_SETIMAGE,
						IMAGE_ICON,(LPARAM) hIcon);

	MakeBold(GetDlgItem(m_hWnd,IDC_CONNSTAT_DISCONNECT_DISPLAY), FALSE);

    m_uiHwndMsgTaskBar = RegisterWindowMessageA("TaskbarCreated");

    return m_hWnd;
}
//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnInitDialog
//
// Synopsis:  Called when dialog is intialized and WM_INITDIALOG is received.
//
// Arguments: None
//
// Returns:   BOOL - FALSE is focus was assigned to a control.
//
// History:   nickball      03/22/00    Created 
//
//+----------------------------------------------------------------------------
BOOL CStatusDlg::OnInitDialog()
{
    SetForegroundWindow(m_hWnd);                        
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnOtherCommand
//
// Synopsis:  Process WM_COMMAND other than IDOK and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of the message
//            LPARAM - 
//
// Returns:   DWORD - Return value of the message
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
DWORD CStatusDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
	switch (LOWORD(wParam)) 
    {
        case IDC_DISCONNECT:
            KillRasMonitorWindow();
            //
            // The thread message loop will handle thread message
	        //
            PostThreadMessageU(GetCurrentThreadId(), CCmConnection::WM_CONN_EVENT,
                CCmConnection::EVENT_USER_DISCONNECT, 0);
			break;

        case IDC_DETAILS:
            m_pConnection->OnStatusDetails();
            break;

        case IDMC_TRAY_STATUS:
            //
            //  Don't show the UI if we are at Winlogon unless we are on NT4
            //
            if (!IsLogonAsSystem() || OS_NT4)
            {
                BringToTop();
            }
            break;

        case WM_DESTROY:
            ReleaseBold(GetDlgItem(m_hWnd, IDC_CONNSTAT_DISCONNECT_DISPLAY));
            break;

        default:
            //
            // Should be message comes from additional tray icon menu item
            //
            if (LOWORD(wParam) >= CCmConnection::IDM_TRAYMENU && 
                LOWORD(wParam) <= (CCmConnection::IDM_TRAYMENU + 100))
            {
                m_pConnection->OnAdditionalTrayMenu(LOWORD(wParam));
            }
            break;
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnOtherMessage
//
// Synopsis:  Process  message other than WM_COMMAND and WM_INITDIALOG
//
// Arguments: UINT uMsg - the message
//            WPARAM wParam - wParam of the message
//            LPARAM lParam - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
DWORD CStatusDlg::OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
    case CCmConnection::WM_TRAYICON:
        return m_pConnection->OnTrayIcon(wParam, lParam);

    case WM_TIMER:
        // CMMON does not use WM_TIMER
        MYDBGASSERT(0);
        return 0;

    case WM_SHOWWINDOW:
        if (wParam)  //fShow == TRUE
        {
            //
            // Statistics is not updated if window is invisible.
            // Force a update of statistics now.
            // 
            m_pConnection->StateConnectedOnTimer();
        }
        break;

    default:
        if (uMsg == m_uiHwndMsgTaskBar && !m_pConnection->IsTrayIconHidden())
        {
            //
            // we need to re-add the trayicon
            //
            m_pConnection->ReInstateTrayIcon();
        }
    break;
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnCancel
//
// Synopsis:  Virtual function. Process WM_COMMAND IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::OnCancel()
{
    //
    // Even through, the status dialog does not have a cancel button, this message 
    // is send when user click Esc, or close from system menu
    //

    //
    // As if OK/StayOnLine is clicked
    //
    OnOK();
}


//+---------------------------------------------------------------